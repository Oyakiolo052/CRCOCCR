Pull,Path,Diff_hunk,Comment
14,tools/releasing/create_release_branch.sh,"@@ -0,0 +1,59 @@
+#!/usr/bin/env bash
+
+#
+# Licensed to the Apache Software Foundation (ASF) under one or more
+# contributor license agreements.  See the NOTICE file distributed with
+# this work for additional information regarding copyright ownership.
+# The ASF licenses this file to You under the Apache License, Version 2.0
+# (the ""License""); you may not use this file except in compliance with
+# the License.  You may obtain a copy of the License at
+#
+#    http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an ""AS IS"" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+##
+## Variables with defaults (if not overwritten by environment)
+##
+RELEASE_CANDIDATE=${RELEASE_CANDIDATE:-none}
+
+##
+## Required variables
+##
+RELEASE_VERSION=${RELEASE_VERSION}","[{'comment': 'It seems like a redundant assignment, am I missing some bash-foo :-)', 'commenter': 'igalshilman'}, {'comment': '@igalshilman its there to avoid `Unresolved variable` warnings later in the script when using the variable.', 'commenter': 'tzulitai'}]"
14,tools/releasing/create_release_branch.sh,"@@ -0,0 +1,59 @@
+#!/usr/bin/env bash
+
+#
+# Licensed to the Apache Software Foundation (ASF) under one or more
+# contributor license agreements.  See the NOTICE file distributed with
+# this work for additional information regarding copyright ownership.
+# The ASF licenses this file to You under the Apache License, Version 2.0
+# (the ""License""); you may not use this file except in compliance with
+# the License.  You may obtain a copy of the License at
+#
+#    http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an ""AS IS"" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+##
+## Variables with defaults (if not overwritten by environment)
+##
+RELEASE_CANDIDATE=${RELEASE_CANDIDATE:-none}
+
+##
+## Required variables
+##
+RELEASE_VERSION=${RELEASE_VERSION}
+
+if [ -z ""${RELEASE_VERSION}"" ]; then
+	echo ""RELEASE_VERSION was not set""
+	exit 1
+fi
+
+# fail immediately
+set -o errexit
+set -o nounset
+
+BASE_DIR=""$( cd ""$( dirname ""${BASH_SOURCE[0]}"" )"" >/dev/null && pwd )""
+PROJECT_ROOT=""${BASE_DIR}/../../""
+
+###########################
+
+TARGET_BRANCH=release-${RELEASE_VERSION}
+if [ ""${RELEASE_CANDIDATE}"" != ""none"" ]; then
+  TARGET_BRANCH=${TARGET_BRANCH}-rc${RELEASE_CANDIDATE}
+fi
+
+cd ${PROJECT_ROOT}
+git checkout -b ${TARGET_BRANCH}
+
+RELEASE_COMMIT_HASH=`git rev-parse HEAD`
+
+TAG_COMMIT_MSG=""Apache Flink Stateful Functions, release ${RELEASE_VERSION}""
+if [ ""${RELEASE_CANDIDATE}"" != ""none"" ]; then
+  TAG_COMMIT_MSG=""${TAG_COMMIT_MSG} candidate #${RELEASE_CANDIDATE}""","[{'comment': 'The TAG_COMMIT_MESSAGE is unused.', 'commenter': 'igalshilman'}, {'comment': 'Oops, good catch.', 'commenter': 'tzulitai'}]"
14,tools/releasing/update_branch_version.sh,"@@ -0,0 +1,56 @@
+#!/usr/bin/env bash
+
+#
+# Licensed to the Apache Software Foundation (ASF) under one or more
+# contributor license agreements.  See the NOTICE file distributed with
+# this work for additional information regarding copyright ownership.
+# The ASF licenses this file to You under the Apache License, Version 2.0
+# (the ""License""); you may not use this file except in compliance with
+# the License.  You may obtain a copy of the License at
+#
+#    http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an ""AS IS"" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+##
+## Required variables
+##
+OLD_VERSION=${OLD_VERSION}
+NEW_VERSION=${NEW_VERSION}
+
+if [ -z ""${OLD_VERSION}"" ]; then
+    echo ""OLD_VERSION was not set.""
+    exit 1
+fi
+
+if [ -z ""${NEW_VERSION}"" ]; then
+    echo ""NEW_VERSION was not set.""
+    exit 1
+fi
+
+# fail immediately
+set -o errexit
+set -o nounset
+
+BASE_DIR=""$( cd ""$( dirname ""${BASH_SOURCE[0]}"" )"" >/dev/null && pwd )""
+PROJECT_ROOT=""${BASE_DIR}/../../""
+
+###########################
+
+cd ${PROJECT_ROOT}","[{'comment': 'It is a good practice to test for a file that you would expect to see here, for example pom.xml, or README.md.\r\nThis would help if the shell script would be moved outside it’s current location.', 'commenter': 'igalshilman'}, {'comment': 'Good point.', 'commenter': 'tzulitai'}]"
14,tools/releasing/update_branch_version.sh,"@@ -0,0 +1,56 @@
+#!/usr/bin/env bash
+
+#
+# Licensed to the Apache Software Foundation (ASF) under one or more
+# contributor license agreements.  See the NOTICE file distributed with
+# this work for additional information regarding copyright ownership.
+# The ASF licenses this file to You under the Apache License, Version 2.0
+# (the ""License""); you may not use this file except in compliance with
+# the License.  You may obtain a copy of the License at
+#
+#    http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an ""AS IS"" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+##
+## Required variables
+##
+OLD_VERSION=${OLD_VERSION}
+NEW_VERSION=${NEW_VERSION}
+
+if [ -z ""${OLD_VERSION}"" ]; then
+    echo ""OLD_VERSION was not set.""
+    exit 1
+fi
+
+if [ -z ""${NEW_VERSION}"" ]; then
+    echo ""NEW_VERSION was not set.""
+    exit 1
+fi
+
+# fail immediately
+set -o errexit
+set -o nounset
+
+BASE_DIR=""$( cd ""$( dirname ""${BASH_SOURCE[0]}"" )"" >/dev/null && pwd )""
+PROJECT_ROOT=""${BASE_DIR}/../../""
+
+###########################
+
+cd ${PROJECT_ROOT}
+
+#change version in all pom files
+find . -name 'pom.xml' -type f -exec perl -pi -e 's#<version>(.*)'${OLD_VERSION}'(.*)</version>#<version>${1}'${NEW_VERSION}'${2}</version>#' {} \;","[{'comment': 'There is a maven command for this,\r\nSee https://www.mojohaus.org/versions-maven-plugin/examples/set.html', 'commenter': 'igalshilman'}, {'comment': ""I'll still keep this script and encourage its usage, since this script handles doc version string updates."", 'commenter': 'tzulitai'}, {'comment': 'For example, there is a version string in the README as well.', 'commenter': 'tzulitai'}, {'comment': ""I'll change the Maven POM update part to `mvn versions:set -DgenerateBackupPoms=false -DnewVersion=${NEW_VERSION}`."", 'commenter': 'tzulitai'}]"
17,statefun-flink/statefun-flink-core/src/main/java/org/apache/flink/statefun/flink/core/cache/SingleThreadedLruCache.java,"@@ -0,0 +1,62 @@
+/*
+ * Copyright 2019 Ververica GmbH.","[{'comment': ""Is this intended? If yes, we might have to add this to the NOTICE file and tag this file (see what I've done to the `fastutil` sources).\r\nOtherwise, since we also happen to be from Ververica 😃 It'd probably be fine for us to make the decision to just copyright this to Apache since this is part of the contribution anyways."", 'commenter': 'tzulitai'}, {'comment': 'It is not intended, it was an old editor template :-) \r\nAnd it was fixed in 5d05e231fddc9932e40e1d6943ccb4bcd6b6c159 (fxiup)', 'commenter': 'igalshilman'}]"
17,statefun-flink/statefun-flink-core/src/main/java/org/apache/flink/statefun/flink/core/state/StateBinder.java,"@@ -36,13 +39,34 @@ public StateBinder(@Label(""state"") State state) {
   }
 
   public BoundState bind(FunctionType functionType, @Nullable Object instance) {
-    List<PersistedValue<Object>> values = PersistedValues.findReflectively(instance);
-
-    for (PersistedValue<Object> persistedValue : values) {
-      Accessor<Object> accessor = state.createFlinkStateAccessor(functionType, persistedValue);
-      ApiExtension.setPersistedValueAccessor(persistedValue, accessor);
+    List<?> values = PersistedValues.findReflectively(instance);","[{'comment': 'Please rename the variable `values` and the class `PersistedValues` to probably `PersistedStates`, since the class now handles not only values but tables as well.', 'commenter': 'tzulitai'}]"
17,statefun-flink/statefun-flink-core/src/main/java/org/apache/flink/statefun/flink/core/state/MultiplexedTableStateAccessor.java,"@@ -0,0 +1,141 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.flink.statefun.flink.core.state;
+
+import com.google.protobuf.ByteString;
+import java.io.IOException;
+import java.util.Objects;
+import javax.annotation.Nonnull;
+import javax.annotation.Nullable;
+import org.apache.flink.api.common.state.MapState;
+import org.apache.flink.api.common.typeutils.TypeSerializer;
+import org.apache.flink.core.memory.DataInputDeserializer;
+import org.apache.flink.core.memory.DataOutputSerializer;
+import org.apache.flink.statefun.flink.core.cache.SingleThreadedLruCache;
+import org.apache.flink.statefun.flink.core.generated.MultiplexedStateKey;
+import org.apache.flink.statefun.sdk.state.TableAccessor;
+
+final class MultiplexedTableStateAccessor<K, V> implements TableAccessor<K, V> {
+  private final MapState<MultiplexedStateKey, byte[]> mapStateHandle;
+  private final MultiplexedStateKey accessorMapKeyPrefix;
+  private final TaggedRawSerializer<K> keySerializer;
+  private final TaggedRawSerializer<V> valueSerializer;
+
+  private final SingleThreadedLruCache<K, MultiplexedStateKey> commonKeysCache =
+      new SingleThreadedLruCache<>(128);
+
+  MultiplexedTableStateAccessor(
+      MapState<MultiplexedStateKey, byte[]> handle,
+      MultiplexedStateKey accessorMapKeyPrefix,
+      TypeSerializer<K> subKeySerializer,
+      TypeSerializer<V> subValueSerializer) {
+    this.mapStateHandle = Objects.requireNonNull(handle);
+    this.keySerializer = new TaggedRawSerializer<>(new byte[0], subKeySerializer);
+    this.valueSerializer = new TaggedRawSerializer<>(new byte[0], subValueSerializer);
+    this.accessorMapKeyPrefix = accessorMapKeyPrefix;
+  }
+
+  @Override
+  public void set(K key, V value) {
+    try {
+      MultiplexedStateKey keyBytes = stateKey(key);
+      if (value == null) {
+        mapStateHandle.remove(keyBytes);
+      } else {
+        byte[] bytes = valueSerializer.serialize(value);
+        mapStateHandle.put(keyBytes, bytes);
+      }
+    } catch (Exception e) {
+      throw new RuntimeException(e);
+    }
+  }
+
+  @Override
+  public V get(K userKey) {
+    try {
+      final MultiplexedStateKey stateKey = stateKey(userKey);
+      final byte[] bytes = mapStateHandle.get(stateKey);
+      if (bytes == null) {
+        return null;
+      }
+      return valueSerializer.deserialize(bytes);
+    } catch (Exception e) {
+      throw new RuntimeException(e);
+    }
+  }
+
+  @Override
+  public void remove(K userKey) {
+    try {
+      mapStateHandle.remove(stateKey(userKey));
+    } catch (Exception e) {
+      throw new RuntimeException(e);
+    }
+  }
+
+  @Nonnull
+  private MultiplexedStateKey stateKey(final K userKey) {
+    Objects.requireNonNull(userKey, ""Key can not be NULL"");
+    @Nullable MultiplexedStateKey stateKey = commonKeysCache.get(userKey);
+    if (stateKey != null) {
+      return stateKey;
+    }
+    try {
+      commonKeysCache.put(userKey, stateKey = computeStateKeyFromUserKey(userKey));
+      return stateKey;
+    } catch (IOException e) {
+      throw new RuntimeException(""Unable to serialize the key "" + userKey, e);
+    }
+  }
+
+  private MultiplexedStateKey computeStateKeyFromUserKey(K userKey) throws IOException {
+    byte[] userKeyBytes = keySerializer.serialize(userKey);
+    ByteString userKeyByteString = ByteString.copyFrom(userKeyBytes);
+    return accessorMapKeyPrefix.toBuilder().addUserKeys(userKeyByteString).build();
+  }
+
+  private static final class TaggedRawSerializer<T> {
+
+    private final TypeSerializer<T> delegate;
+    private final DataOutputSerializer output;
+    private final DataInputDeserializer input;
+    private final byte[] tag;
+
+    TaggedRawSerializer(byte[] tag, TypeSerializer<T> delegate) {
+      this.tag = Objects.requireNonNull(tag);
+      this.delegate = Objects.requireNonNull(delegate);
+      this.output = new DataOutputSerializer(32 + tag.length);","[{'comment': 'nit: Might want to consider setting this `32` to a named static final variable, for the sake of readability of the code.\r\nSomething along the lines of `DEFAULT_OUT_BUFFER_SIZE`.', 'commenter': 'tzulitai'}, {'comment': 'Let me actually remove that, and pull up the RawSerializer.', 'commenter': 'igalshilman'}]"
17,statefun-flink/statefun-flink-core/src/main/java/org/apache/flink/statefun/flink/core/state/MultiplexedTableStateAccessor.java,"@@ -0,0 +1,141 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.flink.statefun.flink.core.state;
+
+import com.google.protobuf.ByteString;
+import java.io.IOException;
+import java.util.Objects;
+import javax.annotation.Nonnull;
+import javax.annotation.Nullable;
+import org.apache.flink.api.common.state.MapState;
+import org.apache.flink.api.common.typeutils.TypeSerializer;
+import org.apache.flink.core.memory.DataInputDeserializer;
+import org.apache.flink.core.memory.DataOutputSerializer;
+import org.apache.flink.statefun.flink.core.cache.SingleThreadedLruCache;
+import org.apache.flink.statefun.flink.core.generated.MultiplexedStateKey;
+import org.apache.flink.statefun.sdk.state.TableAccessor;
+
+final class MultiplexedTableStateAccessor<K, V> implements TableAccessor<K, V> {
+  private final MapState<MultiplexedStateKey, byte[]> mapStateHandle;
+  private final MultiplexedStateKey accessorMapKeyPrefix;
+  private final TaggedRawSerializer<K> keySerializer;
+  private final TaggedRawSerializer<V> valueSerializer;
+
+  private final SingleThreadedLruCache<K, MultiplexedStateKey> commonKeysCache =
+      new SingleThreadedLruCache<>(128);
+
+  MultiplexedTableStateAccessor(
+      MapState<MultiplexedStateKey, byte[]> handle,
+      MultiplexedStateKey accessorMapKeyPrefix,
+      TypeSerializer<K> subKeySerializer,
+      TypeSerializer<V> subValueSerializer) {
+    this.mapStateHandle = Objects.requireNonNull(handle);
+    this.keySerializer = new TaggedRawSerializer<>(new byte[0], subKeySerializer);
+    this.valueSerializer = new TaggedRawSerializer<>(new byte[0], subValueSerializer);
+    this.accessorMapKeyPrefix = accessorMapKeyPrefix;
+  }
+
+  @Override
+  public void set(K key, V value) {
+    try {
+      MultiplexedStateKey keyBytes = stateKey(key);
+      if (value == null) {
+        mapStateHandle.remove(keyBytes);
+      } else {
+        byte[] bytes = valueSerializer.serialize(value);
+        mapStateHandle.put(keyBytes, bytes);
+      }
+    } catch (Exception e) {
+      throw new RuntimeException(e);
+    }
+  }
+
+  @Override
+  public V get(K userKey) {
+    try {
+      final MultiplexedStateKey stateKey = stateKey(userKey);
+      final byte[] bytes = mapStateHandle.get(stateKey);
+      if (bytes == null) {
+        return null;
+      }
+      return valueSerializer.deserialize(bytes);
+    } catch (Exception e) {
+      throw new RuntimeException(e);
+    }
+  }
+
+  @Override
+  public void remove(K userKey) {
+    try {
+      mapStateHandle.remove(stateKey(userKey));
+    } catch (Exception e) {
+      throw new RuntimeException(e);
+    }
+  }
+
+  @Nonnull
+  private MultiplexedStateKey stateKey(final K userKey) {
+    Objects.requireNonNull(userKey, ""Key can not be NULL"");
+    @Nullable MultiplexedStateKey stateKey = commonKeysCache.get(userKey);
+    if (stateKey != null) {
+      return stateKey;
+    }
+    try {
+      commonKeysCache.put(userKey, stateKey = computeStateKeyFromUserKey(userKey));
+      return stateKey;
+    } catch (IOException e) {
+      throw new RuntimeException(""Unable to serialize the key "" + userKey, e);
+    }
+  }
+
+  private MultiplexedStateKey computeStateKeyFromUserKey(K userKey) throws IOException {
+    byte[] userKeyBytes = keySerializer.serialize(userKey);
+    ByteString userKeyByteString = ByteString.copyFrom(userKeyBytes);
+    return accessorMapKeyPrefix.toBuilder().addUserKeys(userKeyByteString).build();","[{'comment': '👍 gotcha (RE: just figured out the answer to my question on whether `MultiplexedStateKey` needs additional fields, answer is no).', 'commenter': 'tzulitai'}]"
17,statefun-flink/statefun-flink-core/src/main/java/org/apache/flink/statefun/flink/core/state/MultiplexedTableStateAccessor.java,"@@ -0,0 +1,141 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.flink.statefun.flink.core.state;
+
+import com.google.protobuf.ByteString;
+import java.io.IOException;
+import java.util.Objects;
+import javax.annotation.Nonnull;
+import javax.annotation.Nullable;
+import org.apache.flink.api.common.state.MapState;
+import org.apache.flink.api.common.typeutils.TypeSerializer;
+import org.apache.flink.core.memory.DataInputDeserializer;
+import org.apache.flink.core.memory.DataOutputSerializer;
+import org.apache.flink.statefun.flink.core.cache.SingleThreadedLruCache;
+import org.apache.flink.statefun.flink.core.generated.MultiplexedStateKey;
+import org.apache.flink.statefun.sdk.state.TableAccessor;
+
+final class MultiplexedTableStateAccessor<K, V> implements TableAccessor<K, V> {
+  private final MapState<MultiplexedStateKey, byte[]> mapStateHandle;
+  private final MultiplexedStateKey accessorMapKeyPrefix;
+  private final TaggedRawSerializer<K> keySerializer;
+  private final TaggedRawSerializer<V> valueSerializer;
+
+  private final SingleThreadedLruCache<K, MultiplexedStateKey> commonKeysCache =
+      new SingleThreadedLruCache<>(128);","[{'comment': 'nit: again, consider assigning this 128 to a class static final named variable for readability.', 'commenter': 'tzulitai'}, {'comment': 'Good idea! will followup with a hot fix commit.', 'commenter': 'igalshilman'}]"
17,statefun-flink/statefun-flink-core/src/main/java/org/apache/flink/statefun/flink/core/state/MultiplexedTableStateAccessor.java,"@@ -0,0 +1,141 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.flink.statefun.flink.core.state;
+
+import com.google.protobuf.ByteString;
+import java.io.IOException;
+import java.util.Objects;
+import javax.annotation.Nonnull;
+import javax.annotation.Nullable;
+import org.apache.flink.api.common.state.MapState;
+import org.apache.flink.api.common.typeutils.TypeSerializer;
+import org.apache.flink.core.memory.DataInputDeserializer;
+import org.apache.flink.core.memory.DataOutputSerializer;
+import org.apache.flink.statefun.flink.core.cache.SingleThreadedLruCache;
+import org.apache.flink.statefun.flink.core.generated.MultiplexedStateKey;
+import org.apache.flink.statefun.sdk.state.TableAccessor;
+
+final class MultiplexedTableStateAccessor<K, V> implements TableAccessor<K, V> {
+  private final MapState<MultiplexedStateKey, byte[]> mapStateHandle;
+  private final MultiplexedStateKey accessorMapKeyPrefix;
+  private final TaggedRawSerializer<K> keySerializer;
+  private final TaggedRawSerializer<V> valueSerializer;
+
+  private final SingleThreadedLruCache<K, MultiplexedStateKey> commonKeysCache =
+      new SingleThreadedLruCache<>(128);
+
+  MultiplexedTableStateAccessor(
+      MapState<MultiplexedStateKey, byte[]> handle,
+      MultiplexedStateKey accessorMapKeyPrefix,
+      TypeSerializer<K> subKeySerializer,
+      TypeSerializer<V> subValueSerializer) {
+    this.mapStateHandle = Objects.requireNonNull(handle);
+    this.keySerializer = new TaggedRawSerializer<>(new byte[0], subKeySerializer);
+    this.valueSerializer = new TaggedRawSerializer<>(new byte[0], subValueSerializer);
+    this.accessorMapKeyPrefix = accessorMapKeyPrefix;
+  }
+
+  @Override
+  public void set(K key, V value) {
+    try {
+      MultiplexedStateKey keyBytes = stateKey(key);
+      if (value == null) {
+        mapStateHandle.remove(keyBytes);
+      } else {
+        byte[] bytes = valueSerializer.serialize(value);
+        mapStateHandle.put(keyBytes, bytes);
+      }
+    } catch (Exception e) {
+      throw new RuntimeException(e);
+    }
+  }
+
+  @Override
+  public V get(K userKey) {
+    try {
+      final MultiplexedStateKey stateKey = stateKey(userKey);
+      final byte[] bytes = mapStateHandle.get(stateKey);
+      if (bytes == null) {
+        return null;
+      }
+      return valueSerializer.deserialize(bytes);
+    } catch (Exception e) {
+      throw new RuntimeException(e);
+    }
+  }
+
+  @Override
+  public void remove(K userKey) {
+    try {
+      mapStateHandle.remove(stateKey(userKey));
+    } catch (Exception e) {
+      throw new RuntimeException(e);
+    }
+  }
+
+  @Nonnull
+  private MultiplexedStateKey stateKey(final K userKey) {
+    Objects.requireNonNull(userKey, ""Key can not be NULL"");
+    @Nullable MultiplexedStateKey stateKey = commonKeysCache.get(userKey);
+    if (stateKey != null) {
+      return stateKey;
+    }
+    try {
+      commonKeysCache.put(userKey, stateKey = computeStateKeyFromUserKey(userKey));
+      return stateKey;
+    } catch (IOException e) {
+      throw new RuntimeException(""Unable to serialize the key "" + userKey, e);
+    }
+  }
+
+  private MultiplexedStateKey computeStateKeyFromUserKey(K userKey) throws IOException {
+    byte[] userKeyBytes = keySerializer.serialize(userKey);
+    ByteString userKeyByteString = ByteString.copyFrom(userKeyBytes);
+    return accessorMapKeyPrefix.toBuilder().addUserKeys(userKeyByteString).build();
+  }
+
+  private static final class TaggedRawSerializer<T> {
+
+    private final TypeSerializer<T> delegate;
+    private final DataOutputSerializer output;
+    private final DataInputDeserializer input;
+    private final byte[] tag;
+
+    TaggedRawSerializer(byte[] tag, TypeSerializer<T> delegate) {
+      this.tag = Objects.requireNonNull(tag);","[{'comment': ""I don't think we need this tag. It's also always an empty byte array being passed as argument in its usages."", 'commenter': 'tzulitai'}, {'comment': 'Yes you are right, I have addressed that in e40b2f2c93716adacbbd07587996f515f263645c', 'commenter': 'igalshilman'}]"
17,statefun-flink/statefun-flink-core/src/main/java/org/apache/flink/statefun/flink/core/state/MultiplexedTableStateAccessor.java,"@@ -0,0 +1,141 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.flink.statefun.flink.core.state;
+
+import com.google.protobuf.ByteString;
+import java.io.IOException;
+import java.util.Objects;
+import javax.annotation.Nonnull;
+import javax.annotation.Nullable;
+import org.apache.flink.api.common.state.MapState;
+import org.apache.flink.api.common.typeutils.TypeSerializer;
+import org.apache.flink.core.memory.DataInputDeserializer;
+import org.apache.flink.core.memory.DataOutputSerializer;
+import org.apache.flink.statefun.flink.core.cache.SingleThreadedLruCache;
+import org.apache.flink.statefun.flink.core.generated.MultiplexedStateKey;
+import org.apache.flink.statefun.sdk.state.TableAccessor;
+
+final class MultiplexedTableStateAccessor<K, V> implements TableAccessor<K, V> {
+  private final MapState<MultiplexedStateKey, byte[]> mapStateHandle;
+  private final MultiplexedStateKey accessorMapKeyPrefix;
+  private final TaggedRawSerializer<K> keySerializer;
+  private final TaggedRawSerializer<V> valueSerializer;
+
+  private final SingleThreadedLruCache<K, MultiplexedStateKey> commonKeysCache =
+      new SingleThreadedLruCache<>(128);
+
+  MultiplexedTableStateAccessor(
+      MapState<MultiplexedStateKey, byte[]> handle,
+      MultiplexedStateKey accessorMapKeyPrefix,
+      TypeSerializer<K> subKeySerializer,
+      TypeSerializer<V> subValueSerializer) {
+    this.mapStateHandle = Objects.requireNonNull(handle);
+    this.keySerializer = new TaggedRawSerializer<>(new byte[0], subKeySerializer);
+    this.valueSerializer = new TaggedRawSerializer<>(new byte[0], subValueSerializer);
+    this.accessorMapKeyPrefix = accessorMapKeyPrefix;","[{'comment': 'Preconditions `Objects.requireNonNull`', 'commenter': 'tzulitai'}]"
17,statefun-flink/statefun-flink-core/src/main/java/org/apache/flink/statefun/flink/core/state/MultiplexedState.java,"@@ -65,6 +67,19 @@ public MultiplexedState(
     return new MultiplexedMapStateAccessor<>(sharedMapStateHandle, uniqueSubKey, valueSerializer);
   }
 
+  @Override
+  public <K, V> TableAccessor<K, V> createFlinkStateTableAccessor(
+      FunctionType functionType, PersistedTable<K, V> persistedTable) {
+    final MultiplexedStateKey uniqueSubKeyPrefix =
+        multiplexedSubstateKey(functionType, persistedTable.name());
+    final TypeSerializer<K> keySerializer =
+        types.registerType(persistedTable.keyType()).createSerializer(executionConfiguration);
+    final TypeSerializer<V> valueSerializer =
+        types.registerType(persistedTable.valueType()).createSerializer(executionConfiguration);
+    return new MultiplexedTableStateAccessor<>(
+        sharedMapStateHandle, uniqueSubKeyPrefix, keySerializer, valueSerializer);","[{'comment': ""What is the benefit of multiplexing both `PersistedValue`s and `PersistedTable`s within the same Flink `MapState`?\r\nWhile I can't really think of a disadvantage of doing this, my gut feeling is that it'll be more future proof to have them separated, i.e. one `MapState` for multiplexing value states, and another one for multiplexing table states.\r\n\r\nWDYT?"", 'commenter': 'tzulitai'}, {'comment': ""One other reason we might want to separate their handles:\r\n\r\nThere's already a problem with the (to-be-introduced) state reader / analyzer, that to read a single function's persisted state values, you have to iterate through ALL keys (which includes state of other functions) since we multiplex everything into a single handle.\r\n\r\nIf you multiplex both tables and values into a single state handle, this will because even more of a problem in the future, say when the user just wants to read table state and not value states."", 'commenter': 'tzulitai'}, {'comment': 'Some more food for thought:\r\nIf we do decide to separate the handles, we can slim down the `MultiplexedStateKey` type a bit, by having a separate `MultiplexedTableStateKey` that has a `ByteString userKey` field and a `MultiplexedStateKey prefix` field.\r\n\r\nFor example, I already have a minor concern with the way we use `MultiplexedStateKey`:\r\nDoes protobuf repeated fields require some extra metadata written? If yes, its a tad bit redundant size-wise in this case since we only ever have 1 user key added.\r\n', 'commenter': 'tzulitai'}, {'comment': ""Hi @tzulitai, \r\nI am hesitant to add another state handle without a clear benefit mainly because of the memory requirements associated with it. \r\nWe Currently have:\r\n* async operations state\r\n* delayed operations\r\n* persisted values\r\n* there would be another ListState coming for multi-language\r\nThis already requires 512MB out of the box, so I'd be carful of adding another without a clear advantage. \r\nIdeally the core limitation at Flink would be addressed so we won't have to multiplex state at all.\r\n\r\n\r\n\r\n"", 'commenter': 'igalshilman'}]"
28,statefun-integration-tests/statefun-sanity-itcase/src/test/java/org/apache/flink/statefun/itcases/sanity/SanityVerificationITCase.java,"@@ -0,0 +1,287 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.statefun.itcases.sanity;
+
+import static org.hamcrest.CoreMatchers.hasItems;
+import static org.hamcrest.MatcherAssert.assertThat;
+
+import java.nio.file.Paths;
+import java.time.Duration;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import java.util.Map;
+import java.util.Properties;
+import java.util.concurrent.Callable;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.Future;
+import java.util.concurrent.TimeUnit;
+import org.apache.flink.statefun.itcases.sanity.generated.VerificationMessages.Command;
+import org.apache.flink.statefun.itcases.sanity.generated.VerificationMessages.FnAddress;
+import org.apache.flink.statefun.itcases.sanity.generated.VerificationMessages.Modify;
+import org.apache.flink.statefun.itcases.sanity.generated.VerificationMessages.Noop;
+import org.apache.flink.statefun.itcases.sanity.generated.VerificationMessages.Send;
+import org.apache.flink.statefun.itcases.sanity.generated.VerificationMessages.StateSnapshot;
+import org.apache.kafka.clients.consumer.Consumer;
+import org.apache.kafka.clients.consumer.ConsumerRecord;
+import org.apache.kafka.clients.consumer.ConsumerRecords;
+import org.apache.kafka.clients.consumer.KafkaConsumer;
+import org.apache.kafka.clients.producer.KafkaProducer;
+import org.apache.kafka.clients.producer.Producer;
+import org.apache.kafka.clients.producer.ProducerRecord;
+import org.apache.kafka.common.serialization.Deserializer;
+import org.apache.kafka.common.serialization.Serializer;
+import org.junit.Rule;
+import org.junit.Test;
+import org.testcontainers.containers.GenericContainer;
+import org.testcontainers.containers.KafkaContainer;
+import org.testcontainers.containers.Network;
+import org.testcontainers.images.builder.ImageFromDockerfile;
+
+/**
+ * Sanity verification integration test based on the {@link SanityVerificationModule} application.
+ *
+ * <p>The integration test setups Kafka brokers and the verification application using Docker, sends
+ * a few commands to Kafka to be consumed by the application, and finally verifies that outputs sent
+ * to Kafka from the application are correct.
+ */
+public class SanityVerificationITCase {
+
+  private static final String CONFLUENT_PLATFORM_VERSION = ""5.0.3"";
+
+  private static final ImageFromDockerfile verificationAppImage =
+      new ImageFromDockerfile(""statefun-sanity-itcase"")
+          .withFileFromClasspath(""Dockerfile"", ""Dockerfile"")
+          .withFileFromPath(""."", Paths.get(System.getProperty(""user.dir"") + ""/target/""));","[{'comment': ""Can you turn this to a static function call, with a comment and a log statement around the `withFileFromPath` ?\r\nA log message would reflects the actual `Path` value at runtime, since. `System.getProperty` is somewhat not deterministic (platform specific, etc')\r\n"", 'commenter': 'igalshilman'}]"
28,statefun-integration-tests/statefun-sanity-itcase/src/test/java/org/apache/flink/statefun/itcases/sanity/SanityVerificationITCase.java,"@@ -0,0 +1,287 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.statefun.itcases.sanity;
+
+import static org.hamcrest.CoreMatchers.hasItems;
+import static org.hamcrest.MatcherAssert.assertThat;
+
+import java.nio.file.Paths;
+import java.time.Duration;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import java.util.Map;
+import java.util.Properties;
+import java.util.concurrent.Callable;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.Future;
+import java.util.concurrent.TimeUnit;
+import org.apache.flink.statefun.itcases.sanity.generated.VerificationMessages.Command;
+import org.apache.flink.statefun.itcases.sanity.generated.VerificationMessages.FnAddress;
+import org.apache.flink.statefun.itcases.sanity.generated.VerificationMessages.Modify;
+import org.apache.flink.statefun.itcases.sanity.generated.VerificationMessages.Noop;
+import org.apache.flink.statefun.itcases.sanity.generated.VerificationMessages.Send;
+import org.apache.flink.statefun.itcases.sanity.generated.VerificationMessages.StateSnapshot;
+import org.apache.kafka.clients.consumer.Consumer;
+import org.apache.kafka.clients.consumer.ConsumerRecord;
+import org.apache.kafka.clients.consumer.ConsumerRecords;
+import org.apache.kafka.clients.consumer.KafkaConsumer;
+import org.apache.kafka.clients.producer.KafkaProducer;
+import org.apache.kafka.clients.producer.Producer;
+import org.apache.kafka.clients.producer.ProducerRecord;
+import org.apache.kafka.common.serialization.Deserializer;
+import org.apache.kafka.common.serialization.Serializer;
+import org.junit.Rule;
+import org.junit.Test;
+import org.testcontainers.containers.GenericContainer;
+import org.testcontainers.containers.KafkaContainer;
+import org.testcontainers.containers.Network;
+import org.testcontainers.images.builder.ImageFromDockerfile;
+
+/**
+ * Sanity verification integration test based on the {@link SanityVerificationModule} application.
+ *
+ * <p>The integration test setups Kafka brokers and the verification application using Docker, sends
+ * a few commands to Kafka to be consumed by the application, and finally verifies that outputs sent
+ * to Kafka from the application are correct.
+ */
+public class SanityVerificationITCase {
+
+  private static final String CONFLUENT_PLATFORM_VERSION = ""5.0.3"";
+
+  private static final ImageFromDockerfile verificationAppImage =
+      new ImageFromDockerfile(""statefun-sanity-itcase"")
+          .withFileFromClasspath(""Dockerfile"", ""Dockerfile"")
+          .withFileFromPath(""."", Paths.get(System.getProperty(""user.dir"") + ""/target/""));
+
+  @Rule public Network network = Network.newNetwork();
+
+  @Rule
+  public KafkaContainer kafka =
+      new KafkaContainer(CONFLUENT_PLATFORM_VERSION)
+          .withNetwork(network)
+          .withNetworkAliases(""kafka-broker"");","[{'comment': 'the network alias is tightly coupled to the Kafka address set in the `KafkaIngressSpec` and `KafkaEgressSpec` can they refer to the same constant?', 'commenter': 'igalshilman'}]"
28,statefun-integration-tests/statefun-sanity-itcase/src/test/java/org/apache/flink/statefun/itcases/sanity/SanityVerificationITCase.java,"@@ -0,0 +1,287 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.statefun.itcases.sanity;
+
+import static org.hamcrest.CoreMatchers.hasItems;
+import static org.hamcrest.MatcherAssert.assertThat;
+
+import java.nio.file.Paths;
+import java.time.Duration;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import java.util.Map;
+import java.util.Properties;
+import java.util.concurrent.Callable;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.Future;
+import java.util.concurrent.TimeUnit;
+import org.apache.flink.statefun.itcases.sanity.generated.VerificationMessages.Command;
+import org.apache.flink.statefun.itcases.sanity.generated.VerificationMessages.FnAddress;
+import org.apache.flink.statefun.itcases.sanity.generated.VerificationMessages.Modify;
+import org.apache.flink.statefun.itcases.sanity.generated.VerificationMessages.Noop;
+import org.apache.flink.statefun.itcases.sanity.generated.VerificationMessages.Send;
+import org.apache.flink.statefun.itcases.sanity.generated.VerificationMessages.StateSnapshot;
+import org.apache.kafka.clients.consumer.Consumer;
+import org.apache.kafka.clients.consumer.ConsumerRecord;
+import org.apache.kafka.clients.consumer.ConsumerRecords;
+import org.apache.kafka.clients.consumer.KafkaConsumer;
+import org.apache.kafka.clients.producer.KafkaProducer;
+import org.apache.kafka.clients.producer.Producer;
+import org.apache.kafka.clients.producer.ProducerRecord;
+import org.apache.kafka.common.serialization.Deserializer;
+import org.apache.kafka.common.serialization.Serializer;
+import org.junit.Rule;
+import org.junit.Test;
+import org.testcontainers.containers.GenericContainer;
+import org.testcontainers.containers.KafkaContainer;
+import org.testcontainers.containers.Network;
+import org.testcontainers.images.builder.ImageFromDockerfile;
+
+/**
+ * Sanity verification integration test based on the {@link SanityVerificationModule} application.
+ *
+ * <p>The integration test setups Kafka brokers and the verification application using Docker, sends
+ * a few commands to Kafka to be consumed by the application, and finally verifies that outputs sent
+ * to Kafka from the application are correct.
+ */
+public class SanityVerificationITCase {
+
+  private static final String CONFLUENT_PLATFORM_VERSION = ""5.0.3"";
+
+  private static final ImageFromDockerfile verificationAppImage =
+      new ImageFromDockerfile(""statefun-sanity-itcase"")
+          .withFileFromClasspath(""Dockerfile"", ""Dockerfile"")
+          .withFileFromPath(""."", Paths.get(System.getProperty(""user.dir"") + ""/target/""));
+
+  @Rule public Network network = Network.newNetwork();
+
+  @Rule
+  public KafkaContainer kafka =
+      new KafkaContainer(CONFLUENT_PLATFORM_VERSION)
+          .withNetwork(network)
+          .withNetworkAliases(""kafka-broker"");
+
+  @Rule
+  public GenericContainer verificationAppMaster =
+      new GenericContainer(verificationAppImage)
+          .dependsOn(kafka)
+          .withNetwork(network)
+          .withNetworkAliases(""master"")
+          .withEnv(""ROLE"", ""master"")
+          .withEnv(""MASTER_HOST"", ""master"");
+
+  @Rule
+  public GenericContainer verificationAppWorker =
+      new GenericContainer(verificationAppImage)
+          .dependsOn(kafka, verificationAppMaster)
+          .withNetwork(network)
+          .withNetworkAliases(""worker"")
+          .withEnv(""ROLE"", ""worker"")
+          .withEnv(""MASTER_HOST"", ""master"");
+
+  @Test
+  public void run() throws Exception {
+    final String kafkaAddress = kafka.getBootstrapServers();
+    final ExecutorService kafkaIoExecutor = Executors.newCachedThreadPool();
+
+    kafkaIoExecutor.submit(new ProduceCommands(kafkaAddress));","[{'comment': 'You can use `CompletableFuture.supplyAsync(() -> ProduceCommands(..)));`\r\n', 'commenter': 'igalshilman'}]"
28,statefun-integration-tests/statefun-sanity-itcase/src/test/java/org/apache/flink/statefun/itcases/sanity/SanityVerificationITCase.java,"@@ -0,0 +1,287 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.statefun.itcases.sanity;
+
+import static org.hamcrest.CoreMatchers.hasItems;
+import static org.hamcrest.MatcherAssert.assertThat;
+
+import java.nio.file.Paths;
+import java.time.Duration;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import java.util.Map;
+import java.util.Properties;
+import java.util.concurrent.Callable;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.Future;
+import java.util.concurrent.TimeUnit;
+import org.apache.flink.statefun.itcases.sanity.generated.VerificationMessages.Command;
+import org.apache.flink.statefun.itcases.sanity.generated.VerificationMessages.FnAddress;
+import org.apache.flink.statefun.itcases.sanity.generated.VerificationMessages.Modify;
+import org.apache.flink.statefun.itcases.sanity.generated.VerificationMessages.Noop;
+import org.apache.flink.statefun.itcases.sanity.generated.VerificationMessages.Send;
+import org.apache.flink.statefun.itcases.sanity.generated.VerificationMessages.StateSnapshot;
+import org.apache.kafka.clients.consumer.Consumer;
+import org.apache.kafka.clients.consumer.ConsumerRecord;
+import org.apache.kafka.clients.consumer.ConsumerRecords;
+import org.apache.kafka.clients.consumer.KafkaConsumer;
+import org.apache.kafka.clients.producer.KafkaProducer;
+import org.apache.kafka.clients.producer.Producer;
+import org.apache.kafka.clients.producer.ProducerRecord;
+import org.apache.kafka.common.serialization.Deserializer;
+import org.apache.kafka.common.serialization.Serializer;
+import org.junit.Rule;
+import org.junit.Test;
+import org.testcontainers.containers.GenericContainer;
+import org.testcontainers.containers.KafkaContainer;
+import org.testcontainers.containers.Network;
+import org.testcontainers.images.builder.ImageFromDockerfile;
+
+/**
+ * Sanity verification integration test based on the {@link SanityVerificationModule} application.
+ *
+ * <p>The integration test setups Kafka brokers and the verification application using Docker, sends
+ * a few commands to Kafka to be consumed by the application, and finally verifies that outputs sent
+ * to Kafka from the application are correct.
+ */
+public class SanityVerificationITCase {
+
+  private static final String CONFLUENT_PLATFORM_VERSION = ""5.0.3"";
+
+  private static final ImageFromDockerfile verificationAppImage =
+      new ImageFromDockerfile(""statefun-sanity-itcase"")
+          .withFileFromClasspath(""Dockerfile"", ""Dockerfile"")
+          .withFileFromPath(""."", Paths.get(System.getProperty(""user.dir"") + ""/target/""));
+
+  @Rule public Network network = Network.newNetwork();
+
+  @Rule
+  public KafkaContainer kafka =
+      new KafkaContainer(CONFLUENT_PLATFORM_VERSION)
+          .withNetwork(network)
+          .withNetworkAliases(""kafka-broker"");
+
+  @Rule
+  public GenericContainer verificationAppMaster =
+      new GenericContainer(verificationAppImage)
+          .dependsOn(kafka)
+          .withNetwork(network)
+          .withNetworkAliases(""master"")
+          .withEnv(""ROLE"", ""master"")
+          .withEnv(""MASTER_HOST"", ""master"");
+
+  @Rule
+  public GenericContainer verificationAppWorker =
+      new GenericContainer(verificationAppImage)
+          .dependsOn(kafka, verificationAppMaster)
+          .withNetwork(network)
+          .withNetworkAliases(""worker"")
+          .withEnv(""ROLE"", ""worker"")
+          .withEnv(""MASTER_HOST"", ""master"");
+
+  @Test
+  public void run() throws Exception {
+    final String kafkaAddress = kafka.getBootstrapServers();
+    final ExecutorService kafkaIoExecutor = Executors.newCachedThreadPool();
+
+    kafkaIoExecutor.submit(new ProduceCommands(kafkaAddress));
+    Future<List<StateSnapshot>> stateSnapshotOutputs =
+        kafkaIoExecutor.submit(new ConsumeStateSnapshots(kafkaAddress));
+
+    assertThat(
+        stateSnapshotOutputs.get(1, TimeUnit.MINUTES),","[{'comment': 'then, this can be `stateSnapshotOutputs.join()`\r\nand the test would use `@Test(timeout = ..` annotation.', 'commenter': 'igalshilman'}]"
28,statefun-integration-tests/statefun-sanity-itcase/src/test/java/org/apache/flink/statefun/itcases/sanity/SanityVerificationITCase.java,"@@ -0,0 +1,287 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.statefun.itcases.sanity;
+
+import static org.hamcrest.CoreMatchers.hasItems;
+import static org.hamcrest.MatcherAssert.assertThat;
+
+import java.nio.file.Paths;
+import java.time.Duration;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import java.util.Map;
+import java.util.Properties;
+import java.util.concurrent.Callable;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.Future;
+import java.util.concurrent.TimeUnit;
+import org.apache.flink.statefun.itcases.sanity.generated.VerificationMessages.Command;
+import org.apache.flink.statefun.itcases.sanity.generated.VerificationMessages.FnAddress;
+import org.apache.flink.statefun.itcases.sanity.generated.VerificationMessages.Modify;
+import org.apache.flink.statefun.itcases.sanity.generated.VerificationMessages.Noop;
+import org.apache.flink.statefun.itcases.sanity.generated.VerificationMessages.Send;
+import org.apache.flink.statefun.itcases.sanity.generated.VerificationMessages.StateSnapshot;
+import org.apache.kafka.clients.consumer.Consumer;
+import org.apache.kafka.clients.consumer.ConsumerRecord;
+import org.apache.kafka.clients.consumer.ConsumerRecords;
+import org.apache.kafka.clients.consumer.KafkaConsumer;
+import org.apache.kafka.clients.producer.KafkaProducer;
+import org.apache.kafka.clients.producer.Producer;
+import org.apache.kafka.clients.producer.ProducerRecord;
+import org.apache.kafka.common.serialization.Deserializer;
+import org.apache.kafka.common.serialization.Serializer;
+import org.junit.Rule;
+import org.junit.Test;
+import org.testcontainers.containers.GenericContainer;
+import org.testcontainers.containers.KafkaContainer;
+import org.testcontainers.containers.Network;
+import org.testcontainers.images.builder.ImageFromDockerfile;
+
+/**
+ * Sanity verification integration test based on the {@link SanityVerificationModule} application.
+ *
+ * <p>The integration test setups Kafka brokers and the verification application using Docker, sends
+ * a few commands to Kafka to be consumed by the application, and finally verifies that outputs sent
+ * to Kafka from the application are correct.
+ */
+public class SanityVerificationITCase {
+
+  private static final String CONFLUENT_PLATFORM_VERSION = ""5.0.3"";
+
+  private static final ImageFromDockerfile verificationAppImage =
+      new ImageFromDockerfile(""statefun-sanity-itcase"")
+          .withFileFromClasspath(""Dockerfile"", ""Dockerfile"")
+          .withFileFromPath(""."", Paths.get(System.getProperty(""user.dir"") + ""/target/""));
+
+  @Rule public Network network = Network.newNetwork();
+
+  @Rule
+  public KafkaContainer kafka =
+      new KafkaContainer(CONFLUENT_PLATFORM_VERSION)
+          .withNetwork(network)
+          .withNetworkAliases(""kafka-broker"");
+
+  @Rule
+  public GenericContainer verificationAppMaster =
+      new GenericContainer(verificationAppImage)
+          .dependsOn(kafka)
+          .withNetwork(network)
+          .withNetworkAliases(""master"")
+          .withEnv(""ROLE"", ""master"")
+          .withEnv(""MASTER_HOST"", ""master"");
+
+  @Rule
+  public GenericContainer verificationAppWorker =
+      new GenericContainer(verificationAppImage)
+          .dependsOn(kafka, verificationAppMaster)
+          .withNetwork(network)
+          .withNetworkAliases(""worker"")
+          .withEnv(""ROLE"", ""worker"")
+          .withEnv(""MASTER_HOST"", ""master"");
+
+  @Test
+  public void run() throws Exception {
+    final String kafkaAddress = kafka.getBootstrapServers();
+    final ExecutorService kafkaIoExecutor = Executors.newCachedThreadPool();
+
+    kafkaIoExecutor.submit(new ProduceCommands(kafkaAddress));
+    Future<List<StateSnapshot>> stateSnapshotOutputs =
+        kafkaIoExecutor.submit(new ConsumeStateSnapshots(kafkaAddress));
+
+    assertThat(
+        stateSnapshotOutputs.get(1, TimeUnit.MINUTES),
+        hasItems(
+            stateSnapshot(fnAddress(0, ""id-1""), 100),
+            stateSnapshot(fnAddress(0, ""id-2""), 300),
+            stateSnapshot(fnAddress(1, ""id-3""), 200),
+            stateSnapshot(fnAddress(0, ""id-2""), 350)));
+  }
+
+  // =================================================================================
+  //  Kafka IO utility classes and methods
+  // =================================================================================
+
+  private static class ProduceCommands implements Runnable {
+    private final String kafkaAddress;
+
+    ProduceCommands(String kafkaAddress) {
+      this.kafkaAddress = kafkaAddress;
+    }
+
+    @Override
+    public void run() {
+      Producer<FnAddress, Command> commandProducer = kafkaCommandProducer(kafkaAddress);
+      produceCommandToKafka(commandProducer, modifyAction(fnAddress(0, ""id-1""), 100));
+      produceCommandToKafka(commandProducer, modifyAction(fnAddress(0, ""id-2""), 300));
+      produceCommandToKafka(commandProducer, modifyAction(fnAddress(1, ""id-3""), 200));
+      produceCommandToKafka(
+          commandProducer,
+          sendAction(fnAddress(1, ""id-2""), modifyAction(fnAddress(0, ""id-2""), 50)));
+      produceCommandToKafka(
+          commandProducer, sendAction(fnAddress(0, ""id-1""), noOpAction(fnAddress(1, ""id-1""))));
+      commandProducer.flush();
+    }
+  }
+
+  private static class ConsumeStateSnapshots implements Callable<List<StateSnapshot>> {
+
+    private final String kafkaAddress;
+
+    ConsumeStateSnapshots(String kafkaAddress) {
+      this.kafkaAddress = kafkaAddress;
+    }
+
+    @Override
+    public List<StateSnapshot> call() throws Exception {
+      Consumer<FnAddress, StateSnapshot> stateSnapshotConsumer =
+          kafkaStateSnapshotConsumer(kafkaAddress);
+
+      final int expectedOutputs = 4;
+      List<StateSnapshot> responses = new ArrayList<>(expectedOutputs);
+      while (responses.size() < expectedOutputs) {
+        ConsumerRecords<FnAddress, StateSnapshot> stateSnapshots =
+            stateSnapshotConsumer.poll(Duration.ofMillis(100));
+        for (ConsumerRecord<FnAddress, StateSnapshot> stateSnapshot : stateSnapshots) {
+          responses.add(stateSnapshot.value());
+        }
+      }
+
+      return responses;
+    }
+  }
+
+  private static Producer<FnAddress, Command> kafkaCommandProducer(String bootstrapServers) {
+    Properties props = new Properties();
+    props.put(""bootstrap.servers"", bootstrapServers);
+
+    return new KafkaProducer<>(
+        props, new FnAddressSerializerDeserializer(), new CommandSerializer());
+  }
+
+  private static Consumer<FnAddress, StateSnapshot> kafkaStateSnapshotConsumer(
+      String bootstrapServers) {
+    Properties consumerProps = new Properties();
+    consumerProps.setProperty(""bootstrap.servers"", bootstrapServers);
+    consumerProps.setProperty(""group.id"", ""sanity-itcase"");
+    consumerProps.setProperty(""auto.offset.reset"", ""earliest"");
+
+    KafkaConsumer<FnAddress, StateSnapshot> consumer =
+        new KafkaConsumer<>(
+            consumerProps, new FnAddressSerializerDeserializer(), new StateSnapshotDeserializer());
+    consumer.subscribe(Collections.singletonList(KafkaIO.STATE_SNAPSHOTS_TOPIC_NAME));
+
+    return consumer;
+  }
+
+  private static void produceCommandToKafka(
+      Producer<FnAddress, Command> producer, Command command) {
+    producer.send(new ProducerRecord<>(KafkaIO.COMMAND_TOPIC_NAME, command.getTarget(), command));
+  }
+
+  // =================================================================================
+  //  Protobuf message building utilities
+  // =================================================================================
+
+  private static StateSnapshot stateSnapshot(FnAddress fromFnAddress, int stateSnapshotValue) {
+    return StateSnapshot.newBuilder().setFrom(fromFnAddress).setState(stateSnapshotValue).build();
+  }
+
+  private static Command sendAction(FnAddress targetAddress, Command commandToSend) {
+    final Send sendAction = Send.newBuilder().addCommandToSend(commandToSend).build();
+
+    return Command.newBuilder().setTarget(targetAddress).setSend(sendAction).build();
+  }
+
+  private static Command modifyAction(FnAddress targetAddress, int stateValueDelta) {
+    final Modify modifyAction = Modify.newBuilder().setDelta(stateValueDelta).build();
+
+    return Command.newBuilder().setTarget(targetAddress).setModify(modifyAction).build();
+  }
+
+  private static Command noOpAction(FnAddress targetAddress) {
+    return Command.newBuilder().setTarget(targetAddress).setNoop(Noop.getDefaultInstance()).build();
+  }
+
+  private static FnAddress fnAddress(int typeIndex, String fnId) {
+    if (typeIndex > Constants.FUNCTION_TYPES.length - 1) {
+      throw new IndexOutOfBoundsException(
+          ""Type index is out of bounds. Max index: "" + (Constants.FUNCTION_TYPES.length - 1));
+    }
+    return FnAddress.newBuilder().setType(typeIndex).setId(fnId).build();
+  }
+
+  // =================================================================================
+  //  Kafka ingress / egress serde
+  // =================================================================================
+
+  public static final class FnAddressSerializerDeserializer","[{'comment': 'Is it possible to replace all of these with a single `ProtobufSerializer<T extends Message>`,\r\nnot a big deal with it is not easy doable.', 'commenter': 'igalshilman'}, {'comment': 'Turns out there is a nice way to do that!\r\nSee fdcdef1c1a4697bbecb0d9949d002dbe76551f44 for the fix.', 'commenter': 'tzulitai'}]"
28,statefun-integration-tests/statefun-sanity-itcase/src/test/java/org/apache/flink/statefun/itcases/sanity/SanityVerificationITCase.java,"@@ -0,0 +1,287 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.statefun.itcases.sanity;
+
+import static org.hamcrest.CoreMatchers.hasItems;
+import static org.hamcrest.MatcherAssert.assertThat;
+
+import java.nio.file.Paths;
+import java.time.Duration;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import java.util.Map;
+import java.util.Properties;
+import java.util.concurrent.Callable;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.Future;
+import java.util.concurrent.TimeUnit;
+import org.apache.flink.statefun.itcases.sanity.generated.VerificationMessages.Command;
+import org.apache.flink.statefun.itcases.sanity.generated.VerificationMessages.FnAddress;
+import org.apache.flink.statefun.itcases.sanity.generated.VerificationMessages.Modify;
+import org.apache.flink.statefun.itcases.sanity.generated.VerificationMessages.Noop;
+import org.apache.flink.statefun.itcases.sanity.generated.VerificationMessages.Send;
+import org.apache.flink.statefun.itcases.sanity.generated.VerificationMessages.StateSnapshot;
+import org.apache.kafka.clients.consumer.Consumer;
+import org.apache.kafka.clients.consumer.ConsumerRecord;
+import org.apache.kafka.clients.consumer.ConsumerRecords;
+import org.apache.kafka.clients.consumer.KafkaConsumer;
+import org.apache.kafka.clients.producer.KafkaProducer;
+import org.apache.kafka.clients.producer.Producer;
+import org.apache.kafka.clients.producer.ProducerRecord;
+import org.apache.kafka.common.serialization.Deserializer;
+import org.apache.kafka.common.serialization.Serializer;
+import org.junit.Rule;
+import org.junit.Test;
+import org.testcontainers.containers.GenericContainer;
+import org.testcontainers.containers.KafkaContainer;
+import org.testcontainers.containers.Network;
+import org.testcontainers.images.builder.ImageFromDockerfile;
+
+/**
+ * Sanity verification integration test based on the {@link SanityVerificationModule} application.
+ *
+ * <p>The integration test setups Kafka brokers and the verification application using Docker, sends
+ * a few commands to Kafka to be consumed by the application, and finally verifies that outputs sent
+ * to Kafka from the application are correct.
+ */
+public class SanityVerificationITCase {","[{'comment': 'With what parallelism does this job starts?\r\nDo you think should the sanity job start with parallelism > 1 ?\r\n\r\n', 'commenter': 'igalshilman'}]"
28,pom.xml,"@@ -55,6 +55,7 @@ under the License.
         <module>statefun-examples</module>
         <module>statefun-flink</module>
         <module>statefun-quickstart</module>
+        <module>statefun-integration-tests</module>","[{'comment': ""It seems like and end to end test, don't you think?\r\n"", 'commenter': 'igalshilman'}]"
28,statefun-integration-tests/statefun-sanity-itcase/src/test/java/org/apache/flink/statefun/itcases/sanity/SanityVerificationITCase.java,"@@ -0,0 +1,287 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.statefun.itcases.sanity;
+
+import static org.hamcrest.CoreMatchers.hasItems;
+import static org.hamcrest.MatcherAssert.assertThat;
+
+import java.nio.file.Paths;
+import java.time.Duration;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import java.util.Map;
+import java.util.Properties;
+import java.util.concurrent.Callable;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.Future;
+import java.util.concurrent.TimeUnit;
+import org.apache.flink.statefun.itcases.sanity.generated.VerificationMessages.Command;
+import org.apache.flink.statefun.itcases.sanity.generated.VerificationMessages.FnAddress;
+import org.apache.flink.statefun.itcases.sanity.generated.VerificationMessages.Modify;
+import org.apache.flink.statefun.itcases.sanity.generated.VerificationMessages.Noop;
+import org.apache.flink.statefun.itcases.sanity.generated.VerificationMessages.Send;
+import org.apache.flink.statefun.itcases.sanity.generated.VerificationMessages.StateSnapshot;
+import org.apache.kafka.clients.consumer.Consumer;
+import org.apache.kafka.clients.consumer.ConsumerRecord;
+import org.apache.kafka.clients.consumer.ConsumerRecords;
+import org.apache.kafka.clients.consumer.KafkaConsumer;
+import org.apache.kafka.clients.producer.KafkaProducer;
+import org.apache.kafka.clients.producer.Producer;
+import org.apache.kafka.clients.producer.ProducerRecord;
+import org.apache.kafka.common.serialization.Deserializer;
+import org.apache.kafka.common.serialization.Serializer;
+import org.junit.Rule;
+import org.junit.Test;
+import org.testcontainers.containers.GenericContainer;
+import org.testcontainers.containers.KafkaContainer;
+import org.testcontainers.containers.Network;
+import org.testcontainers.images.builder.ImageFromDockerfile;
+
+/**
+ * Sanity verification integration test based on the {@link SanityVerificationModule} application.
+ *
+ * <p>The integration test setups Kafka brokers and the verification application using Docker, sends
+ * a few commands to Kafka to be consumed by the application, and finally verifies that outputs sent
+ * to Kafka from the application are correct.
+ */
+public class SanityVerificationITCase {
+
+  private static final String CONFLUENT_PLATFORM_VERSION = ""5.0.3"";
+
+  private static final ImageFromDockerfile verificationAppImage =
+      new ImageFromDockerfile(""statefun-sanity-itcase"")
+          .withFileFromClasspath(""Dockerfile"", ""Dockerfile"")
+          .withFileFromPath(""."", Paths.get(System.getProperty(""user.dir"") + ""/target/""));
+
+  @Rule public Network network = Network.newNetwork();
+
+  @Rule
+  public KafkaContainer kafka =
+      new KafkaContainer(CONFLUENT_PLATFORM_VERSION)
+          .withNetwork(network)
+          .withNetworkAliases(""kafka-broker"");
+
+  @Rule
+  public GenericContainer verificationAppMaster =
+      new GenericContainer(verificationAppImage)
+          .dependsOn(kafka)
+          .withNetwork(network)
+          .withNetworkAliases(""master"")
+          .withEnv(""ROLE"", ""master"")
+          .withEnv(""MASTER_HOST"", ""master"");
+
+  @Rule
+  public GenericContainer verificationAppWorker =
+      new GenericContainer(verificationAppImage)
+          .dependsOn(kafka, verificationAppMaster)
+          .withNetwork(network)
+          .withNetworkAliases(""worker"")
+          .withEnv(""ROLE"", ""worker"")
+          .withEnv(""MASTER_HOST"", ""master"");
+
+  @Test
+  public void run() throws Exception {
+    final String kafkaAddress = kafka.getBootstrapServers();
+    final ExecutorService kafkaIoExecutor = Executors.newCachedThreadPool();
+
+    kafkaIoExecutor.submit(new ProduceCommands(kafkaAddress));
+    Future<List<StateSnapshot>> stateSnapshotOutputs =
+        kafkaIoExecutor.submit(new ConsumeStateSnapshots(kafkaAddress));
+
+    assertThat(
+        stateSnapshotOutputs.get(1, TimeUnit.MINUTES),
+        hasItems(","[{'comment': ""Suggestion:\r\nIt could be nicer if we had thecommands present at the same level that the verification is present.\r\nFor example:\r\n\r\n```\r\nassertThat(\r\n       sending(\r\n           modifiyAction(address1, 100),\r\n           modifiyAction(address2, 200))\r\n     , results(\r\n               stateSnapshot(address1, 100)\r\n               stateSnapshot(address2, 200))\r\n        );\r\n```\r\n\r\nIt is fine the way it is right now, I'm sure will iterate on these kind of tests many times in the future"", 'commenter': 'igalshilman'}]"
42,statefun-flink/statefun-flink-core/src/main/java/org/apache/flink/statefun/flink/core/state/FlinkTableAccessor.java,"@@ -55,4 +57,19 @@ public void remove(K key) {
       throw new RuntimeException(e);
     }
   }
+
+  @Override
+  public Iterable<Map.Entry<K, V>> view() {
+    try {
+      Iterable<Map.Entry<K, V>> entries = handle.entries();
+      return entries == null ? Collections.emptyList() : entries;","[{'comment': 'Actually, I think Flink user `MapState` never returns `null` for `entries()` / `keys()` / `values()`.\r\n\r\nThe actual `MapState` handle that the user gets is always a `UserFacingMapState` in Flink that wraps the actual RocksDB / heap map state handle, which uses an empty map state if the wrapped state handle returns `null` for those methods.', 'commenter': 'tzulitai'}, {'comment': 'Looks like I have some Flink jobs I can remove some null checks from :) ', 'commenter': 'sjwiesman'}]"
42,statefun-flink/statefun-flink-core/src/main/java/org/apache/flink/statefun/flink/core/state/FlinkTableAccessor.java,"@@ -55,4 +57,19 @@ public void remove(K key) {
       throw new RuntimeException(e);
     }
   }
+
+  @Override
+  public Iterable<Map.Entry<K, V>> view() {","[{'comment': 'Do you intend the returned iterable to be modifiable (i.e. the iterator supports `remove()`)?\r\nIf so, maybe we should just call this `entries()` instead.\r\n\r\nWe called the method ""view"" in the `PersistedAppendingBuffer` to emphasize the fact that the returned iterable is unmodifiable.', 'commenter': 'tzulitai'}]"
43,statefun-flink/statefun-flink-core/src/main/protobuf/http-function.proto,"@@ -105,11 +105,34 @@ message FromFunction {
         google.protobuf.Any argument = 2;
     }
 
+    // DelayedInvocation represents a delayed remote function call with a target address, an argument
+    // and a delay in milliseconds, after which this message to be sent.
+    message DelayedInvocation {
+        // the amount of milliseconds to wait before sending this message
+        int64 delay_in_ms = 1;
+        // the target address to send this message to
+        Address target = 2;
+        // the invocation argument
+        google.protobuf.Any argument = 3;
+    }
+
+    // EgressMessage an argument to forward to an egress identified with an egress_identifier.
+    // an ingress identifier corresponds to the Java SDK class EgressIdentifier(namespace, name, consumedType)
+    // where the consumed type is a google.protobuf.Any and the namespace and name are derrived
+    // from the egress_identifier.
+    message EgressMessage {
+        // The target egress id in the form of <namespace>/<name>
+        string egress_identifier = 1;","[{'comment': 'Should we be consistent with the `Address` message, where the `namespace` and `name` are 2 separate fields?', 'commenter': 'tzulitai'}, {'comment': 'Either that, or we change the `Address` message to use the Python / YAML way of formatting namespace + name pairs: `<namespace>/<name>` and do the parsing in the `RequestReplyFunction`', 'commenter': 'tzulitai'}]"
43,statefun-flink/statefun-flink-core/src/main/java/org/apache/flink/statefun/flink/core/reqreply/RequestReplyFunction.java,"@@ -72,6 +75,9 @@
   private final PersistedTable<String, byte[]> managedStates =
       PersistedTable.of(""states"", String.class, byte[].class);
 
+  private final SingleThreadedLruCache<String, EgressIdentifier<Any>> egressIdentifierCache =
+      new SingleThreadedLruCache<>(16);","[{'comment': 'nit: move the 16 to a named class static final variable.', 'commenter': 'tzulitai'}]"
43,statefun-flink/statefun-flink-core/src/test/java/org/apache/flink/statefun/flink/core/reqreply/RequestReplyFunctionTest.java,"@@ -157,6 +164,52 @@ public void stateIsModified() {
     assertThat(client.capturedState(0), is(ByteString.copyFromUtf8(""hello"")));
   }
 
+  @Test
+  public void delayedMessages() {
+    functionUnderTest.invoke(context, Any.getDefaultInstance());
+
+    // A message returned from the function
+    // that asks to put ""hello"" into the session state.","[{'comment': 'the comments here is not coherent with what is being done in the test.', 'commenter': 'tzulitai'}]"
43,statefun-flink/statefun-flink-core/src/test/java/org/apache/flink/statefun/flink/core/reqreply/RequestReplyFunctionTest.java,"@@ -157,6 +164,52 @@ public void stateIsModified() {
     assertThat(client.capturedState(0), is(ByteString.copyFromUtf8(""hello"")));
   }
 
+  @Test
+  public void delayedMessages() {
+    functionUnderTest.invoke(context, Any.getDefaultInstance());
+
+    // A message returned from the function
+    // that asks to put ""hello"" into the session state.
+    FromFunction response =
+        FromFunction.newBuilder()
+            .setInvocationResult(
+                InvocationResponse.newBuilder()
+                    .addDelayedInvocations(
+                        DelayedInvocation.newBuilder()
+                            .setArgument(Any.getDefaultInstance())
+                            .setDelayInMs(1)
+                            .build()))
+            .build();
+
+    functionUnderTest.invoke(context, successfulAsyncOperation(response));
+
+    assertFalse(context.delayed.isEmpty());
+    assertEquals(Duration.ofMillis(1), context.delayed.get(0).getKey());
+  }
+
+  @Test
+  public void egressIsSent() {
+    functionUnderTest.invoke(context, Any.getDefaultInstance());
+
+    // A message returned from the function
+    // that asks to put ""hello"" into the session state.","[{'comment': 'same here: this comment is not coherent with the code', 'commenter': 'tzulitai'}]"
52,statefun-python-sdk/setup.py,"@@ -0,0 +1,38 @@
+################################################################################
+#  Licensed to the Apache Software Foundation (ASF) under one
+#  or more contributor license agreements.  See the NOTICE file
+#  distributed with this work for additional information
+#  regarding copyright ownership.  The ASF licenses this file
+#  to you under the Apache License, Version 2.0 (the
+#  ""License""); you may not use this file except in compliance
+#  with the License.  You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+#  Unless required by applicable law or agreed to in writing, software
+#  distributed under the License is distributed on an ""AS IS"" BASIS,
+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+#  See the License for the specific language governing permissions and
+# limitations under the License.
+################################################################################
+
+from setuptools import setup
+
+setup(
+    name='statefun',
+    version='1.1.0',","[{'comment': 'I think this should follow the version of the `master` branch, i.e. `1.1-SNAPSHOT`.\r\nThis version string would then be updated once we cut release candidate branches (I can update the `create-release-branch.sh` script for that).', 'commenter': 'tzulitai'}]"
52,statefun-python-sdk/setup.py,"@@ -0,0 +1,38 @@
+################################################################################
+#  Licensed to the Apache Software Foundation (ASF) under one
+#  or more contributor license agreements.  See the NOTICE file
+#  distributed with this work for additional information
+#  regarding copyright ownership.  The ASF licenses this file
+#  to you under the Apache License, Version 2.0 (the
+#  ""License""); you may not use this file except in compliance
+#  with the License.  You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+#  Unless required by applicable law or agreed to in writing, software
+#  distributed under the License is distributed on an ""AS IS"" BASIS,
+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+#  See the License for the specific language governing permissions and
+# limitations under the License.
+################################################################################
+
+from setuptools import setup
+
+setup(
+    name='statefun',
+    version='1.1.0',
+    packages=[""statefun""],
+    url='https://github.com/apache/flink-statefun',
+    license='https://www.apache.org/licenses/LICENSE-2.0',
+    author='Apache Software Foundation',
+    author_email='dev@flink.apache.org',
+    description='Python SDK for Flink Stateful functions',
+    install_requires=['protobuf>=3.11.3,<4.0.0'],","[{'comment': 'Why `> 3.11.3`? Statefun itself uses 3.7.1.', 'commenter': 'tzulitai'}]"
52,statefun-python-sdk/setup.py,"@@ -0,0 +1,38 @@
+################################################################################
+#  Licensed to the Apache Software Foundation (ASF) under one
+#  or more contributor license agreements.  See the NOTICE file
+#  distributed with this work for additional information
+#  regarding copyright ownership.  The ASF licenses this file
+#  to you under the Apache License, Version 2.0 (the
+#  ""License""); you may not use this file except in compliance
+#  with the License.  You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+#  Unless required by applicable law or agreed to in writing, software
+#  distributed under the License is distributed on an ""AS IS"" BASIS,
+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+#  See the License for the specific language governing permissions and
+# limitations under the License.
+################################################################################
+
+from setuptools import setup
+
+setup(
+    name='statefun',
+    version='1.1.0',
+    packages=[""statefun""],
+    url='https://github.com/apache/flink-statefun',
+    license='https://www.apache.org/licenses/LICENSE-2.0',
+    author='Apache Software Foundation',
+    author_email='dev@flink.apache.org',
+    description='Python SDK for Flink Stateful functions',","[{'comment': ""```suggestion\r\n    description='Python SDK for Apache Flink Stateful functions',\r\n```"", 'commenter': 'tzulitai'}]"
52,statefun-python-sdk/setup.py,"@@ -0,0 +1,38 @@
+################################################################################
+#  Licensed to the Apache Software Foundation (ASF) under one
+#  or more contributor license agreements.  See the NOTICE file
+#  distributed with this work for additional information
+#  regarding copyright ownership.  The ASF licenses this file
+#  to you under the Apache License, Version 2.0 (the
+#  ""License""); you may not use this file except in compliance
+#  with the License.  You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+#  Unless required by applicable law or agreed to in writing, software
+#  distributed under the License is distributed on an ""AS IS"" BASIS,
+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+#  See the License for the specific language governing permissions and
+# limitations under the License.
+################################################################################
+
+from setuptools import setup
+
+setup(
+    name='statefun',","[{'comment': ""I'm not sure, but I think we should call the package `apache-flink-statefun`.\r\nThis is to be consistent with the Flink Python package naming, where we do `pip install apache-flink` (https://pypi.org/project/apache-flink/).\r\nWhat do you think?"", 'commenter': 'tzulitai'}]"
52,statefun-python-sdk/statefun/kafka_egress_pb2.py,"@@ -0,0 +1,100 @@
+# -*- coding: utf-8 -*-
+################################################################################
+#  Licensed to the Apache Software Foundation (ASF) under one
+#  or more contributor license agreements.  See the NOTICE file
+#  distributed with this work for additional information
+#  regarding copyright ownership.  The ASF licenses this file
+#  to you under the Apache License, Version 2.0 (the
+#  ""License""); you may not use this file except in compliance
+#  with the License.  You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+#  Unless required by applicable law or agreed to in writing, software
+#  distributed under the License is distributed on an ""AS IS"" BASIS,
+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+#  See the License for the specific language governing permissions and
+# limitations under the License.
+################################################################################
+# Generated by the protocol buffer compiler.  DO NOT EDIT!","[{'comment': 'Is it possible to incorporate building this protobuf message in some build process / stage?', 'commenter': 'tzulitai'}]"
52,statefun-python-sdk/statefun/request_reply_pb2.py,"@@ -0,0 +1,643 @@
+# -*- coding: utf-8 -*-
+################################################################################
+#  Licensed to the Apache Software Foundation (ASF) under one
+#  or more contributor license agreements.  See the NOTICE file
+#  distributed with this work for additional information
+#  regarding copyright ownership.  The ASF licenses this file
+#  to you under the Apache License, Version 2.0 (the
+#  ""License""); you may not use this file except in compliance
+#  with the License.  You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+#  Unless required by applicable law or agreed to in writing, software
+#  distributed under the License is distributed on an ""AS IS"" BASIS,
+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+#  See the License for the specific language governing permissions and
+# limitations under the License.
+################################################################################
+# Generated by the protocol buffer compiler.  DO NOT EDIT!
+# source: request-reply.proto
+
+from google.protobuf import descriptor as _descriptor
+from google.protobuf import message as _message
+from google.protobuf import reflection as _reflection
+from google.protobuf import symbol_database as _symbol_database
+# @@protoc_insertion_point(imports)
+
+_sym_db = _symbol_database.Default()
+
+
+from google.protobuf import any_pb2 as google_dot_protobuf_dot_any__pb2
+
+
+DESCRIPTOR = _descriptor.FileDescriptor(","[{'comment': 'Same here: Is it possible to incorporate building this protobuf message in some build process / stage?', 'commenter': 'tzulitai'}]"
52,statefun-python-sdk/tests/examples_pb2.py,"@@ -0,0 +1,124 @@
+# -*- coding: utf-8 -*-
+################################################################################
+#  Licensed to the Apache Software Foundation (ASF) under one
+#  or more contributor license agreements.  See the NOTICE file
+#  distributed with this work for additional information
+#  regarding copyright ownership.  The ASF licenses this file
+#  to you under the Apache License, Version 2.0 (the
+#  ""License""); you may not use this file except in compliance
+#  with the License.  You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+#  Unless required by applicable law or agreed to in writing, software
+#  distributed under the License is distributed on an ""AS IS"" BASIS,
+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+#  See the License for the specific language governing permissions and
+# limitations under the License.
+################################################################################
+# Generated by the protocol buffer compiler.  DO NOT EDIT!
+# source: flask.proto
+
+from google.protobuf import descriptor as _descriptor
+from google.protobuf import message as _message
+from google.protobuf import reflection as _reflection
+from google.protobuf import symbol_database as _symbol_database
+# @@protoc_insertion_point(imports)
+
+_sym_db = _symbol_database.Default()
+
+
+
+
+DESCRIPTOR = _descriptor.FileDescriptor(","[{'comment': 'And here: I think we should probably incorporate code generation in build processes, and have them ignored by git.', 'commenter': 'tzulitai'}]"
52,statefun-python-sdk/examples/k8s/Dockerfile.python-worker,"@@ -0,0 +1,34 @@
+#
+# Licensed to the Apache Software Foundation (ASF) under one or more
+# contributor license agreements.  See the NOTICE file distributed with
+# this work for additional information regarding copyright ownership.
+# The ASF licenses this file to You under the Apache License, Version 2.0
+# (the ""License""); you may not use this file except in compliance with
+# the License.  You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an ""AS IS"" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+FROM python:3.7-alpine
+
+RUN mkdir -p /app
+WORKDIR /app
+
+# The following two lines would be removed once statefun would be published to PyPI","[{'comment': 'Do you intend to let this example work with a locally built Python SDK?\r\nIf so, I think the example should follow the Java examples, where by default they work without pulling packages from Maven central.\r\n\r\nMaybe adding an `LOCAL_WHL_PATH` option which by default is set to the path of the locally built Python SDK distribution?', 'commenter': 'tzulitai'}]"
54,statefun-docs/src/main/resources/module.yaml,"@@ -0,0 +1,31 @@
+# Licensed to the Apache Software Foundation (ASF) under one or more
+# contributor license agreements.  See the NOTICE file distributed with
+# this work for additional information regarding copyright ownership.
+# The ASF licenses this file to You under the Apache License, Version 2.0
+# (the ""License""); you may not use this file except in compliance with
+# the License.  You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an ""AS IS"" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+# This file is the base for the Apache Flink configuration
+
+module:
+  meta:
+    type: remote
+  spec:
+    functions:
+    - function:
+        meta:
+          kind: http
+          type: flink/greeter
+        spec:
+          endpoint: http://greeter:8000/statefun
+          states:
+          - seen_count","[{'comment': 'I think that there is tab missing.', 'commenter': 'igalshilman'}]"
54,statefun-docs/src/main/resources/module.yaml,"@@ -0,0 +1,31 @@
+# Licensed to the Apache Software Foundation (ASF) under one or more
+# contributor license agreements.  See the NOTICE file distributed with
+# this work for additional information regarding copyright ownership.
+# The ASF licenses this file to You under the Apache License, Version 2.0
+# (the ""License""); you may not use this file except in compliance with
+# the License.  You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an ""AS IS"" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+# This file is the base for the Apache Flink configuration
+
+module:
+  meta:
+    type: remote
+  spec:
+    functions:
+    - function:
+        meta:
+          kind: http
+          type: flink/greeter","[{'comment': 'can we not use ""flink"" as the namespace?\r\nI\'m afraid this would confuse some folks to think that this is a flink thing.\r\nespecially when we have `kind` and `type` and the distinction is somewhat blurry to a new user.\r\nPerhaps something like ""example/greeter"" ?', 'commenter': 'igalshilman'}]"
54,statefun-docs/src/main/python/Delayed.py,"@@ -0,0 +1,44 @@
+################################################################################
+#  Licensed to the Apache Software Foundation (ASF) under one
+#  or more contributor license agreements.  See the NOTICE file
+#  distributed with this work for additional information
+#  regarding copyright ownership.  The ASF licenses this file
+#  to you under the Apache License, Version 2.0 (the
+#  ""License""); you may not use this file except in compliance
+#  with the License.  You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+#  Unless required by applicable law or agreed to in writing, software
+#  distributed under the License is distributed on an ""AS IS"" BASIS,
+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+#  See the License for the specific language governing permissions and
+# limitations under the License.
+################################################################################
+
+from google.protobuf.any_pb2 import Any
+from datetime import timedelta
+from statefun import StatefulFunctions
+
+functions = StatefulFunctions()
+
+@functions.bind(""flink/delayed"")
+def delayed(context, message):
+    """"""A function that sends itself a message after a delay """"""
+
+    if message.Is(Message.DESCRIPTOR):","[{'comment': 'can `Message` be called something else? not to confuse with `Protobuf` message.', 'commenter': 'igalshilman'}]"
54,statefun-docs/docs/sdk/python.rst,"@@ -0,0 +1,170 @@
+.. Licensed to the Apache Software Foundation (ASF) under one
+   or more contributor license agreements.  See the NOTICE file
+   distributed with this work for additional information
+   regarding copyright ownership.  The ASF licenses this file
+   to you under the Apache License, Version 2.0 (the
+   ""License""); you may not use this file except in compliance
+   with the License.  You may obtain a copy of the License at
+   http://www.apache.org/licenses/LICENSE-2.0
+   Unless required by applicable law or agreed to in writing,
+   software distributed under the License is distributed on an
+   ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+   KIND, either express or implied.  See the License for the
+   specific language governing permissions and limitations
+   under the License.
+
+.. _python:
+
+######
+Python
+######
+
+Stateful functions are the building blocks of applications; they are atomic units of isolation, distribution, and persistence.
+As objects, they encapsulate the state of a single entity (e.g., a specific user, device, or session) and encode its behavior.
+Stateful functions can interact with each other, and external systems, through message passing.
+The Python SDK is supported as a :ref:`remote_module`.
+
+To get started, add the Python SDK as a dependency to your application.
+
+.. code-block:: bash
+
+    apache-flink-statefun=={version}
+
+.. contents:: :local:
+
+Defining A Stateful Function
+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
+
+A stateful function is any function that that takes two parameters, a ``context`` and ``message``.
+The function is bound to the runtime through the stateful functions decorator.
+The following is an example of a simple hello world function.
+
+.. literalinclude:: ../../src/main/python/HelloWorld.py
+    :language: python
+    :lines: 19-
+
+This code declares a function with in the namespace ``flink`` and of type ``hello`` and binds it to the ``hello_function`` Python instance.
+
+Messages's are untyped and passed through the system as ``google.protobuf.Any`` so one function can potentially process multiple types of messages.
+
+The ``context`` provides metadata about the current message and function, and is how you can call other functions or external systems.
+A full reference of all methods supported by the context object are listed at the :ref:`bottom of this page <context_reference>`.
+
+Type Hints
+==========
+
+If the function has a static set of known supported types, they may be specified as `type hints <https://docs.python.org/3/library/typing.html>`_.
+This includes `union types <https://docs.python.org/3/library/typing.html#typing.Union>`_ for functions that support multiple input message types.
+
+
+.. literalinclude:: ../../src/main/python/TypeHint.py
+    :language: python
+    :lines: 19-
+
+Function Types and Messaging
+^^^^^^^^^^^^^^^^^^^^^^^^^^^^
+
+The decorator ``bind`` registers each function with the runtime under a function type.","[{'comment': 'perhaps we should also mention that it is also possible to call `functions.register(typename, fun)` is decorating is not possible.', 'commenter': 'igalshilman'}]"
54,statefun-docs/docs/sdk/java/index.rst,"@@ -40,52 +58,32 @@ Input's are untyped and passed through the system as a ``java.lang.Object`` so o
 The ``Context`` provides metadata about the current message and function, and is how you can call other functions or external systems.
 Functions are invoked based on a function type and unique identifier.
 
-Function Type's and Identifiers
-^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
+Function Types and Messaging
+^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 
-In a local environment, the address of an object is the same as a reference to it.
-But in a distributed system, objects may be spread across multiple machines and may or may not be active at any given moment.
+In Java, function types are defined as a stringly typed reference containing a namespace and name.","[{'comment': 'stringly -> strongly?', 'commenter': 'igalshilman'}, {'comment': 'No, I meant ""stringly"". A function type is just a string. ', 'commenter': 'sjwiesman'}, {'comment': ""I'll add maybe italics or quotes. "", 'commenter': 'sjwiesman'}]"
54,statefun-docs/docs/deployment_operations/packaging.rst,"@@ -28,14 +28,15 @@ The recommended deployment mode for Stateful Functions applications is to build
 This way, user code does not need to package any Apache Flink components.
 The provided base image allows teams to package their applications with all the necessary runtime dependencies quickly.
 
-Below is an example Dockerfile for building a Stateful Functions image for an application called ``statefun-example``.
+Below is an example Dockerfile for building a Stateful Functions image with both an :ref:`embedded module <embedded_module>` and a :ref:`remote module <remote_module>` for an application called ``statefun-example``.
 
-.. code-block:: java
+.. code-block:: dockerfile
 
     FROM statefun
 
     RUN mkdir -p /opt/statefun/modules/statefun-example
     COPY target/statefun-example*jar /opt/statefun/modules/statefun-example/
+    COPY module.yaml /opt/statefun/modules/remote/module.yaml","[{'comment': 'are you missing a `mkdir -p /opt/statefun/modules/remote` ?', 'commenter': 'igalshilman'}]"
54,statefun-docs/src/main/resources/module.yaml,"@@ -0,0 +1,31 @@
+# Licensed to the Apache Software Foundation (ASF) under one or more
+# contributor license agreements.  See the NOTICE file distributed with
+# this work for additional information regarding copyright ownership.
+# The ASF licenses this file to You under the Apache License, Version 2.0
+# (the ""License""); you may not use this file except in compliance with
+# the License.  You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an ""AS IS"" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+# This file is the base for the Apache Flink configuration
+
+module:
+  meta:
+    type: remote
+  spec:
+    functions:
+    - function:
+        meta:
+          kind: http
+          type: flink/greeter
+        spec:
+          endpoint: http://greeter:8000/statefun
+          states:
+          - seen_count
+          maxNumBatchRequests: 500
+    timeout: 2m","[{'comment': '`timeout` is also missing a tab, and I think the `m` is incorrect (sorry I know it was in one of the examples previously).\r\nit should be `2min`', 'commenter': 'igalshilman'}]"
54,statefun-docs/src/main/resources/module.yaml,"@@ -0,0 +1,31 @@
+# Licensed to the Apache Software Foundation (ASF) under one or more
+# contributor license agreements.  See the NOTICE file distributed with
+# this work for additional information regarding copyright ownership.
+# The ASF licenses this file to You under the Apache License, Version 2.0
+# (the ""License""); you may not use this file except in compliance with
+# the License.  You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an ""AS IS"" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+# This file is the base for the Apache Flink configuration
+","[{'comment': 'missing `version: ""1.0""` above `module:`', 'commenter': 'igalshilman'}]"
54,statefun-docs/docs/concepts/index.rst,"@@ -0,0 +1,97 @@
+.. Licensed to the Apache Software Foundation (ASF) under one
+   or more contributor license agreements.  See the NOTICE file
+   distributed with this work for additional information
+   regarding copyright ownership.  The ASF licenses this file
+   to you under the Apache License, Version 2.0 (the
+   ""License""); you may not use this file except in compliance
+   with the License.  You may obtain a copy of the License at
+   http://www.apache.org/licenses/LICENSE-2.0
+   Unless required by applicable law or agreed to in writing,
+   software distributed under the License is distributed on an
+   ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+   KIND, either express or implied.  See the License for the
+   specific language governing permissions and limitations
+   under the License.
+
+.. _concepts:
+
+########
+Concepts
+########
+
+.. toctree::
+  :hidden:
+
+  logical
+
+Stateful Functions provides a framework for building event drivent applications.
+Here, we explain important aspects of Stateful Function’s architecture.
+
+.. contents:: :local:
+
+Event Ingress
+=============
+
+Stateful Function applications sit squarely in the event driven space, so the natural place to start is with getting events into the system.
+
+.. figure:: ../_static/images/concepts/statefun-app-ingress.svg
+    :width: 85%
+    :align: center
+
+In stateful functions, the component that ingests records into the system is called an event ingress.
+This can be anything from a Kafka topic, to a messsage queue, to an http request.
+Anything that can get data into the system and trigger the intitial functions to begin compution.","[{'comment': '```suggestion\r\nThis can be anything from a Kafka topic, to a messsage queue, to an http request -\r\nanything that can get data into the system and trigger the intitial functions to begin computation.\r\n```', 'commenter': 'tzulitai'}]"
54,statefun-docs/docs/concepts/index.rst,"@@ -0,0 +1,97 @@
+.. Licensed to the Apache Software Foundation (ASF) under one
+   or more contributor license agreements.  See the NOTICE file
+   distributed with this work for additional information
+   regarding copyright ownership.  The ASF licenses this file
+   to you under the Apache License, Version 2.0 (the
+   ""License""); you may not use this file except in compliance
+   with the License.  You may obtain a copy of the License at
+   http://www.apache.org/licenses/LICENSE-2.0
+   Unless required by applicable law or agreed to in writing,
+   software distributed under the License is distributed on an
+   ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+   KIND, either express or implied.  See the License for the
+   specific language governing permissions and limitations
+   under the License.
+
+.. _concepts:
+
+########
+Concepts
+########
+
+.. toctree::
+  :hidden:
+
+  logical
+
+Stateful Functions provides a framework for building event drivent applications.
+Here, we explain important aspects of Stateful Function’s architecture.
+
+.. contents:: :local:
+
+Event Ingress
+=============
+
+Stateful Function applications sit squarely in the event driven space, so the natural place to start is with getting events into the system.
+
+.. figure:: ../_static/images/concepts/statefun-app-ingress.svg
+    :width: 85%
+    :align: center
+
+In stateful functions, the component that ingests records into the system is called an event ingress.
+This can be anything from a Kafka topic, to a messsage queue, to an http request.
+Anything that can get data into the system and trigger the intitial functions to begin compution.
+
+Stateful Functions
+==================
+
+At the core of the diagram are the namesake stateful functions.
+
+.. figure:: ../_static/images/concepts/statefun-app-functions.svg
+    :width: 85%
+    :align: center
+
+Think of these as the building blocks for your service.
+They can message each other arbitrarily, which is one way in which this framework moves away from the traditional stream processing view of the world.
+Instead of building up a static dataflow DAG, these functions can communicate with each other in arbitrary, potentially cyclic, even round trip ways.
+
+If you are familiar with actor programming, this does share certain similarities in its ability to dynamically message between components.
+However, there are a number of significant differences.
+
+Persisted Values
+================
+
+The first is that all functions have locally embedded state, known as persisted values.","[{'comment': '```suggestion\r\nPersisted State\r\n================\r\n\r\nThe first is that all functions have locally embedded state, known as persisted states.\r\n```\r\n\r\nMaybe call these persisted states instead. Otherwise, the term persisted value now points to a very specific primitive, along side persisted tables / appending buffers, etc.', 'commenter': 'tzulitai'}, {'comment': 'Also not sure of the mention ""locally"" here. It seems to be a bit dangerous to use, considering that remote request-reply protocol functions do not really have their state available locally.\r\n\r\nHow about something along the lines of:\r\n`The first is that all functions have *something*-scoped state, known as persisted states.`\r\nI\'m afraid while I feel unsure about it, I also don\'t have much better suggestions 😅 ', 'commenter': 'tzulitai'}]"
54,statefun-docs/docs/concepts/index.rst,"@@ -0,0 +1,97 @@
+.. Licensed to the Apache Software Foundation (ASF) under one
+   or more contributor license agreements.  See the NOTICE file
+   distributed with this work for additional information
+   regarding copyright ownership.  The ASF licenses this file
+   to you under the Apache License, Version 2.0 (the
+   ""License""); you may not use this file except in compliance
+   with the License.  You may obtain a copy of the License at
+   http://www.apache.org/licenses/LICENSE-2.0
+   Unless required by applicable law or agreed to in writing,
+   software distributed under the License is distributed on an
+   ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+   KIND, either express or implied.  See the License for the
+   specific language governing permissions and limitations
+   under the License.
+
+.. _concepts:
+
+########
+Concepts
+########
+
+.. toctree::
+  :hidden:
+
+  logical
+
+Stateful Functions provides a framework for building event drivent applications.
+Here, we explain important aspects of Stateful Function’s architecture.
+
+.. contents:: :local:
+
+Event Ingress
+=============
+
+Stateful Function applications sit squarely in the event driven space, so the natural place to start is with getting events into the system.
+
+.. figure:: ../_static/images/concepts/statefun-app-ingress.svg
+    :width: 85%
+    :align: center
+
+In stateful functions, the component that ingests records into the system is called an event ingress.
+This can be anything from a Kafka topic, to a messsage queue, to an http request.
+Anything that can get data into the system and trigger the intitial functions to begin compution.
+
+Stateful Functions
+==================
+
+At the core of the diagram are the namesake stateful functions.
+
+.. figure:: ../_static/images/concepts/statefun-app-functions.svg
+    :width: 85%
+    :align: center
+
+Think of these as the building blocks for your service.
+They can message each other arbitrarily, which is one way in which this framework moves away from the traditional stream processing view of the world.
+Instead of building up a static dataflow DAG, these functions can communicate with each other in arbitrary, potentially cyclic, even round trip ways.
+
+If you are familiar with actor programming, this does share certain similarities in its ability to dynamically message between components.
+However, there are a number of significant differences.
+
+Persisted Values
+================
+
+The first is that all functions have locally embedded state, known as persisted values.
+
+.. figure:: ../_static/images/concepts/statefun-app-state.svg
+    :width: 85%
+    :align: center
+
+One of Apache Flink's core strengths is its ability to provide fault-tolerant local state.","[{'comment': 'Same comment here about ""local"".\r\nWhile it is true for all Flink function / operators, in Stateful Functions it\'s not always true.', 'commenter': 'tzulitai'}]"
54,statefun-docs/docs/concepts/index.rst,"@@ -0,0 +1,97 @@
+.. Licensed to the Apache Software Foundation (ASF) under one
+   or more contributor license agreements.  See the NOTICE file
+   distributed with this work for additional information
+   regarding copyright ownership.  The ASF licenses this file
+   to you under the Apache License, Version 2.0 (the
+   ""License""); you may not use this file except in compliance
+   with the License.  You may obtain a copy of the License at
+   http://www.apache.org/licenses/LICENSE-2.0
+   Unless required by applicable law or agreed to in writing,
+   software distributed under the License is distributed on an
+   ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+   KIND, either express or implied.  See the License for the
+   specific language governing permissions and limitations
+   under the License.
+
+.. _concepts:
+
+########
+Concepts
+########
+
+.. toctree::
+  :hidden:
+
+  logical
+
+Stateful Functions provides a framework for building event drivent applications.
+Here, we explain important aspects of Stateful Function’s architecture.
+
+.. contents:: :local:
+
+Event Ingress
+=============
+
+Stateful Function applications sit squarely in the event driven space, so the natural place to start is with getting events into the system.
+
+.. figure:: ../_static/images/concepts/statefun-app-ingress.svg
+    :width: 85%
+    :align: center
+
+In stateful functions, the component that ingests records into the system is called an event ingress.
+This can be anything from a Kafka topic, to a messsage queue, to an http request.
+Anything that can get data into the system and trigger the intitial functions to begin compution.
+
+Stateful Functions
+==================
+
+At the core of the diagram are the namesake stateful functions.
+
+.. figure:: ../_static/images/concepts/statefun-app-functions.svg
+    :width: 85%
+    :align: center
+
+Think of these as the building blocks for your service.
+They can message each other arbitrarily, which is one way in which this framework moves away from the traditional stream processing view of the world.
+Instead of building up a static dataflow DAG, these functions can communicate with each other in arbitrary, potentially cyclic, even round trip ways.
+
+If you are familiar with actor programming, this does share certain similarities in its ability to dynamically message between components.
+However, there are a number of significant differences.
+
+Persisted Values
+================
+
+The first is that all functions have locally embedded state, known as persisted values.
+
+.. figure:: ../_static/images/concepts/statefun-app-state.svg
+    :width: 85%
+    :align: center
+
+One of Apache Flink's core strengths is its ability to provide fault-tolerant local state.
+When inside a function, while it is performing some computation, you are always working with local state in local variables.
+
+Fault Tolerance
+===============
+
+For both state and messaging, Stateful Function's is still able to provide the exactly once guaruntees users expect from a modern data processessing framework.","[{'comment': '```suggestion\r\nFor both state and messaging, Stateful Functions is still able to provide the exactly-once guarantees users expect from a modern data processessing framework.\r\n```', 'commenter': 'tzulitai'}]"
54,statefun-docs/docs/concepts/index.rst,"@@ -0,0 +1,97 @@
+.. Licensed to the Apache Software Foundation (ASF) under one
+   or more contributor license agreements.  See the NOTICE file
+   distributed with this work for additional information
+   regarding copyright ownership.  The ASF licenses this file
+   to you under the Apache License, Version 2.0 (the
+   ""License""); you may not use this file except in compliance
+   with the License.  You may obtain a copy of the License at
+   http://www.apache.org/licenses/LICENSE-2.0
+   Unless required by applicable law or agreed to in writing,
+   software distributed under the License is distributed on an
+   ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+   KIND, either express or implied.  See the License for the
+   specific language governing permissions and limitations
+   under the License.
+
+.. _concepts:
+
+########
+Concepts
+########
+
+.. toctree::
+  :hidden:
+
+  logical
+
+Stateful Functions provides a framework for building event drivent applications.
+Here, we explain important aspects of Stateful Function’s architecture.
+
+.. contents:: :local:
+
+Event Ingress
+=============
+
+Stateful Function applications sit squarely in the event driven space, so the natural place to start is with getting events into the system.
+
+.. figure:: ../_static/images/concepts/statefun-app-ingress.svg
+    :width: 85%
+    :align: center
+
+In stateful functions, the component that ingests records into the system is called an event ingress.
+This can be anything from a Kafka topic, to a messsage queue, to an http request.
+Anything that can get data into the system and trigger the intitial functions to begin compution.
+
+Stateful Functions
+==================
+
+At the core of the diagram are the namesake stateful functions.
+
+.. figure:: ../_static/images/concepts/statefun-app-functions.svg
+    :width: 85%
+    :align: center
+
+Think of these as the building blocks for your service.
+They can message each other arbitrarily, which is one way in which this framework moves away from the traditional stream processing view of the world.
+Instead of building up a static dataflow DAG, these functions can communicate with each other in arbitrary, potentially cyclic, even round trip ways.
+
+If you are familiar with actor programming, this does share certain similarities in its ability to dynamically message between components.
+However, there are a number of significant differences.
+
+Persisted Values
+================
+
+The first is that all functions have locally embedded state, known as persisted values.
+
+.. figure:: ../_static/images/concepts/statefun-app-state.svg
+    :width: 85%
+    :align: center
+
+One of Apache Flink's core strengths is its ability to provide fault-tolerant local state.
+When inside a function, while it is performing some computation, you are always working with local state in local variables.
+
+Fault Tolerance
+===============
+
+For both state and messaging, Stateful Function's is still able to provide the exactly once guaruntees users expect from a modern data processessing framework.
+
+.. figure:: ../_static/images/concepts/statefun-app-fault-tolerance.svg
+    :width: 85%
+    :align: center
+
+In the case of failure, the entire state of the world (both persisted values and messages) are rolled back to simulate completely failure free execution.","[{'comment': '```suggestion\r\nIn the case of failure, the entire state of the world (both persisted states and messages) are rolled back to simulate completely failure free execution.\r\n```', 'commenter': 'tzulitai'}]"
54,statefun-docs/docs/concepts/index.rst,"@@ -0,0 +1,97 @@
+.. Licensed to the Apache Software Foundation (ASF) under one
+   or more contributor license agreements.  See the NOTICE file
+   distributed with this work for additional information
+   regarding copyright ownership.  The ASF licenses this file
+   to you under the Apache License, Version 2.0 (the
+   ""License""); you may not use this file except in compliance
+   with the License.  You may obtain a copy of the License at
+   http://www.apache.org/licenses/LICENSE-2.0
+   Unless required by applicable law or agreed to in writing,
+   software distributed under the License is distributed on an
+   ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+   KIND, either express or implied.  See the License for the
+   specific language governing permissions and limitations
+   under the License.
+
+.. _concepts:
+
+########
+Concepts
+########
+
+.. toctree::
+  :hidden:
+
+  logical
+
+Stateful Functions provides a framework for building event drivent applications.
+Here, we explain important aspects of Stateful Function’s architecture.
+
+.. contents:: :local:
+
+Event Ingress
+=============
+
+Stateful Function applications sit squarely in the event driven space, so the natural place to start is with getting events into the system.
+
+.. figure:: ../_static/images/concepts/statefun-app-ingress.svg
+    :width: 85%
+    :align: center
+
+In stateful functions, the component that ingests records into the system is called an event ingress.
+This can be anything from a Kafka topic, to a messsage queue, to an http request.
+Anything that can get data into the system and trigger the intitial functions to begin compution.
+
+Stateful Functions
+==================
+
+At the core of the diagram are the namesake stateful functions.
+
+.. figure:: ../_static/images/concepts/statefun-app-functions.svg
+    :width: 85%
+    :align: center
+
+Think of these as the building blocks for your service.
+They can message each other arbitrarily, which is one way in which this framework moves away from the traditional stream processing view of the world.
+Instead of building up a static dataflow DAG, these functions can communicate with each other in arbitrary, potentially cyclic, even round trip ways.
+
+If you are familiar with actor programming, this does share certain similarities in its ability to dynamically message between components.
+However, there are a number of significant differences.
+
+Persisted Values
+================
+
+The first is that all functions have locally embedded state, known as persisted values.
+
+.. figure:: ../_static/images/concepts/statefun-app-state.svg
+    :width: 85%
+    :align: center
+
+One of Apache Flink's core strengths is its ability to provide fault-tolerant local state.
+When inside a function, while it is performing some computation, you are always working with local state in local variables.
+
+Fault Tolerance
+===============
+
+For both state and messaging, Stateful Function's is still able to provide the exactly once guaruntees users expect from a modern data processessing framework.
+
+.. figure:: ../_static/images/concepts/statefun-app-fault-tolerance.svg
+    :width: 85%
+    :align: center
+
+In the case of failure, the entire state of the world (both persisted values and messages) are rolled back to simulate completely failure free execution.
+
+These guaruntees are provided with no database required, instead Stateful Function's leverages Apache Flink's proven snapshotting mechanism.","[{'comment': ""```suggestion\r\nThese guarantees are provided with no database required, instead Stateful Function's leverages Apache Flink's proven snapshotting mechanism.\r\n```"", 'commenter': 'tzulitai'}]"
54,statefun-docs/docs/concepts/index.rst,"@@ -0,0 +1,97 @@
+.. Licensed to the Apache Software Foundation (ASF) under one
+   or more contributor license agreements.  See the NOTICE file
+   distributed with this work for additional information
+   regarding copyright ownership.  The ASF licenses this file
+   to you under the Apache License, Version 2.0 (the
+   ""License""); you may not use this file except in compliance
+   with the License.  You may obtain a copy of the License at
+   http://www.apache.org/licenses/LICENSE-2.0
+   Unless required by applicable law or agreed to in writing,
+   software distributed under the License is distributed on an
+   ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+   KIND, either express or implied.  See the License for the
+   specific language governing permissions and limitations
+   under the License.
+
+.. _concepts:
+
+########
+Concepts
+########
+
+.. toctree::
+  :hidden:
+
+  logical
+
+Stateful Functions provides a framework for building event drivent applications.
+Here, we explain important aspects of Stateful Function’s architecture.
+
+.. contents:: :local:
+
+Event Ingress
+=============
+
+Stateful Function applications sit squarely in the event driven space, so the natural place to start is with getting events into the system.
+
+.. figure:: ../_static/images/concepts/statefun-app-ingress.svg
+    :width: 85%
+    :align: center
+
+In stateful functions, the component that ingests records into the system is called an event ingress.
+This can be anything from a Kafka topic, to a messsage queue, to an http request.
+Anything that can get data into the system and trigger the intitial functions to begin compution.
+
+Stateful Functions
+==================
+
+At the core of the diagram are the namesake stateful functions.
+
+.. figure:: ../_static/images/concepts/statefun-app-functions.svg
+    :width: 85%
+    :align: center
+
+Think of these as the building blocks for your service.
+They can message each other arbitrarily, which is one way in which this framework moves away from the traditional stream processing view of the world.
+Instead of building up a static dataflow DAG, these functions can communicate with each other in arbitrary, potentially cyclic, even round trip ways.
+
+If you are familiar with actor programming, this does share certain similarities in its ability to dynamically message between components.
+However, there are a number of significant differences.
+
+Persisted Values
+================
+
+The first is that all functions have locally embedded state, known as persisted values.
+
+.. figure:: ../_static/images/concepts/statefun-app-state.svg
+    :width: 85%
+    :align: center
+
+One of Apache Flink's core strengths is its ability to provide fault-tolerant local state.
+When inside a function, while it is performing some computation, you are always working with local state in local variables.
+
+Fault Tolerance
+===============
+
+For both state and messaging, Stateful Function's is still able to provide the exactly once guaruntees users expect from a modern data processessing framework.
+
+.. figure:: ../_static/images/concepts/statefun-app-fault-tolerance.svg
+    :width: 85%
+    :align: center
+
+In the case of failure, the entire state of the world (both persisted values and messages) are rolled back to simulate completely failure free execution.
+
+These guaruntees are provided with no database required, instead Stateful Function's leverages Apache Flink's proven snapshotting mechanism.
+
+Event Egress
+============
+
+Finally, applications can output data to external systems via event egress's.
+
+.. figure:: ../_static/images/concepts/statefun-app-egress.svg
+    :width: 85%
+    :align: center
+
+Of course, functions perform arbitrary computation and can do whatever they like, which includes making RPC calls and connecting to other systems.
+By using an event egress, applications can leverage pre-built interfaces and data output is tied into the systems fault tolerance to avoid data loss.","[{'comment': ""Does this sentence imply that making arbitrary RPC calls / connecting to other systems can have data loss, without using event egresses? It sort of read to me like that, it being after the `Of course, functions perform arbitrary ...` sentence.\r\n\r\nBut that isn't true, as using async operations we still guarantee at-least once interactions with external systems."", 'commenter': 'tzulitai'}]"
54,statefun-docs/docs/concepts/logical.rst,"@@ -0,0 +1,79 @@
+.. Licensed to the Apache Software Foundation (ASF) under one
+   or more contributor license agreements.  See the NOTICE file
+   distributed with this work for additional information
+   regarding copyright ownership.  The ASF licenses this file
+   to you under the Apache License, Version 2.0 (the
+   ""License""); you may not use this file except in compliance
+   with the License.  You may obtain a copy of the License at
+   http://www.apache.org/licenses/LICENSE-2.0
+   Unless required by applicable law or agreed to in writing,
+   software distributed under the License is distributed on an
+   ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+   KIND, either express or implied.  See the License for the
+   specific language governing permissions and limitations
+   under the License.
+
+.. _logical-functions:
+
+#################
+Logical Functions
+#################
+
+Stateful Function's are allocated logically, which means the system can support an unbounded number of instances with a finite amount of resources.
+Logical instances do not use CPU, memory, or threads when not actively being invoked, there is no theoretical upper limit on the number of instances that can created.","[{'comment': '```suggestion\r\nLogical instances do not use CPU, memory, or threads when not actively being invoked, so there is no theoretical upper limit on the number of instances that can created.\r\n```', 'commenter': 'tzulitai'}]"
54,statefun-docs/docs/concepts/index.rst,"@@ -0,0 +1,97 @@
+.. Licensed to the Apache Software Foundation (ASF) under one
+   or more contributor license agreements.  See the NOTICE file
+   distributed with this work for additional information
+   regarding copyright ownership.  The ASF licenses this file
+   to you under the Apache License, Version 2.0 (the
+   ""License""); you may not use this file except in compliance
+   with the License.  You may obtain a copy of the License at
+   http://www.apache.org/licenses/LICENSE-2.0
+   Unless required by applicable law or agreed to in writing,
+   software distributed under the License is distributed on an
+   ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+   KIND, either express or implied.  See the License for the
+   specific language governing permissions and limitations
+   under the License.
+
+.. _concepts:
+
+########
+Concepts
+########
+
+.. toctree::
+  :hidden:
+
+  logical
+
+Stateful Functions provides a framework for building event drivent applications.
+Here, we explain important aspects of Stateful Function’s architecture.
+
+.. contents:: :local:
+
+Event Ingress
+=============
+
+Stateful Function applications sit squarely in the event driven space, so the natural place to start is with getting events into the system.
+
+.. figure:: ../_static/images/concepts/statefun-app-ingress.svg
+    :width: 85%
+    :align: center
+
+In stateful functions, the component that ingests records into the system is called an event ingress.
+This can be anything from a Kafka topic, to a messsage queue, to an http request.
+Anything that can get data into the system and trigger the intitial functions to begin compution.
+
+Stateful Functions
+==================
+
+At the core of the diagram are the namesake stateful functions.
+
+.. figure:: ../_static/images/concepts/statefun-app-functions.svg
+    :width: 85%
+    :align: center
+
+Think of these as the building blocks for your service.
+They can message each other arbitrarily, which is one way in which this framework moves away from the traditional stream processing view of the world.
+Instead of building up a static dataflow DAG, these functions can communicate with each other in arbitrary, potentially cyclic, even round trip ways.
+
+If you are familiar with actor programming, this does share certain similarities in its ability to dynamically message between components.
+However, there are a number of significant differences.","[{'comment': 'As of now: the differences mentioned on this page are:\r\n- persisted state\r\n- fault tolerance\r\n\r\nAnother one is logical instances. While that has its own dedicated page, I wonder if we should also very briefly mention it here, or have a link that directly jumps to the logical instances page.\r\nNot sure, if that breaks the ""reading flow"" for the user.', 'commenter': 'tzulitai'}]"
54,statefun-docs/docs/concepts/index.rst,"@@ -0,0 +1,97 @@
+.. Licensed to the Apache Software Foundation (ASF) under one
+   or more contributor license agreements.  See the NOTICE file
+   distributed with this work for additional information
+   regarding copyright ownership.  The ASF licenses this file
+   to you under the Apache License, Version 2.0 (the
+   ""License""); you may not use this file except in compliance
+   with the License.  You may obtain a copy of the License at
+   http://www.apache.org/licenses/LICENSE-2.0
+   Unless required by applicable law or agreed to in writing,
+   software distributed under the License is distributed on an
+   ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+   KIND, either express or implied.  See the License for the
+   specific language governing permissions and limitations
+   under the License.
+
+.. _concepts:
+
+########
+Concepts
+########
+
+.. toctree::
+  :hidden:
+
+  logical
+
+Stateful Functions provides a framework for building event drivent applications.
+Here, we explain important aspects of Stateful Function’s architecture.
+
+.. contents:: :local:
+
+Event Ingress
+=============
+
+Stateful Function applications sit squarely in the event driven space, so the natural place to start is with getting events into the system.
+
+.. figure:: ../_static/images/concepts/statefun-app-ingress.svg
+    :width: 85%
+    :align: center
+
+In stateful functions, the component that ingests records into the system is called an event ingress.
+This can be anything from a Kafka topic, to a messsage queue, to an http request.
+Anything that can get data into the system and trigger the intitial functions to begin compution.
+
+Stateful Functions
+==================
+
+At the core of the diagram are the namesake stateful functions.
+
+.. figure:: ../_static/images/concepts/statefun-app-functions.svg
+    :width: 85%
+    :align: center
+
+Think of these as the building blocks for your service.
+They can message each other arbitrarily, which is one way in which this framework moves away from the traditional stream processing view of the world.
+Instead of building up a static dataflow DAG, these functions can communicate with each other in arbitrary, potentially cyclic, even round trip ways.
+
+If you are familiar with actor programming, this does share certain similarities in its ability to dynamically message between components.
+However, there are a number of significant differences.
+
+Persisted Values","[{'comment': 'Can we make this title, and ""Fault Tolerance"" one level below the other titles like ""Event Ingress"" / ""Event Egress"" / ""Stateful Functions""? The reason for that is because these are sub-details further explaining ""Stateful Functions"", and it striked me a bit odd that all these sections are the same level.', 'commenter': 'tzulitai'}]"
54,statefun-docs/docs/concepts/logical.rst,"@@ -0,0 +1,79 @@
+.. Licensed to the Apache Software Foundation (ASF) under one
+   or more contributor license agreements.  See the NOTICE file
+   distributed with this work for additional information
+   regarding copyright ownership.  The ASF licenses this file
+   to you under the Apache License, Version 2.0 (the
+   ""License""); you may not use this file except in compliance
+   with the License.  You may obtain a copy of the License at
+   http://www.apache.org/licenses/LICENSE-2.0
+   Unless required by applicable law or agreed to in writing,
+   software distributed under the License is distributed on an
+   ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+   KIND, either express or implied.  See the License for the
+   specific language governing permissions and limitations
+   under the License.
+
+.. _logical-functions:
+
+#################
+Logical Functions
+#################
+
+Stateful Function's are allocated logically, which means the system can support an unbounded number of instances with a finite amount of resources.
+Logical instances do not use CPU, memory, or threads when not actively being invoked, there is no theoretical upper limit on the number of instances that can created.
+Users are encouraged to model their applications as granularly as possible, based on what makes the most sense for their application, instead of desigining applications around resource constraints.
+
+.. contents:: :local:
+
+.. _address:
+
+Function Address
+================
+
+In a local environment, the address of an object is the same as a reference to it.
+But in a Stateful Function's application, function instances are virtual and their runtime location is not exposed to the user.
+Instead, an ``Address`` is used to reference a specific stateful functions in the system..","[{'comment': '```suggestion\r\nInstead, an ``Address`` is used to reference a specific stateful function in the system..\r\n```', 'commenter': 'tzulitai'}]"
54,statefun-docs/docs/concepts/logical.rst,"@@ -0,0 +1,79 @@
+.. Licensed to the Apache Software Foundation (ASF) under one
+   or more contributor license agreements.  See the NOTICE file
+   distributed with this work for additional information
+   regarding copyright ownership.  The ASF licenses this file
+   to you under the Apache License, Version 2.0 (the
+   ""License""); you may not use this file except in compliance
+   with the License.  You may obtain a copy of the License at
+   http://www.apache.org/licenses/LICENSE-2.0
+   Unless required by applicable law or agreed to in writing,
+   software distributed under the License is distributed on an
+   ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+   KIND, either express or implied.  See the License for the
+   specific language governing permissions and limitations
+   under the License.
+
+.. _logical-functions:
+
+#################
+Logical Functions
+#################
+
+Stateful Function's are allocated logically, which means the system can support an unbounded number of instances with a finite amount of resources.
+Logical instances do not use CPU, memory, or threads when not actively being invoked, there is no theoretical upper limit on the number of instances that can created.
+Users are encouraged to model their applications as granularly as possible, based on what makes the most sense for their application, instead of desigining applications around resource constraints.
+
+.. contents:: :local:
+
+.. _address:
+
+Function Address
+================
+
+In a local environment, the address of an object is the same as a reference to it.
+But in a Stateful Function's application, function instances are virtual and their runtime location is not exposed to the user.
+Instead, an ``Address`` is used to reference a specific stateful functions in the system..
+
+.. code-block:: proto
+
+  syntax = ""proto3"";","[{'comment': 'Why use protobuf to illustrate this?\r\nIt seems unrelated, also might confuse users that they need to construct `Address` as a protobuf message.', 'commenter': 'tzulitai'}]"
54,statefun-docs/docs/concepts/logical.rst,"@@ -0,0 +1,79 @@
+.. Licensed to the Apache Software Foundation (ASF) under one
+   or more contributor license agreements.  See the NOTICE file
+   distributed with this work for additional information
+   regarding copyright ownership.  The ASF licenses this file
+   to you under the Apache License, Version 2.0 (the
+   ""License""); you may not use this file except in compliance
+   with the License.  You may obtain a copy of the License at
+   http://www.apache.org/licenses/LICENSE-2.0
+   Unless required by applicable law or agreed to in writing,
+   software distributed under the License is distributed on an
+   ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+   KIND, either express or implied.  See the License for the
+   specific language governing permissions and limitations
+   under the License.
+
+.. _logical-functions:
+
+#################
+Logical Functions
+#################
+
+Stateful Function's are allocated logically, which means the system can support an unbounded number of instances with a finite amount of resources.
+Logical instances do not use CPU, memory, or threads when not actively being invoked, there is no theoretical upper limit on the number of instances that can created.
+Users are encouraged to model their applications as granularly as possible, based on what makes the most sense for their application, instead of desigining applications around resource constraints.
+
+.. contents:: :local:
+
+.. _address:
+
+Function Address
+================
+
+In a local environment, the address of an object is the same as a reference to it.
+But in a Stateful Function's application, function instances are virtual and their runtime location is not exposed to the user.
+Instead, an ``Address`` is used to reference a specific stateful functions in the system..
+
+.. code-block:: proto
+
+  syntax = ""proto3"";
+
+  message Address {
+
+    message FunctionType {
+      string namespace = 1;
+      string name      = 2;
+    }
+
+    FunctionType function_type = 1;
+    string id = 2;
+  }
+
+
+An address is made of two components, a ``FunctionType`` and ``ID``.
+A function type is similar to a class in an object-oriented language; it declares what sort of function the address references.
+The id is a primary key, it scopes the function call to a specific instances of the function type.","[{'comment': '```suggestion\r\nThe id is a primary key, which scopes the function call to a specific instance of the function type.\r\n```', 'commenter': 'tzulitai'}]"
54,statefun-docs/docs/concepts/logical.rst,"@@ -0,0 +1,79 @@
+.. Licensed to the Apache Software Foundation (ASF) under one
+   or more contributor license agreements.  See the NOTICE file
+   distributed with this work for additional information
+   regarding copyright ownership.  The ASF licenses this file
+   to you under the Apache License, Version 2.0 (the
+   ""License""); you may not use this file except in compliance
+   with the License.  You may obtain a copy of the License at
+   http://www.apache.org/licenses/LICENSE-2.0
+   Unless required by applicable law or agreed to in writing,
+   software distributed under the License is distributed on an
+   ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+   KIND, either express or implied.  See the License for the
+   specific language governing permissions and limitations
+   under the License.
+
+.. _logical-functions:
+
+#################
+Logical Functions
+#################
+
+Stateful Function's are allocated logically, which means the system can support an unbounded number of instances with a finite amount of resources.
+Logical instances do not use CPU, memory, or threads when not actively being invoked, there is no theoretical upper limit on the number of instances that can created.
+Users are encouraged to model their applications as granularly as possible, based on what makes the most sense for their application, instead of desigining applications around resource constraints.
+
+.. contents:: :local:
+
+.. _address:
+
+Function Address
+================
+
+In a local environment, the address of an object is the same as a reference to it.
+But in a Stateful Function's application, function instances are virtual and their runtime location is not exposed to the user.
+Instead, an ``Address`` is used to reference a specific stateful functions in the system..
+
+.. code-block:: proto
+
+  syntax = ""proto3"";
+
+  message Address {
+
+    message FunctionType {
+      string namespace = 1;
+      string name      = 2;
+    }
+
+    FunctionType function_type = 1;
+    string id = 2;
+  }
+
+
+An address is made of two components, a ``FunctionType`` and ``ID``.
+A function type is similar to a class in an object-oriented language; it declares what sort of function the address references.
+The id is a primary key, it scopes the function call to a specific instances of the function type.
+
+When a function is being invoked, all actions - including reads and writes of persisted values - are scoped to the current address.","[{'comment': '```suggestion\r\nWhen a function is being invoked, all actions - including reads and writes of persisted states - are scoped to the current address.\r\n```', 'commenter': 'tzulitai'}]"
54,statefun-docs/docs/concepts/logical.rst,"@@ -0,0 +1,79 @@
+.. Licensed to the Apache Software Foundation (ASF) under one
+   or more contributor license agreements.  See the NOTICE file
+   distributed with this work for additional information
+   regarding copyright ownership.  The ASF licenses this file
+   to you under the Apache License, Version 2.0 (the
+   ""License""); you may not use this file except in compliance
+   with the License.  You may obtain a copy of the License at
+   http://www.apache.org/licenses/LICENSE-2.0
+   Unless required by applicable law or agreed to in writing,
+   software distributed under the License is distributed on an
+   ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+   KIND, either express or implied.  See the License for the
+   specific language governing permissions and limitations
+   under the License.
+
+.. _logical-functions:
+
+#################
+Logical Functions
+#################
+
+Stateful Function's are allocated logically, which means the system can support an unbounded number of instances with a finite amount of resources.
+Logical instances do not use CPU, memory, or threads when not actively being invoked, there is no theoretical upper limit on the number of instances that can created.
+Users are encouraged to model their applications as granularly as possible, based on what makes the most sense for their application, instead of desigining applications around resource constraints.
+
+.. contents:: :local:
+
+.. _address:
+
+Function Address
+================
+
+In a local environment, the address of an object is the same as a reference to it.
+But in a Stateful Function's application, function instances are virtual and their runtime location is not exposed to the user.
+Instead, an ``Address`` is used to reference a specific stateful functions in the system..
+
+.. code-block:: proto
+
+  syntax = ""proto3"";
+
+  message Address {
+
+    message FunctionType {
+      string namespace = 1;
+      string name      = 2;
+    }
+
+    FunctionType function_type = 1;
+    string id = 2;
+  }
+
+
+An address is made of two components, a ``FunctionType`` and ``ID``.
+A function type is similar to a class in an object-oriented language; it declares what sort of function the address references.
+The id is a primary key, it scopes the function call to a specific instances of the function type.
+
+When a function is being invoked, all actions - including reads and writes of persisted values - are scoped to the current address.
+
+For example, imagine a there was a Stateful Function application to track the inventory of a warehouse.
+One possible implementation could include an ``Inventory`` function that tracks the number units in stock for a particular item; this would be the function type.
+There would then be one logical instance of this type for each SKU the warehouse manages.
+If it were clothing, there might be an instance for shirts and another for pants; ""shirt"" and ""pant"" would be two ids.
+Each instance may be interacted with and messaged independently.
+The application is free to create as many instances as there are types of items in inventory.
+
+Function Lifecycle
+==================
+
+Logical functions are neither created nor destroyed, but always exist throughout the lifetime of an application.
+When an application starts, each parallel worker of the framework will create one physical object per function type.
+This object will be used to execute all logical instances of that type that are run by that particular worker.
+The first time a message is sent to an address, it will be as if that instance had always existed with its persisted values returning ``NULL``.","[{'comment': '```suggestion\r\nThe first time a message is sent to an address, it will be as if that instance had always existed with its persisted states being empty.\r\n```\r\n\r\nNot all states are initially `null`, some are empty collections for example.\r\nSuggesting a more general term here.', 'commenter': 'tzulitai'}]"
54,statefun-docs/docs/concepts/logical.rst,"@@ -0,0 +1,79 @@
+.. Licensed to the Apache Software Foundation (ASF) under one
+   or more contributor license agreements.  See the NOTICE file
+   distributed with this work for additional information
+   regarding copyright ownership.  The ASF licenses this file
+   to you under the Apache License, Version 2.0 (the
+   ""License""); you may not use this file except in compliance
+   with the License.  You may obtain a copy of the License at
+   http://www.apache.org/licenses/LICENSE-2.0
+   Unless required by applicable law or agreed to in writing,
+   software distributed under the License is distributed on an
+   ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+   KIND, either express or implied.  See the License for the
+   specific language governing permissions and limitations
+   under the License.
+
+.. _logical-functions:
+
+#################
+Logical Functions
+#################
+
+Stateful Function's are allocated logically, which means the system can support an unbounded number of instances with a finite amount of resources.
+Logical instances do not use CPU, memory, or threads when not actively being invoked, there is no theoretical upper limit on the number of instances that can created.
+Users are encouraged to model their applications as granularly as possible, based on what makes the most sense for their application, instead of desigining applications around resource constraints.
+
+.. contents:: :local:
+
+.. _address:
+
+Function Address
+================
+
+In a local environment, the address of an object is the same as a reference to it.
+But in a Stateful Function's application, function instances are virtual and their runtime location is not exposed to the user.
+Instead, an ``Address`` is used to reference a specific stateful functions in the system..
+
+.. code-block:: proto
+
+  syntax = ""proto3"";
+
+  message Address {
+
+    message FunctionType {
+      string namespace = 1;
+      string name      = 2;
+    }
+
+    FunctionType function_type = 1;
+    string id = 2;
+  }
+
+
+An address is made of two components, a ``FunctionType`` and ``ID``.
+A function type is similar to a class in an object-oriented language; it declares what sort of function the address references.
+The id is a primary key, it scopes the function call to a specific instances of the function type.
+
+When a function is being invoked, all actions - including reads and writes of persisted values - are scoped to the current address.
+
+For example, imagine a there was a Stateful Function application to track the inventory of a warehouse.
+One possible implementation could include an ``Inventory`` function that tracks the number units in stock for a particular item; this would be the function type.
+There would then be one logical instance of this type for each SKU the warehouse manages.
+If it were clothing, there might be an instance for shirts and another for pants; ""shirt"" and ""pant"" would be two ids.
+Each instance may be interacted with and messaged independently.
+The application is free to create as many instances as there are types of items in inventory.
+
+Function Lifecycle
+==================
+
+Logical functions are neither created nor destroyed, but always exist throughout the lifetime of an application.
+When an application starts, each parallel worker of the framework will create one physical object per function type.
+This object will be used to execute all logical instances of that type that are run by that particular worker.
+The first time a message is sent to an address, it will be as if that instance had always existed with its persisted values returning ``NULL``.
+
+Clearing all persisted values of a type is the same as destroying it.","[{'comment': '```suggestion\r\nClearing all persisted states of a function instance is the same as destroying it.\r\n```', 'commenter': 'tzulitai'}]"
54,statefun-docs/docs/concepts/logical.rst,"@@ -0,0 +1,79 @@
+.. Licensed to the Apache Software Foundation (ASF) under one
+   or more contributor license agreements.  See the NOTICE file
+   distributed with this work for additional information
+   regarding copyright ownership.  The ASF licenses this file
+   to you under the Apache License, Version 2.0 (the
+   ""License""); you may not use this file except in compliance
+   with the License.  You may obtain a copy of the License at
+   http://www.apache.org/licenses/LICENSE-2.0
+   Unless required by applicable law or agreed to in writing,
+   software distributed under the License is distributed on an
+   ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+   KIND, either express or implied.  See the License for the
+   specific language governing permissions and limitations
+   under the License.
+
+.. _logical-functions:
+
+#################
+Logical Functions
+#################
+
+Stateful Function's are allocated logically, which means the system can support an unbounded number of instances with a finite amount of resources.
+Logical instances do not use CPU, memory, or threads when not actively being invoked, there is no theoretical upper limit on the number of instances that can created.
+Users are encouraged to model their applications as granularly as possible, based on what makes the most sense for their application, instead of desigining applications around resource constraints.
+
+.. contents:: :local:
+
+.. _address:
+
+Function Address
+================
+
+In a local environment, the address of an object is the same as a reference to it.
+But in a Stateful Function's application, function instances are virtual and their runtime location is not exposed to the user.
+Instead, an ``Address`` is used to reference a specific stateful functions in the system..
+
+.. code-block:: proto
+
+  syntax = ""proto3"";
+
+  message Address {
+
+    message FunctionType {
+      string namespace = 1;
+      string name      = 2;
+    }
+
+    FunctionType function_type = 1;
+    string id = 2;
+  }
+
+
+An address is made of two components, a ``FunctionType`` and ``ID``.
+A function type is similar to a class in an object-oriented language; it declares what sort of function the address references.
+The id is a primary key, it scopes the function call to a specific instances of the function type.
+
+When a function is being invoked, all actions - including reads and writes of persisted values - are scoped to the current address.
+
+For example, imagine a there was a Stateful Function application to track the inventory of a warehouse.
+One possible implementation could include an ``Inventory`` function that tracks the number units in stock for a particular item; this would be the function type.
+There would then be one logical instance of this type for each SKU the warehouse manages.
+If it were clothing, there might be an instance for shirts and another for pants; ""shirt"" and ""pant"" would be two ids.
+Each instance may be interacted with and messaged independently.
+The application is free to create as many instances as there are types of items in inventory.
+
+Function Lifecycle
+==================
+
+Logical functions are neither created nor destroyed, but always exist throughout the lifetime of an application.
+When an application starts, each parallel worker of the framework will create one physical object per function type.
+This object will be used to execute all logical instances of that type that are run by that particular worker.
+The first time a message is sent to an address, it will be as if that instance had always existed with its persisted values returning ``NULL``.
+
+Clearing all persisted values of a type is the same as destroying it.
+If an instance has no state and is not actively running, then it occupies no CPU, no threads, and no memory.
+
+An instance with data stored in one or more of its persisted values only occupies the resources necessary to store that data.","[{'comment': '```suggestion\r\nAn instance with data stored in one or more of its persisted states only occupies the resources necessary to store that data.\r\n```', 'commenter': 'tzulitai'}]"
54,statefun-docs/docs/getting_started/walkthrough.rst,"@@ -168,7 +168,7 @@ Each time a message is processed, the function computes a personalized message f
 It reads and updates the number of times that user has been seen and sends a greeting to the egress.
 
 You can check the full code for the application described in this walkthrough `here <{examples}/statefun-greeter-example>`_.
-In particular, take a look at the :ref:`module <module>` GreetingModule, which is the main entry point for the full application, to see how everything gets tied together.
+In particular, take a look at the module GreetingModule, which is the main entry point for the full application, to see how everything gets tied together.","[{'comment': '```suggestion\r\nIn particular, take a look at the module ``GreetingModule``, which is the main entry point for the full application, to see how everything gets tied together.\r\n```', 'commenter': 'tzulitai'}]"
54,statefun-docs/docs/sdk/modules.rst,"@@ -0,0 +1,96 @@
+.. Licensed to the Apache Software Foundation (ASF) under one
+   or more contributor license agreements.  See the NOTICE file
+   distributed with this work for additional information
+   regarding copyright ownership.  The ASF licenses this file
+   to you under the Apache License, Version 2.0 (the
+   ""License""); you may not use this file except in compliance
+   with the License.  You may obtain a copy of the License at
+   http://www.apache.org/licenses/LICENSE-2.0
+   Unless required by applicable law or agreed to in writing,
+   software distributed under the License is distributed on an
+   ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+   KIND, either express or implied.  See the License for the
+   specific language governing permissions and limitations
+   under the License.
+
+.. _modules:
+
+#######
+Modules
+#######
+
+Stateful Function applications are composed of one or more ``Modules``.
+A module is a bundle of functions that are loaded by the runtime and available to be messaged.
+Functions from all loaded modules are multiplexed and free to message each other arbitrarily.
+
+Stateful Functions supports two types of modules: Embedded and Remote.
+
+.. contents:: :local:
+
+.. _embedded_module:
+
+Embedded Module
+===============
+
+Embedded modules are co-located with, and embedded within, the {flink} runtime.
+
+This module type only supports JVM based languages and are defined by implementing the ``StatefulFunctionModule`` interface.
+Embedded modules offer a single configuration method where stateful functions are bound to the system based on their :ref:`function type <address>`.
+Runtime configurations are available through the ``globalConfiguration``, which is the union of all configurations in the applications ``flink-conf.yaml`` under the prefix ``statefun.module.global-config`` and any command line arguments passed in the form ``--key value``.
+
+.. literalinclude:: ../../src/main/java/org/apache/flink/statefun/docs/BasicFunctionModule.java
+    :language: java
+    :lines: 18-
+
+Embedded modules leverage `Java’s Service Provider Interfaces (SPI) <https://docs.oracle.com/javase/8/docs/api/java/util/ServiceLoader.html>`_ for discovery.
+This means that every JAR should contain a file ``org.apache.flink.statefun.sdk.spi.StatefulFunctionModule`` in the ``META_INF/services`` resource directory that lists all available modules that it provides.","[{'comment': ""There's a more straightforward way to do that now, using `@AutoService` annotation on the module classes."", 'commenter': 'tzulitai'}]"
66,statefun-examples/statefun-python-walkthrough/requirements.txt,"@@ -0,0 +1,20 @@
+#
+# Licensed to the Apache Software Foundation (ASF) under one or more
+# contributor license agreements.  See the NOTICE file distributed with
+# this work for additional information regarding copyright ownership.
+# The ASF licenses this file to You under the Apache License, Version 2.0
+# (the ""License""); you may not use this file except in compliance with
+# the License.  You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an ""AS IS"" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+flask
+","[{'comment': 'I think protobuf is also a requirement?', 'commenter': 'tzulitai'}, {'comment': 'It comes transitivity from statefun.\r\nBut sure, let’s make it explicit. ', 'commenter': 'igalshilman'}]"
66,statefun-examples/statefun-python-walkthrough/03context.py,"@@ -0,0 +1,59 @@
+################################################################################
+#  Licensed to the Apache Software Foundation (ASF) under one
+#  or more contributor license agreements.  See the NOTICE file
+#  distributed with this work for additional information
+#  regarding copyright ownership.  The ASF licenses this file
+#  to you under the Apache License, Version 2.0 (the
+#  ""License""); you may not use this file except in compliance
+#  with the License.  You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+#  Unless required by applicable law or agreed to in writing, software
+#  distributed under the License is distributed on an ""AS IS"" BASIS,
+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+#  See the License for the specific language governing permissions and
+# limitations under the License.
+################################################################################
+
+from statefun import StatefulFunctions
+from statefun import kafka_egress_builder
+from walkthrough_pb2 import HelloReply, Hello, Event
+
+functions = StatefulFunctions()
+
+
+@functions.bind(""walkthrough/send"")
+def send(context, message):
+    # context allows you to send messages to other functions, as long as you
+    # know their address. An address is composed of a function type and an id.
+    any = Any()","[{'comment': ""This won't seem to compile because `Any` isn't imported."", 'commenter': 'tzulitai'}]"
66,statefun-examples/statefun-python-walkthrough/03context.py,"@@ -0,0 +1,59 @@
+################################################################################
+#  Licensed to the Apache Software Foundation (ASF) under one
+#  or more contributor license agreements.  See the NOTICE file
+#  distributed with this work for additional information
+#  regarding copyright ownership.  The ASF licenses this file
+#  to you under the Apache License, Version 2.0 (the
+#  ""License""); you may not use this file except in compliance
+#  with the License.  You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+#  Unless required by applicable law or agreed to in writing, software
+#  distributed under the License is distributed on an ""AS IS"" BASIS,
+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+#  See the License for the specific language governing permissions and
+# limitations under the License.
+################################################################################
+
+from statefun import StatefulFunctions
+from statefun import kafka_egress_builder","[{'comment': 'I renamed this to `kafka_egress_record` in master, could you rename it here as well?', 'commenter': 'tzulitai'}]"
66,statefun-examples/statefun-python-walkthrough/README.md,"@@ -0,0 +1,46 @@
+# Apache Stateful Functions - Walkthrough
+
+## Setup
+
+* Create a virtual env
+
+```
+python3 -m venv venv
+source venv/bin/activate   
+```
+
+* Install the requirements 
+
+```
+pip3 install requirements.txt
+```
+
+If you are building from source, then first build the 
+distribution (via calling `statefun-python-sdk/build-distribution.sh`)
+then copy `statefun-python-sdk/dist/apache_flink_statefun-1.1_SNAPSHOT-py3-none-any.whl` here and
+run 
+
+```
+pip3 install apache_flink_statefun-1.1_SNAPSHOT-py3-none-any.whl
+```
+
+## Examples
+
+* Checkout the walkthough examples at [walkthrough.py](walkthrough.py)
+* To invoke one of the example functions, and observe its result, run:
+```
+python3 walkthrough.py
+```
+
+And from another terminal run:
+```
+python3 run-example <example name>","[{'comment': '```suggestion\r\npython3 run-example.py <example name>\r\n```', 'commenter': 'tzulitai'}]"
66,statefun-examples/statefun-python-walkthrough/README.md,"@@ -0,0 +1,46 @@
+# Apache Stateful Functions - Walkthrough
+
+## Setup
+
+* Create a virtual env
+
+```
+python3 -m venv venv
+source venv/bin/activate   
+```
+
+* Install the requirements 
+
+```
+pip3 install requirements.txt
+```
+
+If you are building from source, then first build the 
+distribution (via calling `statefun-python-sdk/build-distribution.sh`)
+then copy `statefun-python-sdk/dist/apache_flink_statefun-1.1_SNAPSHOT-py3-none-any.whl` here and
+run 
+
+```
+pip3 install apache_flink_statefun-1.1_SNAPSHOT-py3-none-any.whl
+```
+
+## Examples
+
+* Checkout the walkthough examples at [walkthrough.py](walkthrough.py)
+* To invoke one of the example functions, and observe its result, run:
+```
+python3 walkthrough.py
+```
+
+And from another terminal run:
+```
+python3 run-example <example name>
+```
+
+i.e.
+
+```
+python3 run-example walkthrough/hello","[{'comment': '```suggestion\r\npython3 run-example.py walkthrough/hello\r\n```', 'commenter': 'tzulitai'}]"
66,statefun-examples/statefun-python-walkthrough/README.md,"@@ -0,0 +1,46 @@
+# Apache Stateful Functions - Walkthrough","[{'comment': '```suggestion\r\n# Apache Stateful Functions - Python SDK Walkthrough\r\n```', 'commenter': 'tzulitai'}]"
66,statefun-examples/statefun-python-walkthrough/README.md,"@@ -0,0 +1,46 @@
+# Apache Stateful Functions - Walkthrough
+
+## Setup
+
+* Create a virtual env
+
+```
+python3 -m venv venv
+source venv/bin/activate   
+```
+
+* Install the requirements 
+
+```
+pip3 install requirements.txt
+```
+
+If you are building from source, then first build the 
+distribution (via calling `statefun-python-sdk/build-distribution.sh`)
+then copy `statefun-python-sdk/dist/apache_flink_statefun-1.1_SNAPSHOT-py3-none-any.whl` here and","[{'comment': '```suggestion\r\nthen copy `statefun-python-sdk/dist/apache_flink_statefun-2.1_SNAPSHOT-py3-none-any.whl` here and\r\n```\r\n\r\nor maybe `apache_flink_statefun-*-py3-none-any.whl` so that its oblivious to the branch version', 'commenter': 'tzulitai'}]"
66,statefun-examples/statefun-python-walkthrough/README.md,"@@ -0,0 +1,46 @@
+# Apache Stateful Functions - Walkthrough
+
+## Setup
+
+* Create a virtual env
+
+```
+python3 -m venv venv
+source venv/bin/activate   
+```
+
+* Install the requirements 
+
+```
+pip3 install requirements.txt
+```
+
+If you are building from source, then first build the 
+distribution (via calling `statefun-python-sdk/build-distribution.sh`)
+then copy `statefun-python-sdk/dist/apache_flink_statefun-1.1_SNAPSHOT-py3-none-any.whl` here and
+run 
+
+```
+pip3 install apache_flink_statefun-1.1_SNAPSHOT-py3-none-any.whl","[{'comment': '```suggestion\r\npip3 install apache_flink_statefun-*-py3-none-any.whl\r\n```', 'commenter': 'tzulitai'}]"
66,statefun-examples/statefun-python-walkthrough/README.md,"@@ -0,0 +1,46 @@
+# Apache Stateful Functions - Walkthrough
+
+## Setup
+
+* Create a virtual env
+
+```
+python3 -m venv venv
+source venv/bin/activate   
+```
+
+* Install the requirements 
+
+```
+pip3 install requirements.txt","[{'comment': '```suggestion\r\npip3 install -r requirements.txt\r\n```', 'commenter': 'tzulitai'}]"
73,docs/README.md,"@@ -0,0 +1,157 @@
+This README gives an overview of how to build and contribute to the documentation of Apache Flink.","[{'comment': 'Could you rename the mentions of `Apache Flink` here as appropriate to mention `Stateful Functions` instead?\r\nIn general the references in this README needs to be adjusted.\r\n\r\n```suggestion\r\nThis README gives an overview of how to build and contribute to the documentation of Stateful Functions.\r\n```', 'commenter': 'tzulitai'}]"
73,docs/README.md,"@@ -0,0 +1,157 @@
+This README gives an overview of how to build and contribute to the documentation of Apache Flink.
+
+The documentation is included with the source of Apache Flink in order to ensure that you always","[{'comment': '```suggestion\r\nThe documentation is included with the source of Stateful Functions in order to ensure that you always\r\n```', 'commenter': 'tzulitai'}]"
73,docs/_config.yml,"@@ -0,0 +1,98 @@
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# ""License""); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+
+#------------------------------------------------------------------------------
+# VARIABLES
+#------------------------------------------------------------------------------
+# Variables specified in this file can be used in the documentation via:
+#     {{ site.CONFIG_KEY }}
+#------------------------------------------------------------------------------
+
+# This are the version referenced in the docs. Please only use these variables
+# to reference a specific Flink version, because this is the only place where
+# we change the version for the complete docs when forking of a release branch
+# etc.
+# The full version string as referenced in Maven (e.g. 1.2.1)
+version: ""2.0-SNAPSHOT""","[{'comment': 'Current master is `2.1-SNAPSHOT`\r\n```suggestion\r\nversion: ""2.1-SNAPSHOT""\r\n```', 'commenter': 'tzulitai'}]"
73,docs/_config_dev_zh.yml,"@@ -0,0 +1,28 @@
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# ""License""); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License
+
+exclude:","[{'comment': ""Can this file be deleted? We don't have Chinese docs right now."", 'commenter': 'tzulitai'}, {'comment': 'Actually, maybe leave it as is in case we do want to add Chinese docs in the future :)', 'commenter': 'tzulitai'}, {'comment': ""That's what I was thinking, I just commented out the bare minimum of the chineese doc infra to get it working while still being easy to re-enable. "", 'commenter': 'sjwiesman'}]"
73,docs/_includes/sidenav.html,"@@ -0,0 +1,185 @@
+<!--
+Licensed to the Apache Software Foundation (ASF) under one
+or more contributor license agreements.  See the NOTICE file
+distributed with this work for additional information
+regarding copyright ownership.  The ASF licenses this file
+to you under the Apache License, Version 2.0 (the
+""License""); you may not use this file except in compliance
+with the License.  You may obtain a copy of the License at
+
+  http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing,
+software distributed under the License is distributed on an
+""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+KIND, either express or implied.  See the License for the
+specific language governing permissions and limitations
+under the License.
+-->
+
+{%- comment -%}
+==============================================================================
+Extract the active nav IDs.
+==============================================================================
+{%- endcomment -%}
+
+{%- assign active_nav_ids = site.array -%}
+{%- assign parent_id = page.nav-parent_id -%}
+
+{%- for i in (1..10) -%}
+  {%- if parent_id -%}
+    {%- assign active_nav_ids = active_nav_ids | push: parent_id -%}
+    {%- assign current = (site.pages_by_language[page.language] | where: ""nav-id"" , parent_id | sort: ""nav-pos"") -%}
+    {%- if current.size > 0 -%}
+      {%- assign parent_id = current[0].nav-parent_id -%}
+    {%- else -%}
+      {%- break -%}
+    {%- endif -%}
+  {%- else -%}
+    {%- break -%}
+  {%- endif -%}
+{%- endfor -%}
+
+{%- if page.language == ""en"" -%}
+  {%- capture baseurl_i18n -%}{{ site.baseurl }}{%- endcapture -%}
+{%- else if page.language == ""zh"" -%}
+  {%- capture baseurl_i18n -%}{{ site.baseurl }}/{{ page.language }}{%- endcapture -%}
+{%- endif -%}
+
+{%- comment -%}
+==============================================================================
+Build the nested list from nav-id and nav-parent_id relations.
+==============================================================================
+This builds a nested list from all pages. The fields used to determine the
+structure are:
+
+- 'nav-id' => ID of this page. Other pages can use this ID as their
+  parent ID.
+- 'nav-parent_id' => ID of the parent. This page will be listed under
+  the page with id 'nav-parent_id'.
+
+Level 0 is made up of all pages, which have nav-parent_id set to 'root'.
+
+The 'title' of the page is used as the default link text. You can
+override this via 'nav-title'. The relative position per navigational
+level is determined by 'nav-pos'.
+{%- endcomment -%}
+
+{%- assign elementsPosStack = site.array -%}
+{%- assign posStack = site.array -%}
+
+{%- assign elements = site.array -%}
+{%- assign all_pages_by_nav_parent = (site.pages_by_language[page.language] | where_exp: ""item"", ""item.nav-parent_id != nil"" | group_by: ""nav-parent_id"") -%}
+{%- assign children = (all_pages_by_nav_parent | where: ""name"" , ""root"") -%}
+{%- assign children = (children[0].items | sort: ""nav-pos"") -%}
+{%- if children.size > 0 -%}
+  {%- assign elements = elements | push: children -%}
+{%- endif -%}
+
+{%- assign elementsPos = 0 -%}
+{%- assign pos = 0 -%}
+
+<div class=""sidenav-logo"">
+  <p><a href=""{{ baseurl_i18n }}/""><img class=""bottom"" alt=""Apache Flink"" src=""{{ site.baseurl }}/page/img/navbar-brand-logo.jpg""></a> v{{ site.version_title }}</p>","[{'comment': ""I think we need to decide what we want put here as the logo.\r\n\r\n![image](https://user-images.githubusercontent.com/5284370/77504245-c8bbef00-6e9a-11ea-9d11-4527f26e198a.png)\r\n\r\nIt is definitely a bit weird looking at it now, that we're using the Flink squirrel logo here, because at first glance it looks like `Apache Flink v2.0-SNAPSHOT`\r\n"", 'commenter': 'tzulitai'}]"
73,docs/_layouts/base.html,"@@ -0,0 +1,118 @@
+<!DOCTYPE html>
+<!--
+Licensed to the Apache Software Foundation (ASF) under one
+or more contributor license agreements.  See the NOTICE file
+distributed with this work for additional information
+regarding copyright ownership.  The ASF licenses this file
+to you under the Apache License, Version 2.0 (the
+""License""); you may not use this file except in compliance
+with the License.  You may obtain a copy of the License at
+
+  http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing,
+software distributed under the License is distributed on an
+""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+KIND, either express or implied.  See the License for the
+specific language governing permissions and limitations
+under the License.
+-->
+<html lang=""en"">
+  <head>
+    <meta charset=""utf-8"">
+    <meta http-equiv=""X-UA-Compatible"" content=""IE=edge"">
+    <meta name=""viewport"" content=""width=device-width, initial-scale=1"">
+    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
+    <title>Apache Flink {{ site.version_title }} Documentation: {{ page.title }}</title>","[{'comment': '```suggestion\r\n    <title>Apache Flink Stateful Functions {{ site.version_title }} Documentation: {{ page.title }}</title>\r\n```', 'commenter': 'tzulitai'}]"
73,docs/_layouts/base.html,"@@ -0,0 +1,118 @@
+<!DOCTYPE html>
+<!--
+Licensed to the Apache Software Foundation (ASF) under one
+or more contributor license agreements.  See the NOTICE file
+distributed with this work for additional information
+regarding copyright ownership.  The ASF licenses this file
+to you under the Apache License, Version 2.0 (the
+""License""); you may not use this file except in compliance
+with the License.  You may obtain a copy of the License at
+
+  http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing,
+software distributed under the License is distributed on an
+""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+KIND, either express or implied.  See the License for the
+specific language governing permissions and limitations
+under the License.
+-->
+<html lang=""en"">
+  <head>
+    <meta charset=""utf-8"">
+    <meta http-equiv=""X-UA-Compatible"" content=""IE=edge"">
+    <meta name=""viewport"" content=""width=device-width, initial-scale=1"">
+    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
+    <title>Apache Flink {{ site.version_title }} Documentation: {{ page.title }}</title>
+    <link rel=""shortcut icon"" href=""{{ site.baseurl }}/page/favicon.ico"" type=""image/x-icon"">","[{'comment': 'Consider switching to Stateful Functions favicon', 'commenter': 'tzulitai'}]"
73,docs/_layouts/base.html,"@@ -0,0 +1,118 @@
+<!DOCTYPE html>
+<!--
+Licensed to the Apache Software Foundation (ASF) under one
+or more contributor license agreements.  See the NOTICE file
+distributed with this work for additional information
+regarding copyright ownership.  The ASF licenses this file
+to you under the Apache License, Version 2.0 (the
+""License""); you may not use this file except in compliance
+with the License.  You may obtain a copy of the License at
+
+  http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing,
+software distributed under the License is distributed on an
+""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+KIND, either express or implied.  See the License for the
+specific language governing permissions and limitations
+under the License.
+-->
+<html lang=""en"">
+  <head>
+    <meta charset=""utf-8"">
+    <meta http-equiv=""X-UA-Compatible"" content=""IE=edge"">
+    <meta name=""viewport"" content=""width=device-width, initial-scale=1"">
+    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
+    <title>Apache Flink {{ site.version_title }} Documentation: {{ page.title }}</title>
+    <link rel=""shortcut icon"" href=""{{ site.baseurl }}/page/favicon.ico"" type=""image/x-icon"">
+    <link rel=""icon"" href=""{{ site.baseurl }}/page/favicon.ico"" type=""image/x-icon"">
+    <link rel=""canonical"" href=""{{ site.stable_baseurl }}{{ page.url | replace:'index.html',''}}"">
+
+    <!-- Bootstrap -->
+    <link rel=""stylesheet"" href=""https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/css/bootstrap.min.css"">
+    <link rel=""stylesheet"" href=""{{ site.baseurl }}/page/css/flink.css"">
+    <link rel=""stylesheet"" href=""{{ site.baseurl }}/page/css/syntax.css"">
+    <link rel=""stylesheet"" href=""{{ site.baseurl }}/page/css/codetabs.css"">
+    <link rel=""stylesheet"" href=""{{ site.baseurl }}/page/font-awesome/css/font-awesome.min.css"">
+    {% if page.mathjax %}
+    <script type=""text/x-mathjax-config"">
+        MathJax.Hub.Config({
+        tex2jax: {
+          inlineMath: [['$','$'], ['\\(','\\)']] },
+        TeX: {
+          equationNumbers: { autoNumber: ""AMS"" } }
+        });
+    </script>
+    <script type=""text/javascript""
+            src=""https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"">
+    </script>
+    {% endif %}
+    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
+    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
+    <!--[if lt IE 9]>
+      <script src=""https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js""></script>
+      <script src=""https://oss.maxcdn.com/respond/1.4.2/respond.min.js""></script>
+    <![endif]-->
+  </head>
+  <body>
+    {% if site.show_outdated_warning %}
+    <div style=""position:fixed; bottom:0; left:0; z-index:99999; width:100%; text-align:center; padding:15px; border-top:5px solid #ECCCD1; background:#F2DEDE; color:#AD433F; font-weight:bold"">
+      {% if page.language == ""en"" %}
+        This documentation is for an out-of-date version of Apache Flink. We recommend you use <a href=""https://ci.apache.org/projects/flink/flink-docs-stable/"">the latest stable version</a>.","[{'comment': '```suggestion\r\n        This documentation is for an out-of-date version of Apache Flink Stateful Functions. We recommend you use <a href=""https://ci.apache.org/projects/flink/flink-statefun-docs-stable/"">the latest stable version</a>.\r\n```', 'commenter': 'tzulitai'}]"
73,docs/_layouts/base.html,"@@ -0,0 +1,118 @@
+<!DOCTYPE html>
+<!--
+Licensed to the Apache Software Foundation (ASF) under one
+or more contributor license agreements.  See the NOTICE file
+distributed with this work for additional information
+regarding copyright ownership.  The ASF licenses this file
+to you under the Apache License, Version 2.0 (the
+""License""); you may not use this file except in compliance
+with the License.  You may obtain a copy of the License at
+
+  http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing,
+software distributed under the License is distributed on an
+""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+KIND, either express or implied.  See the License for the
+specific language governing permissions and limitations
+under the License.
+-->
+<html lang=""en"">
+  <head>
+    <meta charset=""utf-8"">
+    <meta http-equiv=""X-UA-Compatible"" content=""IE=edge"">
+    <meta name=""viewport"" content=""width=device-width, initial-scale=1"">
+    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
+    <title>Apache Flink {{ site.version_title }} Documentation: {{ page.title }}</title>
+    <link rel=""shortcut icon"" href=""{{ site.baseurl }}/page/favicon.ico"" type=""image/x-icon"">
+    <link rel=""icon"" href=""{{ site.baseurl }}/page/favicon.ico"" type=""image/x-icon"">
+    <link rel=""canonical"" href=""{{ site.stable_baseurl }}{{ page.url | replace:'index.html',''}}"">
+
+    <!-- Bootstrap -->
+    <link rel=""stylesheet"" href=""https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/css/bootstrap.min.css"">
+    <link rel=""stylesheet"" href=""{{ site.baseurl }}/page/css/flink.css"">
+    <link rel=""stylesheet"" href=""{{ site.baseurl }}/page/css/syntax.css"">
+    <link rel=""stylesheet"" href=""{{ site.baseurl }}/page/css/codetabs.css"">
+    <link rel=""stylesheet"" href=""{{ site.baseurl }}/page/font-awesome/css/font-awesome.min.css"">
+    {% if page.mathjax %}
+    <script type=""text/x-mathjax-config"">
+        MathJax.Hub.Config({
+        tex2jax: {
+          inlineMath: [['$','$'], ['\\(','\\)']] },
+        TeX: {
+          equationNumbers: { autoNumber: ""AMS"" } }
+        });
+    </script>
+    <script type=""text/javascript""
+            src=""https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"">
+    </script>
+    {% endif %}
+    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
+    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
+    <!--[if lt IE 9]>
+      <script src=""https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js""></script>
+      <script src=""https://oss.maxcdn.com/respond/1.4.2/respond.min.js""></script>
+    <![endif]-->
+  </head>
+  <body>
+    {% if site.show_outdated_warning %}
+    <div style=""position:fixed; bottom:0; left:0; z-index:99999; width:100%; text-align:center; padding:15px; border-top:5px solid #ECCCD1; background:#F2DEDE; color:#AD433F; font-weight:bold"">
+      {% if page.language == ""en"" %}
+        This documentation is for an out-of-date version of Apache Flink. We recommend you use <a href=""https://ci.apache.org/projects/flink/flink-docs-stable/"">the latest stable version</a>.
+      {% else if page.language == ""zh"" %}
+        本文档是 Apache Flink 的旧版本。建议访问 <a href=""https://ci.apache.org/projects/flink/flink-docs-stable/zh"">最新的稳定版本</a>。","[{'comment': '```suggestion\r\n        本文档是 Apache Flink Stateful Functions 的旧版本。建议访问 <a href=""https://ci.apache.org/projects/flink/flink-statefun-docs-stable/zh"">最新的稳定版本</a>。\r\n```', 'commenter': 'tzulitai'}]"
73,docs/_layouts/plain.html,"@@ -0,0 +1,78 @@
+---
+layout: base
+---
+<!--
+Licensed to the Apache Software Foundation (ASF) under one
+or more contributor license agreements.  See the NOTICE file
+distributed with this work for additional information
+regarding copyright ownership.  The ASF licenses this file
+to you under the Apache License, Version 2.0 (the
+""License""); you may not use this file except in compliance
+with the License.  You may obtain a copy of the License at
+
+  http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing,
+software distributed under the License is distributed on an
+""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+KIND, either express or implied.  See the License for the
+specific language governing permissions and limitations
+under the License.
+-->
+
+{%- assign active_pages = site.array -%}
+{%- assign active = page -%}
+
+{%- for i in (1..10) -%}
+  {%- assign active_pages = active_pages | push: active -%}
+  {%- if active.nav-parent_id -%}
+    {%- assign next = site.pages_by_language[page.language] | where: ""nav-id"" , active.nav-parent_id -%}
+    {%- if next.size > 0 -%}
+      {%- assign active = next[0] -%}
+    {%- else -%}
+      {%- break -%}
+    {%- endif -%}
+  {%- else -%}
+    {%- break -%}
+  {%- endif -%}
+{%- endfor -%}
+
+{% assign active_pages = active_pages | reverse %}
+
+<ol class=""breadcrumb"">
+{%- for p in active_pages %}
+  {% capture title %}{% if p.nav-title %}{{ p.nav-title }}{% else %}{{ p.title }}{% endif %}{% endcapture -%}
+  {%- if forloop.last == true %}
+    <li class=""active"">{{ title }}</li>
+  {%- elsif p.nav-show_overview %}
+    <li><a href=""{{ site.baseurl }}{{ p.url }}"">{{ title }}</a></li>
+  {%- else %}
+    <li>{{ title }}</li>
+  {%- endif -%}
+{%- endfor %}
+</ol>
+
+<h1>{{ page.title }}{% if page.is_beta %} <span class=""beta"">Beta</span>{% endif %}</h1>
+{% if site.show_outdated_warning %}
+<div class=""alert alert-danger"" role=""alert"">
+  {%- if page.language == ""en"" %}
+    <strong>This documentation is for an out-of-date version of Apache Flink. We recommend you use <a href=""https://ci.apache.org/projects/flink/flink-docs-stable/"">the latest stable version</a>.</strong>","[{'comment': '```suggestion\r\n    <strong>This documentation is for an out-of-date version of Apache Flink Stateful Functions. We recommend you use <a href=""https://ci.apache.org/projects/flink/flink-statefun-docs-stable/"">the latest stable version</a>.</strong>\r\n```', 'commenter': 'tzulitai'}]"
73,docs/_layouts/plain.html,"@@ -0,0 +1,78 @@
+---
+layout: base
+---
+<!--
+Licensed to the Apache Software Foundation (ASF) under one
+or more contributor license agreements.  See the NOTICE file
+distributed with this work for additional information
+regarding copyright ownership.  The ASF licenses this file
+to you under the Apache License, Version 2.0 (the
+""License""); you may not use this file except in compliance
+with the License.  You may obtain a copy of the License at
+
+  http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing,
+software distributed under the License is distributed on an
+""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+KIND, either express or implied.  See the License for the
+specific language governing permissions and limitations
+under the License.
+-->
+
+{%- assign active_pages = site.array -%}
+{%- assign active = page -%}
+
+{%- for i in (1..10) -%}
+  {%- assign active_pages = active_pages | push: active -%}
+  {%- if active.nav-parent_id -%}
+    {%- assign next = site.pages_by_language[page.language] | where: ""nav-id"" , active.nav-parent_id -%}
+    {%- if next.size > 0 -%}
+      {%- assign active = next[0] -%}
+    {%- else -%}
+      {%- break -%}
+    {%- endif -%}
+  {%- else -%}
+    {%- break -%}
+  {%- endif -%}
+{%- endfor -%}
+
+{% assign active_pages = active_pages | reverse %}
+
+<ol class=""breadcrumb"">
+{%- for p in active_pages %}
+  {% capture title %}{% if p.nav-title %}{{ p.nav-title }}{% else %}{{ p.title }}{% endif %}{% endcapture -%}
+  {%- if forloop.last == true %}
+    <li class=""active"">{{ title }}</li>
+  {%- elsif p.nav-show_overview %}
+    <li><a href=""{{ site.baseurl }}{{ p.url }}"">{{ title }}</a></li>
+  {%- else %}
+    <li>{{ title }}</li>
+  {%- endif -%}
+{%- endfor %}
+</ol>
+
+<h1>{{ page.title }}{% if page.is_beta %} <span class=""beta"">Beta</span>{% endif %}</h1>
+{% if site.show_outdated_warning %}
+<div class=""alert alert-danger"" role=""alert"">
+  {%- if page.language == ""en"" %}
+    <strong>This documentation is for an out-of-date version of Apache Flink. We recommend you use <a href=""https://ci.apache.org/projects/flink/flink-docs-stable/"">the latest stable version</a>.</strong>
+  {%- else if page.language == ""zh"" %}
+    <strong>本文档是 Apache Flink 的旧版本。建议访问 <a href=""https://ci.apache.org/projects/flink/flink-docs-stable/zh"">最新的稳定版本</a>。</strong>","[{'comment': '```suggestion\r\n    <strong>本文档是 Apache Flink Stateful Functions 的旧版本。建议访问 <a href=""https://ci.apache.org/projects/flink/flink-statefun-docs-stable/zh"">最新的稳定版本</a>。</strong>\r\n```', 'commenter': 'tzulitai'}]"
73,docs/index.md,"@@ -0,0 +1,53 @@
+---
+title: ""Stateful Functions - An Apache Flink® Project""","[{'comment': 'Would it be better to rename this title to be, `Apache Flink Stateful Functions Documentation`, to be more consistent with how the Flink docs look?:\r\n\r\n![image](https://user-images.githubusercontent.com/5284370/77506026-b7291600-6e9f-11ea-981b-df51d207fda7.png)\r\n\r\nI also like how the Flink docs home page has a line providing the meta information of the docs build:\r\n`This documentation is for Apache Flink version xxx. These pages were built at yyy`.', 'commenter': 'tzulitai'}]"
73,docs/index.md,"@@ -0,0 +1,53 @@
+---
+title: ""Stateful Functions - An Apache Flink® Project""
+nav-pos: 0
+nav-title: '<i class=""fa fa-home title"" aria-hidden=""true""></i> Home'
+nav-parent_id: root
+---
+<!--
+Licensed to the Apache Software Foundation (ASF) under one
+or more contributor license agreements.  See the NOTICE file
+distributed with this work for additional information
+regarding copyright ownership.  The ASF licenses this file
+to you under the Apache License, Version 2.0 (the
+""License""); you may not use this file except in compliance
+with the License.  You may obtain a copy of the License at
+
+  http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing,
+software distributed under the License is distributed on an
+""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+KIND, either express or implied.  See the License for the
+specific language governing permissions and limitations
+under the License.
+-->
+
+## A Framework for Stateful Distributed Applications","[{'comment': 'I think this sub-title is redundant.\r\n\r\nThe contents of this section can sit right under the main title of this homepage, as a brief intro.', 'commenter': 'tzulitai'}]"
73,docs/getting-started/walkthrough.md,"@@ -0,0 +1,200 @@
+---
+title: ""Walkthrough""
+nav-id: walkthrough
+nav-title: 'Walkthrough'
+nav-parent_id: getting-started
+nav-pos: 1
+---
+<!--
+Licensed to the Apache Software Foundation (ASF) under one
+or more contributor license agreements.  See the NOTICE file
+distributed with this work for additional information
+regarding copyright ownership.  The ASF licenses this file
+to you under the Apache License, Version 2.0 (the
+""License""); you may not use this file except in compliance
+with the License.  You may obtain a copy of the License at
+
+  http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing,
+software distributed under the License is distributed on an
+""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+KIND, either express or implied.  See the License for the
+specific language governing permissions and limitations
+under the License.
+-->
+
+Like all great introductions in software, this walkthrough will start at the beginning: saying hello.
+The application will run a simple function that accepts a request and responds with a greeting.
+It will not attempt to cover all the complexities of application development, but instead focus on building a stateful function — which is where you will implement your business logic.
+
+* This will be replaced by the TOC
+{:toc}
+
+## A Basic Hello
+
+Greeting actions are triggered by consuming, routing and passing messages that are defined using ProtoBuf.
+
+{% highlight proto %}
+syntax = ""proto3"";
+
+message GreetRequest {
+    string who = 1;
+}
+
+message GreetResponse {
+    string who = 1;
+    string greeting = 2;
+}
+{% endhighlight %}
+
+Under the hood, messages are processed using [stateful functions]({{ site.baseurl }}/sdk/java.html), by definition any class that implements the ``StatefulFunction`` interface.
+
+{% highlight java %}
+package org.apache.flink.statefun.examples.greeter;
+
+import org.apache.flink.statefun.sdk.Context;
+import org.apache.flink.statefun.sdk.StatefulFunction;
+
+public final class GreetFunction implements StatefulFunction {
+
+    @Override
+    public void invoke(Context context, Object input) {
+        GreetRequest greetMessage = (GreetRequest) input;
+
+        GreetResponse response = GreetResponse.newBuilder()
+            .setWho(greetMessage.getWho())
+            .setGreeting(""Hello "" + greetMessage.getWho())
+            .build();
+
+        context.send(GreetingConstants.GREETING_EGRESS_ID, response);
+    }
+}
+{% endhighlight %}
+
+
+This function takes in a request and sends a response to an external system (or [egress]({{ site.baseurl }}/io-module/index.html#egress)).
+While this is nice, it does not show off the real power of stateful functions: handling state.
+
+## A Stateful Hello
+
+Suppose you want to generate a personalized response for each user depending on how many times they have sent a request.
+
+{% highlight java %}
+private static String greetText(String name, int seen) {
+    switch (seen) {
+        case 0:
+            return String.format(""Hello %s !"", name);
+        case 1:
+            return String.format(""Hello again %s !"", name);
+        case 2:
+            return String.format(""Third times the charm! %s!"", name);
+        case 3:
+            return String.format(""Happy to see you once again %s !"", name);
+        default:
+            return String.format(""Hello at the %d-th time %s"", seen + 1, name);
+}
+{% endhighlight %}
+
+## Routing Messages
+
+To send a user a personalized greeting, the system needs to keep track of how many times it has seen each user so far.
+Speaking in general terms, the simplest solution would be to create one function for every user and independently track the number of times they have been seen. Using most frameworks, this would be prohibitively expensive.
+However, stateful functions are virtual and do not consume any CPU or memory when not actively being invoked.
+That means your application can create as many functions as necessary — in this case, users — without worrying about resource consumption.
+
+Whenever data is consumed from an external system (or [ingress]({{ site.baseurl }}/io-module/index.html#ingress)), it is routed to a specific function based on a given function type and identifier.
+The function type represents the Class of function to be invoked, such as the Greeter function, while the identifier (``GreetRequest#getWho``) scopes the call to a specific virtual instance based on some key.
+
+{% highlight java %}
+package org.apache.flink.statefun.examples.greeter;
+
+import org.apache.flink.statefun.examples.kafka.generated.GreetRequest;
+import org.apache.flink.statefun.sdk.io.Router;
+
+final class GreetRouter implements Router<GreetRequest> {
+
+    @Override
+    public void route(GreetRequest message, Downstream<GreetRequest> downstream) {
+        downstream.forward(GreetingConstants.GREETER_FUNCTION_TYPE, message.getWho(), message);
+    }
+}
+{% endhighlight %}
+
+So, if a message for a user named John comes in, it will be shipped to John’s dedicated Greeter function.
+In case there is a following message for a user named Jane, a new instance of the Greeter function will be spawned.
+
+## Persistence
+
+[Persisted value]({{ site.baseurl }}/sdk/java.html#persistence) is a special data type that enables stateful functions to maintain fault-tolerant state scoped to their identifiers, so that each instance of a function can track state independently.
+To “remember” information across multiple greeting messages, you then need to associate a persisted value field (``count``) to the Greet function. For each user, functions can now track how many times they have been seen.
+
+{% highlight java %}
+package org.apache.flink.statefun.examples.greeter;
+
+import org.apache.flink.statefun.sdk.Context;
+import org.apache.flink.statefun.sdk.StatefulFunction;
+import org.apache.flink.statefun.sdk.annotations.Persisted;
+import org.apache.flink.statefun.sdk.state.PersistedValue;
+
+public final class GreetFunction implements StatefulFunction {
+
+    @Persisted
+    private final PersistedValue<Integer> count = PersistedValue.of(""count"", Integer.class);
+
+    @Override
+    public void invoke(Context context, Object input) {
+        GreetRequest greetMessage = (GreetRequest) input;
+
+        GreetResponse response = computePersonalizedGreeting(greetMessage);
+
+        context.send(GreetingConstants.GREETING_EGRESS_ID, response);
+    }
+
+    private GreetResponse computePersonalizedGreeting(GreetRequest greetMessage) {
+        final String name = greetMessage.getWho();
+        final int seen = count.getOrDefault(0);
+        count.set(seen + 1);
+
+        String greeting = greetText(name, seen);
+
+        return GreetResponse.newBuilder()
+            .setWho(name)
+            .setGreeting(greeting)
+            .build();
+    }
+}
+{% endhighlight %}
+
+Each time a message is processed, the function computes a personalized message for that user.
+It reads and updates the number of times that user has been seen and sends a greeting to the egress.
+
+You can check the full code for the application described in this walkthrough `here <{examples}/statefun-greeter-example>`.","[{'comment': 'I guess this is supposed to be a link?', 'commenter': 'rmetzger'}, {'comment': 'Yep, nice catch. ', 'commenter': 'sjwiesman'}]"
95,docs/concepts/distributed_architecture.md,"@@ -0,0 +1,99 @@
+---
+title: Distributed Architecture 
+nav-id: dist-arch
+nav-pos: 2
+nav-title: Architecture
+nav-parent_id: concepts
+---
+<!--
+Licensed to the Apache Software Foundation (ASF) under one
+or more contributor license agreements.  See the NOTICE file
+distributed with this work for additional information
+regarding copyright ownership.  The ASF licenses this file
+to you under the Apache License, Version 2.0 (the
+""License""); you may not use this file except in compliance
+with the License.  You may obtain a copy of the License at
+
+  http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing,
+software distributed under the License is distributed on an
+""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+KIND, either express or implied.  See the License for the
+specific language governing permissions and limitations
+under the License.
+-->
+
+A Stateful Functions deployment consists of a few components interacting together. Here we describe these pieces and their ","[{'comment': ""You're missing the second half of this sentence. "", 'commenter': 'sjwiesman'}, {'comment': 'Here we describe these pieces and their relationship to each other and the Apache Flink runtime.', 'commenter': 'sjwiesman'}]"
95,docs/concepts/distributed_architecture.md,"@@ -0,0 +1,99 @@
+---
+title: Distributed Architecture 
+nav-id: dist-arch
+nav-pos: 2
+nav-title: Architecture
+nav-parent_id: concepts
+---
+<!--
+Licensed to the Apache Software Foundation (ASF) under one
+or more contributor license agreements.  See the NOTICE file
+distributed with this work for additional information
+regarding copyright ownership.  The ASF licenses this file
+to you under the Apache License, Version 2.0 (the
+""License""); you may not use this file except in compliance
+with the License.  You may obtain a copy of the License at
+
+  http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing,
+software distributed under the License is distributed on an
+""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+KIND, either express or implied.  See the License for the
+specific language governing permissions and limitations
+under the License.
+-->
+
+A Stateful Functions deployment consists of a few components interacting together. Here we describe these pieces and their 
+
+* This will be replaced by the TOC
+{:toc}
+
+## High-level View
+
+A *Stateful Functions* deployment consists of a set of **Apache Flink Stateful Functions** processes and, optionally, various deployments that execute remote functions.
+
+<p class=""text-center"">
+    <img width=""80%"" src=""{{ site.baseurl }}/fig/concepts/arch_overview.svg""/>
+</p>
+
+The Flink worker processes (TaskManagers) receive the events from the ingress systems (Kafka, Kinesis, etc.) and route them to the target functions. They invoke the functions, and route the resulting mesages to the next respective target functions. Messages designated for egress are written to an egress system (again, Kafka, Kinesis, ...).
+
+## Components
+
+The heavy lifting is done by the Apache Flink processes, which manage the state, handle the messaging, and invoke the stateful functions.
+The Flink cluster consists typically of one master and multiple workers (TaskManagers).
+
+<p class=""text-center"">
+    <img width=""80%"" src=""{{ site.baseurl }}/fig/concepts/arch_components.svg""/>
+</p>
+
+In addition to the Apache Flink processes, a full deployment requires [ZooKeeper](https://zookeeper.apache.org/) (for [master failover](https://ci.apache.org/projects/flink/flink-docs-stable/ops/jobmanager_high_availability.html)) and bulk storage (S3, HDFS, NAS, GCS, Azure Blob Store, etc.) to store Flink's [checkpoints](https://ci.apache.org/projects/flink/flink-docs-master/concepts/stateful-stream-processing.html#checkpointing). In turn, the deployment requires no database, and Flink processes do not require persistent volumes.
+
+## Logical Co-location, Physical Separation
+
+A core principle of many Stream Processors is that application logic and the application state must be co-located. That approach is the basis for their out-of-the box consistency. Stateful Function takes a unique approach to that by *logically co-locating* state and compute, but allowing to *physically separate* them.
+
+  - *Logical co-location:* Messaging, state access/updates and function invocations are managed tightly together, in the same way as in Flink's DataStream API. State is sharded by key, and messages are routed to the state by key. There is a single writer per key at a time, also scheduling the function invocations.
+
+  - *Physical separation:* Functions can be executed remotely, with message and state access provided as part of the invocation request. This way, functions can be managed independently, like stateless processes.
+
+
+## Deployment Styles for Functions
+
+The stateful functions themselves can be deployed in various ways that trade off certain properties with each other: loose coupling and independent scaling on the one hand with performance overhead on the other hand. Each module of functions can be of a different kind, so some functions can run remote, while others could run embedded.
+
+#### Remote Functions
+
+*Remote Functions* use the above-mentioned principle of *physical separation* while maintaining *logical co-location*. The state/messaging tier (i.e., the Flink processes) and the function tier are deployed, managed, and scaled independently.
+
+Function invocations happen through an HTTP / gRPC protocol and go through a service that routes invocation requests to any available endpoint, for example a Kubernetes (load-balancing) service, the AWS request gateway for Lambda, etc. Because invocations are self-contained (contain message, state, access to timers, etc.) the target functions can treated like any stateless application.
+
+<p class=""text-center"">
+	<img width=""80%"" src=""{{ site.baseurl }}/fig/concepts/arch_funs_remote.svg""/>
+</p>
+
+
+Refer to the documentation on the [Python SDK]({{ site.baseurl }}/sdk/python.html) and [remote modules]({{ site.baseurl }}/sdk/modules.html#remote-module) for details. 
+
+#### Co-located Functions
+
+An alternative way of deploying functions is *co-location* with the Flink JVM processes. In such a setup, each Flink TaskManager would talk to one Function process sitting *""next to it""*. A common way to do this is to use a system like Kubernetes and deploy pods consisting of a Flink container and the function side-car container; the two communicate via the pod-local network.
+
+This mode supports different languages while avoiding to route invocations through a Service/LoadBalancer, but it cannot scale the state and compute parts independently.
+
+<p class=""text-center"">
+	<img width=""80%"" src=""{{ site.baseurl }}/fig/concepts/arch_funs_colocated.svg""/>
+</p>
+
+This style of deployment is similar to how Flink's Table API and API Beam's portability layer and deploy execute non-JVM functions.","[{'comment': ""```suggestion\r\nThis style of deployment is similar to how Flink's Table API and API Beam's portability layer deploy and execute non-JVM functions.\r\n```"", 'commenter': 'sjwiesman'}]"
95,docs/concepts/distributed_architecture.md,"@@ -0,0 +1,99 @@
+---
+title: Distributed Architecture 
+nav-id: dist-arch
+nav-pos: 2
+nav-title: Architecture
+nav-parent_id: concepts
+---
+<!--
+Licensed to the Apache Software Foundation (ASF) under one
+or more contributor license agreements.  See the NOTICE file
+distributed with this work for additional information
+regarding copyright ownership.  The ASF licenses this file
+to you under the Apache License, Version 2.0 (the
+""License""); you may not use this file except in compliance
+with the License.  You may obtain a copy of the License at
+
+  http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing,
+software distributed under the License is distributed on an
+""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+KIND, either express or implied.  See the License for the
+specific language governing permissions and limitations
+under the License.
+-->
+
+A Stateful Functions deployment consists of a few components interacting together. Here we describe these pieces and their 
+
+* This will be replaced by the TOC
+{:toc}
+
+## High-level View
+
+A *Stateful Functions* deployment consists of a set of **Apache Flink Stateful Functions** processes and, optionally, various deployments that execute remote functions.
+
+<p class=""text-center"">
+    <img width=""80%"" src=""{{ site.baseurl }}/fig/concepts/arch_overview.svg""/>
+</p>
+
+The Flink worker processes (TaskManagers) receive the events from the ingress systems (Kafka, Kinesis, etc.) and route them to the target functions. They invoke the functions, and route the resulting mesages to the next respective target functions. Messages designated for egress are written to an egress system (again, Kafka, Kinesis, ...).","[{'comment': '```suggestion\r\nThe Flink worker processes (TaskManagers) receive the events from the ingress systems (Kafka, Kinesis, etc.) and route them to the target functions. They invoke the functions and route the resulting messages to the next respective target functions. Messages designated for egress are written to an egress system (again, Kafka, Kinesis, ...).\r\n```', 'commenter': 'sjwiesman'}]"
95,docs/concepts/distributed_architecture.md,"@@ -0,0 +1,99 @@
+---
+title: Distributed Architecture 
+nav-id: dist-arch
+nav-pos: 2","[{'comment': 'I think this should come after the logical functions page, what do you think?\r\n```suggestion\r\nnav-pos: 3\r\n```', 'commenter': 'sjwiesman'}, {'comment': 'I agree here, for me personally the flow is better that way.', 'commenter': 'tzulitai'}]"
96,statefun-python-sdk/README.md,"@@ -1,98 +1,35 @@
-# Apache Flink Stateful Functions
+<img alt=""Stateful Functions"" src=""../docs/fig/stateful_functions_logo.png"" width=350px/>","[{'comment': ""This README is used as the PyPI project description, and apparently they don't support images.\r\nWould have to use plain titles here."", 'commenter': 'tzulitai'}, {'comment': 'Thanks, Gordon — will remove the images.', 'commenter': 'morsapaes'}]"
110,statefun-flink/statefun-flink-core/src/main/java/org/apache/flink/statefun/flink/core/httpfn/HttpFunctionProvider.java,"@@ -41,12 +45,32 @@ public RequestReplyFunction functionOfType(FunctionType type) {
     if (spec == null) {
       throw new IllegalArgumentException(""Unsupported type "" + type);
     }
-    // specific client reuses the same the connection pool and thread pool
-    // as the sharedClient.
-    OkHttpClient specificClient =
-        sharedClient.newBuilder().callTimeout(spec.maxRequestDuration()).build();
-    RequestReplyClient httpClient =
-        new HttpRequestReplyClient(HttpUrl.get(spec.endpoint()), specificClient);
-    return new RequestReplyFunction(spec.states(), spec.maxNumBatchRequests(), httpClient);
+    return new RequestReplyFunction(
+        spec.states(), spec.maxNumBatchRequests(), buildHttpClient(spec));
+  }
+
+  private RequestReplyClient buildHttpClient(HttpFunctionSpec spec) {
+    // We need to build a UDS HTTP client
+    if (spec.unixDomainSocket() != null) {
+      OkHttpClient specificClient =
+          sharedClient
+              .newBuilder()
+              .socketFactory(new AFUNIXSocketFactory.FactoryArg(spec.unixDomainSocket()))
+              // Enable HTTP/2 if available (uses H2 upgrade),
+              // otherwise fallback to HTTP/1.1
+              .protocols(Collections.singletonList(Protocol.HTTP_2))
+              .callTimeout(spec.maxRequestDuration())
+              .build();
+
+      return new HttpRequestReplyClient(
+          // Only the path matters!
+          HttpUrl.get(URI.create(spec.endpoint().getPath())), specificClient);
+    } else {","[{'comment': 'style: you can skip the `else {` since it is followed by a return.', 'commenter': 'igalshilman'}]"
110,statefun-flink/statefun-flink-core/src/main/java/org/apache/flink/statefun/flink/core/httpfn/HttpFunctionProvider.java,"@@ -41,12 +45,32 @@ public RequestReplyFunction functionOfType(FunctionType type) {
     if (spec == null) {
       throw new IllegalArgumentException(""Unsupported type "" + type);
     }
-    // specific client reuses the same the connection pool and thread pool
-    // as the sharedClient.
-    OkHttpClient specificClient =
-        sharedClient.newBuilder().callTimeout(spec.maxRequestDuration()).build();
-    RequestReplyClient httpClient =
-        new HttpRequestReplyClient(HttpUrl.get(spec.endpoint()), specificClient);
-    return new RequestReplyFunction(spec.states(), spec.maxNumBatchRequests(), httpClient);
+    return new RequestReplyFunction(
+        spec.states(), spec.maxNumBatchRequests(), buildHttpClient(spec));
+  }
+
+  private RequestReplyClient buildHttpClient(HttpFunctionSpec spec) {
+    // We need to build a UDS HTTP client
+    if (spec.unixDomainSocket() != null) {
+      OkHttpClient specificClient =
+          sharedClient
+              .newBuilder()
+              .socketFactory(new AFUNIXSocketFactory.FactoryArg(spec.unixDomainSocket()))
+              // Enable HTTP/2 if available (uses H2 upgrade),
+              // otherwise fallback to HTTP/1.1
+              .protocols(Collections.singletonList(Protocol.HTTP_2))","[{'comment': 'I think that this should be added to the `sharedClient`', 'commenter': 'igalshilman'}, {'comment': 'Should i do it in a separate PR or this one is fine?', 'commenter': 'slinkydeveloper'}, {'comment': 'This one is fine.', 'commenter': 'igalshilman'}, {'comment': 'Done', 'commenter': 'slinkydeveloper'}]"
110,statefun-flink/statefun-flink-core/src/main/java/org/apache/flink/statefun/flink/core/httpfn/HttpFunctionSpec.java,"@@ -27,18 +27,21 @@
 public final class HttpFunctionSpec implements FunctionSpec {
   private final FunctionType functionType;
   private final URI endpoint;
+  private final String unixDomainSocket;","[{'comment': 'This should be marked `@Nullable`', 'commenter': 'igalshilman'}]"
110,statefun-flink/statefun-flink-core/src/main/java/org/apache/flink/statefun/flink/core/httpfn/HttpFunctionSpec.java,"@@ -58,6 +61,10 @@ public URI endpoint() {
     return endpoint;
   }
 
+  public String unixDomainSocket() {","[{'comment': 'This should be `Optional<String> unixDomainSocket()`', 'commenter': 'igalshilman'}]"
110,statefun-flink/statefun-flink-core/src/main/java/org/apache/flink/statefun/flink/core/jsonmodule/JsonModule.java,"@@ -294,21 +295,31 @@ private static InetSocketAddress functionAddress(JsonNode functionNode) {
 
   private static URI functionUri(JsonNode functionNode) {
     String uri = Selectors.textAt(functionNode, Pointers.Functions.FUNCTION_ENDPOINT);
+    boolean hasUdsConfig =
+        Selectors.optionalTextAt(functionNode, Functions.FUNCTION_UDS).isPresent();
     URI typedUri = URI.create(uri);
     @Nullable String scheme = typedUri.getScheme();
-    if (scheme == null) {
+    if (!hasUdsConfig) {
+      if (scheme == null) {
+        throw new IllegalArgumentException(
+            ""Missing scheme in function endpoint ""
+                + uri
+                + ""; an http or https scheme must be provided."");
+      }
+      if (scheme.equalsIgnoreCase(""http"") || scheme.equalsIgnoreCase(""https"")) {
+        return typedUri;
+      }
       throw new IllegalArgumentException(
           ""Missing scheme in function endpoint ""
               + uri
               + ""; an http or https scheme must be provided."");
-    }
-    if (scheme.equalsIgnoreCase(""http"") || scheme.equalsIgnoreCase(""https"")) {
+    } else {
+      if (typedUri.getScheme() != null || typedUri.getAuthority() != null) {","[{'comment': '👍 nice validation', 'commenter': 'igalshilman'}]"
110,statefun-flink/statefun-flink-core/src/main/java/org/apache/flink/statefun/flink/core/httpfn/HttpFunctionProvider.java,"@@ -41,12 +45,32 @@ public RequestReplyFunction functionOfType(FunctionType type) {
     if (spec == null) {
       throw new IllegalArgumentException(""Unsupported type "" + type);
     }
-    // specific client reuses the same the connection pool and thread pool
-    // as the sharedClient.
-    OkHttpClient specificClient =
-        sharedClient.newBuilder().callTimeout(spec.maxRequestDuration()).build();
-    RequestReplyClient httpClient =
-        new HttpRequestReplyClient(HttpUrl.get(spec.endpoint()), specificClient);
-    return new RequestReplyFunction(spec.states(), spec.maxNumBatchRequests(), httpClient);
+    return new RequestReplyFunction(
+        spec.states(), spec.maxNumBatchRequests(), buildHttpClient(spec));
+  }
+
+  private RequestReplyClient buildHttpClient(HttpFunctionSpec spec) {
+    // We need to build a UDS HTTP client
+    if (spec.unixDomainSocket() != null) {
+      OkHttpClient specificClient =
+          sharedClient
+              .newBuilder()
+              .socketFactory(new AFUNIXSocketFactory.FactoryArg(spec.unixDomainSocket()))","[{'comment': ""Is there a reason that you chose not to implement a custom UDS socket factory like in the example at https://github.com/square/okhttp/tree/master/samples/unixdomainsockets/src/main/java/okhttp3/unixdomainsockets?\r\n\r\nI'm asking only because we should try to have the `statefun-flink-core` dependencies as slim as possible, as it directly influences the size of our base distributions. It might also not be too big of a deal if the `junixsocket-core` library is small."", 'commenter': 'tzulitai'}, {'comment': ""I didn't used the uds library proposed by okhttp `jnr-unixsocket` because it doesn't look in a very good shape (last release is 0.31 https://github.com/jnr/jnr-unixsocket/releases)\r\n\r\nI'll try to find out if we can use only `junixsocket-core`"", 'commenter': 'slinkydeveloper'}, {'comment': ""Ok so this factory comes from `common` module, that is the least module we can use because it's the one that contains the `java.net.Socket` implementation"", 'commenter': 'slinkydeveloper'}]"
110,statefun-flink/statefun-flink-core/src/main/java/org/apache/flink/statefun/flink/core/httpfn/HttpFunctionProvider.java,"@@ -41,12 +45,32 @@ public RequestReplyFunction functionOfType(FunctionType type) {
     if (spec == null) {
       throw new IllegalArgumentException(""Unsupported type "" + type);
     }
-    // specific client reuses the same the connection pool and thread pool
-    // as the sharedClient.
-    OkHttpClient specificClient =
-        sharedClient.newBuilder().callTimeout(spec.maxRequestDuration()).build();
-    RequestReplyClient httpClient =
-        new HttpRequestReplyClient(HttpUrl.get(spec.endpoint()), specificClient);
-    return new RequestReplyFunction(spec.states(), spec.maxNumBatchRequests(), httpClient);
+    return new RequestReplyFunction(
+        spec.states(), spec.maxNumBatchRequests(), buildHttpClient(spec));
+  }
+
+  private RequestReplyClient buildHttpClient(HttpFunctionSpec spec) {
+    // We need to build a UDS HTTP client
+    if (spec.unixDomainSocket() != null) {
+      OkHttpClient specificClient =
+          sharedClient
+              .newBuilder()
+              .socketFactory(new AFUNIXSocketFactory.FactoryArg(spec.unixDomainSocket()))
+              // Enable HTTP/2 if available (uses H2 upgrade),
+              // otherwise fallback to HTTP/1.1
+              .protocols(Collections.singletonList(Protocol.HTTP_2))
+              .callTimeout(spec.maxRequestDuration())
+              .build();
+
+      return new HttpRequestReplyClient(
+          // Only the path matters!
+          HttpUrl.get(URI.create(spec.endpoint().getPath())), specificClient);","[{'comment': 'For easier readability: maybe it makese sense to add to the spec class a getter method which just returns the path string without the scheme.', 'commenter': 'tzulitai'}]"
110,statefun-flink/statefun-flink-core/src/test/java/org/apache/flink/statefun/flink/core/jsonmodule/JsonModuleTest.java,"@@ -95,6 +96,7 @@ public void testEgresses() {
 
   private static StatefulFunctionModule fromPath(String path) {
     URL moduleUrl = JsonModuleTest.class.getClassLoader().getResource(path);
+    assertThat(moduleUrl, not(nullValue()));","[{'comment': 'This is an independent change, can you separate that to a different commit?', 'commenter': 'igalshilman'}, {'comment': 'Separate commit or separate PR?', 'commenter': 'slinkydeveloper'}, {'comment': ""Don't we squash the PR when we merge it? otherwise i rebase it a bit to look cleaner :smile: "", 'commenter': 'slinkydeveloper'}, {'comment': 'That’s fine, don’t worry about it.\r\nWe don’t necessarily squash, a single PR can produce multiple commits and they will be merged as is.\r\nThat’s why we try to separate the changes, i.e: did the thing, added test, refactored the test etc’\r\nBut don’t worry about it now, this is for your next PR ;)', 'commenter': 'igalshilman'}, {'comment': ""Ok thanks! I'll prefer to just squash this one"", 'commenter': 'slinkydeveloper'}]"
110,statefun-flink/statefun-flink-core/src/main/java/org/apache/flink/statefun/flink/core/httpfn/HttpFunctionProvider.java,"@@ -41,12 +48,51 @@ public RequestReplyFunction functionOfType(FunctionType type) {
     if (spec == null) {
       throw new IllegalArgumentException(""Unsupported type "" + type);
     }
-    // specific client reuses the same the connection pool and thread pool
-    // as the sharedClient.
-    OkHttpClient specificClient =
-        sharedClient.newBuilder().callTimeout(spec.maxRequestDuration()).build();
-    RequestReplyClient httpClient =
-        new HttpRequestReplyClient(HttpUrl.get(spec.endpoint()), specificClient);
-    return new RequestReplyFunction(spec.states(), spec.maxNumBatchRequests(), httpClient);
+    return new RequestReplyFunction(
+        spec.states(), spec.maxNumBatchRequests(), buildHttpClient(spec));
+  }
+
+  private RequestReplyClient buildHttpClient(HttpFunctionSpec spec) {
+    // We need to build a UDS HTTP client
+    if (spec.isUnixDomainSocket()) {
+
+      // We need to split the path in order to get the sock file and the path after the sock file
+      Path path = Paths.get(spec.endpoint().getPath());
+
+      int sockPath =","[{'comment': 'Can you move the `.sock` / endpoint seperation to a separate method,\r\nand add a unit test for that?\r\nA static method annotated with `@VisibleForTesting`.', 'commenter': 'igalshilman'}]"
110,pom.xml,"@@ -170,6 +171,11 @@ under the License.
                             </configuration>
                         </execution>
                     </executions>
+                    <configuration>","[{'comment': 'Can you explain that change? \r\nI am not able to build (on OS X) the project with that.', 'commenter': 'igalshilman'}, {'comment': ""Ops i wrongly committed that. On my machine Fedora 32 without that config it doesn't build"", 'commenter': 'slinkydeveloper'}]"
110,statefun-flink/statefun-flink-core/src/main/java/org/apache/flink/statefun/flink/core/httpfn/OkHttpUtils.java,"@@ -38,6 +41,9 @@ static OkHttpClient newClient() {
         .followRedirects(true)
         .followSslRedirects(true)
         .retryOnConnectionFailure(true)
+        // Enable HTTP/2 if available (uses H2 upgrade),
+        // otherwise fallback to HTTP/1.1
+        .protocols(Collections.singletonList(Protocol.HTTP_2))","[{'comment': 'It seems like okhttp has HTTP_2  already in the default protocol list, so this is not needed. \r\nMoreover the above code throws an exception (when specifying HTTP_2 you must also specify HTTP_1) but if you would look at the default builder you would see that okhttp already has HTTP_2 and HTTP_1 in the list of default protocols.\r\n\r\nAs an attempt to ""make it work"" I\'ve artificially added the prefix `http://localhost/` to the endpoint, what do you think about that (it is technically ""localhost"")?', 'commenter': 'igalshilman'}, {'comment': ""Ah i see:\r\n\r\n```\r\n  static final List<Protocol> DEFAULT_PROTOCOLS = Util.immutableList(\r\n      Protocol.HTTP_2, Protocol.HTTP_1_1);\r\n```\r\n\r\nI'm gonna remove this"", 'commenter': 'slinkydeveloper'}]"
110,statefun-flink/statefun-flink-core/src/main/java/org/apache/flink/statefun/flink/core/httpfn/HttpFunctionProvider.java,"@@ -41,12 +48,56 @@ public RequestReplyFunction functionOfType(FunctionType type) {
     if (spec == null) {
       throw new IllegalArgumentException(""Unsupported type "" + type);
     }
+    return new RequestReplyFunction(
+        spec.states(), spec.maxNumBatchRequests(), buildHttpClient(spec));
+  }
+
+  private RequestReplyClient buildHttpClient(HttpFunctionSpec spec) {
+    // We need to build a UDS HTTP client
+    if (spec.isUnixDomainSocket()) {
+
+      // We need to split the path in order to get the sock file and the path after the sock file
+      Map.Entry<String, String> splittedFilePathAndEndpoint =
+          splitFilePathAndEndpointForUDS(spec.endpoint());
+
+      OkHttpClient specificClient =
+          sharedClient
+              .newBuilder()
+              .socketFactory(
+                  new AFUNIXSocketFactory.FactoryArg(splittedFilePathAndEndpoint.getKey()))
+              .callTimeout(spec.maxRequestDuration())
+              .build();
+
+      return new HttpRequestReplyClient(
+          // Only the path matters!
+          HttpUrl.get(URI.create(splittedFilePathAndEndpoint.getValue())), specificClient);","[{'comment': ""There are two unfortunate things going on here:\r\n1) `HttpUrl.get` would silently return `null` if it was unable to parse the URI\r\n2) the endpoint only (rightfully so) contains the path without the schema and `HttpUrl` doesn't consider it to be valid.\r\n"", 'commenter': 'igalshilman'}, {'comment': ""Ah, that's interesting... So I suppose we need a placeholder value like https://github.com/square/okhttp/blob/master/samples/unixdomainsockets/src/main/java/okhttp3/unixdomainsockets/ClientAndServer.java#L48"", 'commenter': 'slinkydeveloper'}, {'comment': 'Ok I changed the invocation of `HttpUrl.get` to use the `String` override, where the documentation states\r\n\r\n```\r\n@throws IllegalArgumentException If {@code url} is not a well-formed HTTP or HTTPS URL.\r\n```\r\n\r\nHopefully this should avoid silent errors', 'commenter': 'slinkydeveloper'}]"
110,statefun-flink/statefun-flink-core/src/main/java/org/apache/flink/statefun/flink/core/httpfn/HttpFunctionProvider.java,"@@ -41,12 +48,56 @@ public RequestReplyFunction functionOfType(FunctionType type) {
     if (spec == null) {
       throw new IllegalArgumentException(""Unsupported type "" + type);
     }
+    return new RequestReplyFunction(
+        spec.states(), spec.maxNumBatchRequests(), buildHttpClient(spec));
+  }
+
+  private RequestReplyClient buildHttpClient(HttpFunctionSpec spec) {
+    // We need to build a UDS HTTP client
+    if (spec.isUnixDomainSocket()) {
+
+      // We need to split the path in order to get the sock file and the path after the sock file
+      Map.Entry<String, String> splittedFilePathAndEndpoint =
+          splitFilePathAndEndpointForUDS(spec.endpoint());
+
+      OkHttpClient specificClient =
+          sharedClient
+              .newBuilder()
+              .socketFactory(
+                  new AFUNIXSocketFactory.FactoryArg(splittedFilePathAndEndpoint.getKey()))","[{'comment': 'Unfortunately this does not seems to be working.\r\nI get the following stack trace:\r\nIt seems like okhttp is trying to set the socket timeout, before connecting (that makes senes) but the library \r\nexpects first a connection and then setting a timeout (which also makes senes)\r\n\r\n```\r\norker_1           | Caused by: java.net.SocketException: Not open\r\nworker_1           | \tat org.newsclub.net.unix.AFUNIXSocketImpl.validFdOrException(AFUNIXSocketImpl.java:424)\r\nworker_1           | \tat org.newsclub.net.unix.AFUNIXSocketImpl.setOption(AFUNIXSocketImpl.java:504)\r\nworker_1           | \tat org.newsclub.net.unix.AFUNIXSocketImpl$Lenient.setOption(AFUNIXSocketImpl.java:568)\r\nworker_1           | \tat java.net.Socket.setSoTimeout(Socket.java:1159)\r\nworker_1           | \tat okhttp3.internal.connection.RealConnection.connectSocket(RealConnection.java:261)\r\nworker_1           | \tat okhttp3.internal.connection.RealConnection.connect(RealConnection.java:183)\r\nworker_1           | \tat okhttp3.internal.connection.ExchangeFinder.findConnection(ExchangeFinder.java:224)\r\nworker_1           | \tat okhttp3.internal.connection.ExchangeFinder.findHealthyConnection(ExchangeFinder.java:108)\r\nworker_1           | \tat okhttp3.internal.connection.ExchangeFinder.find(ExchangeFinder.java:88)\r\nworker_1           | \tat okhttp3.internal.connection.Transmitter.newExchange(Transmitter.java:169)\r\nworker_1           | \tat okhttp3.internal.connection.ConnectInterceptor.intercept(ConnectInterceptor.java:41)\r\nworker_1           | \tat okhttp3.internal.http.RealInterceptorChain.proceed(RealInterceptorChain.java:142)\r\nworker_1           | \tat okhttp3.internal.http.RealInterceptorChain.proceed(RealInterceptorChain.java:117)\r\nworker_1           | \tat okhttp3.internal.cache.CacheInterceptor.intercept(CacheInterceptor.java:94)\r\nworker_1           | \tat okhttp3.internal.http.RealInterceptorChain.proceed(RealInterceptorChain.java:142)\r\nworker_1           | \tat okhttp3.internal.http.RealInterceptorChain.proceed(RealInterceptorChain.java:117)\r\nworker_1           | \tat okhttp3.internal.http.BridgeInterceptor.intercept(BridgeInterceptor.java:93)\r\nworker_1           | \tat okhttp3.internal.http.RealInterceptorChain.proceed(RealInterceptorChain.java:142)\r\nworker_1           | \tat okhttp3.internal.http.RetryAndFollowUpInterceptor.intercept(RetryAndFollowUpInterceptor.java:88)\r\nworker_1           | \tat okhttp3.internal.http.RealInterceptorChain.proceed(RealInterceptorChain.java:142)\r\nworker_1           | \tat okhttp3.internal.http.RealInterceptorChain.proceed(RealInterceptorChain.java:117)\r\nworker_1           | \tat okhttp3.RealCall.getResponseWithInterceptorChain(RealCall.java:229)\r\nworker_1           | \tat okhttp3.RealCall$AsyncCall.execute(RealCall.java:172)\r\n```', 'commenter': 'igalshilman'}, {'comment': ""Ok i'm on it"", 'commenter': 'slinkydeveloper'}, {'comment': ""Ok It looks like the socket factory doesn't really work as we expect..."", 'commenter': 'slinkydeveloper'}, {'comment': 'In that case I can see two options:\r\n* try out jnrsockets as provided in the original example.\r\n* provide a new RequestReplyClient that is specialized for Unix domain socket, and backed by something else than okhttp.\r\n', 'commenter': 'igalshilman'}, {'comment': 'Opened an issue on junixsocket https://github.com/kohlschutter/junixsocket/issues/79', 'commenter': 'slinkydeveloper'}]"
129,statefun-flink/statefun-flink-core/src/main/java/org/apache/flink/statefun/flink/core/StatefulFunctionsJob.java,"@@ -74,7 +75,9 @@ private static void setDefaultContextClassLoaderIfAbsent() {
     if (classLoader == null) {
       URLClassLoader flinkClassLoader =
           FlinkUserCodeClassLoaders.parentFirst(
-              new URL[0], StatefulFunctionsJob.class.getClassLoader());
+              new URL[0],
+              StatefulFunctionsJob.class.getClassLoader(),
+              FlinkUserCodeClassLoader.NOOP_EXCEPTION_HANDLER);","[{'comment': 'This is the same semantic as before. ', 'commenter': 'sjwiesman'}]"
129,statefun-flink/statefun-flink-core/src/main/java/org/apache/flink/statefun/flink/core/StatefulFunctionsConfig.java,"@@ -113,9 +111,6 @@ public static StatefulFunctionsConfig fromEnvironment(StreamExecutionEnvironment
   }
 
   private static Configuration getConfiguration(StreamExecutionEnvironment env) {
-    if (env instanceof StreamPlanEnvironment) {
-      return GlobalConfiguration.loadConfiguration();
-    }","[{'comment': '🎆 ', 'commenter': 'sjwiesman'}]"
129,statefun-flink/statefun-flink-core/src/main/java/org/apache/flink/statefun/flink/core/feedback/FeedbackUnionOperator.java,"@@ -61,14 +62,16 @@
       SerializableFunction<T, ?> keySelector,
       long totalMemoryUsedForFeedbackCheckpointing,
       TypeSerializer<T> elementSerializer,
-      MailboxExecutor mailboxExecutor) {
+      MailboxExecutor mailboxExecutor,
+      ProcessingTimeService processingTimeService) {
     this.feedbackKey = Objects.requireNonNull(feedbackKey);
     this.isBarrierMessage = Objects.requireNonNull(isBarrierMessage);
     this.keySelector = Objects.requireNonNull(keySelector);
     this.totalMemoryUsedForFeedbackCheckpointing = totalMemoryUsedForFeedbackCheckpointing;
     this.elementSerializer = Objects.requireNonNull(elementSerializer);
     this.mailboxExecutor = Objects.requireNonNull(mailboxExecutor);
     this.chainingStrategy = ChainingStrategy.ALWAYS;
+    this.processingTimeService = processingTimeService;","[{'comment': 'Why is this needed here?', 'commenter': 'igalshilman'}, {'comment': 'The processing time service is no longer set by default. We get a NullPointerException without this change. ', 'commenter': 'sjwiesman'}, {'comment': 'But AFIK it is not used by that specific operator.', 'commenter': 'igalshilman'}, {'comment': ""~You're right, I thought we were talking about FunctionDispatchOperator for some reason.~"", 'commenter': 'sjwiesman'}, {'comment': 'I take it back, this change is necessary. \r\n\r\n```\r\njava.lang.Exception: Exception while creating StreamOperatorStateContext.\r\n\tat org.apache.flink.streaming.api.operators.StreamTaskStateInitializerImpl.streamOperatorStateContext(StreamTaskStateInitializerImpl.java:204)\r\n\tat org.apache.flink.streaming.api.operators.AbstractStreamOperator.initializeState(AbstractStreamOperator.java:247)\r\n\tat org.apache.flink.streaming.runtime.tasks.OperatorChain.initializeStateAndOpenOperators(OperatorChain.java:290)\r\n\tat org.apache.flink.streaming.runtime.tasks.StreamTask.lambda$beforeInvoke$0(StreamTask.java:473)\r\n\tat org.apache.flink.streaming.runtime.tasks.StreamTaskActionExecutor$1.runThrowing(StreamTaskActionExecutor.java:47)\r\n\tat org.apache.flink.streaming.runtime.tasks.StreamTask.beforeInvoke(StreamTask.java:469)\r\n\tat org.apache.flink.streaming.runtime.tasks.StreamTask.invoke(StreamTask.java:522)\r\n\tat org.apache.flink.runtime.taskmanager.Task.doRun(Task.java:721)\r\n\tat org.apache.flink.runtime.taskmanager.Task.run(Task.java:546)\r\n\tat java.lang.Thread.run(Thread.java:748)\r\nCaused by: java.lang.NullPointerException\r\n\tat org.apache.flink.util.Preconditions.checkNotNull(Preconditions.java:58)\r\n\tat org.apache.flink.streaming.api.operators.InternalTimeServiceManager.<init>(InternalTimeServiceManager.java:88)\r\n\tat org.apache.flink.streaming.api.operators.StreamTaskStateInitializerImpl.internalTimeServiceManager(StreamTaskStateInitializerImpl.java:225)\r\n\tat org.apache.flink.streaming.api.operators.StreamTaskStateInitializerImpl.streamOperatorStateContext(StreamTaskStateInitializerImpl.java:167)\r\n\t... 9 more\r\n```', 'commenter': 'sjwiesman'}, {'comment': 'That is unfortunate, the latest changes around the `AbstractStreamOperaptor` indeed requires setting the `AbstractStreamOperaptor.processingTimeService` to a non null value, even tho it is not directly used. \r\nCan you please change `this.processingTimeService` -> `super.processingTimeService` and add a comment, so that it would not be accidentally removed by someone else later?', 'commenter': 'igalshilman'}, {'comment': 'done', 'commenter': 'sjwiesman'}]"
129,statefun-flink/statefun-flink-core/src/main/java/org/apache/flink/statefun/flink/core/feedback/FeedbackUnionOperatorFactory.java,"@@ -65,9 +65,13 @@ public FeedbackUnionOperatorFactory(
             keySelector,
             configuration.getFeedbackBufferSize().getBytes(),
             serializer,
-            mailboxExecutor);
+            mailboxExecutor,
+            streamOperatorParameters.getProcessingTimeService());","[{'comment': 'It is not used in the FeedbackUnionOperator', 'commenter': 'igalshilman'}]"
129,statefun-flink/statefun-flink-state-processor/pom.xml,"@@ -74,7 +74,12 @@ under the License.
             <type>test-jar</type>
             <scope>test</scope>
         </dependency>
-
+        <dependency>","[{'comment': 'Can you explain that dependency? \r\nDoes it brings something that was previously else where?\r\ncc: @tzulitai ', 'commenter': 'igalshilman'}, {'comment': 'This change is due to [FLINK-15090](https://issues.apache.org/jira/browse/FLINK-15090). flink-clients is no longer a transitive dependency but is needed to execute the test. ', 'commenter': 'sjwiesman'}]"
129,tools/docker/flink-distribution-template/conf/flink-conf.yaml,"@@ -28,6 +28,7 @@ state.backend: rocksdb
 state.backend.rocksdb.timer-service.factory: ROCKSDB
 state.checkpoints.dir: file:///checkpoint-dir
 state.backend.incremental: true
+jobmanager.memory.process.size: 1g","[{'comment': 'Is that a new mandatory parameter? if so the `helm` charts needs to be updated as well.', 'commenter': 'igalshilman'}, {'comment': ""Yes, this is now mandatory. I'll update the helm charts. "", 'commenter': 'sjwiesman'}, {'comment': 'The 1g memory size was arbitrary though so if you have a different value in mind just lmk. ', 'commenter': 'sjwiesman'}]"
131,README.zh.md,"@@ -0,0 +1,228 @@
+<img alt=""有状态函数"" src=""docs/fig/stateful_functions_logo.png"" width=350px/>
+
+有状态函数是一个[Apache Flink](https://flink.apache.org/)库， __可简化构建分布式有状态应用程序的过程__ 。它基于有着可持久化状态的函数，这些函数可以在强大的一致性保证下进行动态交互。 
+
+有状态函数使强大的状态管理和组合，与AWS Lambda之类的FaaS实现和Kubernetes之类的现代资源编排框架的弹性，快速缩放/零缩放和滚动升级功能相结合成为可能。通过这些特性，它解决了当今许多FaaS设置中[最常被引用的两个缺点](https://www2.eecs.berkeley.edu/Pubs/TechRpts/2019/EECS-2019-3.pdf) ：状态一致和函数之间的高效消息传递。 
+
+本自述文件旨在简要介绍核心概念以及如何进行设置
+以使您开始使用有状态函数。 
+
+有关详细文档，请访问[官方文档](https://ci.apache.org/projects/flink/flink-statefun-docs-master) 。 
+
+有关代码示例，请查看[示例](statefun-examples/) 。 
+
+ [![构建状态](https://travis-ci.org/apache/flink-statefun.svg?branch=master)](https://travis-ci.org/apache/flink-statefun) 
+
+## 目录
+
+- [核心概念](#core-concepts) 
+   * [抽象化](#abstraction) 
+   * [函数模块和可扩展性](#modules) 
+   * [运行时](#runtime) 
+- [入门](#getting-started) 
+   * [运行一个完整的例子](#greeter) 
+   * [新建项目](#project-setup) 
+   * [构建项目](#build) 
+   * [在IDE Harness中运行](#ide-harness) 
+- [部署应用](#deploying) 
+   * [使用Docker映像进行部署](#docker) 
+   * [部署为Flink作业](#flink) 
+- [贡献](#contributing) 
+- [开源软件许可](#license) 
+
+## <a name=""core-concepts""></a>核心概念
+
+### <a name=""abstraction""></a>抽象化
+
+有状态函数应用程序由以下原语组成：有状态函数，入口(ingress)，
+路由器(router)和出口(egress)。 
+
+<p align=""center"">
+  <img src=""docs/fig/stateful_functions_overview.png"" width=""650px""/>
+</p>
+
+#### 有状态函数
+
+* _有状态函数_是通过消息调用的一小段逻辑/代码。每个有状态函数
+都作为_函数类型_的唯一可调用_虚拟实例_存在。每个实例都通过其``type``以及type中的唯一``ID`` （字符串）来寻址。 
+
+* 有状态函数可以从ingress或任何其他有状态函数（包括其自身）中调用。
+调用者只需要知道目标函数的地址即可。 
+
+* 函数实例是_虚拟的_ ，因为它们不总是同时在内存中活跃。
+在任何时间点，只有一小部分函数及其状态作为实际对象存在。当
+虚拟实例接收到消息时，将配置一个对象并带着该虚拟实例的状态
+加载，然后处理该消息。与虚拟内存类似，许多函数的状态可能
+在任何时间点都被“交换出去”(swap out)。 
+
+* 函数的每个虚拟实例都有其自己的状态，可以通过局部变量访问。
+该状态是私有的，对于该实例是本地的(local)。
+
+如果您知道Apache Flink的DataStream API，则可以将有状态函数考虑为轻量级的
+`KeyedProcessFunction` 。函数``type``等同于处理函数转换(process function transformation)，而`` ID ``是键(key)。不同之处
+在于，函数不是在定义数据流的有向非循环图（DAG）中组装（流拓扑），
+而是使用地址将事件任意发送到所有其他函数。 
+
+#### 入口和出口
+
+* _入口_ (Ingress)是事件最初到达有状态函数应用程序的方式。
+入口可以是消息队列，日志或HTTP服务器-产生事件并由
+应用程序处理的任何物件。 
+
+* _路由器_(Router)连接到入口(Ingress)，以确定哪个函数实例应最初处理事件。 
+
+* _出口_(Egress)是一种以标准化方式从应用程序发送事件的方法。
+出口是可选的；也有可能没有事件离开应用程序和函数接收器(functions sink)事件，或
+直接调用其他应用程序。 
+
+### <a name=""modules""></a>模块(Module)
+
+ _模块_(Module)将核心构建基元添加到有状态函数
+ 应用程序的入口点，即入口，出口，路由器和有状态函数。 
+
+单个应用程序可以是多个模块的组合，每个模块都构成整个应用程序的一部分。
+这允许应用程序的不同部分由不同的模块来组成。例如，
+一个模块可以提供入口和出口，而其他模块可以分别作为状态函数来
+贡献业务逻辑的特定部分。这有助于在独立团队中工作，但仍可以部署到
+相同的更大应用程序中。 
+
+## <a name=""runtime"">运行时 
+
+有状态函数运行时旨在提供一组类似于[无服务器函数](https://martinfowler.com/articles/serverless.html)属性的属性，但适用于有状态问题。 
+
+<p align=""center"">
+  <img src=""docs/fig/stateful_functions_overview-ops.png"" width=""600px""/>
+</p>
+
+运行时建立在Apache Flink<sup>®</sup>，并具有以下设计原则：
+
+*  __逻辑计算/状态共置：__消息传递，状态访问/更新和函数调用在一起紧密管理。这确保了开箱即用地在高层次支持一致性。 <!--TODO: disambiguate high-level 更抽象的(eg. high-level API) vs. 更高度的(eg. a high level of activity) -->
+
+* __物理计算/状态分离：__可以远程执行函数，并将消息和状态访问作为调用请求的一部分提供。这样，可以像无状态进程一样管理函数，并支持快速扩展，滚动升级和其他常见的操作模式。 
+
+* __语言独立性：__函数调用使用简单的HTTP协议/基于gRPC的协议，因此可以轻松地以各种语言实现函数。  
+
+这使得可以在Kubernetes部署，在FaaS平台上或（微）服务后面执行函数，同时在函数之间提供一致的状态和轻量级消息传递。 
+
+## <a name=""getting-started""></a>入门
+
+请按照此处的步骤立即开始使用有状态函数。 
+
+本指南将引导您进行设置以开始开发和测试自己的状态函数（Java）应用程序，并运行现有示例。如果您想使用Python快速开始，
+请查看[StateFun Python SDK](https://github.com/apache/flink-statefun/tree/master/statefun-python-sdk)和[Python Greeter示例](https://github.com/apache/flink-statefun/tree/master/statefun-examples/statefun-python-greeter-example) 。 
+
+### <a name=""project-setup""></a>项目设置
+
+前提条件： 
+
+* Docker  
+    
+* Maven 3.5.x 及以上
+    
+* Java 8 及以上
+
+您可以使用提供的快速入门Maven原型快速开始构建Stateful Function有状态函数应用程序： 
+
+```
+mvn archetype:generate \
+  -DarchetypeGroupId=org.apache.flink \
+  -DarchetypeArtifactId=statefun-quickstart \
+  -DarchetypeVersion=2.2-SNAPSHOT
+```
+
+这使您可以命名新创建的项目。它将以交互方式询问您`` GroupId `` ， 
+`` ArtifactId ``和程序包名称。将有一个与您的`` ArtifactId ``同名的新目录。 
+
+我们建议您将此项目导入到IDE中进行开发和测试。 
+IntelliJ IDEA开箱即用地支持Maven项目。如果使用Eclipse，则`` m2e ``插件允许导入
+Maven项目。某些Eclipse捆绑包默认包含该插件，而另一些则需要您手动安装。 
+
+### <a name=""build""></a>建设项目","[{'comment': 'TODO: fix 构建项目', 'commenter': 'billyrrr'}, {'comment': 'I think `构建项目` is better.', 'commenter': 'carp84'}]"
131,README.zh.md,"@@ -0,0 +1,228 @@
+<img alt=""有状态函数"" src=""docs/fig/stateful_functions_logo.png"" width=350px/>","[{'comment': 'I\'m not quite sure whether translate the name into Chinese is a good idea. Personally I prefer to keep the English name.\r\n```suggestion\r\n<img alt=""Stateful Functions"" src=""docs/fig/stateful_functions_logo.png"" width=350px/>\r\n```', 'commenter': 'carp84'}]"
131,README.zh.md,"@@ -0,0 +1,228 @@
+<img alt=""有状态函数"" src=""docs/fig/stateful_functions_logo.png"" width=350px/>
+
+有状态函数是一个[Apache Flink](https://flink.apache.org/)库， __可简化构建分布式有状态应用程序的过程__ 。它基于有着可持久化状态的函数，这些函数可以在强大的一致性保证下进行动态交互。 ","[{'comment': 'Ditto\r\n```suggestion\r\nStateful Functions 是一个[Apache Flink](https://flink.apache.org/)库， __可简化构建分布式有状态应用程序的过程__ 。它基于有着可持久化状态的函数，这些函数可以在强大的一致性保证下进行动态交互。 \r\n```', 'commenter': 'carp84'}]"
131,README.zh.md,"@@ -0,0 +1,228 @@
+<img alt=""有状态函数"" src=""docs/fig/stateful_functions_logo.png"" width=350px/>
+
+有状态函数是一个[Apache Flink](https://flink.apache.org/)库， __可简化构建分布式有状态应用程序的过程__ 。它基于有着可持久化状态的函数，这些函数可以在强大的一致性保证下进行动态交互。 
+
+有状态函数使强大的状态管理和组合，与AWS Lambda之类的FaaS实现和Kubernetes之类的现代资源编排框架的弹性，快速缩放/零缩放和滚动升级功能相结合成为可能。通过这些特性，它解决了当今许多FaaS设置中[最常被引用的两个缺点](https://www2.eecs.berkeley.edu/Pubs/TechRpts/2019/EECS-2019-3.pdf) ：状态一致和函数之间的高效消息传递。 ","[{'comment': '```suggestion\r\nStateful Functions 使我们能够将强大的状态管理和组合方法，与 AWS Lambda 等 FaaS 实现和 Kubernetes 等现代资源编排框架的弹性、快速扩缩容和滚动升级功能相结合。通过这些特性，它解决了当今许多 FaaS 解决方案中[最常被引用的两个缺点](https://www2.eecs.berkeley.edu/Pubs/TechRpts/2019/EECS-2019-3.pdf) ：函数间的状态一致性和高效消息传递。 \r\n```', 'commenter': 'carp84'}]"
131,README.zh.md,"@@ -0,0 +1,228 @@
+<img alt=""有状态函数"" src=""docs/fig/stateful_functions_logo.png"" width=350px/>
+
+有状态函数是一个[Apache Flink](https://flink.apache.org/)库， __可简化构建分布式有状态应用程序的过程__ 。它基于有着可持久化状态的函数，这些函数可以在强大的一致性保证下进行动态交互。 
+
+有状态函数使强大的状态管理和组合，与AWS Lambda之类的FaaS实现和Kubernetes之类的现代资源编排框架的弹性，快速缩放/零缩放和滚动升级功能相结合成为可能。通过这些特性，它解决了当今许多FaaS设置中[最常被引用的两个缺点](https://www2.eecs.berkeley.edu/Pubs/TechRpts/2019/EECS-2019-3.pdf) ：状态一致和函数之间的高效消息传递。 
+
+本自述文件旨在简要介绍核心概念以及如何进行设置
+以使您开始使用有状态函数。 ","[{'comment': '```suggestion\r\n该文档旨在简要介绍使用 Stateful Functions 需要了解的核心概念和设置方法。 \r\n```', 'commenter': 'carp84'}]"
131,README.zh.md,"@@ -0,0 +1,228 @@
+<img alt=""有状态函数"" src=""docs/fig/stateful_functions_logo.png"" width=350px/>
+
+有状态函数是一个[Apache Flink](https://flink.apache.org/)库， __可简化构建分布式有状态应用程序的过程__ 。它基于有着可持久化状态的函数，这些函数可以在强大的一致性保证下进行动态交互。 
+
+有状态函数使强大的状态管理和组合，与AWS Lambda之类的FaaS实现和Kubernetes之类的现代资源编排框架的弹性，快速缩放/零缩放和滚动升级功能相结合成为可能。通过这些特性，它解决了当今许多FaaS设置中[最常被引用的两个缺点](https://www2.eecs.berkeley.edu/Pubs/TechRpts/2019/EECS-2019-3.pdf) ：状态一致和函数之间的高效消息传递。 
+
+本自述文件旨在简要介绍核心概念以及如何进行设置
+以使您开始使用有状态函数。 
+
+有关详细文档，请访问[官方文档](https://ci.apache.org/projects/flink/flink-statefun-docs-master) 。 ","[{'comment': '```suggestion\r\n更多详细信息，请访问[官方文档](https://ci.apache.org/projects/flink/flink-statefun-docs-master) 。 \r\n```', 'commenter': 'carp84'}]"
131,README.zh.md,"@@ -0,0 +1,228 @@
+<img alt=""有状态函数"" src=""docs/fig/stateful_functions_logo.png"" width=350px/>
+
+有状态函数是一个[Apache Flink](https://flink.apache.org/)库， __可简化构建分布式有状态应用程序的过程__ 。它基于有着可持久化状态的函数，这些函数可以在强大的一致性保证下进行动态交互。 
+
+有状态函数使强大的状态管理和组合，与AWS Lambda之类的FaaS实现和Kubernetes之类的现代资源编排框架的弹性，快速缩放/零缩放和滚动升级功能相结合成为可能。通过这些特性，它解决了当今许多FaaS设置中[最常被引用的两个缺点](https://www2.eecs.berkeley.edu/Pubs/TechRpts/2019/EECS-2019-3.pdf) ：状态一致和函数之间的高效消息传递。 
+
+本自述文件旨在简要介绍核心概念以及如何进行设置
+以使您开始使用有状态函数。 
+
+有关详细文档，请访问[官方文档](https://ci.apache.org/projects/flink/flink-statefun-docs-master) 。 
+
+有关代码示例，请查看[示例](statefun-examples/) 。 ","[{'comment': '```suggestion\r\n相关代码示例，请查看[这里](statefun-examples/) 。 \r\n```', 'commenter': 'carp84'}]"
131,README.zh.md,"@@ -0,0 +1,228 @@
+<img alt=""有状态函数"" src=""docs/fig/stateful_functions_logo.png"" width=350px/>
+
+有状态函数是一个[Apache Flink](https://flink.apache.org/)库， __可简化构建分布式有状态应用程序的过程__ 。它基于有着可持久化状态的函数，这些函数可以在强大的一致性保证下进行动态交互。 
+
+有状态函数使强大的状态管理和组合，与AWS Lambda之类的FaaS实现和Kubernetes之类的现代资源编排框架的弹性，快速缩放/零缩放和滚动升级功能相结合成为可能。通过这些特性，它解决了当今许多FaaS设置中[最常被引用的两个缺点](https://www2.eecs.berkeley.edu/Pubs/TechRpts/2019/EECS-2019-3.pdf) ：状态一致和函数之间的高效消息传递。 
+
+本自述文件旨在简要介绍核心概念以及如何进行设置
+以使您开始使用有状态函数。 
+
+有关详细文档，请访问[官方文档](https://ci.apache.org/projects/flink/flink-statefun-docs-master) 。 
+
+有关代码示例，请查看[示例](statefun-examples/) 。 
+
+ [![构建状态](https://travis-ci.org/apache/flink-statefun.svg?branch=master)](https://travis-ci.org/apache/flink-statefun) 
+
+## 目录
+
+- [核心概念](#core-concepts) 
+   * [抽象化](#abstraction) ","[{'comment': '```suggestion\r\n   * [摘要](#abstraction) \r\n```', 'commenter': 'carp84'}]"
131,README.zh.md,"@@ -0,0 +1,228 @@
+<img alt=""有状态函数"" src=""docs/fig/stateful_functions_logo.png"" width=350px/>
+
+有状态函数是一个[Apache Flink](https://flink.apache.org/)库， __可简化构建分布式有状态应用程序的过程__ 。它基于有着可持久化状态的函数，这些函数可以在强大的一致性保证下进行动态交互。 
+
+有状态函数使强大的状态管理和组合，与AWS Lambda之类的FaaS实现和Kubernetes之类的现代资源编排框架的弹性，快速缩放/零缩放和滚动升级功能相结合成为可能。通过这些特性，它解决了当今许多FaaS设置中[最常被引用的两个缺点](https://www2.eecs.berkeley.edu/Pubs/TechRpts/2019/EECS-2019-3.pdf) ：状态一致和函数之间的高效消息传递。 
+
+本自述文件旨在简要介绍核心概念以及如何进行设置
+以使您开始使用有状态函数。 
+
+有关详细文档，请访问[官方文档](https://ci.apache.org/projects/flink/flink-statefun-docs-master) 。 
+
+有关代码示例，请查看[示例](statefun-examples/) 。 
+
+ [![构建状态](https://travis-ci.org/apache/flink-statefun.svg?branch=master)](https://travis-ci.org/apache/flink-statefun) 
+
+## 目录
+
+- [核心概念](#core-concepts) 
+   * [抽象化](#abstraction) 
+   * [函数模块和可扩展性](#modules) 
+   * [运行时](#runtime) 
+- [入门](#getting-started) 
+   * [运行一个完整的例子](#greeter) 
+   * [新建项目](#project-setup) 
+   * [构建项目](#build) 
+   * [在IDE Harness中运行](#ide-harness) 
+- [部署应用](#deploying) 
+   * [使用Docker映像进行部署](#docker) 
+   * [部署为Flink作业](#flink) 
+- [贡献](#contributing) ","[{'comment': '```suggestion\r\n- [参与贡献](#contributing) \r\n```', 'commenter': 'carp84'}]"
131,README.zh.md,"@@ -0,0 +1,228 @@
+<img alt=""有状态函数"" src=""docs/fig/stateful_functions_logo.png"" width=350px/>
+
+有状态函数是一个[Apache Flink](https://flink.apache.org/)库， __可简化构建分布式有状态应用程序的过程__ 。它基于有着可持久化状态的函数，这些函数可以在强大的一致性保证下进行动态交互。 
+
+有状态函数使强大的状态管理和组合，与AWS Lambda之类的FaaS实现和Kubernetes之类的现代资源编排框架的弹性，快速缩放/零缩放和滚动升级功能相结合成为可能。通过这些特性，它解决了当今许多FaaS设置中[最常被引用的两个缺点](https://www2.eecs.berkeley.edu/Pubs/TechRpts/2019/EECS-2019-3.pdf) ：状态一致和函数之间的高效消息传递。 
+
+本自述文件旨在简要介绍核心概念以及如何进行设置
+以使您开始使用有状态函数。 
+
+有关详细文档，请访问[官方文档](https://ci.apache.org/projects/flink/flink-statefun-docs-master) 。 
+
+有关代码示例，请查看[示例](statefun-examples/) 。 
+
+ [![构建状态](https://travis-ci.org/apache/flink-statefun.svg?branch=master)](https://travis-ci.org/apache/flink-statefun) 
+
+## 目录
+
+- [核心概念](#core-concepts) 
+   * [抽象化](#abstraction) 
+   * [函数模块和可扩展性](#modules) 
+   * [运行时](#runtime) 
+- [入门](#getting-started) 
+   * [运行一个完整的例子](#greeter) 
+   * [新建项目](#project-setup) 
+   * [构建项目](#build) 
+   * [在IDE Harness中运行](#ide-harness) 
+- [部署应用](#deploying) 
+   * [使用Docker映像进行部署](#docker) 
+   * [部署为Flink作业](#flink) 
+- [贡献](#contributing) 
+- [开源软件许可](#license) 
+
+## <a name=""core-concepts""></a>核心概念
+
+### <a name=""abstraction""></a>抽象化
+
+有状态函数应用程序由以下原语组成：有状态函数，入口(ingress)，
+路由器(router)和出口(egress)。 ","[{'comment': '```suggestion\r\nStateful Functions 应用程序由以下原语组成：有状态函数，入口(ingress)，路由器(router)和出口(egress)。 \r\n```', 'commenter': 'carp84'}]"
131,README.zh.md,"@@ -0,0 +1,228 @@
+<img alt=""有状态函数"" src=""docs/fig/stateful_functions_logo.png"" width=350px/>
+
+有状态函数是一个[Apache Flink](https://flink.apache.org/)库， __可简化构建分布式有状态应用程序的过程__ 。它基于有着可持久化状态的函数，这些函数可以在强大的一致性保证下进行动态交互。 
+
+有状态函数使强大的状态管理和组合，与AWS Lambda之类的FaaS实现和Kubernetes之类的现代资源编排框架的弹性，快速缩放/零缩放和滚动升级功能相结合成为可能。通过这些特性，它解决了当今许多FaaS设置中[最常被引用的两个缺点](https://www2.eecs.berkeley.edu/Pubs/TechRpts/2019/EECS-2019-3.pdf) ：状态一致和函数之间的高效消息传递。 
+
+本自述文件旨在简要介绍核心概念以及如何进行设置
+以使您开始使用有状态函数。 
+
+有关详细文档，请访问[官方文档](https://ci.apache.org/projects/flink/flink-statefun-docs-master) 。 
+
+有关代码示例，请查看[示例](statefun-examples/) 。 
+
+ [![构建状态](https://travis-ci.org/apache/flink-statefun.svg?branch=master)](https://travis-ci.org/apache/flink-statefun) 
+
+## 目录
+
+- [核心概念](#core-concepts) 
+   * [抽象化](#abstraction) 
+   * [函数模块和可扩展性](#modules) 
+   * [运行时](#runtime) 
+- [入门](#getting-started) 
+   * [运行一个完整的例子](#greeter) 
+   * [新建项目](#project-setup) 
+   * [构建项目](#build) 
+   * [在IDE Harness中运行](#ide-harness) 
+- [部署应用](#deploying) 
+   * [使用Docker映像进行部署](#docker) 
+   * [部署为Flink作业](#flink) 
+- [贡献](#contributing) 
+- [开源软件许可](#license) 
+
+## <a name=""core-concepts""></a>核心概念
+
+### <a name=""abstraction""></a>抽象化
+
+有状态函数应用程序由以下原语组成：有状态函数，入口(ingress)，
+路由器(router)和出口(egress)。 
+
+<p align=""center"">
+  <img src=""docs/fig/stateful_functions_overview.png"" width=""650px""/>
+</p>
+
+#### 有状态函数
+
+* _有状态函数_是通过消息调用的一小段逻辑/代码。每个有状态函数
+都作为_函数类型_的唯一可调用_虚拟实例_存在。每个实例都通过其``type``以及type中的唯一``ID`` （字符串）来寻址。 
+
+* 有状态函数可以从ingress或任何其他有状态函数（包括其自身）中调用。
+调用者只需要知道目标函数的地址即可。 
+
+* 函数实例是_虚拟的_ ，因为它们不总是同时在内存中活跃。
+在任何时间点，只有一小部分函数及其状态作为实际对象存在。当
+虚拟实例接收到消息时，将配置一个对象并带着该虚拟实例的状态
+加载，然后处理该消息。与虚拟内存类似，许多函数的状态可能
+在任何时间点都被“交换出去”(swap out)。 
+
+* 函数的每个虚拟实例都有其自己的状态，可以通过局部变量访问。
+该状态是私有的，对于该实例是本地的(local)。
+
+如果您知道Apache Flink的DataStream API，则可以将有状态函数考虑为轻量级的
+`KeyedProcessFunction` 。函数``type``等同于处理函数转换(process function transformation)，而`` ID ``是键(key)。不同之处
+在于，函数不是在定义数据流的有向非循环图（DAG）中组装（流拓扑），","[{'comment': '```suggestion\r\n在于，函数不是在定义数据流（拓扑）的有向无环图（DAG）中组装，\r\n```', 'commenter': 'carp84'}]"
131,README.zh.md,"@@ -0,0 +1,228 @@
+<img alt=""有状态函数"" src=""docs/fig/stateful_functions_logo.png"" width=350px/>
+
+有状态函数是一个[Apache Flink](https://flink.apache.org/)库， __可简化构建分布式有状态应用程序的过程__ 。它基于有着可持久化状态的函数，这些函数可以在强大的一致性保证下进行动态交互。 
+
+有状态函数使强大的状态管理和组合，与AWS Lambda之类的FaaS实现和Kubernetes之类的现代资源编排框架的弹性，快速缩放/零缩放和滚动升级功能相结合成为可能。通过这些特性，它解决了当今许多FaaS设置中[最常被引用的两个缺点](https://www2.eecs.berkeley.edu/Pubs/TechRpts/2019/EECS-2019-3.pdf) ：状态一致和函数之间的高效消息传递。 
+
+本自述文件旨在简要介绍核心概念以及如何进行设置
+以使您开始使用有状态函数。 
+
+有关详细文档，请访问[官方文档](https://ci.apache.org/projects/flink/flink-statefun-docs-master) 。 
+
+有关代码示例，请查看[示例](statefun-examples/) 。 
+
+ [![构建状态](https://travis-ci.org/apache/flink-statefun.svg?branch=master)](https://travis-ci.org/apache/flink-statefun) 
+
+## 目录
+
+- [核心概念](#core-concepts) 
+   * [抽象化](#abstraction) 
+   * [函数模块和可扩展性](#modules) 
+   * [运行时](#runtime) 
+- [入门](#getting-started) 
+   * [运行一个完整的例子](#greeter) 
+   * [新建项目](#project-setup) 
+   * [构建项目](#build) 
+   * [在IDE Harness中运行](#ide-harness) 
+- [部署应用](#deploying) 
+   * [使用Docker映像进行部署](#docker) 
+   * [部署为Flink作业](#flink) 
+- [贡献](#contributing) 
+- [开源软件许可](#license) 
+
+## <a name=""core-concepts""></a>核心概念
+
+### <a name=""abstraction""></a>抽象化
+
+有状态函数应用程序由以下原语组成：有状态函数，入口(ingress)，
+路由器(router)和出口(egress)。 
+
+<p align=""center"">
+  <img src=""docs/fig/stateful_functions_overview.png"" width=""650px""/>
+</p>
+
+#### 有状态函数
+
+* _有状态函数_是通过消息调用的一小段逻辑/代码。每个有状态函数
+都作为_函数类型_的唯一可调用_虚拟实例_存在。每个实例都通过其``type``以及type中的唯一``ID`` （字符串）来寻址。 
+
+* 有状态函数可以从ingress或任何其他有状态函数（包括其自身）中调用。
+调用者只需要知道目标函数的地址即可。 
+
+* 函数实例是_虚拟的_ ，因为它们不总是同时在内存中活跃。
+在任何时间点，只有一小部分函数及其状态作为实际对象存在。当
+虚拟实例接收到消息时，将配置一个对象并带着该虚拟实例的状态
+加载，然后处理该消息。与虚拟内存类似，许多函数的状态可能
+在任何时间点都被“交换出去”(swap out)。 
+
+* 函数的每个虚拟实例都有其自己的状态，可以通过局部变量访问。
+该状态是私有的，对于该实例是本地的(local)。
+
+如果您知道Apache Flink的DataStream API，则可以将有状态函数考虑为轻量级的
+`KeyedProcessFunction` 。函数``type``等同于处理函数转换(process function transformation)，而`` ID ``是键(key)。不同之处
+在于，函数不是在定义数据流的有向非循环图（DAG）中组装（流拓扑），
+而是使用地址将事件任意发送到所有其他函数。 
+
+#### 入口和出口
+
+* _入口_ (Ingress)是事件最初到达有状态函数应用程序的方式。
+入口可以是消息队列，日志或HTTP服务器-产生事件并由
+应用程序处理的任何物件。 ","[{'comment': '```suggestion\r\n入口可以是消息队列，日志或HTTP服务器-它们产生事件并交由应用程序处理。 \r\n```', 'commenter': 'carp84'}]"
131,README.zh.md,"@@ -0,0 +1,228 @@
+<img alt=""有状态函数"" src=""docs/fig/stateful_functions_logo.png"" width=350px/>
+
+有状态函数是一个[Apache Flink](https://flink.apache.org/)库， __可简化构建分布式有状态应用程序的过程__ 。它基于有着可持久化状态的函数，这些函数可以在强大的一致性保证下进行动态交互。 
+
+有状态函数使强大的状态管理和组合，与AWS Lambda之类的FaaS实现和Kubernetes之类的现代资源编排框架的弹性，快速缩放/零缩放和滚动升级功能相结合成为可能。通过这些特性，它解决了当今许多FaaS设置中[最常被引用的两个缺点](https://www2.eecs.berkeley.edu/Pubs/TechRpts/2019/EECS-2019-3.pdf) ：状态一致和函数之间的高效消息传递。 
+
+本自述文件旨在简要介绍核心概念以及如何进行设置
+以使您开始使用有状态函数。 
+
+有关详细文档，请访问[官方文档](https://ci.apache.org/projects/flink/flink-statefun-docs-master) 。 
+
+有关代码示例，请查看[示例](statefun-examples/) 。 
+
+ [![构建状态](https://travis-ci.org/apache/flink-statefun.svg?branch=master)](https://travis-ci.org/apache/flink-statefun) 
+
+## 目录
+
+- [核心概念](#core-concepts) 
+   * [抽象化](#abstraction) 
+   * [函数模块和可扩展性](#modules) 
+   * [运行时](#runtime) 
+- [入门](#getting-started) 
+   * [运行一个完整的例子](#greeter) 
+   * [新建项目](#project-setup) 
+   * [构建项目](#build) 
+   * [在IDE Harness中运行](#ide-harness) 
+- [部署应用](#deploying) 
+   * [使用Docker映像进行部署](#docker) 
+   * [部署为Flink作业](#flink) 
+- [贡献](#contributing) 
+- [开源软件许可](#license) 
+
+## <a name=""core-concepts""></a>核心概念
+
+### <a name=""abstraction""></a>抽象化
+
+有状态函数应用程序由以下原语组成：有状态函数，入口(ingress)，
+路由器(router)和出口(egress)。 
+
+<p align=""center"">
+  <img src=""docs/fig/stateful_functions_overview.png"" width=""650px""/>
+</p>
+
+#### 有状态函数
+
+* _有状态函数_是通过消息调用的一小段逻辑/代码。每个有状态函数
+都作为_函数类型_的唯一可调用_虚拟实例_存在。每个实例都通过其``type``以及type中的唯一``ID`` （字符串）来寻址。 
+
+* 有状态函数可以从ingress或任何其他有状态函数（包括其自身）中调用。
+调用者只需要知道目标函数的地址即可。 
+
+* 函数实例是_虚拟的_ ，因为它们不总是同时在内存中活跃。
+在任何时间点，只有一小部分函数及其状态作为实际对象存在。当
+虚拟实例接收到消息时，将配置一个对象并带着该虚拟实例的状态
+加载，然后处理该消息。与虚拟内存类似，许多函数的状态可能
+在任何时间点都被“交换出去”(swap out)。 
+
+* 函数的每个虚拟实例都有其自己的状态，可以通过局部变量访问。
+该状态是私有的，对于该实例是本地的(local)。
+
+如果您知道Apache Flink的DataStream API，则可以将有状态函数考虑为轻量级的
+`KeyedProcessFunction` 。函数``type``等同于处理函数转换(process function transformation)，而`` ID ``是键(key)。不同之处
+在于，函数不是在定义数据流的有向非循环图（DAG）中组装（流拓扑），
+而是使用地址将事件任意发送到所有其他函数。 
+
+#### 入口和出口
+
+* _入口_ (Ingress)是事件最初到达有状态函数应用程序的方式。
+入口可以是消息队列，日志或HTTP服务器-产生事件并由
+应用程序处理的任何物件。 
+
+* _路由器_(Router)连接到入口(Ingress)，以确定哪个函数实例应最初处理事件。 ","[{'comment': '```suggestion\r\n* _路由器_(Router)连接到入口(Ingress)并决定最先处理事件的函数实例。 \r\n```', 'commenter': 'carp84'}]"
131,README.zh.md,"@@ -0,0 +1,228 @@
+<img alt=""有状态函数"" src=""docs/fig/stateful_functions_logo.png"" width=350px/>
+
+有状态函数是一个[Apache Flink](https://flink.apache.org/)库， __可简化构建分布式有状态应用程序的过程__ 。它基于有着可持久化状态的函数，这些函数可以在强大的一致性保证下进行动态交互。 
+
+有状态函数使强大的状态管理和组合，与AWS Lambda之类的FaaS实现和Kubernetes之类的现代资源编排框架的弹性，快速缩放/零缩放和滚动升级功能相结合成为可能。通过这些特性，它解决了当今许多FaaS设置中[最常被引用的两个缺点](https://www2.eecs.berkeley.edu/Pubs/TechRpts/2019/EECS-2019-3.pdf) ：状态一致和函数之间的高效消息传递。 
+
+本自述文件旨在简要介绍核心概念以及如何进行设置
+以使您开始使用有状态函数。 
+
+有关详细文档，请访问[官方文档](https://ci.apache.org/projects/flink/flink-statefun-docs-master) 。 
+
+有关代码示例，请查看[示例](statefun-examples/) 。 
+
+ [![构建状态](https://travis-ci.org/apache/flink-statefun.svg?branch=master)](https://travis-ci.org/apache/flink-statefun) 
+
+## 目录
+
+- [核心概念](#core-concepts) 
+   * [抽象化](#abstraction) 
+   * [函数模块和可扩展性](#modules) 
+   * [运行时](#runtime) 
+- [入门](#getting-started) 
+   * [运行一个完整的例子](#greeter) 
+   * [新建项目](#project-setup) 
+   * [构建项目](#build) 
+   * [在IDE Harness中运行](#ide-harness) 
+- [部署应用](#deploying) 
+   * [使用Docker映像进行部署](#docker) 
+   * [部署为Flink作业](#flink) 
+- [贡献](#contributing) 
+- [开源软件许可](#license) 
+
+## <a name=""core-concepts""></a>核心概念
+
+### <a name=""abstraction""></a>抽象化
+
+有状态函数应用程序由以下原语组成：有状态函数，入口(ingress)，
+路由器(router)和出口(egress)。 
+
+<p align=""center"">
+  <img src=""docs/fig/stateful_functions_overview.png"" width=""650px""/>
+</p>
+
+#### 有状态函数
+
+* _有状态函数_是通过消息调用的一小段逻辑/代码。每个有状态函数
+都作为_函数类型_的唯一可调用_虚拟实例_存在。每个实例都通过其``type``以及type中的唯一``ID`` （字符串）来寻址。 
+
+* 有状态函数可以从ingress或任何其他有状态函数（包括其自身）中调用。
+调用者只需要知道目标函数的地址即可。 
+
+* 函数实例是_虚拟的_ ，因为它们不总是同时在内存中活跃。
+在任何时间点，只有一小部分函数及其状态作为实际对象存在。当
+虚拟实例接收到消息时，将配置一个对象并带着该虚拟实例的状态
+加载，然后处理该消息。与虚拟内存类似，许多函数的状态可能
+在任何时间点都被“交换出去”(swap out)。 
+
+* 函数的每个虚拟实例都有其自己的状态，可以通过局部变量访问。
+该状态是私有的，对于该实例是本地的(local)。
+
+如果您知道Apache Flink的DataStream API，则可以将有状态函数考虑为轻量级的
+`KeyedProcessFunction` 。函数``type``等同于处理函数转换(process function transformation)，而`` ID ``是键(key)。不同之处
+在于，函数不是在定义数据流的有向非循环图（DAG）中组装（流拓扑），
+而是使用地址将事件任意发送到所有其他函数。 
+
+#### 入口和出口
+
+* _入口_ (Ingress)是事件最初到达有状态函数应用程序的方式。
+入口可以是消息队列，日志或HTTP服务器-产生事件并由
+应用程序处理的任何物件。 
+
+* _路由器_(Router)连接到入口(Ingress)，以确定哪个函数实例应最初处理事件。 
+
+* _出口_(Egress)是一种以标准化方式从应用程序发送事件的方法。
+出口是可选的；也有可能没有事件离开应用程序和函数接收器(functions sink)事件，或
+直接调用其他应用程序。 ","[{'comment': '```suggestion\r\n出口是可选的；也有可能没有事件离开应用程序，函数会完成事件的处理或直接调用其他应用程序。 \r\n```', 'commenter': 'carp84'}]"
131,README.zh.md,"@@ -0,0 +1,228 @@
+<img alt=""有状态函数"" src=""docs/fig/stateful_functions_logo.png"" width=350px/>
+
+有状态函数是一个[Apache Flink](https://flink.apache.org/)库， __可简化构建分布式有状态应用程序的过程__ 。它基于有着可持久化状态的函数，这些函数可以在强大的一致性保证下进行动态交互。 
+
+有状态函数使强大的状态管理和组合，与AWS Lambda之类的FaaS实现和Kubernetes之类的现代资源编排框架的弹性，快速缩放/零缩放和滚动升级功能相结合成为可能。通过这些特性，它解决了当今许多FaaS设置中[最常被引用的两个缺点](https://www2.eecs.berkeley.edu/Pubs/TechRpts/2019/EECS-2019-3.pdf) ：状态一致和函数之间的高效消息传递。 
+
+本自述文件旨在简要介绍核心概念以及如何进行设置
+以使您开始使用有状态函数。 
+
+有关详细文档，请访问[官方文档](https://ci.apache.org/projects/flink/flink-statefun-docs-master) 。 
+
+有关代码示例，请查看[示例](statefun-examples/) 。 
+
+ [![构建状态](https://travis-ci.org/apache/flink-statefun.svg?branch=master)](https://travis-ci.org/apache/flink-statefun) 
+
+## 目录
+
+- [核心概念](#core-concepts) 
+   * [抽象化](#abstraction) 
+   * [函数模块和可扩展性](#modules) 
+   * [运行时](#runtime) 
+- [入门](#getting-started) 
+   * [运行一个完整的例子](#greeter) 
+   * [新建项目](#project-setup) 
+   * [构建项目](#build) 
+   * [在IDE Harness中运行](#ide-harness) 
+- [部署应用](#deploying) 
+   * [使用Docker映像进行部署](#docker) 
+   * [部署为Flink作业](#flink) 
+- [贡献](#contributing) 
+- [开源软件许可](#license) 
+
+## <a name=""core-concepts""></a>核心概念
+
+### <a name=""abstraction""></a>抽象化
+
+有状态函数应用程序由以下原语组成：有状态函数，入口(ingress)，
+路由器(router)和出口(egress)。 
+
+<p align=""center"">
+  <img src=""docs/fig/stateful_functions_overview.png"" width=""650px""/>
+</p>
+
+#### 有状态函数
+
+* _有状态函数_是通过消息调用的一小段逻辑/代码。每个有状态函数
+都作为_函数类型_的唯一可调用_虚拟实例_存在。每个实例都通过其``type``以及type中的唯一``ID`` （字符串）来寻址。 
+
+* 有状态函数可以从ingress或任何其他有状态函数（包括其自身）中调用。
+调用者只需要知道目标函数的地址即可。 
+
+* 函数实例是_虚拟的_ ，因为它们不总是同时在内存中活跃。
+在任何时间点，只有一小部分函数及其状态作为实际对象存在。当
+虚拟实例接收到消息时，将配置一个对象并带着该虚拟实例的状态
+加载，然后处理该消息。与虚拟内存类似，许多函数的状态可能
+在任何时间点都被“交换出去”(swap out)。 
+
+* 函数的每个虚拟实例都有其自己的状态，可以通过局部变量访问。
+该状态是私有的，对于该实例是本地的(local)。
+
+如果您知道Apache Flink的DataStream API，则可以将有状态函数考虑为轻量级的
+`KeyedProcessFunction` 。函数``type``等同于处理函数转换(process function transformation)，而`` ID ``是键(key)。不同之处
+在于，函数不是在定义数据流的有向非循环图（DAG）中组装（流拓扑），
+而是使用地址将事件任意发送到所有其他函数。 
+
+#### 入口和出口
+
+* _入口_ (Ingress)是事件最初到达有状态函数应用程序的方式。
+入口可以是消息队列，日志或HTTP服务器-产生事件并由
+应用程序处理的任何物件。 
+
+* _路由器_(Router)连接到入口(Ingress)，以确定哪个函数实例应最初处理事件。 
+
+* _出口_(Egress)是一种以标准化方式从应用程序发送事件的方法。
+出口是可选的；也有可能没有事件离开应用程序和函数接收器(functions sink)事件，或
+直接调用其他应用程序。 
+
+### <a name=""modules""></a>模块(Module)
+
+ _模块_(Module)将核心构建基元添加到有状态函数
+ 应用程序的入口点，即入口，出口，路由器和有状态函数。 ","[{'comment': '```suggestion\r\n _模块_(Module)是将核心构建单元添加到 Stateful Functions 应用程序，即入口、出口、路由器和有状态函数，的入口。 \r\n```', 'commenter': 'carp84'}]"
131,README.zh.md,"@@ -0,0 +1,228 @@
+<img alt=""有状态函数"" src=""docs/fig/stateful_functions_logo.png"" width=350px/>
+
+有状态函数是一个[Apache Flink](https://flink.apache.org/)库， __可简化构建分布式有状态应用程序的过程__ 。它基于有着可持久化状态的函数，这些函数可以在强大的一致性保证下进行动态交互。 
+
+有状态函数使强大的状态管理和组合，与AWS Lambda之类的FaaS实现和Kubernetes之类的现代资源编排框架的弹性，快速缩放/零缩放和滚动升级功能相结合成为可能。通过这些特性，它解决了当今许多FaaS设置中[最常被引用的两个缺点](https://www2.eecs.berkeley.edu/Pubs/TechRpts/2019/EECS-2019-3.pdf) ：状态一致和函数之间的高效消息传递。 
+
+本自述文件旨在简要介绍核心概念以及如何进行设置
+以使您开始使用有状态函数。 
+
+有关详细文档，请访问[官方文档](https://ci.apache.org/projects/flink/flink-statefun-docs-master) 。 
+
+有关代码示例，请查看[示例](statefun-examples/) 。 
+
+ [![构建状态](https://travis-ci.org/apache/flink-statefun.svg?branch=master)](https://travis-ci.org/apache/flink-statefun) 
+
+## 目录
+
+- [核心概念](#core-concepts) 
+   * [抽象化](#abstraction) 
+   * [函数模块和可扩展性](#modules) 
+   * [运行时](#runtime) 
+- [入门](#getting-started) 
+   * [运行一个完整的例子](#greeter) 
+   * [新建项目](#project-setup) 
+   * [构建项目](#build) 
+   * [在IDE Harness中运行](#ide-harness) 
+- [部署应用](#deploying) 
+   * [使用Docker映像进行部署](#docker) 
+   * [部署为Flink作业](#flink) 
+- [贡献](#contributing) 
+- [开源软件许可](#license) 
+
+## <a name=""core-concepts""></a>核心概念
+
+### <a name=""abstraction""></a>抽象化
+
+有状态函数应用程序由以下原语组成：有状态函数，入口(ingress)，
+路由器(router)和出口(egress)。 
+
+<p align=""center"">
+  <img src=""docs/fig/stateful_functions_overview.png"" width=""650px""/>
+</p>
+
+#### 有状态函数
+
+* _有状态函数_是通过消息调用的一小段逻辑/代码。每个有状态函数
+都作为_函数类型_的唯一可调用_虚拟实例_存在。每个实例都通过其``type``以及type中的唯一``ID`` （字符串）来寻址。 
+
+* 有状态函数可以从ingress或任何其他有状态函数（包括其自身）中调用。
+调用者只需要知道目标函数的地址即可。 
+
+* 函数实例是_虚拟的_ ，因为它们不总是同时在内存中活跃。
+在任何时间点，只有一小部分函数及其状态作为实际对象存在。当
+虚拟实例接收到消息时，将配置一个对象并带着该虚拟实例的状态
+加载，然后处理该消息。与虚拟内存类似，许多函数的状态可能
+在任何时间点都被“交换出去”(swap out)。 
+
+* 函数的每个虚拟实例都有其自己的状态，可以通过局部变量访问。
+该状态是私有的，对于该实例是本地的(local)。
+
+如果您知道Apache Flink的DataStream API，则可以将有状态函数考虑为轻量级的
+`KeyedProcessFunction` 。函数``type``等同于处理函数转换(process function transformation)，而`` ID ``是键(key)。不同之处
+在于，函数不是在定义数据流的有向非循环图（DAG）中组装（流拓扑），
+而是使用地址将事件任意发送到所有其他函数。 
+
+#### 入口和出口
+
+* _入口_ (Ingress)是事件最初到达有状态函数应用程序的方式。
+入口可以是消息队列，日志或HTTP服务器-产生事件并由
+应用程序处理的任何物件。 
+
+* _路由器_(Router)连接到入口(Ingress)，以确定哪个函数实例应最初处理事件。 
+
+* _出口_(Egress)是一种以标准化方式从应用程序发送事件的方法。
+出口是可选的；也有可能没有事件离开应用程序和函数接收器(functions sink)事件，或
+直接调用其他应用程序。 
+
+### <a name=""modules""></a>模块(Module)
+
+ _模块_(Module)将核心构建基元添加到有状态函数
+ 应用程序的入口点，即入口，出口，路由器和有状态函数。 
+
+单个应用程序可以是多个模块的组合，每个模块都构成整个应用程序的一部分。
+这允许应用程序的不同部分由不同的模块来组成。例如，
+一个模块可以提供入口和出口，而其他模块可以分别作为状态函数来
+贡献业务逻辑的特定部分。这有助于在独立团队中工作，但仍可以部署到
+相同的更大应用程序中。 ","[{'comment': '```suggestion\r\n一个模块可以提供入口和出口，而其他模块可以通过状态函数来\r\n独立提供业务逻辑的不同部分。这有助于多个独立团队共同完成较大（复杂）的应用程序。\r\n```', 'commenter': 'carp84'}]"
131,README.zh.md,"@@ -0,0 +1,228 @@
+<img alt=""有状态函数"" src=""docs/fig/stateful_functions_logo.png"" width=350px/>
+
+有状态函数是一个[Apache Flink](https://flink.apache.org/)库， __可简化构建分布式有状态应用程序的过程__ 。它基于有着可持久化状态的函数，这些函数可以在强大的一致性保证下进行动态交互。 
+
+有状态函数使强大的状态管理和组合，与AWS Lambda之类的FaaS实现和Kubernetes之类的现代资源编排框架的弹性，快速缩放/零缩放和滚动升级功能相结合成为可能。通过这些特性，它解决了当今许多FaaS设置中[最常被引用的两个缺点](https://www2.eecs.berkeley.edu/Pubs/TechRpts/2019/EECS-2019-3.pdf) ：状态一致和函数之间的高效消息传递。 
+
+本自述文件旨在简要介绍核心概念以及如何进行设置
+以使您开始使用有状态函数。 
+
+有关详细文档，请访问[官方文档](https://ci.apache.org/projects/flink/flink-statefun-docs-master) 。 
+
+有关代码示例，请查看[示例](statefun-examples/) 。 
+
+ [![构建状态](https://travis-ci.org/apache/flink-statefun.svg?branch=master)](https://travis-ci.org/apache/flink-statefun) 
+
+## 目录
+
+- [核心概念](#core-concepts) 
+   * [抽象化](#abstraction) 
+   * [函数模块和可扩展性](#modules) 
+   * [运行时](#runtime) 
+- [入门](#getting-started) 
+   * [运行一个完整的例子](#greeter) 
+   * [新建项目](#project-setup) 
+   * [构建项目](#build) 
+   * [在IDE Harness中运行](#ide-harness) 
+- [部署应用](#deploying) 
+   * [使用Docker映像进行部署](#docker) 
+   * [部署为Flink作业](#flink) 
+- [贡献](#contributing) 
+- [开源软件许可](#license) 
+
+## <a name=""core-concepts""></a>核心概念
+
+### <a name=""abstraction""></a>抽象化
+
+有状态函数应用程序由以下原语组成：有状态函数，入口(ingress)，
+路由器(router)和出口(egress)。 
+
+<p align=""center"">
+  <img src=""docs/fig/stateful_functions_overview.png"" width=""650px""/>
+</p>
+
+#### 有状态函数
+
+* _有状态函数_是通过消息调用的一小段逻辑/代码。每个有状态函数
+都作为_函数类型_的唯一可调用_虚拟实例_存在。每个实例都通过其``type``以及type中的唯一``ID`` （字符串）来寻址。 
+
+* 有状态函数可以从ingress或任何其他有状态函数（包括其自身）中调用。
+调用者只需要知道目标函数的地址即可。 
+
+* 函数实例是_虚拟的_ ，因为它们不总是同时在内存中活跃。
+在任何时间点，只有一小部分函数及其状态作为实际对象存在。当
+虚拟实例接收到消息时，将配置一个对象并带着该虚拟实例的状态
+加载，然后处理该消息。与虚拟内存类似，许多函数的状态可能
+在任何时间点都被“交换出去”(swap out)。 
+
+* 函数的每个虚拟实例都有其自己的状态，可以通过局部变量访问。
+该状态是私有的，对于该实例是本地的(local)。
+
+如果您知道Apache Flink的DataStream API，则可以将有状态函数考虑为轻量级的
+`KeyedProcessFunction` 。函数``type``等同于处理函数转换(process function transformation)，而`` ID ``是键(key)。不同之处
+在于，函数不是在定义数据流的有向非循环图（DAG）中组装（流拓扑），
+而是使用地址将事件任意发送到所有其他函数。 
+
+#### 入口和出口
+
+* _入口_ (Ingress)是事件最初到达有状态函数应用程序的方式。
+入口可以是消息队列，日志或HTTP服务器-产生事件并由
+应用程序处理的任何物件。 
+
+* _路由器_(Router)连接到入口(Ingress)，以确定哪个函数实例应最初处理事件。 
+
+* _出口_(Egress)是一种以标准化方式从应用程序发送事件的方法。
+出口是可选的；也有可能没有事件离开应用程序和函数接收器(functions sink)事件，或
+直接调用其他应用程序。 
+
+### <a name=""modules""></a>模块(Module)
+
+ _模块_(Module)将核心构建基元添加到有状态函数
+ 应用程序的入口点，即入口，出口，路由器和有状态函数。 
+
+单个应用程序可以是多个模块的组合，每个模块都构成整个应用程序的一部分。
+这允许应用程序的不同部分由不同的模块来组成。例如，
+一个模块可以提供入口和出口，而其他模块可以分别作为状态函数来
+贡献业务逻辑的特定部分。这有助于在独立团队中工作，但仍可以部署到
+相同的更大应用程序中。 
+
+## <a name=""runtime"">运行时 
+
+有状态函数运行时旨在提供一组类似于[无服务器函数](https://martinfowler.com/articles/serverless.html)属性的属性，但适用于有状态问题。 ","[{'comment': '```suggestion\r\nStateful Functions 运行时旨在提供一组类似于[无服务器函数](https://martinfowler.com/articles/serverless.html)的属性，但适用于有状态的场景。 \r\n```', 'commenter': 'carp84'}]"
131,README.zh.md,"@@ -0,0 +1,228 @@
+<img alt=""有状态函数"" src=""docs/fig/stateful_functions_logo.png"" width=350px/>
+
+有状态函数是一个[Apache Flink](https://flink.apache.org/)库， __可简化构建分布式有状态应用程序的过程__ 。它基于有着可持久化状态的函数，这些函数可以在强大的一致性保证下进行动态交互。 
+
+有状态函数使强大的状态管理和组合，与AWS Lambda之类的FaaS实现和Kubernetes之类的现代资源编排框架的弹性，快速缩放/零缩放和滚动升级功能相结合成为可能。通过这些特性，它解决了当今许多FaaS设置中[最常被引用的两个缺点](https://www2.eecs.berkeley.edu/Pubs/TechRpts/2019/EECS-2019-3.pdf) ：状态一致和函数之间的高效消息传递。 
+
+本自述文件旨在简要介绍核心概念以及如何进行设置
+以使您开始使用有状态函数。 
+
+有关详细文档，请访问[官方文档](https://ci.apache.org/projects/flink/flink-statefun-docs-master) 。 
+
+有关代码示例，请查看[示例](statefun-examples/) 。 
+
+ [![构建状态](https://travis-ci.org/apache/flink-statefun.svg?branch=master)](https://travis-ci.org/apache/flink-statefun) 
+
+## 目录
+
+- [核心概念](#core-concepts) 
+   * [抽象化](#abstraction) 
+   * [函数模块和可扩展性](#modules) 
+   * [运行时](#runtime) 
+- [入门](#getting-started) 
+   * [运行一个完整的例子](#greeter) 
+   * [新建项目](#project-setup) 
+   * [构建项目](#build) 
+   * [在IDE Harness中运行](#ide-harness) 
+- [部署应用](#deploying) 
+   * [使用Docker映像进行部署](#docker) 
+   * [部署为Flink作业](#flink) 
+- [贡献](#contributing) 
+- [开源软件许可](#license) 
+
+## <a name=""core-concepts""></a>核心概念
+
+### <a name=""abstraction""></a>抽象化
+
+有状态函数应用程序由以下原语组成：有状态函数，入口(ingress)，
+路由器(router)和出口(egress)。 
+
+<p align=""center"">
+  <img src=""docs/fig/stateful_functions_overview.png"" width=""650px""/>
+</p>
+
+#### 有状态函数
+
+* _有状态函数_是通过消息调用的一小段逻辑/代码。每个有状态函数
+都作为_函数类型_的唯一可调用_虚拟实例_存在。每个实例都通过其``type``以及type中的唯一``ID`` （字符串）来寻址。 
+
+* 有状态函数可以从ingress或任何其他有状态函数（包括其自身）中调用。
+调用者只需要知道目标函数的地址即可。 
+
+* 函数实例是_虚拟的_ ，因为它们不总是同时在内存中活跃。
+在任何时间点，只有一小部分函数及其状态作为实际对象存在。当
+虚拟实例接收到消息时，将配置一个对象并带着该虚拟实例的状态
+加载，然后处理该消息。与虚拟内存类似，许多函数的状态可能
+在任何时间点都被“交换出去”(swap out)。 
+
+* 函数的每个虚拟实例都有其自己的状态，可以通过局部变量访问。
+该状态是私有的，对于该实例是本地的(local)。
+
+如果您知道Apache Flink的DataStream API，则可以将有状态函数考虑为轻量级的
+`KeyedProcessFunction` 。函数``type``等同于处理函数转换(process function transformation)，而`` ID ``是键(key)。不同之处
+在于，函数不是在定义数据流的有向非循环图（DAG）中组装（流拓扑），
+而是使用地址将事件任意发送到所有其他函数。 
+
+#### 入口和出口
+
+* _入口_ (Ingress)是事件最初到达有状态函数应用程序的方式。
+入口可以是消息队列，日志或HTTP服务器-产生事件并由
+应用程序处理的任何物件。 
+
+* _路由器_(Router)连接到入口(Ingress)，以确定哪个函数实例应最初处理事件。 
+
+* _出口_(Egress)是一种以标准化方式从应用程序发送事件的方法。
+出口是可选的；也有可能没有事件离开应用程序和函数接收器(functions sink)事件，或
+直接调用其他应用程序。 
+
+### <a name=""modules""></a>模块(Module)
+
+ _模块_(Module)将核心构建基元添加到有状态函数
+ 应用程序的入口点，即入口，出口，路由器和有状态函数。 
+
+单个应用程序可以是多个模块的组合，每个模块都构成整个应用程序的一部分。
+这允许应用程序的不同部分由不同的模块来组成。例如，
+一个模块可以提供入口和出口，而其他模块可以分别作为状态函数来
+贡献业务逻辑的特定部分。这有助于在独立团队中工作，但仍可以部署到
+相同的更大应用程序中。 
+
+## <a name=""runtime"">运行时 
+
+有状态函数运行时旨在提供一组类似于[无服务器函数](https://martinfowler.com/articles/serverless.html)属性的属性，但适用于有状态问题。 
+
+<p align=""center"">
+  <img src=""docs/fig/stateful_functions_overview-ops.png"" width=""600px""/>
+</p>
+
+运行时建立在Apache Flink<sup>®</sup>，并具有以下设计原则：","[{'comment': '```suggestion\r\n运行时基于Apache Flink<sup>®</sup>构建，并具有以下设计原则：\r\n```', 'commenter': 'carp84'}]"
131,README.zh.md,"@@ -0,0 +1,228 @@
+<img alt=""有状态函数"" src=""docs/fig/stateful_functions_logo.png"" width=350px/>
+
+有状态函数是一个[Apache Flink](https://flink.apache.org/)库， __可简化构建分布式有状态应用程序的过程__ 。它基于有着可持久化状态的函数，这些函数可以在强大的一致性保证下进行动态交互。 
+
+有状态函数使强大的状态管理和组合，与AWS Lambda之类的FaaS实现和Kubernetes之类的现代资源编排框架的弹性，快速缩放/零缩放和滚动升级功能相结合成为可能。通过这些特性，它解决了当今许多FaaS设置中[最常被引用的两个缺点](https://www2.eecs.berkeley.edu/Pubs/TechRpts/2019/EECS-2019-3.pdf) ：状态一致和函数之间的高效消息传递。 
+
+本自述文件旨在简要介绍核心概念以及如何进行设置
+以使您开始使用有状态函数。 
+
+有关详细文档，请访问[官方文档](https://ci.apache.org/projects/flink/flink-statefun-docs-master) 。 
+
+有关代码示例，请查看[示例](statefun-examples/) 。 
+
+ [![构建状态](https://travis-ci.org/apache/flink-statefun.svg?branch=master)](https://travis-ci.org/apache/flink-statefun) 
+
+## 目录
+
+- [核心概念](#core-concepts) 
+   * [抽象化](#abstraction) 
+   * [函数模块和可扩展性](#modules) 
+   * [运行时](#runtime) 
+- [入门](#getting-started) 
+   * [运行一个完整的例子](#greeter) 
+   * [新建项目](#project-setup) 
+   * [构建项目](#build) 
+   * [在IDE Harness中运行](#ide-harness) 
+- [部署应用](#deploying) 
+   * [使用Docker映像进行部署](#docker) 
+   * [部署为Flink作业](#flink) 
+- [贡献](#contributing) 
+- [开源软件许可](#license) 
+
+## <a name=""core-concepts""></a>核心概念
+
+### <a name=""abstraction""></a>抽象化
+
+有状态函数应用程序由以下原语组成：有状态函数，入口(ingress)，
+路由器(router)和出口(egress)。 
+
+<p align=""center"">
+  <img src=""docs/fig/stateful_functions_overview.png"" width=""650px""/>
+</p>
+
+#### 有状态函数
+
+* _有状态函数_是通过消息调用的一小段逻辑/代码。每个有状态函数
+都作为_函数类型_的唯一可调用_虚拟实例_存在。每个实例都通过其``type``以及type中的唯一``ID`` （字符串）来寻址。 
+
+* 有状态函数可以从ingress或任何其他有状态函数（包括其自身）中调用。
+调用者只需要知道目标函数的地址即可。 
+
+* 函数实例是_虚拟的_ ，因为它们不总是同时在内存中活跃。
+在任何时间点，只有一小部分函数及其状态作为实际对象存在。当
+虚拟实例接收到消息时，将配置一个对象并带着该虚拟实例的状态
+加载，然后处理该消息。与虚拟内存类似，许多函数的状态可能
+在任何时间点都被“交换出去”(swap out)。 
+
+* 函数的每个虚拟实例都有其自己的状态，可以通过局部变量访问。
+该状态是私有的，对于该实例是本地的(local)。
+
+如果您知道Apache Flink的DataStream API，则可以将有状态函数考虑为轻量级的
+`KeyedProcessFunction` 。函数``type``等同于处理函数转换(process function transformation)，而`` ID ``是键(key)。不同之处
+在于，函数不是在定义数据流的有向非循环图（DAG）中组装（流拓扑），
+而是使用地址将事件任意发送到所有其他函数。 
+
+#### 入口和出口
+
+* _入口_ (Ingress)是事件最初到达有状态函数应用程序的方式。
+入口可以是消息队列，日志或HTTP服务器-产生事件并由
+应用程序处理的任何物件。 
+
+* _路由器_(Router)连接到入口(Ingress)，以确定哪个函数实例应最初处理事件。 
+
+* _出口_(Egress)是一种以标准化方式从应用程序发送事件的方法。
+出口是可选的；也有可能没有事件离开应用程序和函数接收器(functions sink)事件，或
+直接调用其他应用程序。 
+
+### <a name=""modules""></a>模块(Module)
+
+ _模块_(Module)将核心构建基元添加到有状态函数
+ 应用程序的入口点，即入口，出口，路由器和有状态函数。 
+
+单个应用程序可以是多个模块的组合，每个模块都构成整个应用程序的一部分。
+这允许应用程序的不同部分由不同的模块来组成。例如，
+一个模块可以提供入口和出口，而其他模块可以分别作为状态函数来
+贡献业务逻辑的特定部分。这有助于在独立团队中工作，但仍可以部署到
+相同的更大应用程序中。 
+
+## <a name=""runtime"">运行时 
+
+有状态函数运行时旨在提供一组类似于[无服务器函数](https://martinfowler.com/articles/serverless.html)属性的属性，但适用于有状态问题。 
+
+<p align=""center"">
+  <img src=""docs/fig/stateful_functions_overview-ops.png"" width=""600px""/>
+</p>
+
+运行时建立在Apache Flink<sup>®</sup>，并具有以下设计原则：
+
+*  __逻辑计算/状态共置：__消息传递，状态访问/更新和函数调用在一起紧密管理。这确保了开箱即用地在高层次支持一致性。 <!--TODO: disambiguate high-level 更抽象的(eg. high-level API) vs. 更高度的(eg. a high level of activity) -->","[{'comment': '```suggestion\r\n*  __逻辑上计算/状态共置：__消息传递，状态访问/更新和函数调用在一起紧密管理。这在抽象层面天然地保证了一致性。 <!--TODO: disambiguate high-level 更抽象的(eg. high-level API) vs. 更高度的(eg. a high level of activity) -->\r\n```', 'commenter': 'carp84'}]"
131,README.zh.md,"@@ -0,0 +1,228 @@
+<img alt=""有状态函数"" src=""docs/fig/stateful_functions_logo.png"" width=350px/>
+
+有状态函数是一个[Apache Flink](https://flink.apache.org/)库， __可简化构建分布式有状态应用程序的过程__ 。它基于有着可持久化状态的函数，这些函数可以在强大的一致性保证下进行动态交互。 
+
+有状态函数使强大的状态管理和组合，与AWS Lambda之类的FaaS实现和Kubernetes之类的现代资源编排框架的弹性，快速缩放/零缩放和滚动升级功能相结合成为可能。通过这些特性，它解决了当今许多FaaS设置中[最常被引用的两个缺点](https://www2.eecs.berkeley.edu/Pubs/TechRpts/2019/EECS-2019-3.pdf) ：状态一致和函数之间的高效消息传递。 
+
+本自述文件旨在简要介绍核心概念以及如何进行设置
+以使您开始使用有状态函数。 
+
+有关详细文档，请访问[官方文档](https://ci.apache.org/projects/flink/flink-statefun-docs-master) 。 
+
+有关代码示例，请查看[示例](statefun-examples/) 。 
+
+ [![构建状态](https://travis-ci.org/apache/flink-statefun.svg?branch=master)](https://travis-ci.org/apache/flink-statefun) 
+
+## 目录
+
+- [核心概念](#core-concepts) 
+   * [抽象化](#abstraction) 
+   * [函数模块和可扩展性](#modules) 
+   * [运行时](#runtime) 
+- [入门](#getting-started) 
+   * [运行一个完整的例子](#greeter) 
+   * [新建项目](#project-setup) 
+   * [构建项目](#build) 
+   * [在IDE Harness中运行](#ide-harness) 
+- [部署应用](#deploying) 
+   * [使用Docker映像进行部署](#docker) 
+   * [部署为Flink作业](#flink) 
+- [贡献](#contributing) 
+- [开源软件许可](#license) 
+
+## <a name=""core-concepts""></a>核心概念
+
+### <a name=""abstraction""></a>抽象化
+
+有状态函数应用程序由以下原语组成：有状态函数，入口(ingress)，
+路由器(router)和出口(egress)。 
+
+<p align=""center"">
+  <img src=""docs/fig/stateful_functions_overview.png"" width=""650px""/>
+</p>
+
+#### 有状态函数
+
+* _有状态函数_是通过消息调用的一小段逻辑/代码。每个有状态函数
+都作为_函数类型_的唯一可调用_虚拟实例_存在。每个实例都通过其``type``以及type中的唯一``ID`` （字符串）来寻址。 
+
+* 有状态函数可以从ingress或任何其他有状态函数（包括其自身）中调用。
+调用者只需要知道目标函数的地址即可。 
+
+* 函数实例是_虚拟的_ ，因为它们不总是同时在内存中活跃。
+在任何时间点，只有一小部分函数及其状态作为实际对象存在。当
+虚拟实例接收到消息时，将配置一个对象并带着该虚拟实例的状态
+加载，然后处理该消息。与虚拟内存类似，许多函数的状态可能
+在任何时间点都被“交换出去”(swap out)。 
+
+* 函数的每个虚拟实例都有其自己的状态，可以通过局部变量访问。
+该状态是私有的，对于该实例是本地的(local)。
+
+如果您知道Apache Flink的DataStream API，则可以将有状态函数考虑为轻量级的
+`KeyedProcessFunction` 。函数``type``等同于处理函数转换(process function transformation)，而`` ID ``是键(key)。不同之处
+在于，函数不是在定义数据流的有向非循环图（DAG）中组装（流拓扑），
+而是使用地址将事件任意发送到所有其他函数。 
+
+#### 入口和出口
+
+* _入口_ (Ingress)是事件最初到达有状态函数应用程序的方式。
+入口可以是消息队列，日志或HTTP服务器-产生事件并由
+应用程序处理的任何物件。 
+
+* _路由器_(Router)连接到入口(Ingress)，以确定哪个函数实例应最初处理事件。 
+
+* _出口_(Egress)是一种以标准化方式从应用程序发送事件的方法。
+出口是可选的；也有可能没有事件离开应用程序和函数接收器(functions sink)事件，或
+直接调用其他应用程序。 
+
+### <a name=""modules""></a>模块(Module)
+
+ _模块_(Module)将核心构建基元添加到有状态函数
+ 应用程序的入口点，即入口，出口，路由器和有状态函数。 
+
+单个应用程序可以是多个模块的组合，每个模块都构成整个应用程序的一部分。
+这允许应用程序的不同部分由不同的模块来组成。例如，
+一个模块可以提供入口和出口，而其他模块可以分别作为状态函数来
+贡献业务逻辑的特定部分。这有助于在独立团队中工作，但仍可以部署到
+相同的更大应用程序中。 
+
+## <a name=""runtime"">运行时 
+
+有状态函数运行时旨在提供一组类似于[无服务器函数](https://martinfowler.com/articles/serverless.html)属性的属性，但适用于有状态问题。 
+
+<p align=""center"">
+  <img src=""docs/fig/stateful_functions_overview-ops.png"" width=""600px""/>
+</p>
+
+运行时建立在Apache Flink<sup>®</sup>，并具有以下设计原则：
+
+*  __逻辑计算/状态共置：__消息传递，状态访问/更新和函数调用在一起紧密管理。这确保了开箱即用地在高层次支持一致性。 <!--TODO: disambiguate high-level 更抽象的(eg. high-level API) vs. 更高度的(eg. a high level of activity) -->
+
+* __物理计算/状态分离：__可以远程执行函数，并将消息和状态访问作为调用请求的一部分提供。这样，可以像无状态进程一样管理函数，并支持快速扩展，滚动升级和其他常见的操作模式。 ","[{'comment': '```suggestion\r\n* __物理上计算/状态分离：__可以远程执行函数，并将消息和状态访问作为调用请求的一部分提供。这样可以像无状态进程一样管理函数，并支持快速扩展，滚动升级和其他常见的操作模式。 \r\n```', 'commenter': 'carp84'}]"
131,README.zh.md,"@@ -0,0 +1,228 @@
+<img alt=""有状态函数"" src=""docs/fig/stateful_functions_logo.png"" width=350px/>
+
+有状态函数是一个[Apache Flink](https://flink.apache.org/)库， __可简化构建分布式有状态应用程序的过程__ 。它基于有着可持久化状态的函数，这些函数可以在强大的一致性保证下进行动态交互。 
+
+有状态函数使强大的状态管理和组合，与AWS Lambda之类的FaaS实现和Kubernetes之类的现代资源编排框架的弹性，快速缩放/零缩放和滚动升级功能相结合成为可能。通过这些特性，它解决了当今许多FaaS设置中[最常被引用的两个缺点](https://www2.eecs.berkeley.edu/Pubs/TechRpts/2019/EECS-2019-3.pdf) ：状态一致和函数之间的高效消息传递。 
+
+本自述文件旨在简要介绍核心概念以及如何进行设置
+以使您开始使用有状态函数。 
+
+有关详细文档，请访问[官方文档](https://ci.apache.org/projects/flink/flink-statefun-docs-master) 。 
+
+有关代码示例，请查看[示例](statefun-examples/) 。 
+
+ [![构建状态](https://travis-ci.org/apache/flink-statefun.svg?branch=master)](https://travis-ci.org/apache/flink-statefun) 
+
+## 目录
+
+- [核心概念](#core-concepts) 
+   * [抽象化](#abstraction) 
+   * [函数模块和可扩展性](#modules) 
+   * [运行时](#runtime) 
+- [入门](#getting-started) 
+   * [运行一个完整的例子](#greeter) 
+   * [新建项目](#project-setup) 
+   * [构建项目](#build) 
+   * [在IDE Harness中运行](#ide-harness) 
+- [部署应用](#deploying) 
+   * [使用Docker映像进行部署](#docker) 
+   * [部署为Flink作业](#flink) 
+- [贡献](#contributing) 
+- [开源软件许可](#license) 
+
+## <a name=""core-concepts""></a>核心概念
+
+### <a name=""abstraction""></a>抽象化
+
+有状态函数应用程序由以下原语组成：有状态函数，入口(ingress)，
+路由器(router)和出口(egress)。 
+
+<p align=""center"">
+  <img src=""docs/fig/stateful_functions_overview.png"" width=""650px""/>
+</p>
+
+#### 有状态函数
+
+* _有状态函数_是通过消息调用的一小段逻辑/代码。每个有状态函数
+都作为_函数类型_的唯一可调用_虚拟实例_存在。每个实例都通过其``type``以及type中的唯一``ID`` （字符串）来寻址。 
+
+* 有状态函数可以从ingress或任何其他有状态函数（包括其自身）中调用。
+调用者只需要知道目标函数的地址即可。 
+
+* 函数实例是_虚拟的_ ，因为它们不总是同时在内存中活跃。
+在任何时间点，只有一小部分函数及其状态作为实际对象存在。当
+虚拟实例接收到消息时，将配置一个对象并带着该虚拟实例的状态
+加载，然后处理该消息。与虚拟内存类似，许多函数的状态可能
+在任何时间点都被“交换出去”(swap out)。 
+
+* 函数的每个虚拟实例都有其自己的状态，可以通过局部变量访问。
+该状态是私有的，对于该实例是本地的(local)。
+
+如果您知道Apache Flink的DataStream API，则可以将有状态函数考虑为轻量级的
+`KeyedProcessFunction` 。函数``type``等同于处理函数转换(process function transformation)，而`` ID ``是键(key)。不同之处
+在于，函数不是在定义数据流的有向非循环图（DAG）中组装（流拓扑），
+而是使用地址将事件任意发送到所有其他函数。 
+
+#### 入口和出口
+
+* _入口_ (Ingress)是事件最初到达有状态函数应用程序的方式。
+入口可以是消息队列，日志或HTTP服务器-产生事件并由
+应用程序处理的任何物件。 
+
+* _路由器_(Router)连接到入口(Ingress)，以确定哪个函数实例应最初处理事件。 
+
+* _出口_(Egress)是一种以标准化方式从应用程序发送事件的方法。
+出口是可选的；也有可能没有事件离开应用程序和函数接收器(functions sink)事件，或
+直接调用其他应用程序。 
+
+### <a name=""modules""></a>模块(Module)
+
+ _模块_(Module)将核心构建基元添加到有状态函数
+ 应用程序的入口点，即入口，出口，路由器和有状态函数。 
+
+单个应用程序可以是多个模块的组合，每个模块都构成整个应用程序的一部分。
+这允许应用程序的不同部分由不同的模块来组成。例如，
+一个模块可以提供入口和出口，而其他模块可以分别作为状态函数来
+贡献业务逻辑的特定部分。这有助于在独立团队中工作，但仍可以部署到
+相同的更大应用程序中。 
+
+## <a name=""runtime"">运行时 
+
+有状态函数运行时旨在提供一组类似于[无服务器函数](https://martinfowler.com/articles/serverless.html)属性的属性，但适用于有状态问题。 
+
+<p align=""center"">
+  <img src=""docs/fig/stateful_functions_overview-ops.png"" width=""600px""/>
+</p>
+
+运行时建立在Apache Flink<sup>®</sup>，并具有以下设计原则：
+
+*  __逻辑计算/状态共置：__消息传递，状态访问/更新和函数调用在一起紧密管理。这确保了开箱即用地在高层次支持一致性。 <!--TODO: disambiguate high-level 更抽象的(eg. high-level API) vs. 更高度的(eg. a high level of activity) -->
+
+* __物理计算/状态分离：__可以远程执行函数，并将消息和状态访问作为调用请求的一部分提供。这样，可以像无状态进程一样管理函数，并支持快速扩展，滚动升级和其他常见的操作模式。 
+
+* __语言独立性：__函数调用使用简单的HTTP协议/基于gRPC的协议，因此可以轻松地以各种语言实现函数。  ","[{'comment': '```suggestion\r\n* __语言无关性：__函数调用使用一个简单的基于HTTP/gRPC的协议，因此可以用各种语言轻松地实现函数。\r\n```', 'commenter': 'carp84'}]"
131,README.zh.md,"@@ -0,0 +1,228 @@
+<img alt=""有状态函数"" src=""docs/fig/stateful_functions_logo.png"" width=350px/>
+
+有状态函数是一个[Apache Flink](https://flink.apache.org/)库， __可简化构建分布式有状态应用程序的过程__ 。它基于有着可持久化状态的函数，这些函数可以在强大的一致性保证下进行动态交互。 
+
+有状态函数使强大的状态管理和组合，与AWS Lambda之类的FaaS实现和Kubernetes之类的现代资源编排框架的弹性，快速缩放/零缩放和滚动升级功能相结合成为可能。通过这些特性，它解决了当今许多FaaS设置中[最常被引用的两个缺点](https://www2.eecs.berkeley.edu/Pubs/TechRpts/2019/EECS-2019-3.pdf) ：状态一致和函数之间的高效消息传递。 
+
+本自述文件旨在简要介绍核心概念以及如何进行设置
+以使您开始使用有状态函数。 
+
+有关详细文档，请访问[官方文档](https://ci.apache.org/projects/flink/flink-statefun-docs-master) 。 
+
+有关代码示例，请查看[示例](statefun-examples/) 。 
+
+ [![构建状态](https://travis-ci.org/apache/flink-statefun.svg?branch=master)](https://travis-ci.org/apache/flink-statefun) 
+
+## 目录
+
+- [核心概念](#core-concepts) 
+   * [抽象化](#abstraction) 
+   * [函数模块和可扩展性](#modules) 
+   * [运行时](#runtime) 
+- [入门](#getting-started) 
+   * [运行一个完整的例子](#greeter) 
+   * [新建项目](#project-setup) 
+   * [构建项目](#build) 
+   * [在IDE Harness中运行](#ide-harness) 
+- [部署应用](#deploying) 
+   * [使用Docker映像进行部署](#docker) 
+   * [部署为Flink作业](#flink) 
+- [贡献](#contributing) 
+- [开源软件许可](#license) 
+
+## <a name=""core-concepts""></a>核心概念
+
+### <a name=""abstraction""></a>抽象化
+
+有状态函数应用程序由以下原语组成：有状态函数，入口(ingress)，
+路由器(router)和出口(egress)。 
+
+<p align=""center"">
+  <img src=""docs/fig/stateful_functions_overview.png"" width=""650px""/>
+</p>
+
+#### 有状态函数
+
+* _有状态函数_是通过消息调用的一小段逻辑/代码。每个有状态函数
+都作为_函数类型_的唯一可调用_虚拟实例_存在。每个实例都通过其``type``以及type中的唯一``ID`` （字符串）来寻址。 
+
+* 有状态函数可以从ingress或任何其他有状态函数（包括其自身）中调用。
+调用者只需要知道目标函数的地址即可。 
+
+* 函数实例是_虚拟的_ ，因为它们不总是同时在内存中活跃。
+在任何时间点，只有一小部分函数及其状态作为实际对象存在。当
+虚拟实例接收到消息时，将配置一个对象并带着该虚拟实例的状态
+加载，然后处理该消息。与虚拟内存类似，许多函数的状态可能
+在任何时间点都被“交换出去”(swap out)。 
+
+* 函数的每个虚拟实例都有其自己的状态，可以通过局部变量访问。
+该状态是私有的，对于该实例是本地的(local)。
+
+如果您知道Apache Flink的DataStream API，则可以将有状态函数考虑为轻量级的
+`KeyedProcessFunction` 。函数``type``等同于处理函数转换(process function transformation)，而`` ID ``是键(key)。不同之处
+在于，函数不是在定义数据流的有向非循环图（DAG）中组装（流拓扑），
+而是使用地址将事件任意发送到所有其他函数。 
+
+#### 入口和出口
+
+* _入口_ (Ingress)是事件最初到达有状态函数应用程序的方式。
+入口可以是消息队列，日志或HTTP服务器-产生事件并由
+应用程序处理的任何物件。 
+
+* _路由器_(Router)连接到入口(Ingress)，以确定哪个函数实例应最初处理事件。 
+
+* _出口_(Egress)是一种以标准化方式从应用程序发送事件的方法。
+出口是可选的；也有可能没有事件离开应用程序和函数接收器(functions sink)事件，或
+直接调用其他应用程序。 
+
+### <a name=""modules""></a>模块(Module)
+
+ _模块_(Module)将核心构建基元添加到有状态函数
+ 应用程序的入口点，即入口，出口，路由器和有状态函数。 
+
+单个应用程序可以是多个模块的组合，每个模块都构成整个应用程序的一部分。
+这允许应用程序的不同部分由不同的模块来组成。例如，
+一个模块可以提供入口和出口，而其他模块可以分别作为状态函数来
+贡献业务逻辑的特定部分。这有助于在独立团队中工作，但仍可以部署到
+相同的更大应用程序中。 
+
+## <a name=""runtime"">运行时 
+
+有状态函数运行时旨在提供一组类似于[无服务器函数](https://martinfowler.com/articles/serverless.html)属性的属性，但适用于有状态问题。 
+
+<p align=""center"">
+  <img src=""docs/fig/stateful_functions_overview-ops.png"" width=""600px""/>
+</p>
+
+运行时建立在Apache Flink<sup>®</sup>，并具有以下设计原则：
+
+*  __逻辑计算/状态共置：__消息传递，状态访问/更新和函数调用在一起紧密管理。这确保了开箱即用地在高层次支持一致性。 <!--TODO: disambiguate high-level 更抽象的(eg. high-level API) vs. 更高度的(eg. a high level of activity) -->
+
+* __物理计算/状态分离：__可以远程执行函数，并将消息和状态访问作为调用请求的一部分提供。这样，可以像无状态进程一样管理函数，并支持快速扩展，滚动升级和其他常见的操作模式。 
+
+* __语言独立性：__函数调用使用简单的HTTP协议/基于gRPC的协议，因此可以轻松地以各种语言实现函数。  
+
+这使得可以在Kubernetes部署，在FaaS平台上或（微）服务后面执行函数，同时在函数之间提供一致的状态和轻量级消息传递。 ","[{'comment': '```suggestion\r\n这使得在Kubernetes和FaaS平台上，或（微）服务后台执行函数，同时在函数之间提供一致的状态和轻量级消息传递成为可能。 \r\n```', 'commenter': 'carp84'}]"
131,README.zh.md,"@@ -0,0 +1,228 @@
+<img alt=""有状态函数"" src=""docs/fig/stateful_functions_logo.png"" width=350px/>
+
+有状态函数是一个[Apache Flink](https://flink.apache.org/)库， __可简化构建分布式有状态应用程序的过程__ 。它基于有着可持久化状态的函数，这些函数可以在强大的一致性保证下进行动态交互。 
+
+有状态函数使强大的状态管理和组合，与AWS Lambda之类的FaaS实现和Kubernetes之类的现代资源编排框架的弹性，快速缩放/零缩放和滚动升级功能相结合成为可能。通过这些特性，它解决了当今许多FaaS设置中[最常被引用的两个缺点](https://www2.eecs.berkeley.edu/Pubs/TechRpts/2019/EECS-2019-3.pdf) ：状态一致和函数之间的高效消息传递。 
+
+本自述文件旨在简要介绍核心概念以及如何进行设置
+以使您开始使用有状态函数。 
+
+有关详细文档，请访问[官方文档](https://ci.apache.org/projects/flink/flink-statefun-docs-master) 。 
+
+有关代码示例，请查看[示例](statefun-examples/) 。 
+
+ [![构建状态](https://travis-ci.org/apache/flink-statefun.svg?branch=master)](https://travis-ci.org/apache/flink-statefun) 
+
+## 目录
+
+- [核心概念](#core-concepts) 
+   * [抽象化](#abstraction) 
+   * [函数模块和可扩展性](#modules) 
+   * [运行时](#runtime) 
+- [入门](#getting-started) 
+   * [运行一个完整的例子](#greeter) 
+   * [新建项目](#project-setup) 
+   * [构建项目](#build) 
+   * [在IDE Harness中运行](#ide-harness) 
+- [部署应用](#deploying) 
+   * [使用Docker映像进行部署](#docker) 
+   * [部署为Flink作业](#flink) 
+- [贡献](#contributing) 
+- [开源软件许可](#license) 
+
+## <a name=""core-concepts""></a>核心概念
+
+### <a name=""abstraction""></a>抽象化
+
+有状态函数应用程序由以下原语组成：有状态函数，入口(ingress)，
+路由器(router)和出口(egress)。 
+
+<p align=""center"">
+  <img src=""docs/fig/stateful_functions_overview.png"" width=""650px""/>
+</p>
+
+#### 有状态函数
+
+* _有状态函数_是通过消息调用的一小段逻辑/代码。每个有状态函数
+都作为_函数类型_的唯一可调用_虚拟实例_存在。每个实例都通过其``type``以及type中的唯一``ID`` （字符串）来寻址。 
+
+* 有状态函数可以从ingress或任何其他有状态函数（包括其自身）中调用。
+调用者只需要知道目标函数的地址即可。 
+
+* 函数实例是_虚拟的_ ，因为它们不总是同时在内存中活跃。
+在任何时间点，只有一小部分函数及其状态作为实际对象存在。当
+虚拟实例接收到消息时，将配置一个对象并带着该虚拟实例的状态
+加载，然后处理该消息。与虚拟内存类似，许多函数的状态可能
+在任何时间点都被“交换出去”(swap out)。 
+
+* 函数的每个虚拟实例都有其自己的状态，可以通过局部变量访问。
+该状态是私有的，对于该实例是本地的(local)。
+
+如果您知道Apache Flink的DataStream API，则可以将有状态函数考虑为轻量级的
+`KeyedProcessFunction` 。函数``type``等同于处理函数转换(process function transformation)，而`` ID ``是键(key)。不同之处
+在于，函数不是在定义数据流的有向非循环图（DAG）中组装（流拓扑），
+而是使用地址将事件任意发送到所有其他函数。 
+
+#### 入口和出口
+
+* _入口_ (Ingress)是事件最初到达有状态函数应用程序的方式。
+入口可以是消息队列，日志或HTTP服务器-产生事件并由
+应用程序处理的任何物件。 
+
+* _路由器_(Router)连接到入口(Ingress)，以确定哪个函数实例应最初处理事件。 
+
+* _出口_(Egress)是一种以标准化方式从应用程序发送事件的方法。
+出口是可选的；也有可能没有事件离开应用程序和函数接收器(functions sink)事件，或
+直接调用其他应用程序。 
+
+### <a name=""modules""></a>模块(Module)
+
+ _模块_(Module)将核心构建基元添加到有状态函数
+ 应用程序的入口点，即入口，出口，路由器和有状态函数。 
+
+单个应用程序可以是多个模块的组合，每个模块都构成整个应用程序的一部分。
+这允许应用程序的不同部分由不同的模块来组成。例如，
+一个模块可以提供入口和出口，而其他模块可以分别作为状态函数来
+贡献业务逻辑的特定部分。这有助于在独立团队中工作，但仍可以部署到
+相同的更大应用程序中。 
+
+## <a name=""runtime"">运行时 
+
+有状态函数运行时旨在提供一组类似于[无服务器函数](https://martinfowler.com/articles/serverless.html)属性的属性，但适用于有状态问题。 
+
+<p align=""center"">
+  <img src=""docs/fig/stateful_functions_overview-ops.png"" width=""600px""/>
+</p>
+
+运行时建立在Apache Flink<sup>®</sup>，并具有以下设计原则：
+
+*  __逻辑计算/状态共置：__消息传递，状态访问/更新和函数调用在一起紧密管理。这确保了开箱即用地在高层次支持一致性。 <!--TODO: disambiguate high-level 更抽象的(eg. high-level API) vs. 更高度的(eg. a high level of activity) -->
+
+* __物理计算/状态分离：__可以远程执行函数，并将消息和状态访问作为调用请求的一部分提供。这样，可以像无状态进程一样管理函数，并支持快速扩展，滚动升级和其他常见的操作模式。 
+
+* __语言独立性：__函数调用使用简单的HTTP协议/基于gRPC的协议，因此可以轻松地以各种语言实现函数。  
+
+这使得可以在Kubernetes部署，在FaaS平台上或（微）服务后面执行函数，同时在函数之间提供一致的状态和轻量级消息传递。 
+
+## <a name=""getting-started""></a>入门
+
+请按照此处的步骤立即开始使用有状态函数。 ","[{'comment': '```suggestion\r\n按照下面的步骤即可立刻开始使用 Stateful Functions。 \r\n```', 'commenter': 'carp84'}]"
131,README.zh.md,"@@ -0,0 +1,228 @@
+<img alt=""有状态函数"" src=""docs/fig/stateful_functions_logo.png"" width=350px/>
+
+有状态函数是一个[Apache Flink](https://flink.apache.org/)库， __可简化构建分布式有状态应用程序的过程__ 。它基于有着可持久化状态的函数，这些函数可以在强大的一致性保证下进行动态交互。 
+
+有状态函数使强大的状态管理和组合，与AWS Lambda之类的FaaS实现和Kubernetes之类的现代资源编排框架的弹性，快速缩放/零缩放和滚动升级功能相结合成为可能。通过这些特性，它解决了当今许多FaaS设置中[最常被引用的两个缺点](https://www2.eecs.berkeley.edu/Pubs/TechRpts/2019/EECS-2019-3.pdf) ：状态一致和函数之间的高效消息传递。 
+
+本自述文件旨在简要介绍核心概念以及如何进行设置
+以使您开始使用有状态函数。 
+
+有关详细文档，请访问[官方文档](https://ci.apache.org/projects/flink/flink-statefun-docs-master) 。 
+
+有关代码示例，请查看[示例](statefun-examples/) 。 
+
+ [![构建状态](https://travis-ci.org/apache/flink-statefun.svg?branch=master)](https://travis-ci.org/apache/flink-statefun) 
+
+## 目录
+
+- [核心概念](#core-concepts) 
+   * [抽象化](#abstraction) 
+   * [函数模块和可扩展性](#modules) 
+   * [运行时](#runtime) 
+- [入门](#getting-started) 
+   * [运行一个完整的例子](#greeter) 
+   * [新建项目](#project-setup) 
+   * [构建项目](#build) 
+   * [在IDE Harness中运行](#ide-harness) 
+- [部署应用](#deploying) 
+   * [使用Docker映像进行部署](#docker) 
+   * [部署为Flink作业](#flink) 
+- [贡献](#contributing) 
+- [开源软件许可](#license) 
+
+## <a name=""core-concepts""></a>核心概念
+
+### <a name=""abstraction""></a>抽象化
+
+有状态函数应用程序由以下原语组成：有状态函数，入口(ingress)，
+路由器(router)和出口(egress)。 
+
+<p align=""center"">
+  <img src=""docs/fig/stateful_functions_overview.png"" width=""650px""/>
+</p>
+
+#### 有状态函数
+
+* _有状态函数_是通过消息调用的一小段逻辑/代码。每个有状态函数
+都作为_函数类型_的唯一可调用_虚拟实例_存在。每个实例都通过其``type``以及type中的唯一``ID`` （字符串）来寻址。 
+
+* 有状态函数可以从ingress或任何其他有状态函数（包括其自身）中调用。
+调用者只需要知道目标函数的地址即可。 
+
+* 函数实例是_虚拟的_ ，因为它们不总是同时在内存中活跃。
+在任何时间点，只有一小部分函数及其状态作为实际对象存在。当
+虚拟实例接收到消息时，将配置一个对象并带着该虚拟实例的状态
+加载，然后处理该消息。与虚拟内存类似，许多函数的状态可能
+在任何时间点都被“交换出去”(swap out)。 
+
+* 函数的每个虚拟实例都有其自己的状态，可以通过局部变量访问。
+该状态是私有的，对于该实例是本地的(local)。
+
+如果您知道Apache Flink的DataStream API，则可以将有状态函数考虑为轻量级的
+`KeyedProcessFunction` 。函数``type``等同于处理函数转换(process function transformation)，而`` ID ``是键(key)。不同之处
+在于，函数不是在定义数据流的有向非循环图（DAG）中组装（流拓扑），
+而是使用地址将事件任意发送到所有其他函数。 
+
+#### 入口和出口
+
+* _入口_ (Ingress)是事件最初到达有状态函数应用程序的方式。
+入口可以是消息队列，日志或HTTP服务器-产生事件并由
+应用程序处理的任何物件。 
+
+* _路由器_(Router)连接到入口(Ingress)，以确定哪个函数实例应最初处理事件。 
+
+* _出口_(Egress)是一种以标准化方式从应用程序发送事件的方法。
+出口是可选的；也有可能没有事件离开应用程序和函数接收器(functions sink)事件，或
+直接调用其他应用程序。 
+
+### <a name=""modules""></a>模块(Module)
+
+ _模块_(Module)将核心构建基元添加到有状态函数
+ 应用程序的入口点，即入口，出口，路由器和有状态函数。 
+
+单个应用程序可以是多个模块的组合，每个模块都构成整个应用程序的一部分。
+这允许应用程序的不同部分由不同的模块来组成。例如，
+一个模块可以提供入口和出口，而其他模块可以分别作为状态函数来
+贡献业务逻辑的特定部分。这有助于在独立团队中工作，但仍可以部署到
+相同的更大应用程序中。 
+
+## <a name=""runtime"">运行时 
+
+有状态函数运行时旨在提供一组类似于[无服务器函数](https://martinfowler.com/articles/serverless.html)属性的属性，但适用于有状态问题。 
+
+<p align=""center"">
+  <img src=""docs/fig/stateful_functions_overview-ops.png"" width=""600px""/>
+</p>
+
+运行时建立在Apache Flink<sup>®</sup>，并具有以下设计原则：
+
+*  __逻辑计算/状态共置：__消息传递，状态访问/更新和函数调用在一起紧密管理。这确保了开箱即用地在高层次支持一致性。 <!--TODO: disambiguate high-level 更抽象的(eg. high-level API) vs. 更高度的(eg. a high level of activity) -->
+
+* __物理计算/状态分离：__可以远程执行函数，并将消息和状态访问作为调用请求的一部分提供。这样，可以像无状态进程一样管理函数，并支持快速扩展，滚动升级和其他常见的操作模式。 
+
+* __语言独立性：__函数调用使用简单的HTTP协议/基于gRPC的协议，因此可以轻松地以各种语言实现函数。  
+
+这使得可以在Kubernetes部署，在FaaS平台上或（微）服务后面执行函数，同时在函数之间提供一致的状态和轻量级消息传递。 
+
+## <a name=""getting-started""></a>入门
+
+请按照此处的步骤立即开始使用有状态函数。 
+
+本指南将引导您进行设置以开始开发和测试自己的状态函数（Java）应用程序，并运行现有示例。如果您想使用Python快速开始，
+请查看[StateFun Python SDK](https://github.com/apache/flink-statefun/tree/master/statefun-python-sdk)和[Python Greeter示例](https://github.com/apache/flink-statefun/tree/master/statefun-examples/statefun-python-greeter-example) 。 ","[{'comment': '```suggestion\r\n本指南将引导您通过设置开始开发和测试自己的 Stateful Functions（Java）应用程序，并运行一个示例。如果您想使用Python快速开始，\r\n请查看[StateFun Python SDK](https://github.com/apache/flink-statefun/tree/master/statefun-python-sdk)和[Python Greeter示例](https://github.com/apache/flink-statefun/tree/master/statefun-examples/statefun-python-greeter-example) 。 \r\n```', 'commenter': 'carp84'}]"
131,README.zh.md,"@@ -0,0 +1,228 @@
+<img alt=""有状态函数"" src=""docs/fig/stateful_functions_logo.png"" width=350px/>
+
+有状态函数是一个[Apache Flink](https://flink.apache.org/)库， __可简化构建分布式有状态应用程序的过程__ 。它基于有着可持久化状态的函数，这些函数可以在强大的一致性保证下进行动态交互。 
+
+有状态函数使强大的状态管理和组合，与AWS Lambda之类的FaaS实现和Kubernetes之类的现代资源编排框架的弹性，快速缩放/零缩放和滚动升级功能相结合成为可能。通过这些特性，它解决了当今许多FaaS设置中[最常被引用的两个缺点](https://www2.eecs.berkeley.edu/Pubs/TechRpts/2019/EECS-2019-3.pdf) ：状态一致和函数之间的高效消息传递。 
+
+本自述文件旨在简要介绍核心概念以及如何进行设置
+以使您开始使用有状态函数。 
+
+有关详细文档，请访问[官方文档](https://ci.apache.org/projects/flink/flink-statefun-docs-master) 。 
+
+有关代码示例，请查看[示例](statefun-examples/) 。 
+
+ [![构建状态](https://travis-ci.org/apache/flink-statefun.svg?branch=master)](https://travis-ci.org/apache/flink-statefun) 
+
+## 目录
+
+- [核心概念](#core-concepts) 
+   * [抽象化](#abstraction) 
+   * [函数模块和可扩展性](#modules) 
+   * [运行时](#runtime) 
+- [入门](#getting-started) 
+   * [运行一个完整的例子](#greeter) 
+   * [新建项目](#project-setup) 
+   * [构建项目](#build) 
+   * [在IDE Harness中运行](#ide-harness) 
+- [部署应用](#deploying) 
+   * [使用Docker映像进行部署](#docker) 
+   * [部署为Flink作业](#flink) 
+- [贡献](#contributing) 
+- [开源软件许可](#license) 
+
+## <a name=""core-concepts""></a>核心概念
+
+### <a name=""abstraction""></a>抽象化
+
+有状态函数应用程序由以下原语组成：有状态函数，入口(ingress)，
+路由器(router)和出口(egress)。 
+
+<p align=""center"">
+  <img src=""docs/fig/stateful_functions_overview.png"" width=""650px""/>
+</p>
+
+#### 有状态函数
+
+* _有状态函数_是通过消息调用的一小段逻辑/代码。每个有状态函数
+都作为_函数类型_的唯一可调用_虚拟实例_存在。每个实例都通过其``type``以及type中的唯一``ID`` （字符串）来寻址。 
+
+* 有状态函数可以从ingress或任何其他有状态函数（包括其自身）中调用。
+调用者只需要知道目标函数的地址即可。 
+
+* 函数实例是_虚拟的_ ，因为它们不总是同时在内存中活跃。
+在任何时间点，只有一小部分函数及其状态作为实际对象存在。当
+虚拟实例接收到消息时，将配置一个对象并带着该虚拟实例的状态
+加载，然后处理该消息。与虚拟内存类似，许多函数的状态可能
+在任何时间点都被“交换出去”(swap out)。 
+
+* 函数的每个虚拟实例都有其自己的状态，可以通过局部变量访问。
+该状态是私有的，对于该实例是本地的(local)。
+
+如果您知道Apache Flink的DataStream API，则可以将有状态函数考虑为轻量级的
+`KeyedProcessFunction` 。函数``type``等同于处理函数转换(process function transformation)，而`` ID ``是键(key)。不同之处
+在于，函数不是在定义数据流的有向非循环图（DAG）中组装（流拓扑），
+而是使用地址将事件任意发送到所有其他函数。 
+
+#### 入口和出口
+
+* _入口_ (Ingress)是事件最初到达有状态函数应用程序的方式。
+入口可以是消息队列，日志或HTTP服务器-产生事件并由
+应用程序处理的任何物件。 
+
+* _路由器_(Router)连接到入口(Ingress)，以确定哪个函数实例应最初处理事件。 
+
+* _出口_(Egress)是一种以标准化方式从应用程序发送事件的方法。
+出口是可选的；也有可能没有事件离开应用程序和函数接收器(functions sink)事件，或
+直接调用其他应用程序。 
+
+### <a name=""modules""></a>模块(Module)
+
+ _模块_(Module)将核心构建基元添加到有状态函数
+ 应用程序的入口点，即入口，出口，路由器和有状态函数。 
+
+单个应用程序可以是多个模块的组合，每个模块都构成整个应用程序的一部分。
+这允许应用程序的不同部分由不同的模块来组成。例如，
+一个模块可以提供入口和出口，而其他模块可以分别作为状态函数来
+贡献业务逻辑的特定部分。这有助于在独立团队中工作，但仍可以部署到
+相同的更大应用程序中。 
+
+## <a name=""runtime"">运行时 
+
+有状态函数运行时旨在提供一组类似于[无服务器函数](https://martinfowler.com/articles/serverless.html)属性的属性，但适用于有状态问题。 
+
+<p align=""center"">
+  <img src=""docs/fig/stateful_functions_overview-ops.png"" width=""600px""/>
+</p>
+
+运行时建立在Apache Flink<sup>®</sup>，并具有以下设计原则：
+
+*  __逻辑计算/状态共置：__消息传递，状态访问/更新和函数调用在一起紧密管理。这确保了开箱即用地在高层次支持一致性。 <!--TODO: disambiguate high-level 更抽象的(eg. high-level API) vs. 更高度的(eg. a high level of activity) -->
+
+* __物理计算/状态分离：__可以远程执行函数，并将消息和状态访问作为调用请求的一部分提供。这样，可以像无状态进程一样管理函数，并支持快速扩展，滚动升级和其他常见的操作模式。 
+
+* __语言独立性：__函数调用使用简单的HTTP协议/基于gRPC的协议，因此可以轻松地以各种语言实现函数。  
+
+这使得可以在Kubernetes部署，在FaaS平台上或（微）服务后面执行函数，同时在函数之间提供一致的状态和轻量级消息传递。 
+
+## <a name=""getting-started""></a>入门
+
+请按照此处的步骤立即开始使用有状态函数。 
+
+本指南将引导您进行设置以开始开发和测试自己的状态函数（Java）应用程序，并运行现有示例。如果您想使用Python快速开始，
+请查看[StateFun Python SDK](https://github.com/apache/flink-statefun/tree/master/statefun-python-sdk)和[Python Greeter示例](https://github.com/apache/flink-statefun/tree/master/statefun-examples/statefun-python-greeter-example) 。 
+
+### <a name=""project-setup""></a>项目设置
+
+前提条件： 
+
+* Docker  
+    
+* Maven 3.5.x 及以上
+    
+* Java 8 及以上
+
+您可以使用提供的快速入门Maven原型快速开始构建Stateful Function有状态函数应用程序： ","[{'comment': '```suggestion\r\n您可以使用下面的Maven命令快速开始构建 Stateful Functions 应用程序： \r\n```', 'commenter': 'carp84'}]"
131,README.zh.md,"@@ -0,0 +1,228 @@
+<img alt=""有状态函数"" src=""docs/fig/stateful_functions_logo.png"" width=350px/>
+
+有状态函数是一个[Apache Flink](https://flink.apache.org/)库， __可简化构建分布式有状态应用程序的过程__ 。它基于有着可持久化状态的函数，这些函数可以在强大的一致性保证下进行动态交互。 
+
+有状态函数使强大的状态管理和组合，与AWS Lambda之类的FaaS实现和Kubernetes之类的现代资源编排框架的弹性，快速缩放/零缩放和滚动升级功能相结合成为可能。通过这些特性，它解决了当今许多FaaS设置中[最常被引用的两个缺点](https://www2.eecs.berkeley.edu/Pubs/TechRpts/2019/EECS-2019-3.pdf) ：状态一致和函数之间的高效消息传递。 
+
+本自述文件旨在简要介绍核心概念以及如何进行设置
+以使您开始使用有状态函数。 
+
+有关详细文档，请访问[官方文档](https://ci.apache.org/projects/flink/flink-statefun-docs-master) 。 
+
+有关代码示例，请查看[示例](statefun-examples/) 。 
+
+ [![构建状态](https://travis-ci.org/apache/flink-statefun.svg?branch=master)](https://travis-ci.org/apache/flink-statefun) 
+
+## 目录
+
+- [核心概念](#core-concepts) 
+   * [抽象化](#abstraction) 
+   * [函数模块和可扩展性](#modules) 
+   * [运行时](#runtime) 
+- [入门](#getting-started) 
+   * [运行一个完整的例子](#greeter) 
+   * [新建项目](#project-setup) 
+   * [构建项目](#build) 
+   * [在IDE Harness中运行](#ide-harness) 
+- [部署应用](#deploying) 
+   * [使用Docker映像进行部署](#docker) 
+   * [部署为Flink作业](#flink) 
+- [贡献](#contributing) 
+- [开源软件许可](#license) 
+
+## <a name=""core-concepts""></a>核心概念
+
+### <a name=""abstraction""></a>抽象化
+
+有状态函数应用程序由以下原语组成：有状态函数，入口(ingress)，
+路由器(router)和出口(egress)。 
+
+<p align=""center"">
+  <img src=""docs/fig/stateful_functions_overview.png"" width=""650px""/>
+</p>
+
+#### 有状态函数
+
+* _有状态函数_是通过消息调用的一小段逻辑/代码。每个有状态函数
+都作为_函数类型_的唯一可调用_虚拟实例_存在。每个实例都通过其``type``以及type中的唯一``ID`` （字符串）来寻址。 
+
+* 有状态函数可以从ingress或任何其他有状态函数（包括其自身）中调用。
+调用者只需要知道目标函数的地址即可。 
+
+* 函数实例是_虚拟的_ ，因为它们不总是同时在内存中活跃。
+在任何时间点，只有一小部分函数及其状态作为实际对象存在。当
+虚拟实例接收到消息时，将配置一个对象并带着该虚拟实例的状态
+加载，然后处理该消息。与虚拟内存类似，许多函数的状态可能
+在任何时间点都被“交换出去”(swap out)。 
+
+* 函数的每个虚拟实例都有其自己的状态，可以通过局部变量访问。
+该状态是私有的，对于该实例是本地的(local)。
+
+如果您知道Apache Flink的DataStream API，则可以将有状态函数考虑为轻量级的
+`KeyedProcessFunction` 。函数``type``等同于处理函数转换(process function transformation)，而`` ID ``是键(key)。不同之处
+在于，函数不是在定义数据流的有向非循环图（DAG）中组装（流拓扑），
+而是使用地址将事件任意发送到所有其他函数。 
+
+#### 入口和出口
+
+* _入口_ (Ingress)是事件最初到达有状态函数应用程序的方式。
+入口可以是消息队列，日志或HTTP服务器-产生事件并由
+应用程序处理的任何物件。 
+
+* _路由器_(Router)连接到入口(Ingress)，以确定哪个函数实例应最初处理事件。 
+
+* _出口_(Egress)是一种以标准化方式从应用程序发送事件的方法。
+出口是可选的；也有可能没有事件离开应用程序和函数接收器(functions sink)事件，或
+直接调用其他应用程序。 
+
+### <a name=""modules""></a>模块(Module)
+
+ _模块_(Module)将核心构建基元添加到有状态函数
+ 应用程序的入口点，即入口，出口，路由器和有状态函数。 
+
+单个应用程序可以是多个模块的组合，每个模块都构成整个应用程序的一部分。
+这允许应用程序的不同部分由不同的模块来组成。例如，
+一个模块可以提供入口和出口，而其他模块可以分别作为状态函数来
+贡献业务逻辑的特定部分。这有助于在独立团队中工作，但仍可以部署到
+相同的更大应用程序中。 
+
+## <a name=""runtime"">运行时 
+
+有状态函数运行时旨在提供一组类似于[无服务器函数](https://martinfowler.com/articles/serverless.html)属性的属性，但适用于有状态问题。 
+
+<p align=""center"">
+  <img src=""docs/fig/stateful_functions_overview-ops.png"" width=""600px""/>
+</p>
+
+运行时建立在Apache Flink<sup>®</sup>，并具有以下设计原则：
+
+*  __逻辑计算/状态共置：__消息传递，状态访问/更新和函数调用在一起紧密管理。这确保了开箱即用地在高层次支持一致性。 <!--TODO: disambiguate high-level 更抽象的(eg. high-level API) vs. 更高度的(eg. a high level of activity) -->
+
+* __物理计算/状态分离：__可以远程执行函数，并将消息和状态访问作为调用请求的一部分提供。这样，可以像无状态进程一样管理函数，并支持快速扩展，滚动升级和其他常见的操作模式。 
+
+* __语言独立性：__函数调用使用简单的HTTP协议/基于gRPC的协议，因此可以轻松地以各种语言实现函数。  
+
+这使得可以在Kubernetes部署，在FaaS平台上或（微）服务后面执行函数，同时在函数之间提供一致的状态和轻量级消息传递。 
+
+## <a name=""getting-started""></a>入门
+
+请按照此处的步骤立即开始使用有状态函数。 
+
+本指南将引导您进行设置以开始开发和测试自己的状态函数（Java）应用程序，并运行现有示例。如果您想使用Python快速开始，
+请查看[StateFun Python SDK](https://github.com/apache/flink-statefun/tree/master/statefun-python-sdk)和[Python Greeter示例](https://github.com/apache/flink-statefun/tree/master/statefun-examples/statefun-python-greeter-example) 。 
+
+### <a name=""project-setup""></a>项目设置
+
+前提条件： 
+
+* Docker  
+    
+* Maven 3.5.x 及以上
+    
+* Java 8 及以上
+
+您可以使用提供的快速入门Maven原型快速开始构建Stateful Function有状态函数应用程序： 
+
+```
+mvn archetype:generate \
+  -DarchetypeGroupId=org.apache.flink \
+  -DarchetypeArtifactId=statefun-quickstart \
+  -DarchetypeVersion=2.2-SNAPSHOT
+```
+
+这使您可以命名新创建的项目。它将以交互方式询问您`` GroupId `` ， 
+`` ArtifactId ``和程序包名称。将有一个与您的`` ArtifactId ``同名的新目录。 ","[{'comment': '```suggestion\r\n这使您可以命名新创建的项目。它将以交互方式询问您`` GroupId `` ， \r\n`` ArtifactId ``和 package 名称，并将生成一个与您指定的`` ArtifactId ``同名的新目录。 \r\n```', 'commenter': 'carp84'}]"
131,README.zh.md,"@@ -0,0 +1,228 @@
+<img alt=""有状态函数"" src=""docs/fig/stateful_functions_logo.png"" width=350px/>
+
+有状态函数是一个[Apache Flink](https://flink.apache.org/)库， __可简化构建分布式有状态应用程序的过程__ 。它基于有着可持久化状态的函数，这些函数可以在强大的一致性保证下进行动态交互。 
+
+有状态函数使强大的状态管理和组合，与AWS Lambda之类的FaaS实现和Kubernetes之类的现代资源编排框架的弹性，快速缩放/零缩放和滚动升级功能相结合成为可能。通过这些特性，它解决了当今许多FaaS设置中[最常被引用的两个缺点](https://www2.eecs.berkeley.edu/Pubs/TechRpts/2019/EECS-2019-3.pdf) ：状态一致和函数之间的高效消息传递。 
+
+本自述文件旨在简要介绍核心概念以及如何进行设置
+以使您开始使用有状态函数。 
+
+有关详细文档，请访问[官方文档](https://ci.apache.org/projects/flink/flink-statefun-docs-master) 。 
+
+有关代码示例，请查看[示例](statefun-examples/) 。 
+
+ [![构建状态](https://travis-ci.org/apache/flink-statefun.svg?branch=master)](https://travis-ci.org/apache/flink-statefun) 
+
+## 目录
+
+- [核心概念](#core-concepts) 
+   * [抽象化](#abstraction) 
+   * [函数模块和可扩展性](#modules) 
+   * [运行时](#runtime) 
+- [入门](#getting-started) 
+   * [运行一个完整的例子](#greeter) 
+   * [新建项目](#project-setup) 
+   * [构建项目](#build) 
+   * [在IDE Harness中运行](#ide-harness) 
+- [部署应用](#deploying) 
+   * [使用Docker映像进行部署](#docker) 
+   * [部署为Flink作业](#flink) 
+- [贡献](#contributing) 
+- [开源软件许可](#license) 
+
+## <a name=""core-concepts""></a>核心概念
+
+### <a name=""abstraction""></a>抽象化
+
+有状态函数应用程序由以下原语组成：有状态函数，入口(ingress)，
+路由器(router)和出口(egress)。 
+
+<p align=""center"">
+  <img src=""docs/fig/stateful_functions_overview.png"" width=""650px""/>
+</p>
+
+#### 有状态函数
+
+* _有状态函数_是通过消息调用的一小段逻辑/代码。每个有状态函数
+都作为_函数类型_的唯一可调用_虚拟实例_存在。每个实例都通过其``type``以及type中的唯一``ID`` （字符串）来寻址。 
+
+* 有状态函数可以从ingress或任何其他有状态函数（包括其自身）中调用。
+调用者只需要知道目标函数的地址即可。 
+
+* 函数实例是_虚拟的_ ，因为它们不总是同时在内存中活跃。
+在任何时间点，只有一小部分函数及其状态作为实际对象存在。当
+虚拟实例接收到消息时，将配置一个对象并带着该虚拟实例的状态
+加载，然后处理该消息。与虚拟内存类似，许多函数的状态可能
+在任何时间点都被“交换出去”(swap out)。 
+
+* 函数的每个虚拟实例都有其自己的状态，可以通过局部变量访问。
+该状态是私有的，对于该实例是本地的(local)。
+
+如果您知道Apache Flink的DataStream API，则可以将有状态函数考虑为轻量级的
+`KeyedProcessFunction` 。函数``type``等同于处理函数转换(process function transformation)，而`` ID ``是键(key)。不同之处
+在于，函数不是在定义数据流的有向非循环图（DAG）中组装（流拓扑），
+而是使用地址将事件任意发送到所有其他函数。 
+
+#### 入口和出口
+
+* _入口_ (Ingress)是事件最初到达有状态函数应用程序的方式。
+入口可以是消息队列，日志或HTTP服务器-产生事件并由
+应用程序处理的任何物件。 
+
+* _路由器_(Router)连接到入口(Ingress)，以确定哪个函数实例应最初处理事件。 
+
+* _出口_(Egress)是一种以标准化方式从应用程序发送事件的方法。
+出口是可选的；也有可能没有事件离开应用程序和函数接收器(functions sink)事件，或
+直接调用其他应用程序。 
+
+### <a name=""modules""></a>模块(Module)
+
+ _模块_(Module)将核心构建基元添加到有状态函数
+ 应用程序的入口点，即入口，出口，路由器和有状态函数。 
+
+单个应用程序可以是多个模块的组合，每个模块都构成整个应用程序的一部分。
+这允许应用程序的不同部分由不同的模块来组成。例如，
+一个模块可以提供入口和出口，而其他模块可以分别作为状态函数来
+贡献业务逻辑的特定部分。这有助于在独立团队中工作，但仍可以部署到
+相同的更大应用程序中。 
+
+## <a name=""runtime"">运行时 
+
+有状态函数运行时旨在提供一组类似于[无服务器函数](https://martinfowler.com/articles/serverless.html)属性的属性，但适用于有状态问题。 
+
+<p align=""center"">
+  <img src=""docs/fig/stateful_functions_overview-ops.png"" width=""600px""/>
+</p>
+
+运行时建立在Apache Flink<sup>®</sup>，并具有以下设计原则：
+
+*  __逻辑计算/状态共置：__消息传递，状态访问/更新和函数调用在一起紧密管理。这确保了开箱即用地在高层次支持一致性。 <!--TODO: disambiguate high-level 更抽象的(eg. high-level API) vs. 更高度的(eg. a high level of activity) -->
+
+* __物理计算/状态分离：__可以远程执行函数，并将消息和状态访问作为调用请求的一部分提供。这样，可以像无状态进程一样管理函数，并支持快速扩展，滚动升级和其他常见的操作模式。 
+
+* __语言独立性：__函数调用使用简单的HTTP协议/基于gRPC的协议，因此可以轻松地以各种语言实现函数。  
+
+这使得可以在Kubernetes部署，在FaaS平台上或（微）服务后面执行函数，同时在函数之间提供一致的状态和轻量级消息传递。 
+
+## <a name=""getting-started""></a>入门
+
+请按照此处的步骤立即开始使用有状态函数。 
+
+本指南将引导您进行设置以开始开发和测试自己的状态函数（Java）应用程序，并运行现有示例。如果您想使用Python快速开始，
+请查看[StateFun Python SDK](https://github.com/apache/flink-statefun/tree/master/statefun-python-sdk)和[Python Greeter示例](https://github.com/apache/flink-statefun/tree/master/statefun-examples/statefun-python-greeter-example) 。 
+
+### <a name=""project-setup""></a>项目设置
+
+前提条件： 
+
+* Docker  
+    
+* Maven 3.5.x 及以上
+    
+* Java 8 及以上
+
+您可以使用提供的快速入门Maven原型快速开始构建Stateful Function有状态函数应用程序： 
+
+```
+mvn archetype:generate \
+  -DarchetypeGroupId=org.apache.flink \
+  -DarchetypeArtifactId=statefun-quickstart \
+  -DarchetypeVersion=2.2-SNAPSHOT
+```
+
+这使您可以命名新创建的项目。它将以交互方式询问您`` GroupId `` ， 
+`` ArtifactId ``和程序包名称。将有一个与您的`` ArtifactId ``同名的新目录。 
+
+我们建议您将此项目导入到IDE中进行开发和测试。 
+IntelliJ IDEA开箱即用地支持Maven项目。如果使用Eclipse，则`` m2e ``插件允许导入
+Maven项目。某些Eclipse捆绑包默认包含该插件，而另一些则需要您手动安装。 ","[{'comment': '```suggestion\r\nIntelliJ IDEA天然支持Maven项目。如果使用Eclipse，则需要使用`` m2e ``插件导入\r\nMaven项目。一些 Eclipse发布版本默认包含该插件，而另一些则需要您手动安装。 \r\n```', 'commenter': 'carp84'}]"
131,README.zh.md,"@@ -0,0 +1,228 @@
+<img alt=""有状态函数"" src=""docs/fig/stateful_functions_logo.png"" width=350px/>
+
+有状态函数是一个[Apache Flink](https://flink.apache.org/)库， __可简化构建分布式有状态应用程序的过程__ 。它基于有着可持久化状态的函数，这些函数可以在强大的一致性保证下进行动态交互。 
+
+有状态函数使强大的状态管理和组合，与AWS Lambda之类的FaaS实现和Kubernetes之类的现代资源编排框架的弹性，快速缩放/零缩放和滚动升级功能相结合成为可能。通过这些特性，它解决了当今许多FaaS设置中[最常被引用的两个缺点](https://www2.eecs.berkeley.edu/Pubs/TechRpts/2019/EECS-2019-3.pdf) ：状态一致和函数之间的高效消息传递。 
+
+本自述文件旨在简要介绍核心概念以及如何进行设置
+以使您开始使用有状态函数。 
+
+有关详细文档，请访问[官方文档](https://ci.apache.org/projects/flink/flink-statefun-docs-master) 。 
+
+有关代码示例，请查看[示例](statefun-examples/) 。 
+
+ [![构建状态](https://travis-ci.org/apache/flink-statefun.svg?branch=master)](https://travis-ci.org/apache/flink-statefun) 
+
+## 目录
+
+- [核心概念](#core-concepts) 
+   * [抽象化](#abstraction) 
+   * [函数模块和可扩展性](#modules) 
+   * [运行时](#runtime) 
+- [入门](#getting-started) 
+   * [运行一个完整的例子](#greeter) 
+   * [新建项目](#project-setup) 
+   * [构建项目](#build) 
+   * [在IDE Harness中运行](#ide-harness) 
+- [部署应用](#deploying) 
+   * [使用Docker映像进行部署](#docker) 
+   * [部署为Flink作业](#flink) 
+- [贡献](#contributing) 
+- [开源软件许可](#license) 
+
+## <a name=""core-concepts""></a>核心概念
+
+### <a name=""abstraction""></a>抽象化
+
+有状态函数应用程序由以下原语组成：有状态函数，入口(ingress)，
+路由器(router)和出口(egress)。 
+
+<p align=""center"">
+  <img src=""docs/fig/stateful_functions_overview.png"" width=""650px""/>
+</p>
+
+#### 有状态函数
+
+* _有状态函数_是通过消息调用的一小段逻辑/代码。每个有状态函数
+都作为_函数类型_的唯一可调用_虚拟实例_存在。每个实例都通过其``type``以及type中的唯一``ID`` （字符串）来寻址。 
+
+* 有状态函数可以从ingress或任何其他有状态函数（包括其自身）中调用。
+调用者只需要知道目标函数的地址即可。 
+
+* 函数实例是_虚拟的_ ，因为它们不总是同时在内存中活跃。
+在任何时间点，只有一小部分函数及其状态作为实际对象存在。当
+虚拟实例接收到消息时，将配置一个对象并带着该虚拟实例的状态
+加载，然后处理该消息。与虚拟内存类似，许多函数的状态可能
+在任何时间点都被“交换出去”(swap out)。 
+
+* 函数的每个虚拟实例都有其自己的状态，可以通过局部变量访问。
+该状态是私有的，对于该实例是本地的(local)。
+
+如果您知道Apache Flink的DataStream API，则可以将有状态函数考虑为轻量级的
+`KeyedProcessFunction` 。函数``type``等同于处理函数转换(process function transformation)，而`` ID ``是键(key)。不同之处
+在于，函数不是在定义数据流的有向非循环图（DAG）中组装（流拓扑），
+而是使用地址将事件任意发送到所有其他函数。 
+
+#### 入口和出口
+
+* _入口_ (Ingress)是事件最初到达有状态函数应用程序的方式。
+入口可以是消息队列，日志或HTTP服务器-产生事件并由
+应用程序处理的任何物件。 
+
+* _路由器_(Router)连接到入口(Ingress)，以确定哪个函数实例应最初处理事件。 
+
+* _出口_(Egress)是一种以标准化方式从应用程序发送事件的方法。
+出口是可选的；也有可能没有事件离开应用程序和函数接收器(functions sink)事件，或
+直接调用其他应用程序。 
+
+### <a name=""modules""></a>模块(Module)
+
+ _模块_(Module)将核心构建基元添加到有状态函数
+ 应用程序的入口点，即入口，出口，路由器和有状态函数。 
+
+单个应用程序可以是多个模块的组合，每个模块都构成整个应用程序的一部分。
+这允许应用程序的不同部分由不同的模块来组成。例如，
+一个模块可以提供入口和出口，而其他模块可以分别作为状态函数来
+贡献业务逻辑的特定部分。这有助于在独立团队中工作，但仍可以部署到
+相同的更大应用程序中。 
+
+## <a name=""runtime"">运行时 
+
+有状态函数运行时旨在提供一组类似于[无服务器函数](https://martinfowler.com/articles/serverless.html)属性的属性，但适用于有状态问题。 
+
+<p align=""center"">
+  <img src=""docs/fig/stateful_functions_overview-ops.png"" width=""600px""/>
+</p>
+
+运行时建立在Apache Flink<sup>®</sup>，并具有以下设计原则：
+
+*  __逻辑计算/状态共置：__消息传递，状态访问/更新和函数调用在一起紧密管理。这确保了开箱即用地在高层次支持一致性。 <!--TODO: disambiguate high-level 更抽象的(eg. high-level API) vs. 更高度的(eg. a high level of activity) -->
+
+* __物理计算/状态分离：__可以远程执行函数，并将消息和状态访问作为调用请求的一部分提供。这样，可以像无状态进程一样管理函数，并支持快速扩展，滚动升级和其他常见的操作模式。 
+
+* __语言独立性：__函数调用使用简单的HTTP协议/基于gRPC的协议，因此可以轻松地以各种语言实现函数。  
+
+这使得可以在Kubernetes部署，在FaaS平台上或（微）服务后面执行函数，同时在函数之间提供一致的状态和轻量级消息传递。 
+
+## <a name=""getting-started""></a>入门
+
+请按照此处的步骤立即开始使用有状态函数。 
+
+本指南将引导您进行设置以开始开发和测试自己的状态函数（Java）应用程序，并运行现有示例。如果您想使用Python快速开始，
+请查看[StateFun Python SDK](https://github.com/apache/flink-statefun/tree/master/statefun-python-sdk)和[Python Greeter示例](https://github.com/apache/flink-statefun/tree/master/statefun-examples/statefun-python-greeter-example) 。 
+
+### <a name=""project-setup""></a>项目设置
+
+前提条件： 
+
+* Docker  
+    
+* Maven 3.5.x 及以上
+    
+* Java 8 及以上
+
+您可以使用提供的快速入门Maven原型快速开始构建Stateful Function有状态函数应用程序： 
+
+```
+mvn archetype:generate \
+  -DarchetypeGroupId=org.apache.flink \
+  -DarchetypeArtifactId=statefun-quickstart \
+  -DarchetypeVersion=2.2-SNAPSHOT
+```
+
+这使您可以命名新创建的项目。它将以交互方式询问您`` GroupId `` ， 
+`` ArtifactId ``和程序包名称。将有一个与您的`` ArtifactId ``同名的新目录。 
+
+我们建议您将此项目导入到IDE中进行开发和测试。 
+IntelliJ IDEA开箱即用地支持Maven项目。如果使用Eclipse，则`` m2e ``插件允许导入
+Maven项目。某些Eclipse捆绑包默认包含该插件，而另一些则需要您手动安装。 
+
+### <a name=""build""></a>建设项目
+
+如果要构建/打包项目，请转到项目目录并运行`` mvn clean package ``命令。您将找到一个包含您的应用程序的JAR文件，以及可能已作为依赖关系添加到该应用程序的任何库：`target/<artifact-id>-<version>.jar`。 ","[{'comment': '```suggestion\r\n如果要构建/打包项目，请进入项目目录并运行`` mvn clean package ``命令。您将找到一个包含您的应用程序以及相关依赖的JAR包：`target/<artifact-id>-<version>.jar`。 \r\n```', 'commenter': 'carp84'}]"
131,README.zh.md,"@@ -0,0 +1,228 @@
+<img alt=""有状态函数"" src=""docs/fig/stateful_functions_logo.png"" width=350px/>
+
+有状态函数是一个[Apache Flink](https://flink.apache.org/)库， __可简化构建分布式有状态应用程序的过程__ 。它基于有着可持久化状态的函数，这些函数可以在强大的一致性保证下进行动态交互。 
+
+有状态函数使强大的状态管理和组合，与AWS Lambda之类的FaaS实现和Kubernetes之类的现代资源编排框架的弹性，快速缩放/零缩放和滚动升级功能相结合成为可能。通过这些特性，它解决了当今许多FaaS设置中[最常被引用的两个缺点](https://www2.eecs.berkeley.edu/Pubs/TechRpts/2019/EECS-2019-3.pdf) ：状态一致和函数之间的高效消息传递。 
+
+本自述文件旨在简要介绍核心概念以及如何进行设置
+以使您开始使用有状态函数。 
+
+有关详细文档，请访问[官方文档](https://ci.apache.org/projects/flink/flink-statefun-docs-master) 。 
+
+有关代码示例，请查看[示例](statefun-examples/) 。 
+
+ [![构建状态](https://travis-ci.org/apache/flink-statefun.svg?branch=master)](https://travis-ci.org/apache/flink-statefun) 
+
+## 目录
+
+- [核心概念](#core-concepts) 
+   * [抽象化](#abstraction) 
+   * [函数模块和可扩展性](#modules) 
+   * [运行时](#runtime) 
+- [入门](#getting-started) 
+   * [运行一个完整的例子](#greeter) 
+   * [新建项目](#project-setup) 
+   * [构建项目](#build) 
+   * [在IDE Harness中运行](#ide-harness) 
+- [部署应用](#deploying) 
+   * [使用Docker映像进行部署](#docker) 
+   * [部署为Flink作业](#flink) 
+- [贡献](#contributing) 
+- [开源软件许可](#license) 
+
+## <a name=""core-concepts""></a>核心概念
+
+### <a name=""abstraction""></a>抽象化
+
+有状态函数应用程序由以下原语组成：有状态函数，入口(ingress)，
+路由器(router)和出口(egress)。 
+
+<p align=""center"">
+  <img src=""docs/fig/stateful_functions_overview.png"" width=""650px""/>
+</p>
+
+#### 有状态函数
+
+* _有状态函数_是通过消息调用的一小段逻辑/代码。每个有状态函数
+都作为_函数类型_的唯一可调用_虚拟实例_存在。每个实例都通过其``type``以及type中的唯一``ID`` （字符串）来寻址。 
+
+* 有状态函数可以从ingress或任何其他有状态函数（包括其自身）中调用。
+调用者只需要知道目标函数的地址即可。 
+
+* 函数实例是_虚拟的_ ，因为它们不总是同时在内存中活跃。
+在任何时间点，只有一小部分函数及其状态作为实际对象存在。当
+虚拟实例接收到消息时，将配置一个对象并带着该虚拟实例的状态
+加载，然后处理该消息。与虚拟内存类似，许多函数的状态可能
+在任何时间点都被“交换出去”(swap out)。 
+
+* 函数的每个虚拟实例都有其自己的状态，可以通过局部变量访问。
+该状态是私有的，对于该实例是本地的(local)。
+
+如果您知道Apache Flink的DataStream API，则可以将有状态函数考虑为轻量级的
+`KeyedProcessFunction` 。函数``type``等同于处理函数转换(process function transformation)，而`` ID ``是键(key)。不同之处
+在于，函数不是在定义数据流的有向非循环图（DAG）中组装（流拓扑），
+而是使用地址将事件任意发送到所有其他函数。 
+
+#### 入口和出口
+
+* _入口_ (Ingress)是事件最初到达有状态函数应用程序的方式。
+入口可以是消息队列，日志或HTTP服务器-产生事件并由
+应用程序处理的任何物件。 
+
+* _路由器_(Router)连接到入口(Ingress)，以确定哪个函数实例应最初处理事件。 
+
+* _出口_(Egress)是一种以标准化方式从应用程序发送事件的方法。
+出口是可选的；也有可能没有事件离开应用程序和函数接收器(functions sink)事件，或
+直接调用其他应用程序。 
+
+### <a name=""modules""></a>模块(Module)
+
+ _模块_(Module)将核心构建基元添加到有状态函数
+ 应用程序的入口点，即入口，出口，路由器和有状态函数。 
+
+单个应用程序可以是多个模块的组合，每个模块都构成整个应用程序的一部分。
+这允许应用程序的不同部分由不同的模块来组成。例如，
+一个模块可以提供入口和出口，而其他模块可以分别作为状态函数来
+贡献业务逻辑的特定部分。这有助于在独立团队中工作，但仍可以部署到
+相同的更大应用程序中。 
+
+## <a name=""runtime"">运行时 
+
+有状态函数运行时旨在提供一组类似于[无服务器函数](https://martinfowler.com/articles/serverless.html)属性的属性，但适用于有状态问题。 
+
+<p align=""center"">
+  <img src=""docs/fig/stateful_functions_overview-ops.png"" width=""600px""/>
+</p>
+
+运行时建立在Apache Flink<sup>®</sup>，并具有以下设计原则：
+
+*  __逻辑计算/状态共置：__消息传递，状态访问/更新和函数调用在一起紧密管理。这确保了开箱即用地在高层次支持一致性。 <!--TODO: disambiguate high-level 更抽象的(eg. high-level API) vs. 更高度的(eg. a high level of activity) -->
+
+* __物理计算/状态分离：__可以远程执行函数，并将消息和状态访问作为调用请求的一部分提供。这样，可以像无状态进程一样管理函数，并支持快速扩展，滚动升级和其他常见的操作模式。 
+
+* __语言独立性：__函数调用使用简单的HTTP协议/基于gRPC的协议，因此可以轻松地以各种语言实现函数。  
+
+这使得可以在Kubernetes部署，在FaaS平台上或（微）服务后面执行函数，同时在函数之间提供一致的状态和轻量级消息传递。 
+
+## <a name=""getting-started""></a>入门
+
+请按照此处的步骤立即开始使用有状态函数。 
+
+本指南将引导您进行设置以开始开发和测试自己的状态函数（Java）应用程序，并运行现有示例。如果您想使用Python快速开始，
+请查看[StateFun Python SDK](https://github.com/apache/flink-statefun/tree/master/statefun-python-sdk)和[Python Greeter示例](https://github.com/apache/flink-statefun/tree/master/statefun-examples/statefun-python-greeter-example) 。 
+
+### <a name=""project-setup""></a>项目设置
+
+前提条件： 
+
+* Docker  
+    
+* Maven 3.5.x 及以上
+    
+* Java 8 及以上
+
+您可以使用提供的快速入门Maven原型快速开始构建Stateful Function有状态函数应用程序： 
+
+```
+mvn archetype:generate \
+  -DarchetypeGroupId=org.apache.flink \
+  -DarchetypeArtifactId=statefun-quickstart \
+  -DarchetypeVersion=2.2-SNAPSHOT
+```
+
+这使您可以命名新创建的项目。它将以交互方式询问您`` GroupId `` ， 
+`` ArtifactId ``和程序包名称。将有一个与您的`` ArtifactId ``同名的新目录。 
+
+我们建议您将此项目导入到IDE中进行开发和测试。 
+IntelliJ IDEA开箱即用地支持Maven项目。如果使用Eclipse，则`` m2e ``插件允许导入
+Maven项目。某些Eclipse捆绑包默认包含该插件，而另一些则需要您手动安装。 
+
+### <a name=""build""></a>建设项目
+
+如果要构建/打包项目，请转到项目目录并运行`` mvn clean package ``命令。您将找到一个包含您的应用程序的JAR文件，以及可能已作为依赖关系添加到该应用程序的任何库：`target/<artifact-id>-<version>.jar`。 
+
+### <a name=""ide-harness""></a>从IDE Harness运行
+
+要测试您的应用程序，可以直接在IDE中运行它，而无需进行任何进一步的打包或部署。 ","[{'comment': '```suggestion\r\n要测试您的应用程序，可以直接在IDE中运行它，而无需进一步的打包或部署。 \r\n```', 'commenter': 'carp84'}]"
152,statefun-flink/statefun-flink-core/src/main/java/org/apache/flink/statefun/flink/core/StatefulFunctionsConfigValidator.java,"@@ -61,4 +64,26 @@ private static void validateParentFirstClassloaderPatterns(Configuration configu
     }
     return parentFirstClassloaderPatterns;
   }
+
+  private static void validateCustomPayloadSerializerClassName(Configuration configuration) {
+
+    MessageFactoryType factoryType =
+        configuration.get(StatefulFunctionsConfig.USER_MESSAGE_SERIALIZER);
+    String customPayloadSerializerClassName =
+        configuration.get(StatefulFunctionsConfig.USER_MESSAGE_CUSTOM_PAYLOAD_SERIALIZER_CLASS);
+
+    if (factoryType == MessageFactoryType.WITH_CUSTOM_PAYLOADS) {
+      if (StringUtils.isNullOrWhitespaceOnly(customPayloadSerializerClassName)) {","[{'comment': 'I think that it could be just replaced with a call to ‘.trim()’ and then checking if the string is empty.\r\nTo avoid this dependency (I know it is currently there)', 'commenter': 'igalshilman'}, {'comment': ""A question here -- as it stands now, the USER_MESSAGE_CUSTOM_PAYLOAD_SERIALIZER_CLASS config option has no default value, so if not set, its value will be null. So I believe I'd have to first check for null and then check length on the trimmed string. I'm happy to do that, but I thought I'd check first in case that affects things ...\r\n\r\nOr should USER_MESSAGE_CUSTOM_PAYLOAD_SERIALIZER_CLASS have an empty string as the default value?"", 'commenter': 'galenwarren'}, {'comment': ""I think that you are right, let's leave that as it is 👍 "", 'commenter': 'igalshilman'}, {'comment': 'OK will do', 'commenter': 'galenwarren'}]"
152,statefun-flink/statefun-flink-core/src/main/java/org/apache/flink/statefun/flink/core/message/MessageFactoryKey.java,"@@ -0,0 +1,43 @@
+package org.apache.flink.statefun.flink.core.message;
+
+import java.io.Serializable;
+import java.util.Objects;
+
+public class MessageFactoryKey implements Serializable {
+  private static final long serialVersionUID = 1L;
+
+  private final MessageFactoryType type;
+  private final String customPayloadSerializerClassName;
+
+  private MessageFactoryKey(MessageFactoryType type, String customPayloadSerializerClassName) {
+    this.type = type;
+    this.customPayloadSerializerClassName = customPayloadSerializerClassName;
+  }
+
+  public static MessageFactoryKey forType(
+      MessageFactoryType type, String customPayloadSerializerClassName) {
+    return new MessageFactoryKey(type, customPayloadSerializerClassName);
+  }
+
+  public MessageFactoryType getType() {
+    return this.type;
+  }
+
+  public String getCustomPayloadSerializerClassName() {","[{'comment': 'Can you add here a Precondtions.checkState that indeed the serializer is custom?', 'commenter': 'igalshilman'}, {'comment': 'As it stands now, this method gets called from MessageTypeSerializer.Snapshot.writeSnapshot, for all types of message serializers, not just custom ones. For non-custom ones, a null is returned and this is the value that is written into the snapshot, after the MesssageFactoryType. So, the version 2 serialized format is always a MessageFactoryType value and then the custom payload serializer class name (string, which can be null), for all types of serializers.\r\n\r\nThe writeSnapshot method could be changed to only call getCustomPayloadSerializerClassName in the event that the serializer is custom, and then to either 1) force a null serializer class name to be written to the snapshot or 2) skip the write of the serializer class name altogether in the non-custom case. This would make the read/writeSnapshot code and testing a bit more complicated but would definitely be doable, would one of those options be better?', 'commenter': 'galenwarren'}, {'comment': 'That is a good point!\r\nIn that case, what do you think about making this method return an `Optional<String>`,\r\nand version 2 would write an extra byte to indicate if the optional is present or not.\r\n\r\nSomething along the lines:\r\n```\r\nif (className.isPresent()) {\r\n   out.writeBooolean(true);\r\n   out.writeUtf8String(className.get());\r\n} else {\r\n   out.writeBooolean(false);\r\n}\r\n```\r\n', 'commenter': 'igalshilman'}, {'comment': ""For some reason, before I couldn't comment here, but now I can. Weird glitch. Anyway, I left a top-level comment/question for you on this one, just FYI."", 'commenter': 'galenwarren'}, {'comment': ""> \r\n> So the serialized format would already seem to be what you've requested! But if you'd prefer it get written without using `StringUtils.writeNullableString`, I'm happy to make that change.\r\n\r\nOh I see. My original thinking here was to prevent a future NPE by someone who would expect (mistakenly) that `messageFactoryKey.getCustomPayloadSerializerClassName()`  would always return a class name. Making the method return `Optional` would signal to the user of that class that it is not necessarily true.\r\n\r\nAnd regarding `StringUtils` I'd rather to keep that logic local to the `Snapshot` class, to protect from accidental change in `StringUtils`.\r\n\r\n \r\n"", 'commenter': 'igalshilman'}, {'comment': ""Great -- understood, I'll make that change and push a new version."", 'commenter': 'galenwarren'}, {'comment': 'These changes are in the code I just pushed, please let me know if it looks OK or if you need anything else. Thanks.\r\n\r\n', 'commenter': 'galenwarren'}]"
152,statefun-flink/statefun-flink-core/src/main/java/org/apache/flink/statefun/flink/core/message/MessageTypeSerializer.java,"@@ -101,45 +102,67 @@ public int hashCode() {
 
   @Override
   public TypeSerializerSnapshot<Message> snapshotConfiguration() {
-    return new Snapshot(messageFactoryType);
+    return new Snapshot(messageFactoryKey);
   }
 
   private MessageFactory factory() {
     if (factory == null) {
-      factory = MessageFactory.forType(messageFactoryType);
+      factory = MessageFactory.forKey(messageFactoryKey);
     }
     return factory;
   }
 
   public static final class Snapshot implements TypeSerializerSnapshot<Message> {
-    private MessageFactoryType messageFactoryType;
+    private MessageFactoryKey messageFactoryKey;
 
     @SuppressWarnings(""unused"")
     public Snapshot() {}
 
-    Snapshot(MessageFactoryType messageFactoryType) {
-      this.messageFactoryType = messageFactoryType;
+    Snapshot(MessageFactoryKey messageFactoryKey) {
+      this.messageFactoryKey = messageFactoryKey;
+    }
+
+    // used in unit tests
+    MessageFactoryKey getMessageFactoryKey() {","[{'comment': 'Can you annotate this method with @VisibleForTesting annotation?', 'commenter': 'igalshilman'}, {'comment': 'Done', 'commenter': 'galenwarren'}]"
152,statefun-flink/statefun-flink-core/src/test/java/org/apache/flink/statefun/flink/core/message/JavaPayloadSerializer.java,"@@ -0,0 +1,50 @@
+package org.apache.flink.statefun.flink.core.message;","[{'comment': 'Missing license header.', 'commenter': 'igalshilman'}, {'comment': 'Fixed', 'commenter': 'galenwarren'}]"
152,statefun-flink/statefun-flink-core/src/main/java/org/apache/flink/statefun/flink/core/message/MessageFactoryKey.java,"@@ -0,0 +1,43 @@
+package org.apache.flink.statefun.flink.core.message;
+
+import java.io.Serializable;
+import java.util.Objects;
+
+public class MessageFactoryKey implements Serializable {","[{'comment': 'Can this be final?', 'commenter': 'igalshilman'}, {'comment': 'Yes, and it will be included in the next push', 'commenter': 'galenwarren'}]"
152,statefun-flink/statefun-flink-core/src/main/java/org/apache/flink/statefun/flink/core/message/MessageFactoryKey.java,"@@ -0,0 +1,43 @@
+package org.apache.flink.statefun.flink.core.message;
+
+import java.io.Serializable;
+import java.util.Objects;
+
+public class MessageFactoryKey implements Serializable {
+  private static final long serialVersionUID = 1L;
+
+  private final MessageFactoryType type;
+  private final String customPayloadSerializerClassName;
+
+  private MessageFactoryKey(MessageFactoryType type, String customPayloadSerializerClassName) {
+    this.type = type;","[{'comment': 'Can this be: `this.type = Objects.requireNonNull(type);`', 'commenter': 'igalshilman'}, {'comment': 'Yes, will be fixed in next push', 'commenter': 'galenwarren'}]"
176,README.zh.md,"@@ -0,0 +1,214 @@
+<img alt=""Stateful Functions"" src=""docs/fig/stateful_functions_logo.png"" width=350px/>
+
+Stateful Functions（简称 StateFun）是一个 [Apache Flink](https://flink.apache.org/) 库， __可简化构建分布式有状态应用程序的过程__ 。它基于可持久化状态的函数，这些函数可以在强一致性保证下进行动态交互。
+
+Stateful Functions 使我们能够将强大的状态管理与像 AWS Lambda 类似的 FaaS 实现和 Kubernetes 等现代资源编排框架的弹性、快速扩缩容和滚动升级功能相结合。通过这些特性，它解决了当今许多 FaaS 解决方案中 [最常被引用的两个缺点](https://www2.eecs.berkeley.edu/Pubs/TechRpts/2019/EECS-2019-3.pdf) ：函数间的状态一致性和高效消息传递。
+
+本文档旨在简要介绍 Stateful Functions 的核心概念以及如何开发一个 Stateful Functions 应用。
+
+更多详细信息，可以参考 [官方文档](https://ci.apache.org/projects/flink/flink-statefun-docs-master) ，相关代码示例，请查看[这里](statefun-examples/)  。
+
+[![构建状态](https://travis-ci.org/apache/flink-statefun.svg?branch=master)](https://travis-ci.org/apache/flink-statefun)
+
+## 目录
+
+- [核心概念](#core-concepts)
+   * [摘要](#abstraction)
+   * [函数模块和可扩展性](#modules)
+   * [Runtime](#runtime)
+- [入门](#getting-started)
+   * [运行一个完整的例子](#greeter)
+   * [创建项目](#project-setup)
+   * [构建项目](#build)
+   * [在 IDE 中运行](#ide-harness)
+- [应用部署](#deploying)
+   * [使用 Docker 映像进行部署](#docker)
+   * [作为 Flink 作业部署](#flink)
+- [参与贡献](#contributing)
+- [开源软件许可](#license)
+
+## <a name=""core-concepts""></a>核心概念
+
+### <a name=""abstraction""></a>摘要
+
+Stateful Functions 应用程序由以下原语组成：有状态函数，入口(ingresses)，路由器(routers)和出口(egresses)。
+
+<p align=""center"">
+  <img src=""docs/fig/stateful_functions_overview.png"" width=""650px""/>
+</p>
+
+#### Stateful Functions
+
+* 一个 _stateful function_ 是通过消息调用的一小段逻辑/代码。每个 stateful function 都是作为 _函数类型_ 的唯一可
+调用 _虚拟实例_ 存在。每个实例都通过其 ``type`` 以及 type 中的唯一 ``ID``（字符串）来寻址。
+
+* Stateful Functions 可以从 ingress 或任何其他的 stateful function（包括其自身）中调用，调用者只需要知道目标函数的逻辑地址即可。
+
+* 函数实例是 _虚拟的_ ，因为它们不总是同时在内存中活跃。在任何一个时间点，只有一小部分函数及其状态作为实际对象存在。
+当一个虚拟实例接收到消息时，将配置一个对象并带着该虚拟实例的状态加载，然后处理该消息。与虚拟内存类似，许多函数的状态可能
+在任何时间点都被“交换出去”(swap out)。
+
+* 函数的每个虚拟实例都有其自己的状态，可以通过局部变量访问，
+并且该状态是私有的，对于该实例来说是本地的。
+
+如果您知道 Apache Flink 的 DataStream API，则可以将 Stateful Functions 考虑为轻量级的
+`KeyedProcessFunction` 。函数 ``类型`` 等同于处理函数转换（process function transformation），而 `` ID `` 则是键值（key）。不同之处
+在于，函数不是在定义数据流（拓扑）的有向无环图（DAG）中组装，
+而是使用地址将事件任意发送到所有其他函数。
+
+#### 入口和出口
+
+* _入口_ （Ingress）是事件最初到达 Stateful Functions 应用程序的方式。
+入口可以是消息队列，日志或 HTTP 服务器 —— 任何可以产生事件并交由应用程序处理的系统。
+
+* _路由器_（Router）将入口（Ingress）与 stateful function 连接起来，以确定哪个函数实例应该在最开始时处理来自 Ingress 的事件。","[{'comment': '```suggestion\r\n* _路由_（Router）将入口（Ingress）与 stateful function 连接起来，以确定哪个函数实例应该在最开始时处理来自入口的事件。\r\n```\r\nRefer to https://cwiki.apache.org/confluence/display/FLINK/Flink+Translation+Specifications', 'commenter': 'carp84'}]"
176,README.zh.md,"@@ -0,0 +1,214 @@
+<img alt=""Stateful Functions"" src=""docs/fig/stateful_functions_logo.png"" width=350px/>
+
+Stateful Functions（简称 StateFun）是一个 [Apache Flink](https://flink.apache.org/) 库， __可简化构建分布式有状态应用程序的过程__ 。它基于可持久化状态的函数，这些函数可以在强一致性保证下进行动态交互。
+
+Stateful Functions 使我们能够将强大的状态管理与像 AWS Lambda 类似的 FaaS 实现和 Kubernetes 等现代资源编排框架的弹性、快速扩缩容和滚动升级功能相结合。通过这些特性，它解决了当今许多 FaaS 解决方案中 [最常被引用的两个缺点](https://www2.eecs.berkeley.edu/Pubs/TechRpts/2019/EECS-2019-3.pdf) ：函数间的状态一致性和高效消息传递。
+
+本文档旨在简要介绍 Stateful Functions 的核心概念以及如何开发一个 Stateful Functions 应用。
+
+更多详细信息，可以参考 [官方文档](https://ci.apache.org/projects/flink/flink-statefun-docs-master) ，相关代码示例，请查看[这里](statefun-examples/)  。
+
+[![构建状态](https://travis-ci.org/apache/flink-statefun.svg?branch=master)](https://travis-ci.org/apache/flink-statefun)
+
+## 目录
+
+- [核心概念](#core-concepts)
+   * [摘要](#abstraction)
+   * [函数模块和可扩展性](#modules)
+   * [Runtime](#runtime)
+- [入门](#getting-started)
+   * [运行一个完整的例子](#greeter)
+   * [创建项目](#project-setup)
+   * [构建项目](#build)
+   * [在 IDE 中运行](#ide-harness)
+- [应用部署](#deploying)
+   * [使用 Docker 映像进行部署](#docker)
+   * [作为 Flink 作业部署](#flink)
+- [参与贡献](#contributing)
+- [开源软件许可](#license)
+
+## <a name=""core-concepts""></a>核心概念
+
+### <a name=""abstraction""></a>摘要
+
+Stateful Functions 应用程序由以下原语组成：有状态函数，入口(ingresses)，路由器(routers)和出口(egresses)。
+
+<p align=""center"">
+  <img src=""docs/fig/stateful_functions_overview.png"" width=""650px""/>
+</p>
+
+#### Stateful Functions
+
+* 一个 _stateful function_ 是通过消息调用的一小段逻辑/代码。每个 stateful function 都是作为 _函数类型_ 的唯一可
+调用 _虚拟实例_ 存在。每个实例都通过其 ``type`` 以及 type 中的唯一 ``ID``（字符串）来寻址。
+
+* Stateful Functions 可以从 ingress 或任何其他的 stateful function（包括其自身）中调用，调用者只需要知道目标函数的逻辑地址即可。
+
+* 函数实例是 _虚拟的_ ，因为它们不总是同时在内存中活跃。在任何一个时间点，只有一小部分函数及其状态作为实际对象存在。
+当一个虚拟实例接收到消息时，将配置一个对象并带着该虚拟实例的状态加载，然后处理该消息。与虚拟内存类似，许多函数的状态可能
+在任何时间点都被“交换出去”(swap out)。
+
+* 函数的每个虚拟实例都有其自己的状态，可以通过局部变量访问，
+并且该状态是私有的，对于该实例来说是本地的。
+
+如果您知道 Apache Flink 的 DataStream API，则可以将 Stateful Functions 考虑为轻量级的
+`KeyedProcessFunction` 。函数 ``类型`` 等同于处理函数转换（process function transformation），而 `` ID `` 则是键值（key）。不同之处
+在于，函数不是在定义数据流（拓扑）的有向无环图（DAG）中组装，
+而是使用地址将事件任意发送到所有其他函数。
+
+#### 入口和出口
+
+* _入口_ （Ingress）是事件最初到达 Stateful Functions 应用程序的方式。
+入口可以是消息队列，日志或 HTTP 服务器 —— 任何可以产生事件并交由应用程序处理的系统。
+
+* _路由器_（Router）将入口（Ingress）与 stateful function 连接起来，以确定哪个函数实例应该在最开始时处理来自 Ingress 的事件。
+
+* _出口_（Egress）是一种以标准化方式从应用程序发送事件的方法。
+出口是可选的，也有可能没有事件需要从应用程序中发送出去，函数会完成事件的处理或直接调用其他应用程序。
+
+### <a name=""modules""></a>模块(Module)
+
+_模块_（Module）是将核心构建单元添加到一个 Stateful Functions 应用程序的入口，这些核心构建单元包括：入口（Ingress）、出口（Egress）、路由器（Router）和有状态函数。","[{'comment': '```suggestion\r\n_模块_（Module）是将核心构建单元添加到一个 Stateful Functions 应用程序的入口，这些核心构建单元包括：入口（Ingress）、出口（Egress）、路由（Router）和有状态函数。\r\n```', 'commenter': 'carp84'}]"
176,README.zh.md,"@@ -0,0 +1,214 @@
+<img alt=""Stateful Functions"" src=""docs/fig/stateful_functions_logo.png"" width=350px/>
+
+Stateful Functions（简称 StateFun）是一个 [Apache Flink](https://flink.apache.org/) 库， __可简化构建分布式有状态应用程序的过程__ 。它基于可持久化状态的函数，这些函数可以在强一致性保证下进行动态交互。
+
+Stateful Functions 使我们能够将强大的状态管理与像 AWS Lambda 类似的 FaaS 实现和 Kubernetes 等现代资源编排框架的弹性、快速扩缩容和滚动升级功能相结合。通过这些特性，它解决了当今许多 FaaS 解决方案中 [最常被引用的两个缺点](https://www2.eecs.berkeley.edu/Pubs/TechRpts/2019/EECS-2019-3.pdf) ：函数间的状态一致性和高效消息传递。
+
+本文档旨在简要介绍 Stateful Functions 的核心概念以及如何开发一个 Stateful Functions 应用。
+
+更多详细信息，可以参考 [官方文档](https://ci.apache.org/projects/flink/flink-statefun-docs-master) ，相关代码示例，请查看[这里](statefun-examples/)  。
+
+[![构建状态](https://travis-ci.org/apache/flink-statefun.svg?branch=master)](https://travis-ci.org/apache/flink-statefun)
+
+## 目录
+
+- [核心概念](#core-concepts)
+   * [摘要](#abstraction)
+   * [函数模块和可扩展性](#modules)
+   * [Runtime](#runtime)
+- [入门](#getting-started)
+   * [运行一个完整的例子](#greeter)
+   * [创建项目](#project-setup)
+   * [构建项目](#build)
+   * [在 IDE 中运行](#ide-harness)
+- [应用部署](#deploying)
+   * [使用 Docker 映像进行部署](#docker)
+   * [作为 Flink 作业部署](#flink)
+- [参与贡献](#contributing)
+- [开源软件许可](#license)
+
+## <a name=""core-concepts""></a>核心概念
+
+### <a name=""abstraction""></a>摘要
+
+Stateful Functions 应用程序由以下原语组成：有状态函数，入口(ingresses)，路由器(routers)和出口(egresses)。
+
+<p align=""center"">
+  <img src=""docs/fig/stateful_functions_overview.png"" width=""650px""/>
+</p>
+
+#### Stateful Functions
+
+* 一个 _stateful function_ 是通过消息调用的一小段逻辑/代码。每个 stateful function 都是作为 _函数类型_ 的唯一可
+调用 _虚拟实例_ 存在。每个实例都通过其 ``type`` 以及 type 中的唯一 ``ID``（字符串）来寻址。
+
+* Stateful Functions 可以从 ingress 或任何其他的 stateful function（包括其自身）中调用，调用者只需要知道目标函数的逻辑地址即可。
+
+* 函数实例是 _虚拟的_ ，因为它们不总是同时在内存中活跃。在任何一个时间点，只有一小部分函数及其状态作为实际对象存在。
+当一个虚拟实例接收到消息时，将配置一个对象并带着该虚拟实例的状态加载，然后处理该消息。与虚拟内存类似，许多函数的状态可能
+在任何时间点都被“交换出去”(swap out)。
+
+* 函数的每个虚拟实例都有其自己的状态，可以通过局部变量访问，
+并且该状态是私有的，对于该实例来说是本地的。
+
+如果您知道 Apache Flink 的 DataStream API，则可以将 Stateful Functions 考虑为轻量级的
+`KeyedProcessFunction` 。函数 ``类型`` 等同于处理函数转换（process function transformation），而 `` ID `` 则是键值（key）。不同之处
+在于，函数不是在定义数据流（拓扑）的有向无环图（DAG）中组装，
+而是使用地址将事件任意发送到所有其他函数。
+
+#### 入口和出口
+
+* _入口_ （Ingress）是事件最初到达 Stateful Functions 应用程序的方式。
+入口可以是消息队列，日志或 HTTP 服务器 —— 任何可以产生事件并交由应用程序处理的系统。
+
+* _路由器_（Router）将入口（Ingress）与 stateful function 连接起来，以确定哪个函数实例应该在最开始时处理来自 Ingress 的事件。
+
+* _出口_（Egress）是一种以标准化方式从应用程序发送事件的方法。
+出口是可选的，也有可能没有事件需要从应用程序中发送出去，函数会完成事件的处理或直接调用其他应用程序。
+
+### <a name=""modules""></a>模块(Module)
+
+_模块_（Module）是将核心构建单元添加到一个 Stateful Functions 应用程序的入口，这些核心构建单元包括：入口（Ingress）、出口（Egress）、路由器（Router）和有状态函数。
+
+单个应用程序可以是多个模块（Module）的组合，每个模块都构成了整个应用程序的一部分。
+这允许一个 Stateful Functions 应用程序的不同部分由不同的模块来组成，例如：
+一个模块可以提供入口和出口，而其他模块可以通过状态函数来独立提供业务逻辑的不同部分。这有助于多个独立团队共同完成较大（复杂）的应用程序。
+
+## <a name=""runtime"">Runtime
+
+Stateful Functions Runtime 旨在提供一组类似于 [无服务器函数](https://martinfowler.com/articles/serverless.html) 的属性，但适用于有状态的场景。
+
+<p align=""center"">
+  <img src=""docs/fig/stateful_functions_overview-ops.png"" width=""600px""/>
+</p>
+
+Runtime 基于 Apache Flink<sup>®</sup> 构建，并具有以下设计原则：
+
+*  __逻辑上计算/状态共置__：消息传递，状态访问/更新和函数调用在一起紧密管理，这在抽象层面就天然地保证了一致性。","[{'comment': '```suggestion\r\n* __逻辑上计算/状态共置__：消息传递，状态访问/更新和函数调用在一起紧密管理，这在抽象层面就天然地保证了一致性。\r\n```', 'commenter': 'carp84'}]"
176,README.zh.md,"@@ -0,0 +1,214 @@
+<img alt=""Stateful Functions"" src=""docs/fig/stateful_functions_logo.png"" width=350px/>
+
+Stateful Functions（简称 StateFun）是一个 [Apache Flink](https://flink.apache.org/) 库， __可简化构建分布式有状态应用程序的过程__ 。它基于可持久化状态的函数，这些函数可以在强一致性保证下进行动态交互。
+
+Stateful Functions 使我们能够将强大的状态管理与像 AWS Lambda 类似的 FaaS 实现和 Kubernetes 等现代资源编排框架的弹性、快速扩缩容和滚动升级功能相结合。通过这些特性，它解决了当今许多 FaaS 解决方案中 [最常被引用的两个缺点](https://www2.eecs.berkeley.edu/Pubs/TechRpts/2019/EECS-2019-3.pdf) ：函数间的状态一致性和高效消息传递。
+
+本文档旨在简要介绍 Stateful Functions 的核心概念以及如何开发一个 Stateful Functions 应用。
+
+更多详细信息，可以参考 [官方文档](https://ci.apache.org/projects/flink/flink-statefun-docs-master) ，相关代码示例，请查看[这里](statefun-examples/)  。
+
+[![构建状态](https://travis-ci.org/apache/flink-statefun.svg?branch=master)](https://travis-ci.org/apache/flink-statefun)
+
+## 目录
+
+- [核心概念](#core-concepts)
+   * [摘要](#abstraction)
+   * [函数模块和可扩展性](#modules)
+   * [Runtime](#runtime)
+- [入门](#getting-started)
+   * [运行一个完整的例子](#greeter)
+   * [创建项目](#project-setup)
+   * [构建项目](#build)
+   * [在 IDE 中运行](#ide-harness)
+- [应用部署](#deploying)
+   * [使用 Docker 映像进行部署](#docker)
+   * [作为 Flink 作业部署](#flink)
+- [参与贡献](#contributing)
+- [开源软件许可](#license)
+
+## <a name=""core-concepts""></a>核心概念
+
+### <a name=""abstraction""></a>摘要
+
+Stateful Functions 应用程序由以下原语组成：有状态函数，入口(ingresses)，路由器(routers)和出口(egresses)。","[{'comment': '```suggestion\r\nStateful Functions 应用程序由以下原语组成：有状态函数，入口(ingresses)，路由(routers)和出口(egresses)。\r\n```\r\nRefer to https://cwiki.apache.org/confluence/display/FLINK/Flink+Translation+Specifications', 'commenter': 'carp84'}]"
176,README.zh.md,"@@ -0,0 +1,214 @@
+<img alt=""Stateful Functions"" src=""docs/fig/stateful_functions_logo.png"" width=350px/>
+
+Stateful Functions（简称 StateFun）是一个 [Apache Flink](https://flink.apache.org/) 库， __可简化构建分布式有状态应用程序的过程__ 。它基于可持久化状态的函数，这些函数可以在强一致性保证下进行动态交互。
+
+Stateful Functions 使我们能够将强大的状态管理与像 AWS Lambda 类似的 FaaS 实现和 Kubernetes 等现代资源编排框架的弹性、快速扩缩容和滚动升级功能相结合。通过这些特性，它解决了当今许多 FaaS 解决方案中 [最常被引用的两个缺点](https://www2.eecs.berkeley.edu/Pubs/TechRpts/2019/EECS-2019-3.pdf) ：函数间的状态一致性和高效消息传递。
+
+本文档旨在简要介绍 Stateful Functions 的核心概念以及如何开发一个 Stateful Functions 应用。
+
+更多详细信息，可以参考 [官方文档](https://ci.apache.org/projects/flink/flink-statefun-docs-master) ，相关代码示例，请查看[这里](statefun-examples/)  。
+
+[![构建状态](https://travis-ci.org/apache/flink-statefun.svg?branch=master)](https://travis-ci.org/apache/flink-statefun)
+
+## 目录
+
+- [核心概念](#core-concepts)
+   * [摘要](#abstraction)
+   * [函数模块和可扩展性](#modules)
+   * [Runtime](#runtime)
+- [入门](#getting-started)
+   * [运行一个完整的例子](#greeter)
+   * [创建项目](#project-setup)
+   * [构建项目](#build)
+   * [在 IDE 中运行](#ide-harness)
+- [应用部署](#deploying)
+   * [使用 Docker 映像进行部署](#docker)
+   * [作为 Flink 作业部署](#flink)
+- [参与贡献](#contributing)
+- [开源软件许可](#license)
+
+## <a name=""core-concepts""></a>核心概念
+
+### <a name=""abstraction""></a>摘要
+
+Stateful Functions 应用程序由以下原语组成：有状态函数，入口（ingresses），路由（routers）和出口（egresses）。
+
+<p align=""center"">
+  <img src=""docs/fig/stateful_functions_overview.png"" width=""650px""/>
+</p>
+
+#### Stateful Functions
+
+* 一个 _stateful function_ 是通过消息调用的一小段逻辑/代码。每个 stateful function 都是作为 _函数类型_ 的唯一可
+调用 _虚拟实例_ 存在。每个实例都通过其 ``type`` 以及 type 中的唯一 ``ID``（字符串）来寻址。
+
+* Stateful Functions 可以从 ingress 或任何其他的 stateful function（包括其自身）中调用，调用者只需要知道目标函数的逻辑地址即可。
+
+* 函数实例是 _虚拟的_ ，因为它们不总是同时在内存中活跃。在任何一个时间点，只有一小部分函数及其状态作为实际对象存在。
+当一个虚拟实例接收到消息时，将配置一个对象并带着该虚拟实例的状态加载，然后处理该消息。与虚拟内存类似，许多函数的状态可能
+在任何时间点都被“交换出去”（swap out）。
+
+* 函数的每个虚拟实例都有其自己的状态，可以通过局部变量访问，
+并且该状态是私有的，对于该实例来说是本地的。
+
+如果您知道 Apache Flink 的 DataStream API，则可以将 Stateful Functions 考虑为轻量级的
+`KeyedProcessFunction` 。函数 ``类型`` 等同于处理函数转换（process function transformation），而 `` ID `` 则是键值（key）。不同之处
+在于，函数不是在定义数据流（拓扑）的有向无环图（DAG）中组装，","[{'comment': 'nit: 中文来说，不建议这一行（`在于，函数不是在定义数据流（拓扑）的有向无环图（DAG）中组装`）和上一行分开。因为他们是连着的一句话，但是渲染之后这里会有空格，看上去会比较奇怪。\r\n\r\n其他地方也类似', 'commenter': 'klion26'}]"
176,README.zh.md,"@@ -0,0 +1,214 @@
+<img alt=""Stateful Functions"" src=""docs/fig/stateful_functions_logo.png"" width=350px/>
+
+Stateful Functions（简称 StateFun）是一个 [Apache Flink](https://flink.apache.org/) 库， __可简化构建分布式有状态应用程序的过程__ 。它基于可持久化状态的函数，这些函数可以在强一致性保证下进行动态交互。
+
+Stateful Functions 使我们能够将强大的状态管理与像 AWS Lambda 类似的 FaaS 实现和 Kubernetes 等现代资源编排框架的弹性、快速扩缩容和滚动升级功能相结合。通过这些特性，它解决了当今许多 FaaS 解决方案中 [最常被引用的两个缺点](https://www2.eecs.berkeley.edu/Pubs/TechRpts/2019/EECS-2019-3.pdf) ：函数间的状态一致性和高效消息传递。
+
+本文档旨在简要介绍 Stateful Functions 的核心概念以及如何开发一个 Stateful Functions 应用。
+
+更多详细信息，可以参考 [官方文档](https://ci.apache.org/projects/flink/flink-statefun-docs-master) ，相关代码示例，请查看[这里](statefun-examples/)  。
+
+[![构建状态](https://travis-ci.org/apache/flink-statefun.svg?branch=master)](https://travis-ci.org/apache/flink-statefun)
+
+## 目录
+
+- [核心概念](#core-concepts)
+   * [摘要](#abstraction)
+   * [函数模块和可扩展性](#modules)
+   * [Runtime](#runtime)
+- [入门](#getting-started)
+   * [运行一个完整的例子](#greeter)
+   * [创建项目](#project-setup)
+   * [构建项目](#build)
+   * [在 IDE 中运行](#ide-harness)
+- [应用部署](#deploying)
+   * [使用 Docker 映像进行部署](#docker)
+   * [作为 Flink 作业部署](#flink)
+- [参与贡献](#contributing)
+- [开源软件许可](#license)
+
+## <a name=""core-concepts""></a>核心概念
+
+### <a name=""abstraction""></a>摘要
+
+Stateful Functions 应用程序由以下原语组成：有状态函数，入口（ingresses），路由（routers）和出口（egresses）。
+
+<p align=""center"">
+  <img src=""docs/fig/stateful_functions_overview.png"" width=""650px""/>
+</p>
+
+#### Stateful Functions
+
+* 一个 _stateful function_ 是通过消息调用的一小段逻辑/代码。每个 stateful function 都是作为 _函数类型_ 的唯一可
+调用 _虚拟实例_ 存在。每个实例都通过其 ``type`` 以及 type 中的唯一 ``ID``（字符串）来寻址。
+
+* Stateful Functions 可以从 ingress 或任何其他的 stateful function（包括其自身）中调用，调用者只需要知道目标函数的逻辑地址即可。","[{'comment': 'ingress 这里是不是也翻译比较好呢？', 'commenter': 'klion26'}]"
211,docs/content/docs/sdk/java.md,"@@ -29,451 +29,395 @@ under the License.
 Stateful functions are the building blocks of applications; they are atomic units of isolation, distribution, and persistence.
 As objects, they encapsulate the state of a single entity (e.g., a specific user, device, or session) and encode its behavior.
 Stateful functions can interact with each other, and external systems, through message passing.
-The Java SDK is supported as an [embedded module]({{< ref ""docs/sdk/overview#embedded-module"" >}}).
 
 To get started, add the Java SDK as a dependency to your application.
 
-{{< artifact statefun-sdk >}}
+{{< artifact statefun-sdk-java >}}
 
 ## Defining A Stateful Function
 
-A stateful function is any class that implements the ``StatefulFunction`` interface.
-The following is an example of a simple hello world function.
+A stateful function is any class that implements the `StatefulFunction` interface.
+In the following example, a `StatefulFunction` maintains a count for every user
+of an application, emitting a customized greeting.
 
 ```java
-package org.apache.flink.statefun.docs;
-
-import org.apache.flink.statefun.sdk.Context;
-import org.apache.flink.statefun.sdk.StatefulFunction;
-
-public class FnHelloWorld implements StatefulFunction {
+import java.util.concurrent.CompletableFuture;
+import org.apache.flink.statefun.sdk.java.Context;
+import org.apache.flink.statefun.sdk.java.StatefulFunction;
+import org.apache.flink.statefun.sdk.java.TypeName;
+import org.apache.flink.statefun.sdk.java.ValueSpec;
+import org.apache.flink.statefun.sdk.java.message.Message;
 
-	@Override
-	public void invoke(Context context, Object input) {
-		System.out.println(""Hello "" + input.toString());
-	}
-}
-```
+public class GreeterFn implements StatefulFunction {
 
-Functions process each incoming message through their ``invoke`` method.
-Input's are untyped and passed through the system as a ``java.lang.Object`` so one function can potentially process multiple types of messages.
+    static final TypeName TYPE = TypeName.forNameFromString(""com.example.fns/greeter"");","[{'comment': 'forNameFromString  => typeNameFromString', 'commenter': 'afedulov'}]"
211,docs/content/docs/sdk/java.md,"@@ -29,451 +29,395 @@ under the License.
 Stateful functions are the building blocks of applications; they are atomic units of isolation, distribution, and persistence.
 As objects, they encapsulate the state of a single entity (e.g., a specific user, device, or session) and encode its behavior.
 Stateful functions can interact with each other, and external systems, through message passing.
-The Java SDK is supported as an [embedded module]({{< ref ""docs/sdk/overview#embedded-module"" >}}).
 
 To get started, add the Java SDK as a dependency to your application.
 
-{{< artifact statefun-sdk >}}
+{{< artifact statefun-sdk-java >}}
 
 ## Defining A Stateful Function
 
-A stateful function is any class that implements the ``StatefulFunction`` interface.
-The following is an example of a simple hello world function.
+A stateful function is any class that implements the `StatefulFunction` interface.
+In the following example, a `StatefulFunction` maintains a count for every user
+of an application, emitting a customized greeting.
 
 ```java
-package org.apache.flink.statefun.docs;
-
-import org.apache.flink.statefun.sdk.Context;
-import org.apache.flink.statefun.sdk.StatefulFunction;
-
-public class FnHelloWorld implements StatefulFunction {
+import java.util.concurrent.CompletableFuture;
+import org.apache.flink.statefun.sdk.java.Context;
+import org.apache.flink.statefun.sdk.java.StatefulFunction;
+import org.apache.flink.statefun.sdk.java.TypeName;
+import org.apache.flink.statefun.sdk.java.ValueSpec;
+import org.apache.flink.statefun.sdk.java.message.Message;
 
-	@Override
-	public void invoke(Context context, Object input) {
-		System.out.println(""Hello "" + input.toString());
-	}
-}
-```
+public class GreeterFn implements StatefulFunction {
 
-Functions process each incoming message through their ``invoke`` method.
-Input's are untyped and passed through the system as a ``java.lang.Object`` so one function can potentially process multiple types of messages.
+    static final TypeName TYPE = TypeName.forNameFromString(""com.example.fns/greeter"");
 
-The ``Context`` provides metadata about the current message and function, and is how you can call other functions or external systems.
-Functions are invoked based on a function type and unique identifier.
+    static final TypeName INBOX = TypeName.forNameFromString(""com.example.fns/inbox"");","[{'comment': 'forNameFromString  => typeNameFromString', 'commenter': 'afedulov'}]"
211,docs/content/docs/sdk/java.md,"@@ -29,451 +29,395 @@ under the License.
 Stateful functions are the building blocks of applications; they are atomic units of isolation, distribution, and persistence.
 As objects, they encapsulate the state of a single entity (e.g., a specific user, device, or session) and encode its behavior.
 Stateful functions can interact with each other, and external systems, through message passing.
-The Java SDK is supported as an [embedded module]({{< ref ""docs/sdk/overview#embedded-module"" >}}).
 
 To get started, add the Java SDK as a dependency to your application.
 
-{{< artifact statefun-sdk >}}
+{{< artifact statefun-sdk-java >}}
 
 ## Defining A Stateful Function
 
-A stateful function is any class that implements the ``StatefulFunction`` interface.
-The following is an example of a simple hello world function.
+A stateful function is any class that implements the `StatefulFunction` interface.
+In the following example, a `StatefulFunction` maintains a count for every user
+of an application, emitting a customized greeting.
 
 ```java
-package org.apache.flink.statefun.docs;
-
-import org.apache.flink.statefun.sdk.Context;
-import org.apache.flink.statefun.sdk.StatefulFunction;
-
-public class FnHelloWorld implements StatefulFunction {
+import java.util.concurrent.CompletableFuture;
+import org.apache.flink.statefun.sdk.java.Context;
+import org.apache.flink.statefun.sdk.java.StatefulFunction;
+import org.apache.flink.statefun.sdk.java.TypeName;
+import org.apache.flink.statefun.sdk.java.ValueSpec;
+import org.apache.flink.statefun.sdk.java.message.Message;
 
-	@Override
-	public void invoke(Context context, Object input) {
-		System.out.println(""Hello "" + input.toString());
-	}
-}
-```
+public class GreeterFn implements StatefulFunction {
 
-Functions process each incoming message through their ``invoke`` method.
-Input's are untyped and passed through the system as a ``java.lang.Object`` so one function can potentially process multiple types of messages.
+    static final TypeName TYPE = TypeName.forNameFromString(""com.example.fns/greeter"");
 
-The ``Context`` provides metadata about the current message and function, and is how you can call other functions or external systems.
-Functions are invoked based on a function type and unique identifier.
+    static final TypeName INBOX = TypeName.forNameFromString(""com.example.fns/inbox"");
 
-### Stateful Match Function 
+    static final ValueSpec<Integer> SEEN = ValueSpec.named(""seen"").withIntType();
 
-Stateful functions provide a powerful abstraction for working with events and state, allowing developers to build components that can react to any kind of message.
-Commonly, functions only need to handle a known set of message types, and the ``StatefulMatchFunction`` interface provides an opinionated solution to that problem.
+    @Override 
+    CompletableFuture<Void> apply(Context context, Message message) {
+        if (!message.is(User.TYPE)) {
+            throw new IllegalStateException(""Unknown type"");
+        }
 
-#### Simple Match Function
+        User user = message.as(User.TYPE);
+        String name = user.getName();
 
-Stateful match functions are an opinionated variant of stateful functions for precisely this pattern.
-Developers outline expected types, optional predicates, and well-typed business logic and let the system dispatch each input to the correct action.
-Variants are bound inside a ``configure`` method that is executed once the first time an instance is loaded.
+        var storage = context.storage();
+        var seen = storage.get(SEEN).orElse(0);
+        storage.set(SEEN, seen + 1);
 
-```java
-package org.apache.flink.statefun.docs.match;
+        context.send(
+            MessageBuilder.forAddress(INBOX, name)
+                .withValue(""Hello "" + name + "" for the "" + seen + ""th time!"")
+                .build());
 
-import org.apache.flink.statefun.sdk.Context;
-import org.apache.flink.statefun.sdk.match.MatchBinder;
-import org.apache.flink.statefun.sdk.match.StatefulMatchFunction;
+        return context.done();
+    }
+}
+```
 
-public class FnMatchGreeter extends StatefulMatchFunction {
+This code declares a greeter function that will be [registered](#exposing-functions) under the logical type name `com.example.fns/greeter`. Type names must take the form `<namesapce>/<name>`.
+It contains a single `ValueSpec`, which is implicitly scoped to the current address and stores an integer.
 
-	@Override
-	public void configure(MatchBinder binder) {
-		binder
-			.predicate(Customer.class, this::greetCustomer)
-			.predicate(Employee.class, Employee::isManager, this::greetManager)
-			.predicate(Employee.class, this::greetEmployee);
-	}
+Every time a message is sent a greeter, it first validates the message containing a `User` and extracts its name. Both messages and state are strongly typed - either one of the default [built-in types]({{< ref ""docs/sdk/appendix#types"" >}}) - or a [custom type](#types) as in this case.
 
-	private void greetCustomer(Context context, Customer message) {
-		System.out.println(""Hello customer "" + message.getName());
-	}
+The function finally builds a custom greeting for the user.
+The number of times that particular user has been seen so far is queried from the state store and updated
+and the greeting is sent to the users' inbox (another function type). 
 
-	private void greetEmployee(Context context, Employee message) {
-		System.out.println(""Hello employee "" + message.getEmployeeId());
-	}
+## Types
 
-	private void greetManager(Context context, Employee message) {
-		System.out.println(""Hello manager "" + message.getEmployeeId());
-	}
-}
-```
+Stateful Functions strongly types ll messages and state values. 
+Because they run in a distributed manner and state values are persisted to stable storage, Stateful Functions aims to provide efficient and easy to user serializers. 
 
-#### Making Your Function Complete
+Out of the box, all SDKs offer a set of highly optimized serializers for common primitive types; boolean, numerics, and strings.
+Additionally, users are encouraged to plug-in custom types to model more complex data structures. 
 
-Similar to the first example, match functions are partial by default and will throw an ``IllegalStateException`` on any input that does not match any branch.
-They can be made complete by providing an ``otherwise`` clause that serves as a catch-all for unmatched input, think of it as a default clause in a Java switch statement.
-The ``otherwise`` action takes its message as an untyped ``java.lang.Object``, allowing you to handle any unexpected messages.
+In the [example above](#defining-a-stateful-function), the greeter function consumes `User` messages, a POJO type containing several fields.
+By defining a custom type, this object can be passed transparently between functions and stored in state.
+And because the type is tied to a logical typename, instead of the physical Java class, it can be passed to functions written in other langauge SDKs. 
 
 ```java
-package org.apache.flink.statefun.docs.match;
-
-import org.apache.flink.statefun.sdk.Context;
-import org.apache.flink.statefun.sdk.match.MatchBinder;
-import org.apache.flink.statefun.sdk.match.StatefulMatchFunction;
-
-public class FnMatchGreeterWithCatchAll extends StatefulMatchFunction {
-
-	@Override
-	public void configure(MatchBinder binder) {
-		binder
-			.predicate(Customer.class, this::greetCustomer)
-			.predicate(Employee.class, Employee::isManager, this::greetManager)
-			.predicate(Employee.class, this::greetEmployee)
-			.otherwise(this::catchAll);
-	}
-
-	private void greetCustomer(Context context, Customer message) {
-		System.out.println(""Hello customer "" + message.getName());
-	}
-
-	private void greetEmployee(Context context, Employee message) {
-		System.out.println(""Hello employee "" + message.getEmployeeId());
-	}
-
-	private void greetManager(Context context, Employee message) {
-		System.out.println(""Hello manager "" + message.getEmployeeId());
-	}
-
-	private void catchAll(Context context, Object message) {
-		System.out.println(""Hello unexpected message"");
-	}
-}
-```
+import com.fasterxml.jackson.annotation.JsonCreator;
+import com.fasterxml.jackson.annotation.JsonProperty;
+import com.fasterxml.jackson.databind.ObjectMapper;
+import org.apache.flink.statefun.sdk.java.TypeName;
+import org.apache.flink.statefun.sdk.java.types.SimpleType;
+import org.apache.flink.statefun.sdk.java.types.Type;
+import java.util.Objects;
 
-#### Action Resolution Order
+public class User {
 
-Match functions will always match actions from most to least specific using the following resolution rules.
+    private static final ObjectMapper mapper = new ObjectMapper();
 
-First, find an action that matches the type and predicate. If two predicates will return true for a particular input, the one registered in the binder first wins.
-Next, search for an action that matches the type but does not have an associated predicate.
-Finally, if a catch-all exists, it will be executed or an ``IllegalStateException`` will be thrown.
+    public static final Type<User> TYPE = SimpleType.simpleImmutableTypeFrom(
+        TypeName.typeNameFromString(""com.example/User""),
+        mapper:writeValueAsBytes,
+        bytes -> mapper.readValue(byes, User.class));
 
-## Function Types and Messaging
+    private final String name;
 
-In Java, function types are defined as logical pointers composed of a namespace and name.
-The type is bound to the implementing class in the [module]({{< ref ""docs/sdk/overview#embedded-module"" >}}) definition.
-Below is an example function type for the hello world function.
+    private final String favoriteColor;
 
-```java
-package org.apache.flink.statefun.docs;
+    @JsonCreator
+    public User(
+        @JsonProperty(""name"") String name,
+        @JsonProperty(""favorite_color"" String favoriteColor)) {
 
-import org.apache.flink.statefun.sdk.FunctionType;
+        this.name = Objects.requireNonNull(name);
+        this.favoriteColor = Objects.requireNonNull(favoriteColor);
+    }
 
-/** A function type that will be bound to {@link FnHelloWorld}. */
-public class Identifiers {
+    public String getName() {
+        return name;
+    }
 
-  public static final FunctionType HELLO_TYPE = new FunctionType(""apache/flink"", ""hello"");
-}
+    public String getFavoriteColor() {
+        return favoriteColor;
+    }
+
+    @Override
+    public String toString() {
+        return ""User{name="" name + "",favoriteColor="" favoriteColor + ""}""
+    }
 ```
 
-This type can then be referenced from other functions to create an address and message a particular instance.
+## State
 
-```java
-package org.apache.flink.statefun.docs;
+Stateful Functions treats state as a first class citizen and so all functions can easily define state that is automatically made fault tolerant by the runtime.
+State declaration is as simple as defining one or more `ValueSpec`'s describing your state values.
+Value specifications are defined with a unique (to the function) name and [type](#types).
+At runtime, functions can `get`, `set`, and `remove` state values scoped to the address of the current message.
 
-import org.apache.flink.statefun.sdk.Context;
-import org.apache.flink.statefun.sdk.StatefulFunction;
-
-/** A simple stateful function that sends a message to the user with id ""user1"" */
-public class FnCaller implements StatefulFunction {
+{{< hint info >}}
+All value specificiations must be earerly registered in the `StatefulFuctionSpec` when composing
+the applications [RequestReplyHandler](#exposing-functions).
+{{< /hint >}}
 
-  @Override
-  public void invoke(Context context, Object input) {
-    context.send(Identifiers.HELLO_TYPE, ""user1"", new MyUserMessage());
-  }
-}
+```java
+// Value specification for a state named `seen` 
+// with the primitive integer type
+ValueSpec
+    .named(""seen"")
+    .withIntType();
+
+// Value specification with a custom type
+ValueSpec
+    .name(""user"")
+    .withCustomType(User.TYPE);
 ```
 
-## Sending Delayed Messages
+### State Expiration
 
-Functions are able to send messages on a delay so that they will arrive after some duration.
-Functions may even send themselves delayed messages that can serve as a callback.
-The delayed message is non-blocking so functions will continue to process records between the time a delayed message is sent and received.
+By default, state values are persisted until manually `remove`d by the user.
+Optionally, they may be configured to expire and be automatically deleted after a specified duration.
 
 ```java
-package org.apache.flink.statefun.docs.delay;
-
-import java.time.Duration;
-import org.apache.flink.statefun.sdk.Context;
-import org.apache.flink.statefun.sdk.StatefulFunction;
-
-public class FnDelayedMessage implements StatefulFunction {
-
-	@Override
-	public void invoke(Context context, Object input) {
-		if (input instanceof Message) {
-			System.out.println(""Hello"");
-			context.sendAfter(Duration.ofMinutes(1), context.self(), new DelayedMessage());
-		}
-
-		if (input instanceof DelayedMessage) {
-			System.out.println(""Welcome to the future!"");
-		}
-	}
-}
+// Value specification that will automatically
+// delete the value if the function instance goes 
+// more than 30 minutes without being called
+ValueSpec
+    .named(""seen"")
+    .thatExpiresAfterCall(Duration.ofDays(1))
+    .withIntType();
+
+// Value specification that will automatically
+// delete the value if it goes more than 1 day
+// without being written
+ValueSpec
+    .named(""seen"")
+    .thatExpireAfterWrite(Duration.ofDays(1))
+    .withIntType();
 ```
 
-## Completing Async Requests
-
-When interacting with external systems, such as a database or API, one needs to take care that communication delay with the external system does not dominate the application’s total work.
-Stateful Functions allows registering a Java ``CompletableFuture`` that will resolve to a value at some point in the future.
-Future's are registered along with a metadata object that provides additional context about the caller.
+## Sending Delayed Messages
 
-When the future completes, either successfully or exceptionally, the caller function type and id will be invoked with a ``AsyncOperationResult``.
-An asynchronous result can complete in one of three states:
+Functions can send messages on a delay so that they will arrive after some duration.
+They may even send themselves delayed messages that can serve as a callback.
+The delayed message is non-blocking, so functions will continue to process records between when a delayed message is sent and received.
+Additionally, they are fault-tolerant and never lost, even when recovering from failure. 
 
-### Success
+This example sends a response back to the calling function after a 30 minute delay.
 
-The asynchronous operation has succeeded, and the produced result can be obtained via ``AsyncOperationResult#value``.
+```java
+import java.util.concurrent.CompletableFuture;
+import java.time.Duration;
 
-### Failure
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import org.apache.flink.statefun.sdk.java.Context;
+import org.apache.flink.statefun.sdk.java.StatefulFunction;
+import org.apache.flink.statefun.sdk.java.message.Message;
 
-The asynchronous operation has failed, and the cause can be obtained via ``AsyncOperationResult#throwable``.
+public class DelayedFn implements StatefulFunction {
 
-### Unknown
+    private static final Logger LOG = LoggerFactory.getLogger(DelayedFn.class);
 
-The stateful function was restarted, possibly on a different machine, before the ``CompletableFuture`` was completed, therefore it is unknown what is the status of the asynchronous operation.
+    static final TypeName TYPE = TypeName.forNameFromString(""com.example.fns/delayed"");","[{'comment': 'forNameFromString  => typeNameFromString', 'commenter': 'afedulov'}]"
211,docs/content/docs/sdk/java.md,"@@ -29,451 +29,395 @@ under the License.
 Stateful functions are the building blocks of applications; they are atomic units of isolation, distribution, and persistence.
 As objects, they encapsulate the state of a single entity (e.g., a specific user, device, or session) and encode its behavior.
 Stateful functions can interact with each other, and external systems, through message passing.
-The Java SDK is supported as an [embedded module]({{< ref ""docs/sdk/overview#embedded-module"" >}}).
 
 To get started, add the Java SDK as a dependency to your application.
 
-{{< artifact statefun-sdk >}}
+{{< artifact statefun-sdk-java >}}
 
 ## Defining A Stateful Function
 
-A stateful function is any class that implements the ``StatefulFunction`` interface.
-The following is an example of a simple hello world function.
+A stateful function is any class that implements the `StatefulFunction` interface.
+In the following example, a `StatefulFunction` maintains a count for every user
+of an application, emitting a customized greeting.
 
 ```java
-package org.apache.flink.statefun.docs;
-
-import org.apache.flink.statefun.sdk.Context;
-import org.apache.flink.statefun.sdk.StatefulFunction;
-
-public class FnHelloWorld implements StatefulFunction {
+import java.util.concurrent.CompletableFuture;
+import org.apache.flink.statefun.sdk.java.Context;
+import org.apache.flink.statefun.sdk.java.StatefulFunction;
+import org.apache.flink.statefun.sdk.java.TypeName;
+import org.apache.flink.statefun.sdk.java.ValueSpec;
+import org.apache.flink.statefun.sdk.java.message.Message;
 
-	@Override
-	public void invoke(Context context, Object input) {
-		System.out.println(""Hello "" + input.toString());
-	}
-}
-```
+public class GreeterFn implements StatefulFunction {
 
-Functions process each incoming message through their ``invoke`` method.
-Input's are untyped and passed through the system as a ``java.lang.Object`` so one function can potentially process multiple types of messages.
+    static final TypeName TYPE = TypeName.forNameFromString(""com.example.fns/greeter"");
 
-The ``Context`` provides metadata about the current message and function, and is how you can call other functions or external systems.
-Functions are invoked based on a function type and unique identifier.
+    static final TypeName INBOX = TypeName.forNameFromString(""com.example.fns/inbox"");
 
-### Stateful Match Function 
+    static final ValueSpec<Integer> SEEN = ValueSpec.named(""seen"").withIntType();
 
-Stateful functions provide a powerful abstraction for working with events and state, allowing developers to build components that can react to any kind of message.
-Commonly, functions only need to handle a known set of message types, and the ``StatefulMatchFunction`` interface provides an opinionated solution to that problem.
+    @Override 
+    CompletableFuture<Void> apply(Context context, Message message) {
+        if (!message.is(User.TYPE)) {
+            throw new IllegalStateException(""Unknown type"");
+        }
 
-#### Simple Match Function
+        User user = message.as(User.TYPE);
+        String name = user.getName();
 
-Stateful match functions are an opinionated variant of stateful functions for precisely this pattern.
-Developers outline expected types, optional predicates, and well-typed business logic and let the system dispatch each input to the correct action.
-Variants are bound inside a ``configure`` method that is executed once the first time an instance is loaded.
+        var storage = context.storage();
+        var seen = storage.get(SEEN).orElse(0);
+        storage.set(SEEN, seen + 1);
 
-```java
-package org.apache.flink.statefun.docs.match;
+        context.send(
+            MessageBuilder.forAddress(INBOX, name)
+                .withValue(""Hello "" + name + "" for the "" + seen + ""th time!"")
+                .build());
 
-import org.apache.flink.statefun.sdk.Context;
-import org.apache.flink.statefun.sdk.match.MatchBinder;
-import org.apache.flink.statefun.sdk.match.StatefulMatchFunction;
+        return context.done();
+    }
+}
+```
 
-public class FnMatchGreeter extends StatefulMatchFunction {
+This code declares a greeter function that will be [registered](#exposing-functions) under the logical type name `com.example.fns/greeter`. Type names must take the form `<namesapce>/<name>`.
+It contains a single `ValueSpec`, which is implicitly scoped to the current address and stores an integer.
 
-	@Override
-	public void configure(MatchBinder binder) {
-		binder
-			.predicate(Customer.class, this::greetCustomer)
-			.predicate(Employee.class, Employee::isManager, this::greetManager)
-			.predicate(Employee.class, this::greetEmployee);
-	}
+Every time a message is sent a greeter, it first validates the message containing a `User` and extracts its name. Both messages and state are strongly typed - either one of the default [built-in types]({{< ref ""docs/sdk/appendix#types"" >}}) - or a [custom type](#types) as in this case.
 
-	private void greetCustomer(Context context, Customer message) {
-		System.out.println(""Hello customer "" + message.getName());
-	}
+The function finally builds a custom greeting for the user.
+The number of times that particular user has been seen so far is queried from the state store and updated
+and the greeting is sent to the users' inbox (another function type). 
 
-	private void greetEmployee(Context context, Employee message) {
-		System.out.println(""Hello employee "" + message.getEmployeeId());
-	}
+## Types
 
-	private void greetManager(Context context, Employee message) {
-		System.out.println(""Hello manager "" + message.getEmployeeId());
-	}
-}
-```
+Stateful Functions strongly types ll messages and state values. 
+Because they run in a distributed manner and state values are persisted to stable storage, Stateful Functions aims to provide efficient and easy to user serializers. 
 
-#### Making Your Function Complete
+Out of the box, all SDKs offer a set of highly optimized serializers for common primitive types; boolean, numerics, and strings.
+Additionally, users are encouraged to plug-in custom types to model more complex data structures. 
 
-Similar to the first example, match functions are partial by default and will throw an ``IllegalStateException`` on any input that does not match any branch.
-They can be made complete by providing an ``otherwise`` clause that serves as a catch-all for unmatched input, think of it as a default clause in a Java switch statement.
-The ``otherwise`` action takes its message as an untyped ``java.lang.Object``, allowing you to handle any unexpected messages.
+In the [example above](#defining-a-stateful-function), the greeter function consumes `User` messages, a POJO type containing several fields.
+By defining a custom type, this object can be passed transparently between functions and stored in state.
+And because the type is tied to a logical typename, instead of the physical Java class, it can be passed to functions written in other langauge SDKs. 
 
 ```java
-package org.apache.flink.statefun.docs.match;
-
-import org.apache.flink.statefun.sdk.Context;
-import org.apache.flink.statefun.sdk.match.MatchBinder;
-import org.apache.flink.statefun.sdk.match.StatefulMatchFunction;
-
-public class FnMatchGreeterWithCatchAll extends StatefulMatchFunction {
-
-	@Override
-	public void configure(MatchBinder binder) {
-		binder
-			.predicate(Customer.class, this::greetCustomer)
-			.predicate(Employee.class, Employee::isManager, this::greetManager)
-			.predicate(Employee.class, this::greetEmployee)
-			.otherwise(this::catchAll);
-	}
-
-	private void greetCustomer(Context context, Customer message) {
-		System.out.println(""Hello customer "" + message.getName());
-	}
-
-	private void greetEmployee(Context context, Employee message) {
-		System.out.println(""Hello employee "" + message.getEmployeeId());
-	}
-
-	private void greetManager(Context context, Employee message) {
-		System.out.println(""Hello manager "" + message.getEmployeeId());
-	}
-
-	private void catchAll(Context context, Object message) {
-		System.out.println(""Hello unexpected message"");
-	}
-}
-```
+import com.fasterxml.jackson.annotation.JsonCreator;
+import com.fasterxml.jackson.annotation.JsonProperty;
+import com.fasterxml.jackson.databind.ObjectMapper;
+import org.apache.flink.statefun.sdk.java.TypeName;
+import org.apache.flink.statefun.sdk.java.types.SimpleType;
+import org.apache.flink.statefun.sdk.java.types.Type;
+import java.util.Objects;
 
-#### Action Resolution Order
+public class User {
 
-Match functions will always match actions from most to least specific using the following resolution rules.
+    private static final ObjectMapper mapper = new ObjectMapper();
 
-First, find an action that matches the type and predicate. If two predicates will return true for a particular input, the one registered in the binder first wins.
-Next, search for an action that matches the type but does not have an associated predicate.
-Finally, if a catch-all exists, it will be executed or an ``IllegalStateException`` will be thrown.
+    public static final Type<User> TYPE = SimpleType.simpleImmutableTypeFrom(
+        TypeName.typeNameFromString(""com.example/User""),
+        mapper:writeValueAsBytes,
+        bytes -> mapper.readValue(byes, User.class));
 
-## Function Types and Messaging
+    private final String name;
 
-In Java, function types are defined as logical pointers composed of a namespace and name.
-The type is bound to the implementing class in the [module]({{< ref ""docs/sdk/overview#embedded-module"" >}}) definition.
-Below is an example function type for the hello world function.
+    private final String favoriteColor;
 
-```java
-package org.apache.flink.statefun.docs;
+    @JsonCreator
+    public User(
+        @JsonProperty(""name"") String name,
+        @JsonProperty(""favorite_color"" String favoriteColor)) {
 
-import org.apache.flink.statefun.sdk.FunctionType;
+        this.name = Objects.requireNonNull(name);
+        this.favoriteColor = Objects.requireNonNull(favoriteColor);
+    }
 
-/** A function type that will be bound to {@link FnHelloWorld}. */
-public class Identifiers {
+    public String getName() {
+        return name;
+    }
 
-  public static final FunctionType HELLO_TYPE = new FunctionType(""apache/flink"", ""hello"");
-}
+    public String getFavoriteColor() {
+        return favoriteColor;
+    }
+
+    @Override
+    public String toString() {
+        return ""User{name="" name + "",favoriteColor="" favoriteColor + ""}""
+    }
 ```
 
-This type can then be referenced from other functions to create an address and message a particular instance.
+## State
 
-```java
-package org.apache.flink.statefun.docs;
+Stateful Functions treats state as a first class citizen and so all functions can easily define state that is automatically made fault tolerant by the runtime.
+State declaration is as simple as defining one or more `ValueSpec`'s describing your state values.
+Value specifications are defined with a unique (to the function) name and [type](#types).
+At runtime, functions can `get`, `set`, and `remove` state values scoped to the address of the current message.
 
-import org.apache.flink.statefun.sdk.Context;
-import org.apache.flink.statefun.sdk.StatefulFunction;
-
-/** A simple stateful function that sends a message to the user with id ""user1"" */
-public class FnCaller implements StatefulFunction {
+{{< hint info >}}
+All value specificiations must be earerly registered in the `StatefulFuctionSpec` when composing
+the applications [RequestReplyHandler](#exposing-functions).
+{{< /hint >}}
 
-  @Override
-  public void invoke(Context context, Object input) {
-    context.send(Identifiers.HELLO_TYPE, ""user1"", new MyUserMessage());
-  }
-}
+```java
+// Value specification for a state named `seen` 
+// with the primitive integer type
+ValueSpec
+    .named(""seen"")
+    .withIntType();
+
+// Value specification with a custom type
+ValueSpec
+    .name(""user"")
+    .withCustomType(User.TYPE);
 ```
 
-## Sending Delayed Messages
+### State Expiration
 
-Functions are able to send messages on a delay so that they will arrive after some duration.
-Functions may even send themselves delayed messages that can serve as a callback.
-The delayed message is non-blocking so functions will continue to process records between the time a delayed message is sent and received.
+By default, state values are persisted until manually `remove`d by the user.
+Optionally, they may be configured to expire and be automatically deleted after a specified duration.
 
 ```java
-package org.apache.flink.statefun.docs.delay;
-
-import java.time.Duration;
-import org.apache.flink.statefun.sdk.Context;
-import org.apache.flink.statefun.sdk.StatefulFunction;
-
-public class FnDelayedMessage implements StatefulFunction {
-
-	@Override
-	public void invoke(Context context, Object input) {
-		if (input instanceof Message) {
-			System.out.println(""Hello"");
-			context.sendAfter(Duration.ofMinutes(1), context.self(), new DelayedMessage());
-		}
-
-		if (input instanceof DelayedMessage) {
-			System.out.println(""Welcome to the future!"");
-		}
-	}
-}
+// Value specification that will automatically
+// delete the value if the function instance goes 
+// more than 30 minutes without being called
+ValueSpec
+    .named(""seen"")
+    .thatExpiresAfterCall(Duration.ofDays(1))
+    .withIntType();
+
+// Value specification that will automatically
+// delete the value if it goes more than 1 day
+// without being written
+ValueSpec
+    .named(""seen"")
+    .thatExpireAfterWrite(Duration.ofDays(1))
+    .withIntType();
 ```
 
-## Completing Async Requests
-
-When interacting with external systems, such as a database or API, one needs to take care that communication delay with the external system does not dominate the application’s total work.
-Stateful Functions allows registering a Java ``CompletableFuture`` that will resolve to a value at some point in the future.
-Future's are registered along with a metadata object that provides additional context about the caller.
+## Sending Delayed Messages
 
-When the future completes, either successfully or exceptionally, the caller function type and id will be invoked with a ``AsyncOperationResult``.
-An asynchronous result can complete in one of three states:
+Functions can send messages on a delay so that they will arrive after some duration.
+They may even send themselves delayed messages that can serve as a callback.
+The delayed message is non-blocking, so functions will continue to process records between when a delayed message is sent and received.
+Additionally, they are fault-tolerant and never lost, even when recovering from failure. 
 
-### Success
+This example sends a response back to the calling function after a 30 minute delay.
 
-The asynchronous operation has succeeded, and the produced result can be obtained via ``AsyncOperationResult#value``.
+```java
+import java.util.concurrent.CompletableFuture;
+import java.time.Duration;
 
-### Failure
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import org.apache.flink.statefun.sdk.java.Context;
+import org.apache.flink.statefun.sdk.java.StatefulFunction;
+import org.apache.flink.statefun.sdk.java.message.Message;
 
-The asynchronous operation has failed, and the cause can be obtained via ``AsyncOperationResult#throwable``.
+public class DelayedFn implements StatefulFunction {
 
-### Unknown
+    private static final Logger LOG = LoggerFactory.getLogger(DelayedFn.class);
 
-The stateful function was restarted, possibly on a different machine, before the ``CompletableFuture`` was completed, therefore it is unknown what is the status of the asynchronous operation.
+    static final TypeName TYPE = TypeName.forNameFromString(""com.example.fns/delayed"");
 
-```java
-package org.apache.flink.statefun.docs.async;
+    @Override 
+    CompletableFuture<Void> apply(Context context, Message message) {
+        if (!context.caller().isPresent()) {
+            LOG.debug(""Message has no known caller meaning it was sent directly from an ingress"");
+            return;
+        }
 
-import java.util.concurrent.CompletableFuture;
-import org.apache.flink.statefun.sdk.AsyncOperationResult;
-import org.apache.flink.statefun.sdk.Context;
-import org.apache.flink.statefun.sdk.StatefulFunction;
-
-@SuppressWarnings(""unchecked"")
-public class EnrichmentFunction implements StatefulFunction {
-
-	private final QueryService client;
-
-	public EnrichmentFunction(QueryService client) {
-		this.client = client;
-	}
-
-	@Override
-	public void invoke(Context context, Object input) {
-		if (input instanceof User) {
-			onUser(context, (User) input);
-		} else if (input instanceof AsyncOperationResult) {
-			onAsyncResult((AsyncOperationResult) input);
-		}
-	}
-
-	private void onUser(Context context, User user) {
-		CompletableFuture<UserEnrichment> future = client.getDataAsync(user.getUserId());
-		context.registerAsyncOperation(user, future);
-	}
-
-	private void onAsyncResult(AsyncOperationResult<User, UserEnrichment> result) {
-		if (result.successful()) {
-			User metadata = result.metadata();
-			UserEnrichment value = result.value();
-			System.out.println(
-				String.format(""Successfully completed future: %s %s"", metadata, value));
-		} else if (result.failure()) {
-			System.out.println(
-				String.format(""Something has gone terribly wrong %s"", result.throwable()));
-		} else {
-			System.out.println(""Not sure what happened, maybe retry"");
-		}
-	}
+        var caller = context.caller().get();
+        context.sendAfter(Duration.ofMinutes(30), MessageBuilder
+            .forAddress(caller)
+            .withValue(""Hello from the future!""));
+    }
 }
 ```
 
-## Persistence
-
-Stateful Functions treats state as a first class citizen and so all stateful functions can easily define state that is automatically made fault tolerant by the runtime.
-All stateful functions may contain state by merely defining one or more persisted fields.
+## Egress
 
-The simplest way to get started is with a ``PersistedValue``, which is defined by its name and the class of the type that it stores.
-The data is always scoped to a specific function type and identifier.
-Below is a stateful function that greets users based on the number of times they have been seen.
-
-{{< hint info >}}
-All **PersistedValue**, **PersistedTable**, and **PersistedAppendingBuffer** fields must be marked with a **@Persisted** annotation or they will not be made fault tolerant by the runtime.
-{{< /hint >}}
+Functions can message other stateful functions and egresses, exit points for sending messages to the outside world.
+As with other messages, egress messages are always well-typed. 
+Additionally, they contain metadata pertinent to the specific egress type.
 
+{{< tabs ""egress"" >}}
+{{< tab ""Apache Kafka"" >}}
 ```java
-package org.apache.flink.statefun.docs;
-
-import org.apache.flink.statefun.sdk.Context;
-import org.apache.flink.statefun.sdk.FunctionType;
-import org.apache.flink.statefun.sdk.StatefulFunction;
-import org.apache.flink.statefun.sdk.annotations.Persisted;
-import org.apache.flink.statefun.sdk.state.PersistedValue;
-
-public class FnUserGreeter implements StatefulFunction {
-
-	public static FunctionType TYPE = new FunctionType(""example"", ""greeter"");
-
-	@Persisted
-	private final PersistedValue<Integer> count = PersistedValue.of(""count"", Integer.class);
-
-	public void invoke(Context context, Object input) {
-		String userId = context.self().id();
-		int seen = count.getOrDefault(0);
-
-		switch (seen) {
-			case 0:
-				System.out.println(String.format(""Hello %s!"", userId));
-				break;
-			case 1:
-				System.out.println(""Hello Again!"");
-				break;
-			case 2:
-				System.out.println(""Third time is the charm :)"");
-				break;
-			default:
-				System.out.println(String.format(""Hello for the %d-th time"", seen + 1));
-		}
-
-		count.set(seen + 1);
-	}
-}
-```
+import java.util.concurrent.CompletableFuture;
+import org.apache.flink.statefun.sdk.java.Context;
+import org.apache.flink.statefun.sdk.java.StatefulFunction;
+import org.apache.flink.statefun.sdk.java.TypeName;
+import org.apache.flink.statefun.sdk.java.ValueSpec;
+import org.apache.flink.statefun.sdk.java.message.Message;
+import org.apache.flink.statefun.sdk.java.io.KafkaEgressMessage;
 
-``PersistedValue`` comes with the right primitive methods to build powerful stateful applications.
-Calling ``PersistedValue#get`` will return the current value of an object stored in state, or ``null`` if nothing is set.
-Conversely, ``PersistedValue#set`` will update the value in state and ``PersistedValue#clear`` will delete the value from state.
+public class GreeterFn implements StatefulFunction {
 
-### Collection Types
+    static final TypeName TYPE = TypeName.forNameFromString(""com.example.fns/greeter"");","[{'comment': 'forNameFromString  => typeNameFromString', 'commenter': 'afedulov'}]"
211,docs/content/docs/sdk/java.md,"@@ -29,451 +29,395 @@ under the License.
 Stateful functions are the building blocks of applications; they are atomic units of isolation, distribution, and persistence.
 As objects, they encapsulate the state of a single entity (e.g., a specific user, device, or session) and encode its behavior.
 Stateful functions can interact with each other, and external systems, through message passing.
-The Java SDK is supported as an [embedded module]({{< ref ""docs/sdk/overview#embedded-module"" >}}).
 
 To get started, add the Java SDK as a dependency to your application.
 
-{{< artifact statefun-sdk >}}
+{{< artifact statefun-sdk-java >}}
 
 ## Defining A Stateful Function
 
-A stateful function is any class that implements the ``StatefulFunction`` interface.
-The following is an example of a simple hello world function.
+A stateful function is any class that implements the `StatefulFunction` interface.
+In the following example, a `StatefulFunction` maintains a count for every user
+of an application, emitting a customized greeting.
 
 ```java
-package org.apache.flink.statefun.docs;
-
-import org.apache.flink.statefun.sdk.Context;
-import org.apache.flink.statefun.sdk.StatefulFunction;
-
-public class FnHelloWorld implements StatefulFunction {
+import java.util.concurrent.CompletableFuture;
+import org.apache.flink.statefun.sdk.java.Context;
+import org.apache.flink.statefun.sdk.java.StatefulFunction;
+import org.apache.flink.statefun.sdk.java.TypeName;
+import org.apache.flink.statefun.sdk.java.ValueSpec;
+import org.apache.flink.statefun.sdk.java.message.Message;
 
-	@Override
-	public void invoke(Context context, Object input) {
-		System.out.println(""Hello "" + input.toString());
-	}
-}
-```
+public class GreeterFn implements StatefulFunction {
 
-Functions process each incoming message through their ``invoke`` method.
-Input's are untyped and passed through the system as a ``java.lang.Object`` so one function can potentially process multiple types of messages.
+    static final TypeName TYPE = TypeName.forNameFromString(""com.example.fns/greeter"");
 
-The ``Context`` provides metadata about the current message and function, and is how you can call other functions or external systems.
-Functions are invoked based on a function type and unique identifier.
+    static final TypeName INBOX = TypeName.forNameFromString(""com.example.fns/inbox"");
 
-### Stateful Match Function 
+    static final ValueSpec<Integer> SEEN = ValueSpec.named(""seen"").withIntType();
 
-Stateful functions provide a powerful abstraction for working with events and state, allowing developers to build components that can react to any kind of message.
-Commonly, functions only need to handle a known set of message types, and the ``StatefulMatchFunction`` interface provides an opinionated solution to that problem.
+    @Override 
+    CompletableFuture<Void> apply(Context context, Message message) {
+        if (!message.is(User.TYPE)) {
+            throw new IllegalStateException(""Unknown type"");
+        }
 
-#### Simple Match Function
+        User user = message.as(User.TYPE);
+        String name = user.getName();
 
-Stateful match functions are an opinionated variant of stateful functions for precisely this pattern.
-Developers outline expected types, optional predicates, and well-typed business logic and let the system dispatch each input to the correct action.
-Variants are bound inside a ``configure`` method that is executed once the first time an instance is loaded.
+        var storage = context.storage();
+        var seen = storage.get(SEEN).orElse(0);
+        storage.set(SEEN, seen + 1);
 
-```java
-package org.apache.flink.statefun.docs.match;
+        context.send(
+            MessageBuilder.forAddress(INBOX, name)
+                .withValue(""Hello "" + name + "" for the "" + seen + ""th time!"")
+                .build());
 
-import org.apache.flink.statefun.sdk.Context;
-import org.apache.flink.statefun.sdk.match.MatchBinder;
-import org.apache.flink.statefun.sdk.match.StatefulMatchFunction;
+        return context.done();
+    }
+}
+```
 
-public class FnMatchGreeter extends StatefulMatchFunction {
+This code declares a greeter function that will be [registered](#exposing-functions) under the logical type name `com.example.fns/greeter`. Type names must take the form `<namesapce>/<name>`.
+It contains a single `ValueSpec`, which is implicitly scoped to the current address and stores an integer.
 
-	@Override
-	public void configure(MatchBinder binder) {
-		binder
-			.predicate(Customer.class, this::greetCustomer)
-			.predicate(Employee.class, Employee::isManager, this::greetManager)
-			.predicate(Employee.class, this::greetEmployee);
-	}
+Every time a message is sent a greeter, it first validates the message containing a `User` and extracts its name. Both messages and state are strongly typed - either one of the default [built-in types]({{< ref ""docs/sdk/appendix#types"" >}}) - or a [custom type](#types) as in this case.
 
-	private void greetCustomer(Context context, Customer message) {
-		System.out.println(""Hello customer "" + message.getName());
-	}
+The function finally builds a custom greeting for the user.
+The number of times that particular user has been seen so far is queried from the state store and updated
+and the greeting is sent to the users' inbox (another function type). 
 
-	private void greetEmployee(Context context, Employee message) {
-		System.out.println(""Hello employee "" + message.getEmployeeId());
-	}
+## Types
 
-	private void greetManager(Context context, Employee message) {
-		System.out.println(""Hello manager "" + message.getEmployeeId());
-	}
-}
-```
+Stateful Functions strongly types ll messages and state values. 
+Because they run in a distributed manner and state values are persisted to stable storage, Stateful Functions aims to provide efficient and easy to user serializers. 
 
-#### Making Your Function Complete
+Out of the box, all SDKs offer a set of highly optimized serializers for common primitive types; boolean, numerics, and strings.
+Additionally, users are encouraged to plug-in custom types to model more complex data structures. 
 
-Similar to the first example, match functions are partial by default and will throw an ``IllegalStateException`` on any input that does not match any branch.
-They can be made complete by providing an ``otherwise`` clause that serves as a catch-all for unmatched input, think of it as a default clause in a Java switch statement.
-The ``otherwise`` action takes its message as an untyped ``java.lang.Object``, allowing you to handle any unexpected messages.
+In the [example above](#defining-a-stateful-function), the greeter function consumes `User` messages, a POJO type containing several fields.
+By defining a custom type, this object can be passed transparently between functions and stored in state.
+And because the type is tied to a logical typename, instead of the physical Java class, it can be passed to functions written in other langauge SDKs. 
 
 ```java
-package org.apache.flink.statefun.docs.match;
-
-import org.apache.flink.statefun.sdk.Context;
-import org.apache.flink.statefun.sdk.match.MatchBinder;
-import org.apache.flink.statefun.sdk.match.StatefulMatchFunction;
-
-public class FnMatchGreeterWithCatchAll extends StatefulMatchFunction {
-
-	@Override
-	public void configure(MatchBinder binder) {
-		binder
-			.predicate(Customer.class, this::greetCustomer)
-			.predicate(Employee.class, Employee::isManager, this::greetManager)
-			.predicate(Employee.class, this::greetEmployee)
-			.otherwise(this::catchAll);
-	}
-
-	private void greetCustomer(Context context, Customer message) {
-		System.out.println(""Hello customer "" + message.getName());
-	}
-
-	private void greetEmployee(Context context, Employee message) {
-		System.out.println(""Hello employee "" + message.getEmployeeId());
-	}
-
-	private void greetManager(Context context, Employee message) {
-		System.out.println(""Hello manager "" + message.getEmployeeId());
-	}
-
-	private void catchAll(Context context, Object message) {
-		System.out.println(""Hello unexpected message"");
-	}
-}
-```
+import com.fasterxml.jackson.annotation.JsonCreator;
+import com.fasterxml.jackson.annotation.JsonProperty;
+import com.fasterxml.jackson.databind.ObjectMapper;
+import org.apache.flink.statefun.sdk.java.TypeName;
+import org.apache.flink.statefun.sdk.java.types.SimpleType;
+import org.apache.flink.statefun.sdk.java.types.Type;
+import java.util.Objects;
 
-#### Action Resolution Order
+public class User {
 
-Match functions will always match actions from most to least specific using the following resolution rules.
+    private static final ObjectMapper mapper = new ObjectMapper();
 
-First, find an action that matches the type and predicate. If two predicates will return true for a particular input, the one registered in the binder first wins.
-Next, search for an action that matches the type but does not have an associated predicate.
-Finally, if a catch-all exists, it will be executed or an ``IllegalStateException`` will be thrown.
+    public static final Type<User> TYPE = SimpleType.simpleImmutableTypeFrom(
+        TypeName.typeNameFromString(""com.example/User""),
+        mapper:writeValueAsBytes,
+        bytes -> mapper.readValue(byes, User.class));
 
-## Function Types and Messaging
+    private final String name;
 
-In Java, function types are defined as logical pointers composed of a namespace and name.
-The type is bound to the implementing class in the [module]({{< ref ""docs/sdk/overview#embedded-module"" >}}) definition.
-Below is an example function type for the hello world function.
+    private final String favoriteColor;
 
-```java
-package org.apache.flink.statefun.docs;
+    @JsonCreator
+    public User(
+        @JsonProperty(""name"") String name,
+        @JsonProperty(""favorite_color"" String favoriteColor)) {
 
-import org.apache.flink.statefun.sdk.FunctionType;
+        this.name = Objects.requireNonNull(name);
+        this.favoriteColor = Objects.requireNonNull(favoriteColor);
+    }
 
-/** A function type that will be bound to {@link FnHelloWorld}. */
-public class Identifiers {
+    public String getName() {
+        return name;
+    }
 
-  public static final FunctionType HELLO_TYPE = new FunctionType(""apache/flink"", ""hello"");
-}
+    public String getFavoriteColor() {
+        return favoriteColor;
+    }
+
+    @Override
+    public String toString() {
+        return ""User{name="" name + "",favoriteColor="" favoriteColor + ""}""
+    }
 ```
 
-This type can then be referenced from other functions to create an address and message a particular instance.
+## State
 
-```java
-package org.apache.flink.statefun.docs;
+Stateful Functions treats state as a first class citizen and so all functions can easily define state that is automatically made fault tolerant by the runtime.
+State declaration is as simple as defining one or more `ValueSpec`'s describing your state values.
+Value specifications are defined with a unique (to the function) name and [type](#types).
+At runtime, functions can `get`, `set`, and `remove` state values scoped to the address of the current message.
 
-import org.apache.flink.statefun.sdk.Context;
-import org.apache.flink.statefun.sdk.StatefulFunction;
-
-/** A simple stateful function that sends a message to the user with id ""user1"" */
-public class FnCaller implements StatefulFunction {
+{{< hint info >}}
+All value specificiations must be earerly registered in the `StatefulFuctionSpec` when composing
+the applications [RequestReplyHandler](#exposing-functions).
+{{< /hint >}}
 
-  @Override
-  public void invoke(Context context, Object input) {
-    context.send(Identifiers.HELLO_TYPE, ""user1"", new MyUserMessage());
-  }
-}
+```java
+// Value specification for a state named `seen` 
+// with the primitive integer type
+ValueSpec
+    .named(""seen"")
+    .withIntType();
+
+// Value specification with a custom type
+ValueSpec
+    .name(""user"")
+    .withCustomType(User.TYPE);
 ```
 
-## Sending Delayed Messages
+### State Expiration
 
-Functions are able to send messages on a delay so that they will arrive after some duration.
-Functions may even send themselves delayed messages that can serve as a callback.
-The delayed message is non-blocking so functions will continue to process records between the time a delayed message is sent and received.
+By default, state values are persisted until manually `remove`d by the user.
+Optionally, they may be configured to expire and be automatically deleted after a specified duration.
 
 ```java
-package org.apache.flink.statefun.docs.delay;
-
-import java.time.Duration;
-import org.apache.flink.statefun.sdk.Context;
-import org.apache.flink.statefun.sdk.StatefulFunction;
-
-public class FnDelayedMessage implements StatefulFunction {
-
-	@Override
-	public void invoke(Context context, Object input) {
-		if (input instanceof Message) {
-			System.out.println(""Hello"");
-			context.sendAfter(Duration.ofMinutes(1), context.self(), new DelayedMessage());
-		}
-
-		if (input instanceof DelayedMessage) {
-			System.out.println(""Welcome to the future!"");
-		}
-	}
-}
+// Value specification that will automatically
+// delete the value if the function instance goes 
+// more than 30 minutes without being called
+ValueSpec
+    .named(""seen"")
+    .thatExpiresAfterCall(Duration.ofDays(1))
+    .withIntType();
+
+// Value specification that will automatically
+// delete the value if it goes more than 1 day
+// without being written
+ValueSpec
+    .named(""seen"")
+    .thatExpireAfterWrite(Duration.ofDays(1))
+    .withIntType();
 ```
 
-## Completing Async Requests
-
-When interacting with external systems, such as a database or API, one needs to take care that communication delay with the external system does not dominate the application’s total work.
-Stateful Functions allows registering a Java ``CompletableFuture`` that will resolve to a value at some point in the future.
-Future's are registered along with a metadata object that provides additional context about the caller.
+## Sending Delayed Messages
 
-When the future completes, either successfully or exceptionally, the caller function type and id will be invoked with a ``AsyncOperationResult``.
-An asynchronous result can complete in one of three states:
+Functions can send messages on a delay so that they will arrive after some duration.
+They may even send themselves delayed messages that can serve as a callback.
+The delayed message is non-blocking, so functions will continue to process records between when a delayed message is sent and received.
+Additionally, they are fault-tolerant and never lost, even when recovering from failure. 
 
-### Success
+This example sends a response back to the calling function after a 30 minute delay.
 
-The asynchronous operation has succeeded, and the produced result can be obtained via ``AsyncOperationResult#value``.
+```java
+import java.util.concurrent.CompletableFuture;
+import java.time.Duration;
 
-### Failure
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import org.apache.flink.statefun.sdk.java.Context;
+import org.apache.flink.statefun.sdk.java.StatefulFunction;
+import org.apache.flink.statefun.sdk.java.message.Message;
 
-The asynchronous operation has failed, and the cause can be obtained via ``AsyncOperationResult#throwable``.
+public class DelayedFn implements StatefulFunction {
 
-### Unknown
+    private static final Logger LOG = LoggerFactory.getLogger(DelayedFn.class);
 
-The stateful function was restarted, possibly on a different machine, before the ``CompletableFuture`` was completed, therefore it is unknown what is the status of the asynchronous operation.
+    static final TypeName TYPE = TypeName.forNameFromString(""com.example.fns/delayed"");
 
-```java
-package org.apache.flink.statefun.docs.async;
+    @Override 
+    CompletableFuture<Void> apply(Context context, Message message) {
+        if (!context.caller().isPresent()) {
+            LOG.debug(""Message has no known caller meaning it was sent directly from an ingress"");
+            return;
+        }
 
-import java.util.concurrent.CompletableFuture;
-import org.apache.flink.statefun.sdk.AsyncOperationResult;
-import org.apache.flink.statefun.sdk.Context;
-import org.apache.flink.statefun.sdk.StatefulFunction;
-
-@SuppressWarnings(""unchecked"")
-public class EnrichmentFunction implements StatefulFunction {
-
-	private final QueryService client;
-
-	public EnrichmentFunction(QueryService client) {
-		this.client = client;
-	}
-
-	@Override
-	public void invoke(Context context, Object input) {
-		if (input instanceof User) {
-			onUser(context, (User) input);
-		} else if (input instanceof AsyncOperationResult) {
-			onAsyncResult((AsyncOperationResult) input);
-		}
-	}
-
-	private void onUser(Context context, User user) {
-		CompletableFuture<UserEnrichment> future = client.getDataAsync(user.getUserId());
-		context.registerAsyncOperation(user, future);
-	}
-
-	private void onAsyncResult(AsyncOperationResult<User, UserEnrichment> result) {
-		if (result.successful()) {
-			User metadata = result.metadata();
-			UserEnrichment value = result.value();
-			System.out.println(
-				String.format(""Successfully completed future: %s %s"", metadata, value));
-		} else if (result.failure()) {
-			System.out.println(
-				String.format(""Something has gone terribly wrong %s"", result.throwable()));
-		} else {
-			System.out.println(""Not sure what happened, maybe retry"");
-		}
-	}
+        var caller = context.caller().get();
+        context.sendAfter(Duration.ofMinutes(30), MessageBuilder
+            .forAddress(caller)
+            .withValue(""Hello from the future!""));
+    }
 }
 ```
 
-## Persistence
-
-Stateful Functions treats state as a first class citizen and so all stateful functions can easily define state that is automatically made fault tolerant by the runtime.
-All stateful functions may contain state by merely defining one or more persisted fields.
+## Egress
 
-The simplest way to get started is with a ``PersistedValue``, which is defined by its name and the class of the type that it stores.
-The data is always scoped to a specific function type and identifier.
-Below is a stateful function that greets users based on the number of times they have been seen.
-
-{{< hint info >}}
-All **PersistedValue**, **PersistedTable**, and **PersistedAppendingBuffer** fields must be marked with a **@Persisted** annotation or they will not be made fault tolerant by the runtime.
-{{< /hint >}}
+Functions can message other stateful functions and egresses, exit points for sending messages to the outside world.
+As with other messages, egress messages are always well-typed. 
+Additionally, they contain metadata pertinent to the specific egress type.
 
+{{< tabs ""egress"" >}}
+{{< tab ""Apache Kafka"" >}}
 ```java
-package org.apache.flink.statefun.docs;
-
-import org.apache.flink.statefun.sdk.Context;
-import org.apache.flink.statefun.sdk.FunctionType;
-import org.apache.flink.statefun.sdk.StatefulFunction;
-import org.apache.flink.statefun.sdk.annotations.Persisted;
-import org.apache.flink.statefun.sdk.state.PersistedValue;
-
-public class FnUserGreeter implements StatefulFunction {
-
-	public static FunctionType TYPE = new FunctionType(""example"", ""greeter"");
-
-	@Persisted
-	private final PersistedValue<Integer> count = PersistedValue.of(""count"", Integer.class);
-
-	public void invoke(Context context, Object input) {
-		String userId = context.self().id();
-		int seen = count.getOrDefault(0);
-
-		switch (seen) {
-			case 0:
-				System.out.println(String.format(""Hello %s!"", userId));
-				break;
-			case 1:
-				System.out.println(""Hello Again!"");
-				break;
-			case 2:
-				System.out.println(""Third time is the charm :)"");
-				break;
-			default:
-				System.out.println(String.format(""Hello for the %d-th time"", seen + 1));
-		}
-
-		count.set(seen + 1);
-	}
-}
-```
+import java.util.concurrent.CompletableFuture;
+import org.apache.flink.statefun.sdk.java.Context;
+import org.apache.flink.statefun.sdk.java.StatefulFunction;
+import org.apache.flink.statefun.sdk.java.TypeName;
+import org.apache.flink.statefun.sdk.java.ValueSpec;
+import org.apache.flink.statefun.sdk.java.message.Message;
+import org.apache.flink.statefun.sdk.java.io.KafkaEgressMessage;
 
-``PersistedValue`` comes with the right primitive methods to build powerful stateful applications.
-Calling ``PersistedValue#get`` will return the current value of an object stored in state, or ``null`` if nothing is set.
-Conversely, ``PersistedValue#set`` will update the value in state and ``PersistedValue#clear`` will delete the value from state.
+public class GreeterFn implements StatefulFunction {
 
-### Collection Types
+    static final TypeName TYPE = TypeName.forNameFromString(""com.example.fns/greeter"");
 
-Along with ``PersistedValue``, the Java SDK supports two persisted collection types.
-``PersistedTable`` is a collection of keys and values, and ``PersistedAppendingBuffer`` is an append-only buffer.
+    static final TypeName KAFKA_EGRESS = TypeName.forNameFromString(""com.example/greets"");","[{'comment': 'forNameFromString  => typeNameFromString', 'commenter': 'afedulov'}]"
211,docs/content/docs/sdk/java.md,"@@ -29,451 +29,395 @@ under the License.
 Stateful functions are the building blocks of applications; they are atomic units of isolation, distribution, and persistence.
 As objects, they encapsulate the state of a single entity (e.g., a specific user, device, or session) and encode its behavior.
 Stateful functions can interact with each other, and external systems, through message passing.
-The Java SDK is supported as an [embedded module]({{< ref ""docs/sdk/overview#embedded-module"" >}}).
 
 To get started, add the Java SDK as a dependency to your application.
 
-{{< artifact statefun-sdk >}}
+{{< artifact statefun-sdk-java >}}
 
 ## Defining A Stateful Function
 
-A stateful function is any class that implements the ``StatefulFunction`` interface.
-The following is an example of a simple hello world function.
+A stateful function is any class that implements the `StatefulFunction` interface.
+In the following example, a `StatefulFunction` maintains a count for every user
+of an application, emitting a customized greeting.
 
 ```java
-package org.apache.flink.statefun.docs;
-
-import org.apache.flink.statefun.sdk.Context;
-import org.apache.flink.statefun.sdk.StatefulFunction;
-
-public class FnHelloWorld implements StatefulFunction {
+import java.util.concurrent.CompletableFuture;
+import org.apache.flink.statefun.sdk.java.Context;
+import org.apache.flink.statefun.sdk.java.StatefulFunction;
+import org.apache.flink.statefun.sdk.java.TypeName;
+import org.apache.flink.statefun.sdk.java.ValueSpec;
+import org.apache.flink.statefun.sdk.java.message.Message;
 
-	@Override
-	public void invoke(Context context, Object input) {
-		System.out.println(""Hello "" + input.toString());
-	}
-}
-```
+public class GreeterFn implements StatefulFunction {
 
-Functions process each incoming message through their ``invoke`` method.
-Input's are untyped and passed through the system as a ``java.lang.Object`` so one function can potentially process multiple types of messages.
+    static final TypeName TYPE = TypeName.forNameFromString(""com.example.fns/greeter"");
 
-The ``Context`` provides metadata about the current message and function, and is how you can call other functions or external systems.
-Functions are invoked based on a function type and unique identifier.
+    static final TypeName INBOX = TypeName.forNameFromString(""com.example.fns/inbox"");
 
-### Stateful Match Function 
+    static final ValueSpec<Integer> SEEN = ValueSpec.named(""seen"").withIntType();
 
-Stateful functions provide a powerful abstraction for working with events and state, allowing developers to build components that can react to any kind of message.
-Commonly, functions only need to handle a known set of message types, and the ``StatefulMatchFunction`` interface provides an opinionated solution to that problem.
+    @Override 
+    CompletableFuture<Void> apply(Context context, Message message) {
+        if (!message.is(User.TYPE)) {
+            throw new IllegalStateException(""Unknown type"");
+        }
 
-#### Simple Match Function
+        User user = message.as(User.TYPE);
+        String name = user.getName();
 
-Stateful match functions are an opinionated variant of stateful functions for precisely this pattern.
-Developers outline expected types, optional predicates, and well-typed business logic and let the system dispatch each input to the correct action.
-Variants are bound inside a ``configure`` method that is executed once the first time an instance is loaded.
+        var storage = context.storage();
+        var seen = storage.get(SEEN).orElse(0);
+        storage.set(SEEN, seen + 1);
 
-```java
-package org.apache.flink.statefun.docs.match;
+        context.send(
+            MessageBuilder.forAddress(INBOX, name)
+                .withValue(""Hello "" + name + "" for the "" + seen + ""th time!"")
+                .build());
 
-import org.apache.flink.statefun.sdk.Context;
-import org.apache.flink.statefun.sdk.match.MatchBinder;
-import org.apache.flink.statefun.sdk.match.StatefulMatchFunction;
+        return context.done();
+    }
+}
+```
 
-public class FnMatchGreeter extends StatefulMatchFunction {
+This code declares a greeter function that will be [registered](#exposing-functions) under the logical type name `com.example.fns/greeter`. Type names must take the form `<namesapce>/<name>`.
+It contains a single `ValueSpec`, which is implicitly scoped to the current address and stores an integer.
 
-	@Override
-	public void configure(MatchBinder binder) {
-		binder
-			.predicate(Customer.class, this::greetCustomer)
-			.predicate(Employee.class, Employee::isManager, this::greetManager)
-			.predicate(Employee.class, this::greetEmployee);
-	}
+Every time a message is sent a greeter, it first validates the message containing a `User` and extracts its name. Both messages and state are strongly typed - either one of the default [built-in types]({{< ref ""docs/sdk/appendix#types"" >}}) - or a [custom type](#types) as in this case.
 
-	private void greetCustomer(Context context, Customer message) {
-		System.out.println(""Hello customer "" + message.getName());
-	}
+The function finally builds a custom greeting for the user.
+The number of times that particular user has been seen so far is queried from the state store and updated
+and the greeting is sent to the users' inbox (another function type). 
 
-	private void greetEmployee(Context context, Employee message) {
-		System.out.println(""Hello employee "" + message.getEmployeeId());
-	}
+## Types
 
-	private void greetManager(Context context, Employee message) {
-		System.out.println(""Hello manager "" + message.getEmployeeId());
-	}
-}
-```
+Stateful Functions strongly types ll messages and state values. 
+Because they run in a distributed manner and state values are persisted to stable storage, Stateful Functions aims to provide efficient and easy to user serializers. 
 
-#### Making Your Function Complete
+Out of the box, all SDKs offer a set of highly optimized serializers for common primitive types; boolean, numerics, and strings.
+Additionally, users are encouraged to plug-in custom types to model more complex data structures. 
 
-Similar to the first example, match functions are partial by default and will throw an ``IllegalStateException`` on any input that does not match any branch.
-They can be made complete by providing an ``otherwise`` clause that serves as a catch-all for unmatched input, think of it as a default clause in a Java switch statement.
-The ``otherwise`` action takes its message as an untyped ``java.lang.Object``, allowing you to handle any unexpected messages.
+In the [example above](#defining-a-stateful-function), the greeter function consumes `User` messages, a POJO type containing several fields.
+By defining a custom type, this object can be passed transparently between functions and stored in state.
+And because the type is tied to a logical typename, instead of the physical Java class, it can be passed to functions written in other langauge SDKs. 
 
 ```java
-package org.apache.flink.statefun.docs.match;
-
-import org.apache.flink.statefun.sdk.Context;
-import org.apache.flink.statefun.sdk.match.MatchBinder;
-import org.apache.flink.statefun.sdk.match.StatefulMatchFunction;
-
-public class FnMatchGreeterWithCatchAll extends StatefulMatchFunction {
-
-	@Override
-	public void configure(MatchBinder binder) {
-		binder
-			.predicate(Customer.class, this::greetCustomer)
-			.predicate(Employee.class, Employee::isManager, this::greetManager)
-			.predicate(Employee.class, this::greetEmployee)
-			.otherwise(this::catchAll);
-	}
-
-	private void greetCustomer(Context context, Customer message) {
-		System.out.println(""Hello customer "" + message.getName());
-	}
-
-	private void greetEmployee(Context context, Employee message) {
-		System.out.println(""Hello employee "" + message.getEmployeeId());
-	}
-
-	private void greetManager(Context context, Employee message) {
-		System.out.println(""Hello manager "" + message.getEmployeeId());
-	}
-
-	private void catchAll(Context context, Object message) {
-		System.out.println(""Hello unexpected message"");
-	}
-}
-```
+import com.fasterxml.jackson.annotation.JsonCreator;
+import com.fasterxml.jackson.annotation.JsonProperty;
+import com.fasterxml.jackson.databind.ObjectMapper;
+import org.apache.flink.statefun.sdk.java.TypeName;
+import org.apache.flink.statefun.sdk.java.types.SimpleType;
+import org.apache.flink.statefun.sdk.java.types.Type;
+import java.util.Objects;
 
-#### Action Resolution Order
+public class User {
 
-Match functions will always match actions from most to least specific using the following resolution rules.
+    private static final ObjectMapper mapper = new ObjectMapper();
 
-First, find an action that matches the type and predicate. If two predicates will return true for a particular input, the one registered in the binder first wins.
-Next, search for an action that matches the type but does not have an associated predicate.
-Finally, if a catch-all exists, it will be executed or an ``IllegalStateException`` will be thrown.
+    public static final Type<User> TYPE = SimpleType.simpleImmutableTypeFrom(
+        TypeName.typeNameFromString(""com.example/User""),
+        mapper:writeValueAsBytes,
+        bytes -> mapper.readValue(byes, User.class));
 
-## Function Types and Messaging
+    private final String name;
 
-In Java, function types are defined as logical pointers composed of a namespace and name.
-The type is bound to the implementing class in the [module]({{< ref ""docs/sdk/overview#embedded-module"" >}}) definition.
-Below is an example function type for the hello world function.
+    private final String favoriteColor;
 
-```java
-package org.apache.flink.statefun.docs;
+    @JsonCreator
+    public User(
+        @JsonProperty(""name"") String name,
+        @JsonProperty(""favorite_color"" String favoriteColor)) {
 
-import org.apache.flink.statefun.sdk.FunctionType;
+        this.name = Objects.requireNonNull(name);
+        this.favoriteColor = Objects.requireNonNull(favoriteColor);
+    }
 
-/** A function type that will be bound to {@link FnHelloWorld}. */
-public class Identifiers {
+    public String getName() {
+        return name;
+    }
 
-  public static final FunctionType HELLO_TYPE = new FunctionType(""apache/flink"", ""hello"");
-}
+    public String getFavoriteColor() {
+        return favoriteColor;
+    }
+
+    @Override
+    public String toString() {
+        return ""User{name="" name + "",favoriteColor="" favoriteColor + ""}""
+    }
 ```
 
-This type can then be referenced from other functions to create an address and message a particular instance.
+## State
 
-```java
-package org.apache.flink.statefun.docs;
+Stateful Functions treats state as a first class citizen and so all functions can easily define state that is automatically made fault tolerant by the runtime.
+State declaration is as simple as defining one or more `ValueSpec`'s describing your state values.
+Value specifications are defined with a unique (to the function) name and [type](#types).
+At runtime, functions can `get`, `set`, and `remove` state values scoped to the address of the current message.
 
-import org.apache.flink.statefun.sdk.Context;
-import org.apache.flink.statefun.sdk.StatefulFunction;
-
-/** A simple stateful function that sends a message to the user with id ""user1"" */
-public class FnCaller implements StatefulFunction {
+{{< hint info >}}
+All value specificiations must be earerly registered in the `StatefulFuctionSpec` when composing
+the applications [RequestReplyHandler](#exposing-functions).
+{{< /hint >}}
 
-  @Override
-  public void invoke(Context context, Object input) {
-    context.send(Identifiers.HELLO_TYPE, ""user1"", new MyUserMessage());
-  }
-}
+```java
+// Value specification for a state named `seen` 
+// with the primitive integer type
+ValueSpec
+    .named(""seen"")
+    .withIntType();
+
+// Value specification with a custom type
+ValueSpec
+    .name(""user"")
+    .withCustomType(User.TYPE);
 ```
 
-## Sending Delayed Messages
+### State Expiration
 
-Functions are able to send messages on a delay so that they will arrive after some duration.
-Functions may even send themselves delayed messages that can serve as a callback.
-The delayed message is non-blocking so functions will continue to process records between the time a delayed message is sent and received.
+By default, state values are persisted until manually `remove`d by the user.
+Optionally, they may be configured to expire and be automatically deleted after a specified duration.
 
 ```java
-package org.apache.flink.statefun.docs.delay;
-
-import java.time.Duration;
-import org.apache.flink.statefun.sdk.Context;
-import org.apache.flink.statefun.sdk.StatefulFunction;
-
-public class FnDelayedMessage implements StatefulFunction {
-
-	@Override
-	public void invoke(Context context, Object input) {
-		if (input instanceof Message) {
-			System.out.println(""Hello"");
-			context.sendAfter(Duration.ofMinutes(1), context.self(), new DelayedMessage());
-		}
-
-		if (input instanceof DelayedMessage) {
-			System.out.println(""Welcome to the future!"");
-		}
-	}
-}
+// Value specification that will automatically
+// delete the value if the function instance goes 
+// more than 30 minutes without being called
+ValueSpec
+    .named(""seen"")
+    .thatExpiresAfterCall(Duration.ofDays(1))
+    .withIntType();
+
+// Value specification that will automatically
+// delete the value if it goes more than 1 day
+// without being written
+ValueSpec
+    .named(""seen"")
+    .thatExpireAfterWrite(Duration.ofDays(1))
+    .withIntType();
 ```
 
-## Completing Async Requests
-
-When interacting with external systems, such as a database or API, one needs to take care that communication delay with the external system does not dominate the application’s total work.
-Stateful Functions allows registering a Java ``CompletableFuture`` that will resolve to a value at some point in the future.
-Future's are registered along with a metadata object that provides additional context about the caller.
+## Sending Delayed Messages
 
-When the future completes, either successfully or exceptionally, the caller function type and id will be invoked with a ``AsyncOperationResult``.
-An asynchronous result can complete in one of three states:
+Functions can send messages on a delay so that they will arrive after some duration.
+They may even send themselves delayed messages that can serve as a callback.
+The delayed message is non-blocking, so functions will continue to process records between when a delayed message is sent and received.
+Additionally, they are fault-tolerant and never lost, even when recovering from failure. 
 
-### Success
+This example sends a response back to the calling function after a 30 minute delay.
 
-The asynchronous operation has succeeded, and the produced result can be obtained via ``AsyncOperationResult#value``.
+```java
+import java.util.concurrent.CompletableFuture;
+import java.time.Duration;
 
-### Failure
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import org.apache.flink.statefun.sdk.java.Context;
+import org.apache.flink.statefun.sdk.java.StatefulFunction;
+import org.apache.flink.statefun.sdk.java.message.Message;
 
-The asynchronous operation has failed, and the cause can be obtained via ``AsyncOperationResult#throwable``.
+public class DelayedFn implements StatefulFunction {
 
-### Unknown
+    private static final Logger LOG = LoggerFactory.getLogger(DelayedFn.class);
 
-The stateful function was restarted, possibly on a different machine, before the ``CompletableFuture`` was completed, therefore it is unknown what is the status of the asynchronous operation.
+    static final TypeName TYPE = TypeName.forNameFromString(""com.example.fns/delayed"");
 
-```java
-package org.apache.flink.statefun.docs.async;
+    @Override 
+    CompletableFuture<Void> apply(Context context, Message message) {
+        if (!context.caller().isPresent()) {
+            LOG.debug(""Message has no known caller meaning it was sent directly from an ingress"");
+            return;
+        }
 
-import java.util.concurrent.CompletableFuture;
-import org.apache.flink.statefun.sdk.AsyncOperationResult;
-import org.apache.flink.statefun.sdk.Context;
-import org.apache.flink.statefun.sdk.StatefulFunction;
-
-@SuppressWarnings(""unchecked"")
-public class EnrichmentFunction implements StatefulFunction {
-
-	private final QueryService client;
-
-	public EnrichmentFunction(QueryService client) {
-		this.client = client;
-	}
-
-	@Override
-	public void invoke(Context context, Object input) {
-		if (input instanceof User) {
-			onUser(context, (User) input);
-		} else if (input instanceof AsyncOperationResult) {
-			onAsyncResult((AsyncOperationResult) input);
-		}
-	}
-
-	private void onUser(Context context, User user) {
-		CompletableFuture<UserEnrichment> future = client.getDataAsync(user.getUserId());
-		context.registerAsyncOperation(user, future);
-	}
-
-	private void onAsyncResult(AsyncOperationResult<User, UserEnrichment> result) {
-		if (result.successful()) {
-			User metadata = result.metadata();
-			UserEnrichment value = result.value();
-			System.out.println(
-				String.format(""Successfully completed future: %s %s"", metadata, value));
-		} else if (result.failure()) {
-			System.out.println(
-				String.format(""Something has gone terribly wrong %s"", result.throwable()));
-		} else {
-			System.out.println(""Not sure what happened, maybe retry"");
-		}
-	}
+        var caller = context.caller().get();
+        context.sendAfter(Duration.ofMinutes(30), MessageBuilder
+            .forAddress(caller)
+            .withValue(""Hello from the future!""));
+    }
 }
 ```
 
-## Persistence
-
-Stateful Functions treats state as a first class citizen and so all stateful functions can easily define state that is automatically made fault tolerant by the runtime.
-All stateful functions may contain state by merely defining one or more persisted fields.
+## Egress
 
-The simplest way to get started is with a ``PersistedValue``, which is defined by its name and the class of the type that it stores.
-The data is always scoped to a specific function type and identifier.
-Below is a stateful function that greets users based on the number of times they have been seen.
-
-{{< hint info >}}
-All **PersistedValue**, **PersistedTable**, and **PersistedAppendingBuffer** fields must be marked with a **@Persisted** annotation or they will not be made fault tolerant by the runtime.
-{{< /hint >}}
+Functions can message other stateful functions and egresses, exit points for sending messages to the outside world.
+As with other messages, egress messages are always well-typed. 
+Additionally, they contain metadata pertinent to the specific egress type.
 
+{{< tabs ""egress"" >}}
+{{< tab ""Apache Kafka"" >}}
 ```java
-package org.apache.flink.statefun.docs;
-
-import org.apache.flink.statefun.sdk.Context;
-import org.apache.flink.statefun.sdk.FunctionType;
-import org.apache.flink.statefun.sdk.StatefulFunction;
-import org.apache.flink.statefun.sdk.annotations.Persisted;
-import org.apache.flink.statefun.sdk.state.PersistedValue;
-
-public class FnUserGreeter implements StatefulFunction {
-
-	public static FunctionType TYPE = new FunctionType(""example"", ""greeter"");
-
-	@Persisted
-	private final PersistedValue<Integer> count = PersistedValue.of(""count"", Integer.class);
-
-	public void invoke(Context context, Object input) {
-		String userId = context.self().id();
-		int seen = count.getOrDefault(0);
-
-		switch (seen) {
-			case 0:
-				System.out.println(String.format(""Hello %s!"", userId));
-				break;
-			case 1:
-				System.out.println(""Hello Again!"");
-				break;
-			case 2:
-				System.out.println(""Third time is the charm :)"");
-				break;
-			default:
-				System.out.println(String.format(""Hello for the %d-th time"", seen + 1));
-		}
-
-		count.set(seen + 1);
-	}
-}
-```
+import java.util.concurrent.CompletableFuture;
+import org.apache.flink.statefun.sdk.java.Context;
+import org.apache.flink.statefun.sdk.java.StatefulFunction;
+import org.apache.flink.statefun.sdk.java.TypeName;
+import org.apache.flink.statefun.sdk.java.ValueSpec;
+import org.apache.flink.statefun.sdk.java.message.Message;
+import org.apache.flink.statefun.sdk.java.io.KafkaEgressMessage;
 
-``PersistedValue`` comes with the right primitive methods to build powerful stateful applications.
-Calling ``PersistedValue#get`` will return the current value of an object stored in state, or ``null`` if nothing is set.
-Conversely, ``PersistedValue#set`` will update the value in state and ``PersistedValue#clear`` will delete the value from state.
+public class GreeterFn implements StatefulFunction {
 
-### Collection Types
+    static final TypeName TYPE = TypeName.forNameFromString(""com.example.fns/greeter"");
 
-Along with ``PersistedValue``, the Java SDK supports two persisted collection types.
-``PersistedTable`` is a collection of keys and values, and ``PersistedAppendingBuffer`` is an append-only buffer.
+    static final TypeName KAFKA_EGRESS = TypeName.forNameFromString(""com.example/greets"");
 
-These types are functionally equivalent to ``PersistedValue<Map>`` and ``PersistedValue<Collection>`` respectively but may provide better performance in some situations.
+    static final ValueSpec<Integer> SEEN = ValueSpec.named(""seen"").withIntType();
 
-```java
-@Persisted
-PersistedTable<String, Integer> table = PersistedTable.of(""my-table"", String.class, Integer.class);
+    @Override 
+    CompletableFuture<Void> apply(Context context, Message message) {
+        if (!message.is(User.TYPE)) {
+            throw new IllegalStateException(""Unknown type"");
+        }
 
-@Persisted
-PersistedAppendingBuffer<Integer> buffer = PersistedAppendingBuffer.of(""my-buffer"", Integer.class);
-```
+        User user = message.as(User.TYPE);
+        String name = user.getName();
 
-### Dynamic State Registration
+        var storage = context.storage();
+        var seen = storage.get(SEEN).orElse(0);
+        storage.set(SEEN, seen + 1);
 
-Using the above state types, a function's persisted state must be defined eagerly. You cannot use those state types to
-register a new persisted state during invocations (i.e., in the ``invoke`` method) or after the function instance is created.
+        context.send(
+            KafkaEgressMessage.forEgress(KAFKA_EGRESS)
+                .withTopic(""greetings"")
+                .withUtf8Key(name)
+                .withUtf8Value(""Hello "" + name + "" for the "" + seen + ""th time!"")
+                .build());
 
-If dynamic state registration is required, it can be achieved using a ``PersistedStateRegistry``:
-
-```java
-import org.apache.flink.statefun.sdk.Context;
-import org.apache.flink.statefun.sdk.FunctionType;
-import org.apache.flink.statefun.sdk.StatefulFunction;
-import org.apache.flink.statefun.sdk.annotations.Persisted;
-import org.apache.flink.statefun.sdk.state.PersistedStateRegistry;
-import org.apache.flink.statefun.sdk.state.PersistedValue;
-
-public class MyFunction implements StatefulFunction {
-
-	@Persisted
-	private final PersistedStateRegistry registry = new PersistedStateRegistry();
-
-	private PersistedValue<Integer> value;
-
-	public void invoke(Context context, Object input) {
-		if (value == null) {
-			value = PersistedValue.of(""my-value"", Integer.class);
-			registry.registerValue(value);
-		}
-		int count = value.getOrDefault(0);
-		// ...
-	}
+        return context.done();
+    }
 }
 ```
-
-Note how the ``PersistedValue`` field doesn't need to be annotated with the ``@Persisted`` annotations, and is initially
-empty. The state object is dynamically created during invocation and registered with the ``PersistedStateRegistry`` so
-that the system picks it up to be managed for fault-tolerance.
-
-### State Expiration
-
-Persisted states may be configured to expire and be deleted after a specified duration.
-This is supported by all types of state:
-
+{{< /tab >}}
+{{< tab ""Amazon Kinesis"" >}}
 ```java
-@Persisted
-PersistedValue<Integer> value = PersistedValue.of(
-    ""my-value"",
-    Integer.class,
-    Expiration.expireAfterWriting(Duration.ofHours(1)));
-
-@Persisted
-PersistedTable<String, Integer> table = PersistedTable.of(
-    ""my-table"",
-    String.class,
-    Integer.class,
-    Expiration.expireAfterWriting(Duration.ofMinutes(5)));
-
-@Persisted
-PersistedAppendingBuffer<Integer> buffer = PersistedAppendingBuffer.of(
-    ""my-buffer"",
-    Integer.class,
-    Expiration.expireAfterWriting(Duration.ofSeconds(30)));
-```
+import java.util.concurrent.CompletableFuture;
+import org.apache.flink.statefun.sdk.java.Context;
+import org.apache.flink.statefun.sdk.java.StatefulFunction;
+import org.apache.flink.statefun.sdk.java.TypeName;
+import org.apache.flink.statefun.sdk.java.ValueSpec;
+import org.apache.flink.statefun.sdk.java.message.Message;
+import org.apache.flink.statefun.sdk.java.io.KinesisEgressMessage;
 
-There are two expiration modes supported:
+public class GreeterFn implements StatefulFunction {
 
-```java
-Expiration.expireAfterWriting(...)
+    static final TypeName TYPE = TypeName.forNameFromString(""com.example.fns/greeter"");","[{'comment': 'forNameFromString  => typeNameFromString', 'commenter': 'afedulov'}]"
211,docs/content/docs/sdk/java.md,"@@ -29,451 +29,395 @@ under the License.
 Stateful functions are the building blocks of applications; they are atomic units of isolation, distribution, and persistence.
 As objects, they encapsulate the state of a single entity (e.g., a specific user, device, or session) and encode its behavior.
 Stateful functions can interact with each other, and external systems, through message passing.
-The Java SDK is supported as an [embedded module]({{< ref ""docs/sdk/overview#embedded-module"" >}}).
 
 To get started, add the Java SDK as a dependency to your application.
 
-{{< artifact statefun-sdk >}}
+{{< artifact statefun-sdk-java >}}
 
 ## Defining A Stateful Function
 
-A stateful function is any class that implements the ``StatefulFunction`` interface.
-The following is an example of a simple hello world function.
+A stateful function is any class that implements the `StatefulFunction` interface.
+In the following example, a `StatefulFunction` maintains a count for every user
+of an application, emitting a customized greeting.
 
 ```java
-package org.apache.flink.statefun.docs;
-
-import org.apache.flink.statefun.sdk.Context;
-import org.apache.flink.statefun.sdk.StatefulFunction;
-
-public class FnHelloWorld implements StatefulFunction {
+import java.util.concurrent.CompletableFuture;
+import org.apache.flink.statefun.sdk.java.Context;
+import org.apache.flink.statefun.sdk.java.StatefulFunction;
+import org.apache.flink.statefun.sdk.java.TypeName;
+import org.apache.flink.statefun.sdk.java.ValueSpec;
+import org.apache.flink.statefun.sdk.java.message.Message;
 
-	@Override
-	public void invoke(Context context, Object input) {
-		System.out.println(""Hello "" + input.toString());
-	}
-}
-```
+public class GreeterFn implements StatefulFunction {
 
-Functions process each incoming message through their ``invoke`` method.
-Input's are untyped and passed through the system as a ``java.lang.Object`` so one function can potentially process multiple types of messages.
+    static final TypeName TYPE = TypeName.forNameFromString(""com.example.fns/greeter"");
 
-The ``Context`` provides metadata about the current message and function, and is how you can call other functions or external systems.
-Functions are invoked based on a function type and unique identifier.
+    static final TypeName INBOX = TypeName.forNameFromString(""com.example.fns/inbox"");
 
-### Stateful Match Function 
+    static final ValueSpec<Integer> SEEN = ValueSpec.named(""seen"").withIntType();
 
-Stateful functions provide a powerful abstraction for working with events and state, allowing developers to build components that can react to any kind of message.
-Commonly, functions only need to handle a known set of message types, and the ``StatefulMatchFunction`` interface provides an opinionated solution to that problem.
+    @Override 
+    CompletableFuture<Void> apply(Context context, Message message) {
+        if (!message.is(User.TYPE)) {
+            throw new IllegalStateException(""Unknown type"");
+        }
 
-#### Simple Match Function
+        User user = message.as(User.TYPE);
+        String name = user.getName();
 
-Stateful match functions are an opinionated variant of stateful functions for precisely this pattern.
-Developers outline expected types, optional predicates, and well-typed business logic and let the system dispatch each input to the correct action.
-Variants are bound inside a ``configure`` method that is executed once the first time an instance is loaded.
+        var storage = context.storage();
+        var seen = storage.get(SEEN).orElse(0);
+        storage.set(SEEN, seen + 1);
 
-```java
-package org.apache.flink.statefun.docs.match;
+        context.send(
+            MessageBuilder.forAddress(INBOX, name)
+                .withValue(""Hello "" + name + "" for the "" + seen + ""th time!"")
+                .build());
 
-import org.apache.flink.statefun.sdk.Context;
-import org.apache.flink.statefun.sdk.match.MatchBinder;
-import org.apache.flink.statefun.sdk.match.StatefulMatchFunction;
+        return context.done();
+    }
+}
+```
 
-public class FnMatchGreeter extends StatefulMatchFunction {
+This code declares a greeter function that will be [registered](#exposing-functions) under the logical type name `com.example.fns/greeter`. Type names must take the form `<namesapce>/<name>`.
+It contains a single `ValueSpec`, which is implicitly scoped to the current address and stores an integer.
 
-	@Override
-	public void configure(MatchBinder binder) {
-		binder
-			.predicate(Customer.class, this::greetCustomer)
-			.predicate(Employee.class, Employee::isManager, this::greetManager)
-			.predicate(Employee.class, this::greetEmployee);
-	}
+Every time a message is sent a greeter, it first validates the message containing a `User` and extracts its name. Both messages and state are strongly typed - either one of the default [built-in types]({{< ref ""docs/sdk/appendix#types"" >}}) - or a [custom type](#types) as in this case.
 
-	private void greetCustomer(Context context, Customer message) {
-		System.out.println(""Hello customer "" + message.getName());
-	}
+The function finally builds a custom greeting for the user.
+The number of times that particular user has been seen so far is queried from the state store and updated
+and the greeting is sent to the users' inbox (another function type). 
 
-	private void greetEmployee(Context context, Employee message) {
-		System.out.println(""Hello employee "" + message.getEmployeeId());
-	}
+## Types
 
-	private void greetManager(Context context, Employee message) {
-		System.out.println(""Hello manager "" + message.getEmployeeId());
-	}
-}
-```
+Stateful Functions strongly types ll messages and state values. 
+Because they run in a distributed manner and state values are persisted to stable storage, Stateful Functions aims to provide efficient and easy to user serializers. 
 
-#### Making Your Function Complete
+Out of the box, all SDKs offer a set of highly optimized serializers for common primitive types; boolean, numerics, and strings.
+Additionally, users are encouraged to plug-in custom types to model more complex data structures. 
 
-Similar to the first example, match functions are partial by default and will throw an ``IllegalStateException`` on any input that does not match any branch.
-They can be made complete by providing an ``otherwise`` clause that serves as a catch-all for unmatched input, think of it as a default clause in a Java switch statement.
-The ``otherwise`` action takes its message as an untyped ``java.lang.Object``, allowing you to handle any unexpected messages.
+In the [example above](#defining-a-stateful-function), the greeter function consumes `User` messages, a POJO type containing several fields.
+By defining a custom type, this object can be passed transparently between functions and stored in state.
+And because the type is tied to a logical typename, instead of the physical Java class, it can be passed to functions written in other langauge SDKs. 
 
 ```java
-package org.apache.flink.statefun.docs.match;
-
-import org.apache.flink.statefun.sdk.Context;
-import org.apache.flink.statefun.sdk.match.MatchBinder;
-import org.apache.flink.statefun.sdk.match.StatefulMatchFunction;
-
-public class FnMatchGreeterWithCatchAll extends StatefulMatchFunction {
-
-	@Override
-	public void configure(MatchBinder binder) {
-		binder
-			.predicate(Customer.class, this::greetCustomer)
-			.predicate(Employee.class, Employee::isManager, this::greetManager)
-			.predicate(Employee.class, this::greetEmployee)
-			.otherwise(this::catchAll);
-	}
-
-	private void greetCustomer(Context context, Customer message) {
-		System.out.println(""Hello customer "" + message.getName());
-	}
-
-	private void greetEmployee(Context context, Employee message) {
-		System.out.println(""Hello employee "" + message.getEmployeeId());
-	}
-
-	private void greetManager(Context context, Employee message) {
-		System.out.println(""Hello manager "" + message.getEmployeeId());
-	}
-
-	private void catchAll(Context context, Object message) {
-		System.out.println(""Hello unexpected message"");
-	}
-}
-```
+import com.fasterxml.jackson.annotation.JsonCreator;
+import com.fasterxml.jackson.annotation.JsonProperty;
+import com.fasterxml.jackson.databind.ObjectMapper;
+import org.apache.flink.statefun.sdk.java.TypeName;
+import org.apache.flink.statefun.sdk.java.types.SimpleType;
+import org.apache.flink.statefun.sdk.java.types.Type;
+import java.util.Objects;
 
-#### Action Resolution Order
+public class User {
 
-Match functions will always match actions from most to least specific using the following resolution rules.
+    private static final ObjectMapper mapper = new ObjectMapper();
 
-First, find an action that matches the type and predicate. If two predicates will return true for a particular input, the one registered in the binder first wins.
-Next, search for an action that matches the type but does not have an associated predicate.
-Finally, if a catch-all exists, it will be executed or an ``IllegalStateException`` will be thrown.
+    public static final Type<User> TYPE = SimpleType.simpleImmutableTypeFrom(
+        TypeName.typeNameFromString(""com.example/User""),
+        mapper:writeValueAsBytes,
+        bytes -> mapper.readValue(byes, User.class));
 
-## Function Types and Messaging
+    private final String name;
 
-In Java, function types are defined as logical pointers composed of a namespace and name.
-The type is bound to the implementing class in the [module]({{< ref ""docs/sdk/overview#embedded-module"" >}}) definition.
-Below is an example function type for the hello world function.
+    private final String favoriteColor;
 
-```java
-package org.apache.flink.statefun.docs;
+    @JsonCreator
+    public User(
+        @JsonProperty(""name"") String name,
+        @JsonProperty(""favorite_color"" String favoriteColor)) {
 
-import org.apache.flink.statefun.sdk.FunctionType;
+        this.name = Objects.requireNonNull(name);
+        this.favoriteColor = Objects.requireNonNull(favoriteColor);
+    }
 
-/** A function type that will be bound to {@link FnHelloWorld}. */
-public class Identifiers {
+    public String getName() {
+        return name;
+    }
 
-  public static final FunctionType HELLO_TYPE = new FunctionType(""apache/flink"", ""hello"");
-}
+    public String getFavoriteColor() {
+        return favoriteColor;
+    }
+
+    @Override
+    public String toString() {
+        return ""User{name="" name + "",favoriteColor="" favoriteColor + ""}""
+    }
 ```
 
-This type can then be referenced from other functions to create an address and message a particular instance.
+## State
 
-```java
-package org.apache.flink.statefun.docs;
+Stateful Functions treats state as a first class citizen and so all functions can easily define state that is automatically made fault tolerant by the runtime.
+State declaration is as simple as defining one or more `ValueSpec`'s describing your state values.
+Value specifications are defined with a unique (to the function) name and [type](#types).
+At runtime, functions can `get`, `set`, and `remove` state values scoped to the address of the current message.
 
-import org.apache.flink.statefun.sdk.Context;
-import org.apache.flink.statefun.sdk.StatefulFunction;
-
-/** A simple stateful function that sends a message to the user with id ""user1"" */
-public class FnCaller implements StatefulFunction {
+{{< hint info >}}
+All value specificiations must be earerly registered in the `StatefulFuctionSpec` when composing
+the applications [RequestReplyHandler](#exposing-functions).
+{{< /hint >}}
 
-  @Override
-  public void invoke(Context context, Object input) {
-    context.send(Identifiers.HELLO_TYPE, ""user1"", new MyUserMessage());
-  }
-}
+```java
+// Value specification for a state named `seen` 
+// with the primitive integer type
+ValueSpec
+    .named(""seen"")
+    .withIntType();
+
+// Value specification with a custom type
+ValueSpec
+    .name(""user"")
+    .withCustomType(User.TYPE);
 ```
 
-## Sending Delayed Messages
+### State Expiration
 
-Functions are able to send messages on a delay so that they will arrive after some duration.
-Functions may even send themselves delayed messages that can serve as a callback.
-The delayed message is non-blocking so functions will continue to process records between the time a delayed message is sent and received.
+By default, state values are persisted until manually `remove`d by the user.
+Optionally, they may be configured to expire and be automatically deleted after a specified duration.
 
 ```java
-package org.apache.flink.statefun.docs.delay;
-
-import java.time.Duration;
-import org.apache.flink.statefun.sdk.Context;
-import org.apache.flink.statefun.sdk.StatefulFunction;
-
-public class FnDelayedMessage implements StatefulFunction {
-
-	@Override
-	public void invoke(Context context, Object input) {
-		if (input instanceof Message) {
-			System.out.println(""Hello"");
-			context.sendAfter(Duration.ofMinutes(1), context.self(), new DelayedMessage());
-		}
-
-		if (input instanceof DelayedMessage) {
-			System.out.println(""Welcome to the future!"");
-		}
-	}
-}
+// Value specification that will automatically
+// delete the value if the function instance goes 
+// more than 30 minutes without being called
+ValueSpec
+    .named(""seen"")
+    .thatExpiresAfterCall(Duration.ofDays(1))
+    .withIntType();
+
+// Value specification that will automatically
+// delete the value if it goes more than 1 day
+// without being written
+ValueSpec
+    .named(""seen"")
+    .thatExpireAfterWrite(Duration.ofDays(1))
+    .withIntType();
 ```
 
-## Completing Async Requests
-
-When interacting with external systems, such as a database or API, one needs to take care that communication delay with the external system does not dominate the application’s total work.
-Stateful Functions allows registering a Java ``CompletableFuture`` that will resolve to a value at some point in the future.
-Future's are registered along with a metadata object that provides additional context about the caller.
+## Sending Delayed Messages
 
-When the future completes, either successfully or exceptionally, the caller function type and id will be invoked with a ``AsyncOperationResult``.
-An asynchronous result can complete in one of three states:
+Functions can send messages on a delay so that they will arrive after some duration.
+They may even send themselves delayed messages that can serve as a callback.
+The delayed message is non-blocking, so functions will continue to process records between when a delayed message is sent and received.
+Additionally, they are fault-tolerant and never lost, even when recovering from failure. 
 
-### Success
+This example sends a response back to the calling function after a 30 minute delay.
 
-The asynchronous operation has succeeded, and the produced result can be obtained via ``AsyncOperationResult#value``.
+```java
+import java.util.concurrent.CompletableFuture;
+import java.time.Duration;
 
-### Failure
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import org.apache.flink.statefun.sdk.java.Context;
+import org.apache.flink.statefun.sdk.java.StatefulFunction;
+import org.apache.flink.statefun.sdk.java.message.Message;
 
-The asynchronous operation has failed, and the cause can be obtained via ``AsyncOperationResult#throwable``.
+public class DelayedFn implements StatefulFunction {
 
-### Unknown
+    private static final Logger LOG = LoggerFactory.getLogger(DelayedFn.class);
 
-The stateful function was restarted, possibly on a different machine, before the ``CompletableFuture`` was completed, therefore it is unknown what is the status of the asynchronous operation.
+    static final TypeName TYPE = TypeName.forNameFromString(""com.example.fns/delayed"");
 
-```java
-package org.apache.flink.statefun.docs.async;
+    @Override 
+    CompletableFuture<Void> apply(Context context, Message message) {
+        if (!context.caller().isPresent()) {
+            LOG.debug(""Message has no known caller meaning it was sent directly from an ingress"");
+            return;
+        }
 
-import java.util.concurrent.CompletableFuture;
-import org.apache.flink.statefun.sdk.AsyncOperationResult;
-import org.apache.flink.statefun.sdk.Context;
-import org.apache.flink.statefun.sdk.StatefulFunction;
-
-@SuppressWarnings(""unchecked"")
-public class EnrichmentFunction implements StatefulFunction {
-
-	private final QueryService client;
-
-	public EnrichmentFunction(QueryService client) {
-		this.client = client;
-	}
-
-	@Override
-	public void invoke(Context context, Object input) {
-		if (input instanceof User) {
-			onUser(context, (User) input);
-		} else if (input instanceof AsyncOperationResult) {
-			onAsyncResult((AsyncOperationResult) input);
-		}
-	}
-
-	private void onUser(Context context, User user) {
-		CompletableFuture<UserEnrichment> future = client.getDataAsync(user.getUserId());
-		context.registerAsyncOperation(user, future);
-	}
-
-	private void onAsyncResult(AsyncOperationResult<User, UserEnrichment> result) {
-		if (result.successful()) {
-			User metadata = result.metadata();
-			UserEnrichment value = result.value();
-			System.out.println(
-				String.format(""Successfully completed future: %s %s"", metadata, value));
-		} else if (result.failure()) {
-			System.out.println(
-				String.format(""Something has gone terribly wrong %s"", result.throwable()));
-		} else {
-			System.out.println(""Not sure what happened, maybe retry"");
-		}
-	}
+        var caller = context.caller().get();
+        context.sendAfter(Duration.ofMinutes(30), MessageBuilder
+            .forAddress(caller)
+            .withValue(""Hello from the future!""));
+    }
 }
 ```
 
-## Persistence
-
-Stateful Functions treats state as a first class citizen and so all stateful functions can easily define state that is automatically made fault tolerant by the runtime.
-All stateful functions may contain state by merely defining one or more persisted fields.
+## Egress
 
-The simplest way to get started is with a ``PersistedValue``, which is defined by its name and the class of the type that it stores.
-The data is always scoped to a specific function type and identifier.
-Below is a stateful function that greets users based on the number of times they have been seen.
-
-{{< hint info >}}
-All **PersistedValue**, **PersistedTable**, and **PersistedAppendingBuffer** fields must be marked with a **@Persisted** annotation or they will not be made fault tolerant by the runtime.
-{{< /hint >}}
+Functions can message other stateful functions and egresses, exit points for sending messages to the outside world.
+As with other messages, egress messages are always well-typed. 
+Additionally, they contain metadata pertinent to the specific egress type.
 
+{{< tabs ""egress"" >}}
+{{< tab ""Apache Kafka"" >}}
 ```java
-package org.apache.flink.statefun.docs;
-
-import org.apache.flink.statefun.sdk.Context;
-import org.apache.flink.statefun.sdk.FunctionType;
-import org.apache.flink.statefun.sdk.StatefulFunction;
-import org.apache.flink.statefun.sdk.annotations.Persisted;
-import org.apache.flink.statefun.sdk.state.PersistedValue;
-
-public class FnUserGreeter implements StatefulFunction {
-
-	public static FunctionType TYPE = new FunctionType(""example"", ""greeter"");
-
-	@Persisted
-	private final PersistedValue<Integer> count = PersistedValue.of(""count"", Integer.class);
-
-	public void invoke(Context context, Object input) {
-		String userId = context.self().id();
-		int seen = count.getOrDefault(0);
-
-		switch (seen) {
-			case 0:
-				System.out.println(String.format(""Hello %s!"", userId));
-				break;
-			case 1:
-				System.out.println(""Hello Again!"");
-				break;
-			case 2:
-				System.out.println(""Third time is the charm :)"");
-				break;
-			default:
-				System.out.println(String.format(""Hello for the %d-th time"", seen + 1));
-		}
-
-		count.set(seen + 1);
-	}
-}
-```
+import java.util.concurrent.CompletableFuture;
+import org.apache.flink.statefun.sdk.java.Context;
+import org.apache.flink.statefun.sdk.java.StatefulFunction;
+import org.apache.flink.statefun.sdk.java.TypeName;
+import org.apache.flink.statefun.sdk.java.ValueSpec;
+import org.apache.flink.statefun.sdk.java.message.Message;
+import org.apache.flink.statefun.sdk.java.io.KafkaEgressMessage;
 
-``PersistedValue`` comes with the right primitive methods to build powerful stateful applications.
-Calling ``PersistedValue#get`` will return the current value of an object stored in state, or ``null`` if nothing is set.
-Conversely, ``PersistedValue#set`` will update the value in state and ``PersistedValue#clear`` will delete the value from state.
+public class GreeterFn implements StatefulFunction {
 
-### Collection Types
+    static final TypeName TYPE = TypeName.forNameFromString(""com.example.fns/greeter"");
 
-Along with ``PersistedValue``, the Java SDK supports two persisted collection types.
-``PersistedTable`` is a collection of keys and values, and ``PersistedAppendingBuffer`` is an append-only buffer.
+    static final TypeName KAFKA_EGRESS = TypeName.forNameFromString(""com.example/greets"");
 
-These types are functionally equivalent to ``PersistedValue<Map>`` and ``PersistedValue<Collection>`` respectively but may provide better performance in some situations.
+    static final ValueSpec<Integer> SEEN = ValueSpec.named(""seen"").withIntType();
 
-```java
-@Persisted
-PersistedTable<String, Integer> table = PersistedTable.of(""my-table"", String.class, Integer.class);
+    @Override 
+    CompletableFuture<Void> apply(Context context, Message message) {
+        if (!message.is(User.TYPE)) {
+            throw new IllegalStateException(""Unknown type"");
+        }
 
-@Persisted
-PersistedAppendingBuffer<Integer> buffer = PersistedAppendingBuffer.of(""my-buffer"", Integer.class);
-```
+        User user = message.as(User.TYPE);
+        String name = user.getName();
 
-### Dynamic State Registration
+        var storage = context.storage();
+        var seen = storage.get(SEEN).orElse(0);
+        storage.set(SEEN, seen + 1);
 
-Using the above state types, a function's persisted state must be defined eagerly. You cannot use those state types to
-register a new persisted state during invocations (i.e., in the ``invoke`` method) or after the function instance is created.
+        context.send(
+            KafkaEgressMessage.forEgress(KAFKA_EGRESS)
+                .withTopic(""greetings"")
+                .withUtf8Key(name)
+                .withUtf8Value(""Hello "" + name + "" for the "" + seen + ""th time!"")
+                .build());
 
-If dynamic state registration is required, it can be achieved using a ``PersistedStateRegistry``:
-
-```java
-import org.apache.flink.statefun.sdk.Context;
-import org.apache.flink.statefun.sdk.FunctionType;
-import org.apache.flink.statefun.sdk.StatefulFunction;
-import org.apache.flink.statefun.sdk.annotations.Persisted;
-import org.apache.flink.statefun.sdk.state.PersistedStateRegistry;
-import org.apache.flink.statefun.sdk.state.PersistedValue;
-
-public class MyFunction implements StatefulFunction {
-
-	@Persisted
-	private final PersistedStateRegistry registry = new PersistedStateRegistry();
-
-	private PersistedValue<Integer> value;
-
-	public void invoke(Context context, Object input) {
-		if (value == null) {
-			value = PersistedValue.of(""my-value"", Integer.class);
-			registry.registerValue(value);
-		}
-		int count = value.getOrDefault(0);
-		// ...
-	}
+        return context.done();
+    }
 }
 ```
-
-Note how the ``PersistedValue`` field doesn't need to be annotated with the ``@Persisted`` annotations, and is initially
-empty. The state object is dynamically created during invocation and registered with the ``PersistedStateRegistry`` so
-that the system picks it up to be managed for fault-tolerance.
-
-### State Expiration
-
-Persisted states may be configured to expire and be deleted after a specified duration.
-This is supported by all types of state:
-
+{{< /tab >}}
+{{< tab ""Amazon Kinesis"" >}}
 ```java
-@Persisted
-PersistedValue<Integer> value = PersistedValue.of(
-    ""my-value"",
-    Integer.class,
-    Expiration.expireAfterWriting(Duration.ofHours(1)));
-
-@Persisted
-PersistedTable<String, Integer> table = PersistedTable.of(
-    ""my-table"",
-    String.class,
-    Integer.class,
-    Expiration.expireAfterWriting(Duration.ofMinutes(5)));
-
-@Persisted
-PersistedAppendingBuffer<Integer> buffer = PersistedAppendingBuffer.of(
-    ""my-buffer"",
-    Integer.class,
-    Expiration.expireAfterWriting(Duration.ofSeconds(30)));
-```
+import java.util.concurrent.CompletableFuture;
+import org.apache.flink.statefun.sdk.java.Context;
+import org.apache.flink.statefun.sdk.java.StatefulFunction;
+import org.apache.flink.statefun.sdk.java.TypeName;
+import org.apache.flink.statefun.sdk.java.ValueSpec;
+import org.apache.flink.statefun.sdk.java.message.Message;
+import org.apache.flink.statefun.sdk.java.io.KinesisEgressMessage;
 
-There are two expiration modes supported:
+public class GreeterFn implements StatefulFunction {
 
-```java
-Expiration.expireAfterWriting(...)
+    static final TypeName TYPE = TypeName.forNameFromString(""com.example.fns/greeter"");
 
-Expiration.expireAfterReadingOrWriting(...)
-```
+    static final TypeName KINESIS_EGRESS = TypeName.forNameFromString(""com.example/greets"");","[{'comment': 'forNameFromString  => typeNameFromString', 'commenter': 'afedulov'}]"
269,statefun-sdk-js/jest.config.js,"@@ -0,0 +1,14 @@
+export default {
+    ""roots"": [
+      ""<rootDir>""
+    ],
+    ""testMatch"": [
+      ""**/test/**/*.+(ts|tsx|js)"",
+      ""**/?(*.)+(spec|test).+(ts|tsx|js)""
+    ],
+    ""transform"": {
+      ""^.+\\.(ts|tsx)$"": ""ts-jest""
+    },
+    ""preset"": ""ts-jest"",
+    ""testEnvironment"": 'node'","[{'comment': 'nit: inconsistent quotes', 'commenter': 'Airblader'}]"
269,statefun-sdk-js/package.json,"@@ -0,0 +1,31 @@
+{
+  ""name"": ""apache-flink-statefun"",
+  ""version"": ""3.2-SNAPSHOT"",","[{'comment': 'I assume this is the ""StateFun version"" somehow?', 'commenter': 'Airblader'}]"
269,statefun-sdk-js/package.json,"@@ -0,0 +1,31 @@
+{
+  ""name"": ""apache-flink-statefun"",
+  ""version"": ""3.2-SNAPSHOT"",
+  ""description"": ""JavaScript SDK for Apache Flink Stateful functions"",
+  ""main"": ""dist/statefun.js"",
+  ""types"": ""dist/statefun.d.ts"",
+  ""scripts"": {
+    ""build"": ""tsc --noEmitOnError"",
+    ""test"": ""jest""
+  },
+  ""files"": [
+    ""dist""
+  ],
+  ""author"": ""Apache Software Foundation"",
+  ""license"": ""Apache-2.0"",
+  ""email"": ""dev@flink.apache.org"",
+  ""repository"": {
+    ""type"": ""git"",
+    ""url"": ""https://github.com/apache/flink-statefun.git""
+  },
+  ""homepage"": ""https://github.com/apache/flink-statefun"",
+  ""dependencies"": {
+    ""google-protobuf"": ""^3.18.0-rc.2""","[{'comment': 'Is there maybe a better version to use than an RC? Or is there a specific reason to use it?', 'commenter': 'Airblader'}]"
269,statefun-sdk-js/smoketest/commands_pb.js,"@@ -0,0 +1,2081 @@
+// source: commands.proto","[{'comment': 'Is this a generated file? Should it be in git?', 'commenter': 'Airblader'}]"
269,statefun-sdk-js/smoketest/smoke.js,"@@ -0,0 +1,154 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+require(""./commands_pb"");
+
+const http = require(""http"");
+const {egressMessageBuilder, messageBuilder, StateFun, Context} = require(""../dist/statefun"");
+
+// noinspection JSUnresolvedVariable
+const SourceCommandType = StateFun.protoType(""statefun.smoke.e2e/source-command"", proto.org.apache.flink.statefun.e2e.smoke.SourceCommand);
+
+// noinspection JSUnresolvedVariable
+const CommandsType = StateFun.protoType(""statefun.smoke.e2e/commands"", proto.org.apache.flink.statefun.e2e.smoke.Commands);
+
+// noinspection JSUnresolvedVariable
+const VerificationResultType = StateFun.protoType(""statefun.smoke.e2e/verification-result"", proto.org.apache.flink.statefun.e2e.smoke.VerificationResult);
+
+// noinspection JSValidateJSDoc
+/**
+ * @param {Context} context
+ * @param {?proto.org.apache.flink.statefun.e2e.smoke.Command.Send} send
+ */
+function applySend(context, send) {
+    context.send(messageBuilder({
+        typename: ""statefun.smoke.e2e/command-interpreter-fn"",
+        id: `${send.getTarget()}`,
+        value: send.getCommands(),
+        valueType: CommandsType
+    }));
+}
+
+// noinspection JSValidateJSDoc","[{'comment': ""I think it'd be good to get rid of all of these noinspections still. The smoketest is kind of a showcase, right? Then we'd probably not want this scattered everywhere."", 'commenter': 'Airblader'}]"
269,statefun-sdk-js/smoketest/smoke.js,"@@ -0,0 +1,154 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+require(""./commands_pb"");
+
+const http = require(""http"");
+const {egressMessageBuilder, messageBuilder, StateFun, Context} = require(""../dist/statefun"");
+
+// noinspection JSUnresolvedVariable
+const SourceCommandType = StateFun.protoType(""statefun.smoke.e2e/source-command"", proto.org.apache.flink.statefun.e2e.smoke.SourceCommand);
+
+// noinspection JSUnresolvedVariable
+const CommandsType = StateFun.protoType(""statefun.smoke.e2e/commands"", proto.org.apache.flink.statefun.e2e.smoke.Commands);
+
+// noinspection JSUnresolvedVariable
+const VerificationResultType = StateFun.protoType(""statefun.smoke.e2e/verification-result"", proto.org.apache.flink.statefun.e2e.smoke.VerificationResult);
+
+// noinspection JSValidateJSDoc
+/**
+ * @param {Context} context
+ * @param {?proto.org.apache.flink.statefun.e2e.smoke.Command.Send} send
+ */
+function applySend(context, send) {
+    context.send(messageBuilder({
+        typename: ""statefun.smoke.e2e/command-interpreter-fn"",
+        id: `${send.getTarget()}`,
+        value: send.getCommands(),
+        valueType: CommandsType
+    }));
+}
+
+// noinspection JSValidateJSDoc
+/**
+ * @param {Context} context
+ * @param {?proto.org.apache.flink.statefun.e2e.smoke.Command.IncrementState} increment
+ */
+function applyInc(context, increment) {
+    context.storage.state += 1;
+}
+
+// noinspection JSValidateJSDoc
+/**
+ * @param {Context} context
+ * @param {?proto.org.apache.flink.statefun.e2e.smoke.Command.SendAfter} sendAfter
+ */
+function applySendAfter(context, sendAfter) {
+    context.sendAfter(1_000,
+        messageBuilder({
+            typename: ""statefun.smoke.e2e/command-interpreter-fn"",
+            id: `${sendAfter.getTarget()}`,
+            value: sendAfter.getCommands(),
+            valueType: CommandsType
+        }));
+}
+
+// noinspection JSValidateJSDoc
+/**
+ * @param {Context} context
+ * @param {?proto.org.apache.flink.statefun.e2e.smoke.Command.SendEgress} sendEgress
+ */
+function applyEgress(context, sendEgress) {
+    context.send(egressMessageBuilder({
+        typename: ""statefun.smoke.e2e/discard-sink"",
+        value: 'discarded-message',
+        valueType: StateFun.stringType()
+    }));
+}
+
+// noinspection JSValidateJSDoc
+/**
+ * @param {Context} context
+ * @param {?proto.org.apache.flink.statefun.e2e.smoke.Command.Verify} verify
+ */
+function applyVerify(context, verify) {
+    const id = context.self.id;
+    const actual = context.storage.state;
+
+    // noinspection JSUnresolvedVariable
+    let result = new proto.org.apache.flink.statefun.e2e.smoke.VerificationResult();
+
+    result.setActual(actual);
+    result.setExpected(verify.getExpected());
+    result.setId(parseInt(id));
+
+    context.send(egressMessageBuilder({
+        typename: ""statefun.smoke.e2e/verification-sink"",
+        value: result,
+        valueType: VerificationResultType
+    }));
+}
+
+// noinspection JSValidateJSDoc
+/**
+ *
+ * @param {Context} context
+ * @param {proto.org.apache.flink.statefun.e2e.smoke.Commands} commands
+ */
+function applyCommands(context, commands) {
+    for (let command of commands.getCommandList()) {
+        if (command.hasSend()) {
+            applySend(context, command.getSend());
+        } else if (command.hasIncrement()) {
+            applyInc(context, command.getIncrement());
+        } else if (command.hasSendAfter()) {
+            applySendAfter(context, command.getSendAfter());
+        } else if (command.hasSendEgress()) {
+            applyEgress(context, command.getSendEgress())
+        } else if (command.hasVerify()) {
+            applyVerify(context, command.getVerify());
+        } else {
+            throw new Error(`unknown command ${command}`);
+        }
+    }
+}
+
+
+let statefun = new StateFun();","[{'comment': 'nit: `const`', 'commenter': 'Airblader'}]"
269,statefun-sdk-js/src/context.ts,"@@ -0,0 +1,171 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+'use strict';","[{'comment': 'nit: inconsistent quotes', 'commenter': 'Airblader'}]"
269,statefun-sdk-js/src/context.ts,"@@ -0,0 +1,171 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+'use strict';
+
+import {isEmptyOrNull} from ""./core"";
+import {Message} from ""./message"";
+import {EgressMessage} from ""./message"";
+import {Address} from ""./core"";
+
+export class DelayedMessage {","[{'comment': 'For here and all other classes, since this is the actual API, should these not all be documented?', 'commenter': 'Airblader'}]"
269,statefun-sdk-js/src/context.ts,"@@ -0,0 +1,171 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+'use strict';
+
+import {isEmptyOrNull} from ""./core"";
+import {Message} from ""./message"";
+import {EgressMessage} from ""./message"";
+import {Address} from ""./core"";
+
+export class DelayedMessage {
+    readonly delay: number;
+    readonly message: Message;
+    readonly token: string | undefined;
+
+    constructor(delay: number, message: Message, cancellationToken: string | undefined) {","[{'comment': 'If you specifiy the constructor arguments as `public readonly`, you don\'t need to declare the class members anymore or assign them. This applies to all classes, of course.\r\n\r\n```\r\nclass Foo {\r\n    constructor(public readonly name: string) {}\r\n}\r\n\r\nconst foo = new Foo(""test"");\r\nfoo.name // ""test""\r\n```\r\n\r\nFor (JS-native) private fields (`#foo`) you need to still declare them explicitly.', 'commenter': 'Airblader'}]"
269,statefun-sdk-js/src/context.ts,"@@ -0,0 +1,171 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+'use strict';
+
+import {isEmptyOrNull} from ""./core"";
+import {Message} from ""./message"";
+import {EgressMessage} from ""./message"";
+import {Address} from ""./core"";
+
+export class DelayedMessage {
+    readonly delay: number;
+    readonly message: Message;
+    readonly token: string | undefined;
+
+    constructor(delay: number, message: Message, cancellationToken: string | undefined) {
+        this.delay = delay;
+        this.message = message;
+        this.token = cancellationToken;
+
+    }
+}
+
+export class CancellationRequest {
+    readonly token: string;
+
+    constructor(cancellationToken: string) {
+        this.token = cancellationToken;
+    }
+}
+
+export class InternalContext {
+    #caller: null | Address;
+    readonly #sent: Message[];
+    readonly #delayed: (DelayedMessage | CancellationRequest)[];
+    readonly #egress: EgressMessage[];
+
+    constructor() {","[{'comment': 'nit: you can initialize the fields at declaration, no constructor needed.', 'commenter': 'Airblader'}]"
269,statefun-sdk-js/src/context.ts,"@@ -0,0 +1,171 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+'use strict';
+
+import {isEmptyOrNull} from ""./core"";
+import {Message} from ""./message"";
+import {EgressMessage} from ""./message"";
+import {Address} from ""./core"";
+
+export class DelayedMessage {
+    readonly delay: number;
+    readonly message: Message;
+    readonly token: string | undefined;
+
+    constructor(delay: number, message: Message, cancellationToken: string | undefined) {
+        this.delay = delay;
+        this.message = message;
+        this.token = cancellationToken;
+
+    }
+}
+
+export class CancellationRequest {
+    readonly token: string;
+
+    constructor(cancellationToken: string) {
+        this.token = cancellationToken;
+    }
+}
+
+export class InternalContext {
+    #caller: null | Address;","[{'comment': 'Since all of these fields are exposed through getters (and caller through a setter), we can remove all the getter/setters and remove the `#` to make them public fields. This is entirely transparent, i.e. even if later one we need to change the setter logic, we can introduce a setter then.\r\n\r\n```\r\nexport class InternalContext {\r\n    caller: null | Address;\r\n    readonly sent: Message[];\r\n    // …\r\n}\r\n```', 'commenter': 'Airblader'}]"
269,statefun-sdk-js/src/context.ts,"@@ -0,0 +1,171 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+'use strict';
+
+import {isEmptyOrNull} from ""./core"";
+import {Message} from ""./message"";
+import {EgressMessage} from ""./message"";
+import {Address} from ""./core"";
+
+export class DelayedMessage {
+    readonly delay: number;
+    readonly message: Message;
+    readonly token: string | undefined;
+
+    constructor(delay: number, message: Message, cancellationToken: string | undefined) {
+        this.delay = delay;
+        this.message = message;
+        this.token = cancellationToken;
+
+    }
+}
+
+export class CancellationRequest {
+    readonly token: string;
+
+    constructor(cancellationToken: string) {
+        this.token = cancellationToken;
+    }
+}
+
+export class InternalContext {
+    #caller: null | Address;
+    readonly #sent: Message[];
+    readonly #delayed: (DelayedMessage | CancellationRequest)[];
+    readonly #egress: EgressMessage[];
+
+    constructor() {
+        this.#caller = null;
+        this.#sent = [];
+        this.#delayed = [];
+        this.#egress = [];
+    }
+
+    get sent() {
+        return this.#sent;
+    }
+
+    get delayed() {
+        return this.#delayed;
+    }
+
+    get egress() {
+        return this.#egress;
+    }
+
+    set caller(newCaller: null | Address) {
+        this.#caller = newCaller;
+    }
+
+    get caller(): null | Address {
+        return this.#caller;
+    }
+}
+
+// noinspection SuspiciousTypeOfGuard
+export class Context {
+    readonly #storage;","[{'comment': 'These members are all untyped.', 'commenter': 'Airblader'}]"
269,statefun-sdk-js/src/context.ts,"@@ -0,0 +1,171 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+'use strict';
+
+import {isEmptyOrNull} from ""./core"";
+import {Message} from ""./message"";
+import {EgressMessage} from ""./message"";
+import {Address} from ""./core"";
+
+export class DelayedMessage {
+    readonly delay: number;
+    readonly message: Message;
+    readonly token: string | undefined;
+
+    constructor(delay: number, message: Message, cancellationToken: string | undefined) {
+        this.delay = delay;
+        this.message = message;
+        this.token = cancellationToken;
+
+    }
+}
+
+export class CancellationRequest {
+    readonly token: string;
+
+    constructor(cancellationToken: string) {
+        this.token = cancellationToken;
+    }
+}
+
+export class InternalContext {
+    #caller: null | Address;
+    readonly #sent: Message[];
+    readonly #delayed: (DelayedMessage | CancellationRequest)[];
+    readonly #egress: EgressMessage[];
+
+    constructor() {
+        this.#caller = null;
+        this.#sent = [];
+        this.#delayed = [];
+        this.#egress = [];
+    }
+
+    get sent() {
+        return this.#sent;
+    }
+
+    get delayed() {
+        return this.#delayed;
+    }
+
+    get egress() {
+        return this.#egress;
+    }
+
+    set caller(newCaller: null | Address) {
+        this.#caller = newCaller;
+    }
+
+    get caller(): null | Address {
+        return this.#caller;
+    }
+}
+
+// noinspection SuspiciousTypeOfGuard
+export class Context {
+    readonly #storage;
+    readonly #self;
+    readonly #internalContext;
+
+    /**
+     * @param {Address} self an address of the currently executing function.
+     * @param storage an address scoped storage.
+     * @param {InternalContext} internalContext.
+     */
+    constructor(self: Address, storage: any, internalContext: InternalContext) {","[{'comment': 'Is `storage` really `any`?', 'commenter': 'Airblader'}]"
269,statefun-sdk-js/src/context.ts,"@@ -0,0 +1,171 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+'use strict';
+
+import {isEmptyOrNull} from ""./core"";
+import {Message} from ""./message"";
+import {EgressMessage} from ""./message"";
+import {Address} from ""./core"";
+
+export class DelayedMessage {
+    readonly delay: number;
+    readonly message: Message;
+    readonly token: string | undefined;
+
+    constructor(delay: number, message: Message, cancellationToken: string | undefined) {
+        this.delay = delay;
+        this.message = message;
+        this.token = cancellationToken;
+
+    }
+}
+
+export class CancellationRequest {
+    readonly token: string;
+
+    constructor(cancellationToken: string) {
+        this.token = cancellationToken;
+    }
+}
+
+export class InternalContext {
+    #caller: null | Address;
+    readonly #sent: Message[];
+    readonly #delayed: (DelayedMessage | CancellationRequest)[];
+    readonly #egress: EgressMessage[];
+
+    constructor() {
+        this.#caller = null;
+        this.#sent = [];
+        this.#delayed = [];
+        this.#egress = [];
+    }
+
+    get sent() {
+        return this.#sent;
+    }
+
+    get delayed() {
+        return this.#delayed;
+    }
+
+    get egress() {
+        return this.#egress;
+    }
+
+    set caller(newCaller: null | Address) {
+        this.#caller = newCaller;
+    }
+
+    get caller(): null | Address {
+        return this.#caller;
+    }
+}
+
+// noinspection SuspiciousTypeOfGuard
+export class Context {
+    readonly #storage;
+    readonly #self;
+    readonly #internalContext;
+
+    /**
+     * @param {Address} self an address of the currently executing function.
+     * @param storage an address scoped storage.
+     * @param {InternalContext} internalContext.
+     */
+    constructor(self: Address, storage: any, internalContext: InternalContext) {
+        this.#self = self;
+        this.#storage = storage;
+        this.#internalContext = internalContext;
+    }
+
+    /**
+     * Address Scoped Storage.
+     *
+     * This property represents a storage that is scoped for the currently executing function.
+     * The returned object contains, as properties, the values of each registered state spec.
+     *
+     * @returns {any} the address scoped storage that is associated with this function.
+     */
+    get storage() {
+        return this.#storage;
+    }
+
+    /**
+     * @returns {Address | null} the caller address if this message originated from a function.
+     */
+    get caller(): null | Address {
+        return this.#internalContext.caller;
+    }
+
+    /**
+     * @returns {Address} the address of the currently executing function.
+     */
+    get self(): Address {
+        return this.#self;
+    }
+
+    /**
+     * Send a message to a function or an egress.
+     *
+     * @param {EgressMessage|Message} message a message to send.
+     */
+    send(message: Message | EgressMessage) {
+        const internalContext = this.#internalContext;
+        if (message instanceof EgressMessage) {
+            internalContext.egress.push(message);
+        } else if (message instanceof Message) {
+            internalContext.sent.push(message);
+        } else {
+            throw new Error(`Unknown message type ${message}`);
+        }
+    }
+
+    /**
+     * Send a delayed message.
+     *
+     * @param {int} delay a number that represents a time duration in milliseconds, after it this message will be delivered.
+     * @param {Message} message a message to send after the specified delay had passed.
+     * @param {string} cancellationToken an optional value to associate with this message for a later cancellation.
+     */
+    sendAfter(delay: number, message: Message, cancellationToken?: string) {
+        if (!(message instanceof Message)) {
+            throw new Error(`Can only delay messages. Got ${message}`);
+        }
+        if (!Number.isInteger(delay)) {
+            throw new Error(`delay is expected to be a number that represents a time duration in milliseconds.`);
+        }
+        this.#internalContext.delayed.push(new DelayedMessage(delay, message, cancellationToken));
+    }
+
+    /**
+     * Cancel a delayed message (message that was sent using sendAfter) with a given token.
+     * Please note that this is a best-effort operation, since the message might have been already delivered.
+     * If the message was delivered, this is a no-op operation.
+     * @param {string} cancellationToken
+     */
+    cancelDelayedMessage(cancellationToken: string) {
+        if (isEmptyOrNull(cancellationToken)) {
+            throw new Error(`Cancellation token can not be NULL`)","[{'comment': 'nit: missing semicolon inconsistency', 'commenter': 'Airblader'}]"
269,statefun-sdk-js/src/context.ts,"@@ -0,0 +1,171 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+'use strict';
+
+import {isEmptyOrNull} from ""./core"";
+import {Message} from ""./message"";
+import {EgressMessage} from ""./message"";
+import {Address} from ""./core"";
+
+export class DelayedMessage {
+    readonly delay: number;
+    readonly message: Message;
+    readonly token: string | undefined;
+
+    constructor(delay: number, message: Message, cancellationToken: string | undefined) {
+        this.delay = delay;
+        this.message = message;
+        this.token = cancellationToken;
+
+    }
+}
+
+export class CancellationRequest {
+    readonly token: string;
+
+    constructor(cancellationToken: string) {
+        this.token = cancellationToken;
+    }
+}
+
+export class InternalContext {
+    #caller: null | Address;
+    readonly #sent: Message[];
+    readonly #delayed: (DelayedMessage | CancellationRequest)[];
+    readonly #egress: EgressMessage[];
+
+    constructor() {
+        this.#caller = null;
+        this.#sent = [];
+        this.#delayed = [];
+        this.#egress = [];
+    }
+
+    get sent() {
+        return this.#sent;
+    }
+
+    get delayed() {
+        return this.#delayed;
+    }
+
+    get egress() {
+        return this.#egress;
+    }
+
+    set caller(newCaller: null | Address) {
+        this.#caller = newCaller;
+    }
+
+    get caller(): null | Address {
+        return this.#caller;
+    }
+}
+
+// noinspection SuspiciousTypeOfGuard
+export class Context {
+    readonly #storage;
+    readonly #self;
+    readonly #internalContext;
+
+    /**
+     * @param {Address} self an address of the currently executing function.
+     * @param storage an address scoped storage.
+     * @param {InternalContext} internalContext.
+     */
+    constructor(self: Address, storage: any, internalContext: InternalContext) {
+        this.#self = self;
+        this.#storage = storage;
+        this.#internalContext = internalContext;
+    }
+
+    /**
+     * Address Scoped Storage.
+     *
+     * This property represents a storage that is scoped for the currently executing function.
+     * The returned object contains, as properties, the values of each registered state spec.
+     *
+     * @returns {any} the address scoped storage that is associated with this function.
+     */
+    get storage() {
+        return this.#storage;
+    }
+
+    /**
+     * @returns {Address | null} the caller address if this message originated from a function.
+     */
+    get caller(): null | Address {
+        return this.#internalContext.caller;
+    }
+
+    /**
+     * @returns {Address} the address of the currently executing function.
+     */
+    get self(): Address {
+        return this.#self;
+    }
+
+    /**
+     * Send a message to a function or an egress.
+     *
+     * @param {EgressMessage|Message} message a message to send.
+     */
+    send(message: Message | EgressMessage) {","[{'comment': 'For ""non-trivial"" API methods (i.e. not a simple getter), I\'m personally a fan of explicitly declaring the return type (in this case and below `void`). While TS does infer the type, declaring it gives you safety that if you accidentally return something wrong, TS will tell you instead of silently changing the inferred type.', 'commenter': 'Airblader'}]"
269,statefun-sdk-js/src/core.ts,"@@ -0,0 +1,329 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+'use strict';","[{'comment': 'nit: inconsistent quotes', 'commenter': 'Airblader'}]"
269,statefun-sdk-js/src/core.ts,"@@ -0,0 +1,329 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+'use strict';
+
+import {Context} from ""./context"";
+import {Message} from ""./message"";
+
+/**
+ * Type - represents the base class for every StateFun type.
+ * each type is globally and uniquely (across languages) defined by it's Typename string (of the form <namespace>/<name>).","[{'comment': ""If you want to get real fancy, we can introduce a type for the Typename which enforces on a type-level that it contains a slash and use that type everywhere:\r\n\r\n```\r\ntype Typename = `${string}/${string}`;\r\n\r\nconst n1: TypeName = 'foo'; // Type error\r\nconst n2: TypeName = 'foo/bar'; // OK\r\n```\r\n\r\nDue to the way TS works, you don't need to explicitly specify the type when using it. A string which matches the type will be seen of being of that type (if it is constant, otherwise the compiler has no idea, of course)."", 'commenter': 'Airblader'}]"
269,statefun-sdk-js/src/context.ts,"@@ -0,0 +1,171 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+'use strict';
+
+import {isEmptyOrNull} from ""./core"";
+import {Message} from ""./message"";
+import {EgressMessage} from ""./message"";
+import {Address} from ""./core"";
+
+export class DelayedMessage {
+    readonly delay: number;
+    readonly message: Message;
+    readonly token: string | undefined;
+
+    constructor(delay: number, message: Message, cancellationToken: string | undefined) {
+        this.delay = delay;
+        this.message = message;
+        this.token = cancellationToken;
+
+    }
+}
+
+export class CancellationRequest {
+    readonly token: string;
+
+    constructor(cancellationToken: string) {
+        this.token = cancellationToken;
+    }
+}
+
+export class InternalContext {
+    #caller: null | Address;
+    readonly #sent: Message[];
+    readonly #delayed: (DelayedMessage | CancellationRequest)[];
+    readonly #egress: EgressMessage[];
+
+    constructor() {
+        this.#caller = null;
+        this.#sent = [];
+        this.#delayed = [];
+        this.#egress = [];
+    }
+
+    get sent() {
+        return this.#sent;
+    }
+
+    get delayed() {
+        return this.#delayed;
+    }
+
+    get egress() {
+        return this.#egress;
+    }
+
+    set caller(newCaller: null | Address) {
+        this.#caller = newCaller;
+    }
+
+    get caller(): null | Address {
+        return this.#caller;
+    }
+}
+
+// noinspection SuspiciousTypeOfGuard","[{'comment': 'What is this inspection triggering for?', 'commenter': 'Airblader'}]"
269,statefun-sdk-js/src/core.ts,"@@ -0,0 +1,329 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+'use strict';
+
+import {Context} from ""./context"";
+import {Message} from ""./message"";
+
+/**
+ * Type - represents the base class for every StateFun type.
+ * each type is globally and uniquely (across languages) defined by it's Typename string (of the form <namespace>/<name>).
+ */
+abstract class Type<T> {
+    readonly #typename: string;
+
+    protected constructor(typename: string) {
+        validateTypeName(typename);
+        this.#typename = typename;
+    }
+
+    /**
+     * typename is a uniquely identifying <namespace>/<name> string that presents a value
+     * in StateFun's type system.
+     *
+     * @returns {string} the typename representation of this type.
+     */
+    get typename() {
+        return this.#typename;
+    }
+
+    /**
+     * Serialize a value to bytes.
+     *
+     * @param value the value to serialize.
+     * @returns {Buffer} the serialized value.
+     */
+    abstract serialize(value: T): Buffer;
+
+    /**
+     * Deserialize a previously serialized value from bytes.
+     *
+     * @param {Buffer} bytes a serialized value.
+     * @returns a value that was serialized from the input bytes.
+     */
+    abstract deserialize(bytes: Buffer): T;
+}
+
+/**
+ * A Stateful Function's Address.
+ */
+class Address {
+    readonly #namespace;
+    readonly #name;
+    readonly #id;
+    readonly #typename;
+
+    constructor(namespace: string, name: string, id: string, typename: string) {
+        this.#namespace = namespace;
+        this.#name = name
+        this.#id = id;
+        this.#typename = typename;
+    }
+
+    /**
+     * Create an address that consist out of a namespace, name (also known as a typename) and an id.
+     *
+     * @param namespace the namespace part of the address
+     * @param name the name part of the address
+     * @param id the function's unique id.
+     * @returns {Address} an address that represents a specific function instance.
+     */
+    static fromParts(namespace: string, name: string, id: string) {
+        return new Address(namespace, name, id, `${namespace}/${name}`);
+    }
+
+    /**
+     * Creates an address from a <namespace>/<name> (aka typename) and an id pair.
+     * @param typename
+     * @param id
+     * @returns {Address}
+     */
+    // noinspection DuplicatedCode
+    static fromTypeNameId(typename: string, id: string) {
+        if (isEmptyOrNull(id)) {
+            throw new Error(""id must be a defined string"");
+        }
+        const {namespace, name} = parseTypeName(typename);
+        return new Address(namespace, name, id, typename)
+    }
+
+
+    /**
+     * @returns {string} returns the type name string (typename) of this function.
+     */
+    get typename() {
+        return this.#typename;
+    }
+
+    /**
+     * @returns {string} the id part of the address.
+     */
+    get id() {
+        return this.#id;
+    }
+
+    /**
+     *
+     * @returns {string} returns the namespace part of this address
+     */
+    get namespace() {
+        return this.#namespace;
+    }
+
+    /**
+     *
+     * @returns {string} returns the typename's name part of this address.
+     */
+    get name() {
+        return this.#name;
+    }
+}
+
+
+/**
+ * A representation of a single state value specification.
+ * This is created from the following object:
+ * {
+ *     name: string,
+ *     type: Type,
+ *     expireAfterCall / expireAfterWrite : int
+ * }
+ */
+export interface ValueSpecOpts {
+    name: string;
+    type: Type<any>;","[{'comment': '`Type<unknown>`? Or maybe make the interface generic? You can also assign default type arguments:\r\n\r\n```\r\nexport interface ValueSpecOpts<T = unknown> {\r\n    type: Type<T>;\r\n}\r\n```', 'commenter': 'Airblader'}]"
269,statefun-sdk-js/src/core.ts,"@@ -0,0 +1,329 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+'use strict';
+
+import {Context} from ""./context"";
+import {Message} from ""./message"";
+
+/**
+ * Type - represents the base class for every StateFun type.
+ * each type is globally and uniquely (across languages) defined by it's Typename string (of the form <namespace>/<name>).
+ */
+abstract class Type<T> {
+    readonly #typename: string;
+
+    protected constructor(typename: string) {
+        validateTypeName(typename);
+        this.#typename = typename;
+    }
+
+    /**
+     * typename is a uniquely identifying <namespace>/<name> string that presents a value
+     * in StateFun's type system.
+     *
+     * @returns {string} the typename representation of this type.
+     */
+    get typename() {
+        return this.#typename;
+    }
+
+    /**
+     * Serialize a value to bytes.
+     *
+     * @param value the value to serialize.
+     * @returns {Buffer} the serialized value.
+     */
+    abstract serialize(value: T): Buffer;
+
+    /**
+     * Deserialize a previously serialized value from bytes.
+     *
+     * @param {Buffer} bytes a serialized value.
+     * @returns a value that was serialized from the input bytes.
+     */
+    abstract deserialize(bytes: Buffer): T;
+}
+
+/**
+ * A Stateful Function's Address.
+ */
+class Address {
+    readonly #namespace;
+    readonly #name;
+    readonly #id;
+    readonly #typename;
+
+    constructor(namespace: string, name: string, id: string, typename: string) {
+        this.#namespace = namespace;
+        this.#name = name
+        this.#id = id;
+        this.#typename = typename;
+    }
+
+    /**
+     * Create an address that consist out of a namespace, name (also known as a typename) and an id.
+     *
+     * @param namespace the namespace part of the address
+     * @param name the name part of the address
+     * @param id the function's unique id.
+     * @returns {Address} an address that represents a specific function instance.
+     */
+    static fromParts(namespace: string, name: string, id: string) {
+        return new Address(namespace, name, id, `${namespace}/${name}`);
+    }
+
+    /**
+     * Creates an address from a <namespace>/<name> (aka typename) and an id pair.
+     * @param typename
+     * @param id
+     * @returns {Address}
+     */
+    // noinspection DuplicatedCode
+    static fromTypeNameId(typename: string, id: string) {
+        if (isEmptyOrNull(id)) {
+            throw new Error(""id must be a defined string"");
+        }
+        const {namespace, name} = parseTypeName(typename);
+        return new Address(namespace, name, id, typename)
+    }
+
+
+    /**
+     * @returns {string} returns the type name string (typename) of this function.
+     */
+    get typename() {
+        return this.#typename;
+    }
+
+    /**
+     * @returns {string} the id part of the address.
+     */
+    get id() {
+        return this.#id;
+    }
+
+    /**
+     *
+     * @returns {string} returns the namespace part of this address
+     */
+    get namespace() {
+        return this.#namespace;
+    }
+
+    /**
+     *
+     * @returns {string} returns the typename's name part of this address.
+     */
+    get name() {
+        return this.#name;
+    }
+}
+
+
+/**
+ * A representation of a single state value specification.
+ * This is created from the following object:
+ * {
+ *     name: string,
+ *     type: Type,
+ *     expireAfterCall / expireAfterWrite : int
+ * }
+ */
+export interface ValueSpecOpts {
+    name: string;
+    type: Type<any>;
+    expireAfterCall?: number;
+    expireAfterWrite?: number
+}
+
+/**
+ * A representation of a single function.
+ * This can be created with the following object:
+ * {
+ *     typename: ""foo.bar/baz"",
+ *     fn(context, message) {
+ *         ...
+ *     },
+ *     specs: [..]
+ * }
+ */
+export interface FunctionOpts {
+    typename: string;
+    fn: (context: Context, message: Message) => void | Promise<void>;
+    specs?: ValueSpecOpts[]","[{'comment': 'Missing semicolon', 'commenter': 'Airblader'}]"
269,statefun-sdk-js/src/core.ts,"@@ -0,0 +1,329 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+'use strict';
+
+import {Context} from ""./context"";
+import {Message} from ""./message"";
+
+/**
+ * Type - represents the base class for every StateFun type.
+ * each type is globally and uniquely (across languages) defined by it's Typename string (of the form <namespace>/<name>).
+ */
+abstract class Type<T> {
+    readonly #typename: string;
+
+    protected constructor(typename: string) {
+        validateTypeName(typename);
+        this.#typename = typename;
+    }
+
+    /**
+     * typename is a uniquely identifying <namespace>/<name> string that presents a value
+     * in StateFun's type system.
+     *
+     * @returns {string} the typename representation of this type.
+     */
+    get typename() {
+        return this.#typename;
+    }
+
+    /**
+     * Serialize a value to bytes.
+     *
+     * @param value the value to serialize.
+     * @returns {Buffer} the serialized value.
+     */
+    abstract serialize(value: T): Buffer;
+
+    /**
+     * Deserialize a previously serialized value from bytes.
+     *
+     * @param {Buffer} bytes a serialized value.
+     * @returns a value that was serialized from the input bytes.
+     */
+    abstract deserialize(bytes: Buffer): T;
+}
+
+/**
+ * A Stateful Function's Address.
+ */
+class Address {
+    readonly #namespace;
+    readonly #name;
+    readonly #id;
+    readonly #typename;
+
+    constructor(namespace: string, name: string, id: string, typename: string) {
+        this.#namespace = namespace;
+        this.#name = name
+        this.#id = id;
+        this.#typename = typename;
+    }
+
+    /**
+     * Create an address that consist out of a namespace, name (also known as a typename) and an id.
+     *
+     * @param namespace the namespace part of the address
+     * @param name the name part of the address
+     * @param id the function's unique id.
+     * @returns {Address} an address that represents a specific function instance.
+     */
+    static fromParts(namespace: string, name: string, id: string) {
+        return new Address(namespace, name, id, `${namespace}/${name}`);
+    }
+
+    /**
+     * Creates an address from a <namespace>/<name> (aka typename) and an id pair.
+     * @param typename
+     * @param id
+     * @returns {Address}
+     */
+    // noinspection DuplicatedCode
+    static fromTypeNameId(typename: string, id: string) {
+        if (isEmptyOrNull(id)) {
+            throw new Error(""id must be a defined string"");
+        }
+        const {namespace, name} = parseTypeName(typename);
+        return new Address(namespace, name, id, typename)
+    }
+
+
+    /**
+     * @returns {string} returns the type name string (typename) of this function.
+     */
+    get typename() {
+        return this.#typename;
+    }
+
+    /**
+     * @returns {string} the id part of the address.
+     */
+    get id() {
+        return this.#id;
+    }
+
+    /**
+     *
+     * @returns {string} returns the namespace part of this address
+     */
+    get namespace() {
+        return this.#namespace;
+    }
+
+    /**
+     *
+     * @returns {string} returns the typename's name part of this address.
+     */
+    get name() {
+        return this.#name;
+    }
+}
+
+
+/**
+ * A representation of a single state value specification.
+ * This is created from the following object:
+ * {
+ *     name: string,
+ *     type: Type,
+ *     expireAfterCall / expireAfterWrite : int
+ * }
+ */
+export interface ValueSpecOpts {
+    name: string;
+    type: Type<any>;
+    expireAfterCall?: number;
+    expireAfterWrite?: number
+}
+
+/**
+ * A representation of a single function.
+ * This can be created with the following object:
+ * {
+ *     typename: ""foo.bar/baz"",
+ *     fn(context, message) {
+ *         ...
+ *     },
+ *     specs: [..]
+ * }
+ */
+export interface FunctionOpts {
+    typename: string;
+    fn: (context: Context, message: Message) => void | Promise<void>;
+    specs?: ValueSpecOpts[]
+}
+
+/**
+ * an internal representation of function spec
+ */
+class ValueSpec implements ValueSpecOpts {
+    readonly #name: string;
+    readonly #type: Type<any>;
+    readonly #expireAfterCall: number;
+    readonly #expireAfterWrite: number;
+
+    constructor(name: string, type: Type<any>, expireAfterCall?: number, expireAfterWrite?: number) {
+        this.#name = name;
+        this.#type = type;
+        this.#expireAfterCall = expireAfterCall || -1;","[{'comment': 'Nowaday we use `expireAfterCall ?? -1` instead of `||` since `||` has broken semantics for values other than null/undefined in this context.', 'commenter': 'Airblader'}]"
269,statefun-sdk-js/src/core.ts,"@@ -0,0 +1,329 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+'use strict';
+
+import {Context} from ""./context"";
+import {Message} from ""./message"";
+
+/**
+ * Type - represents the base class for every StateFun type.
+ * each type is globally and uniquely (across languages) defined by it's Typename string (of the form <namespace>/<name>).
+ */
+abstract class Type<T> {
+    readonly #typename: string;
+
+    protected constructor(typename: string) {
+        validateTypeName(typename);
+        this.#typename = typename;
+    }
+
+    /**
+     * typename is a uniquely identifying <namespace>/<name> string that presents a value
+     * in StateFun's type system.
+     *
+     * @returns {string} the typename representation of this type.
+     */
+    get typename() {
+        return this.#typename;
+    }
+
+    /**
+     * Serialize a value to bytes.
+     *
+     * @param value the value to serialize.
+     * @returns {Buffer} the serialized value.
+     */
+    abstract serialize(value: T): Buffer;
+
+    /**
+     * Deserialize a previously serialized value from bytes.
+     *
+     * @param {Buffer} bytes a serialized value.
+     * @returns a value that was serialized from the input bytes.
+     */
+    abstract deserialize(bytes: Buffer): T;
+}
+
+/**
+ * A Stateful Function's Address.
+ */
+class Address {
+    readonly #namespace;
+    readonly #name;
+    readonly #id;
+    readonly #typename;
+
+    constructor(namespace: string, name: string, id: string, typename: string) {
+        this.#namespace = namespace;
+        this.#name = name
+        this.#id = id;
+        this.#typename = typename;
+    }
+
+    /**
+     * Create an address that consist out of a namespace, name (also known as a typename) and an id.
+     *
+     * @param namespace the namespace part of the address
+     * @param name the name part of the address
+     * @param id the function's unique id.
+     * @returns {Address} an address that represents a specific function instance.
+     */
+    static fromParts(namespace: string, name: string, id: string) {
+        return new Address(namespace, name, id, `${namespace}/${name}`);
+    }
+
+    /**
+     * Creates an address from a <namespace>/<name> (aka typename) and an id pair.
+     * @param typename
+     * @param id
+     * @returns {Address}
+     */
+    // noinspection DuplicatedCode
+    static fromTypeNameId(typename: string, id: string) {
+        if (isEmptyOrNull(id)) {
+            throw new Error(""id must be a defined string"");
+        }
+        const {namespace, name} = parseTypeName(typename);
+        return new Address(namespace, name, id, typename)
+    }
+
+
+    /**
+     * @returns {string} returns the type name string (typename) of this function.
+     */
+    get typename() {
+        return this.#typename;
+    }
+
+    /**
+     * @returns {string} the id part of the address.
+     */
+    get id() {
+        return this.#id;
+    }
+
+    /**
+     *
+     * @returns {string} returns the namespace part of this address
+     */
+    get namespace() {
+        return this.#namespace;
+    }
+
+    /**
+     *
+     * @returns {string} returns the typename's name part of this address.
+     */
+    get name() {
+        return this.#name;
+    }
+}
+
+
+/**
+ * A representation of a single state value specification.
+ * This is created from the following object:
+ * {
+ *     name: string,
+ *     type: Type,
+ *     expireAfterCall / expireAfterWrite : int
+ * }
+ */
+export interface ValueSpecOpts {
+    name: string;
+    type: Type<any>;
+    expireAfterCall?: number;
+    expireAfterWrite?: number
+}
+
+/**
+ * A representation of a single function.
+ * This can be created with the following object:
+ * {
+ *     typename: ""foo.bar/baz"",
+ *     fn(context, message) {
+ *         ...
+ *     },
+ *     specs: [..]
+ * }
+ */
+export interface FunctionOpts {
+    typename: string;
+    fn: (context: Context, message: Message) => void | Promise<void>;
+    specs?: ValueSpecOpts[]
+}
+
+/**
+ * an internal representation of function spec
+ */
+class ValueSpec implements ValueSpecOpts {
+    readonly #name: string;
+    readonly #type: Type<any>;
+    readonly #expireAfterCall: number;
+    readonly #expireAfterWrite: number;
+
+    constructor(name: string, type: Type<any>, expireAfterCall?: number, expireAfterWrite?: number) {
+        this.#name = name;
+        this.#type = type;
+        this.#expireAfterCall = expireAfterCall || -1;
+        this.#expireAfterWrite = expireAfterWrite || -1;
+    }
+
+    /**
+     * Creates a ValueSpec.
+     *
+     * @param {string} name the unique state name to use. Must be lowercase a-z or _.
+     * @param {Type} type the statefun type to associated with this state.
+     * @param {int} expireAfterCall the time-to-live (milliseconds) of this value after a call
+     * @param {int} expireAfterWrite the time-to-live (milliseconds) of this value after a write
+     * @returns {ValueSpec}
+     */
+    static fromOpts({name, type, expireAfterCall, expireAfterWrite}: ValueSpecOpts) {
+        if (isEmptyOrNull(name)) {
+            throw new Error(""missing name"");
+        }
+        if (!/^[_a-z]+$/.test(name)) {
+            throw new Error(`a name can only contain lower or upper case letters`);
+        }
+        if (type === undefined || type === null) {","[{'comment': 'In TS this cannot happen anymore, but I guess this is worth keeping for JS users.', 'commenter': 'Airblader'}]"
269,statefun-sdk-js/src/core.ts,"@@ -0,0 +1,329 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+'use strict';
+
+import {Context} from ""./context"";
+import {Message} from ""./message"";
+
+/**
+ * Type - represents the base class for every StateFun type.
+ * each type is globally and uniquely (across languages) defined by it's Typename string (of the form <namespace>/<name>).
+ */
+abstract class Type<T> {
+    readonly #typename: string;
+
+    protected constructor(typename: string) {
+        validateTypeName(typename);
+        this.#typename = typename;
+    }
+
+    /**
+     * typename is a uniquely identifying <namespace>/<name> string that presents a value
+     * in StateFun's type system.
+     *
+     * @returns {string} the typename representation of this type.
+     */
+    get typename() {
+        return this.#typename;
+    }
+
+    /**
+     * Serialize a value to bytes.
+     *
+     * @param value the value to serialize.
+     * @returns {Buffer} the serialized value.
+     */
+    abstract serialize(value: T): Buffer;
+
+    /**
+     * Deserialize a previously serialized value from bytes.
+     *
+     * @param {Buffer} bytes a serialized value.
+     * @returns a value that was serialized from the input bytes.
+     */
+    abstract deserialize(bytes: Buffer): T;
+}
+
+/**
+ * A Stateful Function's Address.
+ */
+class Address {
+    readonly #namespace;
+    readonly #name;
+    readonly #id;
+    readonly #typename;
+
+    constructor(namespace: string, name: string, id: string, typename: string) {
+        this.#namespace = namespace;
+        this.#name = name
+        this.#id = id;
+        this.#typename = typename;
+    }
+
+    /**
+     * Create an address that consist out of a namespace, name (also known as a typename) and an id.
+     *
+     * @param namespace the namespace part of the address
+     * @param name the name part of the address
+     * @param id the function's unique id.
+     * @returns {Address} an address that represents a specific function instance.
+     */
+    static fromParts(namespace: string, name: string, id: string) {
+        return new Address(namespace, name, id, `${namespace}/${name}`);
+    }
+
+    /**
+     * Creates an address from a <namespace>/<name> (aka typename) and an id pair.
+     * @param typename
+     * @param id
+     * @returns {Address}
+     */
+    // noinspection DuplicatedCode
+    static fromTypeNameId(typename: string, id: string) {
+        if (isEmptyOrNull(id)) {
+            throw new Error(""id must be a defined string"");
+        }
+        const {namespace, name} = parseTypeName(typename);
+        return new Address(namespace, name, id, typename)
+    }
+
+
+    /**
+     * @returns {string} returns the type name string (typename) of this function.
+     */
+    get typename() {
+        return this.#typename;
+    }
+
+    /**
+     * @returns {string} the id part of the address.
+     */
+    get id() {
+        return this.#id;
+    }
+
+    /**
+     *
+     * @returns {string} returns the namespace part of this address
+     */
+    get namespace() {
+        return this.#namespace;
+    }
+
+    /**
+     *
+     * @returns {string} returns the typename's name part of this address.
+     */
+    get name() {
+        return this.#name;
+    }
+}
+
+
+/**
+ * A representation of a single state value specification.
+ * This is created from the following object:
+ * {
+ *     name: string,
+ *     type: Type,
+ *     expireAfterCall / expireAfterWrite : int
+ * }
+ */
+export interface ValueSpecOpts {
+    name: string;
+    type: Type<any>;
+    expireAfterCall?: number;
+    expireAfterWrite?: number
+}
+
+/**
+ * A representation of a single function.
+ * This can be created with the following object:
+ * {
+ *     typename: ""foo.bar/baz"",
+ *     fn(context, message) {
+ *         ...
+ *     },
+ *     specs: [..]
+ * }
+ */
+export interface FunctionOpts {
+    typename: string;
+    fn: (context: Context, message: Message) => void | Promise<void>;
+    specs?: ValueSpecOpts[]
+}
+
+/**
+ * an internal representation of function spec
+ */
+class ValueSpec implements ValueSpecOpts {
+    readonly #name: string;
+    readonly #type: Type<any>;
+    readonly #expireAfterCall: number;
+    readonly #expireAfterWrite: number;
+
+    constructor(name: string, type: Type<any>, expireAfterCall?: number, expireAfterWrite?: number) {
+        this.#name = name;
+        this.#type = type;
+        this.#expireAfterCall = expireAfterCall || -1;
+        this.#expireAfterWrite = expireAfterWrite || -1;
+    }
+
+    /**
+     * Creates a ValueSpec.
+     *
+     * @param {string} name the unique state name to use. Must be lowercase a-z or _.
+     * @param {Type} type the statefun type to associated with this state.
+     * @param {int} expireAfterCall the time-to-live (milliseconds) of this value after a call
+     * @param {int} expireAfterWrite the time-to-live (milliseconds) of this value after a write
+     * @returns {ValueSpec}
+     */
+    static fromOpts({name, type, expireAfterCall, expireAfterWrite}: ValueSpecOpts) {
+        if (isEmptyOrNull(name)) {
+            throw new Error(""missing name"");
+        }
+        if (!/^[_a-z]+$/.test(name)) {
+            throw new Error(`a name can only contain lower or upper case letters`);
+        }
+        if (type === undefined || type === null) {
+            throw new Error(""missing type"");
+        }
+        if (!Number.isInteger(expireAfterCall || -1)) {","[{'comment': ""This duplicates the fallback logic in `ValueSpec`. I think it'd make more sense if here we only validate it if it is set, and if not do nothing?"", 'commenter': 'Airblader'}]"
269,statefun-sdk-js/src/core.ts,"@@ -0,0 +1,329 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+'use strict';
+
+import {Context} from ""./context"";
+import {Message} from ""./message"";
+
+/**
+ * Type - represents the base class for every StateFun type.
+ * each type is globally and uniquely (across languages) defined by it's Typename string (of the form <namespace>/<name>).
+ */
+abstract class Type<T> {
+    readonly #typename: string;
+
+    protected constructor(typename: string) {
+        validateTypeName(typename);
+        this.#typename = typename;
+    }
+
+    /**
+     * typename is a uniquely identifying <namespace>/<name> string that presents a value
+     * in StateFun's type system.
+     *
+     * @returns {string} the typename representation of this type.
+     */
+    get typename() {
+        return this.#typename;
+    }
+
+    /**
+     * Serialize a value to bytes.
+     *
+     * @param value the value to serialize.
+     * @returns {Buffer} the serialized value.
+     */
+    abstract serialize(value: T): Buffer;
+
+    /**
+     * Deserialize a previously serialized value from bytes.
+     *
+     * @param {Buffer} bytes a serialized value.
+     * @returns a value that was serialized from the input bytes.
+     */
+    abstract deserialize(bytes: Buffer): T;
+}
+
+/**
+ * A Stateful Function's Address.
+ */
+class Address {
+    readonly #namespace;
+    readonly #name;
+    readonly #id;
+    readonly #typename;
+
+    constructor(namespace: string, name: string, id: string, typename: string) {
+        this.#namespace = namespace;
+        this.#name = name
+        this.#id = id;
+        this.#typename = typename;
+    }
+
+    /**
+     * Create an address that consist out of a namespace, name (also known as a typename) and an id.
+     *
+     * @param namespace the namespace part of the address
+     * @param name the name part of the address
+     * @param id the function's unique id.
+     * @returns {Address} an address that represents a specific function instance.
+     */
+    static fromParts(namespace: string, name: string, id: string) {
+        return new Address(namespace, name, id, `${namespace}/${name}`);
+    }
+
+    /**
+     * Creates an address from a <namespace>/<name> (aka typename) and an id pair.
+     * @param typename
+     * @param id
+     * @returns {Address}
+     */
+    // noinspection DuplicatedCode
+    static fromTypeNameId(typename: string, id: string) {
+        if (isEmptyOrNull(id)) {
+            throw new Error(""id must be a defined string"");
+        }
+        const {namespace, name} = parseTypeName(typename);
+        return new Address(namespace, name, id, typename)
+    }
+
+
+    /**
+     * @returns {string} returns the type name string (typename) of this function.
+     */
+    get typename() {
+        return this.#typename;
+    }
+
+    /**
+     * @returns {string} the id part of the address.
+     */
+    get id() {
+        return this.#id;
+    }
+
+    /**
+     *
+     * @returns {string} returns the namespace part of this address
+     */
+    get namespace() {
+        return this.#namespace;
+    }
+
+    /**
+     *
+     * @returns {string} returns the typename's name part of this address.
+     */
+    get name() {
+        return this.#name;
+    }
+}
+
+
+/**
+ * A representation of a single state value specification.
+ * This is created from the following object:
+ * {
+ *     name: string,
+ *     type: Type,
+ *     expireAfterCall / expireAfterWrite : int
+ * }
+ */
+export interface ValueSpecOpts {
+    name: string;
+    type: Type<any>;
+    expireAfterCall?: number;
+    expireAfterWrite?: number
+}
+
+/**
+ * A representation of a single function.
+ * This can be created with the following object:
+ * {
+ *     typename: ""foo.bar/baz"",
+ *     fn(context, message) {
+ *         ...
+ *     },
+ *     specs: [..]
+ * }
+ */
+export interface FunctionOpts {
+    typename: string;
+    fn: (context: Context, message: Message) => void | Promise<void>;
+    specs?: ValueSpecOpts[]
+}
+
+/**
+ * an internal representation of function spec
+ */
+class ValueSpec implements ValueSpecOpts {
+    readonly #name: string;
+    readonly #type: Type<any>;
+    readonly #expireAfterCall: number;
+    readonly #expireAfterWrite: number;
+
+    constructor(name: string, type: Type<any>, expireAfterCall?: number, expireAfterWrite?: number) {
+        this.#name = name;
+        this.#type = type;
+        this.#expireAfterCall = expireAfterCall || -1;
+        this.#expireAfterWrite = expireAfterWrite || -1;
+    }
+
+    /**
+     * Creates a ValueSpec.
+     *
+     * @param {string} name the unique state name to use. Must be lowercase a-z or _.
+     * @param {Type} type the statefun type to associated with this state.
+     * @param {int} expireAfterCall the time-to-live (milliseconds) of this value after a call
+     * @param {int} expireAfterWrite the time-to-live (milliseconds) of this value after a write
+     * @returns {ValueSpec}
+     */
+    static fromOpts({name, type, expireAfterCall, expireAfterWrite}: ValueSpecOpts) {
+        if (isEmptyOrNull(name)) {
+            throw new Error(""missing name"");
+        }
+        if (!/^[_a-z]+$/.test(name)) {
+            throw new Error(`a name can only contain lower or upper case letters`);
+        }
+        if (type === undefined || type === null) {
+            throw new Error(""missing type"");
+        }
+        if (!Number.isInteger(expireAfterCall || -1)) {
+            throw new Error(""expireAfterCall is not an integer"");
+        }
+        if (!Number.isInteger(expireAfterWrite || -1)) {
+            throw new Error(""expireAfterWrite is not an integer"");
+        }
+        return new ValueSpec(name, type, expireAfterCall, expireAfterWrite);
+    }
+
+    /**
+     *
+     * @returns {string} the name of the this spec
+     */
+    get name() {
+        return this.#name;
+    }
+
+    /**
+     * @returns {Type} this StateFun type.
+     */
+    get type() {
+        return this.#type;
+    }
+
+    get expireAfterWrite() {
+        return this.#expireAfterWrite;
+    }
+
+    get expireAfterCall() {
+        return this.#expireAfterCall;
+    }
+}
+
+
+/**
+ * An internal representation of a function spec.
+ * A function specification has a typename, a list of zero or more declared states, and an instance of a function to invoke.
+ */
+class FunctionSpec implements FunctionOpts {
+    readonly #typename;
+    readonly #fn;
+    readonly #valueSpecs;
+
+    constructor(typename: string, fn: (context: Context, message: Message) => void | Promise<void>, specs: ValueSpec[]) {","[{'comment': 'Maybe it would make sense to extract a type definition for this function to be used here and in `FunctionOpts`:\r\n\r\n```\r\ntype ChooseAName = (context: Context, message: Message) => void | Promise<void>;\r\n```', 'commenter': 'Airblader'}]"
269,statefun-sdk-js/src/core.ts,"@@ -0,0 +1,329 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+'use strict';
+
+import {Context} from ""./context"";
+import {Message} from ""./message"";
+
+/**
+ * Type - represents the base class for every StateFun type.
+ * each type is globally and uniquely (across languages) defined by it's Typename string (of the form <namespace>/<name>).
+ */
+abstract class Type<T> {
+    readonly #typename: string;
+
+    protected constructor(typename: string) {
+        validateTypeName(typename);
+        this.#typename = typename;
+    }
+
+    /**
+     * typename is a uniquely identifying <namespace>/<name> string that presents a value
+     * in StateFun's type system.
+     *
+     * @returns {string} the typename representation of this type.
+     */
+    get typename() {
+        return this.#typename;
+    }
+
+    /**
+     * Serialize a value to bytes.
+     *
+     * @param value the value to serialize.
+     * @returns {Buffer} the serialized value.
+     */
+    abstract serialize(value: T): Buffer;
+
+    /**
+     * Deserialize a previously serialized value from bytes.
+     *
+     * @param {Buffer} bytes a serialized value.
+     * @returns a value that was serialized from the input bytes.
+     */
+    abstract deserialize(bytes: Buffer): T;
+}
+
+/**
+ * A Stateful Function's Address.
+ */
+class Address {
+    readonly #namespace;
+    readonly #name;
+    readonly #id;
+    readonly #typename;
+
+    constructor(namespace: string, name: string, id: string, typename: string) {
+        this.#namespace = namespace;
+        this.#name = name
+        this.#id = id;
+        this.#typename = typename;
+    }
+
+    /**
+     * Create an address that consist out of a namespace, name (also known as a typename) and an id.
+     *
+     * @param namespace the namespace part of the address
+     * @param name the name part of the address
+     * @param id the function's unique id.
+     * @returns {Address} an address that represents a specific function instance.
+     */
+    static fromParts(namespace: string, name: string, id: string) {
+        return new Address(namespace, name, id, `${namespace}/${name}`);
+    }
+
+    /**
+     * Creates an address from a <namespace>/<name> (aka typename) and an id pair.
+     * @param typename
+     * @param id
+     * @returns {Address}
+     */
+    // noinspection DuplicatedCode
+    static fromTypeNameId(typename: string, id: string) {
+        if (isEmptyOrNull(id)) {
+            throw new Error(""id must be a defined string"");
+        }
+        const {namespace, name} = parseTypeName(typename);
+        return new Address(namespace, name, id, typename)
+    }
+
+
+    /**
+     * @returns {string} returns the type name string (typename) of this function.
+     */
+    get typename() {
+        return this.#typename;
+    }
+
+    /**
+     * @returns {string} the id part of the address.
+     */
+    get id() {
+        return this.#id;
+    }
+
+    /**
+     *
+     * @returns {string} returns the namespace part of this address
+     */
+    get namespace() {
+        return this.#namespace;
+    }
+
+    /**
+     *
+     * @returns {string} returns the typename's name part of this address.
+     */
+    get name() {
+        return this.#name;
+    }
+}
+
+
+/**
+ * A representation of a single state value specification.
+ * This is created from the following object:
+ * {
+ *     name: string,
+ *     type: Type,
+ *     expireAfterCall / expireAfterWrite : int
+ * }
+ */
+export interface ValueSpecOpts {
+    name: string;
+    type: Type<any>;
+    expireAfterCall?: number;
+    expireAfterWrite?: number
+}
+
+/**
+ * A representation of a single function.
+ * This can be created with the following object:
+ * {
+ *     typename: ""foo.bar/baz"",
+ *     fn(context, message) {
+ *         ...
+ *     },
+ *     specs: [..]
+ * }
+ */
+export interface FunctionOpts {
+    typename: string;
+    fn: (context: Context, message: Message) => void | Promise<void>;
+    specs?: ValueSpecOpts[]
+}
+
+/**
+ * an internal representation of function spec
+ */
+class ValueSpec implements ValueSpecOpts {
+    readonly #name: string;
+    readonly #type: Type<any>;
+    readonly #expireAfterCall: number;
+    readonly #expireAfterWrite: number;
+
+    constructor(name: string, type: Type<any>, expireAfterCall?: number, expireAfterWrite?: number) {
+        this.#name = name;
+        this.#type = type;
+        this.#expireAfterCall = expireAfterCall || -1;
+        this.#expireAfterWrite = expireAfterWrite || -1;
+    }
+
+    /**
+     * Creates a ValueSpec.
+     *
+     * @param {string} name the unique state name to use. Must be lowercase a-z or _.
+     * @param {Type} type the statefun type to associated with this state.
+     * @param {int} expireAfterCall the time-to-live (milliseconds) of this value after a call
+     * @param {int} expireAfterWrite the time-to-live (milliseconds) of this value after a write
+     * @returns {ValueSpec}
+     */
+    static fromOpts({name, type, expireAfterCall, expireAfterWrite}: ValueSpecOpts) {
+        if (isEmptyOrNull(name)) {
+            throw new Error(""missing name"");
+        }
+        if (!/^[_a-z]+$/.test(name)) {
+            throw new Error(`a name can only contain lower or upper case letters`);
+        }
+        if (type === undefined || type === null) {
+            throw new Error(""missing type"");
+        }
+        if (!Number.isInteger(expireAfterCall || -1)) {
+            throw new Error(""expireAfterCall is not an integer"");
+        }
+        if (!Number.isInteger(expireAfterWrite || -1)) {
+            throw new Error(""expireAfterWrite is not an integer"");
+        }
+        return new ValueSpec(name, type, expireAfterCall, expireAfterWrite);
+    }
+
+    /**
+     *
+     * @returns {string} the name of the this spec
+     */
+    get name() {
+        return this.#name;
+    }
+
+    /**
+     * @returns {Type} this StateFun type.
+     */
+    get type() {
+        return this.#type;
+    }
+
+    get expireAfterWrite() {
+        return this.#expireAfterWrite;
+    }
+
+    get expireAfterCall() {
+        return this.#expireAfterCall;
+    }
+}
+
+
+/**
+ * An internal representation of a function spec.
+ * A function specification has a typename, a list of zero or more declared states, and an instance of a function to invoke.
+ */
+class FunctionSpec implements FunctionOpts {
+    readonly #typename;
+    readonly #fn;
+    readonly #valueSpecs;
+
+    constructor(typename: string, fn: (context: Context, message: Message) => void | Promise<void>, specs: ValueSpec[]) {
+        validateTypeName(typename);
+        if (fn === undefined) {
+            throw new Error(`input function must be defined.`);
+        }
+        this.#typename = typename;
+        this.#fn = fn;
+        this.#valueSpecs = specs;
+    }
+
+    static fromOpts({fn, specs, typename}: FunctionOpts): FunctionSpec {
+        validateTypeName(typename);
+        if (fn === undefined || fn === null) {
+            throw new Error(`missing function instance for ${typename}`);
+        }
+        let validatedSpecs = [];
+        let seen: Record<string, ValueSpec> = {};","[{'comment': ""You can use a `Set` for this, also you're not using the `ValueSpec` value.\r\n\r\n```\r\nconst seen = new Set<string>();\r\nseen.add('x');\r\nseen.has('x');\r\n```"", 'commenter': 'Airblader'}, {'comment': 'If I may just propose a different way of writing it:\r\n\r\n```\r\nconst valueSpecs = (specs ?? []).map(spec => ValueSpec.fromOpts(spec));\r\n\r\nconst seen = new Set<String>();\r\nfor (const valueSpec of valueSpecs) {\r\n    if (seen.has(valueSpec.name)) {\r\n        throw new Error(`{valueSpec.name} is already defined.`);\r\n    }\r\n\r\n    seen.add(valueSpec.name);\r\n}\r\n\r\nreturn new FunctionSpec(typename, fn, valueSpecs);\r\n```', 'commenter': 'Airblader'}]"
269,statefun-sdk-js/src/core.ts,"@@ -0,0 +1,329 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+'use strict';
+
+import {Context} from ""./context"";
+import {Message} from ""./message"";
+
+/**
+ * Type - represents the base class for every StateFun type.
+ * each type is globally and uniquely (across languages) defined by it's Typename string (of the form <namespace>/<name>).
+ */
+abstract class Type<T> {
+    readonly #typename: string;
+
+    protected constructor(typename: string) {
+        validateTypeName(typename);
+        this.#typename = typename;
+    }
+
+    /**
+     * typename is a uniquely identifying <namespace>/<name> string that presents a value
+     * in StateFun's type system.
+     *
+     * @returns {string} the typename representation of this type.
+     */
+    get typename() {
+        return this.#typename;
+    }
+
+    /**
+     * Serialize a value to bytes.
+     *
+     * @param value the value to serialize.
+     * @returns {Buffer} the serialized value.
+     */
+    abstract serialize(value: T): Buffer;
+
+    /**
+     * Deserialize a previously serialized value from bytes.
+     *
+     * @param {Buffer} bytes a serialized value.
+     * @returns a value that was serialized from the input bytes.
+     */
+    abstract deserialize(bytes: Buffer): T;
+}
+
+/**
+ * A Stateful Function's Address.
+ */
+class Address {
+    readonly #namespace;
+    readonly #name;
+    readonly #id;
+    readonly #typename;
+
+    constructor(namespace: string, name: string, id: string, typename: string) {
+        this.#namespace = namespace;
+        this.#name = name
+        this.#id = id;
+        this.#typename = typename;
+    }
+
+    /**
+     * Create an address that consist out of a namespace, name (also known as a typename) and an id.
+     *
+     * @param namespace the namespace part of the address
+     * @param name the name part of the address
+     * @param id the function's unique id.
+     * @returns {Address} an address that represents a specific function instance.
+     */
+    static fromParts(namespace: string, name: string, id: string) {
+        return new Address(namespace, name, id, `${namespace}/${name}`);
+    }
+
+    /**
+     * Creates an address from a <namespace>/<name> (aka typename) and an id pair.
+     * @param typename
+     * @param id
+     * @returns {Address}
+     */
+    // noinspection DuplicatedCode
+    static fromTypeNameId(typename: string, id: string) {
+        if (isEmptyOrNull(id)) {
+            throw new Error(""id must be a defined string"");
+        }
+        const {namespace, name} = parseTypeName(typename);
+        return new Address(namespace, name, id, typename)
+    }
+
+
+    /**
+     * @returns {string} returns the type name string (typename) of this function.
+     */
+    get typename() {
+        return this.#typename;
+    }
+
+    /**
+     * @returns {string} the id part of the address.
+     */
+    get id() {
+        return this.#id;
+    }
+
+    /**
+     *
+     * @returns {string} returns the namespace part of this address
+     */
+    get namespace() {
+        return this.#namespace;
+    }
+
+    /**
+     *
+     * @returns {string} returns the typename's name part of this address.
+     */
+    get name() {
+        return this.#name;
+    }
+}
+
+
+/**
+ * A representation of a single state value specification.
+ * This is created from the following object:
+ * {
+ *     name: string,
+ *     type: Type,
+ *     expireAfterCall / expireAfterWrite : int
+ * }
+ */
+export interface ValueSpecOpts {
+    name: string;
+    type: Type<any>;
+    expireAfterCall?: number;
+    expireAfterWrite?: number
+}
+
+/**
+ * A representation of a single function.
+ * This can be created with the following object:
+ * {
+ *     typename: ""foo.bar/baz"",
+ *     fn(context, message) {
+ *         ...
+ *     },
+ *     specs: [..]
+ * }
+ */
+export interface FunctionOpts {
+    typename: string;
+    fn: (context: Context, message: Message) => void | Promise<void>;
+    specs?: ValueSpecOpts[]
+}
+
+/**
+ * an internal representation of function spec
+ */
+class ValueSpec implements ValueSpecOpts {
+    readonly #name: string;
+    readonly #type: Type<any>;
+    readonly #expireAfterCall: number;
+    readonly #expireAfterWrite: number;
+
+    constructor(name: string, type: Type<any>, expireAfterCall?: number, expireAfterWrite?: number) {
+        this.#name = name;
+        this.#type = type;
+        this.#expireAfterCall = expireAfterCall || -1;
+        this.#expireAfterWrite = expireAfterWrite || -1;
+    }
+
+    /**
+     * Creates a ValueSpec.
+     *
+     * @param {string} name the unique state name to use. Must be lowercase a-z or _.
+     * @param {Type} type the statefun type to associated with this state.
+     * @param {int} expireAfterCall the time-to-live (milliseconds) of this value after a call
+     * @param {int} expireAfterWrite the time-to-live (milliseconds) of this value after a write
+     * @returns {ValueSpec}
+     */
+    static fromOpts({name, type, expireAfterCall, expireAfterWrite}: ValueSpecOpts) {
+        if (isEmptyOrNull(name)) {
+            throw new Error(""missing name"");
+        }
+        if (!/^[_a-z]+$/.test(name)) {
+            throw new Error(`a name can only contain lower or upper case letters`);
+        }
+        if (type === undefined || type === null) {
+            throw new Error(""missing type"");
+        }
+        if (!Number.isInteger(expireAfterCall || -1)) {
+            throw new Error(""expireAfterCall is not an integer"");
+        }
+        if (!Number.isInteger(expireAfterWrite || -1)) {
+            throw new Error(""expireAfterWrite is not an integer"");
+        }
+        return new ValueSpec(name, type, expireAfterCall, expireAfterWrite);
+    }
+
+    /**
+     *
+     * @returns {string} the name of the this spec
+     */
+    get name() {
+        return this.#name;
+    }
+
+    /**
+     * @returns {Type} this StateFun type.
+     */
+    get type() {
+        return this.#type;
+    }
+
+    get expireAfterWrite() {
+        return this.#expireAfterWrite;
+    }
+
+    get expireAfterCall() {
+        return this.#expireAfterCall;
+    }
+}
+
+
+/**
+ * An internal representation of a function spec.
+ * A function specification has a typename, a list of zero or more declared states, and an instance of a function to invoke.
+ */
+class FunctionSpec implements FunctionOpts {
+    readonly #typename;
+    readonly #fn;
+    readonly #valueSpecs;
+
+    constructor(typename: string, fn: (context: Context, message: Message) => void | Promise<void>, specs: ValueSpec[]) {
+        validateTypeName(typename);
+        if (fn === undefined) {
+            throw new Error(`input function must be defined.`);
+        }
+        this.#typename = typename;
+        this.#fn = fn;
+        this.#valueSpecs = specs;
+    }
+
+    static fromOpts({fn, specs, typename}: FunctionOpts): FunctionSpec {
+        validateTypeName(typename);
+        if (fn === undefined || fn === null) {
+            throw new Error(`missing function instance for ${typename}`);
+        }
+        let validatedSpecs = [];
+        let seen: Record<string, ValueSpec> = {};
+        for (let spec of (specs || [])) {
+            const valueSpec = ValueSpec.fromOpts(spec);
+            if (seen.hasOwnProperty(valueSpec.name)) {
+                throw new Error(`${valueSpec.name} is already defined.`);
+            }
+            seen[valueSpec.name] = valueSpec;
+            validatedSpecs.push(valueSpec);
+        }
+        return new FunctionSpec(typename, fn, validatedSpecs);
+    }
+
+    get valueSpecs() {
+        return this.#valueSpecs;
+    }
+
+    get fn() {
+        return this.#fn;
+    }
+
+    get typename() {
+        return this.#typename;
+    }
+}
+
+/**
+ *
+ * @param {string} typename a namespace/name string
+ */
+function validateTypeName(typename: string) {
+    parseTypeName(typename);
+}
+
+/**
+ * @param {string} typename a string of  <namespace>/<name>
+ * @returns {{namespace: string, name: string}}
+ */
+function parseTypeName(typename: string) {
+    if (isEmptyOrNull(typename)) {
+        throw new Error(`typename must be provided and of the form <namespace>/<name>`);
+    }
+    const index = typename.lastIndexOf(""/"");
+    if (index < 0 || index > typename.length) {
+        throw new Error(`Unable to find a / in ${typename}`);
+    }
+    const namespace = typename.substring(0, index);
+    const name = typename.substring(index + 1);
+    if (namespace === undefined || namespace.length === 0 || name === undefined || name.length === 0) {
+        throw new Error(`Illegal ${typename}, it must be of a form <namespace>/<name>`);
+    }
+    return {namespace, name};
+}
+
+function isEmptyOrNull(s: string | undefined | null) {
+    // noinspection SuspiciousTypeOfGuard
+    return (s === null || s === undefined || (typeof s !== 'string') || s.length === 0);
+}
+
+export {FunctionSpec}","[{'comment': ""It'd be nicer to add the `export` directly at the types instead of doing all of this on the bottom."", 'commenter': 'Airblader'}]"
269,statefun-sdk-js/src/egress.ts,"@@ -0,0 +1,131 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+'use strict';","[{'comment': 'Inconsistent quotes', 'commenter': 'Airblader'}]"
269,statefun-sdk-js/src/egress.ts,"@@ -0,0 +1,131 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+'use strict';
+
+import ""./generated/kafka-egress_pb"";
+import ""./generated/kinesis-egress_pb"";
+
+import {Type, validateTypeName} from ""./core"";
+
+import {isEmptyOrNull} from ""./core"";
+import {TypedValueSupport} from ""./types"";
+import {EgressMessage} from ""./message"";
+
+// noinspection JSUnresolvedVariable
+const PB_KAFKA = global.proto.io.statefun.sdk.egress.KafkaProducerRecord;
+
+// noinspection JSUnresolvedVariable
+const PB_KINESIS = global.proto.io.statefun.sdk.egress.KinesisEgressRecord;
+
+function serialize(type: Type<any> | undefined, value: any): Buffer {","[{'comment': 'Make this function generic instead of using `any`?', 'commenter': 'Airblader'}]"
269,statefun-sdk-js/src/egress.ts,"@@ -0,0 +1,131 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+'use strict';
+
+import ""./generated/kafka-egress_pb"";
+import ""./generated/kinesis-egress_pb"";
+
+import {Type, validateTypeName} from ""./core"";
+
+import {isEmptyOrNull} from ""./core"";
+import {TypedValueSupport} from ""./types"";
+import {EgressMessage} from ""./message"";
+
+// noinspection JSUnresolvedVariable
+const PB_KAFKA = global.proto.io.statefun.sdk.egress.KafkaProducerRecord;
+
+// noinspection JSUnresolvedVariable
+const PB_KINESIS = global.proto.io.statefun.sdk.egress.KinesisEgressRecord;
+
+function serialize(type: Type<any> | undefined, value: any): Buffer {
+    if (!(type === undefined || type === null)) {
+        return type.serialize(value);
+    }
+    if (typeof value === 'string') {","[{'comment': 'More inconsistent quotes :-)', 'commenter': 'Airblader'}]"
303,statefun-sdk-go/v3/pkg/statefun/context.go,"@@ -76,6 +81,12 @@ func (s *statefunContext) Storage() AddressScopedStorage {
 	return s.storage
 }
 
+func (s *statefunContext) WithContext(ctx context.Context) Context {
+	newContext := *s
+	newContext.Context = ctx
+	return &newContext","[{'comment': 'Will this then share the mutex across both contexts? Reading [this thread](https://groups.google.com/g/golang-nuts/c/imxjBLNJ9OY), it seems like another approach would be to lock the mutex, copy the protected fields into a new object (which holds a new mutex), then unlock. We may also want to copy the other pointer fields like caller, storage, address. wdyt? \r\n\r\n', 'commenter': 'austince'}, {'comment': ""Unless I'm mistaken, the initial assignment operation:\r\n\r\n```\r\nnewContext := *s\r\n```\r\n\r\n... will shallow copy all the fields from the existing `statefunContext` to the new one, including the caller (a pointer), self (not a pointer), storage (a pointer), address (a pointer), response (a pointer), and the mutex (a pointer). (EDIT: And the context (interface) too, but that is overwritten in the next line.)\r\n\r\nThis means that both contexts will share the same mutex and response, which is what we want, I think? The mutex is used to serialize access to fields in the response, i.e.:\r\n\r\n```\r\ns.Lock()\r\ns.response.OutgoingMessages = append(s.response.OutgoingMessages, invocation)\r\ns.Unlock()\r\n```\r\n\r\nMy read of the linked thread is that it describes how to copy a mutex when it is directly embedded (i.e. not a pointer); in this case, we have the option to make it a pointer and sidestep the problem. But please let me know if you disagree. Thanks."", 'commenter': 'galenwarren'}, {'comment': 'Ah yeah, I was thinking we want this to be a full, independent copy of the Context, without shared state (like in `http.Request`). I don\'t have enough ""context"" here to know if that\'s a requirement / what possible situations would arise if the state is shared.\r\nAnd yeah, agreed that the assignment will shallow copy all fields, just curious about the pointer fields as they\'d be shared state. ', 'commenter': 'austince'}, {'comment': '@sjwiesman ? ', 'commenter': 'austince'}, {'comment': ""Ah, I understand what you're saying.\r\n\r\nI think that, with regard to the mutex and the response, we need the old and new contexts to share the same state, because both contexts need to update the same response object, i.e. the one (and only) response object that will be returned from the invocation of the stateful function.\r\n\r\nI think that also holds true for the storage; there is only one storage instance that applies for the entire stateful-function call, so both contexts need to reference it. (And the storage operations are protected with a `sync.RWMutex`, so this should be safe.)\r\n\r\nSo that just leaves the caller. My understanding is that this is a pointer in order that it can be nil, to handle the case where there is no caller, but that it is also intended to be read-only. Even without the addition of `WithContext`, two consumers of the same `statefun.Context` could conceivably step on each others' toes by modifying the `Address` returned from `Caller`. I think the assumption is that the returned `Address` will be read-only, and with that assumption, we wouldn't be making anything worse by shallow copying vs. deep copying.\r\n\r\nBut, deep copying the caller `Address` would certainly be possible.\r\n\r\n@sjwiesman @tillrohrmann Do you have any thoughts on this?"", 'commenter': 'galenwarren'}, {'comment': 'The statefun context very explicitly has shared state. It is effectively building the return payload from the batch of messages. Self is static for all messages in the batch. Caller is message specific, but from user code perspective both are immutable for the full invocation. ', 'commenter': 'sjwiesman'}]"
303,statefun-sdk-go/v3/pkg/statefun/context.go,"@@ -64,7 +66,7 @@ type Context interface {
 }
 
 type statefunContext struct {
-	sync.Mutex
+	*sync.Mutex","[{'comment': 'why is this change required? ', 'commenter': 'sjwiesman'}, {'comment': 'This was changed to a pointer so that different statefunContext instances can reference the same sync.Mutex, as opposed to each having their own sync.Mutex. I thought this was necessary because derived statefunContext instances all reference the same response object, and the mutex is used to prevent concurrent modifications to the response object?', 'commenter': 'galenwarren'}, {'comment': 'You are correct. Thank you. ', 'commenter': 'sjwiesman'}]"
339,statefun-flink/statefun-flink-distribution/src/main/resources/META-INF/NOTICE,"@@ -1,47 +1,49 @@
 statefun-flink-distribution
-Copyright 2014-2020 The Apache Software Foundation
+Copyright 2014-2023 The Apache Software Foundation
 
 This product includes software developed at
 The Apache Software Foundation (http://www.apache.org/).
 
 This project bundles the following dependencies under the Apache Software License 2.0 (http://www.apache.org/licenses/LICENSE-2.0.txt)
 
-- com.kohlschutter.junixsocket:junixsocket-core:2.3.2
-- com.kohlschutter.junixsocket:junixsocket-common:2.3.2
-- com.kohlschutter.junixsocket:junixsocket-native-common:2.3.2
-- commons-codec:commons-codec:1.13
-- commons-lang:commons-lang:2.6
-- commons-logging:commons-logging:1.1.3
-- commons-io:commons-io:2.8.0
+- com.fasterxml.jackson.core:jackson-annotations:2.13.4
+- com.fasterxml.jackson.core:jackson-core:2.13.4
+- com.fasterxml.jackson.core:jackson-databind:2.13.4
+- com.fasterxml.jackson.dataformat:jackson-dataformat-cbor:2.13.4
 - com.google.auto.service:auto-service-annotations:1.0-rc6
-- com.google.guava:guava:29.0-jre
+- com.google.errorprone:error_prone_annotations:2.3.4
 - com.google.guava:failureaccess:1.0.1
+- com.google.guava:guava:29.0-jre
 - com.google.guava:listenablefuture:9999.0-empty-to-avoid-conflict-with-guava
-- com.google.errorprone:error_prone_annotations:2.3.4
 - com.google.j2objc:j2objc-annotations:1.3
-- org.checkerframework:checker-qual:2.11.1
-- org.apache.commons:commons-lang3:3.3.2
-- org.apache.kafka:kafka-clients:2.4.1
-- org.lz4:lz4-java:1.8.0
+- com.kohlschutter.junixsocket:junixsocket-common:2.3.2
+- com.kohlschutter.junixsocket:junixsocket-core:2.3.2
+- com.kohlschutter.junixsocket:junixsocket-native-common:2.3.2
 - com.squareup.okhttp3:okhttp:3.14.6
 - com.squareup.okio:okio:1.17.2
-- com.fasterxml.jackson.core:jackson-databind:2.12.1
-- com.fasterxml.jackson.core:jackson-annotations:2.12.1
-- com.fasterxml.jackson.core:jackson-core:2.12.1
-- com.fasterxml.jackson.dataformat:jackson-dataformat-cbor:2.12.1
-- joda-time:joda-time:2.5
-- software.amazon.ion:ion-java:1.0.2
+- commons-codec:commons-codec:1.15
+- commons-collections:commons-collections:3.2.2
+- commons-io:commons-io:2.11.0
+- commons-lang:commons-lang:2.6
+- commons-logging:commons-logging:1.1.3
 - io.dropwizard.metrics:metrics-core:jar:3.2.6","[{'comment': 'This one should not include the `:jar`', 'commenter': 'dannycranmer'}]"
339,statefun-flink/statefun-flink-distribution/src/main/resources/META-INF/NOTICE,"@@ -1,47 +1,49 @@
 statefun-flink-distribution
-Copyright 2014-2020 The Apache Software Foundation
+Copyright 2014-2023 The Apache Software Foundation
 
 This product includes software developed at
 The Apache Software Foundation (http://www.apache.org/).
 
 This project bundles the following dependencies under the Apache Software License 2.0 (http://www.apache.org/licenses/LICENSE-2.0.txt)
 
-- com.kohlschutter.junixsocket:junixsocket-core:2.3.2
-- com.kohlschutter.junixsocket:junixsocket-common:2.3.2
-- com.kohlschutter.junixsocket:junixsocket-native-common:2.3.2
-- commons-codec:commons-codec:1.13
-- commons-lang:commons-lang:2.6
-- commons-logging:commons-logging:1.1.3
-- commons-io:commons-io:2.8.0
+- com.fasterxml.jackson.core:jackson-annotations:2.13.4
+- com.fasterxml.jackson.core:jackson-core:2.13.4
+- com.fasterxml.jackson.core:jackson-databind:2.13.4","[{'comment': 'I believe this should be `2.13.4.2`', 'commenter': 'dannycranmer'}]"
