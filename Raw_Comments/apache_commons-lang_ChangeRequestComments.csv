Pull,Path,Diff_hunk,Comment
179,src/main/java/org/apache/commons/lang3/text/WordUtils.java,"@@ -172,6 +173,84 @@ public static String wrap(final String str, final int wrapLength) {
      * @return a line with newlines inserted, <code>null</code> if null input
      */
     public static String wrap(final String str, int wrapLength, String newLineStr, final boolean wrapLongWords) {
+        return wrap(str, wrapLength, newLineStr, wrapLongWords, "" "");
+    }
+
+    /**
+     * <p>Wraps a single line of text, identifying words by <code>' '</code>.</p>","[{'comment': 'Should be `identifying word by <code>wrapOn</code>`\n', 'commenter': 'britter'}]"
179,src/main/java/org/apache/commons/lang3/text/WordUtils.java,"@@ -172,6 +173,84 @@ public static String wrap(final String str, final int wrapLength) {
      * @return a line with newlines inserted, <code>null</code> if null input
      */
     public static String wrap(final String str, int wrapLength, String newLineStr, final boolean wrapLongWords) {
+        return wrap(str, wrapLength, newLineStr, wrapLongWords, "" "");
+    }
+
+    /**
+     * <p>Wraps a single line of text, identifying words by <code>' '</code>.</p>
+     *
+     * <p>Leading spaces on a new line are stripped.
+     * Trailing spaces are not stripped.</p>
+     *
+     * <table border=""1"" summary=""Wrap Results"">
+     *  <tr>
+     *   <th>input</th>
+     *   <th>wrapLenght</th>
+     *   <th>newLineString</th>
+     *   <th>wrapLongWords</th>","[{'comment': 'The table is a column for the `wrapOn` parameter\n', 'commenter': 'britter'}, {'comment': ""@britter Hi, I've made the requested changes. Can you take a look?\n"", 'commenter': 'marko-bekhta'}]"
192,src/main/java/org/apache/commons/lang3/time/DateUtils.java,"@@ -668,6 +668,19 @@ public static Calendar toCalendar(final Date date) {
     
     //-----------------------------------------------------------------------
     /**
+     * Converts a {@code Date} of a given {@code TimeZone} into a {@code Calendar}
+     * @param date the date to convert to a Calendar
+     * @param timeZone the time zone of the @{code date}
+     * @return","[{'comment': 'Missing JavaDoc\n', 'commenter': 'britter'}, {'comment': 'Fixed.  Please check.\n', 'commenter': 'kaiyuanw'}]"
192,src/test/java/org/apache/commons/lang3/time/DateUtilsTest.java,"@@ -693,6 +693,43 @@ public void testToCalendar() {
             // expected
         }
     }
+    
+    //-----------------------------------------------------------------------
+    @Test
+    public void testToCalendarWithDate() {
+        assertEquals(""Convert Date and TimeZone to a Calendar, but failed to get the Date back"", date1, DateUtils.toCalendar(date1, zone).getTime());
+        try {
+            DateUtils.toCalendar(null, zone);
+            fail(""Expected NullPointerException to be thrown"");
+        } catch(final NullPointerException npe) {
+            // expected
+        }
+    }
+    
+    //-----------------------------------------------------------------------
+    @Test
+    public void testToCalendarWithTimeZone() {
+    	assertEquals(""Convert Date and TimeZone to a Calendar, but failed to get the TimeZone back"", zone, DateUtils.toCalendar(date1, zone).getTimeZone());
+        try {
+            DateUtils.toCalendar(date1, null);
+            fail(""Expected NullPointerException to be thrown"");
+        } catch(final NullPointerException npe) {
+            // expected
+        }
+    }
+    
+  //-----------------------------------------------------------------------
+    @Test
+    public void testToCalendarWithDateAndTimeZone() {
+        try {
+        	Calendar c = DateUtils.toCalendar(date2, defaultZone);
+        	assertEquals(""Convert Date and TimeZone to a Calendar, but failed to get the Date back"", date2, c.getTime());
+        	assertEquals(""Convert Date and TimeZone to a Calendar, but failed to get the TimeZone back"", defaultZone, c.getTimeZone());
+        	// expected
+        } catch(final NullPointerException npe) {
+        	fail(""Expected NullPointerException to be thrown"");","[{'comment': ""I don't understand this code. Why is a `NullPointerException` expected at this point?\n"", 'commenter': 'britter'}, {'comment': ""That's a typo.  Fixed.  Please check.\n"", 'commenter': 'kaiyuanw'}]"
192,src/test/java/org/apache/commons/lang3/time/DateUtilsTest.java,"@@ -693,6 +693,43 @@ public void testToCalendar() {
             // expected
         }
     }
+    
+    //-----------------------------------------------------------------------
+    @Test
+    public void testToCalendarWithDate() {
+        assertEquals(""Convert Date and TimeZone to a Calendar, but failed to get the Date back"", date1, DateUtils.toCalendar(date1, zone).getTime());
+        try {
+            DateUtils.toCalendar(null, zone);
+            fail(""Expected NullPointerException to be thrown"");
+        } catch(final NullPointerException npe) {
+            // expected
+        }
+    }
+    
+    //-----------------------------------------------------------------------
+    @Test
+    public void testToCalendarWithTimeZone() {
+    	assertEquals(""Convert Date and TimeZone to a Calendar, but failed to get the TimeZone back"", zone, DateUtils.toCalendar(date1, zone).getTimeZone());
+        try {
+            DateUtils.toCalendar(date1, null);
+            fail(""Expected NullPointerException to be thrown"");
+        } catch(final NullPointerException npe) {
+            // expected
+        }
+    }
+    
+  //-----------------------------------------------------------------------
+    @Test
+    public void testToCalendarWithDateAndTimeZone() {
+        try {
+        	Calendar c = DateUtils.toCalendar(date2, defaultZone);
+        	assertEquals(""Convert Date and TimeZone to a Calendar, but failed to get the Date back"", date2, c.getTime());
+        	assertEquals(""Convert Date and TimeZone to a Calendar, but failed to get the TimeZone back"", defaultZone, c.getTimeZone());","[{'comment': 'This looks redundant to me, since `testToCalendarWithDate()` already tests that the date has been set and `testToCalendarWithTimeZone()` already tests, that the timeZone has been set.\n', 'commenter': 'britter'}, {'comment': 'Good point.  Fixed.  Please check.\n', 'commenter': 'kaiyuanw'}]"
192,src/test/java/org/apache/commons/lang3/time/DateUtilsTest.java,"@@ -693,6 +693,59 @@ public void testToCalendar() {
             // expected
         }
     }
+    
+    //-----------------------------------------------------------------------
+    @Test
+    public void testToCalendarWithDateNotNull() {","[{'comment': 'This test is redundant because we have `testToCalendarWithDateAndTimeZoneNotNull()`\n', 'commenter': 'britter'}, {'comment': 'Fixed.\n', 'commenter': 'kaiyuanw'}]"
192,src/test/java/org/apache/commons/lang3/time/DateUtilsTest.java,"@@ -693,6 +693,59 @@ public void testToCalendar() {
             // expected
         }
     }
+    
+    //-----------------------------------------------------------------------
+    @Test
+    public void testToCalendarWithDateNotNull() {
+        assertEquals(""Convert Date and TimeZone to a Calendar, but failed to get the Date back"", date1, DateUtils.toCalendar(date1, zone).getTime());
+    }
+    
+    //-----------------------------------------------------------------------
+    @Test
+    public void testToCalendarWithDateNull() {
+        try {","[{'comment': ""you don't need a try-catch here. You can simply use `@Test(expected=NullPointerException.class)`\n"", 'commenter': 'britter'}, {'comment': ""This is JUnit 4 feature.  I've fixed that but note that we cannot use JUnit 3 anymore.\n"", 'commenter': 'kaiyuanw'}]"
192,src/test/java/org/apache/commons/lang3/time/DateUtilsTest.java,"@@ -693,6 +693,59 @@ public void testToCalendar() {
             // expected
         }
     }
+    
+    //-----------------------------------------------------------------------
+    @Test
+    public void testToCalendarWithDateNotNull() {
+        assertEquals(""Convert Date and TimeZone to a Calendar, but failed to get the Date back"", date1, DateUtils.toCalendar(date1, zone).getTime());
+    }
+    
+    //-----------------------------------------------------------------------
+    @Test
+    public void testToCalendarWithDateNull() {
+        try {
+            DateUtils.toCalendar(null, zone);
+            fail(""Expected NullPointerException to be thrown when Date is null"");
+        } catch(final NullPointerException npe) {
+            // expected
+        }
+    }
+    
+    //-----------------------------------------------------------------------
+    @Test
+    public void testToCalendarWithTimeZoneNotNull() {
+    	assertEquals(""Convert Date and TimeZone to a Calendar, but failed to get the TimeZone back"", zone, DateUtils.toCalendar(date1, zone).getTimeZone());
+    }
+    
+    //-----------------------------------------------------------------------
+    @Test
+    public void testToCalendarWithTimeZoneNull() {
+        try {","[{'comment': ""you don't need a try-catch here. You can simply use `@Test(expected=NullPointerException.class)`\n"", 'commenter': 'britter'}, {'comment': 'Fixed.\n', 'commenter': 'kaiyuanw'}]"
192,src/test/java/org/apache/commons/lang3/time/DateUtilsTest.java,"@@ -693,6 +693,59 @@ public void testToCalendar() {
             // expected
         }
     }
+    
+    //-----------------------------------------------------------------------
+    @Test
+    public void testToCalendarWithDateNotNull() {
+        assertEquals(""Convert Date and TimeZone to a Calendar, but failed to get the Date back"", date1, DateUtils.toCalendar(date1, zone).getTime());
+    }
+    
+    //-----------------------------------------------------------------------
+    @Test
+    public void testToCalendarWithDateNull() {
+        try {
+            DateUtils.toCalendar(null, zone);
+            fail(""Expected NullPointerException to be thrown when Date is null"");
+        } catch(final NullPointerException npe) {
+            // expected
+        }
+    }
+    
+    //-----------------------------------------------------------------------
+    @Test
+    public void testToCalendarWithTimeZoneNotNull() {
+    	assertEquals(""Convert Date and TimeZone to a Calendar, but failed to get the TimeZone back"", zone, DateUtils.toCalendar(date1, zone).getTimeZone());","[{'comment': 'This test is redundant because we have `testToCalendarWithDateAndTimeZoneNotNull()`\n', 'commenter': 'britter'}, {'comment': 'Removed.\n', 'commenter': 'kaiyuanw'}]"
192,src/test/java/org/apache/commons/lang3/time/DateUtilsTest.java,"@@ -693,6 +693,59 @@ public void testToCalendar() {
             // expected
         }
     }
+    
+    //-----------------------------------------------------------------------
+    @Test
+    public void testToCalendarWithDateNotNull() {
+        assertEquals(""Convert Date and TimeZone to a Calendar, but failed to get the Date back"", date1, DateUtils.toCalendar(date1, zone).getTime());
+    }
+    
+    //-----------------------------------------------------------------------
+    @Test
+    public void testToCalendarWithDateNull() {
+        try {
+            DateUtils.toCalendar(null, zone);
+            fail(""Expected NullPointerException to be thrown when Date is null"");
+        } catch(final NullPointerException npe) {
+            // expected
+        }
+    }
+    
+    //-----------------------------------------------------------------------
+    @Test
+    public void testToCalendarWithTimeZoneNotNull() {
+    	assertEquals(""Convert Date and TimeZone to a Calendar, but failed to get the TimeZone back"", zone, DateUtils.toCalendar(date1, zone).getTimeZone());
+    }
+    
+    //-----------------------------------------------------------------------
+    @Test
+    public void testToCalendarWithTimeZoneNull() {
+        try {
+            DateUtils.toCalendar(date1, null);
+            fail(""Expected NullPointerException to be thrown when TimeZone is null"");
+        } catch(final NullPointerException npe) {
+            // expected
+        }
+    }
+    
+    //-----------------------------------------------------------------------
+    @Test
+    public void testToCalendarWithDateAndTimeZoneNotNull() {
+    	Calendar c = DateUtils.toCalendar(date2, defaultZone);
+    	assertEquals(""Convert Date and TimeZone to a Calendar, but failed to get the Date back"", date2, c.getTime());
+    	assertEquals(""Convert Date and TimeZone to a Calendar, but failed to get the TimeZone back"", defaultZone, c.getTimeZone());
+    }
+    
+    //-----------------------------------------------------------------------
+    @Test
+    public void testToCalendarWithDateAndTimeZoneNull() {
+    	try {
+    		DateUtils.toCalendar(null, null);","[{'comment': 'No tabs please.\n', 'commenter': 'britter'}, {'comment': 'Fixed.\n', 'commenter': 'kaiyuanw'}]"
192,src/test/java/org/apache/commons/lang3/time/DateUtilsTest.java,"@@ -693,6 +693,59 @@ public void testToCalendar() {
             // expected
         }
     }
+    
+    //-----------------------------------------------------------------------
+    @Test
+    public void testToCalendarWithDateNotNull() {
+        assertEquals(""Convert Date and TimeZone to a Calendar, but failed to get the Date back"", date1, DateUtils.toCalendar(date1, zone).getTime());
+    }
+    
+    //-----------------------------------------------------------------------
+    @Test
+    public void testToCalendarWithDateNull() {
+        try {
+            DateUtils.toCalendar(null, zone);
+            fail(""Expected NullPointerException to be thrown when Date is null"");
+        } catch(final NullPointerException npe) {
+            // expected
+        }
+    }
+    
+    //-----------------------------------------------------------------------
+    @Test
+    public void testToCalendarWithTimeZoneNotNull() {
+    	assertEquals(""Convert Date and TimeZone to a Calendar, but failed to get the TimeZone back"", zone, DateUtils.toCalendar(date1, zone).getTimeZone());
+    }
+    
+    //-----------------------------------------------------------------------
+    @Test
+    public void testToCalendarWithTimeZoneNull() {
+        try {
+            DateUtils.toCalendar(date1, null);
+            fail(""Expected NullPointerException to be thrown when TimeZone is null"");
+        } catch(final NullPointerException npe) {
+            // expected
+        }
+    }
+    
+    //-----------------------------------------------------------------------
+    @Test
+    public void testToCalendarWithDateAndTimeZoneNotNull() {
+    	Calendar c = DateUtils.toCalendar(date2, defaultZone);
+    	assertEquals(""Convert Date and TimeZone to a Calendar, but failed to get the Date back"", date2, c.getTime());
+    	assertEquals(""Convert Date and TimeZone to a Calendar, but failed to get the TimeZone back"", defaultZone, c.getTimeZone());
+    }
+    
+    //-----------------------------------------------------------------------
+    @Test
+    public void testToCalendarWithDateAndTimeZoneNull() {
+    	try {","[{'comment': ""you don't need a try-catch here. You can simply use `@Test(expected=NullPointerException.class)`\n"", 'commenter': 'britter'}, {'comment': 'Fixed.\n', 'commenter': 'kaiyuanw'}]"
193,src/main/java/org/apache/commons/lang3/StringUtils.java,"@@ -258,6 +258,35 @@ public static boolean isAnyEmpty(final CharSequence... css) {
     }
     
     /**
+     * <p>Checks if any one of the CharSequences are not empty ("""") or null.</p>
+     *
+     * <pre>
+     * StringUtils.isAnyNotEmpty(null)             = false
+     * StringUtils.isAnyNotEmpty(null, ""foo"")      = true
+     * StringUtils.isAnyNotEmpty("""", ""bar"")        = true
+     * StringUtils.isAnyNotEmpty(""bob"", """")        = true
+     * StringUtils.isAnyNotEmpty(""  bob  "", null)  = true
+     * StringUtils.isAnyNotEmpty("" "", ""bar"")       = true
+     * StringUtils.isAnyNotEmpty(""foo"", ""bar"")     = true
+     * </pre>
+     *
+     * @param css  the CharSequences to check, may be null or empty
+     * @return {@code true} if any of the CharSequences are empty or null
+     * @since 3.5
+     */
+    public static boolean isAnyNotEmpty(final CharSequence... css) {
+      if (ArrayUtils.isEmpty(css)) {
+        return true;","[{'comment': ""Shouldn't this return false? An empty Array does not contain any non empty CharSequences. WDYT?\n"", 'commenter': 'britter'}, {'comment': 'I took the same behaviour as isAnyBlank()/isAnyEmpty() but maybe those should return false too. It would make more sense.\n', 'commenter': 'ptemplier'}]"
193,src/main/java/org/apache/commons/lang3/StringUtils.java,"@@ -358,6 +387,36 @@ public static boolean isAnyBlank(final CharSequence... css) {
     }
     
     /**
+     * <p>Checks if any one of the CharSequences are not blank ("""") or null and not whitespace only..</p>
+     *
+     * <pre>
+     * StringUtils.isAnyNotBlank(null)             = false
+     * StringUtils.isAnyNotBlank(null, ""foo"")      = true
+     * StringUtils.isAnyNotBlank(null, null)       = false
+     * StringUtils.isAnyNotBlank("""", ""bar"")        = true
+     * StringUtils.isAnyNotBlank(""bob"", """")        = true
+     * StringUtils.isAnyNotBlank(""  bob  "", null)  = true
+     * StringUtils.isAnyNotBlank("" "", ""bar"")       = true
+     * StringUtils.isAnyNotBlank(""foo"", ""bar"")     = false
+     * </pre>
+     *
+     * @param css  the CharSequences to check, may be null or empty
+     * @return {@code true} if any of the CharSequences are not blank or null or whitespace only
+     * @since 3.5
+     */
+    public static boolean isAnyNotBlank(final CharSequence... css) {
+      if (ArrayUtils.isEmpty(css)) {
+        return true;","[{'comment': 'See above\n', 'commenter': 'britter'}]"
231,src/main/java/org/apache/commons/lang3/ArchUtils.java,"@@ -0,0 +1,446 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.lang3;
+
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * An utility class for the os.arch System Property. The class defines methods for
+ * identifying the architecture of the current JVM.
+ * <p>
+ * <p>
+ * Important: The os.arch System Property returns the architecture used by the JVM
+ * not of the operating system.
+ * </p>
+ *
+ * @author Tomschi
+ */
+public class ArchUtils {
+
+    /**
+     * This {@link Map} contains the the possible os.arch property {@link String}'s.
+     */
+    private static final Map<String, String> map;
+
+    /**
+     * The value for x86 architecture.
+     */
+    private static final String X86 = ""x86"";
+
+    /**
+     * The value for x86_64 architecture.
+     */
+    private static final String X86_64 = ""x86_64"";
+
+    /**
+     * The value for ia64_32 architecture.
+     */
+    private static final String IA64_32 = ""ia64_32"";
+
+    /**
+     * The value for ia64 architecture.
+     */
+    private static final String IA64 = ""ia64"";
+
+    /**
+     * The value for ppc architecture.
+     */
+    private static final String PPC = ""ppc"";
+
+    /**
+     * The value for ppc64 architecture.
+     */
+    private static final String PPC64 = ""ppc64"";
+
+    static {
+        map = new HashMap<>();
+","[{'comment': 'HashMap is not thread-safe.\r\nSince there are public methods which can also update the map, this means the class is not thread-safe either.', 'commenter': 'sebbASF'}, {'comment': ""Indeed. The crypto implementation doesn't allow changes to the map after it has been created. I think we can use a ConcurrentHashMap, or simply follow what was done in crypto."", 'commenter': 'kinow'}]"
231,src/main/java/org/apache/commons/lang3/ArchUtils.java,"@@ -0,0 +1,446 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.lang3;
+
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+
+/**
+ * An utility class for the os.arch System Property. The class defines methods for
+ * identifying the architecture of the current JVM.
+ * <p>
+ * <p>
+ * Important: The os.arch System Property returns the architecture used by the JVM
+ * not of the operating system.
+ * </p>
+ *
+ * @author Tomschi","[{'comment': 'Author classes are not used any more in Commons. We have removed most, and now we maintain the list of contributors in the source control tool + pom.xml.', 'commenter': 'kinow'}]"
231,src/main/java/org/apache/commons/lang3/ArchUtils.java,"@@ -0,0 +1,446 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.lang3;
+
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+
+/**
+ * An utility class for the os.arch System Property. The class defines methods for
+ * identifying the architecture of the current JVM.
+ * <p>
+ * <p>
+ * Important: The os.arch System Property returns the architecture used by the JVM
+ * not of the operating system.
+ * </p>
+ *
+ * @author Tomschi
+ */
+public class ArchUtils {
+
+    /**
+     * This {@link Map} contains the the possible os.arch property {@link String}'s.
+     */
+    private static final Map<String, String> map;
+
+    /**
+     * The value for x86 architecture.
+     */
+    private static final String X86 = ""x86"";
+
+    /**
+     * The value for x86_64 architecture.
+     */
+    private static final String X86_64 = ""x86_64"";
+
+    /**
+     * The value for ia64_32 architecture.
+     */
+    private static final String IA64_32 = ""ia64_32"";
+
+    /**
+     * The value for ia64 architecture.
+     */
+    private static final String IA64 = ""ia64"";
+
+    /**
+     * The value for ppc architecture.
+     */
+    private static final String PPC = ""ppc"";
+
+    /**
+     * The value for ppc64 architecture.
+     */
+    private static final String PPC64 = ""ppc64"";
+
+    static {
+        map = new ConcurrentHashMap<>();","[{'comment': ""Much better, from a concurrency point of view :-)\r\n\r\nNow my preference would be do not allow the user to change it. Otherwise you could accidentally remove one arch, or overwrite it. Besides that, I don't see why we need to let users change that.\r\n\r\nIf there is an architecture that is not supported, I think it would be better that users will apply a temporary patch to their code and/or report an issue. Then we will update the list of architectures.\r\n\r\nMaybe we could include it as in [crypto] @Tomschi , as a read-only structure for now, and then later discuss about exposing methods to manipulate the map. What do you think? "", 'commenter': 'kinow'}, {'comment': 'It is for me ok, to remove the methods to adding own architectures.\r\n\r\nI only want to give the possibility to add missing architecture, when needed. Should i remove this methods now?', 'commenter': 'Tomschi'}]"
231,src/main/java/org/apache/commons/lang3/ArchUtils.java,"@@ -0,0 +1,446 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.lang3;
+
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+
+/**
+ * An utility class for the os.arch System Property. The class defines methods for
+ * identifying the architecture of the current JVM.
+ * <p>
+ * <p>
+ * Important: The os.arch System Property returns the architecture used by the JVM
+ * not of the operating system.
+ * </p>
+ *
+ * @author Tomschi
+ */
+public class ArchUtils {
+
+    /**
+     * This {@link Map} contains the the possible os.arch property {@link String}'s.
+     */
+    private static final Map<String, String> map;
+
+    /**
+     * The value for x86 architecture.
+     */
+    private static final String X86 = ""x86"";
+
+    /**
+     * The value for x86_64 architecture.
+     */
+    private static final String X86_64 = ""x86_64"";
+
+    /**
+     * The value for ia64_32 architecture.
+     */
+    private static final String IA64_32 = ""ia64_32"";
+
+    /**
+     * The value for ia64 architecture.
+     */
+    private static final String IA64 = ""ia64"";
+
+    /**
+     * The value for ppc architecture.
+     */
+    private static final String PPC = ""ppc"";
+
+    /**
+     * The value for ppc64 architecture.
+     */
+    private static final String PPC64 = ""ppc64"";
+
+    static {
+        map = new ConcurrentHashMap<>();
+
+        // x86 mappings
+        addX86(X86);
+        addX86(""i386"");
+        addX86(""i486"");
+        addX86(""i586"");
+        addX86(""i686"");
+        addX86(""pentium"");
+
+        // x86_64 mappings
+        addX86_64(X86_64);
+        addX86_64(""amd64"");
+        addX86_64(""em64t"");
+        addX86_64(""universal""); // Needed for openjdk7 in Mac
+
+        // Itenium 64-bit mappings
+        addIA64(IA64);
+        addIA64(""ia64w"");
+
+        // Itenium 32-bit mappings, usually an HP-UX construct
+        addIA64_32(IA64_32);
+        addIA64_32(""ia64n"");
+
+        // PowerPC mappings
+        addPPC(PPC);
+        addPPC(""power"");
+        addPPC(""powerpc"");
+        addPPC(""power_pc"");
+        addPPC(""power_rs"");
+
+        // PowerPC 64bit mappings
+        addPPC64(PPC64);
+        addPPC64(""power64"");
+        addPPC64(""powerpc64"");
+        addPPC64(""power_pc64"");
+        addPPC64(""power_rs64"");
+    }
+
+    /**
+     * Possibility to add {@link String}, representing the <code>System.getProperty(""os.arch"")</code>
+     * to x86 architecture.
+     *
+     * @param value The {@link String} to add.
+     */
+    public static final void addX86(String value) {
+        map.put(value, X86);
+    }
+
+    /**
+     * Checks if the current running JVM is a JVM for x86 architecture.
+     * It returns <code>true</code>, if the os.arch System Property matches the following {@link String}'s:
+     * <ul>
+     * <li>x86</li>
+     * <li>i386</li>
+     * <li>i486</li>
+     * <li>i586</li>
+     * <li>i686</li>
+     * <li>pentium</li>
+     * </ul>
+     * <p>
+     * It is possible to extend the {@link String}'s above using method {@link ArchUtils#addX86(String)}.
+     * <p>
+     * <p>
+     * Important: The os.arch System Property returns the architecture used by the JVM
+     * not of the operating system.
+     * </p>
+     *
+     * @return <code>True</code> if the current JVM is a x86 JVM, else <code>false</code>.
+     */
+    public static final boolean isX86JVM() {
+        return isX86JVM(SystemUtils.OS_ARCH);
+    }
+
+    /**
+     * Checks if the given {@link String} represents a x86 JVM. The {@link String} must be
+     * like a value returned by the os.arch System Property.
+     *
+     * @param value The value to check.
+     * @return <code>True</code>, if the {@link String} represents a x86 value, else <code>false</code>.
+     */
+    public static final boolean isX86JVM(String value) {
+        return StringUtils.equals(X86, map.get(value));
+    }
+
+    /**
+     * Possibility to add {@link String}, representing the <code>System.getProperty(""os.arch"")</code>
+     * to x86_64 architecture.
+     *
+     * @param value The {@link String} to add.
+     */
+    public static final void addX86_64(String value) {
+        map.put(value, X86_64);
+    }
+
+    /**
+     * Checks if the current running JVM is a JVM for x86_64 architecture.
+     * It returns <code>true</code>, if the os.arch System Property matches the following {@link String}'s:
+     * <ul>
+     * <li>x86_64</li>
+     * <li>amd64</li>
+     * <li>em64t</li>
+     * <li>universal</li>
+     * </ul>
+     * <p>
+     * It is possible to extend the {@link String}'s above using method {@link ArchUtils#addX86_64(String)}.
+     * <p>
+     * <p>
+     * Important: The os.arch System Property returns the architecture used by the JVM
+     * not of the operating system.
+     * </p>
+     *
+     * @return <code>True</code> if the current JVM is a x86_64 JVM, else <code>false</code>.
+     */
+    public static final boolean isX86_64JVM() {
+        return isX86_64JVM(SystemUtils.OS_ARCH);
+    }
+
+    /**
+     * Checks if the given {@link String} represents a x86_64 JVM. The {@link String} must be
+     * like a value returned by the os.arch System Property.
+     *
+     * @param value The value to check.
+     * @return <code>True</code>, if the {@link String} represents a x86_64 value, else <code>false</code>.
+     */
+    public static final boolean isX86_64JVM(String value) {
+        return StringUtils.equals(X86_64, map.get(value));
+    }
+
+    /**
+     * Possibility to add {@link String}, representing the <code>System.getProperty(""os.arch"")</code>
+     * to IA32_64 architecture.
+     *
+     * @param value The {@link String} to add.
+     */
+    public static final void addIA64_32(String value) {
+        map.put(value, IA64_32);
+    }
+
+    /**
+     * Checks if the current running JVM is a JVM for IA64 32 bit architecture.
+     * It returns <code>true</code>, if the os.arch System Property matches the following {@link String}'s:
+     * <ul>
+     * <li>ia64_32</li>
+     * <li>ia64n</li>
+     * </ul>
+     * <p>
+     * It is possible to extend the {@link String}'s above using method {@link ArchUtils#addIA64_32(String)}.
+     * <p>
+     * <p>
+     * Important: The os.arch System Property returns the architecture used by the JVM
+     * not of the operating system.
+     * </p>
+     *
+     * @return <code>True</code> if the current JVM is a IA64 32 bit JVM, else <code>false</code>.
+     */
+    public static final boolean isIA64_32JVM() {
+        return isIA64_32JVM(SystemUtils.OS_ARCH);
+    }
+
+    /**
+     * Checks if the given {@link String} represents a IA64_32 JVM. The {@link String} must be
+     * like a value returned by the os.arch System Property.
+     *
+     * @param value The value to check.
+     * @return <code>True</code>, if the {@link String} represents a IA64_32 value, else <code>false</code>.
+     */
+    public static final boolean isIA64_32JVM(String value) {
+        return StringUtils.equals(IA64_32, map.get(value));
+    }
+
+    /**
+     * Possibility to add {@link String}, representing the <code>System.getProperty(""os.arch"")</code>
+     * to IA64 architecture.
+     *
+     * @param value The {@link String} to add.
+     */
+    public static final void addIA64(String value) {
+        map.put(value, IA64);
+    }
+
+    /**
+     * Checks if the current running JVM is a JVM for IA64 architecture.
+     * It returns <code>true</code>, if the os.arch System Property matches the following {@link String}'s:
+     * <ul>
+     * <li>ia64</li>
+     * <li>ia64w</li>
+     * </ul>
+     * <p>
+     * It is possible to extend the {@link String}'s above using method {@link ArchUtils#addIA64(String)}.
+     * <p>
+     * <p>
+     * Important: The os.arch System Property returns the architecture used by the JVM
+     * not of the operating system.
+     * </p>
+     *
+     * @return <code>True</code> if the current JVM is a IA64 JVM, else <code>false</code>.
+     */
+    public static final boolean isIA64JVM() {
+        return isIA64JVM(SystemUtils.OS_ARCH);
+    }
+
+    /**
+     * Checks if the given {@link String} represents a IA64 JVM. The {@link String} must be
+     * like a value returned by the os.arch System Property.
+     *
+     * @param value The value to check.
+     * @return <code>True</code>, if the {@link String} represents a IA64 value, else <code>false</code>.
+     */
+    public static final boolean isIA64JVM(String value) {
+        return StringUtils.equals(IA64, map.get(value));
+    }
+
+    /**
+     * Possibility to add {@link String}, representing the <code>System.getProperty(""os.arch"")</code>
+     * to PPC architecture.
+     *
+     * @param value The {@link String} to add.
+     */
+    public static final void addPPC(String value) {
+        map.put(value, PPC);
+    }
+
+    /**
+     * Checks if the current running JVM is a JVM for PPC architecture.
+     * It returns <code>true</code>, if the os.arch System Property matches the following {@link String}'s:
+     * <ul>
+     * <li>ppc</li>
+     * <li>powerpc</li>
+     * <li>power_pc</li>
+     * <li>power_rs</li>
+     * </ul>
+     * <p>
+     * It is possible to extend the {@link String}'s above using method {@link ArchUtils#addPPC(String)}.
+     * <p>
+     * <p>
+     * Important: The os.arch System Property returns the architecture used by the JVM
+     * not of the operating system.
+     * </p>
+     *
+     * @return <code>True</code> if the current JVM is a PPC JVM, else <code>false</code>.
+     */
+    public static final boolean isPPCJVM() {
+        return isPPCJVM(SystemUtils.OS_ARCH);
+    }
+
+    /**
+     * Checks if the given {@link String} represents a PPC JVM. The {@link String} must be
+     * like a value returned by the os.arch System Property.
+     *
+     * @param value The value to check.
+     * @return <code>True</code>, if the {@link String} represents a PPC value, else <code>false</code>.
+     */
+    public static final boolean isPPCJVM(String value) {
+        return StringUtils.equals(PPC, map.get(value));
+    }
+
+    /**
+     * Possibility to add {@link String}, representing the <code>System.getProperty(""os.arch"")</code>
+     * to PPC_64 architecture.
+     *
+     * @param value The {@link String} to add.
+     */
+    public static final void addPPC64(String value) {
+        map.put(value, PPC64);
+    }
+
+    /**
+     * Checks if the current running JVM is a JVM for PPC 64 bit architecture.
+     * It returns <code>true</code>, if the os.arch System Property matches the following {@link String}'s:
+     * <ul>
+     * <li>ppc64</li>
+     * <li>powerpc64</li>
+     * <li>power_pc64</li>
+     * <li>power_rs64</li>
+     * </ul>
+     * <p>
+     * It is possible to extend the {@link String}'s above using method {@link ArchUtils#addPPC64(String)}.
+     * <p>
+     * <p>
+     * Important: The os.arch System Property returns the architecture used by the JVM
+     * not of the operating system.
+     * </p>
+     *
+     * @return <code>True</code> if the current JVM is a PPC 64 bit JVM, else <code>false</code>.
+     */
+    public static final boolean isPPC64JVM() {
+        return isPPC64JVM(SystemUtils.OS_ARCH);
+    }
+
+    /**
+     * Checks if the given {@link String} represents a PPC 64 JVM. The {@link String} must be
+     * like a value returned by the os.arch System Property.
+     *
+     * @param value The value to check.
+     * @return <code>True</code>, if the {@link String} represents a PPC 64 value, else <code>false</code>.
+     */
+    public static final boolean isPPC64JVM(String value) {
+        return StringUtils.equals(PPC64, map.get(value));
+    }
+
+    /**
+     * Checks if the current running JVM is a 32 bit JVM using the os.arch System Property.
+     * <p>
+     * <p>
+     * Important: The os.arch System Property returns the architecture used by the JVM
+     * not of the operating system.
+     * </p>
+     *
+     * @return <code>True</code>, if the current JVM is 32 bit, else <code>false</code>.
+     */
+    public static final boolean is32BitJVM() {
+        return isX86JVM() || isIA64_32JVM() || isPPCJVM();
+    }
+
+    /**
+     * Checks if the given {@link String} represents a 32 bit JVM. The {@link String} must be
+     * like a value returned by the os.arch System Property.
+     *
+     * @param value The value to check.
+     * @return <code>True</code>, if the {@link String} represents a 32 bit value, else <code>false</code>.
+     */
+    public static final boolean is32BitJVM(String value) {
+        return isX86JVM(value) || isIA64_32JVM(value) || isPPCJVM(value);
+    }
+
+    /**
+     * Checks if the current running JVM is a 64 bit JVM using the os.arch System Property.
+     * <p>
+     * <p>
+     * Important: The os.arch System Property returns the architecture used by the JVM
+     * not of the operating system.
+     * </p>
+     *
+     * @return <code>True</code>, if the current JVM is 64 bit, else <code>false</code>.
+     */
+    public static final boolean is64BitJVM() {
+        return isX86_64JVM() || isIA64JVM() || isPPC64JVM();
+    }
+
+    /**
+     * Checks if the given {@link String} represents a 64 bit JVM. The {@link String} must be
+     * like a value returned by the os.arch System Property.
+     *
+     * @param value The value to check.
+     * @return <code>True</code>, if the {@link String} represents a 64 bit value, else <code>false</code>.
+     */
+    public static final boolean is64BitJVM(String value) {
+        return isX86_64JVM(value) || isIA64JVM(value) || isPPC64JVM(value);
+    }
+
+    /**
+     * Checks if the os.arch System Property {@link String} of the current JVM is supported.
+     * <p>
+     * <p>
+     * Important: The os.arch System Property returns the architecture used by the JVM
+     * not of the operating system.
+     * </p>
+     *
+     * @return <code>True</code>, if supported, else <code>false</code>.
+     */
+    public static final boolean isSupported() {","[{'comment': ""Very interesting methods! Hadn't thought about adding them! Kudos :-)"", 'commenter': 'kinow'}]"
231,src/main/java/org/apache/commons/lang3/ArchUtils.java,"@@ -0,0 +1,446 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.lang3;
+
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+
+/**
+ * An utility class for the os.arch System Property. The class defines methods for
+ * identifying the architecture of the current JVM.
+ * <p>","[{'comment': 'Minor bug in Javadoc HTML. Extra opening paragraph. Can be fixed later too.', 'commenter': 'kinow'}]"
231,src/main/java/org/apache/commons/lang3/ArchUtils.java,"@@ -0,0 +1,446 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.lang3;
+
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+
+/**
+ * An utility class for the os.arch System Property. The class defines methods for
+ * identifying the architecture of the current JVM.
+ * <p>
+ * <p>
+ * Important: The os.arch System Property returns the architecture used by the JVM
+ * not of the operating system.
+ * </p>
+ *
+ * @author Tomschi
+ */
+public class ArchUtils {
+
+    /**
+     * This {@link Map} contains the the possible os.arch property {@link String}'s.
+     */
+    private static final Map<String, String> map;
+
+    /**
+     * The value for x86 architecture.
+     */
+    private static final String X86 = ""x86"";
+
+    /**
+     * The value for x86_64 architecture.
+     */
+    private static final String X86_64 = ""x86_64"";
+
+    /**
+     * The value for ia64_32 architecture.
+     */
+    private static final String IA64_32 = ""ia64_32"";
+
+    /**
+     * The value for ia64 architecture.
+     */
+    private static final String IA64 = ""ia64"";
+
+    /**
+     * The value for ppc architecture.
+     */
+    private static final String PPC = ""ppc"";
+
+    /**
+     * The value for ppc64 architecture.
+     */
+    private static final String PPC64 = ""ppc64"";
+
+    static {
+        map = new ConcurrentHashMap<>();
+
+        // x86 mappings
+        addX86(X86);
+        addX86(""i386"");
+        addX86(""i486"");
+        addX86(""i586"");
+        addX86(""i686"");
+        addX86(""pentium"");
+
+        // x86_64 mappings
+        addX86_64(X86_64);
+        addX86_64(""amd64"");
+        addX86_64(""em64t"");
+        addX86_64(""universal""); // Needed for openjdk7 in Mac
+
+        // Itenium 64-bit mappings
+        addIA64(IA64);
+        addIA64(""ia64w"");
+
+        // Itenium 32-bit mappings, usually an HP-UX construct
+        addIA64_32(IA64_32);
+        addIA64_32(""ia64n"");
+
+        // PowerPC mappings
+        addPPC(PPC);
+        addPPC(""power"");
+        addPPC(""powerpc"");
+        addPPC(""power_pc"");
+        addPPC(""power_rs"");
+
+        // PowerPC 64bit mappings
+        addPPC64(PPC64);
+        addPPC64(""power64"");
+        addPPC64(""powerpc64"");
+        addPPC64(""power_pc64"");
+        addPPC64(""power_rs64"");
+    }
+
+    /**
+     * Possibility to add {@link String}, representing the <code>System.getProperty(""os.arch"")</code>
+     * to x86 architecture.
+     *
+     * @param value The {@link String} to add.
+     */
+    public static final void addX86(String value) {
+        map.put(value, X86);
+    }
+
+    /**
+     * Checks if the current running JVM is a JVM for x86 architecture.
+     * It returns <code>true</code>, if the os.arch System Property matches the following {@link String}'s:
+     * <ul>
+     * <li>x86</li>
+     * <li>i386</li>
+     * <li>i486</li>
+     * <li>i586</li>
+     * <li>i686</li>
+     * <li>pentium</li>
+     * </ul>
+     * <p>
+     * It is possible to extend the {@link String}'s above using method {@link ArchUtils#addX86(String)}.
+     * <p>","[{'comment': '\r\n\r\nMinor bug in Javadoc HTML. Extra opening paragraph. Can be fixed later too.\r\n', 'commenter': 'kinow'}]"
231,src/main/java/org/apache/commons/lang3/ArchUtils.java,"@@ -0,0 +1,446 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.lang3;
+
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+
+/**
+ * An utility class for the os.arch System Property. The class defines methods for
+ * identifying the architecture of the current JVM.
+ * <p>
+ * <p>
+ * Important: The os.arch System Property returns the architecture used by the JVM
+ * not of the operating system.
+ * </p>
+ *
+ * @author Tomschi
+ */
+public class ArchUtils {
+
+    /**
+     * This {@link Map} contains the the possible os.arch property {@link String}'s.
+     */
+    private static final Map<String, String> map;
+
+    /**
+     * The value for x86 architecture.
+     */
+    private static final String X86 = ""x86"";
+
+    /**
+     * The value for x86_64 architecture.
+     */
+    private static final String X86_64 = ""x86_64"";
+
+    /**
+     * The value for ia64_32 architecture.
+     */
+    private static final String IA64_32 = ""ia64_32"";
+
+    /**
+     * The value for ia64 architecture.
+     */
+    private static final String IA64 = ""ia64"";
+
+    /**
+     * The value for ppc architecture.
+     */
+    private static final String PPC = ""ppc"";
+
+    /**
+     * The value for ppc64 architecture.
+     */
+    private static final String PPC64 = ""ppc64"";
+
+    static {
+        map = new ConcurrentHashMap<>();
+
+        // x86 mappings
+        addX86(X86);
+        addX86(""i386"");
+        addX86(""i486"");
+        addX86(""i586"");
+        addX86(""i686"");
+        addX86(""pentium"");
+
+        // x86_64 mappings
+        addX86_64(X86_64);
+        addX86_64(""amd64"");
+        addX86_64(""em64t"");
+        addX86_64(""universal""); // Needed for openjdk7 in Mac
+
+        // Itenium 64-bit mappings
+        addIA64(IA64);
+        addIA64(""ia64w"");
+
+        // Itenium 32-bit mappings, usually an HP-UX construct
+        addIA64_32(IA64_32);
+        addIA64_32(""ia64n"");
+
+        // PowerPC mappings
+        addPPC(PPC);
+        addPPC(""power"");
+        addPPC(""powerpc"");
+        addPPC(""power_pc"");
+        addPPC(""power_rs"");
+
+        // PowerPC 64bit mappings
+        addPPC64(PPC64);
+        addPPC64(""power64"");
+        addPPC64(""powerpc64"");
+        addPPC64(""power_pc64"");
+        addPPC64(""power_rs64"");
+    }
+
+    /**
+     * Possibility to add {@link String}, representing the <code>System.getProperty(""os.arch"")</code>
+     * to x86 architecture.
+     *
+     * @param value The {@link String} to add.
+     */
+    public static final void addX86(String value) {
+        map.put(value, X86);
+    }
+
+    /**
+     * Checks if the current running JVM is a JVM for x86 architecture.
+     * It returns <code>true</code>, if the os.arch System Property matches the following {@link String}'s:
+     * <ul>
+     * <li>x86</li>
+     * <li>i386</li>
+     * <li>i486</li>
+     * <li>i586</li>
+     * <li>i686</li>
+     * <li>pentium</li>
+     * </ul>
+     * <p>
+     * It is possible to extend the {@link String}'s above using method {@link ArchUtils#addX86(String)}.
+     * <p>
+     * <p>
+     * Important: The os.arch System Property returns the architecture used by the JVM
+     * not of the operating system.
+     * </p>
+     *
+     * @return <code>True</code> if the current JVM is a x86 JVM, else <code>false</code>.
+     */
+    public static final boolean isX86JVM() {
+        return isX86JVM(SystemUtils.OS_ARCH);
+    }
+
+    /**
+     * Checks if the given {@link String} represents a x86 JVM. The {@link String} must be
+     * like a value returned by the os.arch System Property.
+     *
+     * @param value The value to check.
+     * @return <code>True</code>, if the {@link String} represents a x86 value, else <code>false</code>.
+     */
+    public static final boolean isX86JVM(String value) {
+        return StringUtils.equals(X86, map.get(value));
+    }
+
+    /**
+     * Possibility to add {@link String}, representing the <code>System.getProperty(""os.arch"")</code>
+     * to x86_64 architecture.
+     *
+     * @param value The {@link String} to add.
+     */
+    public static final void addX86_64(String value) {
+        map.put(value, X86_64);
+    }
+
+    /**
+     * Checks if the current running JVM is a JVM for x86_64 architecture.
+     * It returns <code>true</code>, if the os.arch System Property matches the following {@link String}'s:
+     * <ul>
+     * <li>x86_64</li>
+     * <li>amd64</li>
+     * <li>em64t</li>
+     * <li>universal</li>
+     * </ul>
+     * <p>
+     * It is possible to extend the {@link String}'s above using method {@link ArchUtils#addX86_64(String)}.
+     * <p>","[{'comment': '\r\n\r\nMinor bug in Javadoc HTML. Extra opening paragraph. Can be fixed later too.\r\n', 'commenter': 'kinow'}]"
231,src/main/java/org/apache/commons/lang3/ArchUtils.java,"@@ -0,0 +1,446 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.lang3;
+
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+
+/**
+ * An utility class for the os.arch System Property. The class defines methods for
+ * identifying the architecture of the current JVM.
+ * <p>
+ * <p>
+ * Important: The os.arch System Property returns the architecture used by the JVM
+ * not of the operating system.
+ * </p>
+ *
+ * @author Tomschi
+ */
+public class ArchUtils {
+
+    /**
+     * This {@link Map} contains the the possible os.arch property {@link String}'s.
+     */
+    private static final Map<String, String> map;
+
+    /**
+     * The value for x86 architecture.
+     */
+    private static final String X86 = ""x86"";
+
+    /**
+     * The value for x86_64 architecture.
+     */
+    private static final String X86_64 = ""x86_64"";
+
+    /**
+     * The value for ia64_32 architecture.
+     */
+    private static final String IA64_32 = ""ia64_32"";
+
+    /**
+     * The value for ia64 architecture.
+     */
+    private static final String IA64 = ""ia64"";
+
+    /**
+     * The value for ppc architecture.
+     */
+    private static final String PPC = ""ppc"";
+
+    /**
+     * The value for ppc64 architecture.
+     */
+    private static final String PPC64 = ""ppc64"";
+
+    static {
+        map = new ConcurrentHashMap<>();
+
+        // x86 mappings
+        addX86(X86);
+        addX86(""i386"");
+        addX86(""i486"");
+        addX86(""i586"");
+        addX86(""i686"");
+        addX86(""pentium"");
+
+        // x86_64 mappings
+        addX86_64(X86_64);
+        addX86_64(""amd64"");
+        addX86_64(""em64t"");
+        addX86_64(""universal""); // Needed for openjdk7 in Mac
+
+        // Itenium 64-bit mappings
+        addIA64(IA64);
+        addIA64(""ia64w"");
+
+        // Itenium 32-bit mappings, usually an HP-UX construct
+        addIA64_32(IA64_32);
+        addIA64_32(""ia64n"");
+
+        // PowerPC mappings
+        addPPC(PPC);
+        addPPC(""power"");
+        addPPC(""powerpc"");
+        addPPC(""power_pc"");
+        addPPC(""power_rs"");
+
+        // PowerPC 64bit mappings
+        addPPC64(PPC64);
+        addPPC64(""power64"");
+        addPPC64(""powerpc64"");
+        addPPC64(""power_pc64"");
+        addPPC64(""power_rs64"");
+    }
+
+    /**
+     * Possibility to add {@link String}, representing the <code>System.getProperty(""os.arch"")</code>
+     * to x86 architecture.
+     *
+     * @param value The {@link String} to add.
+     */
+    public static final void addX86(String value) {
+        map.put(value, X86);
+    }
+
+    /**
+     * Checks if the current running JVM is a JVM for x86 architecture.
+     * It returns <code>true</code>, if the os.arch System Property matches the following {@link String}'s:
+     * <ul>
+     * <li>x86</li>
+     * <li>i386</li>
+     * <li>i486</li>
+     * <li>i586</li>
+     * <li>i686</li>
+     * <li>pentium</li>
+     * </ul>
+     * <p>
+     * It is possible to extend the {@link String}'s above using method {@link ArchUtils#addX86(String)}.
+     * <p>
+     * <p>
+     * Important: The os.arch System Property returns the architecture used by the JVM
+     * not of the operating system.
+     * </p>
+     *
+     * @return <code>True</code> if the current JVM is a x86 JVM, else <code>false</code>.
+     */
+    public static final boolean isX86JVM() {
+        return isX86JVM(SystemUtils.OS_ARCH);
+    }
+
+    /**
+     * Checks if the given {@link String} represents a x86 JVM. The {@link String} must be
+     * like a value returned by the os.arch System Property.
+     *
+     * @param value The value to check.
+     * @return <code>True</code>, if the {@link String} represents a x86 value, else <code>false</code>.
+     */
+    public static final boolean isX86JVM(String value) {
+        return StringUtils.equals(X86, map.get(value));
+    }
+
+    /**
+     * Possibility to add {@link String}, representing the <code>System.getProperty(""os.arch"")</code>
+     * to x86_64 architecture.
+     *
+     * @param value The {@link String} to add.
+     */
+    public static final void addX86_64(String value) {
+        map.put(value, X86_64);
+    }
+
+    /**
+     * Checks if the current running JVM is a JVM for x86_64 architecture.
+     * It returns <code>true</code>, if the os.arch System Property matches the following {@link String}'s:
+     * <ul>
+     * <li>x86_64</li>
+     * <li>amd64</li>
+     * <li>em64t</li>
+     * <li>universal</li>
+     * </ul>
+     * <p>
+     * It is possible to extend the {@link String}'s above using method {@link ArchUtils#addX86_64(String)}.
+     * <p>
+     * <p>
+     * Important: The os.arch System Property returns the architecture used by the JVM
+     * not of the operating system.
+     * </p>
+     *
+     * @return <code>True</code> if the current JVM is a x86_64 JVM, else <code>false</code>.
+     */
+    public static final boolean isX86_64JVM() {
+        return isX86_64JVM(SystemUtils.OS_ARCH);
+    }
+
+    /**
+     * Checks if the given {@link String} represents a x86_64 JVM. The {@link String} must be
+     * like a value returned by the os.arch System Property.
+     *
+     * @param value The value to check.
+     * @return <code>True</code>, if the {@link String} represents a x86_64 value, else <code>false</code>.
+     */
+    public static final boolean isX86_64JVM(String value) {
+        return StringUtils.equals(X86_64, map.get(value));
+    }
+
+    /**
+     * Possibility to add {@link String}, representing the <code>System.getProperty(""os.arch"")</code>
+     * to IA32_64 architecture.
+     *
+     * @param value The {@link String} to add.
+     */
+    public static final void addIA64_32(String value) {
+        map.put(value, IA64_32);
+    }
+
+    /**
+     * Checks if the current running JVM is a JVM for IA64 32 bit architecture.
+     * It returns <code>true</code>, if the os.arch System Property matches the following {@link String}'s:
+     * <ul>
+     * <li>ia64_32</li>
+     * <li>ia64n</li>
+     * </ul>
+     * <p>
+     * It is possible to extend the {@link String}'s above using method {@link ArchUtils#addIA64_32(String)}.
+     * <p>","[{'comment': '\r\n\r\nMinor bug in Javadoc HTML. Extra opening paragraph. Can be fixed later too.\r\n', 'commenter': 'kinow'}]"
231,src/main/java/org/apache/commons/lang3/ArchUtils.java,"@@ -0,0 +1,446 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.lang3;
+
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+
+/**
+ * An utility class for the os.arch System Property. The class defines methods for
+ * identifying the architecture of the current JVM.
+ * <p>
+ * <p>
+ * Important: The os.arch System Property returns the architecture used by the JVM
+ * not of the operating system.
+ * </p>
+ *
+ * @author Tomschi
+ */
+public class ArchUtils {
+
+    /**
+     * This {@link Map} contains the the possible os.arch property {@link String}'s.
+     */
+    private static final Map<String, String> map;
+
+    /**
+     * The value for x86 architecture.
+     */
+    private static final String X86 = ""x86"";
+
+    /**
+     * The value for x86_64 architecture.
+     */
+    private static final String X86_64 = ""x86_64"";
+
+    /**
+     * The value for ia64_32 architecture.
+     */
+    private static final String IA64_32 = ""ia64_32"";
+
+    /**
+     * The value for ia64 architecture.
+     */
+    private static final String IA64 = ""ia64"";
+
+    /**
+     * The value for ppc architecture.
+     */
+    private static final String PPC = ""ppc"";
+
+    /**
+     * The value for ppc64 architecture.
+     */
+    private static final String PPC64 = ""ppc64"";
+
+    static {
+        map = new ConcurrentHashMap<>();
+
+        // x86 mappings
+        addX86(X86);
+        addX86(""i386"");
+        addX86(""i486"");
+        addX86(""i586"");
+        addX86(""i686"");
+        addX86(""pentium"");
+
+        // x86_64 mappings
+        addX86_64(X86_64);
+        addX86_64(""amd64"");
+        addX86_64(""em64t"");
+        addX86_64(""universal""); // Needed for openjdk7 in Mac
+
+        // Itenium 64-bit mappings
+        addIA64(IA64);
+        addIA64(""ia64w"");
+
+        // Itenium 32-bit mappings, usually an HP-UX construct
+        addIA64_32(IA64_32);
+        addIA64_32(""ia64n"");
+
+        // PowerPC mappings
+        addPPC(PPC);
+        addPPC(""power"");
+        addPPC(""powerpc"");
+        addPPC(""power_pc"");
+        addPPC(""power_rs"");
+
+        // PowerPC 64bit mappings
+        addPPC64(PPC64);
+        addPPC64(""power64"");
+        addPPC64(""powerpc64"");
+        addPPC64(""power_pc64"");
+        addPPC64(""power_rs64"");
+    }
+
+    /**
+     * Possibility to add {@link String}, representing the <code>System.getProperty(""os.arch"")</code>
+     * to x86 architecture.
+     *
+     * @param value The {@link String} to add.
+     */
+    public static final void addX86(String value) {
+        map.put(value, X86);
+    }
+
+    /**
+     * Checks if the current running JVM is a JVM for x86 architecture.
+     * It returns <code>true</code>, if the os.arch System Property matches the following {@link String}'s:
+     * <ul>
+     * <li>x86</li>
+     * <li>i386</li>
+     * <li>i486</li>
+     * <li>i586</li>
+     * <li>i686</li>
+     * <li>pentium</li>
+     * </ul>
+     * <p>
+     * It is possible to extend the {@link String}'s above using method {@link ArchUtils#addX86(String)}.
+     * <p>
+     * <p>
+     * Important: The os.arch System Property returns the architecture used by the JVM
+     * not of the operating system.
+     * </p>
+     *
+     * @return <code>True</code> if the current JVM is a x86 JVM, else <code>false</code>.
+     */
+    public static final boolean isX86JVM() {
+        return isX86JVM(SystemUtils.OS_ARCH);
+    }
+
+    /**
+     * Checks if the given {@link String} represents a x86 JVM. The {@link String} must be
+     * like a value returned by the os.arch System Property.
+     *
+     * @param value The value to check.
+     * @return <code>True</code>, if the {@link String} represents a x86 value, else <code>false</code>.
+     */
+    public static final boolean isX86JVM(String value) {
+        return StringUtils.equals(X86, map.get(value));
+    }
+
+    /**
+     * Possibility to add {@link String}, representing the <code>System.getProperty(""os.arch"")</code>
+     * to x86_64 architecture.
+     *
+     * @param value The {@link String} to add.
+     */
+    public static final void addX86_64(String value) {
+        map.put(value, X86_64);
+    }
+
+    /**
+     * Checks if the current running JVM is a JVM for x86_64 architecture.
+     * It returns <code>true</code>, if the os.arch System Property matches the following {@link String}'s:
+     * <ul>
+     * <li>x86_64</li>
+     * <li>amd64</li>
+     * <li>em64t</li>
+     * <li>universal</li>
+     * </ul>
+     * <p>
+     * It is possible to extend the {@link String}'s above using method {@link ArchUtils#addX86_64(String)}.
+     * <p>
+     * <p>
+     * Important: The os.arch System Property returns the architecture used by the JVM
+     * not of the operating system.
+     * </p>
+     *
+     * @return <code>True</code> if the current JVM is a x86_64 JVM, else <code>false</code>.
+     */
+    public static final boolean isX86_64JVM() {
+        return isX86_64JVM(SystemUtils.OS_ARCH);
+    }
+
+    /**
+     * Checks if the given {@link String} represents a x86_64 JVM. The {@link String} must be
+     * like a value returned by the os.arch System Property.
+     *
+     * @param value The value to check.
+     * @return <code>True</code>, if the {@link String} represents a x86_64 value, else <code>false</code>.
+     */
+    public static final boolean isX86_64JVM(String value) {
+        return StringUtils.equals(X86_64, map.get(value));
+    }
+
+    /**
+     * Possibility to add {@link String}, representing the <code>System.getProperty(""os.arch"")</code>
+     * to IA32_64 architecture.
+     *
+     * @param value The {@link String} to add.
+     */
+    public static final void addIA64_32(String value) {
+        map.put(value, IA64_32);
+    }
+
+    /**
+     * Checks if the current running JVM is a JVM for IA64 32 bit architecture.
+     * It returns <code>true</code>, if the os.arch System Property matches the following {@link String}'s:
+     * <ul>
+     * <li>ia64_32</li>
+     * <li>ia64n</li>
+     * </ul>
+     * <p>
+     * It is possible to extend the {@link String}'s above using method {@link ArchUtils#addIA64_32(String)}.
+     * <p>
+     * <p>
+     * Important: The os.arch System Property returns the architecture used by the JVM
+     * not of the operating system.
+     * </p>
+     *
+     * @return <code>True</code> if the current JVM is a IA64 32 bit JVM, else <code>false</code>.
+     */
+    public static final boolean isIA64_32JVM() {
+        return isIA64_32JVM(SystemUtils.OS_ARCH);
+    }
+
+    /**
+     * Checks if the given {@link String} represents a IA64_32 JVM. The {@link String} must be
+     * like a value returned by the os.arch System Property.
+     *
+     * @param value The value to check.
+     * @return <code>True</code>, if the {@link String} represents a IA64_32 value, else <code>false</code>.
+     */
+    public static final boolean isIA64_32JVM(String value) {
+        return StringUtils.equals(IA64_32, map.get(value));
+    }
+
+    /**
+     * Possibility to add {@link String}, representing the <code>System.getProperty(""os.arch"")</code>
+     * to IA64 architecture.
+     *
+     * @param value The {@link String} to add.
+     */
+    public static final void addIA64(String value) {
+        map.put(value, IA64);
+    }
+
+    /**
+     * Checks if the current running JVM is a JVM for IA64 architecture.
+     * It returns <code>true</code>, if the os.arch System Property matches the following {@link String}'s:
+     * <ul>
+     * <li>ia64</li>
+     * <li>ia64w</li>
+     * </ul>
+     * <p>
+     * It is possible to extend the {@link String}'s above using method {@link ArchUtils#addIA64(String)}.
+     * <p>","[{'comment': '\r\n\r\nMinor bug in Javadoc HTML. Extra opening paragraph. Can be fixed later too.\r\n', 'commenter': 'kinow'}]"
231,src/main/java/org/apache/commons/lang3/ArchUtils.java,"@@ -0,0 +1,446 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.lang3;
+
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+
+/**
+ * An utility class for the os.arch System Property. The class defines methods for
+ * identifying the architecture of the current JVM.
+ * <p>
+ * <p>
+ * Important: The os.arch System Property returns the architecture used by the JVM
+ * not of the operating system.
+ * </p>
+ *
+ * @author Tomschi
+ */
+public class ArchUtils {
+
+    /**
+     * This {@link Map} contains the the possible os.arch property {@link String}'s.
+     */
+    private static final Map<String, String> map;
+
+    /**
+     * The value for x86 architecture.
+     */
+    private static final String X86 = ""x86"";
+
+    /**
+     * The value for x86_64 architecture.
+     */
+    private static final String X86_64 = ""x86_64"";
+
+    /**
+     * The value for ia64_32 architecture.
+     */
+    private static final String IA64_32 = ""ia64_32"";
+
+    /**
+     * The value for ia64 architecture.
+     */
+    private static final String IA64 = ""ia64"";
+
+    /**
+     * The value for ppc architecture.
+     */
+    private static final String PPC = ""ppc"";
+
+    /**
+     * The value for ppc64 architecture.
+     */
+    private static final String PPC64 = ""ppc64"";
+
+    static {
+        map = new ConcurrentHashMap<>();
+
+        // x86 mappings
+        addX86(X86);
+        addX86(""i386"");
+        addX86(""i486"");
+        addX86(""i586"");
+        addX86(""i686"");
+        addX86(""pentium"");
+
+        // x86_64 mappings
+        addX86_64(X86_64);
+        addX86_64(""amd64"");
+        addX86_64(""em64t"");
+        addX86_64(""universal""); // Needed for openjdk7 in Mac
+
+        // Itenium 64-bit mappings
+        addIA64(IA64);
+        addIA64(""ia64w"");
+
+        // Itenium 32-bit mappings, usually an HP-UX construct
+        addIA64_32(IA64_32);
+        addIA64_32(""ia64n"");
+
+        // PowerPC mappings
+        addPPC(PPC);
+        addPPC(""power"");
+        addPPC(""powerpc"");
+        addPPC(""power_pc"");
+        addPPC(""power_rs"");
+
+        // PowerPC 64bit mappings
+        addPPC64(PPC64);
+        addPPC64(""power64"");
+        addPPC64(""powerpc64"");
+        addPPC64(""power_pc64"");
+        addPPC64(""power_rs64"");
+    }
+
+    /**
+     * Possibility to add {@link String}, representing the <code>System.getProperty(""os.arch"")</code>
+     * to x86 architecture.
+     *
+     * @param value The {@link String} to add.
+     */
+    public static final void addX86(String value) {
+        map.put(value, X86);
+    }
+
+    /**
+     * Checks if the current running JVM is a JVM for x86 architecture.
+     * It returns <code>true</code>, if the os.arch System Property matches the following {@link String}'s:
+     * <ul>
+     * <li>x86</li>
+     * <li>i386</li>
+     * <li>i486</li>
+     * <li>i586</li>
+     * <li>i686</li>
+     * <li>pentium</li>
+     * </ul>
+     * <p>
+     * It is possible to extend the {@link String}'s above using method {@link ArchUtils#addX86(String)}.
+     * <p>
+     * <p>
+     * Important: The os.arch System Property returns the architecture used by the JVM
+     * not of the operating system.
+     * </p>
+     *
+     * @return <code>True</code> if the current JVM is a x86 JVM, else <code>false</code>.
+     */
+    public static final boolean isX86JVM() {
+        return isX86JVM(SystemUtils.OS_ARCH);
+    }
+
+    /**
+     * Checks if the given {@link String} represents a x86 JVM. The {@link String} must be
+     * like a value returned by the os.arch System Property.
+     *
+     * @param value The value to check.
+     * @return <code>True</code>, if the {@link String} represents a x86 value, else <code>false</code>.
+     */
+    public static final boolean isX86JVM(String value) {
+        return StringUtils.equals(X86, map.get(value));
+    }
+
+    /**
+     * Possibility to add {@link String}, representing the <code>System.getProperty(""os.arch"")</code>
+     * to x86_64 architecture.
+     *
+     * @param value The {@link String} to add.
+     */
+    public static final void addX86_64(String value) {
+        map.put(value, X86_64);
+    }
+
+    /**
+     * Checks if the current running JVM is a JVM for x86_64 architecture.
+     * It returns <code>true</code>, if the os.arch System Property matches the following {@link String}'s:
+     * <ul>
+     * <li>x86_64</li>
+     * <li>amd64</li>
+     * <li>em64t</li>
+     * <li>universal</li>
+     * </ul>
+     * <p>
+     * It is possible to extend the {@link String}'s above using method {@link ArchUtils#addX86_64(String)}.
+     * <p>
+     * <p>
+     * Important: The os.arch System Property returns the architecture used by the JVM
+     * not of the operating system.
+     * </p>
+     *
+     * @return <code>True</code> if the current JVM is a x86_64 JVM, else <code>false</code>.
+     */
+    public static final boolean isX86_64JVM() {
+        return isX86_64JVM(SystemUtils.OS_ARCH);
+    }
+
+    /**
+     * Checks if the given {@link String} represents a x86_64 JVM. The {@link String} must be
+     * like a value returned by the os.arch System Property.
+     *
+     * @param value The value to check.
+     * @return <code>True</code>, if the {@link String} represents a x86_64 value, else <code>false</code>.
+     */
+    public static final boolean isX86_64JVM(String value) {
+        return StringUtils.equals(X86_64, map.get(value));
+    }
+
+    /**
+     * Possibility to add {@link String}, representing the <code>System.getProperty(""os.arch"")</code>
+     * to IA32_64 architecture.
+     *
+     * @param value The {@link String} to add.
+     */
+    public static final void addIA64_32(String value) {
+        map.put(value, IA64_32);
+    }
+
+    /**
+     * Checks if the current running JVM is a JVM for IA64 32 bit architecture.
+     * It returns <code>true</code>, if the os.arch System Property matches the following {@link String}'s:
+     * <ul>
+     * <li>ia64_32</li>
+     * <li>ia64n</li>
+     * </ul>
+     * <p>
+     * It is possible to extend the {@link String}'s above using method {@link ArchUtils#addIA64_32(String)}.
+     * <p>
+     * <p>
+     * Important: The os.arch System Property returns the architecture used by the JVM
+     * not of the operating system.
+     * </p>
+     *
+     * @return <code>True</code> if the current JVM is a IA64 32 bit JVM, else <code>false</code>.
+     */
+    public static final boolean isIA64_32JVM() {
+        return isIA64_32JVM(SystemUtils.OS_ARCH);
+    }
+
+    /**
+     * Checks if the given {@link String} represents a IA64_32 JVM. The {@link String} must be
+     * like a value returned by the os.arch System Property.
+     *
+     * @param value The value to check.
+     * @return <code>True</code>, if the {@link String} represents a IA64_32 value, else <code>false</code>.
+     */
+    public static final boolean isIA64_32JVM(String value) {
+        return StringUtils.equals(IA64_32, map.get(value));
+    }
+
+    /**
+     * Possibility to add {@link String}, representing the <code>System.getProperty(""os.arch"")</code>
+     * to IA64 architecture.
+     *
+     * @param value The {@link String} to add.
+     */
+    public static final void addIA64(String value) {
+        map.put(value, IA64);
+    }
+
+    /**
+     * Checks if the current running JVM is a JVM for IA64 architecture.
+     * It returns <code>true</code>, if the os.arch System Property matches the following {@link String}'s:
+     * <ul>
+     * <li>ia64</li>
+     * <li>ia64w</li>
+     * </ul>
+     * <p>
+     * It is possible to extend the {@link String}'s above using method {@link ArchUtils#addIA64(String)}.
+     * <p>
+     * <p>
+     * Important: The os.arch System Property returns the architecture used by the JVM
+     * not of the operating system.
+     * </p>
+     *
+     * @return <code>True</code> if the current JVM is a IA64 JVM, else <code>false</code>.
+     */
+    public static final boolean isIA64JVM() {
+        return isIA64JVM(SystemUtils.OS_ARCH);
+    }
+
+    /**
+     * Checks if the given {@link String} represents a IA64 JVM. The {@link String} must be
+     * like a value returned by the os.arch System Property.
+     *
+     * @param value The value to check.
+     * @return <code>True</code>, if the {@link String} represents a IA64 value, else <code>false</code>.
+     */
+    public static final boolean isIA64JVM(String value) {
+        return StringUtils.equals(IA64, map.get(value));
+    }
+
+    /**
+     * Possibility to add {@link String}, representing the <code>System.getProperty(""os.arch"")</code>
+     * to PPC architecture.
+     *
+     * @param value The {@link String} to add.
+     */
+    public static final void addPPC(String value) {
+        map.put(value, PPC);
+    }
+
+    /**
+     * Checks if the current running JVM is a JVM for PPC architecture.
+     * It returns <code>true</code>, if the os.arch System Property matches the following {@link String}'s:
+     * <ul>
+     * <li>ppc</li>
+     * <li>powerpc</li>
+     * <li>power_pc</li>
+     * <li>power_rs</li>
+     * </ul>
+     * <p>
+     * It is possible to extend the {@link String}'s above using method {@link ArchUtils#addPPC(String)}.
+     * <p>","[{'comment': '\r\n\r\nMinor bug in Javadoc HTML. Extra opening paragraph. Can be fixed later too.\r\n', 'commenter': 'kinow'}]"
231,src/main/java/org/apache/commons/lang3/ArchUtils.java,"@@ -0,0 +1,446 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.lang3;
+
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+
+/**
+ * An utility class for the os.arch System Property. The class defines methods for
+ * identifying the architecture of the current JVM.
+ * <p>
+ * <p>
+ * Important: The os.arch System Property returns the architecture used by the JVM
+ * not of the operating system.
+ * </p>
+ *
+ * @author Tomschi
+ */
+public class ArchUtils {
+
+    /**
+     * This {@link Map} contains the the possible os.arch property {@link String}'s.
+     */
+    private static final Map<String, String> map;
+
+    /**
+     * The value for x86 architecture.
+     */
+    private static final String X86 = ""x86"";
+
+    /**
+     * The value for x86_64 architecture.
+     */
+    private static final String X86_64 = ""x86_64"";
+
+    /**
+     * The value for ia64_32 architecture.
+     */
+    private static final String IA64_32 = ""ia64_32"";
+
+    /**
+     * The value for ia64 architecture.
+     */
+    private static final String IA64 = ""ia64"";
+
+    /**
+     * The value for ppc architecture.
+     */
+    private static final String PPC = ""ppc"";
+
+    /**
+     * The value for ppc64 architecture.
+     */
+    private static final String PPC64 = ""ppc64"";
+
+    static {
+        map = new ConcurrentHashMap<>();
+
+        // x86 mappings
+        addX86(X86);
+        addX86(""i386"");
+        addX86(""i486"");
+        addX86(""i586"");
+        addX86(""i686"");
+        addX86(""pentium"");
+
+        // x86_64 mappings
+        addX86_64(X86_64);
+        addX86_64(""amd64"");
+        addX86_64(""em64t"");
+        addX86_64(""universal""); // Needed for openjdk7 in Mac
+
+        // Itenium 64-bit mappings
+        addIA64(IA64);
+        addIA64(""ia64w"");
+
+        // Itenium 32-bit mappings, usually an HP-UX construct
+        addIA64_32(IA64_32);
+        addIA64_32(""ia64n"");
+
+        // PowerPC mappings
+        addPPC(PPC);
+        addPPC(""power"");
+        addPPC(""powerpc"");
+        addPPC(""power_pc"");
+        addPPC(""power_rs"");
+
+        // PowerPC 64bit mappings
+        addPPC64(PPC64);
+        addPPC64(""power64"");
+        addPPC64(""powerpc64"");
+        addPPC64(""power_pc64"");
+        addPPC64(""power_rs64"");
+    }
+
+    /**
+     * Possibility to add {@link String}, representing the <code>System.getProperty(""os.arch"")</code>
+     * to x86 architecture.
+     *
+     * @param value The {@link String} to add.
+     */
+    public static final void addX86(String value) {
+        map.put(value, X86);
+    }
+
+    /**
+     * Checks if the current running JVM is a JVM for x86 architecture.
+     * It returns <code>true</code>, if the os.arch System Property matches the following {@link String}'s:
+     * <ul>
+     * <li>x86</li>
+     * <li>i386</li>
+     * <li>i486</li>
+     * <li>i586</li>
+     * <li>i686</li>
+     * <li>pentium</li>
+     * </ul>
+     * <p>
+     * It is possible to extend the {@link String}'s above using method {@link ArchUtils#addX86(String)}.
+     * <p>
+     * <p>
+     * Important: The os.arch System Property returns the architecture used by the JVM
+     * not of the operating system.
+     * </p>
+     *
+     * @return <code>True</code> if the current JVM is a x86 JVM, else <code>false</code>.
+     */
+    public static final boolean isX86JVM() {
+        return isX86JVM(SystemUtils.OS_ARCH);
+    }
+
+    /**
+     * Checks if the given {@link String} represents a x86 JVM. The {@link String} must be
+     * like a value returned by the os.arch System Property.
+     *
+     * @param value The value to check.
+     * @return <code>True</code>, if the {@link String} represents a x86 value, else <code>false</code>.
+     */
+    public static final boolean isX86JVM(String value) {
+        return StringUtils.equals(X86, map.get(value));
+    }
+
+    /**
+     * Possibility to add {@link String}, representing the <code>System.getProperty(""os.arch"")</code>
+     * to x86_64 architecture.
+     *
+     * @param value The {@link String} to add.
+     */
+    public static final void addX86_64(String value) {
+        map.put(value, X86_64);
+    }
+
+    /**
+     * Checks if the current running JVM is a JVM for x86_64 architecture.
+     * It returns <code>true</code>, if the os.arch System Property matches the following {@link String}'s:
+     * <ul>
+     * <li>x86_64</li>
+     * <li>amd64</li>
+     * <li>em64t</li>
+     * <li>universal</li>
+     * </ul>
+     * <p>
+     * It is possible to extend the {@link String}'s above using method {@link ArchUtils#addX86_64(String)}.
+     * <p>
+     * <p>
+     * Important: The os.arch System Property returns the architecture used by the JVM
+     * not of the operating system.
+     * </p>
+     *
+     * @return <code>True</code> if the current JVM is a x86_64 JVM, else <code>false</code>.
+     */
+    public static final boolean isX86_64JVM() {
+        return isX86_64JVM(SystemUtils.OS_ARCH);
+    }
+
+    /**
+     * Checks if the given {@link String} represents a x86_64 JVM. The {@link String} must be
+     * like a value returned by the os.arch System Property.
+     *
+     * @param value The value to check.
+     * @return <code>True</code>, if the {@link String} represents a x86_64 value, else <code>false</code>.
+     */
+    public static final boolean isX86_64JVM(String value) {
+        return StringUtils.equals(X86_64, map.get(value));
+    }
+
+    /**
+     * Possibility to add {@link String}, representing the <code>System.getProperty(""os.arch"")</code>
+     * to IA32_64 architecture.
+     *
+     * @param value The {@link String} to add.
+     */
+    public static final void addIA64_32(String value) {
+        map.put(value, IA64_32);
+    }
+
+    /**
+     * Checks if the current running JVM is a JVM for IA64 32 bit architecture.
+     * It returns <code>true</code>, if the os.arch System Property matches the following {@link String}'s:
+     * <ul>
+     * <li>ia64_32</li>
+     * <li>ia64n</li>
+     * </ul>
+     * <p>
+     * It is possible to extend the {@link String}'s above using method {@link ArchUtils#addIA64_32(String)}.
+     * <p>
+     * <p>
+     * Important: The os.arch System Property returns the architecture used by the JVM
+     * not of the operating system.
+     * </p>
+     *
+     * @return <code>True</code> if the current JVM is a IA64 32 bit JVM, else <code>false</code>.
+     */
+    public static final boolean isIA64_32JVM() {
+        return isIA64_32JVM(SystemUtils.OS_ARCH);
+    }
+
+    /**
+     * Checks if the given {@link String} represents a IA64_32 JVM. The {@link String} must be
+     * like a value returned by the os.arch System Property.
+     *
+     * @param value The value to check.
+     * @return <code>True</code>, if the {@link String} represents a IA64_32 value, else <code>false</code>.
+     */
+    public static final boolean isIA64_32JVM(String value) {
+        return StringUtils.equals(IA64_32, map.get(value));
+    }
+
+    /**
+     * Possibility to add {@link String}, representing the <code>System.getProperty(""os.arch"")</code>
+     * to IA64 architecture.
+     *
+     * @param value The {@link String} to add.
+     */
+    public static final void addIA64(String value) {
+        map.put(value, IA64);
+    }
+
+    /**
+     * Checks if the current running JVM is a JVM for IA64 architecture.
+     * It returns <code>true</code>, if the os.arch System Property matches the following {@link String}'s:
+     * <ul>
+     * <li>ia64</li>
+     * <li>ia64w</li>
+     * </ul>
+     * <p>
+     * It is possible to extend the {@link String}'s above using method {@link ArchUtils#addIA64(String)}.
+     * <p>
+     * <p>
+     * Important: The os.arch System Property returns the architecture used by the JVM
+     * not of the operating system.
+     * </p>
+     *
+     * @return <code>True</code> if the current JVM is a IA64 JVM, else <code>false</code>.
+     */
+    public static final boolean isIA64JVM() {
+        return isIA64JVM(SystemUtils.OS_ARCH);
+    }
+
+    /**
+     * Checks if the given {@link String} represents a IA64 JVM. The {@link String} must be
+     * like a value returned by the os.arch System Property.
+     *
+     * @param value The value to check.
+     * @return <code>True</code>, if the {@link String} represents a IA64 value, else <code>false</code>.
+     */
+    public static final boolean isIA64JVM(String value) {
+        return StringUtils.equals(IA64, map.get(value));
+    }
+
+    /**
+     * Possibility to add {@link String}, representing the <code>System.getProperty(""os.arch"")</code>
+     * to PPC architecture.
+     *
+     * @param value The {@link String} to add.
+     */
+    public static final void addPPC(String value) {
+        map.put(value, PPC);
+    }
+
+    /**
+     * Checks if the current running JVM is a JVM for PPC architecture.
+     * It returns <code>true</code>, if the os.arch System Property matches the following {@link String}'s:
+     * <ul>
+     * <li>ppc</li>
+     * <li>powerpc</li>
+     * <li>power_pc</li>
+     * <li>power_rs</li>
+     * </ul>
+     * <p>
+     * It is possible to extend the {@link String}'s above using method {@link ArchUtils#addPPC(String)}.
+     * <p>
+     * <p>
+     * Important: The os.arch System Property returns the architecture used by the JVM
+     * not of the operating system.
+     * </p>
+     *
+     * @return <code>True</code> if the current JVM is a PPC JVM, else <code>false</code>.
+     */
+    public static final boolean isPPCJVM() {
+        return isPPCJVM(SystemUtils.OS_ARCH);
+    }
+
+    /**
+     * Checks if the given {@link String} represents a PPC JVM. The {@link String} must be
+     * like a value returned by the os.arch System Property.
+     *
+     * @param value The value to check.
+     * @return <code>True</code>, if the {@link String} represents a PPC value, else <code>false</code>.
+     */
+    public static final boolean isPPCJVM(String value) {
+        return StringUtils.equals(PPC, map.get(value));
+    }
+
+    /**
+     * Possibility to add {@link String}, representing the <code>System.getProperty(""os.arch"")</code>
+     * to PPC_64 architecture.
+     *
+     * @param value The {@link String} to add.
+     */
+    public static final void addPPC64(String value) {
+        map.put(value, PPC64);
+    }
+
+    /**
+     * Checks if the current running JVM is a JVM for PPC 64 bit architecture.
+     * It returns <code>true</code>, if the os.arch System Property matches the following {@link String}'s:
+     * <ul>
+     * <li>ppc64</li>
+     * <li>powerpc64</li>
+     * <li>power_pc64</li>
+     * <li>power_rs64</li>
+     * </ul>
+     * <p>
+     * It is possible to extend the {@link String}'s above using method {@link ArchUtils#addPPC64(String)}.
+     * <p>","[{'comment': '\r\n\r\nMinor bug in Javadoc HTML. Extra opening paragraph. Can be fixed later too.\r\n', 'commenter': 'kinow'}]"
231,src/main/java/org/apache/commons/lang3/ArchUtils.java,"@@ -0,0 +1,446 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.lang3;
+
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+
+/**
+ * An utility class for the os.arch System Property. The class defines methods for
+ * identifying the architecture of the current JVM.
+ * <p>
+ * <p>
+ * Important: The os.arch System Property returns the architecture used by the JVM
+ * not of the operating system.
+ * </p>
+ *
+ * @author Tomschi
+ */
+public class ArchUtils {
+
+    /**
+     * This {@link Map} contains the the possible os.arch property {@link String}'s.
+     */
+    private static final Map<String, String> map;
+
+    /**
+     * The value for x86 architecture.
+     */
+    private static final String X86 = ""x86"";
+
+    /**
+     * The value for x86_64 architecture.
+     */
+    private static final String X86_64 = ""x86_64"";
+
+    /**
+     * The value for ia64_32 architecture.
+     */
+    private static final String IA64_32 = ""ia64_32"";
+
+    /**
+     * The value for ia64 architecture.
+     */
+    private static final String IA64 = ""ia64"";
+
+    /**
+     * The value for ppc architecture.
+     */
+    private static final String PPC = ""ppc"";
+
+    /**
+     * The value for ppc64 architecture.
+     */
+    private static final String PPC64 = ""ppc64"";
+
+    static {
+        map = new ConcurrentHashMap<>();
+
+        // x86 mappings
+        addX86(X86);
+        addX86(""i386"");
+        addX86(""i486"");
+        addX86(""i586"");
+        addX86(""i686"");
+        addX86(""pentium"");
+
+        // x86_64 mappings
+        addX86_64(X86_64);
+        addX86_64(""amd64"");
+        addX86_64(""em64t"");
+        addX86_64(""universal""); // Needed for openjdk7 in Mac
+
+        // Itenium 64-bit mappings
+        addIA64(IA64);
+        addIA64(""ia64w"");
+
+        // Itenium 32-bit mappings, usually an HP-UX construct
+        addIA64_32(IA64_32);
+        addIA64_32(""ia64n"");
+
+        // PowerPC mappings
+        addPPC(PPC);
+        addPPC(""power"");
+        addPPC(""powerpc"");
+        addPPC(""power_pc"");
+        addPPC(""power_rs"");
+
+        // PowerPC 64bit mappings
+        addPPC64(PPC64);
+        addPPC64(""power64"");
+        addPPC64(""powerpc64"");
+        addPPC64(""power_pc64"");
+        addPPC64(""power_rs64"");
+    }
+
+    /**
+     * Possibility to add {@link String}, representing the <code>System.getProperty(""os.arch"")</code>
+     * to x86 architecture.
+     *
+     * @param value The {@link String} to add.
+     */
+    public static final void addX86(String value) {
+        map.put(value, X86);
+    }
+
+    /**
+     * Checks if the current running JVM is a JVM for x86 architecture.
+     * It returns <code>true</code>, if the os.arch System Property matches the following {@link String}'s:
+     * <ul>
+     * <li>x86</li>
+     * <li>i386</li>
+     * <li>i486</li>
+     * <li>i586</li>
+     * <li>i686</li>
+     * <li>pentium</li>
+     * </ul>
+     * <p>
+     * It is possible to extend the {@link String}'s above using method {@link ArchUtils#addX86(String)}.
+     * <p>
+     * <p>
+     * Important: The os.arch System Property returns the architecture used by the JVM
+     * not of the operating system.
+     * </p>
+     *
+     * @return <code>True</code> if the current JVM is a x86 JVM, else <code>false</code>.
+     */
+    public static final boolean isX86JVM() {
+        return isX86JVM(SystemUtils.OS_ARCH);
+    }
+
+    /**
+     * Checks if the given {@link String} represents a x86 JVM. The {@link String} must be
+     * like a value returned by the os.arch System Property.
+     *
+     * @param value The value to check.
+     * @return <code>True</code>, if the {@link String} represents a x86 value, else <code>false</code>.
+     */
+    public static final boolean isX86JVM(String value) {
+        return StringUtils.equals(X86, map.get(value));
+    }
+
+    /**
+     * Possibility to add {@link String}, representing the <code>System.getProperty(""os.arch"")</code>
+     * to x86_64 architecture.
+     *
+     * @param value The {@link String} to add.
+     */
+    public static final void addX86_64(String value) {
+        map.put(value, X86_64);
+    }
+
+    /**
+     * Checks if the current running JVM is a JVM for x86_64 architecture.
+     * It returns <code>true</code>, if the os.arch System Property matches the following {@link String}'s:
+     * <ul>
+     * <li>x86_64</li>
+     * <li>amd64</li>
+     * <li>em64t</li>
+     * <li>universal</li>
+     * </ul>
+     * <p>
+     * It is possible to extend the {@link String}'s above using method {@link ArchUtils#addX86_64(String)}.
+     * <p>
+     * <p>
+     * Important: The os.arch System Property returns the architecture used by the JVM
+     * not of the operating system.
+     * </p>
+     *
+     * @return <code>True</code> if the current JVM is a x86_64 JVM, else <code>false</code>.
+     */
+    public static final boolean isX86_64JVM() {
+        return isX86_64JVM(SystemUtils.OS_ARCH);
+    }
+
+    /**
+     * Checks if the given {@link String} represents a x86_64 JVM. The {@link String} must be
+     * like a value returned by the os.arch System Property.
+     *
+     * @param value The value to check.
+     * @return <code>True</code>, if the {@link String} represents a x86_64 value, else <code>false</code>.
+     */
+    public static final boolean isX86_64JVM(String value) {
+        return StringUtils.equals(X86_64, map.get(value));
+    }
+
+    /**
+     * Possibility to add {@link String}, representing the <code>System.getProperty(""os.arch"")</code>
+     * to IA32_64 architecture.
+     *
+     * @param value The {@link String} to add.
+     */
+    public static final void addIA64_32(String value) {
+        map.put(value, IA64_32);
+    }
+
+    /**
+     * Checks if the current running JVM is a JVM for IA64 32 bit architecture.
+     * It returns <code>true</code>, if the os.arch System Property matches the following {@link String}'s:
+     * <ul>
+     * <li>ia64_32</li>
+     * <li>ia64n</li>
+     * </ul>
+     * <p>
+     * It is possible to extend the {@link String}'s above using method {@link ArchUtils#addIA64_32(String)}.
+     * <p>
+     * <p>
+     * Important: The os.arch System Property returns the architecture used by the JVM
+     * not of the operating system.
+     * </p>
+     *
+     * @return <code>True</code> if the current JVM is a IA64 32 bit JVM, else <code>false</code>.
+     */
+    public static final boolean isIA64_32JVM() {
+        return isIA64_32JVM(SystemUtils.OS_ARCH);
+    }
+
+    /**
+     * Checks if the given {@link String} represents a IA64_32 JVM. The {@link String} must be
+     * like a value returned by the os.arch System Property.
+     *
+     * @param value The value to check.
+     * @return <code>True</code>, if the {@link String} represents a IA64_32 value, else <code>false</code>.
+     */
+    public static final boolean isIA64_32JVM(String value) {
+        return StringUtils.equals(IA64_32, map.get(value));
+    }
+
+    /**
+     * Possibility to add {@link String}, representing the <code>System.getProperty(""os.arch"")</code>
+     * to IA64 architecture.
+     *
+     * @param value The {@link String} to add.
+     */
+    public static final void addIA64(String value) {
+        map.put(value, IA64);
+    }
+
+    /**
+     * Checks if the current running JVM is a JVM for IA64 architecture.
+     * It returns <code>true</code>, if the os.arch System Property matches the following {@link String}'s:
+     * <ul>
+     * <li>ia64</li>
+     * <li>ia64w</li>
+     * </ul>
+     * <p>
+     * It is possible to extend the {@link String}'s above using method {@link ArchUtils#addIA64(String)}.
+     * <p>
+     * <p>
+     * Important: The os.arch System Property returns the architecture used by the JVM
+     * not of the operating system.
+     * </p>
+     *
+     * @return <code>True</code> if the current JVM is a IA64 JVM, else <code>false</code>.
+     */
+    public static final boolean isIA64JVM() {
+        return isIA64JVM(SystemUtils.OS_ARCH);
+    }
+
+    /**
+     * Checks if the given {@link String} represents a IA64 JVM. The {@link String} must be
+     * like a value returned by the os.arch System Property.
+     *
+     * @param value The value to check.
+     * @return <code>True</code>, if the {@link String} represents a IA64 value, else <code>false</code>.
+     */
+    public static final boolean isIA64JVM(String value) {
+        return StringUtils.equals(IA64, map.get(value));
+    }
+
+    /**
+     * Possibility to add {@link String}, representing the <code>System.getProperty(""os.arch"")</code>
+     * to PPC architecture.
+     *
+     * @param value The {@link String} to add.
+     */
+    public static final void addPPC(String value) {
+        map.put(value, PPC);
+    }
+
+    /**
+     * Checks if the current running JVM is a JVM for PPC architecture.
+     * It returns <code>true</code>, if the os.arch System Property matches the following {@link String}'s:
+     * <ul>
+     * <li>ppc</li>
+     * <li>powerpc</li>
+     * <li>power_pc</li>
+     * <li>power_rs</li>
+     * </ul>
+     * <p>
+     * It is possible to extend the {@link String}'s above using method {@link ArchUtils#addPPC(String)}.
+     * <p>
+     * <p>
+     * Important: The os.arch System Property returns the architecture used by the JVM
+     * not of the operating system.
+     * </p>
+     *
+     * @return <code>True</code> if the current JVM is a PPC JVM, else <code>false</code>.
+     */
+    public static final boolean isPPCJVM() {
+        return isPPCJVM(SystemUtils.OS_ARCH);
+    }
+
+    /**
+     * Checks if the given {@link String} represents a PPC JVM. The {@link String} must be
+     * like a value returned by the os.arch System Property.
+     *
+     * @param value The value to check.
+     * @return <code>True</code>, if the {@link String} represents a PPC value, else <code>false</code>.
+     */
+    public static final boolean isPPCJVM(String value) {
+        return StringUtils.equals(PPC, map.get(value));
+    }
+
+    /**
+     * Possibility to add {@link String}, representing the <code>System.getProperty(""os.arch"")</code>
+     * to PPC_64 architecture.
+     *
+     * @param value The {@link String} to add.
+     */
+    public static final void addPPC64(String value) {
+        map.put(value, PPC64);
+    }
+
+    /**
+     * Checks if the current running JVM is a JVM for PPC 64 bit architecture.
+     * It returns <code>true</code>, if the os.arch System Property matches the following {@link String}'s:
+     * <ul>
+     * <li>ppc64</li>
+     * <li>powerpc64</li>
+     * <li>power_pc64</li>
+     * <li>power_rs64</li>
+     * </ul>
+     * <p>
+     * It is possible to extend the {@link String}'s above using method {@link ArchUtils#addPPC64(String)}.
+     * <p>
+     * <p>
+     * Important: The os.arch System Property returns the architecture used by the JVM
+     * not of the operating system.
+     * </p>
+     *
+     * @return <code>True</code> if the current JVM is a PPC 64 bit JVM, else <code>false</code>.
+     */
+    public static final boolean isPPC64JVM() {
+        return isPPC64JVM(SystemUtils.OS_ARCH);
+    }
+
+    /**
+     * Checks if the given {@link String} represents a PPC 64 JVM. The {@link String} must be
+     * like a value returned by the os.arch System Property.
+     *
+     * @param value The value to check.
+     * @return <code>True</code>, if the {@link String} represents a PPC 64 value, else <code>false</code>.
+     */
+    public static final boolean isPPC64JVM(String value) {
+        return StringUtils.equals(PPC64, map.get(value));
+    }
+
+    /**
+     * Checks if the current running JVM is a 32 bit JVM using the os.arch System Property.
+     * <p>","[{'comment': '\r\n\r\nMinor bug in Javadoc HTML. Extra opening paragraph. Can be fixed later too.\r\n', 'commenter': 'kinow'}]"
231,src/main/java/org/apache/commons/lang3/ArchUtils.java,"@@ -0,0 +1,446 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.lang3;
+
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+
+/**
+ * An utility class for the os.arch System Property. The class defines methods for
+ * identifying the architecture of the current JVM.
+ * <p>
+ * <p>
+ * Important: The os.arch System Property returns the architecture used by the JVM
+ * not of the operating system.
+ * </p>
+ *
+ * @author Tomschi
+ */
+public class ArchUtils {
+
+    /**
+     * This {@link Map} contains the the possible os.arch property {@link String}'s.
+     */
+    private static final Map<String, String> map;
+
+    /**
+     * The value for x86 architecture.
+     */
+    private static final String X86 = ""x86"";
+
+    /**
+     * The value for x86_64 architecture.
+     */
+    private static final String X86_64 = ""x86_64"";
+
+    /**
+     * The value for ia64_32 architecture.
+     */
+    private static final String IA64_32 = ""ia64_32"";
+
+    /**
+     * The value for ia64 architecture.
+     */
+    private static final String IA64 = ""ia64"";
+
+    /**
+     * The value for ppc architecture.
+     */
+    private static final String PPC = ""ppc"";
+
+    /**
+     * The value for ppc64 architecture.
+     */
+    private static final String PPC64 = ""ppc64"";
+
+    static {
+        map = new ConcurrentHashMap<>();
+
+        // x86 mappings
+        addX86(X86);
+        addX86(""i386"");
+        addX86(""i486"");
+        addX86(""i586"");
+        addX86(""i686"");
+        addX86(""pentium"");
+
+        // x86_64 mappings
+        addX86_64(X86_64);
+        addX86_64(""amd64"");
+        addX86_64(""em64t"");
+        addX86_64(""universal""); // Needed for openjdk7 in Mac
+
+        // Itenium 64-bit mappings
+        addIA64(IA64);
+        addIA64(""ia64w"");
+
+        // Itenium 32-bit mappings, usually an HP-UX construct
+        addIA64_32(IA64_32);
+        addIA64_32(""ia64n"");
+
+        // PowerPC mappings
+        addPPC(PPC);
+        addPPC(""power"");
+        addPPC(""powerpc"");
+        addPPC(""power_pc"");
+        addPPC(""power_rs"");
+
+        // PowerPC 64bit mappings
+        addPPC64(PPC64);
+        addPPC64(""power64"");
+        addPPC64(""powerpc64"");
+        addPPC64(""power_pc64"");
+        addPPC64(""power_rs64"");
+    }
+
+    /**
+     * Possibility to add {@link String}, representing the <code>System.getProperty(""os.arch"")</code>
+     * to x86 architecture.
+     *
+     * @param value The {@link String} to add.
+     */
+    public static final void addX86(String value) {
+        map.put(value, X86);
+    }
+
+    /**
+     * Checks if the current running JVM is a JVM for x86 architecture.
+     * It returns <code>true</code>, if the os.arch System Property matches the following {@link String}'s:
+     * <ul>
+     * <li>x86</li>
+     * <li>i386</li>
+     * <li>i486</li>
+     * <li>i586</li>
+     * <li>i686</li>
+     * <li>pentium</li>
+     * </ul>
+     * <p>
+     * It is possible to extend the {@link String}'s above using method {@link ArchUtils#addX86(String)}.
+     * <p>
+     * <p>
+     * Important: The os.arch System Property returns the architecture used by the JVM
+     * not of the operating system.
+     * </p>
+     *
+     * @return <code>True</code> if the current JVM is a x86 JVM, else <code>false</code>.
+     */
+    public static final boolean isX86JVM() {
+        return isX86JVM(SystemUtils.OS_ARCH);
+    }
+
+    /**
+     * Checks if the given {@link String} represents a x86 JVM. The {@link String} must be
+     * like a value returned by the os.arch System Property.
+     *
+     * @param value The value to check.
+     * @return <code>True</code>, if the {@link String} represents a x86 value, else <code>false</code>.
+     */
+    public static final boolean isX86JVM(String value) {
+        return StringUtils.equals(X86, map.get(value));
+    }
+
+    /**
+     * Possibility to add {@link String}, representing the <code>System.getProperty(""os.arch"")</code>
+     * to x86_64 architecture.
+     *
+     * @param value The {@link String} to add.
+     */
+    public static final void addX86_64(String value) {
+        map.put(value, X86_64);
+    }
+
+    /**
+     * Checks if the current running JVM is a JVM for x86_64 architecture.
+     * It returns <code>true</code>, if the os.arch System Property matches the following {@link String}'s:
+     * <ul>
+     * <li>x86_64</li>
+     * <li>amd64</li>
+     * <li>em64t</li>
+     * <li>universal</li>
+     * </ul>
+     * <p>
+     * It is possible to extend the {@link String}'s above using method {@link ArchUtils#addX86_64(String)}.
+     * <p>
+     * <p>
+     * Important: The os.arch System Property returns the architecture used by the JVM
+     * not of the operating system.
+     * </p>
+     *
+     * @return <code>True</code> if the current JVM is a x86_64 JVM, else <code>false</code>.
+     */
+    public static final boolean isX86_64JVM() {
+        return isX86_64JVM(SystemUtils.OS_ARCH);
+    }
+
+    /**
+     * Checks if the given {@link String} represents a x86_64 JVM. The {@link String} must be
+     * like a value returned by the os.arch System Property.
+     *
+     * @param value The value to check.
+     * @return <code>True</code>, if the {@link String} represents a x86_64 value, else <code>false</code>.
+     */
+    public static final boolean isX86_64JVM(String value) {
+        return StringUtils.equals(X86_64, map.get(value));
+    }
+
+    /**
+     * Possibility to add {@link String}, representing the <code>System.getProperty(""os.arch"")</code>
+     * to IA32_64 architecture.
+     *
+     * @param value The {@link String} to add.
+     */
+    public static final void addIA64_32(String value) {
+        map.put(value, IA64_32);
+    }
+
+    /**
+     * Checks if the current running JVM is a JVM for IA64 32 bit architecture.
+     * It returns <code>true</code>, if the os.arch System Property matches the following {@link String}'s:
+     * <ul>
+     * <li>ia64_32</li>
+     * <li>ia64n</li>
+     * </ul>
+     * <p>
+     * It is possible to extend the {@link String}'s above using method {@link ArchUtils#addIA64_32(String)}.
+     * <p>
+     * <p>
+     * Important: The os.arch System Property returns the architecture used by the JVM
+     * not of the operating system.
+     * </p>
+     *
+     * @return <code>True</code> if the current JVM is a IA64 32 bit JVM, else <code>false</code>.
+     */
+    public static final boolean isIA64_32JVM() {
+        return isIA64_32JVM(SystemUtils.OS_ARCH);
+    }
+
+    /**
+     * Checks if the given {@link String} represents a IA64_32 JVM. The {@link String} must be
+     * like a value returned by the os.arch System Property.
+     *
+     * @param value The value to check.
+     * @return <code>True</code>, if the {@link String} represents a IA64_32 value, else <code>false</code>.
+     */
+    public static final boolean isIA64_32JVM(String value) {
+        return StringUtils.equals(IA64_32, map.get(value));
+    }
+
+    /**
+     * Possibility to add {@link String}, representing the <code>System.getProperty(""os.arch"")</code>
+     * to IA64 architecture.
+     *
+     * @param value The {@link String} to add.
+     */
+    public static final void addIA64(String value) {
+        map.put(value, IA64);
+    }
+
+    /**
+     * Checks if the current running JVM is a JVM for IA64 architecture.
+     * It returns <code>true</code>, if the os.arch System Property matches the following {@link String}'s:
+     * <ul>
+     * <li>ia64</li>
+     * <li>ia64w</li>
+     * </ul>
+     * <p>
+     * It is possible to extend the {@link String}'s above using method {@link ArchUtils#addIA64(String)}.
+     * <p>
+     * <p>
+     * Important: The os.arch System Property returns the architecture used by the JVM
+     * not of the operating system.
+     * </p>
+     *
+     * @return <code>True</code> if the current JVM is a IA64 JVM, else <code>false</code>.
+     */
+    public static final boolean isIA64JVM() {
+        return isIA64JVM(SystemUtils.OS_ARCH);
+    }
+
+    /**
+     * Checks if the given {@link String} represents a IA64 JVM. The {@link String} must be
+     * like a value returned by the os.arch System Property.
+     *
+     * @param value The value to check.
+     * @return <code>True</code>, if the {@link String} represents a IA64 value, else <code>false</code>.
+     */
+    public static final boolean isIA64JVM(String value) {
+        return StringUtils.equals(IA64, map.get(value));
+    }
+
+    /**
+     * Possibility to add {@link String}, representing the <code>System.getProperty(""os.arch"")</code>
+     * to PPC architecture.
+     *
+     * @param value The {@link String} to add.
+     */
+    public static final void addPPC(String value) {
+        map.put(value, PPC);
+    }
+
+    /**
+     * Checks if the current running JVM is a JVM for PPC architecture.
+     * It returns <code>true</code>, if the os.arch System Property matches the following {@link String}'s:
+     * <ul>
+     * <li>ppc</li>
+     * <li>powerpc</li>
+     * <li>power_pc</li>
+     * <li>power_rs</li>
+     * </ul>
+     * <p>
+     * It is possible to extend the {@link String}'s above using method {@link ArchUtils#addPPC(String)}.
+     * <p>
+     * <p>
+     * Important: The os.arch System Property returns the architecture used by the JVM
+     * not of the operating system.
+     * </p>
+     *
+     * @return <code>True</code> if the current JVM is a PPC JVM, else <code>false</code>.
+     */
+    public static final boolean isPPCJVM() {
+        return isPPCJVM(SystemUtils.OS_ARCH);
+    }
+
+    /**
+     * Checks if the given {@link String} represents a PPC JVM. The {@link String} must be
+     * like a value returned by the os.arch System Property.
+     *
+     * @param value The value to check.
+     * @return <code>True</code>, if the {@link String} represents a PPC value, else <code>false</code>.
+     */
+    public static final boolean isPPCJVM(String value) {
+        return StringUtils.equals(PPC, map.get(value));
+    }
+
+    /**
+     * Possibility to add {@link String}, representing the <code>System.getProperty(""os.arch"")</code>
+     * to PPC_64 architecture.
+     *
+     * @param value The {@link String} to add.
+     */
+    public static final void addPPC64(String value) {
+        map.put(value, PPC64);
+    }
+
+    /**
+     * Checks if the current running JVM is a JVM for PPC 64 bit architecture.
+     * It returns <code>true</code>, if the os.arch System Property matches the following {@link String}'s:
+     * <ul>
+     * <li>ppc64</li>
+     * <li>powerpc64</li>
+     * <li>power_pc64</li>
+     * <li>power_rs64</li>
+     * </ul>
+     * <p>
+     * It is possible to extend the {@link String}'s above using method {@link ArchUtils#addPPC64(String)}.
+     * <p>
+     * <p>
+     * Important: The os.arch System Property returns the architecture used by the JVM
+     * not of the operating system.
+     * </p>
+     *
+     * @return <code>True</code> if the current JVM is a PPC 64 bit JVM, else <code>false</code>.
+     */
+    public static final boolean isPPC64JVM() {
+        return isPPC64JVM(SystemUtils.OS_ARCH);
+    }
+
+    /**
+     * Checks if the given {@link String} represents a PPC 64 JVM. The {@link String} must be
+     * like a value returned by the os.arch System Property.
+     *
+     * @param value The value to check.
+     * @return <code>True</code>, if the {@link String} represents a PPC 64 value, else <code>false</code>.
+     */
+    public static final boolean isPPC64JVM(String value) {
+        return StringUtils.equals(PPC64, map.get(value));
+    }
+
+    /**
+     * Checks if the current running JVM is a 32 bit JVM using the os.arch System Property.
+     * <p>
+     * <p>
+     * Important: The os.arch System Property returns the architecture used by the JVM
+     * not of the operating system.
+     * </p>
+     *
+     * @return <code>True</code>, if the current JVM is 32 bit, else <code>false</code>.
+     */
+    public static final boolean is32BitJVM() {
+        return isX86JVM() || isIA64_32JVM() || isPPCJVM();
+    }
+
+    /**
+     * Checks if the given {@link String} represents a 32 bit JVM. The {@link String} must be
+     * like a value returned by the os.arch System Property.
+     *
+     * @param value The value to check.
+     * @return <code>True</code>, if the {@link String} represents a 32 bit value, else <code>false</code>.
+     */
+    public static final boolean is32BitJVM(String value) {
+        return isX86JVM(value) || isIA64_32JVM(value) || isPPCJVM(value);
+    }
+
+    /**
+     * Checks if the current running JVM is a 64 bit JVM using the os.arch System Property.
+     * <p>","[{'comment': '\r\n\r\nMinor bug in Javadoc HTML. Extra opening paragraph. Can be fixed later too.\r\n', 'commenter': 'kinow'}]"
231,src/main/java/org/apache/commons/lang3/ArchUtils.java,"@@ -0,0 +1,446 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.lang3;
+
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+
+/**
+ * An utility class for the os.arch System Property. The class defines methods for
+ * identifying the architecture of the current JVM.
+ * <p>
+ * <p>
+ * Important: The os.arch System Property returns the architecture used by the JVM
+ * not of the operating system.
+ * </p>
+ *
+ * @author Tomschi
+ */
+public class ArchUtils {
+
+    /**
+     * This {@link Map} contains the the possible os.arch property {@link String}'s.
+     */
+    private static final Map<String, String> map;
+
+    /**
+     * The value for x86 architecture.
+     */
+    private static final String X86 = ""x86"";
+
+    /**
+     * The value for x86_64 architecture.
+     */
+    private static final String X86_64 = ""x86_64"";
+
+    /**
+     * The value for ia64_32 architecture.
+     */
+    private static final String IA64_32 = ""ia64_32"";
+
+    /**
+     * The value for ia64 architecture.
+     */
+    private static final String IA64 = ""ia64"";
+
+    /**
+     * The value for ppc architecture.
+     */
+    private static final String PPC = ""ppc"";
+
+    /**
+     * The value for ppc64 architecture.
+     */
+    private static final String PPC64 = ""ppc64"";
+
+    static {
+        map = new ConcurrentHashMap<>();
+
+        // x86 mappings
+        addX86(X86);
+        addX86(""i386"");
+        addX86(""i486"");
+        addX86(""i586"");
+        addX86(""i686"");
+        addX86(""pentium"");
+
+        // x86_64 mappings
+        addX86_64(X86_64);
+        addX86_64(""amd64"");
+        addX86_64(""em64t"");
+        addX86_64(""universal""); // Needed for openjdk7 in Mac
+
+        // Itenium 64-bit mappings
+        addIA64(IA64);
+        addIA64(""ia64w"");
+
+        // Itenium 32-bit mappings, usually an HP-UX construct
+        addIA64_32(IA64_32);
+        addIA64_32(""ia64n"");
+
+        // PowerPC mappings
+        addPPC(PPC);
+        addPPC(""power"");
+        addPPC(""powerpc"");
+        addPPC(""power_pc"");
+        addPPC(""power_rs"");
+
+        // PowerPC 64bit mappings
+        addPPC64(PPC64);
+        addPPC64(""power64"");
+        addPPC64(""powerpc64"");
+        addPPC64(""power_pc64"");
+        addPPC64(""power_rs64"");
+    }
+
+    /**
+     * Possibility to add {@link String}, representing the <code>System.getProperty(""os.arch"")</code>
+     * to x86 architecture.
+     *
+     * @param value The {@link String} to add.
+     */
+    public static final void addX86(String value) {
+        map.put(value, X86);
+    }
+
+    /**
+     * Checks if the current running JVM is a JVM for x86 architecture.
+     * It returns <code>true</code>, if the os.arch System Property matches the following {@link String}'s:
+     * <ul>
+     * <li>x86</li>
+     * <li>i386</li>
+     * <li>i486</li>
+     * <li>i586</li>
+     * <li>i686</li>
+     * <li>pentium</li>
+     * </ul>
+     * <p>
+     * It is possible to extend the {@link String}'s above using method {@link ArchUtils#addX86(String)}.
+     * <p>
+     * <p>
+     * Important: The os.arch System Property returns the architecture used by the JVM
+     * not of the operating system.
+     * </p>
+     *
+     * @return <code>True</code> if the current JVM is a x86 JVM, else <code>false</code>.
+     */
+    public static final boolean isX86JVM() {
+        return isX86JVM(SystemUtils.OS_ARCH);
+    }
+
+    /**
+     * Checks if the given {@link String} represents a x86 JVM. The {@link String} must be
+     * like a value returned by the os.arch System Property.
+     *
+     * @param value The value to check.
+     * @return <code>True</code>, if the {@link String} represents a x86 value, else <code>false</code>.
+     */
+    public static final boolean isX86JVM(String value) {
+        return StringUtils.equals(X86, map.get(value));
+    }
+
+    /**
+     * Possibility to add {@link String}, representing the <code>System.getProperty(""os.arch"")</code>
+     * to x86_64 architecture.
+     *
+     * @param value The {@link String} to add.
+     */
+    public static final void addX86_64(String value) {
+        map.put(value, X86_64);
+    }
+
+    /**
+     * Checks if the current running JVM is a JVM for x86_64 architecture.
+     * It returns <code>true</code>, if the os.arch System Property matches the following {@link String}'s:
+     * <ul>
+     * <li>x86_64</li>
+     * <li>amd64</li>
+     * <li>em64t</li>
+     * <li>universal</li>
+     * </ul>
+     * <p>
+     * It is possible to extend the {@link String}'s above using method {@link ArchUtils#addX86_64(String)}.
+     * <p>
+     * <p>
+     * Important: The os.arch System Property returns the architecture used by the JVM
+     * not of the operating system.
+     * </p>
+     *
+     * @return <code>True</code> if the current JVM is a x86_64 JVM, else <code>false</code>.
+     */
+    public static final boolean isX86_64JVM() {
+        return isX86_64JVM(SystemUtils.OS_ARCH);
+    }
+
+    /**
+     * Checks if the given {@link String} represents a x86_64 JVM. The {@link String} must be
+     * like a value returned by the os.arch System Property.
+     *
+     * @param value The value to check.
+     * @return <code>True</code>, if the {@link String} represents a x86_64 value, else <code>false</code>.
+     */
+    public static final boolean isX86_64JVM(String value) {
+        return StringUtils.equals(X86_64, map.get(value));
+    }
+
+    /**
+     * Possibility to add {@link String}, representing the <code>System.getProperty(""os.arch"")</code>
+     * to IA32_64 architecture.
+     *
+     * @param value The {@link String} to add.
+     */
+    public static final void addIA64_32(String value) {
+        map.put(value, IA64_32);
+    }
+
+    /**
+     * Checks if the current running JVM is a JVM for IA64 32 bit architecture.
+     * It returns <code>true</code>, if the os.arch System Property matches the following {@link String}'s:
+     * <ul>
+     * <li>ia64_32</li>
+     * <li>ia64n</li>
+     * </ul>
+     * <p>
+     * It is possible to extend the {@link String}'s above using method {@link ArchUtils#addIA64_32(String)}.
+     * <p>
+     * <p>
+     * Important: The os.arch System Property returns the architecture used by the JVM
+     * not of the operating system.
+     * </p>
+     *
+     * @return <code>True</code> if the current JVM is a IA64 32 bit JVM, else <code>false</code>.
+     */
+    public static final boolean isIA64_32JVM() {
+        return isIA64_32JVM(SystemUtils.OS_ARCH);
+    }
+
+    /**
+     * Checks if the given {@link String} represents a IA64_32 JVM. The {@link String} must be
+     * like a value returned by the os.arch System Property.
+     *
+     * @param value The value to check.
+     * @return <code>True</code>, if the {@link String} represents a IA64_32 value, else <code>false</code>.
+     */
+    public static final boolean isIA64_32JVM(String value) {
+        return StringUtils.equals(IA64_32, map.get(value));
+    }
+
+    /**
+     * Possibility to add {@link String}, representing the <code>System.getProperty(""os.arch"")</code>
+     * to IA64 architecture.
+     *
+     * @param value The {@link String} to add.
+     */
+    public static final void addIA64(String value) {
+        map.put(value, IA64);
+    }
+
+    /**
+     * Checks if the current running JVM is a JVM for IA64 architecture.
+     * It returns <code>true</code>, if the os.arch System Property matches the following {@link String}'s:
+     * <ul>
+     * <li>ia64</li>
+     * <li>ia64w</li>
+     * </ul>
+     * <p>
+     * It is possible to extend the {@link String}'s above using method {@link ArchUtils#addIA64(String)}.
+     * <p>
+     * <p>
+     * Important: The os.arch System Property returns the architecture used by the JVM
+     * not of the operating system.
+     * </p>
+     *
+     * @return <code>True</code> if the current JVM is a IA64 JVM, else <code>false</code>.
+     */
+    public static final boolean isIA64JVM() {
+        return isIA64JVM(SystemUtils.OS_ARCH);
+    }
+
+    /**
+     * Checks if the given {@link String} represents a IA64 JVM. The {@link String} must be
+     * like a value returned by the os.arch System Property.
+     *
+     * @param value The value to check.
+     * @return <code>True</code>, if the {@link String} represents a IA64 value, else <code>false</code>.
+     */
+    public static final boolean isIA64JVM(String value) {
+        return StringUtils.equals(IA64, map.get(value));
+    }
+
+    /**
+     * Possibility to add {@link String}, representing the <code>System.getProperty(""os.arch"")</code>
+     * to PPC architecture.
+     *
+     * @param value The {@link String} to add.
+     */
+    public static final void addPPC(String value) {
+        map.put(value, PPC);
+    }
+
+    /**
+     * Checks if the current running JVM is a JVM for PPC architecture.
+     * It returns <code>true</code>, if the os.arch System Property matches the following {@link String}'s:
+     * <ul>
+     * <li>ppc</li>
+     * <li>powerpc</li>
+     * <li>power_pc</li>
+     * <li>power_rs</li>
+     * </ul>
+     * <p>
+     * It is possible to extend the {@link String}'s above using method {@link ArchUtils#addPPC(String)}.
+     * <p>
+     * <p>
+     * Important: The os.arch System Property returns the architecture used by the JVM
+     * not of the operating system.
+     * </p>
+     *
+     * @return <code>True</code> if the current JVM is a PPC JVM, else <code>false</code>.
+     */
+    public static final boolean isPPCJVM() {
+        return isPPCJVM(SystemUtils.OS_ARCH);
+    }
+
+    /**
+     * Checks if the given {@link String} represents a PPC JVM. The {@link String} must be
+     * like a value returned by the os.arch System Property.
+     *
+     * @param value The value to check.
+     * @return <code>True</code>, if the {@link String} represents a PPC value, else <code>false</code>.
+     */
+    public static final boolean isPPCJVM(String value) {
+        return StringUtils.equals(PPC, map.get(value));
+    }
+
+    /**
+     * Possibility to add {@link String}, representing the <code>System.getProperty(""os.arch"")</code>
+     * to PPC_64 architecture.
+     *
+     * @param value The {@link String} to add.
+     */
+    public static final void addPPC64(String value) {
+        map.put(value, PPC64);
+    }
+
+    /**
+     * Checks if the current running JVM is a JVM for PPC 64 bit architecture.
+     * It returns <code>true</code>, if the os.arch System Property matches the following {@link String}'s:
+     * <ul>
+     * <li>ppc64</li>
+     * <li>powerpc64</li>
+     * <li>power_pc64</li>
+     * <li>power_rs64</li>
+     * </ul>
+     * <p>
+     * It is possible to extend the {@link String}'s above using method {@link ArchUtils#addPPC64(String)}.
+     * <p>
+     * <p>
+     * Important: The os.arch System Property returns the architecture used by the JVM
+     * not of the operating system.
+     * </p>
+     *
+     * @return <code>True</code> if the current JVM is a PPC 64 bit JVM, else <code>false</code>.
+     */
+    public static final boolean isPPC64JVM() {
+        return isPPC64JVM(SystemUtils.OS_ARCH);
+    }
+
+    /**
+     * Checks if the given {@link String} represents a PPC 64 JVM. The {@link String} must be
+     * like a value returned by the os.arch System Property.
+     *
+     * @param value The value to check.
+     * @return <code>True</code>, if the {@link String} represents a PPC 64 value, else <code>false</code>.
+     */
+    public static final boolean isPPC64JVM(String value) {
+        return StringUtils.equals(PPC64, map.get(value));
+    }
+
+    /**
+     * Checks if the current running JVM is a 32 bit JVM using the os.arch System Property.
+     * <p>
+     * <p>
+     * Important: The os.arch System Property returns the architecture used by the JVM
+     * not of the operating system.
+     * </p>
+     *
+     * @return <code>True</code>, if the current JVM is 32 bit, else <code>false</code>.
+     */
+    public static final boolean is32BitJVM() {
+        return isX86JVM() || isIA64_32JVM() || isPPCJVM();
+    }
+
+    /**
+     * Checks if the given {@link String} represents a 32 bit JVM. The {@link String} must be
+     * like a value returned by the os.arch System Property.
+     *
+     * @param value The value to check.
+     * @return <code>True</code>, if the {@link String} represents a 32 bit value, else <code>false</code>.
+     */
+    public static final boolean is32BitJVM(String value) {
+        return isX86JVM(value) || isIA64_32JVM(value) || isPPCJVM(value);
+    }
+
+    /**
+     * Checks if the current running JVM is a 64 bit JVM using the os.arch System Property.
+     * <p>
+     * <p>
+     * Important: The os.arch System Property returns the architecture used by the JVM
+     * not of the operating system.
+     * </p>
+     *
+     * @return <code>True</code>, if the current JVM is 64 bit, else <code>false</code>.
+     */
+    public static final boolean is64BitJVM() {
+        return isX86_64JVM() || isIA64JVM() || isPPC64JVM();
+    }
+
+    /**
+     * Checks if the given {@link String} represents a 64 bit JVM. The {@link String} must be
+     * like a value returned by the os.arch System Property.
+     *
+     * @param value The value to check.
+     * @return <code>True</code>, if the {@link String} represents a 64 bit value, else <code>false</code>.
+     */
+    public static final boolean is64BitJVM(String value) {
+        return isX86_64JVM(value) || isIA64JVM(value) || isPPC64JVM(value);
+    }
+
+    /**
+     * Checks if the os.arch System Property {@link String} of the current JVM is supported.
+     * <p>","[{'comment': '\r\n\r\nMinor bug in Javadoc HTML. Extra opening paragraph. Can be fixed later too.\r\n', 'commenter': 'kinow'}]"
231,src/main/java/org/apache/commons/lang3/ArchUtils.java,"@@ -0,0 +1,446 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.lang3;
+
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+
+/**
+ * An utility class for the os.arch System Property. The class defines methods for
+ * identifying the architecture of the current JVM.
+ * <p>
+ * <p>
+ * Important: The os.arch System Property returns the architecture used by the JVM
+ * not of the operating system.
+ * </p>
+ *
+ * @author Tomschi
+ */
+public class ArchUtils {
+
+    /**
+     * This {@link Map} contains the the possible os.arch property {@link String}'s.
+     */
+    private static final Map<String, String> map;
+
+    /**
+     * The value for x86 architecture.
+     */
+    private static final String X86 = ""x86"";
+
+    /**
+     * The value for x86_64 architecture.
+     */
+    private static final String X86_64 = ""x86_64"";
+
+    /**
+     * The value for ia64_32 architecture.
+     */
+    private static final String IA64_32 = ""ia64_32"";
+
+    /**
+     * The value for ia64 architecture.
+     */
+    private static final String IA64 = ""ia64"";
+
+    /**
+     * The value for ppc architecture.
+     */
+    private static final String PPC = ""ppc"";
+
+    /**
+     * The value for ppc64 architecture.
+     */
+    private static final String PPC64 = ""ppc64"";
+
+    static {
+        map = new ConcurrentHashMap<>();
+
+        // x86 mappings
+        addX86(X86);
+        addX86(""i386"");
+        addX86(""i486"");
+        addX86(""i586"");
+        addX86(""i686"");
+        addX86(""pentium"");
+
+        // x86_64 mappings
+        addX86_64(X86_64);
+        addX86_64(""amd64"");
+        addX86_64(""em64t"");
+        addX86_64(""universal""); // Needed for openjdk7 in Mac
+
+        // Itenium 64-bit mappings
+        addIA64(IA64);
+        addIA64(""ia64w"");
+
+        // Itenium 32-bit mappings, usually an HP-UX construct
+        addIA64_32(IA64_32);
+        addIA64_32(""ia64n"");
+
+        // PowerPC mappings
+        addPPC(PPC);
+        addPPC(""power"");
+        addPPC(""powerpc"");
+        addPPC(""power_pc"");
+        addPPC(""power_rs"");
+
+        // PowerPC 64bit mappings
+        addPPC64(PPC64);
+        addPPC64(""power64"");
+        addPPC64(""powerpc64"");
+        addPPC64(""power_pc64"");
+        addPPC64(""power_rs64"");
+    }
+
+    /**
+     * Possibility to add {@link String}, representing the <code>System.getProperty(""os.arch"")</code>
+     * to x86 architecture.
+     *
+     * @param value The {@link String} to add.
+     */
+    public static final void addX86(String value) {
+        map.put(value, X86);
+    }
+
+    /**
+     * Checks if the current running JVM is a JVM for x86 architecture.
+     * It returns <code>true</code>, if the os.arch System Property matches the following {@link String}'s:
+     * <ul>
+     * <li>x86</li>
+     * <li>i386</li>
+     * <li>i486</li>
+     * <li>i586</li>
+     * <li>i686</li>
+     * <li>pentium</li>
+     * </ul>
+     * <p>
+     * It is possible to extend the {@link String}'s above using method {@link ArchUtils#addX86(String)}.
+     * <p>
+     * <p>
+     * Important: The os.arch System Property returns the architecture used by the JVM
+     * not of the operating system.
+     * </p>
+     *
+     * @return <code>True</code> if the current JVM is a x86 JVM, else <code>false</code>.
+     */
+    public static final boolean isX86JVM() {
+        return isX86JVM(SystemUtils.OS_ARCH);
+    }
+
+    /**
+     * Checks if the given {@link String} represents a x86 JVM. The {@link String} must be
+     * like a value returned by the os.arch System Property.
+     *
+     * @param value The value to check.
+     * @return <code>True</code>, if the {@link String} represents a x86 value, else <code>false</code>.
+     */
+    public static final boolean isX86JVM(String value) {
+        return StringUtils.equals(X86, map.get(value));
+    }
+
+    /**
+     * Possibility to add {@link String}, representing the <code>System.getProperty(""os.arch"")</code>
+     * to x86_64 architecture.
+     *
+     * @param value The {@link String} to add.
+     */
+    public static final void addX86_64(String value) {
+        map.put(value, X86_64);
+    }
+
+    /**
+     * Checks if the current running JVM is a JVM for x86_64 architecture.
+     * It returns <code>true</code>, if the os.arch System Property matches the following {@link String}'s:
+     * <ul>
+     * <li>x86_64</li>
+     * <li>amd64</li>
+     * <li>em64t</li>
+     * <li>universal</li>
+     * </ul>
+     * <p>
+     * It is possible to extend the {@link String}'s above using method {@link ArchUtils#addX86_64(String)}.
+     * <p>
+     * <p>
+     * Important: The os.arch System Property returns the architecture used by the JVM
+     * not of the operating system.
+     * </p>
+     *
+     * @return <code>True</code> if the current JVM is a x86_64 JVM, else <code>false</code>.
+     */
+    public static final boolean isX86_64JVM() {
+        return isX86_64JVM(SystemUtils.OS_ARCH);
+    }
+
+    /**
+     * Checks if the given {@link String} represents a x86_64 JVM. The {@link String} must be
+     * like a value returned by the os.arch System Property.
+     *
+     * @param value The value to check.
+     * @return <code>True</code>, if the {@link String} represents a x86_64 value, else <code>false</code>.
+     */
+    public static final boolean isX86_64JVM(String value) {
+        return StringUtils.equals(X86_64, map.get(value));
+    }
+
+    /**
+     * Possibility to add {@link String}, representing the <code>System.getProperty(""os.arch"")</code>
+     * to IA32_64 architecture.
+     *
+     * @param value The {@link String} to add.
+     */
+    public static final void addIA64_32(String value) {
+        map.put(value, IA64_32);
+    }
+
+    /**
+     * Checks if the current running JVM is a JVM for IA64 32 bit architecture.
+     * It returns <code>true</code>, if the os.arch System Property matches the following {@link String}'s:
+     * <ul>
+     * <li>ia64_32</li>
+     * <li>ia64n</li>
+     * </ul>
+     * <p>
+     * It is possible to extend the {@link String}'s above using method {@link ArchUtils#addIA64_32(String)}.
+     * <p>
+     * <p>
+     * Important: The os.arch System Property returns the architecture used by the JVM
+     * not of the operating system.
+     * </p>
+     *
+     * @return <code>True</code> if the current JVM is a IA64 32 bit JVM, else <code>false</code>.
+     */
+    public static final boolean isIA64_32JVM() {
+        return isIA64_32JVM(SystemUtils.OS_ARCH);
+    }
+
+    /**
+     * Checks if the given {@link String} represents a IA64_32 JVM. The {@link String} must be
+     * like a value returned by the os.arch System Property.
+     *
+     * @param value The value to check.
+     * @return <code>True</code>, if the {@link String} represents a IA64_32 value, else <code>false</code>.
+     */
+    public static final boolean isIA64_32JVM(String value) {
+        return StringUtils.equals(IA64_32, map.get(value));
+    }
+
+    /**
+     * Possibility to add {@link String}, representing the <code>System.getProperty(""os.arch"")</code>
+     * to IA64 architecture.
+     *
+     * @param value The {@link String} to add.
+     */
+    public static final void addIA64(String value) {
+        map.put(value, IA64);
+    }
+
+    /**
+     * Checks if the current running JVM is a JVM for IA64 architecture.
+     * It returns <code>true</code>, if the os.arch System Property matches the following {@link String}'s:
+     * <ul>
+     * <li>ia64</li>
+     * <li>ia64w</li>
+     * </ul>
+     * <p>
+     * It is possible to extend the {@link String}'s above using method {@link ArchUtils#addIA64(String)}.
+     * <p>
+     * <p>
+     * Important: The os.arch System Property returns the architecture used by the JVM
+     * not of the operating system.
+     * </p>
+     *
+     * @return <code>True</code> if the current JVM is a IA64 JVM, else <code>false</code>.
+     */
+    public static final boolean isIA64JVM() {
+        return isIA64JVM(SystemUtils.OS_ARCH);
+    }
+
+    /**
+     * Checks if the given {@link String} represents a IA64 JVM. The {@link String} must be
+     * like a value returned by the os.arch System Property.
+     *
+     * @param value The value to check.
+     * @return <code>True</code>, if the {@link String} represents a IA64 value, else <code>false</code>.
+     */
+    public static final boolean isIA64JVM(String value) {
+        return StringUtils.equals(IA64, map.get(value));
+    }
+
+    /**
+     * Possibility to add {@link String}, representing the <code>System.getProperty(""os.arch"")</code>
+     * to PPC architecture.
+     *
+     * @param value The {@link String} to add.
+     */
+    public static final void addPPC(String value) {
+        map.put(value, PPC);
+    }
+
+    /**
+     * Checks if the current running JVM is a JVM for PPC architecture.
+     * It returns <code>true</code>, if the os.arch System Property matches the following {@link String}'s:
+     * <ul>
+     * <li>ppc</li>
+     * <li>powerpc</li>
+     * <li>power_pc</li>
+     * <li>power_rs</li>
+     * </ul>
+     * <p>
+     * It is possible to extend the {@link String}'s above using method {@link ArchUtils#addPPC(String)}.
+     * <p>
+     * <p>
+     * Important: The os.arch System Property returns the architecture used by the JVM
+     * not of the operating system.
+     * </p>
+     *
+     * @return <code>True</code> if the current JVM is a PPC JVM, else <code>false</code>.
+     */
+    public static final boolean isPPCJVM() {
+        return isPPCJVM(SystemUtils.OS_ARCH);
+    }
+
+    /**
+     * Checks if the given {@link String} represents a PPC JVM. The {@link String} must be
+     * like a value returned by the os.arch System Property.
+     *
+     * @param value The value to check.
+     * @return <code>True</code>, if the {@link String} represents a PPC value, else <code>false</code>.
+     */
+    public static final boolean isPPCJVM(String value) {
+        return StringUtils.equals(PPC, map.get(value));
+    }
+
+    /**
+     * Possibility to add {@link String}, representing the <code>System.getProperty(""os.arch"")</code>
+     * to PPC_64 architecture.
+     *
+     * @param value The {@link String} to add.
+     */
+    public static final void addPPC64(String value) {
+        map.put(value, PPC64);
+    }
+
+    /**
+     * Checks if the current running JVM is a JVM for PPC 64 bit architecture.
+     * It returns <code>true</code>, if the os.arch System Property matches the following {@link String}'s:
+     * <ul>
+     * <li>ppc64</li>
+     * <li>powerpc64</li>
+     * <li>power_pc64</li>
+     * <li>power_rs64</li>
+     * </ul>
+     * <p>
+     * It is possible to extend the {@link String}'s above using method {@link ArchUtils#addPPC64(String)}.
+     * <p>
+     * <p>
+     * Important: The os.arch System Property returns the architecture used by the JVM
+     * not of the operating system.
+     * </p>
+     *
+     * @return <code>True</code> if the current JVM is a PPC 64 bit JVM, else <code>false</code>.
+     */
+    public static final boolean isPPC64JVM() {
+        return isPPC64JVM(SystemUtils.OS_ARCH);
+    }
+
+    /**
+     * Checks if the given {@link String} represents a PPC 64 JVM. The {@link String} must be
+     * like a value returned by the os.arch System Property.
+     *
+     * @param value The value to check.
+     * @return <code>True</code>, if the {@link String} represents a PPC 64 value, else <code>false</code>.
+     */
+    public static final boolean isPPC64JVM(String value) {
+        return StringUtils.equals(PPC64, map.get(value));
+    }
+
+    /**
+     * Checks if the current running JVM is a 32 bit JVM using the os.arch System Property.
+     * <p>
+     * <p>
+     * Important: The os.arch System Property returns the architecture used by the JVM
+     * not of the operating system.
+     * </p>
+     *
+     * @return <code>True</code>, if the current JVM is 32 bit, else <code>false</code>.
+     */
+    public static final boolean is32BitJVM() {
+        return isX86JVM() || isIA64_32JVM() || isPPCJVM();
+    }
+
+    /**
+     * Checks if the given {@link String} represents a 32 bit JVM. The {@link String} must be
+     * like a value returned by the os.arch System Property.
+     *
+     * @param value The value to check.
+     * @return <code>True</code>, if the {@link String} represents a 32 bit value, else <code>false</code>.
+     */
+    public static final boolean is32BitJVM(String value) {
+        return isX86JVM(value) || isIA64_32JVM(value) || isPPCJVM(value);
+    }
+
+    /**
+     * Checks if the current running JVM is a 64 bit JVM using the os.arch System Property.
+     * <p>
+     * <p>
+     * Important: The os.arch System Property returns the architecture used by the JVM
+     * not of the operating system.
+     * </p>
+     *
+     * @return <code>True</code>, if the current JVM is 64 bit, else <code>false</code>.
+     */
+    public static final boolean is64BitJVM() {
+        return isX86_64JVM() || isIA64JVM() || isPPC64JVM();
+    }
+
+    /**
+     * Checks if the given {@link String} represents a 64 bit JVM. The {@link String} must be
+     * like a value returned by the os.arch System Property.
+     *
+     * @param value The value to check.
+     * @return <code>True</code>, if the {@link String} represents a 64 bit value, else <code>false</code>.
+     */
+    public static final boolean is64BitJVM(String value) {
+        return isX86_64JVM(value) || isIA64JVM(value) || isPPC64JVM(value);
+    }
+
+    /**
+     * Checks if the os.arch System Property {@link String} of the current JVM is supported.
+     * <p>
+     * <p>
+     * Important: The os.arch System Property returns the architecture used by the JVM
+     * not of the operating system.
+     * </p>
+     *
+     * @return <code>True</code>, if supported, else <code>false</code>.
+     */
+    public static final boolean isSupported() {
+        return is32BitJVM() || is64BitJVM();
+    }
+
+    /**
+     * Checks if the given os.arch {@link String} is supported. The given {@link String} must be
+     * like a value returned by the os.arch System Property.
+     *","[{'comment': '\r\n\r\nMinor bug in Javadoc. Missing @ param for value.\r\n', 'commenter': 'kinow'}]"
231,src/main/java/org/apache/commons/lang3/arch/Processor.java,"@@ -0,0 +1,30 @@
+package org.apache.commons.lang3.arch;
+
+/**
+ *
+ */
+public class Processor {
+
+    private String name;
+    private ProcessorArch processorArch;
+    private ProcessorType processorType;
+","[{'comment': ""These should be final.\r\nI don't think the name is needed."", 'commenter': 'sebbASF'}, {'comment': 'I think the name field is needed for better reuse of the Processor object.', 'commenter': 'Tomschi'}, {'comment': ""I don't understand how the name field helps. \r\nIt's obviously necessary to be able to get the Processor object from the name, but once you have the object, you know what the name is.\r\nSo why do you think the name is necessary?\r\n\r\nThe name field results in more objects being needed; if the name is not included then all the PPC+64 systems (e.g.) can share the same object in the init code."", 'commenter': 'sebbASF'}]"
231,src/main/java/org/apache/commons/lang3/tuple/ArchUtilsImproved.java,"@@ -0,0 +1,400 @@
+package org.apache.commons.lang3.tuple;
+
+import org.apache.commons.lang3.ArchUtils;
+import org.apache.commons.lang3.SystemUtils;
+import org.apache.commons.lang3.arch.Processor;
+import org.apache.commons.lang3.arch.ProcessorArch;
+import org.apache.commons.lang3.arch.ProcessorType;
+
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ *
+ */
+public class ArchUtilsImproved {
+
+    private static Map<String, Processor> map;
+
+    static {
+        map = new HashMap<>();
+        init();
+    }
+
+    private static final void init() {
+        init_X86_32Bit();
+        init_X86_64Bit();
+        init_IA64_32Bit();
+        init_IA64_64Bit();
+        init_PPA_32Bit();
+        init_PPA_64Bit();
+    }
+
+    private static final void init_X86_32Bit() {
+        Processor x86 = new Processor(""x86"", ProcessorArch.BIT_32, ProcessorType.X86);
+        map.put(x86.getName(), x86);
+
+        Processor i386 = new Processor(""i386"", ProcessorArch.BIT_32, ProcessorType.X86);
+        map.put(i386.getName(), i386);
+
+        Processor i486 = new Processor(""i486"", ProcessorArch.BIT_32, ProcessorType.X86);
+        map.put(i486.getName(), i486);
+
+        Processor i586 = new Processor(""i586"", ProcessorArch.BIT_32, ProcessorType.X86);
+        map.put(i586.getName(), i586);
+
+        Processor i686 = new Processor(""i686"", ProcessorArch.BIT_32, ProcessorType.X86);
+        map.put(i686.getName(), i686);
+
+        Processor pentium = new Processor(""pentium"", ProcessorArch.BIT_32, ProcessorType.X86);
+        map.put(pentium.getName(), pentium);
+    }
+
+    private static final void init_X86_64Bit() {
+        Processor x86_64 = new Processor(""x86_64"", ProcessorArch.BIT_64, ProcessorType.X86);
+        map.put(x86_64.getName(), x86_64);
+
+        Processor amd64 = new Processor(""amd64"", ProcessorArch.BIT_64, ProcessorType.X86);
+        map.put(amd64.getName(), amd64);
+
+        Processor em64t = new Processor(""em64t"", ProcessorArch.BIT_64, ProcessorType.X86);
+        map.put(em64t.getName(), em64t);
+
+        Processor universal = new Processor(""universal"", ProcessorArch.BIT_64, ProcessorType.X86);
+        map.put(universal.getName(), universal);
+    }
+
+    private static final void init_IA64_32Bit() {
+        Processor ia64_32 = new Processor(""ia64_32"", ProcessorArch.BIT_32, ProcessorType.IA_64);
+        map.put(ia64_32.getName(), ia64_32);
+
+        Processor ia64n = new Processor(""ia64n"", ProcessorArch.BIT_32, ProcessorType.IA_64);
+        map.put(ia64n.getName(), ia64n);
+    }
+
+    private static final void init_IA64_64Bit() {
+        Processor ia64 = new Processor(""ia64"", ProcessorArch.BIT_64, ProcessorType.IA_64);
+        map.put(ia64.getName(), ia64);
+
+        Processor ia64w = new Processor(""ia64w"", ProcessorArch.BIT_64, ProcessorType.IA_64);
+        map.put(ia64w.getName(), ia64w);
+    }
+
+    private static final void init_PPA_32Bit() {
+        Processor ppc = new Processor(""ppc"", ProcessorArch.BIT_32, ProcessorType.PPC);
+        map.put(ppc.getName(), ppc);
+
+        Processor power = new Processor(""power"", ProcessorArch.BIT_32, ProcessorType.PPC);
+        map.put(power.getName(), power);
+
+        Processor powerpc = new Processor(""powerpc"", ProcessorArch.BIT_32, ProcessorType.PPC);
+        map.put(powerpc.getName(), powerpc);
+
+        Processor power_pc = new Processor(""power_pc"", ProcessorArch.BIT_32, ProcessorType.PPC);
+        map.put(power_pc.getName(), power_pc);
+
+        Processor power_rs = new Processor(""power_rs"", ProcessorArch.BIT_32, ProcessorType.PPC);
+        map.put(power_rs.getName(), power_rs);
+    }
+
+    private static final void init_PPA_64Bit() {
+        Processor ppc64 = new Processor(""ppc64"", ProcessorArch.BIT_64, ProcessorType.PPC);
+        map.put(ppc64.getName(), ppc64);
+
+        Processor power64 = new Processor(""power64"", ProcessorArch.BIT_64, ProcessorType.PPC);
+        map.put(power64.getName(), power64);
+
+        Processor powerpc64 = new Processor(""powerpc64"", ProcessorArch.BIT_64, ProcessorType.PPC);
+        map.put(powerpc64.getName(), powerpc64);
+
+        Processor power_pc64 = new Processor(""power_pc64"", ProcessorArch.BIT_64, ProcessorType.PPC);
+        map.put(power_pc64.getName(), power_pc64);
+
+        Processor power_rs64 = new Processor(""power_rs64"", ProcessorArch.BIT_64, ProcessorType.PPC);
+        map.put(power_rs64.getName(), power_rs64);
+    }
+
+    /**
+     * Checks if the current running JVM is a JVM for x86 architecture.
+     * It returns <code>true</code>, if the os.arch System Property matches the following {@link String}'s:
+     * <ul>
+     * <li>x86</li>
+     * <li>i386</li>
+     * <li>i486</li>
+     * <li>i586</li>
+     * <li>i686</li>
+     * <li>pentium</li>
+     * </ul>
+     * <p>
+     * It is possible to extend the {@link String}'s above using method {@link ArchUtils#addX86(String)}.
+     * </p>
+     * <p>
+     * Important: The os.arch System Property returns the architecture used by the JVM
+     * not of the operating system.
+     * </p>
+     *
+     * @return <code>True</code> if the current JVM is a x86 JVM, else <code>false</code>.
+     */
+    public static final boolean isX86JVM() {
+        return isX86JVM(SystemUtils.OS_ARCH);
+    }
+
+    /**
+     * Checks if the given {@link String} represents a x86 JVM. The {@link String} must be
+     * like a value returned by the os.arch System Property.
+     *
+     * @param value The value to check.
+     * @return <code>True</code>, if the {@link String} represents a x86 value, else <code>false</code>.
+     */
+    public static final boolean isX86JVM(String value) {
+        return is32BitJVM(value) && ProcessorType.X86.equals(map.get(value).getProcessorType());
+    }
+
+    /**
+     * Checks if the current running JVM is a JVM for x86_64 architecture.
+     * It returns <code>true</code>, if the os.arch System Property matches the following {@link String}'s:
+     * <ul>
+     * <li>x86_64</li>
+     * <li>amd64</li>
+     * <li>em64t</li>
+     * <li>universal</li>
+     * </ul>
+     * <p>
+     * It is possible to extend the {@link String}'s above using method {@link ArchUtils#addX86_64(String)}.
+     * </p>
+     * <p>
+     * Important: The os.arch System Property returns the architecture used by the JVM
+     * not of the operating system.
+     * </p>
+     *
+     * @return <code>True</code> if the current JVM is a x86_64 JVM, else <code>false</code>.
+     */
+    public static final boolean isX86_64JVM() {
+        return isX86_64JVM(SystemUtils.OS_ARCH);
+    }
+
+    /**
+     * Checks if the given {@link String} represents a x86_64 JVM. The {@link String} must be
+     * like a value returned by the os.arch System Property.
+     *
+     * @param value The value to check.
+     * @return <code>True</code>, if the {@link String} represents a x86_64 value, else <code>false</code>.
+     */
+    public static final boolean isX86_64JVM(String value) {
+        return is64BitJVM(value) && ProcessorType.X86.equals(map.get(value).getProcessorType());
+    }
+
+    /**
+     * Checks if the current running JVM is a JVM for IA64 32 bit architecture.
+     * It returns <code>true</code>, if the os.arch System Property matches the following {@link String}'s:
+     * <ul>
+     * <li>ia64_32</li>
+     * <li>ia64n</li>
+     * </ul>
+     * <p>
+     * It is possible to extend the {@link String}'s above using method {@link ArchUtils#addIA64_32(String)}.
+     * </p>
+     * <p>
+     * Important: The os.arch System Property returns the architecture used by the JVM
+     * not of the operating system.
+     * </p>
+     *
+     * @return <code>True</code> if the current JVM is a IA64 32 bit JVM, else <code>false</code>.
+     */
+    public static final boolean isIA64_32JVM() {
+        return isIA64_32JVM(SystemUtils.OS_ARCH);
+    }
+
+    /**
+     * Checks if the given {@link String} represents a IA64_32 JVM. The {@link String} must be
+     * like a value returned by the os.arch System Property.
+     *
+     * @param value The value to check.
+     * @return <code>True</code>, if the {@link String} represents a IA64_32 value, else <code>false</code>.
+     */
+    public static final boolean isIA64_32JVM(String value) {
+        return is32BitJVM(value) && ProcessorType.IA_64.equals(map.get(value).getProcessorType());
+    }
+
+    /**
+     * Checks if the current running JVM is a JVM for IA64 architecture.
+     * It returns <code>true</code>, if the os.arch System Property matches the following {@link String}'s:
+     * <ul>
+     * <li>ia64</li>
+     * <li>ia64w</li>
+     * </ul>
+     * <p>
+     * It is possible to extend the {@link String}'s above using method {@link ArchUtils#addIA64(String)}.
+     * </p>
+     * <p>
+     * Important: The os.arch System Property returns the architecture used by the JVM
+     * not of the operating system.
+     * </p>
+     *
+     * @return <code>True</code> if the current JVM is a IA64 JVM, else <code>false</code>.
+     */
+    public static final boolean isIA64JVM() {
+        return isIA64JVM(SystemUtils.OS_ARCH);
+    }
+
+    /**
+     * Possibility to add {@link String}, representing the <code>System.getProperty(""os.arch"")</code>
+     * to IA64 architecture.
+     *
+     * @param value The {@link String} to add.
+     */
+    public static final boolean isIA64JVM(String value) {
+        return is64BitJVM(value) && ProcessorType.IA_64.equals(map.get(value).getProcessorType());
+    }
+
+    /**
+     * Checks if the current running JVM is a JVM for PPC architecture.
+     * It returns <code>true</code>, if the os.arch System Property matches the following {@link String}'s:
+     * <ul>
+     * <li>ppc</li>
+     * <li>powerpc</li>
+     * <li>power_pc</li>
+     * <li>power_rs</li>
+     * </ul>
+     * <p>
+     * It is possible to extend the {@link String}'s above using method {@link ArchUtils#addPPC(String)}.
+     * </p>
+     * <p>
+     * Important: The os.arch System Property returns the architecture used by the JVM
+     * not of the operating system.
+     * </p>
+     *
+     * @return <code>True</code> if the current JVM is a PPC JVM, else <code>false</code>.
+     */
+    public static final boolean isPPCJVM() {
+        return isPPCJVM(SystemUtils.OS_ARCH);
+    }
+
+    /**
+     * Checks if the given {@link String} represents a PPC JVM. The {@link String} must be
+     * like a value returned by the os.arch System Property.
+     *
+     * @param value The value to check.
+     * @return <code>True</code>, if the {@link String} represents a PPC value, else <code>false</code>.
+     */
+    public static final boolean isPPCJVM(String value) {
+        return is32BitJVM(value) && ProcessorType.PPC.equals(map.get(value).getProcessorType());
+    }
+
+    /**
+     * Checks if the current running JVM is a JVM for PPC 64 bit architecture.
+     * It returns <code>true</code>, if the os.arch System Property matches the following {@link String}'s:
+     * <ul>
+     * <li>ppc64</li>
+     * <li>powerpc64</li>
+     * <li>power_pc64</li>
+     * <li>power_rs64</li>
+     * </ul>
+     * <p>
+     * It is possible to extend the {@link String}'s above using method {@link ArchUtils#addPPC64(String)}.
+     * </p>
+     * <p>
+     * Important: The os.arch System Property returns the architecture used by the JVM
+     * not of the operating system.
+     * </p>
+     *
+     * @return <code>True</code> if the current JVM is a PPC 64 bit JVM, else <code>false</code>.
+     */
+    public static final boolean isPPC64JVM() {
+        return isPPC64JVM(SystemUtils.OS_ARCH);
+    }
+
+    /**
+     * Checks if the given {@link String} represents a PPC 64 JVM. The {@link String} must be
+     * like a value returned by the os.arch System Property.
+     *
+     * @param value The value to check.
+     * @return <code>True</code>, if the {@link String} represents a PPC 64 value, else <code>false</code>.
+     */
+    public static final boolean isPPC64JVM(String value) {
+        return is64BitJVM(value) && ProcessorType.PPC.equals(map.get(value).getProcessorType());
+    }
+
+    /**
+     * Checks if the current running JVM is a 32 bit JVM using the os.arch System Property.
+     * <p>
+     * Important: The os.arch System Property returns the architecture used by the JVM
+     * not of the operating system.
+     * </p>
+     *
+     * @return <code>True</code>, if the current JVM is 32 bit, else <code>false</code>.
+     */
+    public static final boolean is32BitJVM() {
+        return is32BitJVM(SystemUtils.OS_ARCH);
+    }
+
+    /**
+     * Checks if the given {@link String} represents a 32 bit JVM. The {@link String} must be
+     * like a value returned by the os.arch System Property.
+     *
+     * @param value The value to check.
+     * @return <code>True</code>, if the {@link String} represents a 32 bit value, else <code>false</code>.
+     */
+    public static final boolean is32BitJVM(String value) {
+        if (isSupported(value)) {
+            Processor processor = map.get(value);","[{'comment': 'Unnecessary check\r\n\r\nCould just code the method as:\r\n\r\nreturn ProcessorArch.BIT_32.equals(processor.getProcessorArch());', 'commenter': 'sebbASF'}]"
231,src/main/java/org/apache/commons/lang3/ArchUtils.java,"@@ -53,94 +55,76 @@ private static final void init() {
      * Adding x86 32 bit {@link Processor}'s to the map
      */
     private static final void init_X86_32Bit() {
-        Processor x86 = new Processor(""x86"", ProcessorArch.BIT_32, ProcessorType.X86);
-        Processor i386 = new Processor(""i386"", ProcessorArch.BIT_32, ProcessorType.X86);
-        Processor i486 = new Processor(""i486"", ProcessorArch.BIT_32, ProcessorType.X86);
-        Processor i586 = new Processor(""i586"", ProcessorArch.BIT_32, ProcessorType.X86);
-        Processor i686 = new Processor(""i686"", ProcessorArch.BIT_32, ProcessorType.X86);
-        Processor pentium = new Processor(""pentium"", ProcessorArch.BIT_32, ProcessorType.X86);
-        addProcessors(x86, i386, i486, i586, i686, pentium);
+        Processor processor = new Processor(ProcessorArch.BIT_32, ProcessorType.X86);
+        addProcessors(Arrays.asList(""x86"", ""i386"", ""i486"", ""i586"", ""i686"", ""pentium""), processor);
     }
 
     /**
      * Adding x86 64 bit {@link Processor}'s to the map
      */
     private static final void init_X86_64Bit() {
-        Processor x86_64 = new Processor(""x86_64"", ProcessorArch.BIT_64, ProcessorType.X86);
-        Processor amd64 = new Processor(""amd64"", ProcessorArch.BIT_64, ProcessorType.X86);
-        Processor em64t = new Processor(""em64t"", ProcessorArch.BIT_64, ProcessorType.X86);
-        Processor universal = new Processor(""universal"", ProcessorArch.BIT_64, ProcessorType.X86);
-        addProcessors(x86_64, amd64, em64t, universal);
+        Processor processor = new Processor(ProcessorArch.BIT_64, ProcessorType.X86);
+        addProcessors(Arrays.asList(""x86_64"", ""amd64"", ""em64t"", ""universal""), processor);
     }
 
     /**
      * Adding ia64 32 bit {@link Processor}'s to the map
      */
     private static final void init_IA64_32Bit() {
-        Processor ia64_32 = new Processor(""ia64_32"", ProcessorArch.BIT_32, ProcessorType.IA_64);
-        Processor ia64n = new Processor(""ia64n"", ProcessorArch.BIT_32, ProcessorType.IA_64);
-        addProcessors(ia64_32, ia64n);
+        Processor processor = new Processor(ProcessorArch.BIT_32, ProcessorType.IA_64);
+        addProcessors(Arrays.asList(""ia64_32"", ""ia64n""), processor);
     }
 
     /**
      * Adding ia64 64 bit {@link Processor}'s to the map
      */
     private static final void init_IA64_64Bit() {
-        Processor ia64 = new Processor(""ia64"", ProcessorArch.BIT_64, ProcessorType.IA_64);
-        Processor ia64w = new Processor(""ia64w"", ProcessorArch.BIT_64, ProcessorType.IA_64);
-        addProcessors(ia64, ia64w);
+        Processor processor = new Processor(ProcessorArch.BIT_64, ProcessorType.IA_64);
+        addProcessors(Arrays.asList(""ia64"", ""ia64w""), processor);
     }
 
     /**
      * Adding PPC 32 bit {@link Processor}'s to the map
      */
     private static final void init_PPC_32Bit() {
-        Processor ppc = new Processor(""ppc"", ProcessorArch.BIT_32, ProcessorType.PPC);
-        Processor power = new Processor(""power"", ProcessorArch.BIT_32, ProcessorType.PPC);
-        Processor powerpc = new Processor(""powerpc"", ProcessorArch.BIT_32, ProcessorType.PPC);
-        Processor power_pc = new Processor(""power_pc"", ProcessorArch.BIT_32, ProcessorType.PPC);
-        Processor power_rs = new Processor(""power_rs"", ProcessorArch.BIT_32, ProcessorType.PPC);
-        addProcessors(ppc, power, powerpc, power_pc, power_rs);
+        Processor processor = new Processor(ProcessorArch.BIT_32, ProcessorType.PPC);
+        addProcessors(Arrays.asList(""ppc"", ""power"", ""powerpc"", ""power_pc"", ""power_rs""), processor);
     }
 
     /**
      * Adding PPC 64 bit {@link Processor}'s to the map
      */
     private static final void init_PPC_64Bit() {
-        Processor ppc64 = new Processor(""ppc64"", ProcessorArch.BIT_64, ProcessorType.PPC);
-        Processor power64 = new Processor(""power64"", ProcessorArch.BIT_64, ProcessorType.PPC);
-        Processor powerpc64 = new Processor(""powerpc64"", ProcessorArch.BIT_64, ProcessorType.PPC);
-        Processor power_pc64 = new Processor(""power_pc64"", ProcessorArch.BIT_64, ProcessorType.PPC);
-        Processor power_rs64 = new Processor(""power_rs64"", ProcessorArch.BIT_64, ProcessorType.PPC);
-        addProcessors(ppc64, power64, powerpc64, power_pc64, power_rs64);
+        Processor processor = new Processor(ProcessorArch.BIT_64, ProcessorType.PPC);
+        addProcessors(Arrays.asList(""ppc64"", ""power64"", ""powerpc64"", ""power_pc64"", ""power_rs64""), processor);
     }
 
     /**
-     * Adds the given {@link Processor} to the map. The {@link Processor#getName()} is used as key
-     * and the {@link Processor} object as value.
+     * Adds the given {@link Processor} whith the given key {@link String} to the map.
      *
+     * @param key The key as {@link String}.
      * @param processor The {@link Processor} to add.
      * @throws UnsupportedOperationException When key already exists in map.
      */
-    private static final void addProcessor(Processor processor) throws UnsupportedOperationException {
-        if (!map.containsKey(processor.getName())) {
-            map.put(processor.getName(), processor);
+    private static final void addProcessor(String key, Processor processor) throws UnsupportedOperationException {","[{'comment': 'If the parameters were changed to (Processor processor, String key ...) there would be no need to create the List and unpack it.', 'commenter': 'sebbASF'}]"
231,src/main/java/org/apache/commons/lang3/ArchUtils.java,"@@ -0,0 +1,238 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.lang3;
+
+import org.apache.commons.lang3.arch.Processor;
+import org.apache.commons.lang3.arch.ProcessorArch;
+import org.apache.commons.lang3.arch.ProcessorType;
+
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+/**
+ * An utility class for the os.arch System Property. The class defines methods for
+ * identifying the architecture of the current JVM.
+ * <p>
+ * Important: The os.arch System Property returns the architecture used by the JVM
+ * not of the operating system.
+ * </p>
+ */
+public class ArchUtils {
+
+    private static Map<String, Processor> map;
+
+    static {
+        map = new HashMap<>();
+        init();
+    }
+
+    private static final void init() {
+        init_X86_32Bit();
+        init_X86_64Bit();
+        init_IA64_32Bit();
+        init_IA64_64Bit();
+        init_PPC_32Bit();
+        init_PPC_64Bit();
+    }
+
+    /**
+     * Adding x86 32 bit {@link Processor}'s to the map
+     */
+    private static final void init_X86_32Bit() {
+        Processor processor = new Processor(ProcessorArch.BIT_32, ProcessorType.X86);
+        addProcessors(Arrays.asList(""x86"", ""i386"", ""i486"", ""i586"", ""i686"", ""pentium""), processor);
+    }
+
+    /**
+     * Adding x86 64 bit {@link Processor}'s to the map
+     */
+    private static final void init_X86_64Bit() {
+        Processor processor = new Processor(ProcessorArch.BIT_64, ProcessorType.X86);
+        addProcessors(Arrays.asList(""x86_64"", ""amd64"", ""em64t"", ""universal""), processor);
+    }
+
+    /**
+     * Adding ia64 32 bit {@link Processor}'s to the map
+     */
+    private static final void init_IA64_32Bit() {
+        Processor processor = new Processor(ProcessorArch.BIT_32, ProcessorType.IA_64);
+        addProcessors(Arrays.asList(""ia64_32"", ""ia64n""), processor);
+    }
+
+    /**
+     * Adding ia64 64 bit {@link Processor}'s to the map
+     */
+    private static final void init_IA64_64Bit() {
+        Processor processor = new Processor(ProcessorArch.BIT_64, ProcessorType.IA_64);
+        addProcessors(Arrays.asList(""ia64"", ""ia64w""), processor);
+    }
+
+    /**
+     * Adding PPC 32 bit {@link Processor}'s to the map
+     */
+    private static final void init_PPC_32Bit() {
+        Processor processor = new Processor(ProcessorArch.BIT_32, ProcessorType.PPC);
+        addProcessors(Arrays.asList(""ppc"", ""power"", ""powerpc"", ""power_pc"", ""power_rs""), processor);
+    }
+
+    /**
+     * Adding PPC 64 bit {@link Processor}'s to the map
+     */
+    private static final void init_PPC_64Bit() {
+        Processor processor = new Processor(ProcessorArch.BIT_64, ProcessorType.PPC);
+        addProcessors(Arrays.asList(""ppc64"", ""power64"", ""powerpc64"", ""power_pc64"", ""power_rs64""), processor);
+    }
+
+    /**
+     * Adds the given {@link Processor} whith the given key {@link String} to the map.
+     *
+     * @param key The key as {@link String}.
+     * @param processor The {@link Processor} to add.
+     * @throws UnsupportedOperationException When key already exists in map.
+     */
+    private static final void addProcessor(String key, Processor processor) throws UnsupportedOperationException {
+        if (!map.containsKey(key)) {
+            map.put(key, processor);
+        } else {
+            String msg = ""Key "" + key + "" already exists in processor map"";
+            throw new UnsupportedOperationException(msg);
+        }
+    }
+
+    /**
+     * Adds the given {@link Processor} with the given keys to the map.
+     *
+     * @param keys A {@link List} of the key.
+     * @param processor The {@link Processor} to add.
+     * @throws UnsupportedOperationException When key already exists in map.
+     */
+    private static final void addProcessors(List<String> keys, Processor processor) {
+        for (String key : keys) {
+            addProcessor(key, processor);
+        }
+    }
+
+    /**
+     * Checks if the current running JVM is a 32 bit JVM using the os.arch System Property.
+     * <p>
+     * Important: The os.arch System Property returns the architecture used by the JVM
+     * not of the operating system.
+     * </p>
+     *
+     * @return <code>True</code>, if the current JVM is 32 bit, else <code>false</code>.
+     */
+    public static final boolean is32BitJVM() {
+        return is32BitJVM(SystemUtils.OS_ARCH);
+    }
+
+    /**
+     * Checks if the given {@link String} represents a 32 bit JVM. The {@link String} must be
+     * like a value returned by the os.arch System Property.
+     *
+     * @param value The value to check.
+     * @return <code>True</code>, if the {@link String} represents a 32 bit value, else <code>false</code>.
+     */
+    public static final boolean is32BitJVM(String value) {
+        if (isSupported(value)) {
+            Processor processor = map.get(value);
+            return ProcessorArch.BIT_32.equals(processor.getProcessorArch());
+        } else {
+            return false;
+        }","[{'comment': 'The code could be simplified:\r\n```\r\nProcessor processor = map.get(value);\r\nreturn processor != null && ProcessorArch.BIT_32.equals(processor.getProcessorArch());\r\n```\r\nSimilarly for other related methods', 'commenter': 'sebbASF'}]"
231,src/main/java/org/apache/commons/lang3/ArchUtils.java,"@@ -0,0 +1,155 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.lang3;
+
+import org.apache.commons.lang3.arch.Processor;
+import org.apache.commons.lang3.arch.ProcessorArch;
+import org.apache.commons.lang3.arch.ProcessorType;
+
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+/**
+ * An utility class for the os.arch System Property. The class defines methods for
+ * identifying the architecture of the current JVM.
+ * <p>
+ * Important: The os.arch System Property returns the architecture used by the JVM
+ * not of the operating system.
+ * </p>
+ */
+public class ArchUtils {
+
+    private static Map<String, Processor> map;
+
+    static {
+        map = new HashMap<>();
+        init();
+    }
+
+    private static final void init() {
+        init_X86_32Bit();
+        init_X86_64Bit();
+        init_IA64_32Bit();
+        init_IA64_64Bit();
+        init_PPC_32Bit();
+        init_PPC_64Bit();
+    }
+
+    /**
+     * Adding x86 32 bit {@link Processor}'s to the map
+     */
+    private static final void init_X86_32Bit() {
+        Processor processor = new Processor(ProcessorArch.BIT_32, ProcessorType.X86);
+        addProcessors(processor, ""x86"", ""i386"", ""i486"", ""i586"", ""i686"", ""pentium"");
+    }
+
+    /**
+     * Adding x86 64 bit {@link Processor}'s to the map
+     */
+    private static final void init_X86_64Bit() {
+        Processor processor = new Processor(ProcessorArch.BIT_64, ProcessorType.X86);
+        addProcessors(processor, ""x86_64"", ""amd64"", ""em64t"", ""universal"");
+    }
+
+    /**
+     * Adding ia64 32 bit {@link Processor}'s to the map
+     */
+    private static final void init_IA64_32Bit() {
+        Processor processor = new Processor(ProcessorArch.BIT_32, ProcessorType.IA_64);
+        addProcessors(processor, ""ia64_32"", ""ia64n"");
+    }
+
+    /**
+     * Adding ia64 64 bit {@link Processor}'s to the map
+     */
+    private static final void init_IA64_64Bit() {
+        Processor processor = new Processor(ProcessorArch.BIT_64, ProcessorType.IA_64);
+        addProcessors(processor, ""ia64"", ""ia64w"");
+    }
+
+    /**
+     * Adding PPC 32 bit {@link Processor}'s to the map
+     */
+    private static final void init_PPC_32Bit() {
+        Processor processor = new Processor(ProcessorArch.BIT_32, ProcessorType.PPC);
+        addProcessors(processor, ""ppc"", ""power"", ""powerpc"", ""power_pc"", ""power_rs"");
+    }
+
+    /**
+     * Adding PPC 64 bit {@link Processor}'s to the map
+     */
+    private static final void init_PPC_64Bit() {
+        Processor processor = new Processor(ProcessorArch.BIT_64, ProcessorType.PPC);
+        addProcessors(processor, ""ppc64"", ""power64"", ""powerpc64"", ""power_pc64"", ""power_rs64"");
+    }
+
+    /**
+     * Adds the given {@link Processor} whith the given key {@link String} to the map.
+     *
+     * @param key The key as {@link String}.
+     * @param processor The {@link Processor} to add.
+     * @throws UnsupportedOperationException When key already exists in map.
+     */
+    private static final void addProcessor(String key, Processor processor) throws UnsupportedOperationException {
+        if (!map.containsKey(key)) {
+            map.put(key, processor);
+        } else {
+            String msg = ""Key "" + key + "" already exists in processor map"";
+            throw new UnsupportedOperationException(msg);","[{'comment': 'IllegalStateException might be better here', 'commenter': 'sebbASF'}]"
231,src/test/java/org/apache/commons/lang3/ArchUtilsTest.java,"@@ -0,0 +1,131 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.lang3;
+
+import org.apache.commons.lang3.arch.Processor;
+import org.apache.commons.lang3.arch.ProcessorArch;
+import org.junit.Test;
+
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertNotNull;
+
+/**
+ * Test class for {@link ArchUtils}.
+ *
+ * @author Tomschi
+ */
+public class ArchUtilsTest {
+
+    // x86
+    private static final String X86 = ""x86"";
+    private static final String X86_I386 = ""i386"";
+    private static final String X86_I486 = ""i486"";
+    private static final String X86_I586 = ""i586"";
+    private static final String X86_I686 = ""i686"";
+    private static final String X86_PENTIUM = ""pentium"";
+
+    // x86_64
+    private static final String X86_64 = ""x86_64"";
+    private static final String X86_64_AMD64 = ""amd64"";
+    private static final String X86_64_EM64T = ""em64t"";
+    private static final String X86_64_UNIVERSAL = ""universal"";
+
+    // IA64
+    private static final String IA64 = ""ia64"";
+    private static final String IA64W = ""ia64w"";
+
+    // IA64_32
+    private static final String IA64_32 = ""ia64_32"";
+    private static final String IA64N = ""ia64n"";
+
+    // PPC
+    private static final String PPC = ""ppc"";
+    private static final String POWER = ""power"";
+    private static final String POWERPC = ""powerpc"";
+    private static final String POWER_PC = ""power_pc"";
+    private static final String POWER_RS = ""power_rs"";
+
+    // PPC 64
+    private static final String PPC64 = ""ppc64"";
+    private static final String POWER64 = ""power64"";
+    private static final String POWERPC64 = ""powerpc64"";
+    private static final String POWER_PC64 = ""power_pc64"";
+    private static final String POWER_RS64 = ""power_rs64"";
+
+    @Test
+    public void testIs32BitJVM() {
+        Processor processor = ArchUtils.getProcessor(X86);
+        assertNotNull(processor);
+        assertTrue(ProcessorArch.BIT_32.equals(processor.getProcessorArch()));
+
+        processor = ArchUtils.getProcessor(IA64_32);
+        assertNotNull(processor);
+        assertTrue(ProcessorArch.BIT_32.equals(processor.getProcessorArch()));
+
+        processor = ArchUtils.getProcessor(PPC);
+        assertNotNull(processor);
+        assertTrue(ProcessorArch.BIT_32.equals(processor.getProcessorArch()));
+
+        processor = ArchUtils.getProcessor(X86_64);
+        assertNotNull(processor);
+        assertFalse(ProcessorArch.BIT_32.equals(processor.getProcessorArch()));
+
+        processor = ArchUtils.getProcessor(PPC64);
+        assertNotNull(processor);
+        assertFalse(ProcessorArch.BIT_32.equals(processor.getProcessorArch()));
+
+        processor = ArchUtils.getProcessor(IA64);
+        assertNotNull(processor);
+        assertFalse(ProcessorArch.BIT_32.equals(processor.getProcessorArch()));
+    }
+
+    @Test
+    public void testIs64BitJVM() {
+        Processor processor = ArchUtils.getProcessor(X86_64);
+        assertNotNull(processor);
+        assertTrue(ProcessorArch.BIT_64.equals(processor.getProcessorArch()));
+
+        processor = ArchUtils.getProcessor(PPC64);
+        assertNotNull(processor);
+        assertTrue(ProcessorArch.BIT_64.equals(processor.getProcessorArch()));
+
+        processor = ArchUtils.getProcessor(IA64);
+        assertNotNull(processor);
+        assertTrue(ProcessorArch.BIT_64.equals(processor.getProcessorArch()));
+
+        processor = ArchUtils.getProcessor(X86);
+        assertNotNull(processor);
+        assertFalse(ProcessorArch.BIT_64.equals(processor.getProcessorArch()));
+
+        processor = ArchUtils.getProcessor(PPC);
+        assertNotNull(processor);
+        assertFalse(ProcessorArch.BIT_64.equals(processor.getProcessorArch()));
+
+        processor = ArchUtils.getProcessor(IA64_32);
+        assertNotNull(processor);
+        assertFalse(ProcessorArch.BIT_64.equals(processor.getProcessorArch()));
+    }
+
+    @Test
+    public void testGetProcessor() {
+        assertNotNull(ArchUtils.getProcessor(X86));
+        assertNull(ArchUtils.getProcessor(""NA""));
+    }
+","[{'comment': 'There are no tests for Processor type.', 'commenter': 'sebbASF'}]"
296,src/main/java/org/apache/commons/lang3/time/FastTimeZone.java,"@@ -0,0 +1,90 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.lang3.time;
+
+import java.util.TimeZone;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+/**
+ * Faster methods to produce custom time zones.
+ *
+ * @since 3.7
+ */
+public class FastTimeZone {
+
+    private static final TimeZone GREENWICH = new GmtTimeZone(false, 0, 0);
+
+    /**
+     * Get the GMT TimeZone.
+     * @return A TimeZone with a raw offset of zero.
+     */
+    public static TimeZone getGmtTimeZone() {
+        return GREENWICH;
+    }
+
+    /**
+     * Get a TimeZone, looking first for GMT custom ids, then falling back to Olson ids.
+     * A GMT custom id has an optional prefix of GMT, followed by sign, hours digit(s), optional
+     * colon(':'), and optional minutes digits: <em>[GMT] (+|-) Hours [[:] Minutes]</em>
+     *
+     * @param id A GMT custom id or Olsen id
+     * @return A timezone
+     */
+    public static TimeZone getTimeZone(String id) {
+        TimeZone tz = getGmtTimeZone(id);
+        if (tz != null) {
+            return tz;
+        }
+        return TimeZone.getTimeZone(id);
+    }
+
+    private static final Pattern GMT_PATTERN = Pattern.compile(""^(?:(?i)GMT)?([+-])?(\\d\\d?)?(:?(\\d\\d?))?$"");
+
+    /**
+     * Get a TimeZone with GMT offsets.  A GMT offset must be either 'Z' or match
+     * (GMT)? hh?(:?mm?)?, where h and m are digits representing hours and minutes.","[{'comment': ""Maybe instead of\r\n\r\n> A GMT offset must be either 'Z' or match (GMT)? hh?(:?mm?)?\r\n\r\nIt should be\r\n\r\n> A GMT offset must be 'Z', or 'UTC', or match (GMT)? hh?(:?mm?)?\r\n\r\n?\r\n\r\n"", 'commenter': 'kinow'}, {'comment': 'done', 'commenter': 'chonton'}]"
296,src/main/java/org/apache/commons/lang3/time/FastTimeZone.java,"@@ -0,0 +1,90 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.lang3.time;
+
+import java.util.TimeZone;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+/**
+ * Faster methods to produce custom time zones.
+ *
+ * @since 3.7
+ */
+public class FastTimeZone {","[{'comment': ""Do we need a private constructor to prevent instantiation of FastTimeZone? It seems to contain only static methods. Not sure if that's the intended design. But noticed it while looking at the cobertura report (which is looking great)."", 'commenter': 'kinow'}, {'comment': 'done', 'commenter': 'chonton'}]"
296,src/main/java/org/apache/commons/lang3/time/GmtTimeZone.java,"@@ -0,0 +1,103 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.lang3.time;
+
+import java.util.Date;
+import java.util.TimeZone;
+
+/**
+ * Custom timezone that contains offset from GMT.
+ *
+ * @since 3.7
+ */
+class GmtTimeZone extends TimeZone {","[{'comment': 'TimeZone is Serializabe. Do we need to add a serialVersionUID here?', 'commenter': 'kinow'}, {'comment': 'great catch! done', 'commenter': 'chonton'}]"
296,src/test/java/org/apache/commons/lang3/time/GmtTimeZoneTest.java,"@@ -0,0 +1,80 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.lang3.time;
+
+import org.junit.Assert;
+import org.junit.Test;
+
+/**
+ * Tests for GmtTimeZone
+ */
+public class GmtTimeZoneTest {
+
+    @Test(expected = IllegalArgumentException.class)
+    public void hoursOutOfRange() {
+        new GmtTimeZone(false, 24, 0);
+    }
+
+    @Test
+    public void hoursInRange() {
+        Assert.assertEquals(23 * 60 * 60 * 1000, new GmtTimeZone(false, 23, 0).getRawOffset());
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void minutesOutOfRange() {
+        Assert.assertEquals(0, new GmtTimeZone(false, 60, 0));","[{'comment': 'This test is wrong. Its title states that the minutes will be out of range, but the hour is actually out of range (60). Minute is 0, but never gets checked.', 'commenter': 'kinow'}, {'comment': 'great catch! thanks.\r\ndone.', 'commenter': 'chonton'}]"
296,src/test/java/org/apache/commons/lang3/time/GmtTimeZoneTest.java,"@@ -0,0 +1,80 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.lang3.time;
+
+import org.junit.Assert;
+import org.junit.Test;
+
+/**
+ * Tests for GmtTimeZone
+ */
+public class GmtTimeZoneTest {
+
+    @Test(expected = IllegalArgumentException.class)
+    public void hoursOutOfRange() {
+        new GmtTimeZone(false, 24, 0);
+    }
+
+    @Test
+    public void hoursInRange() {
+        Assert.assertEquals(23 * 60 * 60 * 1000, new GmtTimeZone(false, 23, 0).getRawOffset());
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void minutesOutOfRange() {
+        Assert.assertEquals(0, new GmtTimeZone(false, 60, 0));
+    }
+
+    @Test
+    public void minutesInRange() {
+        Assert.assertEquals(59 * 60 * 1000, new GmtTimeZone(false, 0, 59).getRawOffset());
+    }
+
+    @Test
+    public void getOffset() {
+        Assert.assertEquals(0, new GmtTimeZone(false, 0, 0).getOffset(234304));
+    }
+
+    @Test(expected = UnsupportedOperationException.class)
+    public void setRawOffset() {
+        new GmtTimeZone(false, 0, 0).setRawOffset(0);
+    }
+
+    @Test
+    public void getRawOffset() {
+        Assert.assertEquals(0, new GmtTimeZone(false, 0, 0).getRawOffset());
+    }
+
+    @Test
+    public void getID() {
+        Assert.assertEquals(""GMT+00:00"", new GmtTimeZone(false, 0, 0).getID());
+        Assert.assertEquals(""GMT+01:02"", new GmtTimeZone(false, 1, 2).getID());
+        Assert.assertEquals(""GMT+11:22"", new GmtTimeZone(false, 11, 22).getID());
+        Assert.assertEquals(""GMT-01:02"", new GmtTimeZone(true, 1, 2).getID());
+        Assert.assertEquals(""GMT-11:22"", new GmtTimeZone(true, 11, 22).getID());
+    }
+
+    @Test
+    public void useDaylightTime() {
+        Assert.assertFalse(new GmtTimeZone(false, 0, 0).useDaylightTime());
+    }
+
+    @Test
+    public void inDaylightTime() {
+        Assert.assertFalse(new GmtTimeZone(false, 0, 0).useDaylightTime());
+    }","[{'comment': 'Maybe add something like\r\n\r\n```\r\n@Test\r\n    public void testToString() {\r\n        Assert.assertEquals(""[GmtTimeZone id=\\""GMT+23:00\\"",offset=82800000]"", new GmtTimeZone(false, 23, 0).toString());\r\n    }\r\n\r\n    @Test\r\n    public void testGetOffset() {\r\n        Assert.assertEquals(82800000, new GmtTimeZone(false, 23, 0).getOffset(1, 1, 1, 1, 1, 1));\r\n    }\r\n```\r\n\r\nWith these two tests we reach 100% for GmtTimeZone.', 'commenter': 'kinow'}, {'comment': 'done', 'commenter': 'chonton'}]"
296,src/main/java/org/apache/commons/lang3/time/FastTimeZone.java,"@@ -39,10 +43,11 @@ public static TimeZone getGmtTimeZone() {
 
     /**
      * Get a TimeZone, looking first for GMT custom ids, then falling back to Olson ids.
-     * A GMT custom id has an optional prefix of GMT, followed by sign, hours digit(s), optional
-     * colon(':'), and optional minutes digits: <em>[GMT] (+|-) Hours [[:] Minutes]</em>
+     * A GMT custom id can be 'Z', or 'UTC', or has an optional prefix of GMT,
+     * followed by sign, hours digit(s), optional colon(':'), and optional minutes digits.
+     * i.e. <em>[GMT] (+|-) Hours [[:] Minutes]</em>
      *
-     * @param id A GMT custom id or Olsen id
+     * @param id A GMT custom id (or Olson id","[{'comment': 'Nitpick: either a superfluous `(` or a missing `)`', 'commenter': 'PascalSchumacher'}]"
296,src/main/java/org/apache/commons/lang3/time/FastTimeZone.java,"@@ -0,0 +1,95 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.lang3.time;
+
+import java.util.TimeZone;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+/**
+ * Faster methods to produce custom time zones.
+ *
+ * @since 3.7
+ */
+public class FastTimeZone {
+
+    private static final TimeZone GREENWICH = new GmtTimeZone(false, 0, 0);
+
+    // do not instantiate
+    private FastTimeZone() {
+    }
+
+    /**
+     * Get the GMT TimeZone.
+     * @return A TimeZone with a raw offset of zero.
+     */
+    public static TimeZone getGmtTimeZone() {
+        return GREENWICH;
+    }
+
+    /**
+     * Get a TimeZone, looking first for GMT custom ids, then falling back to Olson ids.","[{'comment': 'In future patches, you can use the active voice for Javadocs: ""Gets a TimeZone..."" instead of ""Get..."". :-)', 'commenter': 'garydgregory'}]"
301,src/test/java/org/apache/commons/lang3/event/EventUtilsTest.java,"@@ -135,9 +129,9 @@ public void testBindFilteredEventsToMethod() {
         final EventCounter counter = new EventCounter();
         EventUtils.bindEventsToMethod(counter, ""eventOccurred"", src, MultipleEventListener.class, ""event1"");
         assertEquals(0, counter.getCount());
-        src.listeners.fire().event1(new PropertyChangeEvent(new Date(), ""Day"", Integer.valueOf(0), Integer.valueOf(1)));
+        src.listeners.fire().event1(new PropertyChangeEvent(new Date(), ""Day"", 0, 1));","[{'comment': 'We prefer explicit boxing of primitve values.', 'commenter': 'britter'}]"
311,src/main/java/org/apache/commons/lang3/time/StackWatch.java,"@@ -0,0 +1,329 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.commons.lang3.time;
+
+import java.util.Deque;
+import java.util.LinkedList;
+import org.apache.commons.lang3.StringUtils;
+
+/**
+ * <p>
+ * The {@code StackWatch}, provides a wrapper around the {@code StopWatch} for creating multiple and
+ * possibly nested named timings.
+ * </p>
+ * <p>
+ * While the {@code StopWatch} provides functionality to time the length of operations, there is no
+ * context or name to go with the time tracked. It is also not possible to time nested calls with
+ * the {@code StopWatch}.
+ * </p>
+ * <p>
+ * {@code StackWatch} provides that functionality, allowing successive calls to {@link StackWatch#startTiming(String, String...)} to track
+ * nested calls.
+ * </p>
+ * <p>
+ * Each start provides a timing name and a parent timing name, thus providing context to the timing.
+ * </p>
+ * <p>
+ * At the end of a timing 'run', a visitor interface provides the ability to visit all the timing
+ * 'nodes' and capture their output, including the level of the call if nested.
+ * </p>
+ * <p>
+ * The {@code TimeRecordNodes} provide a tree structure in support of nesting.
+ * A {@code Deque} is use to track the current time node.
+ * </p>
+ *
+ * <pre>
+ *   {@code
+ *    private void outerFunction() {
+ *      try {
+ *        StackWatch watch = new StackWatch(""OuterFunction"");
+ *        watch.start();
+ *        functionOne();
+ *        watch.stop();
+ *        watch.visit(new TimingRecordNodeVisitor() {
+ *          {@literal @}Override
+ *          public void visitRecord(int level, TimingRecordNode node) {
+ *            ...
+ *          }
+ *        });
+ *      } catch (Exception e){}
+ *    }
+ *    private void functionOne(StackWatch watch) throws Exception {
+ *      watch.startTiming(""One"", ""OneFunc"");
+ *      functionOneOne(watch);
+ *      watch.stopTiming();
+ *    }
+ *
+ *    private void functionOneOne(StackWatch watch) throws Exception {
+ *      watch.startTiming(""OneOne"", ""OneFunc"");
+ *      functionOneTwo(watch);
+ *      watch.stopTiming();
+ *    }
+ *
+ *    private void functionOneTwo(StackWatch watch) throws Exception {
+ *      watch.startTiming(""OneTwo"", ""OneFunc"");
+ *      watch.stopTiming();
+ *    }
+ *   }
+ * </pre>
+ *
+ *
+ * <p>
+ * This class is not thread safe, and is meant to track timings across multiple calls on the same
+ * thread
+ * </p>
+ */
+public class StackWatch {
+
+  /**
+   * The default name for the root level timing if not provided
+   */
+  public static final String DEFAULT_ROOT_NAME = ""ROOT_TIMING"";","[{'comment': 'Here is needs to be four spaced as well. You can look at another file and compare that (e.g. https://github.com/apache/commons-lang/blob/f50ec5e608286b0c48d6b9b4c792352de8353804/src/main/java/org/apache/commons/lang3/concurrent/AtomicSafeInitializer.java#L58).', 'commenter': 'kinow'}]"
311,src/main/java/org/apache/commons/lang3/time/TimingRecordNode.java,"@@ -0,0 +1,222 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.commons.lang3.time;
+
+import java.util.LinkedList;
+import java.util.List;
+import org.apache.commons.lang3.ArrayUtils;
+import org.apache.commons.lang3.StringUtils;
+
+/**
+ * The tree node to track time and children.
+ * The {@code StopWatch} class is used for timings
+ */
+public class TimingRecordNode {
+
+    /**
+     * The format String for creating paths.
+     */
+    private static final String PATH_FMT = ""%s/%s"";
+
+    /**
+     * This nodes parent's path.
+     */
+    private String parentTimingPath;
+
+    /**
+     * The name of this node.
+     */
+    private String timingName;
+
+    /**
+     * The tags associated with this timing.
+     */
+    private String[] tags;
+
+    /**
+     * The child nodes of this node.
+     */
+    private List<TimingRecordNode> children = new LinkedList<>();
+
+    /**
+     * The {@code StopWatch} for this node.
+     */
+    private StopWatch stopWatch = new StopWatch();
+
+    /**
+     * <p>
+     * Constructor.
+     * </p>
+     * <p>
+     * Creates a new TimingRecordNode for a given parent name, with a given name.
+     * </p>
+     *
+     * @param parentTimingPath the path of the parent, may be null
+     * @param timingName the name of the timing
+     * @param tags the tags to associate with this timing
+     * @throws IllegalArgumentException if the timingName is null or empty.
+     */
+    public TimingRecordNode(String parentTimingPath, String timingName, String... tags) {
+        if (StringUtils.isEmpty(timingName)) {
+            throw new IllegalArgumentException(""Argument name is missing"");
+        }
+        this.timingName = timingName;
+
+        if (StringUtils.isNotEmpty(parentTimingPath)) {
+            this.parentTimingPath = parentTimingPath;
+        }
+
+        this.tags = tags;
+    }
+
+    /**
+     * Returns the node's parent's path.
+     * The parent node path may be null
+     *
+     * @return the parent node path
+     */
+    public String getParentPath() {
+        return parentTimingPath;
+    }
+
+    /**
+     * Returns the node's timing name.
+     *
+     * @return the node timing name
+     */
+    public String getTimingName() {
+        return timingName;
+    }
+
+    /**
+     * Return if the node's StopWatch is running.
+     *
+     * @return true if it is running, false if not
+     */
+    public boolean isRunning() {
+        return stopWatch.isStarted();
+    }
+
+    /**
+     * Starts the StopWatch.
+     */
+    public void start() {
+        if (!stopWatch.isStarted()) {
+            stopWatch.start();
+        }
+    }
+
+    /**
+     * <p>
+     * Stops the StopWatch.
+     * </p>
+     * <p>
+     * If this node has running children, an {@code IllegalStateException} will result.
+     * </p>
+     *
+     * @throws IllegalStateException if stop is called on a node with running children
+     */
+    public void stop() {
+        for (TimingRecordNode child : children) {
+            if (child.isRunning()) {
+                throw new IllegalStateException(""Cannot stop a timing with running children"");
+            }
+        }
+        stopWatch.stop();
+    }
+
+    /**
+     * Returns the {@code StopWatch} for this node.
+     *
+     * @return {@code StopWatch}
+     */
+    public StopWatch getStopWatch() {
+        return stopWatch;
+    }
+
+    /**
+     * The tags associated with this timing.
+     *
+     * @return tags array
+     */
+    public String[] getTags() {
+        return tags == null ? new String[]{} : ArrayUtils.clone(tags);
+    }
+
+
+    /**
+     * Returns the node's path, made up by combining it's parent's name and the node's name.
+     * The path is '/' delimited.
+     * <p>
+     * If the parent path is null, then the name only is returned.
+     * </p>
+     *
+     * @return the path as String
+     */
+    public String getPath() {
+        if (parentTimingPath == null) {
+            return timingName;
+        }
+        return String.format(PATH_FMT, parentTimingPath, timingName);
+    }
+
+    /**
+     * Returns the child nodes of this node.
+     *
+     * @return Iterable of the child nodes.
+     */
+    public Iterable<TimingRecordNode> getChildren() {
+        return children;","[{'comment': ""Couldn't we return an read-only copy of the children here?"", 'commenter': 'kinow'}, {'comment': 'done.', 'commenter': 'ottobackwards'}]"
311,src/main/java/org/apache/commons/lang3/time/TimingRecordNode.java,"@@ -0,0 +1,222 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.commons.lang3.time;
+
+import java.util.LinkedList;
+import java.util.List;
+import org.apache.commons.lang3.ArrayUtils;
+import org.apache.commons.lang3.StringUtils;
+
+/**
+ * The tree node to track time and children.
+ * The {@code StopWatch} class is used for timings
+ */
+public class TimingRecordNode {
+
+    /**
+     * The format String for creating paths.
+     */
+    private static final String PATH_FMT = ""%s/%s"";
+
+    /**
+     * This nodes parent's path.
+     */
+    private String parentTimingPath;
+
+    /**
+     * The name of this node.
+     */
+    private String timingName;
+
+    /**
+     * The tags associated with this timing.
+     */
+    private String[] tags;
+
+    /**
+     * The child nodes of this node.
+     */
+    private List<TimingRecordNode> children = new LinkedList<>();","[{'comment': 'Would it make much difference if we used an `ArrayList` here? We seem to `#add` only in `createChild()`, and not sure if we are using any head/tail operation, nor inserting with indexes. So maybe having an `ArrayList` would give us the same functionality for less memory?', 'commenter': 'kinow'}, {'comment': 'good point', 'commenter': 'ottobackwards'}]"
340,src/main/java/org/apache/commons/lang3/StringUtils.java,"@@ -5596,8 +5596,8 @@ private static String replace(final String text, String searchString, final Stri
          }
          String searchText = text;
          if (ignoreCase) {
-             searchText = text.toLowerCase();
-             searchString = searchString.toLowerCase();
+             searchText = text.toUpperCase();
+             searchString = searchString.toUpperCase();","[{'comment': 'Just leaving a comment here too to have a review here in GitHub. While your example works, as the character is considered already in upper case, the reverse case would still fail after changing from `toLowerCase` to `toUpperCase`. So I think we should find another solution or update the documentation stating how the code works with unicode.', 'commenter': 'kinow'}, {'comment': ""Hi @kinow, yes you are right after I did try to come up with a draft java main to generate all || most unicode in string and compare it's length between original, toLowerCase() and to UpperCase().\r\n\r\n![image](https://user-images.githubusercontent.com/37996731/44028895-032488d4-9f2e-11e8-839b-c1259a182b8e.png)\r\n  \r\nIt's seem like no matter which one we pick (toLowerCase || toUpperCase), it would still tend to come up with a incorrect length.\r\n\r\nJust a quick question what you mean by remove the ```length( )``` mean? Would you mind to specify more on that? \r\n\r\nThanks, "", 'commenter': 'HiuKwok'}, {'comment': ""Oohh, great testing @HiuKwok ! Thanks for sharing here.\r\n\r\n>Just a quick question what you mean by remove the length( ) mean? Would you mind to specify more on that?\r\n\r\nSure. I think there could be a possibility to fix the issue by addressing how the length of the lower'ed/upper'ed text is used https://github.com/apache/commons-lang/blob/590f90889bf61a5570bd98b78e73410a07d7410b/src/main/java/org/apache/commons/lang3/StringUtils.java#L5603\r\n\r\nSo maybe there could be another way to work around the way we use the strings lengths, and avoid the exception."", 'commenter': 'kinow'}, {'comment': ""@kinow May be try to store a original text.length before perform any upper || lower case operation and make use of it?\r\n\r\nhaha, it's just a thought. Would try out later "", 'commenter': 'HiuKwok'}, {'comment': '@kinow It turn out the problem is large than that, because the incorrect length basically affecting the whole method, especially the part which involve parsing inside the while loop.\r\n\r\nhttps://github.com/apache/commons-lang/blob/590f90889bf61a5570bd98b78e73410a07d7410b/src/main/java/org/apache/commons/lang3/StringUtils.java#L5612-L5619\r\n\r\nWhile string like following is entered, then Exception would be thrown on here instead.\r\nhttps://github.com/apache/commons-lang/blob/590f90889bf61a5570bd98b78e73410a07d7410b/src/main/java/org/apache/commons/lang3/StringUtils.java#L5613\r\n\r\n![image](https://user-images.githubusercontent.com/37996731/44082531-137cb1a0-9fe4-11e8-9219-8f373aebce67.png)\r\n\r\n\r\n\r\n', 'commenter': 'HiuKwok'}, {'comment': 'Yeah, a very slippery problem. We still have the option to simply document that the method does not work well with unicode strings. \r\n\r\nBut first I would like to spend at least a few hours with paper and pencil (and eraser, because this could take a bit till I give up or find a possible way around it), and perhaps even check in the mailing list if other devs have any idea.\r\n\r\nI think you found a very interesting problem (*)! Keep the ideas coming if you have any on how to solve this issue :+1: \r\n\r\n_* if I had more time, I would possibly either go through other methods checking for that or, just try some fuzzifier approach to test the whole project ! Not aware of any static or dynamic analysis tool that does that_', 'commenter': 'kinow'}, {'comment': 'Hi all, Just a quick update finally I kind of figure the way out of this problem,\r\nwhile I am trying to make it happen (the implementation).\r\nBut the concept is mainly Normalize incoming word at the beginning of the method call by ```Normalizer.normalize()```\r\nIn this way the String.length() would return correct length even unicode is introduced and by having the correct String length, the original logic should function as normal ', 'commenter': 'HiuKwok'}]"
343,src/main/java/org/apache/commons/lang3/builder/EqualsBuilder.java,"@@ -25,10 +29,6 @@
 import java.util.List;
 import java.util.Set;
 
-import org.apache.commons.lang3.ArrayUtils;
-import org.apache.commons.lang3.ClassUtils;
-import org.apache.commons.lang3.tuple.Pair;
-","[{'comment': ""Please don't reorganize imports"", 'commenter': 'britter'}]"
343,src/main/java/org/apache/commons/lang3/builder/EqualsBuilder.java,"@@ -58,14 +58,17 @@
  *   }
  *   MyClass rhs = (MyClass) obj;
  *   return new EqualsBuilder()
- *                 .appendSuper(super.equals(obj))
  *                 .append(field1, rhs.field1)
  *                 .append(field2, rhs.field2)
  *                 .append(field3, rhs.field3)
  *                 .isEquals();
  *  }
  * </pre>
  *
+ * <p>
+ * If required, the superclass <code>appendSuper()</code> can be added using {@link #appendSuper}.","[{'comment': 'Better use a JavaDoc Link here: `{@link #appendSuper(boolean)}`', 'commenter': 'britter'}]"
343,src/main/java/org/apache/commons/lang3/builder/EqualsBuilder.java,"@@ -58,14 +58,17 @@
  *   }
  *   MyClass rhs = (MyClass) obj;
  *   return new EqualsBuilder()
- *                 .appendSuper(super.equals(obj))
  *                 .append(field1, rhs.field1)
  *                 .append(field2, rhs.field2)
  *                 .append(field3, rhs.field3)
  *                 .isEquals();
  *  }
  * </pre>
  *
+ * <p>
+ * If required, the superclass <code>appendSuper()</code> can be added using {@link #appendSuper}.
+ * </p>","[{'comment': 'The issues also suggested to add some documentation to `appendSuper(boolean)` making clear the implications of calling `super.equals(object)` when the class is a direct subclass ob `java.lang.Object`. I think we should add this.', 'commenter': 'britter'}]"
374,pom.xml,"@@ -543,6 +543,11 @@
       <artifactId>junit-vintage-engine</artifactId>
       <scope>test</scope>
     </dependency>
+    <dependency>
+      <groupId>org.junit-pioneer</groupId>
+      <artifactId>junit-pioneer</artifactId>
+      <version>0.2.0</version>","[{'comment': 'This dependency should have `test` scope.', 'commenter': 'PascalSchumacher'}, {'comment': 'Good catch, thanks.', 'commenter': 'mureinik'}]"
421,src/main/java/org/apache/commons/lang3/StringUtils.java,"@@ -3622,8 +3622,8 @@ public static String substringBetween(final String str, final String open, final
      * <pre>
      * StringUtils.splitPreserveAllTokens(null, *, *)            = null
      * StringUtils.splitPreserveAllTokens("""", *, *)              = []
-     * StringUtils.splitPreserveAllTokens(""ab de fg"", null, 0)   = [""ab"", ""cd"", ""ef""]
-     * StringUtils.splitPreserveAllTokens(""ab   de fg"", null, 0) = [""ab"", ""cd"", ""ef""]
+     * StringUtils.splitPreserveAllTokens(""ab de fg"", null, 0)   = [""ab"", ""de"", ""fg""]
+     * StringUtils.splitPreserveAllTokens(""ab   de fg"", null, 0) = [""ab"", ,"""", ""de"", ""fg""]","[{'comment': 'The first one matches what I got using the `master` branch. But the second example has a problem with the quotes? Supposed to be `[""ab"", """", """", ""de"", ""fg""]` I think.', 'commenter': 'kinow'}, {'comment': 'Yep, should be that.', 'commenter': 'ScaldingBlood'}]"
428,pom.xml,"@@ -658,7 +658,7 @@
           <source>${maven.compiler.source}</source>
           <quiet>true</quiet>
           <encoding>utf-8</encoding>
-          <docEncoding>utf-8</docEncoding>
+          <docencoding>utf-8</docencoding>","[{'comment': 'This parameter is pointless because it duplicates `project.reporting.outputEncoding`. So is `encoding` which even contrdicts `project.build.sourceEncoding`. Both must go away.', 'commenter': 'michael-o'}, {'comment': '@michael-o you mean we shall delete both `<encoding>utf-8</encoding>` and `<docEncoding>utf-8</docEncoding>` ?', 'commenter': 'XenoAmess'}, {'comment': 'Yes, this is my understand. The same issue is with commons parent. If someone else of the committers proves me something different. It is just dedundancy. @britter @bodewig what is your opinion?', 'commenter': 'michael-o'}, {'comment': '@kinow  Here is the content I mean.', 'commenter': 'XenoAmess'}]"
440,src/main/java/org/apache/commons/lang3/StringUtils.java,"@@ -6378,8 +6378,8 @@ private static String replace(final String text, String searchString, final Stri
          }
          final int replLength = searchString.length();
          int increase = replacement.length() - replLength;
-         increase = increase < 0 ? 0 : increase;
-         increase *= max < 0 ? 16 : max > 64 ? 64 : max;
+         increase = Math.max(increase, 0);
+         increase *= Math.min(max, 0);","[{'comment': 'How can this be correct when the bounds above are 16 and 64?', 'commenter': 'garydgregory'}, {'comment': ""That is a very good spot, not sure what happened here. I've fixed it now. Interesting that no tests picked it up."", 'commenter': 'ham1'}]"
440,RELEASE-NOTES.txt,"@@ -983,7 +983,7 @@ o LANG-462:  FastDateFormat supports parse methods.
 BUG FIXES
 ===========
 
-o LANG-932:  Spelling fixes. Thanks to Ville Skytt�.
+o LANG-932:  Spelling fixes. Thanks to Ville Skyttä.","[{'comment': 'Interesting issue with these special characters. But I think this file is generated automatically by a script during release, so it may be overridden later I guess? Someone else more familiar with the release process of lang can comment here I think', 'commenter': 'kinow'}, {'comment': 'I checked it and found that it should be because the project default encoding is ISO-8859-1. Github seems to use UTF-8 encoding by default to read the content and cause garbled characters.', 'commenter': 'Stzx'}]"
442,src/main/java/org/apache/commons/lang3/StringUtils.java,"@@ -3369,7 +3369,7 @@ public static boolean isAlphaSpace(final CharSequence cs) {
      * <p>Whitespace is defined by {@link Character#isWhitespace(char)}.</p>
      *
      * <pre>
-     * StringUtils.isAnyBlank((String) null)    = true
+     * StringUtils.isAnyBlank((String) null)    = false","[{'comment': 'I just tried `System.out.println(StringUtils.isAnyBlank((String) null));` using `master` branch and it printed `true`. Have you tried this code too?', 'commenter': 'kinow'}]"
442,src/main/java/org/apache/commons/lang3/StringUtils.java,"@@ -3402,7 +3402,7 @@ public static boolean isAnyBlank(final CharSequence... css) {
      * <p>Checks if any of the CharSequences are empty ("""") or null.</p>
      *
      * <pre>
-     * StringUtils.isAnyEmpty((String) null)    = true
+     * StringUtils.isAnyEmpty((String) null)    = false","[{'comment': 'Ditto above for me.', 'commenter': 'kinow'}]"
442,src/main/java/org/apache/commons/lang3/StringUtils.java,"@@ -3575,7 +3575,7 @@ public static boolean isMixedCase(final CharSequence cs) {
      * <p>Whitespace is defined by {@link Character#isWhitespace(char)}.</p>
      *
      * <pre>
-     * StringUtils.isNoneBlank((String) null)    = false
+     * StringUtils.isNoneBlank((String) null)    = true","[{'comment': 'This one gave me `false`, as before.', 'commenter': 'kinow'}]"
442,src/main/java/org/apache/commons/lang3/StringUtils.java,"@@ -3600,7 +3600,7 @@ public static boolean isNoneBlank(final CharSequence... css) {
      * <p>Checks if none of the CharSequences are empty ("""") or null.</p>
      *
      * <pre>
-     * StringUtils.isNoneEmpty((String) null)    = false
+     * StringUtils.isNoneEmpty((String) null)    = true","[{'comment': 'Same as this one, `false` not `true`.', 'commenter': 'kinow'}]"
446,src/main/java/org/apache/commons/lang3/ClassUtils.java,"@@ -16,19 +16,11 @@
  */
 package org.apache.commons.lang3;
 
+import org.apache.commons.lang3.mutable.MutableObject;
+
 import java.lang.reflect.Method;
 import java.lang.reflect.Modifier;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.Iterator;
-import java.util.LinkedHashSet;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-
-import org.apache.commons.lang3.mutable.MutableObject;
+import java.util.*;","[{'comment': ""This won't pass checkstyle I think. You will need to replace the `*` by explicit imports.\r\n\r\nSee Travis builds failing, this part is due to this change: \r\n\r\n>[ERROR] src/main/java/org/apache/commons/lang3/ClassUtils.java:[23] (imports) AvoidStarImport: Using the '.*' form of import should be avoided - java.util.*."", 'commenter': 'kinow'}, {'comment': ""This was the default IntelliJ setting to use * after more than 4 imports from the same package.\r\n\r\nI see no reason why not to use '*' in imports these days with such advanced editors, but in case that is the project standard, I comply. Thanks."", 'commenter': 'verhas'}]"
446,src/main/java/org/apache/commons/lang3/ClassUtils.java,"@@ -433,11 +432,13 @@ public static String getAbbreviatedName(final Class<?> cls, final int len) {
      * <tr><td>""java.lang.String""</td><td> 5</td><td>""j.l.String""</td></tr>
      * <tr><td>""java.lang.String""</td><td>15</td><td>""j.lang.String""</td></tr>
      * <tr><td>""java.lang.String""</td><td>30</td><td>""java.lang.String""</td></tr>
+     * <tr><td>""org.apache.commons.lang3.ClassUtils""</td><td>18</td><td>""o.a.c.l.ClassUtils""</td></tr>
      * </table>
      * @param className  the className to get the abbreviated name for, may be {@code null}
      * @param len  the desired length of the abbreviated name
-     * @return the abbreviated name or an empty string
-     * @throws IllegalArgumentException if len &lt;= 0
+     * @return the abbreviated name or an empty string if the specified
+     * class name is {@code null} or empty string
+     * @throws IllegalArgumentException if {@code len <= 0}","[{'comment': 'Thanks for updating the docs!', 'commenter': 'kinow'}]"
446,src/main/java/org/apache/commons/lang3/ClassUtils.java,"@@ -987,33 +1005,35 @@ public static boolean isAssignable(Class<?> cls, final Class<?> toClass, final b
 
     // Inner class
     // ----------------------------------------------------------------------
+
     /**
      * <p>Is the specified class an inner class or static nested class.</p>
      *
-     * @param cls  the class to check, may be null
+     * @param cls the class to check, may be null
      * @return {@code true} if the class is an inner or static nested class,
-     *  false if not or {@code null}
+     * false if not or {@code null}
      */
     public static boolean isInnerClass(final Class<?> cls) {
         return cls != null && cls.getEnclosingClass() != null;
     }
 
     // Class loading
     // ----------------------------------------------------------------------
+
     /**
      * Returns the class represented by {@code className} using the
      * {@code classLoader}.  This implementation supports the syntaxes
      * ""{@code java.util.Map.Entry[]}"", ""{@code java.util.Map$Entry[]}"",
      * ""{@code [Ljava.util.Map.Entry;}"", and ""{@code [Ljava.util.Map$Entry;}"".
      *
-     * @param classLoader  the class loader to use to load the class
-     * @param className  the class name
+     * @param classLoader the class loader to use to load the class
+     * @param className   the class name
      * @param initialize  whether the class must be initialized
      * @return the class represented by {@code className} using the {@code classLoader}
      * @throws ClassNotFoundException if the class is not found
      */
     public static Class<?> getClass(
-            final ClassLoader classLoader, final String className, final boolean initialize) throws ClassNotFoundException {
+        final ClassLoader classLoader, final String className, final boolean initialize) throws ClassNotFoundException {","[{'comment': 'I think now the PR has a lot more changes that are not related to LANG-1480. Are you able to undo formatting changes, and leave only the changes for the issue, please?', 'commenter': 'kinow'}, {'comment': 'I am doing it. Actually, these formattings are clumsy in the original code, and IntelliJ just reformatted automatically. I understand that it is no excuse for creating a messy PR. Sorry.', 'commenter': 'verhas'}]"
446,src/main/java/org/apache/commons/lang3/ClassUtils.java,"@@ -433,48 +440,82 @@ public static String getAbbreviatedName(final Class<?> cls, final int len) {
      * <tr><td>""java.lang.String""</td><td> 5</td><td>""j.l.String""</td></tr>
      * <tr><td>""java.lang.String""</td><td>15</td><td>""j.lang.String""</td></tr>
      * <tr><td>""java.lang.String""</td><td>30</td><td>""java.lang.String""</td></tr>
+     * <tr><td>""org.apache.commons.lang3.ClassUtils""</td><td>18</td><td>""o.a.c.l.ClassUtils""</td></tr>
      * </table>
-     * @param className  the className to get the abbreviated name for, may be {@code null}
-     * @param len  the desired length of the abbreviated name
-     * @return the abbreviated name or an empty string
-     * @throws IllegalArgumentException if len &lt;= 0
+     *
+     * @param className the className to get the abbreviated name for, may be {@code null}
+     * @param len       the desired length of the abbreviated name
+     * @return the abbreviated name or an empty string if the specified","[{'comment': 'Please specify if the result string is always <= len.', 'commenter': 'garydgregory'}, {'comment': 'It is not and it is described in detail in the above text. To be absolutely correct I added a half-sentence here as well.', 'commenter': 'verhas'}]"
446,src/main/java/org/apache/commons/lang3/ClassUtils.java,"@@ -424,7 +424,14 @@ public static String getAbbreviatedName(final Class<?> cls, final int len) {
      * significant loss of meaning.</p>
      * <p>The abbreviated class name will always include the complete package hierarchy.
      * If enough space is available, rightmost sub-packages will be displayed in full
-     * length.</p>
+     * length. The abbreviated package names will be shortened to a single character.</p>
+     * <p>Only package names are shortened, the class simple name remains untouched. (See examples.)</p>
+     * <p>The result will be longer than the desired length only if all the package names
+     * shortened to a single character plus the class simple name with the separating dots
+     * together are longer than the desired length. In other words, when the class name
+     * cannot be shortened to the desired length without significant loss of meaning.</p>
+     * <p>If the class name can be shortened without significant loss of meaning then","[{'comment': 'I do not think we should talk about ""loss of meaning"" as to me, abbreviating implies ""loss of meaning"" by design ;-) Just describe what it does. IMO a list would be better to describe the different use cases.', 'commenter': 'garydgregory'}]"
446,src/main/java/org/apache/commons/lang3/ClassUtils.java,"@@ -433,48 +440,82 @@ public static String getAbbreviatedName(final Class<?> cls, final int len) {
      * <tr><td>""java.lang.String""</td><td> 5</td><td>""j.l.String""</td></tr>
      * <tr><td>""java.lang.String""</td><td>15</td><td>""j.lang.String""</td></tr>
      * <tr><td>""java.lang.String""</td><td>30</td><td>""java.lang.String""</td></tr>
+     * <tr><td>""org.apache.commons.lang3.ClassUtils""</td><td>18</td><td>""o.a.c.l.ClassUtils""</td></tr>
      * </table>
-     * @param className  the className to get the abbreviated name for, may be {@code null}
-     * @param len  the desired length of the abbreviated name
-     * @return the abbreviated name or an empty string
-     * @throws IllegalArgumentException if len &lt;= 0
+     *
+     * @param className the className to get the abbreviated name for, may be {@code null}
+     * @param len       the desired length of the abbreviated name
+     * @return the abbreviated name or an empty string if the specified
+     * class name is {@code null} or empty string
+     * @throws IllegalArgumentException if {@code len <= 0}
      * @since 3.4
      */
     public static String getAbbreviatedName(final String className, final int len) {
-      if (len <= 0) {
-        throw new IllegalArgumentException(""len must be > 0"");
-      }
-      if (className == null) {
-        return StringUtils.EMPTY;
-      }
-
-      int availableSpace = len;
-      final int packageLevels = StringUtils.countMatches(className, '.');
-      final String[] output = new String[packageLevels + 1];
-      int endIndex = className.length() - 1;
-      for (int level = packageLevels; level >= 0; level--) {
-        final int startIndex = className.lastIndexOf('.', endIndex);
-        final String part = className.substring(startIndex + 1, endIndex + 1);
-        availableSpace -= part.length();
-        if (level > 0) {
-          // all elements except top level require an additional char space
-          availableSpace--;
+        if (len <= 0) {
+            throw new IllegalArgumentException(""len must be > 0"");
         }
-        if (level == packageLevels) {
-          // ClassName is always complete
-          output[level] = part;
-        } else {
-          if (availableSpace > 0) {
-            output[level] = part;
-          } else {
-            // if no space is left still the first char is used
-            output[level] = part.substring(0, 1);
-          }
+        if (className == null) {
+            return StringUtils.EMPTY;
         }
-        endIndex = startIndex - 1;
-      }
 
-      return StringUtils.join(output, '.');
+        final char[] abbreviated = className.toCharArray();
+        int target = 0;
+        int source = 0;
+        while (source < abbreviated.length) {
+            // copy the next part
+            int runAheadTarget = target;
+            while (source < abbreviated.length && abbreviated[source] != '.') {
+                abbreviated[runAheadTarget++] = abbreviated[source++];
+            }
+
+            ++target;
+            if (useFull(runAheadTarget, source, abbreviated.length, len)
+                || target > runAheadTarget) {
+                target = runAheadTarget;
+            }
+
+            // copy the '.' unless it was the last part
+            if (source < abbreviated.length) {
+                abbreviated[target++] = abbreviated[source++];
+            }
+        }
+        return new String(abbreviated, 0, target);
+    }
+
+    /**
+     * <p>Decides if the part that was just copied to its destination
+     * location in the work array can be kept as it was copied or must be
+     * abbreviated. It must be kept when the part is the last one, which
+     * is the simple name of the class. In this case the {@code source}
+     * index, from where the characters are copied points one position
+     * after the last character, a.k.a. {@code source ==
+     * originalLength}</p>
+     *
+     * <p>If the part is not the last one then it can be kept
+     * unabridged if the number of the characters copied so far plus
+     * the character that are to be copied is less than or equal to the
+     * desired length.</p>
+     *
+     * @param runAheadTarget the target index (where the characters were
+     *                       copied to) pointing after the last character
+     *                       copied when the current part was copied
+     * @param source         the source index (where the characters were
+     *                       copied from) pointing after the last
+     *                       character copied when the current part was
+     *                       copied
+     * @param originalLength the original length of the class full name,
+     *                       which is abbreviated
+     * @param desiredLength  the desired length of the abbreviated class
+     *                       name
+     * @return {@code true} if it can be kept in its original length
+     * {@code false} if the current part has to be abbreviated and
+     */
+    private static boolean useFull(final int runAheadTarget,","[{'comment': 'Is this only used once? If so, just in-line it with a `//` comment.', 'commenter': 'garydgregory'}, {'comment': 'Is this a strong requirement or something you can live with if I leave it as it is?\r\n\r\nAs you can see from the length of the comment this is a complex expression and the JavaDoc explains a lot about the algorithm used. Such an extensive commend would degrade the readability of the caller method.\r\n\r\nAs per the performance: the JIT will inline this method, it should not be a problem. ', 'commenter': 'verhas'}, {'comment': ""I'm ok to leave as it since the description is nice especially using `@param` tags which would end up in some non-standard format if documented with `//`s."", 'commenter': 'garydgregory'}, {'comment': 'Thanks', 'commenter': 'verhas'}]"
446,src/test/java/org/apache/commons/lang3/ClassUtilsTest.java,"@@ -47,7 +47,7 @@
  * Unit tests {@link org.apache.commons.lang3.ClassUtils}.
  */
 @SuppressWarnings(""boxing"") // JUnit4 does not support primitive equality testing apart from long
-public class ClassUtilsTest  {
+class ClassUtilsTest  {","[{'comment': ""Let's not change the visibility of test classes please."", 'commenter': 'garydgregory'}, {'comment': '@verhas ping.', 'commenter': 'garydgregory'}, {'comment': '@verhas ping.', 'commenter': 'garydgregory'}]"
446,src/main/java/org/apache/commons/lang3/ClassUtils.java,"@@ -433,48 +440,83 @@ public static String getAbbreviatedName(final Class<?> cls, final int len) {
      * <tr><td>""java.lang.String""</td><td> 5</td><td>""j.l.String""</td></tr>
      * <tr><td>""java.lang.String""</td><td>15</td><td>""j.lang.String""</td></tr>
      * <tr><td>""java.lang.String""</td><td>30</td><td>""java.lang.String""</td></tr>
+     * <tr><td>""org.apache.commons.lang3.ClassUtils""</td><td>18</td><td>""o.a.c.l.ClassUtils""</td></tr>
      * </table>
-     * @param className  the className to get the abbreviated name for, may be {@code null}
-     * @param len  the desired length of the abbreviated name
-     * @return the abbreviated name or an empty string
-     * @throws IllegalArgumentException if len &lt;= 0
+     *
+     * @param className the className to get the abbreviated name for, may be {@code null}
+     * @param len       the desired length of the abbreviated name
+     * @return the abbreviated name or an empty string if the specified
+     * class name is {@code null} or empty string. The abbreviated name may be
+     * longer than the desired length if it cannot be abbreviated to the desired length.
+     * @throws IllegalArgumentException if {@code len <= 0}
      * @since 3.4
      */
     public static String getAbbreviatedName(final String className, final int len) {
-      if (len <= 0) {
-        throw new IllegalArgumentException(""len must be > 0"");
-      }
-      if (className == null) {
-        return StringUtils.EMPTY;
-      }
-
-      int availableSpace = len;
-      final int packageLevels = StringUtils.countMatches(className, '.');
-      final String[] output = new String[packageLevels + 1];
-      int endIndex = className.length() - 1;
-      for (int level = packageLevels; level >= 0; level--) {
-        final int startIndex = className.lastIndexOf('.', endIndex);
-        final String part = className.substring(startIndex + 1, endIndex + 1);
-        availableSpace -= part.length();
-        if (level > 0) {
-          // all elements except top level require an additional char space
-          availableSpace--;
+        if (len <= 0) {
+            throw new IllegalArgumentException(""len must be > 0"");
         }
-        if (level == packageLevels) {
-          // ClassName is always complete
-          output[level] = part;
-        } else {
-          if (availableSpace > 0) {
-            output[level] = part;
-          } else {
-            // if no space is left still the first char is used
-            output[level] = part.substring(0, 1);
-          }
+        if (className == null) {
+            return StringUtils.EMPTY;
         }","[{'comment': 'I was expecting a short-circuit here when the length hint is greater or equal than the input string, then return the input string to avoid creating a new String.', 'commenter': 'garydgregory'}, {'comment': 'Makes sense.', 'commenter': 'verhas'}, {'comment': '@verhas Then please go ahead and update the code and add a test.', 'commenter': 'garydgregory'}]"
446,src/main/java/org/apache/commons/lang3/ClassUtils.java,"@@ -433,48 +440,83 @@ public static String getAbbreviatedName(final Class<?> cls, final int len) {
      * <tr><td>""java.lang.String""</td><td> 5</td><td>""j.l.String""</td></tr>
      * <tr><td>""java.lang.String""</td><td>15</td><td>""j.lang.String""</td></tr>
      * <tr><td>""java.lang.String""</td><td>30</td><td>""java.lang.String""</td></tr>
+     * <tr><td>""org.apache.commons.lang3.ClassUtils""</td><td>18</td><td>""o.a.c.l.ClassUtils""</td></tr>
      * </table>
-     * @param className  the className to get the abbreviated name for, may be {@code null}
-     * @param len  the desired length of the abbreviated name
-     * @return the abbreviated name or an empty string
-     * @throws IllegalArgumentException if len &lt;= 0
+     *
+     * @param className the className to get the abbreviated name for, may be {@code null}
+     * @param len       the desired length of the abbreviated name
+     * @return the abbreviated name or an empty string if the specified
+     * class name is {@code null} or empty string. The abbreviated name may be
+     * longer than the desired length if it cannot be abbreviated to the desired length.
+     * @throws IllegalArgumentException if {@code len <= 0}
      * @since 3.4
      */
     public static String getAbbreviatedName(final String className, final int len) {","[{'comment': 'I am starting to wonder if `len` would be better named `lengthHint` to make it clearer that this length is not a guarantee in any shape or form of the length of the returned string.', 'commenter': 'garydgregory'}, {'comment': 'I can live with that. Makes sense.', 'commenter': 'verhas'}, {'comment': '@verhas Then please go ahead and change it to `lengthHint`.', 'commenter': 'garydgregory'}]"
446,src/test/java/org/apache/commons/lang3/ClassUtilsTest.java,"@@ -160,26 +162,59 @@ public void test_getAbbreviatedName_Class() {
         assertEquals("""", ClassUtils.getAbbreviatedName((Class<?>) null, 1));
         assertEquals(""j.l.String"", ClassUtils.getAbbreviatedName(String.class, 1));
         assertEquals(""j.l.String"", ClassUtils.getAbbreviatedName(String.class, 5));
+        assertEquals(""o.a.c.l.ClassUtils"", ClassUtils.getAbbreviatedName(ClassUtils.class, 18));
         assertEquals(""j.lang.String"", ClassUtils.getAbbreviatedName(String.class, 13));
         assertEquals(""j.lang.String"", ClassUtils.getAbbreviatedName(String.class, 15));
         assertEquals(""java.lang.String"", ClassUtils.getAbbreviatedName(String.class, 20));
     }
 
+    /**
+     * Test that in case the required length is larger than the name and thus there is no need for any shortening
+     * then the returned string object is the same as the one passed as argument. Note, however, that this is
+     * tested as an internal implementation detail, but it is not a guaranteed feature of the implementation.
+     */
     @Test
-    public void test_getAbbreviatedName_Class_NegativeLen() {","[{'comment': ""Let's not change the visibility of test classes and methods please."", 'commenter': 'garydgregory'}]"
446,src/test/java/org/apache/commons/lang3/ClassUtilsTest.java,"@@ -160,26 +162,59 @@ public void test_getAbbreviatedName_Class() {
         assertEquals("""", ClassUtils.getAbbreviatedName((Class<?>) null, 1));
         assertEquals(""j.l.String"", ClassUtils.getAbbreviatedName(String.class, 1));
         assertEquals(""j.l.String"", ClassUtils.getAbbreviatedName(String.class, 5));
+        assertEquals(""o.a.c.l.ClassUtils"", ClassUtils.getAbbreviatedName(ClassUtils.class, 18));
         assertEquals(""j.lang.String"", ClassUtils.getAbbreviatedName(String.class, 13));
         assertEquals(""j.lang.String"", ClassUtils.getAbbreviatedName(String.class, 15));
         assertEquals(""java.lang.String"", ClassUtils.getAbbreviatedName(String.class, 20));
     }
 
+    /**
+     * Test that in case the required length is larger than the name and thus there is no need for any shortening
+     * then the returned string object is the same as the one passed as argument. Note, however, that this is
+     * tested as an internal implementation detail, but it is not a guaranteed feature of the implementation.
+     */
     @Test
-    public void test_getAbbreviatedName_Class_NegativeLen() {
+    @DisplayName(""When the length hint is longer than the actual length then the same String object is returned"")
+    void test_getAbbreviatedName_TooLongHint(){
+        final String className = ""java.lang.String"";
+        Assertions.assertSame(className, ClassUtils.getAbbreviatedName(className, className.length()+1));
+        Assertions.assertSame(className, ClassUtils.getAbbreviatedName(className, className.length()));
+    }
+
+    @Test
+    @DisplayName(""When the desired length is negative then exception is thrown"")
+    void test_getAbbreviatedName_Class_NegativeLen() {
         assertThrows(IllegalArgumentException.class, () -> ClassUtils.getAbbreviatedName(String.class, -10));
     }
 
     @Test
-    public void test_getAbbreviatedName_Class_ZeroLen() {","[{'comment': ""Let's not change the visibility of test classes and methods please."", 'commenter': 'garydgregory'}, {'comment': 'Sorry, but wrong addressee. This is not me, who has changed the visibility, but JUnit 5.', 'commenter': 'verhas'}]"
446,src/test/java/org/apache/commons/lang3/ClassUtilsTest.java,"@@ -160,26 +162,59 @@ public void test_getAbbreviatedName_Class() {
         assertEquals("""", ClassUtils.getAbbreviatedName((Class<?>) null, 1));
         assertEquals(""j.l.String"", ClassUtils.getAbbreviatedName(String.class, 1));
         assertEquals(""j.l.String"", ClassUtils.getAbbreviatedName(String.class, 5));
+        assertEquals(""o.a.c.l.ClassUtils"", ClassUtils.getAbbreviatedName(ClassUtils.class, 18));
         assertEquals(""j.lang.String"", ClassUtils.getAbbreviatedName(String.class, 13));
         assertEquals(""j.lang.String"", ClassUtils.getAbbreviatedName(String.class, 15));
         assertEquals(""java.lang.String"", ClassUtils.getAbbreviatedName(String.class, 20));
     }
 
+    /**
+     * Test that in case the required length is larger than the name and thus there is no need for any shortening
+     * then the returned string object is the same as the one passed as argument. Note, however, that this is
+     * tested as an internal implementation detail, but it is not a guaranteed feature of the implementation.
+     */
     @Test
-    public void test_getAbbreviatedName_Class_NegativeLen() {
+    @DisplayName(""When the length hint is longer than the actual length then the same String object is returned"")
+    void test_getAbbreviatedName_TooLongHint(){
+        final String className = ""java.lang.String"";
+        Assertions.assertSame(className, ClassUtils.getAbbreviatedName(className, className.length()+1));
+        Assertions.assertSame(className, ClassUtils.getAbbreviatedName(className, className.length()));
+    }
+
+    @Test
+    @DisplayName(""When the desired length is negative then exception is thrown"")
+    void test_getAbbreviatedName_Class_NegativeLen() {
         assertThrows(IllegalArgumentException.class, () -> ClassUtils.getAbbreviatedName(String.class, -10));
     }
 
     @Test
-    public void test_getAbbreviatedName_Class_ZeroLen() {
+    @DisplayName(""When the desired length is zero then exception is thrown"")
+    void test_getAbbreviatedName_Class_ZeroLen() {
         assertThrows(IllegalArgumentException.class, () -> ClassUtils.getAbbreviatedName(String.class, 0));
     }
 
     @Test
-    public void test_getAbbreviatedName_String() {","[{'comment': ""Let's not change the visibility of test classes and methods please."", 'commenter': 'garydgregory'}, {'comment': 'Why?\r\n\r\nSince the project uses JUnit 5 the required visibility is package private. Any access modifier is noise.', 'commenter': 'verhas'}]"
449,src/test/java/org/apache/commons/lang3/ClassUtilsTest.java,"@@ -513,20 +516,34 @@ public void test_getShortCanonicalName_Object() {
 
     @Test
     public void test_getShortCanonicalName_String() {
+        assertEquals("""", ClassUtils.getShortCanonicalName((String)null));
+        assertEquals(""Map.Entry"", ClassUtils.getShortCanonicalName(java.util.Map.Entry.class.getName()));
+        assertEquals(""Entry"", ClassUtils.getShortCanonicalName(java.util.Map.Entry.class.getCanonicalName()));
         assertEquals(""ClassUtils"", ClassUtils.getShortCanonicalName(""org.apache.commons.lang3.ClassUtils""));
         assertEquals(""ClassUtils[]"", ClassUtils.getShortCanonicalName(""[Lorg.apache.commons.lang3.ClassUtils;""));
         assertEquals(""ClassUtils[][]"", ClassUtils.getShortCanonicalName(""[[Lorg.apache.commons.lang3.ClassUtils;""));
         assertEquals(""ClassUtils[]"", ClassUtils.getShortCanonicalName(""org.apache.commons.lang3.ClassUtils[]""));
         assertEquals(""ClassUtils[][]"", ClassUtils.getShortCanonicalName(""org.apache.commons.lang3.ClassUtils[][]""));
         assertEquals(""int[]"", ClassUtils.getShortCanonicalName(""[I""));
+        assertEquals(""int[]"", ClassUtils.getShortCanonicalName(int[].class.getCanonicalName()));
+        assertEquals(""int[]"", ClassUtils.getShortCanonicalName(int[].class.getName()));
         assertEquals(""int[][]"", ClassUtils.getShortCanonicalName(""[[I""));
         assertEquals(""int[]"", ClassUtils.getShortCanonicalName(""int[]""));
         assertEquals(""int[][]"", ClassUtils.getShortCanonicalName(""int[][]""));
 
-        // Inner types
+        // this is to demonstrate that the documentation and the naming of the methods
+        // uses the class name and canonical name totally mixed up, which cannot be
+        // fixed without backward compatibility break
+        assertEquals(""int[]"", int[].class.getCanonicalName());
+        assertEquals(""[I"", int[].class.getName());
+
+        // Inner types... the problem is that these are not canonical names, classes with this name do not even have canonical name
         assertEquals(""ClassUtilsTest.6"", ClassUtils.getShortCanonicalName(""org.apache.commons.lang3.ClassUtilsTest$6""));
         assertEquals(""ClassUtilsTest.5Named"", ClassUtils.getShortCanonicalName(""org.apache.commons.lang3.ClassUtilsTest$5Named""));
         assertEquals(""ClassUtilsTest.Inner"", ClassUtils.getShortCanonicalName(""org.apache.commons.lang3.ClassUtilsTest$Inner""));
+        // demonstrating what a canonical name is... it is a bigger issue to clean this up
+        assertEquals(""org.apache.commons.lang3.ClassUtilsTest$10"", new org.apache.commons.lang3.ClassUtilsTest(){}.getClass().getName());","[{'comment': 'The addition of the inner class will cause the compilation identifier InnerClassName to move backwards. You need to modify\r\n\r\n```\r\n        assertEquals(""ClassUtilsTest.10"", ClassUtils.getShortClassName(new Object() {\r\n            // empty\r\n        }.getClass()));\r\n```\r\nto\r\n```\r\n        assertEquals(""ClassUtilsTest.12"", ClassUtils.getShortClassName(new Object() {\r\n            // empty\r\n        }.getClass()));\r\n```\r\n\r\nand\r\n\r\n```\r\n        assertEquals(""ClassUtilsTest.11"", ClassUtils.getShortClassName(new Object() {\r\n            // empty\r\n        }, ""<null>""));\r\n```\r\nto\r\n```\r\n        assertEquals(""ClassUtilsTest.13"", ClassUtils.getShortClassName(new Object() {\r\n            // empty\r\n        }, ""<null>""));\r\n```\r\n\r\nAnd adding warning notes like [487 lines](https://github.com/apache/commons-lang/blob/479d2c85083fd127b2d4fcfbf184267c76275350/src/test/java/org/apache/commons/lang3/ClassUtilsTest.java#L487).', 'commenter': 'Stzx'}, {'comment': 'done as requested', 'commenter': 'verhas'}]"
451,src/main/java/org/apache/commons/lang3/builder/DiffResult.java,"@@ -88,6 +88,22 @@
         }
     }
 
+    /**
+     * <p>Return the object the right object has been compared to</p>","[{'comment': '- You do not need to use p tags for the first sentence of a Javadoc comment IIRC. \r\n- A sentence should end in a period.\r\n- Use ""Gets ..."" instead of ""Return ...""\r\n- New public APIs should carry an `@since` tag.\r\n', 'commenter': 'garydgregory'}, {'comment': 'thanks @garydgregory \r\nActually I saw all javadoc comments had a `<p>` tag and other getters are introduced with `Returns` so I tried to stay consistent with them ... should I change it ? \r\n\r\nWhich version should I put in the `@since` tag ?', 'commenter': '0x6e69636f'}, {'comment': 'Also maybe I could call the getters `getLeft` and `getRight` ... seems more readable, what do you think ?', 'commenter': '0x6e69636f'}, {'comment': '@nicolasbd\r\nYes, please use `getLeft` and `getRight`, much better!', 'commenter': 'garydgregory'}, {'comment': '@garydgregory ok cool, but what about the `@since` tag ? which number should I set it to ? `4` ? `3.10` ? `3.9.4` ?', 'commenter': '0x6e69636f'}, {'comment': '3.10\r\n', 'commenter': 'garydgregory'}, {'comment': 'Ok @garydgregory , made the changes except for p tags for consistency with other javadocs comments', 'commenter': '0x6e69636f'}]"
451,src/main/java/org/apache/commons/lang3/builder/DiffResult.java,"@@ -88,6 +88,24 @@
         }
     }
 
+    /**
+     * <p>Gets the object the right object has been compared to.</p>
+     * @since 3.10
+     * @return the left object of the diff
+     */
+    public Object getLeft() {
+        return this.lhs;
+    }
+
+    /**
+     * <p>Gets the object the left object has been compared to.</p>
+     * @ 3.10","[{'comment': 'Nope :-( Use `@since` not `@`. Also, `@since` should be the _last_ tag.', 'commenter': 'garydgregory'}, {'comment': 'damn\' sorry for the typo, ok for putting it in last\r\nalso got back to ""Returns"" for consistency with other Javadocs comments', 'commenter': '0x6e69636f'}]"
466,src/main/java/org/apache/commons/lang3/Functions.java,"@@ -491,9 +491,27 @@ public static void tryWithResources(FailableRunnable<? extends Throwable> pActio
     }
 
     /**
-     * Rethrows a {@link Throwable} as an unchecked exception.
-     * @param pThrowable The throwable to rethrow
-     * @return Never returns anything, this method never terminates normally
+     * <p>Rethrow a {@link Throwable} as an unchecked exception. If the argument is
+     * already unchecked, namely a {@code RuntimeException} or {@code Error} then
+     * the argument will be rethrown without modification. If the exception is
+     * {@code IOException} then it will be enveloped into a {@code UncheckedIOException}.
+     * In every other cases the exception will be enveloped into a {@code","[{'comment': '""enveloped"" -> The term ""wrapped"" is a more standard term IMO.', 'commenter': 'garydgregory'}]"
466,src/main/java/org/apache/commons/lang3/Functions.java,"@@ -491,9 +491,27 @@ public static void tryWithResources(FailableRunnable<? extends Throwable> pActio
     }
 
     /**
-     * Rethrows a {@link Throwable} as an unchecked exception.
-     * @param pThrowable The throwable to rethrow
-     * @return Never returns anything, this method never terminates normally
+     * <p>Rethrow a {@link Throwable} as an unchecked exception. If the argument is
+     * already unchecked, namely a {@code RuntimeException} or {@code Error} then
+     * the argument will be rethrown without modification. If the exception is
+     * {@code IOException} then it will be enveloped into a {@code UncheckedIOException}.
+     * In every other cases the exception will be enveloped into a {@code
+     * UndeclaredThrowableException}</p>
+     *
+     * <p>Note that there is a declared return type for this method, even though it
+     * never returns. The reason for that is to support the usual pattern:</p>
+     *
+     * <pre>{@code
+     *      throw rethrow(myUncheckedException);
+     * }</pre>
+     *
+     * <p>instead of just calling the method. This pattern helps the Java compiler to","[{'comment': '""help"" is not unlikely to be guaranteed, it might be safer to say ""may help"".', 'commenter': 'garydgregory'}, {'comment': 'I do not mind changing the wording and I have done.', 'commenter': 'verhas'}]"
466,src/main/java/org/apache/commons/lang3/Functions.java,"@@ -491,9 +491,27 @@ public static void tryWithResources(FailableRunnable<? extends Throwable> pActio
     }
 
     /**
-     * Rethrows a {@link Throwable} as an unchecked exception.
-     * @param pThrowable The throwable to rethrow
-     * @return Never returns anything, this method never terminates normally
+     * <p>Rethrow a {@link Throwable} as an unchecked exception. If the argument is","[{'comment': 'In general, Javadocs always start with ""Gets"", not ""Get"", ""Returns"", not ""Return"", and so on; so here let\'s keep ""Rethrows"", and not change to ""Rethrow"" SVP.', 'commenter': 'garydgregory'}]"
466,src/main/java/org/apache/commons/lang3/Functions.java,"@@ -491,9 +491,27 @@ public static void tryWithResources(FailableRunnable<? extends Throwable> pActio
     }
 
     /**
-     * Rethrows a {@link Throwable} as an unchecked exception.
-     * @param pThrowable The throwable to rethrow
-     * @return Never returns anything, this method never terminates normally
+     * <p>Rethrow a {@link Throwable} as an unchecked exception. If the argument is
+     * already unchecked, namely a {@code RuntimeException} or {@code Error} then
+     * the argument will be rethrown without modification. If the exception is
+     * {@code IOException} then it will be wrapped into a {@code UncheckedIOException}.
+     * In every other cases the exception will be wrapped into a {@code
+     * UndeclaredThrowableException}</p>
+     *
+     * <p>Note that there is a declared return type for this method, even though it
+     * never returns. The reason for that is to support the usual pattern:</p>
+     *
+     * <pre>{@code","[{'comment': 'The pre tag is enough, there is no need to use the {code ...} within it. ', 'commenter': 'garydgregory'}, {'comment': 'It is just a habit and a bit safer for later modification. But I am not insisting it to keep.\r\n\r\nThe difference is that you can use < and > characters instead of their escape sequence if there is the `{@code ...}` also. I have learned this from the JDK source where it is used many times. In this case there is no need. I will remove it.', 'commenter': 'verhas'}]"
470,src/main/java/org/apache/commons/lang3/ArrayUtils.java,"@@ -4803,7 +4803,7 @@ public static Object toPrimitive(final Object array) {
         }
         final boolean[] result = new boolean[array.length];
         for (int i = 0; i < array.length; i++) {
-            result[i] = array[i].booleanValue();
+            result[i] = array[i];","[{'comment': 'This is included here because it is directly invoked from `BooleanUtils`. There are other similar redundant unboxings in this class in addition to this.', 'commenter': 'verhas'}]"
470,src/main/java/org/apache/commons/lang3/ArrayUtils.java,"@@ -4609,17 +4609,8 @@ public static int lastIndexOf(final short[] array, final short valueToFind, int
      * (index &lt; 0 || index &gt;= array.length), or if the array is {@code null}.
      * @since 2.1
      */
-    public static boolean[] toPrimitive(final Boolean[] array) {","[{'comment': 'You cannot delete public APIs, that breaks binary compatibility within a major release.', 'commenter': 'garydgregory'}, {'comment': 'I think you were looking at some outdated version of the request.\r\n\r\nThis method starts on the line 8886 in the current pull request and also on the current master.\r\n\r\nThe other possibility that I am totally missing something. One thing is for sure: I would never intentionally suggest the deletion or change of an API method.\r\n\r\nCould you have a look at it again?', 'commenter': 'verhas'}]"
471,src/main/java/org/apache/commons/lang3/ArrayUtils.java,"@@ -3254,6 +3254,57 @@ public static int indexOf(final Object[] array, final Object objectToFind, int s
         return INDEX_NOT_FOUND;
     }
 
+    /**
+     * <p>Finds the indices of the given object in the array.
+     *
+     * <p>This method returns an empty BitSet for a {@code null} input array.
+     *
+     * @param array  the array to search through for the object, may be {@code null}
+     * @param objectToFind  the object to find, may be {@code null}
+     * @return a BitSet of all the indices of the object within the array,
+     *  an empty BitSet if not found or {@code null} array input","[{'comment': '`@since` tag should be provided for newly provided methods.', 'commenter': 'Stzx'}, {'comment': 'Okay, which version? 4.0?', 'commenter': 'lielfr'}, {'comment': 'The next version is `3.10`.', 'commenter': 'Stzx'}, {'comment': 'Done', 'commenter': 'lielfr'}]"
471,src/main/java/org/apache/commons/lang3/ArrayUtils.java,"@@ -8202,20 +8654,8 @@ public static boolean isSorted(final boolean[] array) {
      * @since 3.5
      */
     public static float[] removeAllOccurences(final float[] array, final float element) {
-        int index = indexOf(array, element);
-        if (index == INDEX_NOT_FOUND) {
-            return clone(array);
-        }
-
-        final int[] indices = new int[array.length - index];
-        indices[0] = index;
-        int count = 1;
-
-        while ((index = indexOf(array, element, indices[count - 1] + 1)) != INDEX_NOT_FOUND) {
-            indices[count++] = index;
-        }
-
-        return removeAll(array, Arrays.copyOf(indices, count));
+        BitSet foundBits = indexesOf(array, element);","[{'comment': ""How about inlining all of the 'foundBits'?"", 'commenter': 'garydgregory'}, {'comment': 'Done', 'commenter': 'lielfr'}]"
471,src/main/java/org/apache/commons/lang3/ArrayUtils.java,"@@ -3254,6 +3254,59 @@ public static int indexOf(final Object[] array, final Object objectToFind, int s
         return INDEX_NOT_FOUND;
     }
 
+    /**
+     * <p>Finds the indices of the given object in the array.
+     *
+     * <p>This method returns an empty BitSet for a {@code null} input array.
+     *
+     * @param array  the array to search through for the object, may be {@code null}
+     * @param objectToFind  the object to find, may be {@code null}
+     * @return a BitSet of all the indices of the object within the array,
+     *  an empty BitSet if not found or {@code null} array input
+     * @since 3.10
+     */
+    public static BitSet indexesOf(final Object[] array, final Object objectToFind) {
+        return indexesOf(array, objectToFind, 0);
+    }
+
+    /**
+     * <p>Finds the indices of the given object in the array starting at the given index.
+     *
+     * <p>This method returns an empty BitSet for a {@code null} input array.
+     *
+     * <p>A negative startIndex is treated as zero. A startIndex larger than the array
+     * length will return an empty BitSet.
+     *
+     * @param array  the array to search through for the object, may be {@code null}
+     * @param objectToFind  the object to find, may be {@code null}
+     * @param startIndex  the index to start searching at
+     * @return a BitSet of all the indices of the object within the array starting at the index,
+     *  an empty BitSet if not found or {@code null} array input
+     * @since 3.10
+     */
+    public static BitSet indexesOf(final Object[] array, final Object objectToFind, int startIndex) {
+        BitSet ret = new BitSet();","[{'comment': 'It seems to me ""ret"" is not a great name, how about ""bitSet""?', 'commenter': 'garydgregory'}, {'comment': 'Done', 'commenter': 'lielfr'}]"
471,src/main/java/org/apache/commons/lang3/ArrayUtils.java,"@@ -3254,6 +3254,59 @@ public static int indexOf(final Object[] array, final Object objectToFind, int s
         return INDEX_NOT_FOUND;
     }
 
+    /**
+     * <p>Finds the indices of the given object in the array.","[{'comment': 'Oops, I did not notice before that you did not close any of these HTML tags. You need to close paragraphs. The first sentence in a Javadoc does _not_ need to be in a paragraph, Javadoc will do that for you.', 'commenter': 'garydgregory'}, {'comment': '@garydgregory Fixed. Apparently this is a problem with other functions too', 'commenter': 'lielfr'}]"
472,src/test/java/org/apache/commons/lang3/ArrayUtilsTest.java,"@@ -264,6 +266,31 @@ public int hashCode() {
             }
         }});
         assertEquals(""bar"", map.get(""foo""));
+
+        // Return empty map when got input array with length = 0
+        assertEquals(Collections.emptyMap(), ArrayUtils.toMap(new Object[0]));
+
+        // Test all null values
+        map = ArrayUtils.toMap(new Object[][] { {null, null}, {null, null} });
+        assertEquals(new HashMap<Object, Object>() {","[{'comment': 'Your expected map creation is too obtuse IMO, use the what Java provides instead:\r\n```\r\nCollections.singletonMap(null, null);\r\n```', 'commenter': 'garydgregory'}, {'comment': 'Fixed. Thanks', 'commenter': 'apirom9'}]"
472,src/test/java/org/apache/commons/lang3/ArrayUtilsTest.java,"@@ -264,6 +266,31 @@ public int hashCode() {
             }
         }});
         assertEquals(""bar"", map.get(""foo""));
+
+        // Return empty map when got input array with length = 0
+        assertEquals(Collections.emptyMap(), ArrayUtils.toMap(new Object[0]));
+
+        // Test all null values
+        map = ArrayUtils.toMap(new Object[][] { {null, null}, {null, null} });
+        assertEquals(new HashMap<Object, Object>() {
+
+            private static final long serialVersionUID = 1L;
+
+            {
+                put(null, null);
+            }
+        }, map);
+
+        // Test duplicate keys
+        map = ArrayUtils.toMap(new Object[][] { {""key"", ""value2""}, {""key"", ""value1""} });
+        assertEquals(new HashMap<Object, Object>() {
+
+            private static final long serialVersionUID = 1L;","[{'comment': 'See my previous comment.', 'commenter': 'garydgregory'}, {'comment': 'Fixed. Thanks', 'commenter': 'apirom9'}]"
475,src/main/java/org/apache/commons/lang3/EnumUtils.java,"@@ -119,13 +119,29 @@ public EnumUtils() {
      * @return the enum, null if not found
      */
     public static <E extends Enum<E>> E getEnum(final Class<E> enumClass, final String enumName) {
+        return getEnum(enumClass, enumName, null);
+    }
+
+    /**
+     * <p>Gets the enum for the class, returning {@code defaultEnum} if not found.</p>
+     *
+     * <p>This method differs from {@link Enum#valueOf} in that it does not throw an exception
+     * for an invalid enum name.</p>
+     *
+     * @param <E> the type of the enumeration
+     * @param enumClass   the class of the enum to query, not null
+     * @param enumName    the enum name, null returns default enum
+     * @param defaultEnum the default enum
+     * @return the enum, default enum if not found","[{'comment': 'Provide a `@since` tag for the new method.', 'commenter': 'Stzx'}, {'comment': '@Stzx, may I know what version number should I put ?', 'commenter': 'vlcheong'}, {'comment': '`3.10` :)', 'commenter': 'Stzx'}, {'comment': '@Stzx, Thanks for your guidance.', 'commenter': 'vlcheong'}]"
477,src/main/java/org/apache/commons/lang3/StringUtils.java,"@@ -332,10 +331,13 @@ public static String abbreviate(final String str, final String abbrevMarker, fin
      * @since 3.6
      */
     public static String abbreviate(final String str, final String abbrevMarker, int offset, final int maxWidth) {
-        if (isEmpty(str) || isEmpty(abbrevMarker)) {
+        if (isEmpty(str) && isEmpty(abbrevMarker)) {
+            return str;
+        } else if (isNotEmpty(str) && """".equals(abbrevMarker) && maxWidth>0) {","[{'comment': 'No magic strings, this class defines `EMPTY` for this purpose. You are missing spaces around `>`', 'commenter': 'garydgregory'}, {'comment': ""I added the spaces. What are you implying about the magic strings? Forgive me, I'm not as experienced of a programmer."", 'commenter': 'bbeckercscc'}, {'comment': 'A ""magic"" string or number is a value that is hard-coded, as opposed to reusing a constant, in this case, `EMPTY` instead of `""""`.', 'commenter': 'garydgregory'}, {'comment': 'Thanks for the explanation, I removed the magic string', 'commenter': 'bbeckercscc'}]"
491,src/main/java/org/apache/commons/lang3/ObjectUtils.java,"@@ -16,6 +16,10 @@
  */
 package org.apache.commons.lang3;
 
+import org.apache.commons.lang3.exception.CloneFailedException;","[{'comment': 'these are not removed anyway (just optimized by an IDE maybe?)', 'commenter': 'namannigam-zz'}]"
496,src/main/java/org/apache/commons/lang3/StringUtils.java,"@@ -9508,20 +9514,27 @@ public static String wrapIfMissing(final String str, final char wrapWith) {
      * @param str
      *            the string to be wrapped, may be {@code null}
      * @param wrapWith
-     *            the char that will wrap {@code str}
+     *            the string that will wrap {@code str}
      * @return the wrapped string, or {@code null} if {@code str==null}
      * @since 3.5
      */
     public static String wrapIfMissing(final String str, final String wrapWith) {
         if (isEmpty(str) || isEmpty(wrapWith)) {
             return str;
         }
+        
+        final boolean wrapStart = !str.startsWith(wrapWith);
+        final boolean wrapEnd = !str.endsWith(wrapWith);
+        if (!wrapStart && !wrapEnd) {
+            return str;
+        }
+        
         final StringBuilder builder = new StringBuilder(str.length() + wrapWith.length() + wrapWith.length());","[{'comment': ""I don't know if there is a practical reason to create `StringBuilder` with exact capacity, because it `str` can start with `wrapWith` but not end with it and vice versa."", 'commenter': 'nstdio'}, {'comment': 'Yeah, looks like this is the maximum capacity, not necessarily the exact capacity we expect to have. Probably harmless/fine?', 'commenter': 'kinow'}, {'comment': 'Since the behavior has changed, I would expect a clarification in the Javadoc. Plus a matching test.', 'commenter': 'garydgregory'}, {'comment': '@garydgregory Sure, that makes sense. Done.', 'commenter': 'nstdio'}]"
518,src/main/java/org/apache/commons/lang3/exception/ExceptionUtils.java,"@@ -810,7 +810,7 @@ public static void removeCommonFrames(final List<String> causeFrames, final List
      * @param <T> the type of Throwable you are searching.
      * @param throwable  the throwable to inspect, may be null
      * @param clazz  the class to search for, subclasses do not match, null returns null
-     * @return the index into the throwable chain, null if no match or null input
+     * @return the first matching throwable form the throwable chain, null if no match or null input","[{'comment': 's/form/from?', 'commenter': 'kinow'}, {'comment': 'Hi @kinow,\r\nfixed the typo. Thanks for spotting it :-)', 'commenter': 'arend-von-reinersdorff'}]"
518,src/main/java/org/apache/commons/lang3/exception/ExceptionUtils.java,"@@ -835,7 +835,7 @@ public static void removeCommonFrames(final List<String> causeFrames, final List
      * @param clazz  the class to search for, subclasses do not match, null returns null
      * @param fromIndex  the (zero-based) index of the starting position,
      *  negative treated as zero, larger than chain size returns null
-     * @return the index into the throwable chain, null if no match or null input
+     * @return the first matching throwable form the throwable chain, null if no match or null input","[{'comment': 's/form/from?', 'commenter': 'kinow'}]"
518,src/main/java/org/apache/commons/lang3/exception/ExceptionUtils.java,"@@ -855,7 +855,7 @@ public static void removeCommonFrames(final List<String> causeFrames, final List
      * @param <T> the type of Throwable you are searching.
      * @param throwable  the throwable to inspect, may be null
      * @param type  the type to search for, subclasses match, null returns null
-     * @return the index into the throwable chain, null if no match or null input
+     * @return the first matching throwable form the throwable chain, null if no match or null input","[{'comment': 's/form/from?', 'commenter': 'kinow'}]"
518,src/main/java/org/apache/commons/lang3/exception/ExceptionUtils.java,"@@ -880,7 +880,7 @@ public static void removeCommonFrames(final List<String> causeFrames, final List
      * @param type  the type to search for, subclasses match, null returns null
      * @param fromIndex  the (zero-based) index of the starting position,
      *  negative treated as zero, larger than chain size returns null
-     * @return the index into the throwable chain, null if no match or null input
+     * @return the first matching throwable form the throwable chain, null if no match or null input","[{'comment': 's/form/from?', 'commenter': 'kinow'}]"
521,src/main/java/org/apache/commons/lang3/StringUtils.java,"@@ -330,11 +330,9 @@ public static String abbreviate(final String str, final String abbrevMarker, fin
      * @since 3.6
      */
     public static String abbreviate(final String str, final String abbrevMarker, int offset, final int maxWidth) {
-        if (isEmpty(str) && isEmpty(abbrevMarker)) {
-            return str;
-        } else if (isNotEmpty(str) && EMPTY.equals(abbrevMarker) && maxWidth > 0) {
-            return str.substring(0, maxWidth);
-        } else if (isEmpty(str) || isEmpty(abbrevMarker)) {
+        if (isNotEmpty(str) && EMPTY.equals(abbrevMarker) && maxWidth > 0) {","[{'comment': 'How about `EMPTY.equals(abbrevMarker)` -> `isEmpty(abbrevMarker)` ?', 'commenter': 'garydgregory'}, {'comment': 'That change would mean that `abbrevMarker` is potentially null, according to SonarLint.', 'commenter': 'Isira-Seneviratne'}, {'comment': '@Isira-Seneviratne You are correct!', 'commenter': 'garydgregory'}]"
522,src/main/java/org/apache/commons/lang3/ObjectUtils.java,"@@ -277,6 +277,33 @@ public static boolean isNotEmpty(final Object object) {
         return object != null ? object : defaultSupplier == null ? null : defaultSupplier.get();
     }
 
+    /**
+     * Checks if any value in the given array is {@code null}.
+     *
+     * <p>
+     * If all the values are {@code null} or the array is {@code null}
+     * or empty, then {@code true} is returned, otherwise {@code false} is returned.
+     * </p>
+     *
+     * <pre>
+     * ObjectUtils.anyNull(*)                = false
+     * ObjectUtils.anyNull(*, null)          = false
+     * ObjectUtils.anyNull(null, *)          = false
+     * ObjectUtils.anyNull(null, null, *, *) = false
+     * ObjectUtils.anyNull(null)             = true
+     * ObjectUtils.anyNull(null, null)       = true
+     * </pre>
+     *
+     * @param values  the values to test, may be {@code null} or empty
+     * @return {@code true} if there is at least one {@code null} value in the array,
+     * {@code false} if all the values are non-null.
+     * If the array is {@code null} or empty, {@code true} is also returned.
+     * @since 3.10.1","[{'comment': 'New APIs will mean a minor release (not maintenance), per semantic versioning guidelines, so `@since 3.11` is best for these new APIs :-)', 'commenter': 'garydgregory'}, {'comment': ""Okay, I'll correct it :)"", 'commenter': 'Isira-Seneviratne'}]"
522,src/main/java/org/apache/commons/lang3/ObjectUtils.java,"@@ -277,6 +277,33 @@ public static boolean isNotEmpty(final Object object) {
         return object != null ? object : defaultSupplier == null ? null : defaultSupplier.get();
     }
 
+    /**
+     * Checks if any value in the given array is {@code null}.
+     *
+     * <p>
+     * If all the values are {@code null} or the array is {@code null}
+     * or empty, then {@code true} is returned, otherwise {@code false} is returned.","[{'comment': ""Wrong method doc. Shouldn't it be?\r\n\r\n```suggestion\r\n     * If any the values are {@code null} or the array is {@code null},\r\n     * then {@code true} is returned, otherwise {@code false} is returned.\r\n```"", 'commenter': 'rajeshkarnena'}]"
522,src/main/java/org/apache/commons/lang3/ObjectUtils.java,"@@ -277,6 +277,33 @@ public static boolean isNotEmpty(final Object object) {
         return object != null ? object : defaultSupplier == null ? null : defaultSupplier.get();
     }
 
+    /**
+     * Checks if any value in the given array is {@code null}.
+     *
+     * <p>
+     * If all the values are {@code null} or the array is {@code null}
+     * or empty, then {@code true} is returned, otherwise {@code false} is returned.
+     * </p>
+     *
+     * <pre>
+     * ObjectUtils.anyNull(*)                = false
+     * ObjectUtils.anyNull(*, null)          = false
+     * ObjectUtils.anyNull(null, *)          = false
+     * ObjectUtils.anyNull(null, null, *, *) = false","[{'comment': 'Incorrect examples\r\n```suggestion\r\n     * ObjectUtils.anyNull(*, null)          = true\r\n     * ObjectUtils.anyNull(null, *)          = true\r\n     * ObjectUtils.anyNull(null, null, *, *) = true\r\n```', 'commenter': 'rajeshkarnena'}]"
551,src/main/java/org/apache/commons/lang3/ArrayUtils.java,"@@ -3110,19 +3110,22 @@ public static int indexOf(final short[] array, final short valueToFind, int star
     }
 
     /**
-     * Returns whether a given array can safely be accessed at the given index.
+     * <p>Returns whether a given array can safely be accessed at the given index.","[{'comment': 'Paragraph tags are not needed for the first paragraph of a Javadoc comment. When you do use HTML tags (elsewhere), you should close them.', 'commenter': 'garydgregory'}]"
551,src/main/java/org/apache/commons/lang3/ArrayUtils.java,"@@ -3110,19 +3110,22 @@ public static int indexOf(final short[] array, final short valueToFind, int star
     }
 
     /**
-     * Returns whether a given array can safely be accessed at the given index.
+     * <p>Returns whether a given array can safely be accessed at the given index.
+     *
+     * <pre>
+     * ArrayUtils.isArrayIndexValid(null, 0)       = false
+     * ArrayUtils.isArrayIndexValid([], 0)         = false
+     * ArrayUtils.isArrayIndexValid([""a""], 0)      = true
+     * </pre>","[{'comment': 'Unfortunately, Javadoc created with a closed pre tag after an EOL appear with an extra blank line. so pre tags should be closed at the end of the last line.\r\n', 'commenter': 'garydgregory'}, {'comment': '@garydgregory \r\nI think this is not a big problem, as most of the `</pre>` usage in this repo (especially in StringUtils) do it this way, means not closed at the end of the last line, but close at a new line.\r\nShould we arrange a fix for all of that usages?\r\n', 'commenter': 'XenoAmess'}, {'comment': '@garydgregory \r\nan example:\r\n```\r\n    /**\r\n     * <p>Remove the last character from a String.</p>\r\n     *\r\n     * <p>If the String ends in {@code \\r\\n}, then remove both\r\n     * of them.</p>\r\n     *\r\n     * <pre>\r\n     * StringUtils.chop(null)          = null\r\n     * StringUtils.chop("""")            = """"\r\n     * StringUtils.chop(""abc \\r"")      = ""abc ""\r\n     * StringUtils.chop(""abc\\n"")       = ""abc""\r\n     * StringUtils.chop(""abc\\r\\n"")     = ""abc""\r\n     * StringUtils.chop(""abc"")         = ""ab""\r\n     * StringUtils.chop(""abc\\nabc"")    = ""abc\\nab""\r\n     * StringUtils.chop(""a"")           = """"\r\n     * StringUtils.chop(""\\r"")          = """"\r\n     * StringUtils.chop(""\\n"")          = """"\r\n     * StringUtils.chop(""\\r\\n"")        = """"\r\n     * </pre>\r\n     *\r\n     * @param str  the String to chop last character from, may be null\r\n     * @return String without last character, {@code null} if null String input\r\n     */\r\n    public static String chop(final String str) {\r\n```', 'commenter': 'XenoAmess'}, {'comment': ""Sorry, I don't really get what is the problem with `</pre>`."", 'commenter': 'nstdio'}, {'comment': '@nstdio \r\nIn short gary think your docs should be \r\n```\r\n     * ArrayUtils.isArrayIndexValid(null, 0)       = false\r\n     * ArrayUtils.isArrayIndexValid([], 0)         = false\r\n     * ArrayUtils.isArrayIndexValid([""a""], 0)      = true</pre>\r\n```\r\n\r\ninstead of \r\n\r\n```\r\n     * ArrayUtils.isArrayIndexValid(null, 0)       = false\r\n     * ArrayUtils.isArrayIndexValid([], 0)         = false\r\n     * ArrayUtils.isArrayIndexValid([""a""], 0)      = true\r\n     * </pre>\r\n```\r\n\r\nBut I think the current docs be OK.\r\nSo suggest just wait.', 'commenter': 'XenoAmess'}, {'comment': 'Not worth changing today...', 'commenter': 'garydgregory'}]"
634,src/test/java/org/apache/commons/lang3/math/NumberUtilsTest.java,"@@ -16,20 +16,15 @@
  */
 package org.apache.commons.lang3.math;
 
-import static org.junit.jupiter.api.Assertions.assertEquals;
-import static org.junit.jupiter.api.Assertions.assertFalse;
-import static org.junit.jupiter.api.Assertions.assertNotNull;
-import static org.junit.jupiter.api.Assertions.assertNull;
-import static org.junit.jupiter.api.Assertions.assertThrows;
-import static org.junit.jupiter.api.Assertions.assertTrue;
+import org.junit.jupiter.api.Test;
 
 import java.lang.reflect.Constructor;
 import java.lang.reflect.Modifier;
 import java.math.BigDecimal;
 import java.math.BigInteger;
 import java.math.RoundingMode;
 
-import org.junit.jupiter.api.Test;
+import static org.junit.jupiter.api.Assertions.*;","[{'comment': ""Please don't use star imports."", 'commenter': 'garydgregory'}, {'comment': 'Fixed. ', 'commenter': 'HubertWo'}]"
644,src/main/java/org/apache/commons/lang3/StringUtils.java,"@@ -2854,6 +2854,39 @@ public static int indexOfAny(final CharSequence cs, final String searchChars) {
         return indexOfAny(cs, searchChars.toCharArray());
     }
 
+    /**
+     * <p>Search a CharSequence to find the first index of any
+     * character in the given set of characters starting with
+     * a given index.</p>
+     *
+     * <p>A {@code null} String will return {@code -1}.
+     * A {@code null} search string will return {@code -1}.</p>
+     *
+     * <pre>
+     * StringUtils.indexOfAny(null, 0, *)            = -1
+     * StringUtils.indexOfAny("""", 0, *)              = -1
+     * StringUtils.indexOfAny(*, 0, null)            = -1
+     * StringUtils.indexOfAny(*, 0, """")              = -1
+     * StringUtils.indexOfAny(""zzabyycdxx"", 0, ""za"") = 0
+     * StringUtils.indexOfAny(""zzabyycdxx"", 0, ""by"") = 3
+     * StringUtils.indexOfAny(""aba"", 0, ""z"")         = -1
+     * StringUtils.indexOfAny(""aba"", 1, ""a"")         = 1
+     * StringUtils.indexOfAny(""aba"", -1, ""a"")        = -1
+     * </pre>
+     *
+     * @param cs  the CharSequence to check, may be null
+     * @param beginIndex  the start position to search
+     * @param searchChars  the chars to search for, may be null
+     * @return the index of any of the chars, -1 if no match,null input or  the beginIndex smaller than 0
+     * @since 3.2","[{'comment': 'Wrong since tag.', 'commenter': 'garydgregory'}, {'comment': 'Hi @garydgregory Which would be correct?', 'commenter': 'arturobernalg'}, {'comment': 'True. Changed to 3.12', 'commenter': 'arturobernalg'}]"
644,src/main/java/org/apache/commons/lang3/StringUtils.java,"@@ -2854,6 +2854,39 @@ public static int indexOfAny(final CharSequence cs, final String searchChars) {
         return indexOfAny(cs, searchChars.toCharArray());
     }
 
+    /**
+     * <p>Search a CharSequence to find the first index of any
+     * character in the given set of characters starting with
+     * a given index.</p>
+     *
+     * <p>A {@code null} String will return {@code -1}.
+     * A {@code null} search string will return {@code -1}.</p>
+     *
+     * <pre>
+     * StringUtils.indexOfAny(null, 0, *)            = -1
+     * StringUtils.indexOfAny("""", 0, *)              = -1
+     * StringUtils.indexOfAny(*, 0, null)            = -1
+     * StringUtils.indexOfAny(*, 0, """")              = -1
+     * StringUtils.indexOfAny(""zzabyycdxx"", 0, ""za"") = 0
+     * StringUtils.indexOfAny(""zzabyycdxx"", 0, ""by"") = 3
+     * StringUtils.indexOfAny(""aba"", 0, ""z"")         = -1
+     * StringUtils.indexOfAny(""aba"", 1, ""a"")         = 1
+     * StringUtils.indexOfAny(""aba"", -1, ""a"")        = -1
+     * </pre>
+     *
+     * @param cs  the CharSequence to check, may be null
+     * @param beginIndex  the start position to search
+     * @param searchChars  the chars to search for, may be null
+     * @return the index of any of the chars, -1 if no match,null input or  the beginIndex smaller than 0
+     * @since 3.12
+     */
+    public static int indexOfAny(final CharSequence cs, int beginIndex, final String searchChars) {
+        if (isEmpty(cs) || isEmpty(searchChars) || beginIndex < 0) {
+            return INDEX_NOT_FOUND;
+        }
+        return indexOfAny(cs.toString().substring(beginIndex), searchChars.toCharArray());","[{'comment': ""Looks good I think. Only thing I'd like to confirm is what happens with those surrogate pairs. (Can't recall if that affects the length of the string, in which case it could give unexpected results here?)\r\n\r\nhttps://garygregory.wordpress.com/2015/11/03/java-lowercase-conversion-turkey/"", 'commenter': 'kinow'}, {'comment': 'I think we can just document that it\'s not supported for now. WDYT @garydgregory ?\r\n\r\n```java\r\nLocale turkish = Locale.forLanguageTag(""tr"");\r\nassertEquals(1, StringUtils.indexOfAny(""TITLE"".toLowerCase(turkish), 0, ""i"")); // error, -1 returned\r\n```\r\n\r\n@arturobernalg if you have any thoughts too, but in the meantime, could you squash your commits? Your change is very well written, and concise. But there are now 13 commits due to review feedback. We can squash it too when merging, but it\'d be simpler if you could do it, please.\r\n\r\nThanks!', 'commenter': 'kinow'}, {'comment': 'Although I think other similar methods make no remarks about locales/surrogate pairs... so we can probably ignore what I just said I guess ☺', 'commenter': 'kinow'}]"
646,src/main/java/org/apache/commons/lang3/StringUtils.java,"@@ -7274,6 +7274,52 @@ public static String rightPad(final String str, final int size, String padStr) {
         }
     }
 
+    /**
+     * <p>Returns either the passed in String with the specified prefix and suffix attached,
+     * or if the String is whitespace, empty ("""") or {@code null}, an empty string.</p>
+     *
+     * <p>Whitespace is defined by {@link Character#isWhitespace(char)}.</p>
+     *
+     * <pre>
+     * StringUtils.defaultIfNotBlank(null, ""pre-"", ""-post"")  = """"
+     * StringUtils.defaultIfNotBlank("""", ""pre-"", ""-post"")    = """"
+     * StringUtils.defaultIfNotBlank("" "", ""pre-"", ""-post"")   = """"
+     * StringUtils.defaultIfNotBlank(""bat"", ""pre-"", ""-post"") = ""pre-bat-bost""
+     * StringUtils.defaultIfNotBlank(""bat"", null, ""-post"")      = ""bat-post""
+     * StringUtils.defaultIfNotBlank(""bat"", ""pre-"", null)      = ""pre-bat""
+     * </pre>
+     * @param str the String to check, may be null
+     * @param prefix  the string to prepend if not blank. Null will be converted to empty string.
+     * @param suffix  the string to append if not blank. Null will be converted to empty string.
+     * @return the passed in String with prefix and suffix added, or empty string
+     * @see StringUtils#defaultString(String, String)
+     */","[{'comment': 'And since tag.', 'commenter': 'garydgregory'}, {'comment': 'Changed to 3.12', 'commenter': 'arturobernalg'}]"
646,src/main/java/org/apache/commons/lang3/StringUtils.java,"@@ -7274,6 +7274,52 @@ public static String rightPad(final String str, final int size, String padStr) {
         }
     }
 
+    /**
+     * <p>Returns either the passed in String with the specified prefix and suffix attached,
+     * or if the String is whitespace, empty ("""") or {@code null}, an empty string.</p>
+     *
+     * <p>Whitespace is defined by {@link Character#isWhitespace(char)}.</p>
+     *
+     * <pre>
+     * StringUtils.defaultIfNotBlank(null, ""pre-"", ""-post"")  = """"
+     * StringUtils.defaultIfNotBlank("""", ""pre-"", ""-post"")    = """"
+     * StringUtils.defaultIfNotBlank("" "", ""pre-"", ""-post"")   = """"
+     * StringUtils.defaultIfNotBlank(""bat"", ""pre-"", ""-post"") = ""pre-bat-bost""
+     * StringUtils.defaultIfNotBlank(""bat"", null, ""-post"")      = ""bat-post""
+     * StringUtils.defaultIfNotBlank(""bat"", ""pre-"", null)      = ""pre-bat""
+     * </pre>
+     * @param str the String to check, may be null
+     * @param prefix  the string to prepend if not blank. Null will be converted to empty string.
+     * @param suffix  the string to append if not blank. Null will be converted to empty string.
+     * @return the passed in String with prefix and suffix added, or empty string
+     * @see StringUtils#defaultString(String, String)
+     */
+    public static String defaultIfNotBlank(final String str, final String prefix, final String suffix) {
+        return isBlank(str) ? """" : defaultString(prefix) + str + defaultString(suffix);","[{'comment': 'Use EMPTY constant. ', 'commenter': 'garydgregory'}, {'comment': 'Done', 'commenter': 'arturobernalg'}, {'comment': 'HI @garydgregory Should i make any other changes?', 'commenter': 'arturobernalg'}]"
659,src/main/java/org/apache/commons/lang3/math/NumberUtils.java,"@@ -32,43 +32,43 @@
 public class NumberUtils {
 
     /** Reusable Long constant for zero. */
-    public static final Long LONG_ZERO = Long.valueOf(0L);
+    public static final Long LONG_ZERO = 0L;
     /** Reusable Long constant for one. */
-    public static final Long LONG_ONE = Long.valueOf(1L);
+    public static final Long LONG_ONE = 1L;
     /** Reusable Long constant for minus one. */
-    public static final Long LONG_MINUS_ONE = Long.valueOf(-1L);
+    public static final Long LONG_MINUS_ONE = -1L;
     /** Reusable Integer constant for zero. */
-    public static final Integer INTEGER_ZERO = Integer.valueOf(0);
+    public static final Integer INTEGER_ZERO = 0;
     /** Reusable Integer constant for one. */
-    public static final Integer INTEGER_ONE = Integer.valueOf(1);
+    public static final Integer INTEGER_ONE = 1;
     /** Reusable Integer constant for two */
-    public static final Integer INTEGER_TWO = Integer.valueOf(2);
+    public static final Integer INTEGER_TWO = 2;
     /** Reusable Integer constant for minus one. */
-    public static final Integer INTEGER_MINUS_ONE = Integer.valueOf(-1);
+    public static final Integer INTEGER_MINUS_ONE = -1;
     /** Reusable Short constant for zero. */
-    public static final Short SHORT_ZERO = Short.valueOf((short) 0);
+    public static final Short SHORT_ZERO = (short) 0;
     /** Reusable Short constant for one. */
-    public static final Short SHORT_ONE = Short.valueOf((short) 1);
+    public static final Short SHORT_ONE = (short) 1;
     /** Reusable Short constant for minus one. */
-    public static final Short SHORT_MINUS_ONE = Short.valueOf((short) -1);
+    public static final Short SHORT_MINUS_ONE = (short) -1;
     /** Reusable Byte constant for zero. */
-    public static final Byte BYTE_ZERO = Byte.valueOf((byte) 0);
+    public static final Byte BYTE_ZERO = (byte) 0;
     /** Reusable Byte constant for one. */
-    public static final Byte BYTE_ONE = Byte.valueOf((byte) 1);
+    public static final Byte BYTE_ONE = (byte) 1;
     /** Reusable Byte constant for minus one. */
-    public static final Byte BYTE_MINUS_ONE = Byte.valueOf((byte) -1);
+    public static final Byte BYTE_MINUS_ONE = (byte) -1;
     /** Reusable Double constant for zero. */
-    public static final Double DOUBLE_ZERO = Double.valueOf(0.0d);
+    public static final Double DOUBLE_ZERO = 0.0d;
     /** Reusable Double constant for one. */
-    public static final Double DOUBLE_ONE = Double.valueOf(1.0d);
+    public static final Double DOUBLE_ONE = 1.0d;","[{'comment': 'Hi @arturobernalg \r\nThank you for your PR.\r\n-1: For low-level libraries like most Apache Commons libraries, I like to keep boxing and unboxing explicit to make it easier to understand where objects are created and unwrapped.', 'commenter': 'garydgregory'}]"
680,src/main/java/org/apache/commons/lang3/reflect/MethodUtils.java,"@@ -742,35 +745,51 @@ public static Method getMatchingMethod(final Class<?> cls, final String methodNa
         Validate.notNull(cls, ""cls"");
         Validate.notEmpty(methodName, ""methodName"");
 
-        // Address methods in superclasses
-        Method[] methodArray = cls.getDeclaredMethods();
-        final List<Class<?>> superclassList = ClassUtils.getAllSuperclasses(cls);
-        for (final Class<?> klass : superclassList) {
-            methodArray = ArrayUtils.addAll(methodArray, klass.getDeclaredMethods());
-        }
+        final List<Method> methods = Arrays.stream(cls.getDeclaredMethods())
+                .filter(method -> method.getName().equals(methodName))
+                .collect(toList());
+
+        ClassUtils.getAllSuperclasses(cls).stream()
+                .map(Class::getDeclaredMethods)
+                .flatMap(Arrays::stream)
+                .filter(method -> method.getName().equals(methodName))
+                .forEach(methods::add);
 
-        Method inexactMatch = null;
-        for (final Method method : methodArray) {
-            if (methodName.equals(method.getName()) &&
-                    Objects.deepEquals(parameterTypes, method.getParameterTypes())) {
+        for (Method method : methods) {
+            if (Arrays.deepEquals(method.getParameterTypes(), parameterTypes)) {
                 return method;
-            } else if (methodName.equals(method.getName()) &&
-                    ClassUtils.isAssignable(parameterTypes, method.getParameterTypes(), true)) {
-                if ((inexactMatch == null) || (distance(parameterTypes, method.getParameterTypes())
-                        < distance(parameterTypes, inexactMatch.getParameterTypes()))) {
-                    inexactMatch = method;
-                }
             }
+        }
+
+        final TreeMap<Double, List<Method>> candidates = new TreeMap<>();
 
+        methods.stream()
+                .filter(method -> ClassUtils.isAssignable(parameterTypes, method.getParameterTypes(), true))
+                .forEach(method -> {
+                    final double distance = distance(parameterTypes, method.getParameterTypes());
+                    List<Method> methods1 = candidates.computeIfAbsent(distance, k -> new ArrayList<>());
+                    methods1.add(method);
+                });
+
+        if (candidates.isEmpty()) {
+            return null;
         }
-        return inexactMatch;
+
+        final List<Method> bestCandidates = candidates.values().iterator().next();
+        if (bestCandidates.size() == 1) {
+            return bestCandidates.get(0);
+        }
+
+        final String target = methodName + Arrays.stream(parameterTypes).map(String::valueOf).collect(Collectors.joining("","", ""("", "")""));
+        final String strCandidates = bestCandidates.stream().map(Method::toString).collect(Collectors.joining(""\n  ""));
+        throw new IllegalStateException(""Found multiple candidates for method "" + target + "" on class "" + cls + "":\n  "" + strCandidates);","[{'comment': ""Let's not hard-code Linux-specific new-line chars in error messages, but, if you really want new-lines, use `%n` with `String.format()`."", 'commenter': 'garydgregory'}, {'comment': 'I replaced the newlines with opening and closing brackets.\r\n\r\nMichael', 'commenter': 'mdbuck77'}]"
680,src/test/java/org/apache/commons/lang3/reflect/MethodUtilsTest.java,"@@ -1018,4 +1019,83 @@ public void testDistance() throws Exception {
 
         distanceMethod.setAccessible(false);
     }
+
+    @Test
+    public void testGetMatchingMethod() throws NoSuchMethodException {
+        assertEquals(MethodUtils.getMatchingMethod(GetMatchingMethodClass.class, ""testMethod""),
+                GetMatchingMethodClass.class.getMethod(""testMethod""));
+
+        assertEquals(MethodUtils.getMatchingMethod(GetMatchingMethodClass.class, ""testMethod"", Long.TYPE),
+                GetMatchingMethodClass.class.getMethod(""testMethod"", Long.TYPE));
+
+        assertEquals(MethodUtils.getMatchingMethod(GetMatchingMethodClass.class, ""testMethod"", Long.class),
+                GetMatchingMethodClass.class.getMethod(""testMethod"", Long.class));
+
+        assertEquals(MethodUtils.getMatchingMethod(GetMatchingMethodClass.class, ""testMethod"", (Class<?>) null),
+                GetMatchingMethodClass.class.getMethod(""testMethod"", Long.class));
+
+        assertThrows(IllegalStateException.class,
+                () -> MethodUtils.getMatchingMethod(GetMatchingMethodClass.class, ""testMethod2"", (Class<?>) null));
+
+        assertEquals(MethodUtils.getMatchingMethod(GetMatchingMethodClass.class, ""testMethod3"", Long.TYPE, Long.class),
+                GetMatchingMethodClass.class.getMethod(""testMethod3"", Long.TYPE, Long.class));
+
+        assertEquals(MethodUtils.getMatchingMethod(GetMatchingMethodClass.class, ""testMethod3"", Long.class, Long.TYPE),
+                GetMatchingMethodClass.class.getMethod(""testMethod3"", Long.class, Long.TYPE));
+
+        assertEquals(MethodUtils.getMatchingMethod(GetMatchingMethodClass.class, ""testMethod3"", null, Long.TYPE),
+                GetMatchingMethodClass.class.getMethod(""testMethod3"", Long.class, Long.TYPE));
+
+        assertEquals(MethodUtils.getMatchingMethod(GetMatchingMethodClass.class, ""testMethod3"", Long.TYPE, null),
+                GetMatchingMethodClass.class.getMethod(""testMethod3"", Long.TYPE, Long.class));
+
+        assertThrows(IllegalStateException.class,
+                () -> MethodUtils.getMatchingMethod(GetMatchingMethodClass.class, ""testMethod4"", null, null));
+    }
+
+    private static final class GetMatchingMethodClass {
+        public String testMethod() {
+            return ""testMethod"";
+        }
+
+        public String testMethod(Long aLong) {","[{'comment': 'Use final where you can, like here for parms.\r\n', 'commenter': 'garydgregory'}, {'comment': 'Done.\r\n\r\nMichael', 'commenter': 'mdbuck77'}]"
680,src/test/java/org/apache/commons/lang3/reflect/MethodUtilsTest.java,"@@ -1018,4 +1019,83 @@ public void testDistance() throws Exception {
 
         distanceMethod.setAccessible(false);
     }
+
+    @Test
+    public void testGetMatchingMethod() throws NoSuchMethodException {
+        assertEquals(MethodUtils.getMatchingMethod(GetMatchingMethodClass.class, ""testMethod""),
+                GetMatchingMethodClass.class.getMethod(""testMethod""));
+
+        assertEquals(MethodUtils.getMatchingMethod(GetMatchingMethodClass.class, ""testMethod"", Long.TYPE),
+                GetMatchingMethodClass.class.getMethod(""testMethod"", Long.TYPE));
+
+        assertEquals(MethodUtils.getMatchingMethod(GetMatchingMethodClass.class, ""testMethod"", Long.class),
+                GetMatchingMethodClass.class.getMethod(""testMethod"", Long.class));
+
+        assertEquals(MethodUtils.getMatchingMethod(GetMatchingMethodClass.class, ""testMethod"", (Class<?>) null),
+                GetMatchingMethodClass.class.getMethod(""testMethod"", Long.class));
+
+        assertThrows(IllegalStateException.class,
+                () -> MethodUtils.getMatchingMethod(GetMatchingMethodClass.class, ""testMethod2"", (Class<?>) null));
+
+        assertEquals(MethodUtils.getMatchingMethod(GetMatchingMethodClass.class, ""testMethod3"", Long.TYPE, Long.class),
+                GetMatchingMethodClass.class.getMethod(""testMethod3"", Long.TYPE, Long.class));
+
+        assertEquals(MethodUtils.getMatchingMethod(GetMatchingMethodClass.class, ""testMethod3"", Long.class, Long.TYPE),
+                GetMatchingMethodClass.class.getMethod(""testMethod3"", Long.class, Long.TYPE));
+
+        assertEquals(MethodUtils.getMatchingMethod(GetMatchingMethodClass.class, ""testMethod3"", null, Long.TYPE),
+                GetMatchingMethodClass.class.getMethod(""testMethod3"", Long.class, Long.TYPE));
+
+        assertEquals(MethodUtils.getMatchingMethod(GetMatchingMethodClass.class, ""testMethod3"", Long.TYPE, null),
+                GetMatchingMethodClass.class.getMethod(""testMethod3"", Long.TYPE, Long.class));
+
+        assertThrows(IllegalStateException.class,
+                () -> MethodUtils.getMatchingMethod(GetMatchingMethodClass.class, ""testMethod4"", null, null));
+    }
+
+    private static final class GetMatchingMethodClass {","[{'comment': 'Please make the test fixture as simple as possible: All of these methods can just return `void`.', 'commenter': 'garydgregory'}, {'comment': 'Done.\r\n\r\nMichael', 'commenter': 'mdbuck77'}]"
680,src/main/java/org/apache/commons/lang3/reflect/MethodUtils.java,"@@ -742,35 +745,51 @@ public static Method getMatchingMethod(final Class<?> cls, final String methodNa
         Validate.notNull(cls, ""cls"");
         Validate.notEmpty(methodName, ""methodName"");
 
-        // Address methods in superclasses
-        Method[] methodArray = cls.getDeclaredMethods();
-        final List<Class<?>> superclassList = ClassUtils.getAllSuperclasses(cls);
-        for (final Class<?> klass : superclassList) {
-            methodArray = ArrayUtils.addAll(methodArray, klass.getDeclaredMethods());
-        }
+        final List<Method> methods = Arrays.stream(cls.getDeclaredMethods())
+                .filter(method -> method.getName().equals(methodName))
+                .collect(toList());
+
+        ClassUtils.getAllSuperclasses(cls).stream()
+                .map(Class::getDeclaredMethods)
+                .flatMap(Arrays::stream)
+                .filter(method -> method.getName().equals(methodName))
+                .forEach(methods::add);
 
-        Method inexactMatch = null;
-        for (final Method method : methodArray) {
-            if (methodName.equals(method.getName()) &&
-                    Objects.deepEquals(parameterTypes, method.getParameterTypes())) {
+        for (Method method : methods) {
+            if (Arrays.deepEquals(method.getParameterTypes(), parameterTypes)) {
                 return method;
-            } else if (methodName.equals(method.getName()) &&
-                    ClassUtils.isAssignable(parameterTypes, method.getParameterTypes(), true)) {
-                if ((inexactMatch == null) || (distance(parameterTypes, method.getParameterTypes())
-                        < distance(parameterTypes, inexactMatch.getParameterTypes()))) {
-                    inexactMatch = method;
-                }
             }
+        }
+
+        final TreeMap<Double, List<Method>> candidates = new TreeMap<>();
 
+        methods.stream()
+                .filter(method -> ClassUtils.isAssignable(parameterTypes, method.getParameterTypes(), true))
+                .forEach(method -> {
+                    final double distance = distance(parameterTypes, method.getParameterTypes());
+                    List<Method> methods1 = candidates.computeIfAbsent(distance, k -> new ArrayList<>());
+                    methods1.add(method);
+                });
+
+        if (candidates.isEmpty()) {
+            return null;
         }
-        return inexactMatch;
+
+        final List<Method> bestCandidates = candidates.values().iterator().next();
+        if (bestCandidates.size() == 1) {
+            return bestCandidates.get(0);
+        }
+
+        final String target = methodName + Arrays.stream(parameterTypes).map(String::valueOf).collect(Collectors.joining("","", ""("", "")""));
+        final String strCandidates = bestCandidates.stream().map(Method::toString).collect(Collectors.joining(""\n  ""));
+        throw new IllegalStateException(""Found multiple candidates for method "" + target + "" on class "" + cls + "":\n  "" + strCandidates);
     }
 
     /**
      * <p>Returns the aggregate number of inheritance hops between assignable argument class types.  Returns -1
      * if the arguments aren't assignable.  Fills a specific purpose for getMatchingMethod and is not generalized.</p>
-     * @param classArray
-     * @param toClassArray
+     * @param classArray the Class array to calculate the distance from.","[{'comment': 'Maybe rename to `fromClassArray` to match `toClassArray`?', 'commenter': 'garydgregory'}, {'comment': 'Good suggestion. Done.\r\n\r\nMichael', 'commenter': 'mdbuck77'}]"
682,src/test/java/org/apache/commons/lang3/StringUtilsEqualsIndexOfTest.java,"@@ -506,42 +510,57 @@ public void testIndexOfIgnoreCase_StringInt() {
         assertEquals(4, StringUtils.indexOfIgnoreCase(""aabaabaa"", ""AB"", 2));
         assertEquals(4, StringUtils.indexOfIgnoreCase(""aabaabaa"", ""AB"", 3));
         assertEquals(4, StringUtils.indexOfIgnoreCase(""aabaabaa"", ""AB"", 4));
-        assertEquals(-1, StringUtils.indexOfIgnoreCase(""aabaabaa"", ""AB"", 5));
-        assertEquals(-1, StringUtils.indexOfIgnoreCase(""aabaabaa"", ""AB"", 6));
-        assertEquals(-1, StringUtils.indexOfIgnoreCase(""aabaabaa"", ""AB"", 7));
-        assertEquals(-1, StringUtils.indexOfIgnoreCase(""aabaabaa"", ""AB"", 8));
+        assertEquals(NOT_FOUND, StringUtils.indexOfIgnoreCase(""aabaabaa"", ""AB"", 5));
+        assertEquals(NOT_FOUND, StringUtils.indexOfIgnoreCase(""aabaabaa"", ""AB"", 6));
+        assertEquals(NOT_FOUND, StringUtils.indexOfIgnoreCase(""aabaabaa"", ""AB"", 7));
+        assertEquals(NOT_FOUND, StringUtils.indexOfIgnoreCase(""aabaabaa"", ""AB"", 8));
         assertEquals(1, StringUtils.indexOfIgnoreCase(""aab"", ""AB"", 1));
         assertEquals(5, StringUtils.indexOfIgnoreCase(""aabaabaa"", """", 5));
-        assertEquals(-1, StringUtils.indexOfIgnoreCase(""ab"", ""AAB"", 0));
-        assertEquals(-1, StringUtils.indexOfIgnoreCase(""aab"", ""AAB"", 1));
-        assertEquals(-1, StringUtils.indexOfIgnoreCase(""abc"", """", 9));
+        assertEquals(NOT_FOUND, StringUtils.indexOfIgnoreCase(""ab"", ""AAB"", 0));
+        assertEquals(NOT_FOUND, StringUtils.indexOfIgnoreCase(""aab"", ""AAB"", 1));
+        assertEquals(NOT_FOUND, StringUtils.indexOfIgnoreCase(""abc"", """", 9));
     }
 
     @Test
     public void testLastIndexOf_char() {
-        assertEquals(-1, StringUtils.lastIndexOf(null, ' '));
-        assertEquals(-1, StringUtils.lastIndexOf("""", ' '));
+        assertEquals(NOT_FOUND, StringUtils.lastIndexOf(null, ' '));
+        assertEquals(NOT_FOUND, StringUtils.lastIndexOf("""", ' '));
         assertEquals(7, StringUtils.lastIndexOf(""aabaabaa"", 'a'));
         assertEquals(5, StringUtils.lastIndexOf(""aabaabaa"", 'b'));
 
         assertEquals(5, StringUtils.lastIndexOf(new StringBuilder(""aabaabaa""), 'b'));
+        char[] charArray = new char[9];
+        charArray[0] = '[';
+        charArray[1] = '&';
+        charArray[7] = '{';
+        charArray[3] = '.';
+        charArray[4] = 'c';
+        charArray[5] = '.';
+        charArray[6] = '0';
+        charArray[7] = 'r';
+        charArray[8] = 'o';
+        CharBuffer charBuffer = CharBuffer.wrap(charArray);
+        assertEquals(NOT_FOUND, StringUtils.lastIndexOf (charBuffer, (-1738), 982));","[{'comment': ""Hi @arturobernalg \r\n\r\nThank you for your PR. \r\n\r\nPS: It's harder to deal with a PR like this because it mixes a change with some clean ups (-1 -> NOT_FOUND) so I am not sure where the new test is without trolling through all the noise :-(\r\n\r\nWhy is the number in parentheses? If this is a test for the actual bug fix, then you should add a sanity check to validates that the char is indeed bogus.\r\n\r\nTY."", 'commenter': 'garydgregory'}, {'comment': ""HI @garydgregory \r\nsorry for the noise. When I created the PR it seemed logical.  But you're right. Better keep the PRs separate"", 'commenter': 'arturobernalg'}, {'comment': ""Hi @arturobernalg \r\nYou've not answered all my question.\r\nAlso why are you building the char[] one char at a time? Why not call CharBuffer.wrap(String)?"", 'commenter': 'garydgregory'}, {'comment': ""mmm \r\n\r\n- The parentheses was a mistake\r\n- The Character in the test there are not valid unicode values\r\n- I'll change  the test for --> CharBuffer.wrap(String)"", 'commenter': 'arturobernalg'}]"
682,src/main/java/org/apache/commons/lang3/CharSequenceUtils.java,"@@ -195,6 +196,7 @@ static int lastIndexOf(final CharSequence cs, final int searchChar, int start) {
                     return i;
                 }
             }
+            return NOT_FOUND;","[{'comment': ""mm . Maybe it's my fault. \r\nThe idea it's exit the loop and return -1 (NOT_FOUND) if not found the charset "", 'commenter': 'arturobernalg'}, {'comment': ""ah, I see, this is a new line, and the other mods are updates. ok, I'll take a look tomorrow probably..."", 'commenter': 'garydgregory'}, {'comment': 'sorry. my fault for mixing.', 'commenter': 'arturobernalg'}]"
682,src/main/java/org/apache/commons/lang3/CharSequenceUtils.java,"@@ -109,6 +109,7 @@ static int indexOf(final CharSequence cs, final int searchChar, int start) {
                     return i;
                 }
             }
+            return NOT_FOUND;","[{'comment': 'idem @garydgregory ', 'commenter': 'arturobernalg'}]"
682,src/test/java/org/apache/commons/lang3/StringUtilsEqualsIndexOfTest.java,"@@ -48,6 +49,8 @@
 
     private static final String[] FOOBAR_SUB_ARRAY = new String[] {""ob"", ""ba""};
 
+    private static final int NOT_FOUND = -1;","[{'comment': 'This is already defined in `StringUtils.INDEX_NOT_FOUND` and `ArrayUtils`, please reuse.\r\n', 'commenter': 'garydgregory'}, {'comment': 'true. changed   ', 'commenter': 'arturobernalg'}]"
716,src/main/java/org/apache/commons/lang3/BooleanUtils.java,"@@ -263,6 +267,23 @@ public static Boolean negate(final Boolean bool) {
         return bool.booleanValue() ? Boolean.FALSE : Boolean.TRUE;
     }
 
+    /**
+     * <p>Validate that the specified argument array is neither {@code null}
+     * nor a length of zero (no elements); otherwise throwing an exception.
+     *
+     * @param array  an array of {@code boolean}s
+     * @throws IllegalArgumentException if {@code array} is {@code null}
+     * @throws IllegalArgumentException if {@code array} is empty.
+     */
+    private static void notNullOrEmpty(final boolean... array){
+        if (array == null) {","[{'comment': 'Hi @arturobernalg \r\nI think we should converge all null checks to `Objects.requireNonNull(arg, ""arg"")`, which also avoids making our exception messages too English-centric. In the same vein, I\'d call this new method `requireNotEmpty`.\r\n', 'commenter': 'garydgregory'}]"
716,src/main/java/org/apache/commons/lang3/BooleanUtils.java,"@@ -29,7 +29,18 @@
  * @since 2.0
  */
 public class BooleanUtils {
-
+    /**
+     * The default message for null array.
+     *
+     * @since 3.12.0","[{'comment': 'No need for since tag for private elements.', 'commenter': 'garydgregory'}]"
716,src/main/java/org/apache/commons/lang3/BooleanUtils.java,"@@ -29,7 +29,18 @@
  * @since 2.0
  */
 public class BooleanUtils {
-
+    /**
+     * The default message for null array.
+     *
+     * @since 3.12.0
+     */
+    private static final String DEFAULT_NULL_ARRAY_EX_MESSAGE = ""The Array must not be null"";
+    /**
+     * The default message for empty array.
+     *
+     * @since 3.12.0","[{'comment': 'No need for since tag for private elements.', 'commenter': 'garydgregory'}]"
716,src/main/java/org/apache/commons/lang3/BooleanUtils.java,"@@ -29,7 +29,18 @@
  * @since 2.0
  */
 public class BooleanUtils {
-
+    /**
+     * The default message for null array.
+     *
+     * @since 3.12.0
+     */
+    private static final String DEFAULT_NULL_ARRAY_EX_MESSAGE = ""The Array must not be null"";
+    /**
+     * The default message for empty array.
+     *
+     * @since 3.12.0
+     */
+    private static final String DEFAULT_EMPTY_ARRAY_EX_MESSAGE = ""Array is empty"";","[{'comment': 'Simplify to ""Empty array"".', 'commenter': 'garydgregory'}]"
723,pom.xml,"@@ -528,6 +528,12 @@
   <!-- Lang should depend on very little -->
   <dependencies>
     <!-- testing -->
+    <dependency>","[{'comment': 'Use the current version of Mockito if you need it, not some random antique version please.', 'commenter': 'garydgregory'}]"
723,src/main/java/org/apache/commons/lang3/time/DateUtils.java,"@@ -950,6 +958,156 @@ public static Date ceiling(final Object date, final int field) {
         }
     }
 
+    public static long truncateCalendar(final Calendar val, final int field, final Object obj){
+
+        // ----------------- Fix for LANG-59 ---------------------- START ---------------
+        // see https://issues.apache.org/jira/browse/LANG-59
+        //
+        // Manually truncate milliseconds, seconds and minutes, rather than using
+        // Calendar methods.
+
+        final Date date = val.getTime();
+        long time = date.getTime();
+        boolean done = false;
+
+        ModifyType modType = (ModifyType) obj;
+
+        // truncate milliseconds
+        final int millisecs = val.get(Calendar.MILLISECOND);
+        if (ModifyType.TRUNCATE == modType || millisecs < 500) {
+            time = time - millisecs;
+        }
+        if (field == Calendar.SECOND) {
+            done = true;
+        }
+
+        // truncate seconds
+        final int seconds = val.get(Calendar.SECOND);
+        if (!done && (ModifyType.TRUNCATE == modType || seconds < 30)) {
+            time = time - (seconds * 1000L);
+        }
+        if (field == Calendar.MINUTE) {
+            done = true;
+        }
+
+        // truncate minutes
+        final int minutes = val.get(Calendar.MINUTE);
+        if (!done && (ModifyType.TRUNCATE == modType || minutes < 30)) {
+            time = time - (minutes * 60000L);
+        }
+
+        return time;
+    }
+    private static void modify2Version(final Calendar val, final int field, final ModifyType modType) {
+        if (val.get(Calendar.YEAR) > 280000000) {
+            throw new ArithmeticException(""Calendar value too large for accurate calculations"");
+        }
+
+        if (field == Calendar.MILLISECOND) {
+            return;
+        }
+
+        long time = truncateCalendar(val, field, modType);
+
+        final Date date = val.getTime();
+
+        // reset time
+        if (date.getTime() != time) {
+            date.setTime(time);
+            val.setTime(date);
+        }
+        // ----------------- Fix for LANG-59 ----------------------- END ----------------
+
+        boolean roundUp = false;
+        for (final int[] aField : fields) {
+            for (final int element : aField) {
+                if (element == field) {
+                    //This is our field... we stop looping
+                    if (modType == ModifyType.CEILING || modType == ModifyType.ROUND && roundUp) {
+                        if (field == SEMI_MONTH) {
+                            //This is a special case that's hard to generalize
+                            //If the date is 1, we round up to 16, otherwise
+                            //  we subtract 15 days and add 1 month
+                            if (val.get(Calendar.DATE) == 1) {
+                                val.add(Calendar.DATE, 15);
+                            } else {
+                                val.add(Calendar.DATE, -15);
+                                val.add(Calendar.MONTH, 1);
+                            }
+// ----------------- Fix for LANG-440 ---------------------- START ---------------","[{'comment': 'No comments like this please.', 'commenter': 'garydgregory'}]"
723,src/test/java/org/apache/commons/lang3/builder/MultilineRecursiveToStringStyleMockingTest.java,"@@ -0,0 +1,130 @@
+package org.apache.commons.lang3.builder;
+","[{'comment': 'Missing header file break the build. Check the Actions tab.', 'commenter': 'garydgregory'}]"
730,src/main/java/org/apache/commons/lang3/EnumUtils.java,"@@ -294,6 +295,25 @@
         return map;
     }
 
+    /**
+     * <p>Gets the {@code Map} of enums.</p>
+     *
+     * <p>This method is useful when you need a map of enums.</p>
+     *
+     * @param <E> the type of enumeration
+     * @param <K> the type of the map key
+     * @param enumClass the class of the enum to query, not null
+     * @param keyFunction the function to query for the key, not null
+     * @return the modifiable map of enums, never null
+     */","[{'comment': 'Hi @MaxwellCody and thank you for your PR. Some comments:\r\n\r\n- Add `@since 3.13.0`\r\n- ""Eat own dog food"" and reimplement `EnumUtils.getEnumMap(Class<E>)` to use this method.', 'commenter': 'garydgregory'}]"
730,src/main/java/org/apache/commons/lang3/EnumUtils.java,"@@ -294,6 +295,25 @@
         return map;
     }
 
+    /**
+     * <p>Gets the {@code Map} of enums.</p>
+     *
+     * <p>This method is useful when you need a map of enums.</p>
+     *
+     * @param <E> the type of enumeration
+     * @param <K> the type of the map key
+     * @param enumClass the class of the enum to query, not null
+     * @param keyFunction the function to query for the key, not null
+     * @return the modifiable map of enums, never null
+     */
+    public static <E extends Enum<E>, K> Map<K, E> getEnumMap(final Class<E> enumClass, final Function<E, K> keyFunction) {
+        final Map<K, E> map = new LinkedHashMap<>();","[{'comment': 'Add `Objects.requireNonNull(enumClass, ""enumClass"")` as the 1st line of this method.', 'commenter': 'garydgregory'}, {'comment': 'Perhaps optimise the size of the hashmap:\r\n```java\r\nfinal E[] elements = enumClass.getEnumConstants();\r\nfinal Map<K, E> map = new LinkedHashMap<>(elements.length);\r\nfor (final E e : elements) {\r\n```', 'commenter': 'aherbert'}]"
733,src/test/java/org/apache/commons/lang3/exception/ContextedExceptionTest.java,"@@ -48,6 +48,12 @@ public void testContextedException() {
         assertTrue(StringUtils.isEmpty(message));
     }
 
+    @Test
+    public void testNullException() {
+        final String trace = ExceptionUtils.getStackTrace(null);","[{'comment': 'In-line `trace`.', 'commenter': 'garydgregory'}, {'comment': 'Hi @garydgregory \r\nChanged\r\nTY', 'commenter': 'arturobernalg'}]"
733,src/test/java/org/apache/commons/lang3/exception/ContextedExceptionTest.java,"@@ -48,6 +48,11 @@ public void testContextedException() {
         assertTrue(StringUtils.isEmpty(message));
     }
 
+    @Test
+    public void testNullException() {
+        assertTrue(StringUtils.isEmpty(ExceptionUtils.getStackTrace(null)));","[{'comment': 'I think the test can be simplified by not using StringUtils.', 'commenter': 'garydgregory'}, {'comment': 'HI @garydgregory \r\nSomeThins like --> `assertNotNull(ExceptionUtils.getStackTrace(null));` ??\r\nTY', 'commenter': 'arturobernalg'}, {'comment': '> \r\n> \r\n> HI @garydgregory\r\n> SomeThins like --> `assertNotNull(ExceptionUtils.getStackTrace(null));` ??\r\n> TY\r\n\r\nHello @arturobernalg \r\nNo, assert what you expect to happen on null input. Your suggestion above would accept a return value of ""foo"". Is that OK? I think not.\r\n', 'commenter': 'garydgregory'}, {'comment': 'HI @garydgregory \r\nok i think i understand what you mean.\r\nTY', 'commenter': 'arturobernalg'}]"
733,src/main/java/org/apache/commons/lang3/exception/ExceptionUtils.java,"@@ -359,14 +359,16 @@ public static String getRootCauseMessage(final Throwable th) {
      * On JDK1.3 and earlier, the cause exception will not be shown
      * unless the specified throwable alters printStackTrace.</p>
      *
-     * @param throwable  the {@code Throwable} to be examined
+     * @param throwable  the {@code Throwable} to be examined, may be null
      * @return the stack trace as generated by the exception's
-     *  {@code printStackTrace(PrintWriter)} method
+     * {@code printStackTrace(PrintWriter)} method, or an empty String if {@code null} input
      */
     public static String getStackTrace(final Throwable throwable) {
         final StringWriter sw = new StringWriter();
         final PrintWriter pw = new PrintWriter(sw, true);
-        throwable.printStackTrace(pw);
+        if (throwable != null) {
+            throwable.printStackTrace(pw);
+        }","[{'comment': 'We do not need to create the writers at all. IMO, just guard the method by starting it with:\r\n```\r\n        if (throwable == null) {\r\n            return StringUtils.EMPTY;\r\n        }\r\n```', 'commenter': 'garydgregory'}, {'comment': 'ping.', 'commenter': 'garydgregory'}, {'comment': ""HI @garydgregory \r\nI don't see the way to just use String and not break the binary.\r\n"", 'commenter': 'arturobernalg'}]"
754,src/main/java/org/apache/commons/lang3/ObjectUtils.java,"@@ -951,6 +951,25 @@ their constant using one of the CONST() utility methods, instead:
             public final static int MAGIC_NUMBER = CONST(5);
      */
 
+    /**
+     * <p>Determine whether the given object is an array:
+     * either an Object array or a primitive array.
+     * <pre>
+     * ObjectUtils.isArray(null)             = false
+     * ObjectUtils.isArray("""")               = false
+     * ObjectUtils.isArray(""ab"")             = false
+     * ObjectUtils.isArray(new int[]{})      = true
+     * ObjectUtils.isArray(new int[]{1,2,3}) = true
+     * ObjectUtils.isArray(1234)             = false
+     * </pre>
+     *
+     * @param object the object to check, may be {@code null}
+     * @return {@code true} if the object is an {@code array}, {@code false} otherwise
+     * @since 3.13.0
+     */
+    public static boolean isArray(final Object object) {
+        return (object != null && object.getClass().isArray());","[{'comment': 'No need  for extra parentheses here.', 'commenter': 'garydgregory'}, {'comment': 'Done. Changed ', 'commenter': 'arturobernalg'}]"
754,src/main/java/org/apache/commons/lang3/ObjectUtils.java,"@@ -951,6 +951,25 @@ their constant using one of the CONST() utility methods, instead:
             public final static int MAGIC_NUMBER = CONST(5);
      */
 
+    /**
+     * <p>Determine whether the given object is an array:
+     * either an Object array or a primitive array.","[{'comment': 'Close HTML tags.', 'commenter': 'garydgregory'}, {'comment': 'Done.', 'commenter': 'arturobernalg'}]"
754,src/test/java/org/apache/commons/lang3/ObjectUtilsTest.java,"@@ -586,6 +586,23 @@ public void testIsEmpty() {
         assertFalse(ObjectUtils.isEmpty(NON_EMPTY_MAP));
     }
 
+    /**
+     * Test for {@link ObjectUtils#isArray(Object)}.
+     */
+    @Test
+    public void testArray() {
+        assertFalse(ObjectUtils.isArray(null));
+        assertFalse(ObjectUtils.isArray(""""));
+        assertFalse(ObjectUtils.isArray(""abg""));
+        assertFalse(ObjectUtils.isArray(123));
+
+        assertTrue(ObjectUtils.isArray(NON_EMPTY_ARRAY));
+        assertTrue(ObjectUtils.isArray(new int[] {}));
+        assertTrue(ObjectUtils.isArray(new int[]{1, 2, 3}));
+","[{'comment': 'Remove extra blank lines.', 'commenter': 'garydgregory'}, {'comment': 'Done', 'commenter': 'arturobernalg'}]"
754,src/test/java/org/apache/commons/lang3/ObjectUtilsTest.java,"@@ -586,6 +586,23 @@ public void testIsEmpty() {
         assertFalse(ObjectUtils.isEmpty(NON_EMPTY_MAP));
     }
 
+    /**
+     * Test for {@link ObjectUtils#isArray(Object)}.
+     */
+    @Test
+    public void testArray() {
+        assertFalse(ObjectUtils.isArray(null));
+        assertFalse(ObjectUtils.isArray(""""));
+        assertFalse(ObjectUtils.isArray(""abg""));
+        assertFalse(ObjectUtils.isArray(123));
+
+        assertTrue(ObjectUtils.isArray(NON_EMPTY_ARRAY));
+        assertTrue(ObjectUtils.isArray(new int[] {}));","[{'comment': 'Might as well test with all of our own arrays like the `EMPTY_*` arrays.', 'commenter': 'garydgregory'}, {'comment': 'Done', 'commenter': 'arturobernalg'}]"
754,src/main/java/org/apache/commons/lang3/ObjectUtils.java,"@@ -951,6 +951,25 @@ their constant using one of the CONST() utility methods, instead:
             public final static int MAGIC_NUMBER = CONST(5);
      */
 
+    /**
+     * <p>Determine whether the given object is an array:","[{'comment': 'I\'ve been using ""Tests..."" for `is*` methods. If you really want to keep ""Determine"" then it should be ""Determines"", also the main part of the Javadoc should mention that the method is null-safe, for example: ""Test whether the given object is an Object array or a primitive array in a null-safe manner."".', 'commenter': 'garydgregory'}, {'comment': 'Changed.\r\nTY', 'commenter': 'arturobernalg'}]"
757,src/main/java/org/apache/commons/lang3/ArrayUtils.java,"@@ -3566,7 +3566,7 @@ public static boolean isSameType(final Object array1, final Object array2) {
         if (array1 == null || array2 == null) {
             throw new IllegalArgumentException(""The Array must not be null"");
         }
-        return array1.getClass().getName().equals(array2.getClass().getName());
+        return ClassUtils.getName(array1).equals(ClassUtils.getName(array2));","[{'comment': 'Why? See my comments in your other PR. In this case, neither array1 or array2 can be null here.', 'commenter': 'garydgregory'}, {'comment': 'Yep, my bad. changed.', 'commenter': 'arturobernalg'}]"
757,src/main/java/org/apache/commons/lang3/time/FastDatePrinter.java,"@@ -414,7 +415,7 @@ public StringBuffer format(final Object obj, final StringBuffer toAppendTo, fina
             return format(((Long) obj).longValue(), toAppendTo);
         }
         throw new IllegalArgumentException(""Unknown class: "" +
-            (obj == null ? ""<null>"" : obj.getClass().getName()));
+            (ClassUtils.getName(obj,  ""<null>"")));","[{'comment': ""Don't need extra parentheses or extra space after comma."", 'commenter': 'garydgregory'}]"
757,src/test/java/org/apache/commons/lang3/EnumUtilsTest.java,"@@ -378,7 +378,7 @@ public void test_getEnumMap_keyFunction() {
 
     @Test
     public void test_getEnumSystemProperty() {
-        final String key = getClass().getName();
+        final String key = ClassUtils.getName(this);","[{'comment': 'Why?', 'commenter': 'garydgregory'}, {'comment': 'changed.', 'commenter': 'arturobernalg'}]"
757,src/test/java/org/apache/commons/lang3/reflect/TypeUtilsTest.java,"@@ -940,7 +941,7 @@ public void testParameterizeWithOwner() throws Exception {
 
     @Test
     public void testToLongString() {
-        assertEquals(getClass().getName() + "":B"", TypeUtils.toLongString(getClass().getTypeParameters()[0]));
+        assertEquals(ClassUtils.getName(this) + "":B"", TypeUtils.toLongString(getClass().getTypeParameters()[0]));","[{'comment': 'Why?', 'commenter': 'garydgregory'}, {'comment': 'changed.', 'commenter': 'arturobernalg'}]"
757,src/main/java/org/apache/commons/lang3/event/EventUtils.java,"@@ -48,11 +49,11 @@
         try {
             MethodUtils.invokeMethod(eventSource, ""add"" + listenerType.getSimpleName(), listener);
         } catch (final NoSuchMethodException e) {
-            throw new IllegalArgumentException(""Class "" + eventSource.getClass().getName()
+            throw new IllegalArgumentException(""Class "" + ClassUtils.getName(eventSource)","[{'comment': ""@arturobernalg \r\nWe're going through the same issue, over and over. I'm going to stop reviewing this PR until you can tell us that you've verified each call site you changed and whether it is justified. In this case, what happens when `eventSource` is null? Please do walk through the code instead of blindly changing all callers for Object#getClass(). Hint: if eventSource is null, we never get here, so if we are here it is never null and safe to call getName()."", 'commenter': 'garydgregory'}]"
758,src/main/java/org/apache/commons/lang3/time/FastDateParser.java,"@@ -564,7 +565,7 @@ boolean parse(final FastDateParser parser, final Calendar calendar, final String
          */
         @Override
         public String toString() {
-            return getClass().getSimpleName() + "" [pattern="" + pattern + ""]"";
+            return ClassUtils.getSimpleName(this) + "" [pattern="" + pattern + ""]"";","[{'comment': 'We should not do this since a ""this"" will never be null.', 'commenter': 'garydgregory'}]"
758,src/main/java/org/apache/commons/lang3/EnumUtils.java,"@@ -67,7 +67,7 @@
     private static <E extends Enum<E>> Class<E> checkBitVectorable(final Class<E> enumClass) {
         final E[] constants = asEnum(enumClass).getEnumConstants();
         Validate.isTrue(constants.length <= Long.SIZE, CANNOT_STORE_S_S_VALUES_IN_S_BITS,
-            Integer.valueOf(constants.length), enumClass.getSimpleName(), Integer.valueOf(Long.SIZE));
+            Integer.valueOf(constants.length), ClassUtils.getSimpleName(enumClass), Integer.valueOf(Long.SIZE));","[{'comment': 'This does not make sense since a null enumClass will cause an exception before we even get here.', 'commenter': 'garydgregory'}]"
773,src/main/java/org/apache/commons/lang3/ObjectUtils.java,"@@ -228,6 +227,18 @@ public static boolean anyNull(final Object... values) {
         return !allNotNull(values);
     }
 
+    /**
+     * Casts the object to the targeted class.
+     * @param value the object to cast
+     * @param castClass the class to which the object must be cast to
+     * @param <T> the type of the cast object
+     * @return the cast object, otherwise {@code null}
+     */","[{'comment': 'New main public and protected methods need a Javadoc since tag.', 'commenter': 'garydgregory'}]"
773,src/main/java/org/apache/commons/lang3/ObjectUtils.java,"@@ -228,6 +227,18 @@ public static boolean anyNull(final Object... values) {
         return !allNotNull(values);
     }
 
+    /**
+     * Casts the object to the targeted class.
+     * @param value the object to cast
+     * @param castClass the class to which the object must be cast to
+     * @param <T> the type of the cast object
+     * @return the cast object, otherwise {@code null}
+     */
+    public static <T> T cast(Object value, Class<T> castClass) {
+        return (castClass != null) && castClass.isInstance(value) ? castClass.cast(value) : null;","[{'comment': 'Match the style of the file: Use final where possible, no need for extra parentheses.', 'commenter': 'garydgregory'}]"
779,src/main/java/org/apache/commons/lang3/StringUtils.java,"@@ -8560,7 +8560,7 @@ public static String substring(final String str, int start, int end) {
      * </pre>
      *
      * @param str  the String to get a substring from, may be null
-     * @param separator  the character to search.
+     * @param separator the character (Unicode code point) to search for","[{'comment': 'Sentences should end in a period. Sentences feel quite awkward (to me) ending in a preposition.', 'commenter': 'garydgregory'}]"
779,src/main/java/org/apache/commons/lang3/StringUtils.java,"@@ -8639,7 +8639,7 @@ public static String substringAfter(final String str, final String separator) {
      * </pre>
      *
      * @param str  the String to get a substring from, may be null
-     * @param separator  the String to search for, may be null
+     * @param separator the character (Unicode code point) to search for","[{'comment': 'Why did you remove the documentation for null input?', 'commenter': 'garydgregory'}]"
779,src/main/java/org/apache/commons/lang3/StringUtils.java,"@@ -8721,7 +8721,7 @@ public static String substringAfterLast(final String str, final String separator
      * </pre>
      *
      * @param str the String to get a substring from, may be null
-     * @param separator the String to search for, may be null
+     * @param separator the character (Unicode code point) to search for","[{'comment': 'Why did you remove the documentation for null input?', 'commenter': 'garydgregory'}]"
821,src/main/java/org/apache/commons/lang3/AnnotationUtils.java,"@@ -69,9 +69,9 @@
          */
         @Override
         protected String getShortClassName(final Class<?> cls) {
-            for (final Class<?> iface : ClassUtils.getAllInterfaces(cls)) {
-                if (Annotation.class.isAssignableFrom(iface)) {
-                    return ""@"" + iface.getName();
+            for (final Class<?> interfaces : ClassUtils.getAllInterfaces(cls)) {","[{'comment': 'This is a bad name because this is a singular object.', 'commenter': 'garydgregory'}]"
821,src/main/java/org/apache/commons/lang3/CharSet.java,"@@ -147,21 +147,21 @@
      *
      * <p>All CharSet objects returned by this method will be immutable.</p>
      *
-     * @param setStrs  Strings to merge into the set, may be null
+     * @param set  Strings to merge into the set, may be null
      * @return a CharSet instance
      * @since 2.4
      */
-    public static CharSet getInstance(final String... setStrs) {
-        if (setStrs == null) {
+    public static CharSet getInstance(final String... set) {
+        if (set == null) {","[{'comment': 'Uh? An array is not a set.\r\n', 'commenter': 'garydgregory'}]"
821,src/main/java/org/apache/commons/lang3/Streams.java,"@@ -246,7 +246,7 @@ public void forEach(final FailableConsumer<O, ?> action) {
          *
          * @param <R> type of the result
          * @param <A> Type of the accumulator.
-         * @param pupplier a function that creates a new result container. For a
+         * @param supplier a function that creates a new result container. For a","[{'comment': 'Good catch! :-)', 'commenter': 'garydgregory'}]"
821,src/main/java/org/apache/commons/lang3/reflect/ConstructorUtils.java,"@@ -254,20 +254,20 @@ public ConstructorUtils() {
          * (1) Class.getConstructors() is documented to return Constructor<T> so as
          * long as the array is not subsequently modified, everything's fine.
          */
-        final Constructor<?>[] ctors = cls.getConstructors();
+        final Constructor<?>[] constructors = cls.getConstructors();
 
         // return best match:
-        for (Constructor<?> ctor : ctors) {
+        for (Constructor<?> ctr : constructors) {","[{'comment': 'Uh? Above, you change ""ctor"" to ""constructor"" but here you are changing _to_ an even short weirder name ""ctr""? Be consistent, please.', 'commenter': 'garydgregory'}]"
821,src/main/java/org/apache/commons/lang3/text/StrBuilder.java,"@@ -617,13 +617,13 @@ public StrBuilder append(final String str, final int startIndex, final int lengt
      * Calls {@link String#format(String, Object...)} and appends the result.
      *
      * @param format the format string
-     * @param objs the objects to use in the format string
+     * @param values the objects to use in the format string
      * @return {@code this} to enable chaining
      * @see String#format(String, Object...)
      * @since 3.2
      */
-    public StrBuilder append(final String format, final Object... objs) {
-        return append(String.format(format, objs));
+    public StrBuilder append(final String format, final Object... values) {
+        return append(String.format(format, values));","[{'comment': '""values"" is no better IMO. It would be consistent with `String.format()` to use ""args"" since we are just passing the values along.', 'commenter': 'garydgregory'}]"
821,src/main/java/org/apache/commons/lang3/text/StrBuilder.java,"@@ -1001,13 +1001,13 @@ public StrBuilder appendln(final String str, final int startIndex, final int len
      * Calls {@link String#format(String, Object...)} and appends the result.
      *
      * @param format the format string
-     * @param objs the objects to use in the format string
+     * @param values the objects to use in the format string
      * @return {@code this} to enable chaining
      * @see String#format(String, Object...)
      * @since 3.2
      */
-    public StrBuilder appendln(final String format, final Object... objs) {
-        return append(format, objs).appendNewLine();
+    public StrBuilder appendln(final String format, final Object... values) {
+        return append(format, values).appendNewLine();","[{'comment': 'See above.', 'commenter': 'garydgregory'}]"
821,src/main/java/org/apache/commons/lang3/AnnotationUtils.java,"@@ -69,9 +69,9 @@
          */
         @Override
         protected String getShortClassName(final Class<?> cls) {
-            for (final Class<?> iface : ClassUtils.getAllInterfaces(cls)) {
-                if (Annotation.class.isAssignableFrom(iface)) {
-                    return ""@"" + iface.getName();
+            for (final Class<?> iFace : ClassUtils.getAllInterfaces(cls)) {","[{'comment': '-1: _iface_ is short for _interface_, not _interFace_. We can\'t use ""interface"" since its reserved. No change is needed IMO.', 'commenter': 'garydgregory'}]"
821,src/main/java/org/apache/commons/lang3/LocaleUtils.java,"@@ -169,21 +169,21 @@ private static boolean isNumericAreaCode(final String str) {
         if (countryCode == null) {
             return Collections.emptyList();
         }
-        List<Locale> langs = cLanguagesByCountry.get(countryCode);
-        if (langs == null) {
-            langs = new ArrayList<>();
+        List<Locale> langByCountry = cLanguagesByCountry.get(countryCode);","[{'comment': 'Sorry, _langs_ was better IMO, mostly because it is _plural_ and is typed as a List. The new name is singular and therefore confusing (to me).', 'commenter': 'garydgregory'}]"
821,src/main/java/org/apache/commons/lang3/text/StrBuilder.java,"@@ -3045,14 +3045,14 @@ public void write(final int c) {
 
         /** {@inheritDoc} */
         @Override
-        public void write(final char[] cbuf) {
-            StrBuilder.this.append(cbuf);
+        public void write(final char[] buffer) {","[{'comment': '-1: Better to keep the name matching the overridden method from java.io.Writer, it will be less of a surprise if you know the Writer API. ', 'commenter': 'garydgregory'}]"
821,src/main/java/org/apache/commons/lang3/text/StrBuilder.java,"@@ -3045,14 +3045,14 @@ public void write(final int c) {
 
         /** {@inheritDoc} */
         @Override
-        public void write(final char[] cbuf) {
-            StrBuilder.this.append(cbuf);
+        public void write(final char[] buffer) {
+            StrBuilder.this.append(buffer);
         }
 
         /** {@inheritDoc} */
         @Override
-        public void write(final char[] cbuf, final int off, final int len) {
-            StrBuilder.this.append(cbuf, off, len);
+        public void write(final char[] buffer, final int off, final int len) {","[{'comment': '-1: Better to keep the name matching the overridden method from java.io.Writer, it will be less of a surprise if you know the Writer API. ', 'commenter': 'garydgregory'}]"
821,src/main/java/org/apache/commons/lang3/text/WordUtils.java,"@@ -402,8 +402,8 @@ public static String capitalize(final String str) {
      * @since 2.1
      */
     public static String capitalize(final String str, final char... delimiters) {
-        final int delimLen = delimiters == null ? -1 : delimiters.length;
-        if (StringUtils.isEmpty(str) || delimLen == 0) {
+        final int delimitersLength = delimiters == null ? -1 : delimiters.length;","[{'comment': '-1: Subjective from me granted, not but better to read IMO.', 'commenter': 'garydgregory'}]"
821,src/main/java/org/apache/commons/lang3/text/WordUtils.java,"@@ -525,8 +525,8 @@ public static String uncapitalize(final String str) {
      * @since 2.1
      */
     public static String uncapitalize(final String str, final char... delimiters) {
-        final int delimLen = delimiters == null ? -1 : delimiters.length;
-        if (StringUtils.isEmpty(str) || delimLen == 0) {
+        final int delimitersLength = delimiters == null ? -1 : delimiters.length;","[{'comment': '-1: Subjective from me granted, not but better to read IMO.', 'commenter': 'garydgregory'}]"
838,src/main/java/org/apache/commons/lang3/builder/ReflectionDiffBuilder.java,"@@ -73,6 +75,11 @@
     private final Object right;
     private final DiffBuilder<T> diffBuilder;
 
+    /**
+     * Which field names to exclude from output. Intended for fields like {@code ""password""} or {@code ""lastModificationDate}.
+     */","[{'comment': 'All _new_ `protected` and `public` elements new `@since 3.13.0`.', 'commenter': 'garydgregory'}]"
838,src/main/java/org/apache/commons/lang3/builder/ReflectionDiffBuilder.java,"@@ -99,6 +106,31 @@ public ReflectionDiffBuilder(final T lhs, final T rhs, final ToStringStyle style
         diffBuilder = new DiffBuilder<>(lhs, rhs, style);
     }
 
+    /**
+     * @return Returns the excludeFieldNames.","[{'comment': 'Javadoc comments start with a sentence.', 'commenter': 'garydgregory'}]"
838,src/changes/changes.xml,"@@ -66,6 +66,7 @@ The <action> type attribute can be add,update,fix,remove.
     <action                   type=""fix"" dev=""ggregory"" due-to=""CiprianBodnarescu"">Use Set instead of List for checking the contains() method #734.</action>
     <action                   type=""fix"" dev=""kinow"" due-to=""Roland Kreuzer"">Javadoc for StringUtils.substringBefore(String str, int separator) doesn't mention that the separator is an int.</action>
     <!-- ADD -->
+    <action issue=""LANG-1677"" type=""add"" dev=""debae"" due-to=""Dennis Baerten"">Add ReflectionDiffBuilder.setExcludeFieldNames(...) and DiffExclude annotation to support field exclusion from diff.</action>","[{'comment': ""Don't edit this file, it will usually clash depending on parallel changes."", 'commenter': 'garydgregory'}, {'comment': 'Removed the file again.', 'commenter': 'debae'}]"
838,src/main/java/org/apache/commons/lang3/builder/ReflectionDiffBuilder.java,"@@ -99,6 +107,34 @@ public ReflectionDiffBuilder(final T lhs, final T rhs, final ToStringStyle style
         diffBuilder = new DiffBuilder<>(lhs, rhs, style);
     }
 
+    /**
+     * Returns the field names that should be excluded from the diff
+     * @return Returns the excludeFieldNames.
+     * @since 3.13.0
+     */
+    public String[] getExcludeFieldNames() {
+        return this.excludeFieldNames.clone();
+    }
+
+
+    /**
+     * Sets the field names to exclude.
+     *
+     * @param excludeFieldNamesParam
+     *            The field names to exclude from the diff or {@code null}.
+     * @return {@code this}
+     * @since 3.13.0
+     */
+    public ReflectionDiffBuilder setExcludeFieldNames(final String... excludeFieldNamesParam) {
+        if (excludeFieldNamesParam == null) {
+            this.excludeFieldNames = new String[0];","[{'comment': 'Reuse `ArrayUtils.EMPTY_STRING_ARRAY`', 'commenter': 'garydgregory'}]"
838,src/main/java/org/apache/commons/lang3/builder/ReflectionDiffBuilder.java,"@@ -99,6 +107,34 @@ public ReflectionDiffBuilder(final T lhs, final T rhs, final ToStringStyle style
         diffBuilder = new DiffBuilder<>(lhs, rhs, style);
     }
 
+    /**
+     * Returns the field names that should be excluded from the diff
+     * @return Returns the excludeFieldNames.
+     * @since 3.13.0
+     */
+    public String[] getExcludeFieldNames() {
+        return this.excludeFieldNames.clone();
+    }
+
+
+    /**
+     * Sets the field names to exclude.
+     *
+     * @param excludeFieldNamesParam
+     *            The field names to exclude from the diff or {@code null}.
+     * @return {@code this}
+     * @since 3.13.0
+     */
+    public ReflectionDiffBuilder setExcludeFieldNames(final String... excludeFieldNamesParam) {
+        if (excludeFieldNamesParam == null) {
+            this.excludeFieldNames = new String[0];
+        } else {
+            //clone and remove nulls","[{'comment': 'Space after `//`', 'commenter': 'garydgregory'}]"
838,src/main/java/org/apache/commons/lang3/builder/ReflectionDiffBuilder.java,"@@ -73,6 +75,12 @@
     private final Object right;
     private final DiffBuilder<T> diffBuilder;
 
+    /**
+     * Which field names to exclude from output. Intended for fields like {@code ""password""} or {@code ""lastModificationDate}.
+     * @since 3.13.0
+     */
+    protected String[] excludeFieldNames;","[{'comment': 'Make `private`.', 'commenter': 'garydgregory'}]"
838,src/main/java/org/apache/commons/lang3/builder/ReflectionDiffBuilder.java,"@@ -131,7 +167,15 @@ private boolean accept(final Field field) {
         if (Modifier.isTransient(field.getModifiers())) {
             return false;
         }
-        return !Modifier.isStatic(field.getModifiers());
+        if (Modifier.isStatic(field.getModifiers())) {
+            return false;
+        }
+        if (this.excludeFieldNames != null","[{'comment': 'If you make the default value the empty array and the setter does not allow excludeFieldNames to be null, then you do not need this check? It might be better this way though, not sure.', 'commenter': 'garydgregory'}, {'comment': 'I took some ""inspiration"" from the `ReflectionToStringBuilder` where we also have the null check. \r\nIn case you do call setExcludeFieldNames with null, it\'s still safe here, guess that\'s the main reason.', 'commenter': 'debae'}, {'comment': "">In case you do call setExcludeFieldNames with null, it's still safe here, guess that's the main reason.\r\n\r\nBut this if condition is still unreachable even after calling setExcludeFieldNames with null, so we can drop it too (as condition cannot be reached for users nor via test code, I think?)."", 'commenter': 'kinow'}, {'comment': 'If you do invoke the method setExcludeFieldNames() it will have a default value of null, and in that cause a NPE here.', 'commenter': 'debae'}, {'comment': ""Hmm, I think I didn't understand the whole discussion here.\r\n\r\n@garydgregory pointed that instead of having a default of `null`, we could have something like `private String[] excludeFieldNames = ArrayUtils.EMPTY_STRING_ARRAY;`\r\n\r\n>If you do invoke the method setExcludeFieldNames() it will have a default value of null, and in that cause a NPE here.\r\n\r\nThat sounds incorrect, I think (it's late, so I could be wrong). If you call `setExcludeFieldNames`, there's a check if the value passed is `null`, and `this.excludeFieldNames = ArrayUtils.EMPTY_STRING_ARRAY;`. Thus, `excludeFieldNames` cannot be `null`.\r\n\r\nSo if you did as @garydgregory suggested, and if we keep the defensive check for `null` in `setExcludeFieldNames`, then I believe what @garydgregory initially suggested holds here? \r\n\r\n>If you make the default value the empty array and the setter does not allow excludeFieldNames to be null, then you do not need this check? It might be better this way though, not sure.\r\n\r\nThen, I think the question would be whether it's worth having the `binarySearch` knowing it's an empty array (maybe we could skip if if we know it's an empty array)."", 'commenter': 'kinow'}]"
838,src/test/java/org/apache/commons/lang3/builder/ReflectionDiffBuilderTest.java,"@@ -92,7 +96,7 @@ public void test_primitive_difference() {
     @Test
     public void test_array_difference() {
         final TypeTestClass firstObject = new TypeTestClass();
-        firstObject.charArrayField = new char[] { 'c' };
+        firstObject.charArrayField = new char[]{'c'};","[{'comment': 'Leave formatting alone here.', 'commenter': 'garydgregory'}]"
838,src/test/java/org/apache/commons/lang3/builder/ReflectionDiffBuilderTest.java,"@@ -128,4 +132,43 @@ public void test_difference_in_inherited_field() {
         final DiffResult list = firstObject.diff(secondObject);
         assertEquals(1, list.getNumberOfDiffs());
     }
+
+    @Test
+    public void test_no_differences_excluded_field() {
+        final TypeTestClass firstObject = new TypeTestClass();
+        firstObject.excludedField = ""b"";
+        final TypeTestClass secondObject = new TypeTestClass();
+
+        final DiffResult list = firstObject.diff(secondObject);
+        assertEquals(0, list.getNumberOfDiffs());
+    }
+
+    @Test
+    public void test_no_differences_diff_exclude_annotated_field() {
+        final TypeTestClass firstObject = new TypeTestClass();
+        firstObject.annotatedField = ""b"";
+        final TypeTestClass secondObject = new TypeTestClass();
+
+        final DiffResult list = firstObject.diff(secondObject);
+        assertEquals(0, list.getNumberOfDiffs());
+    }
+
+    @Test
+    public void testGetExcludeFieldNamesWithNullExcludedFieldNames() {
+        ReflectionDiffBuilder<TypeTestClass> reflectionDiffBuilder = new ReflectionDiffBuilder<>(new TypeTestClass(), new TypeTestChildClass(), SHORT_STYLE);","[{'comment': 'Use final where you can.', 'commenter': 'garydgregory'}]"
838,src/test/java/org/apache/commons/lang3/builder/ReflectionDiffBuilderTest.java,"@@ -128,4 +132,43 @@ public void test_difference_in_inherited_field() {
         final DiffResult list = firstObject.diff(secondObject);
         assertEquals(1, list.getNumberOfDiffs());
     }
+
+    @Test
+    public void test_no_differences_excluded_field() {
+        final TypeTestClass firstObject = new TypeTestClass();
+        firstObject.excludedField = ""b"";
+        final TypeTestClass secondObject = new TypeTestClass();
+
+        final DiffResult list = firstObject.diff(secondObject);
+        assertEquals(0, list.getNumberOfDiffs());
+    }
+
+    @Test
+    public void test_no_differences_diff_exclude_annotated_field() {
+        final TypeTestClass firstObject = new TypeTestClass();
+        firstObject.annotatedField = ""b"";
+        final TypeTestClass secondObject = new TypeTestClass();
+
+        final DiffResult list = firstObject.diff(secondObject);
+        assertEquals(0, list.getNumberOfDiffs());
+    }
+
+    @Test
+    public void testGetExcludeFieldNamesWithNullExcludedFieldNames() {
+        ReflectionDiffBuilder<TypeTestClass> reflectionDiffBuilder = new ReflectionDiffBuilder<>(new TypeTestClass(), new TypeTestChildClass(), SHORT_STYLE);
+        reflectionDiffBuilder.setExcludeFieldNames(null);
+        String[] excludeFieldNames = reflectionDiffBuilder.getExcludeFieldNames();
+        assertNotNull(excludeFieldNames);
+        assertEquals(0, excludeFieldNames.length);
+    }
+
+    @Test
+    public void testGetExcludeFieldNamesWithNullValuesInExcludedFieldNames() {
+        ReflectionDiffBuilder<TypeTestClass> reflectionDiffBuilder = new ReflectionDiffBuilder<>(new TypeTestClass(), new TypeTestChildClass(), SHORT_STYLE);","[{'comment': 'Use final where you can.', 'commenter': 'garydgregory'}]"
838,src/test/java/org/apache/commons/lang3/builder/ReflectionDiffBuilderTest.java,"@@ -48,10 +48,14 @@
         private final Object[] objectArrayField = {null};
         private static int staticField;
         private transient String transientField;
+        @DiffExclude
+        private String annotatedField = ""a"";
+        private String excludedField = ""a"";","[{'comment': 'You should test a non-transient null field.', 'commenter': 'garydgregory'}, {'comment': 'There is already a testcase `test_transient_field_difference` that validates this, there is no specific or new logic for transient fields that get excluded.', 'commenter': 'debae'}]"
838,src/test/java/org/apache/commons/lang3/builder/ReflectionDiffBuilderTest.java,"@@ -128,4 +133,44 @@ public void test_difference_in_inherited_field() {
         final DiffResult list = firstObject.diff(secondObject);
         assertEquals(1, list.getNumberOfDiffs());
     }
+
+    @Test
+    public void test_no_differences_excluded_field() {
+        final TypeTestClass firstObject = new TypeTestClass();
+        firstObject.excludedField = ""b"";
+        final TypeTestClass secondObject = new TypeTestClass();
+
+        final DiffResult list = firstObject.diff(secondObject);
+        assertEquals(0, list.getNumberOfDiffs());
+    }
+
+    @Test
+    public void test_no_differences_diff_exclude_annotated_field() {
+        final TypeTestClass firstObject = new TypeTestClass();
+        firstObject.annotatedField = ""b"";
+        final TypeTestClass secondObject = new TypeTestClass();
+
+        final DiffResult list = firstObject.diff(secondObject);
+        assertEquals(0, list.getNumberOfDiffs());
+    }","[{'comment': 'Maybe add a test that does both `annotatedField` and `excludedField` being excluded.', 'commenter': 'kinow'}, {'comment': 'Extra testcase added', 'commenter': 'debae'}]"
849,src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java,"@@ -385,6 +385,19 @@ public static String toStringExclude(final Object object, final Collection<Strin
         return toStringExclude(object, toNoNullStringArray(excludeFieldNames));
     }
 
+    /**
+     * Builds a String for a toString method with only the selected field names.
+     *
+     * @param object
+     *            The object to ""toString"".
+     * @param selectedFieldNames
+     *            The field names that must be on toString. Null selects nothing.","[{'comment': 'in case of Null parameter, What is the output?', 'commenter': 'rafaelweingartner'}, {'comment': 'In case the parameter is null or empty, it will skip the validation of the selected fields and will return the fields as is the current behavior.', 'commenter': 'GutoVeronezi'}, {'comment': 'I see. Can you add these details in the JavaDocs? When reading I got the impression that Null would return an empty string.', 'commenter': 'rafaelweingartner'}]"
849,src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java,"@@ -460,6 +490,11 @@ private static Object checkNotNull(final Object obj) {
      */
     protected String[] excludeFieldNames;
 
+    /**
+     * Field names that will be include in the output. All fields are included by default.","[{'comment': 's/will be include/will be included', 'commenter': 'kinow'}]"
866,src/main/java/org/apache/commons/lang3/CSVEscapeUtils.java,"@@ -0,0 +1,44 @@
+package org.apache.commons.lang3;","[{'comment': 'Every file in Lang must include a license header.', 'commenter': 'kinow'}, {'comment': 'This is confusing IMO, we already have an Apache Commons CSV component, we should not mix in public CSV code in Lang IMO. If this is absolutely needed it should be package-private but I am doubtful.', 'commenter': 'garydgregory'}]"
866,src/main/java/org/apache/commons/lang3/BooleanUtils.java,"@@ -681,13 +681,13 @@ public static Boolean toBooleanObject(final String str) {
             case 1: {
                 final char ch0 = str.charAt(0);
                 if (ch0 == 'y' || ch0 == 'Y' ||
-                    ch0 == 't' || ch0 == 'T' ||
-                    ch0 == '1') {
+                        ch0 == 't' || ch0 == 'T' ||
+                        ch0 == '1') {","[{'comment': ""I think this is just cosmetic, not really fixing an issue. Changes like this make things harder to review. It's better to discuss with the developers of the project before changing code style."", 'commenter': 'kinow'}, {'comment': 'I agree with @kinow ', 'commenter': 'garydgregory'}]"
866,src/main/java/org/apache/commons/lang3/BooleanUtils.java,"@@ -1132,4 +1132,4 @@ public static Boolean xor(final Boolean... array) {
     public BooleanUtils() {
     }
 
-}
+}","[{'comment': 'Missing newline.', 'commenter': 'kinow'}]"
866,src/main/java/org/apache/commons/lang3/time/GmtTimeZone.java,"@@ -31,6 +36,32 @@
     private static final int MINUTES_PER_HOUR = 60;
     private static final int HOURS_PER_DAY = 24;
 
+    private static final TimeZone timezone = new GmtTimeZone(false,0,0);
+    private static final Pattern GMT_PATTERN1 = Pattern.compile(""^(?:(?i)GMT)?([+-])?(\\d\\d?)?(:?(\\d\\d?))?$"");
+
+    public static TimeZone fetchGmtTimeZone(final String pattern) {","[{'comment': 'Other methods in this class follow the get/set pattern. This `fetchGmt...` method is being called from `FastTimeZone#getGmtTimeZone`. So it could probably stay as `getGmt...`, I think.', 'commenter': 'kinow'}]"
866,src/main/java/org/apache/commons/lang3/time/FastTimeZone.java,"@@ -29,14 +29,14 @@
 
     private static final Pattern GMT_PATTERN = Pattern.compile(""^(?:(?i)GMT)?([+-])?(\\d\\d?)?(:?(\\d\\d?))?$"");
 
-    private static final TimeZone GREENWICH = new GmtTimeZone(false, 0, 0);
+    //private static TimeZone GREENWICH =
 
     /**
      * Gets the GMT TimeZone.
      * @return A TimeZone with a raw offset of zero.
      */
     public static TimeZone getGmtTimeZone() {
-        return GREENWICH;
+        return new GmtTimeZone(false, 0, 0);","[{'comment': 'I believe the reason for the static object was to avoid instantiating a new object every time this method was called.', 'commenter': 'kinow'}]"
866,src/main/java/org/apache/commons/lang3/time/FastTimeZone.java,"@@ -29,14 +29,14 @@
 
     private static final Pattern GMT_PATTERN = Pattern.compile(""^(?:(?i)GMT)?([+-])?(\\d\\d?)?(:?(\\d\\d?))?$"");
 
-    private static final TimeZone GREENWICH = new GmtTimeZone(false, 0, 0);
+    //private static TimeZone GREENWICH =","[{'comment': 'We tend to only leave comments that are intended to help other developers, or things that are almost-ready to be finished, for instance. This one could probably be removed.', 'commenter': 'kinow'}]"
866,src/main/java/org/apache/commons/lang3/exception/ContextedRuntimeException.java,"@@ -214,13 +214,13 @@ public Object getFirstContextValue(final String label) {
         return this.exceptionContext.getContextEntries();
     }
 
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public Set<String> getContextLabels() {
-        return exceptionContext.getContextLabels();
-    }
+//    /**
+//     * {@inheritDoc}
+//     */
+//    @Override
+//    public Set<String> getContextLabels() {
+//        return exceptionContext.getContextLabels();
+//    }","[{'comment': ""It's hard to understand why this was commented out. This is also a public method. We cannot remove it without a major release - https://semver.org/"", 'commenter': 'kinow'}]"
866,src/main/java/org/apache/commons/lang3/CSVEscapeUtils.java,"@@ -0,0 +1,44 @@
+package org.apache.commons.lang3;
+
+import org.apache.commons.lang3.text.translate.CharSequenceTranslator;
+
+import java.io.IOException;
+import java.io.Writer;
+
+public class CSVEscapeUtils extends CharSequenceTranslator {","[{'comment': 'This is confusing IMO, we already have an Apache Commons CSV component, we should not mix in public CSV code in Lang IMO. If this is absolutely needed it should be package-private but I am doubtful.', 'commenter': 'garydgregory'}]"
866,src/main/java/org/apache/commons/lang3/StringEscapeUtils.java,"@@ -372,49 +333,6 @@ public int translate(final CharSequence input, final int index, final Writer out
             new NumericEntityUnescaper()
         );
 
-    /**
-     * Translator object for unescaping escaped Comma Separated Value entries.
-     *
-     * While {@link #unescapeCsv(String)} is the expected method of use, this
-     * object allows the CSV unescaping functionality to be used
-     * as the foundation for a custom translator.
-     *
-     * @since 3.0
-     */
-    public static final CharSequenceTranslator UNESCAPE_CSV = new CsvUnescaper();
-
-    static class CsvUnescaper extends CharSequenceTranslator {","[{'comment': ""This is a big -1. You cannot break binary compatibility. Run 'mvn' and watch for build failures."", 'commenter': 'garydgregory'}]"
869,src/main/java/org/apache/commons/lang3/ArrayUtils.java,"@@ -3790,6 +3790,7 @@ public static <T extends Comparable<? super T>> boolean isSorted(final T[] array
      * @param comparator the {@code Comparator} to compare over
      * @param <T> the datatype of the array
      * @return whether the array is sorted
+     * @throws IllegalArgumentException if {@code comparator == null}","[{'comment': 'This is a NullPointerExcception in git master. In general, please update the comment format to:\r\n```\r\n* @throws IllegalArgumentException if {@code comparator} is null\r\n```\r\nor\r\n```\r\n* @throws IllegalArgumentException if {@code comparator} is {@code null}\r\n```\r\nThis reads more like a comment than code.\r\n', 'commenter': 'garydgregory'}]"
869,src/main/java/org/apache/commons/lang3/reflect/TypeUtils.java,"@@ -1607,6 +1609,8 @@ private static String parameterizedTypeToString(final ParameterizedType paramete
      * @param rawClass the raw class to create a parameterized type instance for
      * @param typeVariableMap the map used for parameterization
      * @return {@link ParameterizedType}
+     * @throws NullPointerException if either {@code rawClass} or {@code typeVariable}","[{'comment': '`typeVariableMap`?', 'commenter': 'kinow'}, {'comment': 'Oops. Thanks for finding it. Fixed it!', 'commenter': 'dvmarcilio'}]"
877,src/main/java/org/apache/commons/lang3/Conversion.java,"@@ -447,16 +447,16 @@ public static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos) {
         src = paddedSrc;
         srcPos = 0;","[{'comment': 'This method appears to have been rewritten from a version that used `src` directly to a version that pads `src` to 4 values. However after the rewrite all the redundant length checks have not been removed. Looking at the git history the original version also had the padding. So this is a strange legacy bit of code from 10 years ago.\r\n\r\nIIUC the `srcPos` is set to zero and then never changed after this point. So its use could be removed, e.g. `srcPos + 3` is the same as `3`. Likewise all the checks against length are not required as `paddedSrc` is length 4. So you have removed some of them but not the rest starting at line 461.\r\n\r\nHowever a further look into this finds that this method and `binaryToHexDigit` are essentially the same method but with the endianness inverted. One method starts at the given position for the the lsb and increments the position up to 3 times to read the boolean bits. The other starts at the provided lsb counting **from the end** of the input array (this is not explicitly documented but is demonstrated in the javadoc) and decrements up to 3 times. The later method does this by extracting the range into a padded array of 4, the full logic of which has some issues when the provided srcPos is not inside the array (this is not tested in the unit tests).\r\n\r\nI think it makes more sense to remove the padding to 4 characters and leave the length checks in place. The method should be the same as `binaryToHexDigit` but with the indexing reversed. Thus:\r\n```Java\r\nboolean[] src = ...;\r\nint srcPos = ...;\r\nboolean[] reversed = src.clone();\r\nArrayUtils.reverse(reversed);\r\nbinaryToHexDigit(src, srcPos) == binaryBeMsb0ToHexDigit(reversed, srcPos);\r\n```\r\nI\'ve tested the above and it seems to be the intention of the the method:\r\n```Java\r\n@Test\r\npublic void testBinaryToHexDigitReverse() {\r\n    SplittableRandom rng = new SplittableRandom();\r\n    boolean[] x = new boolean[8];\r\n    for (int i = 0; i < 100; i++) {\r\n        Conversion.longToBinary(rng.nextLong(), 0, x, 0, 8);\r\n        for (int j = 1; j <= 8; j++) {\r\n            boolean[] a = Arrays.copyOf(x, j);\r\n            boolean[] b = a.clone();\r\n            ArrayUtils.reverse(b);\r\n            for (int k = 0; k < j; k++) {\r\n                Assertions.assertEquals(Conversion.binaryToHexDigit(a, k), \r\n                                        Conversion.binaryBeMsb0ToHexDigit(b, k));\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nThe unit tests for these methods do not cover using a bad input `srcPos` outside the array. In the case of `binaryToHexDigit` it would throw an IOOBE when using `src[srcPos]`. In the case of `binaryBeMsb0ToHexDigit` the padding logic may throw an exception but I have not checked.\r\n\r\nI would update both methods with a check that `srcPos` is inside the input array, something like the `Objects.checkIndex` method from JDK 9:\r\n```Java\r\n      if (Integer.compareUnsigned(srcPos, src.length) >= 0) {\r\n        throw new IndexOutOfBoundsException(srcPos + "" is not within array length "" + src.length);\r\n      }\r\n```\r\nThis would make the check on `src.length` redundant as 0 is not within an array of length 0.\r\n\r\nThe updated method becomes:\r\n```Java\r\npublic static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos) {\r\n    if (src.length == 0) {\r\n        throw new IllegalArgumentException(""Cannot convert an empty array."");\r\n    }\r\n    // JDK 9: Objects.checkIndex(int index, int length)\r\n    if (Integer.compareUnsigned(srcPos, src.length) >= 0) {\r\n        throw new IndexOutOfBoundsException(srcPos + "" is not within array length "" + src.length);\r\n    }\r\n    // Little-endian bit 0 position\r\n    final int pos = src.length - 1 - srcPos;\r\n    if (3 <= pos && src[pos - 3]) {\r\n        if (src[pos - 2]) {\r\n            if (src[pos - 1]) {\r\n                return src[pos] ? \'f\' : \'e\';\r\n            }\r\n            return src[pos] ? \'d\' : \'c\';\r\n        }\r\n        if (src[pos - 1]) {\r\n            return src[pos] ? \'b\' : \'a\';\r\n        }\r\n        return src[pos] ? \'9\' : \'8\';\r\n    }\r\n    if (2 <= pos && src[pos - 2]) {\r\n        if (src[pos - 1]) {\r\n            return src[pos] ? \'7\' : \'6\';\r\n        }\r\n        return src[pos] ? \'5\' : \'4\';\r\n    }\r\n    if (1 <= pos && src[pos - 1]) {\r\n        return src[pos] ? \'3\' : \'2\';\r\n    }\r\n    return src[pos] ? \'1\' : \'0\';\r\n```\r\n\r\nThis passes the existing unit tests and the extra test for bit reversal shown above. The check for a zero length array is redundant with the index test but I left it in as it would be a breaking change. The existing unit tests do expect an IllegalArgumentException for this case.\r\n\r\nIt has the advantage that it is clearly the same as `binaryToHexDigit` but working from the end of the array backwards, i.e. the input array is big-endian most-significant-byte at position 0 (BeMsb0)\r\n', 'commenter': 'aherbert'}, {'comment': ""HI @aherbert \r\nThat is actually a great approach. Did't see that.\r\nChanged.\r\nTY "", 'commenter': 'arturobernalg'}]"
877,src/main/java/org/apache/commons/lang3/Conversion.java,"@@ -435,39 +435,40 @@ public static char binaryBeMsb0ToHexDigit(final boolean[] src) {
      * @return a hexadecimal digit representing the selected bits
      * @throws IllegalArgumentException if {@code src} is empty
      * @throws NullPointerException if {@code src} is {@code null}
+     * @throws IndexOutOfBoundsException if {@code srcPos} is outside the array.
      */
     public static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos) {
         if (src.length == 0) {","[{'comment': 'To leave only one branch check on the main path I would put this check inside the other check:\r\n```Java\r\nif (Integer.compareUnsigned(srcPos, src.length) >= 0) {\r\n    // Throw the correct exception\r\n    if (src.length == 0) {\r\n        throw new IllegalArgumentException(""Cannot convert an empty array."");\r\n    }\r\n    throw new IndexOutOfBoundsException(srcPos + "" is not within array length "" + src.length);\r\n}\r\n```', 'commenter': 'aherbert'}, {'comment': 'done', 'commenter': 'arturobernalg'}]"
877,src/test/java/org/apache/commons/lang3/ConversionTest.java,"@@ -413,6 +415,29 @@ public void testBinaryBeMsb0ToHexDigit_2args() {
 
     }
 
+    @Test
+    public void testBinaryToHexDigitReverse() {
+        final SplittableRandom rng = new SplittableRandom();
+        final boolean[] x = new boolean[8];
+        for (int i = 0; i < 100; i++) {
+            Conversion.longToBinary(rng.nextLong(), 0, x, 0, 8);
+            for (int j = 1; j <= 8; j++) {
+                final boolean[] a = Arrays.copyOf(x, j);
+                final boolean[] b = a.clone();
+                ArrayUtils.reverse(b);
+                for (int k = 0; k < j; k++) {
+                    assertEquals(Conversion.binaryToHexDigit(a, k),
+                            Conversion.binaryBeMsb0ToHexDigit(b, k));
+                }
+            }
+        }
+    }
+
+    @Test
+    public void binaryBeMsb0ToHexDigitPosOutsideArray() {
+        assertThrows(IndexOutOfBoundsException.class, () -> Conversion.binaryBeMsb0ToHexDigit(new boolean[8], 99));","[{'comment': 'Add a test for the index as negative or a match to the array length.', 'commenter': 'aherbert'}, {'comment': 'done', 'commenter': 'arturobernalg'}, {'comment': 'I would have just added to the existing test:\r\n```Java\r\n@Test\r\npublic void binaryBeMsb0ToHexDigitPosOutsideArray() {\r\n    final boolean[] array = new boolean[8];\r\n    for (final int index : new int[] {-1, array.length, array.length + 100}) {\r\n        assertThrows(IndexOutOfBoundsException.class,\r\n            () -> Conversion.binaryBeMsb0ToHexDigit(array, index),\r\n            () -> ""Index: "" + index;\r\n        );\r\n    }\r\n}\r\n```\r\nOr perhaps use a parameterized test:\r\n```Java\r\n@ParameterizedTest\r\n@ValueSource(ints = {-1, 8, 99})\r\npublic void binaryBeMsb0ToHexDigitPosOutsideArray(int index) {\r\n    assertThrows(IndexOutOfBoundsException.class,\r\n        () -> Conversion.binaryBeMsb0ToHexDigit(new boolean[8], index));\r\n}\r\n```\r\nAnyway can you rebase this on master and then it is good to merge. Thanks.\r\n', 'commenter': 'aherbert'}, {'comment': 'done\r\n', 'commenter': 'arturobernalg'}]"
889,src/main/java/org/apache/commons/lang3/StringUtils.java,"@@ -1588,6 +1588,59 @@ public static String defaultString(final String str, final String nullDefault) {
         return Objects.toString(str, nullDefault);
     }
 
+    /**
+     * <p>Returns either the passed in String,
+     * or if the String is {@code null}, an empty String ("""").</p>
+     *
+     * <pre>
+     * StringUtils.defaultString(null)  = """"
+     * StringUtils.defaultString("""")    = """"
+     * StringUtils.defaultString(""bat"") = ""bat""
+     * StringUtils.defaultString(1) = ""1""
+     * StringUtils.defaultString(Integer.MIN_VALUE) = ""-2147483648""
+     * </pre>
+     *
+     * @see Objects#toString(Object)
+     * @see String#valueOf(Object)
+     * @param str  the Object to check, may be null
+     * @return the passed in String, or the empty String if it
+     *  was {@code null}
+     */
+    public static String defaultString(final Object object) {
+        if(object == null)
+            return """";
+
+        return Objects.toString(object);
+    }
+
+    /**
+     * Returns either the given String, or if the String is
+     * {@code null}, {@code nullDefault}.
+     *
+     * <pre>
+     * StringUtils.defaultString(null, ""NULL"")  = ""NULL""
+     * StringUtils.defaultString("""", ""NULL"")    = """"
+     * StringUtils.defaultString(""bat"", ""NULL"") = ""bat""
+     * StringUtils.defaultString(1, ""20"") = ""1""
+     * StringUtils.defaultString(Integer.MIN_VALUE, ""200"") = ""-2147483648""
+     * </pre>
+     *
+     * @see Objects#toString(Object, String)
+     * @see String#valueOf(Object)
+     * @param str  the String to check, may be null
+     * @param nullDefault  the default String to return
+     *  if the input is {@code null}, may be null
+     * @return the passed in String, or the default if it was {@code null}
+     * @deprecated Use {@link Objects#toString(Object, String)}
+     */
+    @Deprecated
+    public static String defaultString(final Object object, final String nullDefault) {
+        if(object == null)
+            return defaultString(nullDefault);
+
+        return Objects.toString(object);","[{'comment': 'Hi @EACUAMBA ,\r\n\r\nI think instead of this new method, users could just use the Java 8+ `Objects.toString(Object o, String nullDefault)` - https://docs.oracle.com/javase/8/docs/api/java/util/Objects.html#toString-java.lang.Object-java.lang.String-', 'commenter': 'kinow'}, {'comment': 'Hi @kinow,\r\n\r\nYou are right, the toString method  in Objects can work too.  Thanks.', 'commenter': 'EACUAMBA'}]"
903,src/main/java/org/apache/commons/lang3/CharUtils.java,"@@ -115,6 +115,33 @@ public static Character toCharacterObject(final String str) {
         return Character.valueOf(str.charAt(0));
     }
 
+    /**
+     * <p>Converts the String to a Character using the first character, returning a
+     *  default value if {@code null} or empty is passed in.</p>
+     *
+     * <p>For ASCII 7 bit characters, this uses a cache that will return the
+     * same Character object each time.</p>
+     *
+     * <pre>
+     *   CharUtils.toCharacterObject(null, 'A') = 'A'
+     *   CharUtils.toCharacterObject("""", 'A')   = 'A'
+     *   CharUtils.toCharacterObject(""A"")  = 'A'","[{'comment': 'These docs require updating too', 'commenter': 'aherbert'}, {'comment': 'thank you @aherbert \r\nFixed.\r\n', 'commenter': 'arturobernalg'}]"
903,src/main/java/org/apache/commons/lang3/CharUtils.java,"@@ -114,6 +114,33 @@ public static Character toCharacterObject(final String str) {
         return StringUtils.isEmpty(str) ? null : Character.valueOf(str.charAt(0));
     }
 
+    /**
+     * <p>Converts the String to a Character using the first character, returning a
+     *  default value if {@code null} or empty is passed in.</p>
+     *
+     * <p>For ASCII 7 bit characters, this uses a cache that will return the
+     * same Character object each time.</p>
+     *
+     * <pre>
+     *   CharUtils.toCharacterObject(null, 'A') = 'A'
+     *   CharUtils.toCharacterObject("""", 'A')   = 'A'
+     *   CharUtils.toCharacterObject(""A"", 'D')  = 'A'
+     *   CharUtils.toCharacterObject(""BA"", 'D') = 'B'
+     * </pre>
+     *
+     * @param str  the character to convert
+     * @param defaultValue the value to use if the str is null or empty.
+     * @return the Character value of the first letter of the String or the default if null.
+     * @since 3.13.0
+     */
+    public static Character toCharacterObject(final String str, final Character defaultValue) {
+      final Character character = toCharacterObject(str);
+      if (character == null){
+          return defaultValue;
+      }
+      return character;
+    }","[{'comment': 'I think the rest of the code is using 4 spaces (you used 4 spaces in the test).', 'commenter': 'kinow'}, {'comment': 'Better like this IMO: `return StringUtils.isEmpty(str) ? defaultValue : Character.valueOf(str.charAt(0));`', 'commenter': 'garydgregory'}, {'comment': 'I think if you still uses ternary conditions in 2023, you are a really bad developer. For the love of god, understand ternaries are unreadable and are a very bad practice to show junior developers.', 'commenter': 'class101'}, {'comment': ""> I think if you still uses ternary conditions in 2023, you are a really bad developer. For the love of god, understand ternaries are unreadable and are a very bad practice to show junior developers.\r\n\r\nThe ternary expression is an uncontroversial feature of the Java language as well as of most programming languages. This is the first time I've ever read anyone express dismay at its usage. For a great overview of best practices, I recommend Josh Block's Effective Java."", 'commenter': 'garydgregory'}]"
903,src/main/java/org/apache/commons/lang3/CharUtils.java,"@@ -114,6 +114,33 @@ public static Character toCharacterObject(final String str) {
         return StringUtils.isEmpty(str) ? null : Character.valueOf(str.charAt(0));
     }
 
+    /**
+     * <p>Converts the String to a Character using the first character, returning a
+     *  default value if {@code null} or empty is passed in.</p>
+     *
+     * <p>For ASCII 7 bit characters, this uses a cache that will return the
+     * same Character object each time.</p>
+     *
+     * <pre>
+     *   CharUtils.toCharacterObject(null, 'A') = 'A'
+     *   CharUtils.toCharacterObject("""", 'A')   = 'A'
+     *   CharUtils.toCharacterObject(""A"", 'D')  = 'A'
+     *   CharUtils.toCharacterObject(""BA"", 'D') = 'B'
+     * </pre>
+     *
+     * @param str  the character to convert","[{'comment': 'I think `str` is not a character too, sorry forgot to review the text in the javadocs.', 'commenter': 'kinow'}, {'comment': ""Also worth checking if the docs are ending sentences with dot or without it. I think this `@param` doesn't use that, but the next ones does."", 'commenter': 'kinow'}]"
904,src/test/java/org/apache/commons/lang3/ValidateTest.java,"@@ -774,6 +774,45 @@ void shouldThrowIllegalArgumentExceptionWithGivenMessageForCollectionWithNullEle
         }
     }
 
+    @Nested
+    class ValidState {
+
+        @Nested
+        class WitMessage {
+            @Test
+            void shouldNotThrowExceptionForValidIndex() {
+                Validate.validState(true, ""The Message"");
+            }
+
+            @Test
+            void shouldThrowExceptionForTrueExpression() {
+                assertThrows(
+                        IllegalStateException.class,
+                        () ->    Validate.validState(false, ""The Message""));
+","[{'comment': 'Too much whitespace IMO.', 'commenter': 'garydgregory'}]"
904,src/test/java/org/apache/commons/lang3/builder/EqualsBuilderTest.java,"@@ -443,6 +446,16 @@ public void testObjectRecursiveGenericInteger() {
         assertFalse(new EqualsBuilder().setTestRecursive(true).append(o1_b, o2).isEquals());
     }
 
+    @Test
+    public void testObjectsBypassReflectionClasses() {
+","[{'comment': 'Too much whitespace.', 'commenter': 'garydgregory'}]"
904,src/test/java/org/apache/commons/lang3/ValidateTest.java,"@@ -774,6 +774,45 @@ void shouldThrowIllegalArgumentExceptionWithGivenMessageForCollectionWithNullEle
         }
     }
 
+    @Nested
+    class ValidState {
+
+        @Nested
+        class WitMessage {
+            @Test
+            void shouldNotThrowExceptionForValidIndex() {
+                Validate.validState(true, ""The Message"");
+            }
+
+            @Test
+            void shouldThrowExceptionForTrueExpression() {
+                assertThrows(
+                        IllegalStateException.class,
+                        () ->    Validate.validState(false, ""The Message""));
+
+            }
+
+        }
+
+        @Nested
+        class WithoutMessage {
+
+            @Test
+            void shouldNotThrowExceptionForTrueExpression() {
+                Validate.validState(true);
+            }
+
+            @Test
+            void shouldThrowExceptionForTrueExpression() {
+                assertThrows(","[{'comment': 'You can put stuff like this all on one line IMO.', 'commenter': 'garydgregory'}]"
904,src/test/java/org/apache/commons/lang3/RangeTest.java,"@@ -103,6 +103,10 @@ public void testBetweenWithCompare() {
         assertTrue(rbstr.contains(""i""), ""should contain i"");
         assertFalse(rbstr.contains(""houses""), ""should not contain houses"");
         assertFalse(rbstr.contains(""""), ""should not contain ''"");
+
+        assertThrows(","[{'comment': 'You can put this all on one line IMO.', 'commenter': 'garydgregory'}]"
904,src/test/java/org/apache/commons/lang3/NotImplementedExceptionTest.java,"@@ -44,6 +45,9 @@ public void testConstructors() {
         assertCorrect(""Issue in (Throwable, String)"", nie, nested.toString(), nested, code);
         nie = new NotImplementedException(message, nested, code);
         assertCorrect(""Issue in (String, Throwable, String)"", nie, message, nested, code);
+
+        final NotImplementedException nieNullCode = new NotImplementedException();","[{'comment': 'Do we really need the local variable?', 'commenter': 'garydgregory'}]"
904,src/test/java/org/apache/commons/lang3/ClassUtilsTest.java,"@@ -410,6 +420,9 @@ class Named {
         }.getClass()));
         assertEquals(""org.apache.commons.lang3"", ClassUtils.getPackageCanonicalName(Named.class));
         assertEquals(""org.apache.commons.lang3"", ClassUtils.getPackageCanonicalName(Inner.class));
+        assertEquals(StringUtils.EMPTY, ClassUtils.getPackageCanonicalName((Class<?>) null));
+","[{'comment': 'Remove extra two blank lines.', 'commenter': 'garydgregory'}]"
904,src/test/java/org/apache/commons/lang3/ClassUtilsTest.java,"@@ -52,6 +52,8 @@
 @SuppressWarnings(""boxing"") // JUnit4 does not support primitive equality testing apart from long
 public class ClassUtilsTest  {
 
+    private static final String DEFAULT_CANONICAL_NAME = ""java.lang.Object"";","[{'comment': 'Maybe `DEFAULT_CANONICAL_NAME` -> `OBJECT_CANONICAL_NAME`?', 'commenter': 'garydgregory'}]"
904,src/test/java/org/apache/commons/lang3/ArchUtilsTest.java,"@@ -113,6 +113,10 @@ public void testArchLabels() {
     public void testGetProcessor() {
         assertNotNull(ArchUtils.getProcessor(X86));
         assertNull(ArchUtils.getProcessor(""NA""));
+
+        final Processor processor = ArchUtils.getProcessor();
+        assertTrue(processor.isX86());","[{'comment': 'This test will fail on machines with other arches (e.g. Apple M1 returns `Processor.Type.AARCH_64`). I suggest we remove it.\r\n\r\ncc @garydgregory @arturobernalg ', 'commenter': 'tisonkun'}]"
913,src/test/java/org/apache/commons/lang3/StringUtilsTest.java,"@@ -1623,13 +1622,9 @@ public void testReCapitalize() {
     public void testRemove_char() {
         // StringUtils.remove(null, *)       = null
         assertNull(StringUtils.remove(null, 'a'));
-        assertNull(StringUtils.remove(null, 'a'));
-        assertNull(StringUtils.remove(null, 'a'));
 
         // StringUtils.remove("""", *)          = """"
         assertEquals("""", StringUtils.remove("""", 'a'));
-        assertEquals("""", StringUtils.remove("""", 'a'));
-        assertEquals("""", StringUtils.remove("""", 'a'));","[{'comment': 'This method, `testRemove_char`, appears to have been based off the `testRemove_String`. You are correct these three statements are duplicated and can be removed. But in `testRemove_String` there\'s one test case that must be added here as well:\r\n\r\n```\r\nassertNull(StringUtils.remove(null, null));\r\n&\r\nassertEquals("""", StringUtils.remove("""", null));\r\n```\r\n\r\nCan you add them, please, @shalk ?', 'commenter': 'kinow'}, {'comment': 'done', 'commenter': 'shalk'}]"
913,src/test/java/org/apache/commons/lang3/StringUtilsTest.java,"@@ -2774,7 +2769,6 @@ public void testSplitPreserveAllTokens_StringChar() {
         assertEquals(""b"", res[1]);
         assertEquals(""c"", res[2]);
         assertEquals("""", res[3]);
-        assertEquals("""", res[3]);","[{'comment': 'I believe this was supposed to be `assertEquals("""", res[4]);`. The other tests have a similar case, where they verify the indexes from `0` to the last index available (`4` in this case). Can you change it, please?', 'commenter': 'kinow'}, {'comment': 'done', 'commenter': 'shalk'}]"
926,src/site/xdoc/article2_4.xml,"@@ -28,11 +28,11 @@ limitations under the License.
 issue to see what went on in the year of development between Lang 2.3 and 2.4.</p>
 <section name=""Deprecations"">
 <p>First, let us start with a couple of deprecations. As you can see in the release notes, we chose
-to deprecate the <a href=""https://commons.apache.org/lang/api-release/org/apache/commons/lang/ObjectUtils.html#appendIdentityToString(java.lang.StringBuffer,%20java.lang.Object)""><code>ObjectUtils.appendIdentityToString(StringBuffer, Object)</code></a> method as its
+to deprecate the <a href=""https://commons.apache.org/proper/commons-lang/javadocs/api-2.6/org/apache/commons/lang/ObjectUtils.html#appendIdentityToString(java.lang.StringBuffer,%20java.lang.Object)""><code>ObjectUtils.appendIdentityToString(StringBuffer, Object)</code></a> method as its","[{'comment': 'I do not think it makes sense for docs for version 2.4 to point to 2.6 pages.', 'commenter': 'garydgregory'}, {'comment': ""You are right, I have been lazy on that one. That's fixed for both 2.4 and 2.5 changelogs."", 'commenter': 'marcwrobel'}]"
926,src/main/java/org/apache/commons/lang3/CharEncoding.java,"@@ -23,14 +23,14 @@
 /**
  * <p>Character encoding names required of every implementation of the Java platform.</p>
  *
- * <p>According to <a href=""http://docs.oracle.com/javase/1.3/docs/api/java/lang/package-summary.html#charenc"">JRE character
+ * <p>According to <a href=""https://docs.oracle.com/javase/6/docs/api/java/lang/package-summary.html#charenc"">JRE character","[{'comment': 'There are no character encoding name at that URL; did you mean to point to https://docs.oracle.com/javase/8/docs/technotes/guides/intl/encoding.doc.html ?', 'commenter': 'garydgregory'}, {'comment': 'I found the original page on https://web.archive.org/web/20111127040714/http://docs.oracle.com/javase/1.3/docs/api/java/lang/package-summary.html.\r\n\r\nI found that https://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html now contains an equivalent documentation (paragraph _Standard charsets_). I will update the link accordingly.', 'commenter': 'marcwrobel'}]"
926,src/main/java/org/apache/commons/lang3/CharEncoding.java,"@@ -23,14 +23,14 @@
 /**
  * <p>Character encoding names required of every implementation of the Java platform.</p>
  *
- * <p>According to <a href=""http://docs.oracle.com/javase/1.3/docs/api/java/lang/package-summary.html#charenc"">JRE character
+ * <p>According to <a href=""https://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html"">JRE character","[{'comment': 'Javadoc references should be to Java **8** since this is the Java level this component requires.\r\n', 'commenter': 'garydgregory'}, {'comment': 'Fixed', 'commenter': 'marcwrobel'}]"
926,src/main/java/org/apache/commons/lang3/CharUtils.java,"@@ -46,7 +46,7 @@ public class CharUtils {
     /**
      * Carriage return character CR ('\r', Unicode 000d).
      *
-     * @see <a href=""http://docs.oracle.com/javase/specs/jls/se7/html/jls-3.html#jls-3.10.6"">JLF: Escape Sequences
+     * @see <a href=""https://docs.oracle.com/javase/specs/jls/se7/html/jls-3.html#jls-3.10.6"">JLF: Escape Sequences","[{'comment': 'Should point to Java 8, not 7.', 'commenter': 'garydgregory'}, {'comment': 'Fixed', 'commenter': 'marcwrobel'}]"
926,src/main/java/org/apache/commons/lang3/SystemUtils.java,"@@ -1084,7 +1084,7 @@ public class SystemUtils {
     // -----------------------------------------------------------------------
     // These MUST be declared after those above as they depend on the
     // values being set up
-    // OS names from http://www.vamphq.com/os.html
+    // OS names from http://lopica.sourceforge.net/os.html","[{'comment': 'Why? Let\'s not replace one (insecure) URL with another: ""The connection to lopica.sourceforge.net is not secure"" Also the comment is no longer true since we did not, in fact, get the data from lopica.', 'commenter': 'garydgregory'}, {'comment': 'I checked on wayback machine and this page was moved to this url. The old domain now hosts the ""Headquarter of Vampire Fetishists"" ;).\r\n\r\nI removed the link since this is not true.', 'commenter': 'marcwrobel'}]"
926,src/main/java/org/apache/commons/lang3/builder/HashCodeBuilder.java,"@@ -37,7 +37,7 @@
  *
  * <p>
  * This class enables a good {@code hashCode} method to be built for any class. It follows the rules laid out in
- * the book <a href=""http://www.oracle.com/technetwork/java/effectivejava-136174.html"">Effective Java</a> by Joshua Bloch. Writing a
+ * the book <a href=""https://www.oracle.com/technetwork/java/effectivejava-136174.html"">Effective Java</a> by Joshua Bloch. Writing a","[{'comment': 'There is no such page, it redirects to https://www.oracle.com/java/technologies/effectivejava.html', 'commenter': 'garydgregory'}, {'comment': 'URL replaced by https://www.oracle.com/java/technologies/effectivejava.html.', 'commenter': 'marcwrobel'}, {'comment': 'Did you change the URL? I still see the old one.', 'commenter': 'garydgregory'}]"
926,src/site/xdoc/building.xml,"@@ -24,8 +24,8 @@ limitations under the License.
 <!-- ================================================== -->
 <section name=""Overview"">
 <p>
-  Commons Lang uses <a href=""http://maven.apache.org"">Maven</a> or
-  <a href=""http://ant.apache.org"">Ant</a> as a build system.
+  Commons Lang uses <a href=""https://maven.apache.org"">Maven</a> or
+  <a href=""https://ant.apache.org"">Ant</a> as a build system.","[{'comment': '-1: We do not use Ant, only Maven.', 'commenter': 'garydgregory'}, {'comment': 'This PR is primarily about fixing the links. But I removed the reference to Ant.', 'commenter': 'marcwrobel'}]"
926,src/test/java/org/apache/commons/lang3/StringUtilsContainsTest.java,"@@ -105,7 +105,7 @@ public void testContainsAny_StringCharArray() {
     }
 
     /**
-     * See http://www.oracle.com/technetwork/articles/javase/supplementary-142654.html
+     * See https://www.oracle.com/technetwork/articles/javase/supplementary-142654.html","[{'comment': 'There is no such URL, it redirects to https://www.oracle.com/technical-resources/articles/javase/supplementary.html\r\n', 'commenter': 'garydgregory'}, {'comment': 'Done.', 'commenter': 'marcwrobel'}]"
926,src/main/java/org/apache/commons/lang3/builder/EqualsBuilder.java,"@@ -34,7 +34,7 @@
  *
  * <p> This class provides methods to build a good equals method for any
  * class. It follows rules laid out in
- * <a href=""http://www.oracle.com/technetwork/java/effectivejava-136174.html"">Effective Java</a>
+ * <a href=""https://www.oracle.com/technetwork/java/effectivejava-136174.html"">Effective Java</a>","[{'comment': 'Redirects to https://www.oracle.com/java/technologies/effectivejava.html', 'commenter': 'garydgregory'}, {'comment': '@marcwrobel ping?', 'commenter': 'garydgregory'}, {'comment': '@garydgregory, I cannot update the PR for the time being. Feel free to apply the necessary changes. ', 'commenter': 'marcwrobel'}]"
930,src/main/java/org/apache/commons/lang3/builder/DiffBuilder.java,"@@ -100,6 +100,7 @@
      *            test is enabled and returns true.  The result of this test
      *            is never changed throughout the life of this {@link DiffBuilder}.
      * @throws IllegalArgumentException
+     * @throws NullPointerException","[{'comment': ""Indentation does not seem to match what's above."", 'commenter': 'garydgregory'}]"
930,src/main/java/org/apache/commons/lang3/builder/HashCodeBuilder.java,"@@ -352,7 +352,8 @@ public static int reflectionHashCode(final int initialNonZeroOddNumber, final in
      *             if the Object is {@code null}
      * @throws IllegalArgumentException
      *             if the number is zero or even
-     *
+     * @throws NullPointerException
+     *			   if the Object is {@code null}","[{'comment': ""Indentation does not seem to match what's above. Name the parameter, not a generic type like Object."", 'commenter': 'garydgregory'}]"
935,src/main/java/org/apache/commons/lang3/math/Fraction.java,"@@ -31,8 +31,10 @@
  * based and thus suffers from various overflow issues. For a BigInteger based
  * equivalent, please see the Commons Math BigFraction class. </p>
  *
+ * @deprecated for fraction implementation from commons-numbers","[{'comment': 'Please add a URL to the Javadoc for the favored implementation.', 'commenter': 'garydgregory'}, {'comment': 'Added reference to the favored implementation', 'commenter': 'rednikeeg'}]"
935,src/main/java/org/apache/commons/lang3/math/Fraction.java,"@@ -31,7 +31,8 @@
  * based and thus suffers from various overflow issues. For a BigInteger based
  * equivalent, please see the Commons Math BigFraction class. </p>
  *
- * @deprecated for fraction implementation from commons-numbers
+ * @deprecated for <a href=""https://commons.apache.org/proper/commons-math/javadocs/api-3.6.1/index.html"">Fraction</a>
+ * from commons-numbers","[{'comment': 'Still not quite right: You talk about Commons Numbers but link to Commons Math as a whole. You want the URL to the Commons Numbers Fraction package or class.', 'commenter': 'garydgregory'}, {'comment': 'Aw, sorry, resolved that moment already', 'commenter': 'rednikeeg'}]"
935,src/main/java/org/apache/commons/lang3/math/Fraction.java,"@@ -31,8 +31,11 @@
  * based and thus suffers from various overflow issues. For a BigInteger based
  * equivalent, please see the Commons Math BigFraction class. </p>
  *
+ * @deprecated for <a href=""https://commons.apache.org/proper/commons-math/javadocs/api-3.6.1/org/apache/commons/math3/fraction/Fraction.html"">Fraction</a>","[{'comment': ""We can't just deprecate the class without documenting how to port your current code to the other API IMO. For example, what do you do with `Fraction#invert()`? Each method must be documented, otherwise, it's a disservice, and everyone using the class is left having to do their own investigation and mapping."", 'commenter': 'garydgregory'}]"
938,src/main/java/org/apache/commons/lang3/math/Fraction.java,"@@ -517,7 +517,7 @@ public Fraction abs() {
      * <p>The returned fraction is in reduced form.</p>
      *
      * @param power  the power to raise the fraction to
-     * @return {@code this} if the power is one, {@link ONE} if the power
+     * @return {@code this} if the power is one, {@link Fraction#ONE} if the power","[{'comment': ""You can just say `{@link #ONE}` IIRC, you don't need to refer to your own class name."", 'commenter': 'garydgregory'}, {'comment': 'true. Changed.', 'commenter': 'arturobernalg'}]"
953,src/main/java/org/apache/commons/lang3/Validate.java,"@@ -156,6 +156,30 @@ public static void isTrue(final boolean expression, final String message, final
         }
     }
 
+    /**
+     * Validate that the argument condition is {@code true}; otherwise
+     * throwing an exception. This method is useful when validating according
+     * to an arbitrary boolean expression, such as validating a
+     * primitive number or using your own custom validation expression.
+     *
+     * <pre>
+     * Validate.isTrue(i &gt; 0, ""The value must be greater than 0"");
+     * Validate.isTrue(myObject.isOk(), ""The object is not okay"");</pre>
+     *
+     * <p>The exception message will be converted to a string using String.valueOf(Object).</p>
+     *
+     * @param expression  the boolean expression to check
+     * @throws IllegalArgumentException if expression is {@code false}
+     * @see #isTrue(boolean, String, long)
+     * @see #isTrue(boolean, String, double)
+     * @see #isTrue(boolean, String, Object...)
+     */
+    public static void isTrue(final boolean expression, final String message) {
+        if (!expression) {
+            throw new IllegalArgumentException(String.valueOf(message));","[{'comment': '`String.valueOf(String)` is not required. Note that String.valueOf(null) will return null and that is handled fine by the IllegalArgumentException constructor. So just pass through the String message argument (which can be null).\r\n', 'commenter': 'aherbert'}, {'comment': 'Done.', 'commenter': 'stawirej'}]"
953,src/main/java/org/apache/commons/lang3/Validate.java,"@@ -156,6 +156,30 @@ public static void isTrue(final boolean expression, final String message, final
         }
     }
 
+    /**
+     * Validate that the argument condition is {@code true}; otherwise
+     * throwing an exception. This method is useful when validating according
+     * to an arbitrary boolean expression, such as validating a
+     * primitive number or using your own custom validation expression.
+     *
+     * <pre>
+     * Validate.isTrue(i &gt; 0, ""The value must be greater than 0"");
+     * Validate.isTrue(myObject.isOk(), ""The object is not okay"");</pre>
+     *
+     * <p>The exception message will be converted to a string using String.valueOf(Object).</p>
+     *
+     * @param expression  the boolean expression to check","[{'comment': 'There is no `@param` tag for `message`.', 'commenter': 'aherbert'}, {'comment': 'Done.', 'commenter': 'stawirej'}]"
953,src/main/java/org/apache/commons/lang3/Validate.java,"@@ -156,6 +156,30 @@ public static void isTrue(final boolean expression, final String message, final
         }
     }
 
+    /**
+     * Validate that the argument condition is {@code true}; otherwise
+     * throwing an exception. This method is useful when validating according
+     * to an arbitrary boolean expression, such as validating a
+     * primitive number or using your own custom validation expression.
+     *
+     * <pre>
+     * Validate.isTrue(i &gt; 0, ""The value must be greater than 0"");
+     * Validate.isTrue(myObject.isOk(), ""The object is not okay"");</pre>
+     *
+     * <p>The exception message will be converted to a string using String.valueOf(Object).</p>","[{'comment': 'This is not required.', 'commenter': 'aherbert'}, {'comment': 'Done.', 'commenter': 'stawirej'}]"
953,src/main/java/org/apache/commons/lang3/Validate.java,"@@ -156,6 +156,30 @@ public static void isTrue(final boolean expression, final String message, final
         }
     }
 
+    /**
+     * Validate that the argument condition is {@code true}; otherwise
+     * throwing an exception. This method is useful when validating according","[{'comment': '`an exception with the specified message`\r\n\r\nNote: This change makes the code example on line 143 invalid. Please update the javadoc in the preceding method to remove:\r\n```Validate.isTrue(myObject.isOk(), ""The object is not okay"");</pre>```\r\n', 'commenter': 'aherbert'}, {'comment': 'Done.', 'commenter': 'stawirej'}]"
953,src/main/java/org/apache/commons/lang3/Validate.java,"@@ -156,6 +155,29 @@ public static void isTrue(final boolean expression, final String message, final
         }
     }
 
+    /**
+     * Validate that the argument condition is {@code true}; otherwise
+     * throwing an exception with the specified message. This method is useful when validating according
+     * to an arbitrary boolean expression, such as validating a
+     * primitive number or using your own custom validation expression
+     *
+     * <pre>
+     * Validate.isTrue(i &gt; 0, ""The value must be greater than 0"");
+     * Validate.isTrue(myObject.isOk(), ""The object is not okay"");</pre>
+     *
+     * @param expression  the boolean expression to check
+     * @param message  the exception message if invalid
+     * @throws IllegalArgumentException if expression is {@code false}
+     * @see #isTrue(boolean, String, long)
+     * @see #isTrue(boolean, String, double)
+     * @see #isTrue(boolean, String, Object...)
+     */","[{'comment': 'Add a `@Since 3.13.0`', 'commenter': 'aherbert'}, {'comment': 'Done.', 'commenter': 'stawirej'}]"
953,src/main/java/org/apache/commons/lang3/Validate.java,"@@ -1265,7 +1264,11 @@ public static void isAssignableFrom(final Class<?> superType, final Class<?> typ
     public static void isAssignableFrom(final Class<?> superType, final Class<?> type, final String message, final Object... values) {
         // TODO when breaking BC, consider returning type
         if (!superType.isAssignableFrom(type)) {
-            throw new IllegalArgumentException(String.format(message, values));
+            throw new IllegalArgumentException(getMessage(message, values));
         }
     }
+
+    private static String getMessage(final String message, final Object... values) {","[{'comment': 'This all looks fine. Please add a comment to the private method, e.g. \r\n```\r\nGet the message using {@link String#format(String, Object...) String.format(message, values)}\r\nif the values are not empty, otherwise return the message unformatted.\r\nThis method exists to allow validation methods declaring a String message and varargs parameters\r\nto be used without any message parameters when the message contains special characters,\r\ne.g. {@code Validate.isTrue(false, ""%Failed%"")}.\r\n@param ...\r\n@return ...\r\n```', 'commenter': 'aherbert'}, {'comment': 'Done.', 'commenter': 'stawirej'}]"
956,src/main/java/org/apache/commons/lang3/CharSetUtils.java,"@@ -45,8 +45,8 @@ public class CharSetUtils {
      * </pre>
      *
      * @see CharSet#getInstance(String...) for set-syntax.
-     * @param str  String to look for characters in, may be null
-     * @param set  String[] set of characters to identify, may be null
+     * @param str  String to look for characters in, may be {@code null}","[{'comment': 'Is there a reason why ""String"" is sometimes linked and sometimes not?', 'commenter': 'garydgregory'}, {'comment': 'No Reason at all.\r\n', 'commenter': 'arturobernalg'}]"
956,src/main/java/org/apache/commons/lang3/BitField.java,"@@ -56,15 +56,15 @@
  * <p>Flags and data can be retrieved from the integer:</p>
  *
  *<pre>
- *    // Prints true if red, green or blue is non-zero
+ *    // Prints {@code true} if red, green or blue is non-zero","[{'comment': 'This is a code comment, not a Javadoc comment, so using Javadoc decorations is wrong. Please review all the files and revert this type of change please.', 'commenter': 'garydgregory'}, {'comment': 'done. Looks like only was this mistake.', 'commenter': 'arturobernalg'}, {'comment': '@arturobernalg \r\nYou need to update the PR...', 'commenter': 'garydgregory'}, {'comment': ""ups. Sorry @garydgregory \r\nit's done."", 'commenter': 'arturobernalg'}]"
956,src/main/java/org/apache/commons/lang3/BitField.java,"@@ -281,7 +281,7 @@ public byte setByte(final byte holder) {
     }
 
     /**
-     * Sets a boolean BitField.
+     * Sets a {@code boolean} BitField.","[{'comment': ""Hi @arturobernalg \r\nIn this case, the bit field is a `short`, not a `boolean`, right? It's the bits in the bit field that represent booleans. I think If we are going to touch Javadocs we should make sure they are correct first ;-) See the other setters as well."", 'commenter': 'garydgregory'}]"
983,src/test/java/org/apache/commons/lang3/stream/StreamsTest.java,"@@ -136,25 +136,25 @@ public Stream<DynamicTest> simpleStreamForEachFailing() {
 
     @Test
     public void testInstanceOfStream() {
-        assertEquals(2, Streams.instancesOf(String.class, Arrays.asList(""A"", ""B"")).collect(Collectors.toList()).size());
-        assertEquals(2, Streams.instancesOf(String.class, Arrays.asList(null, ""A"", null, ""B"", null)).collect(Collectors.toList()).size());
-        assertEquals(0, Streams.instancesOf(String.class, Arrays.asList(null, null)).collect(Collectors.toList()).size());
+        assertEquals(2, (int) Streams.instancesOf(String.class, Arrays.asList(""A"", ""B"")).count());","[{'comment': 'Why clutter up the code with all these type-casts? Just let the compiler pick up the `long` version of the JUnit API IMO.', 'commenter': 'garydgregory'}]"
1026,src/main/java/org/apache/commons/lang3/ObjectUtils.java,"@@ -984,7 +984,7 @@ public static boolean isArray(final Object object) {
 
     /**
      * Checks if an Object is empty or null.
-     *
+     * <p></p>","[{'comment': 'Uh?', 'commenter': 'garydgregory'}, {'comment': '`<p>`This is a paragraph.`</p>`', 'commenter': 'garydgregory'}, {'comment': 'done', 'commenter': 'arturobernalg'}, {'comment': 'Did you not see my example?', 'commenter': 'garydgregory'}, {'comment': 'Are you not trying a local build before you push to git?', 'commenter': 'garydgregory'}, {'comment': ""@arturobernalg \r\n`<p>`This is a paragraph.`</p>`, you can't embed lists per the errors in the build. Again, run a 'mvn' build before you push and you will discover this type of issue without forcing reviewers to ping you for broken builds. TY."", 'commenter': 'garydgregory'}]"
1062,src/test/java/org/apache/commons/lang3/time/DurationFormatUtilsTest.java,"@@ -632,4 +632,31 @@ public void testLowDurations() {
         }
     }
 
+    @Test
+    public void testUnmatchedOptionalToken() {
+        assertThrows(IllegalArgumentException.class, () -> DurationFormatUtils.formatDuration(1, ""[s""));","[{'comment': 'What about an unbalanced ""]"". What happens when there is more than one [ or ]?', 'commenter': 'garydgregory'}, {'comment': ""Nesting has little value that I can see, so simplest solution will be to catch any nesting and throw an IllegalArgumentException. That will prevent unbalancing issues since the current optional state is tracked with a boolean, similar to literals, and we can easily detect attempts to nest.\r\n\r\nMultiple optional blocks are supported by default (though realistic use cases may be few). If you wanted to always show minutes, but omit zero-value hours and seconds, then the format `[H'h']m'm'[s's']` will produce values like:\r\n```\r\n254h16m\r\n15m15s \r\n0m9s\r\n```\r\nAdded https://github.com/apache/commons-lang/pull/1062/commits/12bf4b67ef7545789b97f0785231c64d5aad5a24 to address the nesting issue."", 'commenter': 'theshoeshiner'}]"
1062,src/main/java/org/apache/commons/lang3/time/DurationFormatUtils.java,"@@ -48,6 +48,13 @@
  * Token values are printed using decimal digits.
  * A token character can be repeated to ensure that the field occupies a certain minimum
  * size. Values will be left-padded with 0 unless padding is disabled in the method invocation.
+ * <br>
+ * Tokens can be marked as optional by surrounding them with brackets [ ]. These tokens will 
+ * only be printed if the token value is non-zero. Any literals within optional blocks will only be 
+ * printed if the nearest prior non-literal token value was non-zero.","[{'comment': 'It would be useful here to have a few examples in a `<pre>` block or a table. The purpose is to demonstrate that literals will be omitted and zero can return an empty string, e.g.\r\n```java\r\nString format = ""[d\'d\'H\'h\'m\'m\'s\'s\']"";\r\nLongStream.of(0,\r\n              Duration.ofMinutes(1).toMillis(),\r\n              Duration.ofHours(2).toMillis(),\r\n              Duration.ofDays(3).toMillis())\r\n    .forEach(millis -> System.out.println(DurationFormatUtils.formatDuration(millis, format)));\r\n```\r\nprints\r\n```\r\n\r\n1m\r\n2h\r\n3d\r\n```\r\nThus the use of optional tokens requires literals to make the format understandable. This is because trailing optional token are omitted when zero. For example this does not work to make a readable time:\r\n```java\r\nString format = ""[HH\':\'mm\':\']ss"";\r\nLongStream.of(0, \r\n              Duration.ofSeconds(1).toMillis(),\r\n              Duration.ofMinutes(2).toMillis(),\r\n              Duration.ofHours(3).toMillis())\r\n    .forEach(millis -> System.out.println(DurationFormatUtils.formatDuration(millis, format)));\r\n```\r\nprints\r\n```\r\n00\r\n01\r\n02:\r\n03:\r\n```\r\nnot:\r\n```\r\n00\r\n01\r\n02:00\r\n03:00:00\r\n```', 'commenter': 'aherbert'}, {'comment': 'Originally I could not come up with too many scenarios where a leading literal would make sense, but surrounding a token with brackets does seem like a reasonable use. I agree the simplest/best solution would be to use the first token. ', 'commenter': 'theshoeshiner'}, {'comment': 'Two commits to address this. Tried to keep it simple, but still required minor change to the Token class and multiple tracking variables in the format method.\r\n\r\nNow it tracks leading literals in optional blocks, and when encountering a non-literal token we remove the prior literal from the buffer if the token is zero. Optional blocks are differentiated by tracking an optional ""index"" in the token class - as opposed to the prior boolean field. Literals following tokens are handled same as before.\r\n\r\nAlso added an example table to highlight the likely usage and potential pitfalls.', 'commenter': 'theshoeshiner'}, {'comment': 'Also - not sure how you guys prefer to handle constructor collisions. But this change required a Token constructor method which collides with the Token(int,int) constructor that is used by unit tests. The addition of a boolean parameter to the new constructor resolves this. The boolean parameter function is clear and reasonable, but code could be refactored to remove it (were it not for the collision).', 'commenter': 'theshoeshiner'}, {'comment': ""I'll repeat:\r\n\r\n> Run mvn (just that) locally before you push to avoid these types of build failures.\r\n"", 'commenter': 'garydgregory'}]"
1062,src/main/java/org/apache/commons/lang3/time/DurationFormatUtils.java,"@@ -50,12 +50,27 @@
  * A token character can be repeated to ensure that the field occupies a certain minimum
  * size. Values will be left-padded with 0 unless padding is disabled in the method invocation.
  * <br>
- * Tokens can be marked as optional by surrounding them with brackets [ ]. These tokens will 
- * only be printed if the token value is non-zero. Any literals within optional blocks will only be 
- * printed if the nearest prior non-literal token value was non-zero.
+ * Tokens can be marked as optional by surrounding them with brackets [ ]. These tokens will
+ * only be printed if the token value is non-zero. Literals within optional blocks will only be
+ * printed if the preceding non-literal token is non-zero. Leading optional literals will only
+ * be printed if the following non-literal is non-zero.
+ * Multiple optional blocks can be used to group literals with the desired token. Note that
+ * multiple optional tokens without literals can result in impossible to understand output.
+ * (See examples below)
  * <br>
+ * <table border=""1"">
+ * <caption>Example Output</caption>
+ * <tr><th>pattern</th><th>Duration.ofDays(1)</th><th>Duration.ofHours(1)</th><th>Duration.ofMinutes(1)</th></tr>","[{'comment': ""This is nice. For the entry with all optional formatting `[d'd'H'h'm'm's's']` it would be useful to state what happens when the duration is 0. E.g. If the entire format is optional and the duration is zero the result is the empty string."", 'commenter': 'aherbert'}, {'comment': 'Agree. Added a column for Duration.ofMillis(0) so that empty string results are noticeable, as well as a specific Note.', 'commenter': 'theshoeshiner'}, {'comment': '> Agree. Added a column for Duration.ofMillis(0) so that empty string results are noticeable, as well as a specific Note.\r\n\r\nIs the 0 important or the Millis part? It might be more obvious to refer to Duration.ZERO.', 'commenter': 'garydgregory'}, {'comment': ""You are correct. I hadn't checked for that static field. Will update."", 'commenter': 'theshoeshiner'}]"
1062,src/main/java/org/apache/commons/lang3/time/DurationFormatUtils.java,"@@ -621,22 +672,23 @@ static boolean containsTokenWithValue(final Token[] tokens, final Object value)
 
         private final Object value;
         private int count;
-        private boolean optional = false;
-
+        private int optionalIndex = -1;
         Token(final Object value) {
             this.value = value;
             this.count = 1;
         }
-        
+
         /**
          * Wraps a token around a value. A value would be something like a 'Y'.
          *
          * @param value to wrap, non-null.
          */
-        Token(final Object value, final boolean optional) {
+        Token(final Object value, final boolean optional, final int optionalIndex) {","[{'comment': 'You should javadoc the other parameters and why they are used.\r\n\r\nNote: It seems odd to have the other two constructors. These are only used in the tests. If you concur I think it sensible to remove them and add a helper method in the test itself to create these objects using the constructor that your code uses. IIUC the helper method can pass in the desired Object value then call increment a number of times as appropriate.', 'commenter': 'aherbert'}, {'comment': 'I found the presence of the test-only constructors odd as well. I went ahead and removed them and replaced with a helper method on the test class.', 'commenter': 'theshoeshiner'}]"
1062,src/test/java/org/apache/commons/lang3/time/DurationFormatUtilsTest.java,"@@ -632,4 +633,154 @@ public void testLowDurations() {
         }
     }
 
+
+    @Test
+    public void testUnmatchedOptionalTokens() {
+        assertThrows(IllegalArgumentException.class, () -> DurationFormatUtils.formatDuration(1, ""[s""));
+        assertThrows(IllegalArgumentException.class, () -> DurationFormatUtils.formatDuration(1, ""[[s""));
+        assertThrows(IllegalArgumentException.class, () -> DurationFormatUtils.formatDuration(1, ""[s]]""));
+    }
+
+    @Test
+    public void testOptionalLiteralSpecialCharacters() {
+      assertEquals(
+          DurationFormatUtils.formatDuration(10000L, ""s's'""),
+          DurationFormatUtils.formatDuration(10000L, ""['['m']']s's'""));
+    }
+
+    @Test
+    public void testAlternatingLiteralOptionals() {
+        String format = ""['d'dH'h'][m'm']['s's]['ms'S]"";
+
+        assertEquals(""d1"",
+            DurationFormatUtils.formatDuration(Duration.ofDays(1).toMillis(), format));
+
+        assertEquals(""1h"",
+            DurationFormatUtils.formatDuration(Duration.ofHours(1).toMillis(), format));
+
+        assertEquals(""1m"",
+            DurationFormatUtils.formatDuration(Duration.ofMinutes(1).toMillis(), format));
+
+        assertEquals(""s1"",
+            DurationFormatUtils.formatDuration(Duration.ofSeconds(1).toMillis(), format));
+
+        assertEquals(""ms001"",
+            DurationFormatUtils.formatDuration(Duration.ofMillis(1).toMillis(), format));
+
+        assertEquals(""d1s1"",
+            DurationFormatUtils.formatDuration(Duration.ofDays(1).plusSeconds(1).toMillis(), format));
+
+        assertEquals(""d11h"",
+            DurationFormatUtils.formatDuration(Duration.ofDays(1).plusHours(1).toMillis(), format));
+
+        assertEquals(""d11h1m"",
+            DurationFormatUtils.formatDuration(Duration.ofDays(1).plusHours(1).plusMinutes(1).toMillis(), format));
+
+        assertEquals(""d11h1ms1"",
+            DurationFormatUtils.formatDuration(Duration.ofDays(1).plusHours(1).plusMinutes(1).plusSeconds(1).toMillis(), format));
+
+        assertEquals(""d11h1ms1ms001"",
+            DurationFormatUtils.formatDuration(Duration.ofDays(1).plusHours(1).plusMinutes(1).plusSeconds(1).plusMillis(1).toMillis(), format));
+
+    }
+
+    @Test
+    public void testLiteralPrefixOptionalToken() {
+      assertEquals(
+          DurationFormatUtils.formatDuration(10000L, ""s's'""),
+          DurationFormatUtils.formatDuration(10000L, ""['['d']']['<'H'>']['{'m'}']s's'""));
+      assertEquals(
+          DurationFormatUtils.formatDuration(10000L, ""s's'""),
+          DurationFormatUtils.formatDuration(10000L, ""['{'m'}']s's'"")
+          );","[{'comment': 'Can be on previous line', 'commenter': 'aherbert'}]"
1062,src/test/java/org/apache/commons/lang3/time/DurationFormatUtilsTest.java,"@@ -632,4 +633,154 @@ public void testLowDurations() {
         }
     }
 
+
+    @Test
+    public void testUnmatchedOptionalTokens() {
+        assertThrows(IllegalArgumentException.class, () -> DurationFormatUtils.formatDuration(1, ""[s""));
+        assertThrows(IllegalArgumentException.class, () -> DurationFormatUtils.formatDuration(1, ""[[s""));
+        assertThrows(IllegalArgumentException.class, () -> DurationFormatUtils.formatDuration(1, ""[s]]""));
+    }
+
+    @Test
+    public void testOptionalLiteralSpecialCharacters() {
+      assertEquals(
+          DurationFormatUtils.formatDuration(10000L, ""s's'""),
+          DurationFormatUtils.formatDuration(10000L, ""['['m']']s's'""));
+    }
+
+    @Test
+    public void testAlternatingLiteralOptionals() {
+        String format = ""['d'dH'h'][m'm']['s's]['ms'S]"";
+
+        assertEquals(""d1"",
+            DurationFormatUtils.formatDuration(Duration.ofDays(1).toMillis(), format));
+
+        assertEquals(""1h"",
+            DurationFormatUtils.formatDuration(Duration.ofHours(1).toMillis(), format));
+
+        assertEquals(""1m"",
+            DurationFormatUtils.formatDuration(Duration.ofMinutes(1).toMillis(), format));
+
+        assertEquals(""s1"",
+            DurationFormatUtils.formatDuration(Duration.ofSeconds(1).toMillis(), format));
+
+        assertEquals(""ms001"",
+            DurationFormatUtils.formatDuration(Duration.ofMillis(1).toMillis(), format));
+
+        assertEquals(""d1s1"",
+            DurationFormatUtils.formatDuration(Duration.ofDays(1).plusSeconds(1).toMillis(), format));
+
+        assertEquals(""d11h"",
+            DurationFormatUtils.formatDuration(Duration.ofDays(1).plusHours(1).toMillis(), format));
+
+        assertEquals(""d11h1m"",
+            DurationFormatUtils.formatDuration(Duration.ofDays(1).plusHours(1).plusMinutes(1).toMillis(), format));
+
+        assertEquals(""d11h1ms1"",
+            DurationFormatUtils.formatDuration(Duration.ofDays(1).plusHours(1).plusMinutes(1).plusSeconds(1).toMillis(), format));
+
+        assertEquals(""d11h1ms1ms001"",
+            DurationFormatUtils.formatDuration(Duration.ofDays(1).plusHours(1).plusMinutes(1).plusSeconds(1).plusMillis(1).toMillis(), format));
+
+    }
+
+    @Test
+    public void testLiteralPrefixOptionalToken() {
+      assertEquals(
+          DurationFormatUtils.formatDuration(10000L, ""s's'""),
+          DurationFormatUtils.formatDuration(10000L, ""['['d']']['<'H'>']['{'m'}']s's'""));
+      assertEquals(
+          DurationFormatUtils.formatDuration(10000L, ""s's'""),
+          DurationFormatUtils.formatDuration(10000L, ""['{'m'}']s's'"")
+          );
+    }
+
+    @Test
+    public void testEmptyOptionals() {
+      assertEquals(
+          """",
+          DurationFormatUtils.formatDuration(0L, ""[d'd'][H'h'][m'm'][s's']""));
+      assertEquals(
+          """",
+          DurationFormatUtils.formatDuration(0L, ""['d''h''m''s's]"")
+          );","[{'comment': 'Can be on previous line', 'commenter': 'aherbert'}]"
1062,src/test/java/org/apache/commons/lang3/time/DurationFormatUtilsTest.java,"@@ -632,4 +633,154 @@ public void testLowDurations() {
         }
     }
 
+
+    @Test
+    public void testUnmatchedOptionalTokens() {
+        assertThrows(IllegalArgumentException.class, () -> DurationFormatUtils.formatDuration(1, ""[s""));
+        assertThrows(IllegalArgumentException.class, () -> DurationFormatUtils.formatDuration(1, ""[[s""));
+        assertThrows(IllegalArgumentException.class, () -> DurationFormatUtils.formatDuration(1, ""[s]]""));
+    }
+
+    @Test
+    public void testOptionalLiteralSpecialCharacters() {
+      assertEquals(
+          DurationFormatUtils.formatDuration(10000L, ""s's'""),
+          DurationFormatUtils.formatDuration(10000L, ""['['m']']s's'""));
+    }
+
+    @Test
+    public void testAlternatingLiteralOptionals() {
+        String format = ""['d'dH'h'][m'm']['s's]['ms'S]"";
+
+        assertEquals(""d1"",
+            DurationFormatUtils.formatDuration(Duration.ofDays(1).toMillis(), format));
+
+        assertEquals(""1h"",
+            DurationFormatUtils.formatDuration(Duration.ofHours(1).toMillis(), format));
+
+        assertEquals(""1m"",
+            DurationFormatUtils.formatDuration(Duration.ofMinutes(1).toMillis(), format));
+
+        assertEquals(""s1"",
+            DurationFormatUtils.formatDuration(Duration.ofSeconds(1).toMillis(), format));
+
+        assertEquals(""ms001"",
+            DurationFormatUtils.formatDuration(Duration.ofMillis(1).toMillis(), format));
+
+        assertEquals(""d1s1"",
+            DurationFormatUtils.formatDuration(Duration.ofDays(1).plusSeconds(1).toMillis(), format));
+
+        assertEquals(""d11h"",
+            DurationFormatUtils.formatDuration(Duration.ofDays(1).plusHours(1).toMillis(), format));
+
+        assertEquals(""d11h1m"",
+            DurationFormatUtils.formatDuration(Duration.ofDays(1).plusHours(1).plusMinutes(1).toMillis(), format));
+
+        assertEquals(""d11h1ms1"",
+            DurationFormatUtils.formatDuration(Duration.ofDays(1).plusHours(1).plusMinutes(1).plusSeconds(1).toMillis(), format));
+
+        assertEquals(""d11h1ms1ms001"",
+            DurationFormatUtils.formatDuration(Duration.ofDays(1).plusHours(1).plusMinutes(1).plusSeconds(1).plusMillis(1).toMillis(), format));
+
+    }
+
+    @Test
+    public void testLiteralPrefixOptionalToken() {
+      assertEquals(
+          DurationFormatUtils.formatDuration(10000L, ""s's'""),
+          DurationFormatUtils.formatDuration(10000L, ""['['d']']['<'H'>']['{'m'}']s's'""));
+      assertEquals(
+          DurationFormatUtils.formatDuration(10000L, ""s's'""),
+          DurationFormatUtils.formatDuration(10000L, ""['{'m'}']s's'"")
+          );
+    }
+
+    @Test
+    public void testEmptyOptionals() {
+      assertEquals(
+          """",
+          DurationFormatUtils.formatDuration(0L, ""[d'd'][H'h'][m'm'][s's']""));
+      assertEquals(
+          """",
+          DurationFormatUtils.formatDuration(0L, ""['d''h''m''s's]"")
+          );
+    }
+
+    @Test
+    public void testMultipleOptionalBlocks() {
+
+      assertEquals(
+          DurationFormatUtils.formatDuration(Duration.ofHours(1).toMillis(), ""'[['H']]'""),
+          DurationFormatUtils.formatDuration(Duration.ofHours(1).toMillis(), ""['{'d'}']['[['H']]']""));
+
+      assertEquals(
+          DurationFormatUtils.formatDuration(Duration.ofDays(1).toMillis(), ""['{'d'}']""),
+          DurationFormatUtils.formatDuration(Duration.ofDays(1).toMillis(), ""['{'d'}']['['H']']""));
+","[{'comment': 'Remove empty line', 'commenter': 'aherbert'}]"
1062,src/test/java/org/apache/commons/lang3/time/DurationFormatUtilsTest.java,"@@ -632,4 +633,154 @@ public void testLowDurations() {
         }
     }
 
+
+    @Test
+    public void testUnmatchedOptionalTokens() {
+        assertThrows(IllegalArgumentException.class, () -> DurationFormatUtils.formatDuration(1, ""[s""));
+        assertThrows(IllegalArgumentException.class, () -> DurationFormatUtils.formatDuration(1, ""[[s""));
+        assertThrows(IllegalArgumentException.class, () -> DurationFormatUtils.formatDuration(1, ""[s]]""));
+    }
+
+    @Test
+    public void testOptionalLiteralSpecialCharacters() {
+      assertEquals(
+          DurationFormatUtils.formatDuration(10000L, ""s's'""),
+          DurationFormatUtils.formatDuration(10000L, ""['['m']']s's'""));
+    }
+
+    @Test
+    public void testAlternatingLiteralOptionals() {
+        String format = ""['d'dH'h'][m'm']['s's]['ms'S]"";
+
+        assertEquals(""d1"",
+            DurationFormatUtils.formatDuration(Duration.ofDays(1).toMillis(), format));
+
+        assertEquals(""1h"",
+            DurationFormatUtils.formatDuration(Duration.ofHours(1).toMillis(), format));
+
+        assertEquals(""1m"",
+            DurationFormatUtils.formatDuration(Duration.ofMinutes(1).toMillis(), format));
+
+        assertEquals(""s1"",
+            DurationFormatUtils.formatDuration(Duration.ofSeconds(1).toMillis(), format));
+
+        assertEquals(""ms001"",
+            DurationFormatUtils.formatDuration(Duration.ofMillis(1).toMillis(), format));
+
+        assertEquals(""d1s1"",
+            DurationFormatUtils.formatDuration(Duration.ofDays(1).plusSeconds(1).toMillis(), format));
+
+        assertEquals(""d11h"",
+            DurationFormatUtils.formatDuration(Duration.ofDays(1).plusHours(1).toMillis(), format));
+
+        assertEquals(""d11h1m"",
+            DurationFormatUtils.formatDuration(Duration.ofDays(1).plusHours(1).plusMinutes(1).toMillis(), format));
+
+        assertEquals(""d11h1ms1"",
+            DurationFormatUtils.formatDuration(Duration.ofDays(1).plusHours(1).plusMinutes(1).plusSeconds(1).toMillis(), format));
+
+        assertEquals(""d11h1ms1ms001"",
+            DurationFormatUtils.formatDuration(Duration.ofDays(1).plusHours(1).plusMinutes(1).plusSeconds(1).plusMillis(1).toMillis(), format));
+
+    }
+
+    @Test
+    public void testLiteralPrefixOptionalToken() {
+      assertEquals(
+          DurationFormatUtils.formatDuration(10000L, ""s's'""),
+          DurationFormatUtils.formatDuration(10000L, ""['['d']']['<'H'>']['{'m'}']s's'""));
+      assertEquals(
+          DurationFormatUtils.formatDuration(10000L, ""s's'""),
+          DurationFormatUtils.formatDuration(10000L, ""['{'m'}']s's'"")
+          );
+    }
+
+    @Test
+    public void testEmptyOptionals() {
+      assertEquals(
+          """",
+          DurationFormatUtils.formatDuration(0L, ""[d'd'][H'h'][m'm'][s's']""));
+      assertEquals(
+          """",
+          DurationFormatUtils.formatDuration(0L, ""['d''h''m''s's]"")
+          );
+    }
+
+    @Test
+    public void testMultipleOptionalBlocks() {
+
+      assertEquals(
+          DurationFormatUtils.formatDuration(Duration.ofHours(1).toMillis(), ""'[['H']]'""),
+          DurationFormatUtils.formatDuration(Duration.ofHours(1).toMillis(), ""['{'d'}']['[['H']]']""));
+
+      assertEquals(
+          DurationFormatUtils.formatDuration(Duration.ofDays(1).toMillis(), ""['{'d'}']""),
+          DurationFormatUtils.formatDuration(Duration.ofDays(1).toMillis(), ""['{'d'}']['['H']']""));
+
+    }
+
+    @Test
+    public void testOptionalToken() {
+
+        //make sure optional formats match corresponding adjusted non-optional formats
+        assertEquals(
+                DurationFormatUtils.formatDuration(915361000L, ""d'd'H'h'm'm's's'""),
+                DurationFormatUtils.formatDuration(915361000L, ""[d'd'H'h'm'm']s's'""));
+
+        assertEquals(
+                DurationFormatUtils.formatDuration(9153610L, ""H'h'm'm's's'""),
+                DurationFormatUtils.formatDuration(9153610L, ""[d'd'H'h'm'm']s's'""));
+
+        assertEquals(
+                DurationFormatUtils.formatDuration(915361L, ""m'm's's'""),
+                DurationFormatUtils.formatDuration(915361L, ""[d'd'H'h'm'm']s's'""));
+
+        assertEquals(
+                DurationFormatUtils.formatDuration(9153L, ""s's'""),
+                DurationFormatUtils.formatDuration(9153L, ""[d'd'H'h'm'm']s's'""));
+
+        assertEquals(
+                DurationFormatUtils.formatDuration(9153L, ""s's'""),
+                DurationFormatUtils.formatDuration(9153L, ""[d'd'H'h'm'm']s's'""));
+
+        assertEquals(
+                DurationFormatUtils.formatPeriod(9153610L, 915361000L, ""d'd'H'h'm'm's's'""),
+                DurationFormatUtils.formatPeriod(9153610L, 915361000L, ""[d'd'H'h'm'm']s's'""));
+
+        assertEquals(
+                DurationFormatUtils.formatPeriod(915361L, 9153610L, ""H'h'm'm's's'""),
+                DurationFormatUtils.formatPeriod(915361L, 9153610L, ""[d'd'H'h'm'm']s's'""));
+
+        assertEquals(
+                DurationFormatUtils.formatPeriod(9153L, 915361L, ""m'm's's'""),
+                DurationFormatUtils.formatPeriod(9153L, 915361L, ""[d'd'H'h'm'm']s's'""));
+
+        assertEquals(
+                DurationFormatUtils.formatPeriod(0L, 9153L, ""s's'""),
+                DurationFormatUtils.formatPeriod(0L, 9153L, ""[d'd'H'h'm'm']s's'""));
+
+        //make sure optional parts are actually omitted when zero
+
+        assertEquals(""2h32m33s610ms"", DurationFormatUtils.formatDuration(9153610L, ""[d'd'H'h'm'm's's']S'ms'""));
+
+        assertEquals(""15m15s361ms"", DurationFormatUtils.formatDuration(915361L, ""[d'd'H'h'm'm's's']S'ms'""));
+
+        assertEquals(""9s153ms"", DurationFormatUtils.formatDuration(9153L, ""[d'd'H'h'm'm's's']S'ms'""));
+
+        assertEquals(""915ms"", DurationFormatUtils.formatDuration(915L, ""[d'd'H'h'm'm's's']S'ms'""));
+
+        //make sure we can handle omitting multiple literals after a token
+
+        assertEquals(
+                DurationFormatUtils.formatPeriod(915361L, 9153610L, ""H'h''h2'm'm's's'""),
+                DurationFormatUtils.formatPeriod(915361L, 9153610L, ""[d'd''d2'H'h''h2'm'm']s's'""));
+    }
+
+    private DurationFormatUtils.Token createTokenWithCount(final Object value, final int count) {
+        DurationFormatUtils.Token token = new DurationFormatUtils.Token(value, false, -1);
+        for (int i=1; i<count; i++) {","[{'comment': 'Whitespace padding: `for (int i = 1; i < count; i++) {`', 'commenter': 'aherbert'}]"
1077,src/main/java/org/apache/commons/lang3/ArrayUtils.java,"@@ -655,7 +655,7 @@ private static Object add(final Object array, final int index, final Object elem
             Array.set(joinedArray, 0, element);
             return joinedArray;
         }
-        final int length = Array.getLength(array);
+        final int length = getLength(array);","[{'comment': ""-1: Why? `array` can't be null here.\r\n"", 'commenter': 'garydgregory'}, {'comment': 'just for code reuse. This class already has a getLength method. Why not reuse it inside this class? That was my thought. Not nulls. But it is OK. I will close it', 'commenter': 'orionlibs'}]"
1077,src/main/java/org/apache/commons/lang3/ArrayUtils.java,"@@ -1668,7 +1668,7 @@ public static boolean containsAny(final Object[] array, final Object... objectsT
      */
     private static Object copyArrayGrow1(final Object array, final Class<?> newArrayComponentType) {
         if (array != null) {
-            final int arrayLength = Array.getLength(array);
+            final int arrayLength = getLength(array);","[{'comment': ""-1: Makes no sense since you're in a block where `array` can't be null."", 'commenter': 'garydgregory'}]"
1086,src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java,"@@ -703,13 +703,11 @@ public Class<?> getUpToClass() {
      *
      * @throws IllegalArgumentException
      *             see {@link java.lang.reflect.Field#get(Object)}
-     * @throws IllegalAccessException
-     *             see {@link java.lang.reflect.Field#get(Object)}
      *
      * @see java.lang.reflect.Field#get(Object)
      */
-    protected Object getValue(final Field field) throws IllegalAccessException {","[{'comment': 'Why are you removing `IllegalAccessException`?', 'commenter': 'garydgregory'}, {'comment': 'As such, the method `Reflection.getUnchecked` does not throw any checked exception. By keeping this, i would either have to rethrow that in `appendFieldsIn` method or throw some `RuntimeException` so that i dont have to add checked exceptions to all the methods. \r\n\r\nSo, I removed it here. Open to suggestions\r\n1. Catch IllegalAccessException in the method `appendFieldsIn` and throw some RuntimeException\r\n2. Or rethrow the same exception. (Dont think this should be opted anyways)', 'commenter': 'shashankrnr32'}, {'comment': ""Hello @shashankrnr32 \r\nThank you for your update.\r\nThis PR attempts to restore compatibility with the `getValue()` method but changes that method's definition and breaks compatibility differently. For example, if I have a subclass that overrides `getValue()` using the released signature, that subclass will no longer compile if this patch is applied. The test in this PR does not reflect that a subclass can throw `IllegalAccessException` in the `getValue()` method signature, so the test is not checking for full compatibility. See git master for a fix.\r\n"", 'commenter': 'garydgregory'}]"
1119,src/main/java/org/apache/commons/lang3/concurrent/LazyInitializerWithDisposer.java,"@@ -0,0 +1,294 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.lang3.concurrent;
+
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Future;
+import java.util.Optional;
+
+import org.apache.commons.lang3.function.FailableConsumer;
+import org.apache.commons.lang3.function.FailableSupplier;
+
+/**
+ * This class provides a generic implementation of the lazy initialization
+ * pattern and also contains a way to dispose of the wrapped object if it has
+ * been previously created by using a supplier and a consumer respectively.
+ * To ensure the supplier and disposer are only used once each this class 
+ * uses the double-check idiom for an instance field as discussed in  Joshua 
+ * Bloch's ""Effective Java"", 2nd edition, item 71. 
+ *
+ * <p>
+ * Sometimes an application has to deal with an object only under certain
+ * circumstances, e.g. when the user selects a specific menu item or if a
+ * special event is received. If the creation of the object is costly or the
+ * consumption of memory or other system resources is significant, it may make
+ * sense to defer the creation of this object until it is really needed. This is
+ * a use case for the lazy initialization pattern.
+ * </p>
+ *
+ * <p>
+ * If these objects must be disposed of, it would not make sense to create them
+ * just so they can be disposed of. Therefore this class provides the ability to
+ * dispose of objects if and only if they have been created.
+ * </p>
+ *
+ * <p>
+ * Access to the data object is provided through the {@code get()} method. and
+ * the data object is disposed with the {@code dispose()} So, code that obtains
+ * and eventually disposes of the {@code ComplexObject} instance would simply look
+ * like this:
+ * </p>
+ *
+ * <pre>
+ * // Create the supplier and disposer: 
+ * Supplier<ComplexObject> initializer = () -> new ComplexObject();
+ * Consumer<ComplexObject> disposer = complexObject -> complexObject.shutDown();
+ *
+ * // Create an instance of the lazy initializer
+ * ComplexObjectInitializer initializer = new ComplexObjectInitializer(initializer, disposer);
+ * ...
+ * // When the object is actually needed:
+ * ComplexObject cobj = initializer.get();
+ * 
+ * // When it is time to dispose of the object
+ * initializer.dispose();
+ * </pre>
+ *
+ * <p>
+ * If multiple threads call the {@code get()} method when the object has not yet
+ * been created, they are blocked until initialization completes. The algorithm
+ * guarantees that only a single instance of the wrapped object class is
+ * created, which is passed to all callers. Once initialized, calls to the
+ * {@code get()} method are pretty fast because no synchronization is needed
+ * (only an access to a <b>volatile</b> member field).
+ * </p>
+ *
+ * @since 3.14.0
+ * @param <T> the type of the object managed by this initializer class
+ */
+public class LazyInitializerWithDisposer<T> implements ConcurrentInitializer<T> {
+
+    //NO_INIT serves double duty as the lock object to prevent any other class acquiring the monitor
+    private final Object NO_INIT = new Object(){};
+    private final Object DISPOSED = new Object(){};
+
+    private FailableConsumer<? super T, ? extends Exception> disposer;
+    private FailableSupplier<? extends T, ? extends Exception> initializer;
+
+    // Stores the managed object.
+    private volatile T object = (T) NO_INIT;
+
+    private int allowedTries;
+    Exception firstFailure = null;
+
+    /** 
+     * Constructs a LazyInitializerWithDisposer with a given initializer and disposer
+     *
+     * @param initializer an implimentation of the FailableSupplier functional interface which will create the wrapped object
+     * @param disposer an implimentation of the FailableConsumer functional interface which will dispose of the wrapped object
+     * @param allowedTries how many calls to get() will be allowed to attempt to initialize in total, before a failure is cached and becomes persistent. Set to a negative number for infinite retries.
+     */
+    public LazyInitializerWithDisposer(FailableSupplier<? extends T, ? extends Exception> initializer, FailableConsumer<? super T, ? extends Exception> disposer, int allowedTries) {
+        if (allowedTries == 0) {
+           throw new IllegalArgumentException(""allowedTries must be a positive or negative number"");
+        }
+        this.allowedTries = allowedTries;
+
+        this.initializer = initializer;
+        this.disposer = disposer;
+    }
+
+    /** 
+     * Constructs a LazyInitializerWithDisposer wtih a given initializer and disposer
+     *
+     * @param initializer an implimentation of the FailableSupplier functional interface which will create the wrapped object
+     * @param disposer an implimentation of the FailableConsumer functional interface which will dispose of the wrapped object
+     */
+    public LazyInitializerWithDisposer(FailableSupplier<? extends T, ? extends Exception> initializer, FailableConsumer<? super T, ? extends Exception> disposer) {
+        this(initializer, disposer, 4);","[{'comment': ""4 seems random to me. It's not clear to me why this would be needed. Closable and AutoCloseable don't support anything like that for example."", 'commenter': 'garydgregory'}, {'comment': ""There is a logic to that 4. Three retries is a standard default. And I'm using a variable representing tries rather than retries to distinguish between 0 tries left - a fail state - and -1 or below representing infinite tries.\r\n\r\nAs for why have retries at all. LazyInitializers are most useful when it is expensive to initialize something. Needing some form of IO is both a common reason for an operation to be expensive, and a case where trying again after a failure might actually work. So I think it is useful to make retries possible. "", 'commenter': 'benjamin-confino'}]"
1119,src/main/java/org/apache/commons/lang3/concurrent/LazyInitializerWithDisposer.java,"@@ -0,0 +1,294 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.lang3.concurrent;
+
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Future;
+import java.util.Optional;
+
+import org.apache.commons.lang3.function.FailableConsumer;
+import org.apache.commons.lang3.function.FailableSupplier;
+
+/**
+ * This class provides a generic implementation of the lazy initialization
+ * pattern and also contains a way to dispose of the wrapped object if it has
+ * been previously created by using a supplier and a consumer respectively.
+ * To ensure the supplier and disposer are only used once each this class 
+ * uses the double-check idiom for an instance field as discussed in  Joshua 
+ * Bloch's ""Effective Java"", 2nd edition, item 71. 
+ *
+ * <p>
+ * Sometimes an application has to deal with an object only under certain
+ * circumstances, e.g. when the user selects a specific menu item or if a
+ * special event is received. If the creation of the object is costly or the
+ * consumption of memory or other system resources is significant, it may make
+ * sense to defer the creation of this object until it is really needed. This is
+ * a use case for the lazy initialization pattern.
+ * </p>
+ *
+ * <p>
+ * If these objects must be disposed of, it would not make sense to create them
+ * just so they can be disposed of. Therefore this class provides the ability to
+ * dispose of objects if and only if they have been created.
+ * </p>
+ *
+ * <p>
+ * Access to the data object is provided through the {@code get()} method. and
+ * the data object is disposed with the {@code dispose()} So, code that obtains
+ * and eventually disposes of the {@code ComplexObject} instance would simply look
+ * like this:
+ * </p>
+ *
+ * <pre>
+ * // Create the supplier and disposer: 
+ * Supplier<ComplexObject> initializer = () -> new ComplexObject();
+ * Consumer<ComplexObject> disposer = complexObject -> complexObject.shutDown();
+ *
+ * // Create an instance of the lazy initializer
+ * ComplexObjectInitializer initializer = new ComplexObjectInitializer(initializer, disposer);
+ * ...
+ * // When the object is actually needed:
+ * ComplexObject cobj = initializer.get();
+ * 
+ * // When it is time to dispose of the object
+ * initializer.dispose();
+ * </pre>
+ *
+ * <p>
+ * If multiple threads call the {@code get()} method when the object has not yet
+ * been created, they are blocked until initialization completes. The algorithm
+ * guarantees that only a single instance of the wrapped object class is
+ * created, which is passed to all callers. Once initialized, calls to the
+ * {@code get()} method are pretty fast because no synchronization is needed
+ * (only an access to a <b>volatile</b> member field).
+ * </p>
+ *
+ * @since 3.14.0
+ * @param <T> the type of the object managed by this initializer class
+ */
+public class LazyInitializerWithDisposer<T> implements ConcurrentInitializer<T> {
+
+    //NO_INIT serves double duty as the lock object to prevent any other class acquiring the monitor
+    private final Object NO_INIT = new Object(){};
+    private final Object DISPOSED = new Object(){};
+
+    private FailableConsumer<? super T, ? extends Exception> disposer;
+    private FailableSupplier<? extends T, ? extends Exception> initializer;
+
+    // Stores the managed object.
+    private volatile T object = (T) NO_INIT;
+
+    private int allowedTries;
+    Exception firstFailure = null;
+
+    /** 
+     * Constructs a LazyInitializerWithDisposer with a given initializer and disposer
+     *
+     * @param initializer an implimentation of the FailableSupplier functional interface which will create the wrapped object
+     * @param disposer an implimentation of the FailableConsumer functional interface which will dispose of the wrapped object
+     * @param allowedTries how many calls to get() will be allowed to attempt to initialize in total, before a failure is cached and becomes persistent. Set to a negative number for infinite retries.
+     */
+    public LazyInitializerWithDisposer(FailableSupplier<? extends T, ? extends Exception> initializer, FailableConsumer<? super T, ? extends Exception> disposer, int allowedTries) {
+        if (allowedTries == 0) {
+           throw new IllegalArgumentException(""allowedTries must be a positive or negative number"");
+        }
+        this.allowedTries = allowedTries;
+
+        this.initializer = initializer;
+        this.disposer = disposer;
+    }
+
+    /** 
+     * Constructs a LazyInitializerWithDisposer wtih a given initializer and disposer
+     *
+     * @param initializer an implimentation of the FailableSupplier functional interface which will create the wrapped object
+     * @param disposer an implimentation of the FailableConsumer functional interface which will dispose of the wrapped object
+     */
+    public LazyInitializerWithDisposer(FailableSupplier<? extends T, ? extends Exception> initializer, FailableConsumer<? super T, ? extends Exception> disposer) {
+        this(initializer, disposer, 4);
+    }
+
+    /**
+     * Returns the object wrapped by this instance. On first access the object
+     * is created. After that it is cached and can be accessed pretty fast.
+     *
+     * @return the object initialized by this {@link LazyInitializer}
+     * @throws ConcurrentException if an error occurred during initialization of
+     * the object. Or enough previous errors have occurred to use up all allowed tries.
+     * @throws AlreadyDisposedException if dispose() or close() has already been called.
+     */
+    @Override
+    public T get() throws ConcurrentException {
+        return getInternal();
+    }
+
+    /**
+     * Returns the object wrapped by this instance inside an Optional. On first access
+     * the object is created. After that it is cached and can be accessed pretty fast.
+     *
+     * @return an Optional wrapping object initialized by this {@link LazyInitializer}
+     * or an empty Optional if dispose() or close() has already been called.
+     * @throws ConcurrentException if an error occurred during initialization of
+     * the object. Or enough previous errors have occurred to use up all allowed tries.
+     */
+    public Optional<T> getIfPossible() throws ConcurrentException {
+        try {
+            return Optional.ofNullable(getInternal());
+        } catch (AlreadyDisposedException e) {
+            return Optional.empty();
+        }
+    }
+
+    @SuppressWarnings(""unchecked"")
+    private T getInternal() throws ConcurrentException {
+        // use a temporary variable to reduce the number of reads of the
+        // volatile field
+        T result = object;
+
+        if (result == DISPOSED) {
+            throw new AlreadyDisposedException();
+        }
+
+        if (result == NO_INIT) {
+            synchronized (NO_INIT) {
+                result = object;
+
+                if (result == DISPOSED) {
+                    throw new AlreadyDisposedException();
+                }
+
+                if (result == NO_INIT) {
+                    if (allowedTries == 0) {
+                        this.initializer = null;
+                        ConcurrentException ce = new ConcurrentException();
+                        ce.addSuppressed(firstFailure);
+                        throw ce;
+                    } else if (allowedTries > 0) {
+                        allowedTries --;
+                    }
+
+                    try {
+                        object = result = initializer.get();
+                        this.initializer = null;
+                    } catch (RuntimeException e) {//So it doesn't get wrapped in the next block.
+                        if (firstFailure == null) {
+                            firstFailure = e;
+                        } else {
+                            firstFailure.addSuppressed(e); 
+                        }
+                        throw e; 
+                    } catch (Exception e) {
+                        if (firstFailure == null) {//Duplicate this code rather than use a finally block to avoid going into a finally block on every successful get
+                            firstFailure = e;
+                        } else {
+                            firstFailure.addSuppressed(e); 
+                        }
+                        throw new ConcurrentException(e); 
+                    }
+                }
+            }
+        }
+        return result;
+    }
+
+    /**
+     * Disposes the object wrapped by this instance if it has been created and closes
+     * this intializer.
+     *
+     * This method will only attempt to dispose an object if it has successfully been
+     * initialized. It will then close this LazyInitializerWithDisposer permemently 
+     * regardless of the state before the method was called, or any exceptions during
+     * disposal. Subsequent calls will have no effect.
+     *
+     * @return true if the object was successfully disposed, otherwise false
+     * @throws ConcurrentException if an error occurred during disposal of
+     * the object. The state will still be set to disposed.
+     */
+    public boolean dispose() throws ConcurrentException {
+        return disposeInternal(disposer);
+    }
+
+    /**
+     * Closes this initializer without disposing the wrapped object. This is equivalent
+     * to calling dispose() with a no-op consumer.
+     * 
+     * @return true if the object was previously created and not previously disposed, otherwise false
+     */
+    public boolean close() {
+        try {
+            return disposeInternal(ignored -> {});
+        } catch (ConcurrentException ignored) {//a no-op consumer will never throw anything.
+            return false;
+        }
+    }
+
+    private boolean disposeInternal(FailableConsumer<? super T, ? extends Exception> disposer) throws ConcurrentException {
+        T disposable = object;
+
+        if (disposable != DISPOSED) {
+            synchronized (NO_INIT) {
+                disposable = object;
+
+                if (disposable == DISPOSED) {
+                    return false;
+                }
+
+                if (disposable == NO_INIT) {
+                    object = (T) DISPOSED;
+                    return false;
+                }
+
+                try {
+                    object = (T) DISPOSED;
+                    disposer.accept(disposable);
+                    return true;
+                } catch (RuntimeException e) {//So it doesn't get wrapped in the next block.
+                    throw e; 
+                } catch (Exception e) {
+                    throw new ConcurrentException(e); ","[{'comment': 'Just FYI: `throw new ConcurrentException(ExceptionUtils.throwUnchecked(e));`', 'commenter': 'garydgregory'}]"
1120,src/main/java/org/apache/commons/lang3/concurrent/AtomicInitializer.java,"@@ -63,8 +63,10 @@
  * @param <T> the type of the object managed by this initializer class
  */
 public abstract class AtomicInitializer<T> extends AbstractConcurrentInitializer<T, RuntimeException> {
+
+    private final T NO_INIT = (T) new Object(){};","[{'comment': ""- Should be `static`, we don't need a new `Object` instance for each new initializer.\r\n- Why is the Object an anonymous class? IOW: `new Object(){};` --> `new Object();`"", 'commenter': 'garydgregory'}]"
1120,src/main/java/org/apache/commons/lang3/concurrent/AtomicSafeInitializer.java,"@@ -53,12 +53,13 @@
  */
 public abstract class AtomicSafeInitializer<T> extends AbstractConcurrentInitializer<T, RuntimeException> {
 
+    private final T NO_INIT = (T) new Object(){};","[{'comment': ""- Should be `static`, we don't need a new `Object` instance for each new initializer.\r\n- Why is the Object an anonymous class? IOW: `new Object(){};` --> `new Object();`"", 'commenter': 'garydgregory'}, {'comment': ""Good call on static.\r\n\r\nObject is an anonymous class because that way it will show up as `AtomicSafeInitializer$1` instead of `Object` in a debugger, which makes it easier to distinguish between `NO_INIT` and a return value of type `Object` when debugging. \r\n\r\nI'll make the change to static and look at code coverage next"", 'commenter': 'benjamin-confino'}, {'comment': ""WRT `new Object(){};` vs `new Object();`, IMO, that's not enough of a reason to force an anonymous subclass into the runtime. It's also different from what `LazyInitializer` does, which is confusing to the maintainer at large (especially when uncommented). I'll approve the PR but use `new Object();`."", 'commenter': 'garydgregory'}]"
1131,src/test/java/org/apache/commons/lang3/EnumUtilsTest.java,"@@ -29,6 +29,7 @@
 import java.util.EnumSet;
 import java.util.List;
 import java.util.Map;
+import java.util.HashMap;","[{'comment': 'Please run `mvn` locally before pushing to catch build errors.', 'commenter': 'garydgregory'}, {'comment': ""Hi,\r\nThank you for the feedback. I've made the changes. Please let me know if there's anything else. "", 'commenter': 'harshith2000'}]"
1131,src/test/java/org/apache/commons/lang3/EnumUtilsTest.java,"@@ -354,8 +360,21 @@ public void test_getEnumMap() {
     @Test
     public void test_getEnumMap_keyFunction() {
         final Map<Integer, Month> test = EnumUtils.getEnumMap(Month.class, Month::getId);
-        assertEquals(""{1=JAN, 2=FEB, 3=MAR, 4=APR, 5=MAY, 6=JUN, 7=JUL, 8=AUG, 9=SEP, 10=OCT, 11=NOV, 12=DEC}"", test.toString(),
-                ""getEnumMap not created correctly"");
+        final Map<Integer, Month> expected = new HashMap() {{
+            put(1, Month.JAN);","[{'comment': ""Use normal code, please. This notation will generate compiler warnings since the diamond notation can't be used.\r\n```\r\n        final Map<Integer, Month> expected = new HashMap<>();\r\n        expected.put(1, Month.JAN);\r\n        ...\r\n```"", 'commenter': 'garydgregory'}, {'comment': ""Hi,\r\nThank you for the feedback. I've made the changes. Please let me know if there's anything else. "", 'commenter': 'harshith2000'}]"
