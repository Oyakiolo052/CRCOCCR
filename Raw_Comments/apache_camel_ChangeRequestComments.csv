Pull,Path,Diff_hunk,Comment
1319,components/camel-cdi/src/main/java/org/apache/camel/cdi/CdiCamelConfiguration.java,"@@ -0,0 +1,41 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.cdi;
+
+/**
+ * The Camel CDI configuration. Camel CDI fires a {@code CdiCamelConfiguration} event
+ * during the deployment phase that the application can observe and use to configure it.
+ *
+ * Note that the event fired can only be used within the observer method invocation context. Any attempt to call one of its methods outside of that context will result in an `IllegalStateException` to be thrown.
+ */
+public interface CdiCamelConfiguration {
+
+    /**
+     * Overrides the Camel Cdi behavior to automatically add all RouteBuilders to context.
+     *
+     * @return this Camel CDI configuration
+     * @throws IllegalStateException if called outside of the observer method invocation
+     */
+    CdiCamelConfiguration autostartRoutes(boolean autostartRoutes);
+
+    /**
+     * @return Current state of autostartRoutes parameter
+     */
+    boolean autostartRoutes();
+    
+    boolean isUnmodifiable();","[{'comment': ""`isUnmodifiable` is rather an internal state so it'd be preferable not to expose it in the interface."", 'commenter': 'astefanutti'}, {'comment': 'Ok', 'commenter': 'sverkera'}]"
1319,components/camel-cdi/src/main/java/org/apache/camel/cdi/CdiCamelConfiguration.java,"@@ -0,0 +1,41 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.cdi;
+
+/**
+ * The Camel CDI configuration. Camel CDI fires a {@code CdiCamelConfiguration} event
+ * during the deployment phase that the application can observe and use to configure it.
+ *
+ * Note that the event fired can only be used within the observer method invocation context. Any attempt to call one of its methods outside of that context will result in an `IllegalStateException` to be thrown.
+ */
+public interface CdiCamelConfiguration {
+
+    /**
+     * Overrides the Camel Cdi behavior to automatically add all RouteBuilders to context.","[{'comment': 'Cdi -> CDI', 'commenter': 'astefanutti'}, {'comment': 'Ok', 'commenter': 'sverkera'}]"
1319,components/camel-cdi/src/main/java/org/apache/camel/cdi/CdiCamelConfiguration.java,"@@ -0,0 +1,41 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.cdi;
+
+/**
+ * The Camel CDI configuration. Camel CDI fires a {@code CdiCamelConfiguration} event
+ * during the deployment phase that the application can observe and use to configure it.
+ *
+ * Note that the event fired can only be used within the observer method invocation context. Any attempt to call one of its methods outside of that context will result in an `IllegalStateException` to be thrown.
+ */
+public interface CdiCamelConfiguration {
+
+    /**
+     * Overrides the Camel Cdi behavior to automatically add all RouteBuilders to context.
+     *
+     * @return this Camel CDI configuration
+     * @throws IllegalStateException if called outside of the observer method invocation
+     */
+    CdiCamelConfiguration autostartRoutes(boolean autostartRoutes);","[{'comment': 'The `autostart` semantic already exists in Camel and does not map with the implementation here, where routes are not even added to the corresponding Camel contexts.', 'commenter': 'astefanutti'}, {'comment': ""I don't quite follow. Suggestion for better name name of this setting?"", 'commenter': 'sverkera'}, {'comment': 'The existing `autostart` property implies routes added to a Camel context are not started when the context is started. In the current PR, the routes are not even added to the context. So either the routes are still auto-configured, i.e. added to the corresponding context, yet not started along with it, and the `autostartRoutes` configuration naming is consistent, or the routes are not added to the context and we need to find another name, like `autoConfigureRoutes`.', 'commenter': 'astefanutti'}, {'comment': 'Ok, changed.', 'commenter': 'sverkera'}]"
1319,components/camel-cdi/src/main/java/org/apache/camel/cdi/CdiCamelExtension.java,"@@ -239,7 +241,7 @@ private void beans(@Observes ProcessBean<?> pb, BeanManager manager) {
     }
 
     private void afterBeanDiscovery(@Observes AfterBeanDiscovery abd, BeanManager manager) {
-        // The set of extra Camel CDI beans
+    	// The set of extra Camel CDI beans","[{'comment': 'Unecessary', 'commenter': 'astefanutti'}, {'comment': 'Ok', 'commenter': 'sverkera'}]"
1319,components/camel-cdi/src/main/java/org/apache/camel/cdi/CdiCamelExtension.java,"@@ -373,6 +375,11 @@ private boolean shouldDeployDefaultCamelContext(Set<Bean<?>> beans) {
     }
 
     private void afterDeploymentValidation(@Observes AfterDeploymentValidation adv, BeanManager manager) {
+    	if(!configuration.isUnmodifiable()) {","[{'comment': 'At that stage the event is always modifiable, right? So the check could be removed?', 'commenter': 'astefanutti'}, {'comment': 'Ok', 'commenter': 'sverkera'}]"
1319,components/camel-cdi/src/test/java/org/apache/camel/cdi/test/CdiCamelConfigurationTest.java,"@@ -0,0 +1,57 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.cdi.test;
+
+import org.apache.camel.cdi.CdiCamelConfiguration;
+import org.apache.camel.cdi.CdiCamelExtension;
+import org.jboss.arquillian.container.test.api.Deployment;
+import org.jboss.arquillian.junit.Arquillian;
+import org.jboss.shrinkwrap.api.Archive;
+import org.jboss.shrinkwrap.api.ShrinkWrap;
+import org.jboss.shrinkwrap.api.asset.EmptyAsset;
+import org.jboss.shrinkwrap.api.spec.JavaArchive;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import javax.enterprise.event.Observes;
+
+import static org.junit.Assert.assertTrue;
+
+@RunWith(Arquillian.class)
+public class CdiCamelConfigurationTest {","[{'comment': 'We could provide a more comprehensive / functional test that covers that a RouteBuilder bean is not added to the Camel context instead of simply checking for the config event being fired.', 'commenter': 'astefanutti'}, {'comment': 'Ok', 'commenter': 'sverkera'}, {'comment': 'I added a test to check that no routebuilders exist on context', 'commenter': 'sverkera'}]"
1319,components/camel-cdi/src/main/java/org/apache/camel/cdi/CdiCamelExtension.java,"@@ -387,23 +394,25 @@ private void afterDeploymentValidation(@Observes AfterDeploymentValidation adv,
         }
 
         // Add routes to Camel contexts
-        boolean deploymentException = false;
-        Set<Bean<?>> routes = new HashSet<>(manager.getBeans(RoutesBuilder.class, ANY));
-        routes.addAll(manager.getBeans(RouteContainer.class, ANY));
-        for (Bean<?> context : manager.getBeans(CamelContext.class, ANY)) {
-            for (Bean<?> route : routes) {
-                Set<Annotation> qualifiers = new HashSet<>(context.getQualifiers());
-                qualifiers.retainAll(route.getQualifiers());
-                if (qualifiers.size() > 1) {
-                    deploymentException |= !addRouteToContext(route, context, manager, adv);
-                }
-            }
-        }
-        // Let's return to avoid starting misconfigured contexts
-        if (deploymentException) {
-            return;
+        if(configuration.autostartRoutes()) {
+        	boolean deploymentException = false;
+        	Set<Bean<?>> routes = new HashSet<>(manager.getBeans(RoutesBuilder.class, ANY));
+        	routes.addAll(manager.getBeans(RouteContainer.class, ANY));
+        	for (Bean<?> context : manager.getBeans(CamelContext.class, ANY)) {
+        		for (Bean<?> route : routes) {
+        			Set<Annotation> qualifiers = new HashSet<>(context.getQualifiers());
+        			qualifiers.retainAll(route.getQualifiers());
+        			if (qualifiers.size() > 1) {
+        				deploymentException |= !addRouteToContext(route, context, manager, adv);
+        			}
+        		}
+        	}
+        	// Let's return to avoid starting misconfigured contexts
+        	if (deploymentException) {
+        		return;
+        	}
         }
-
+        ","[{'comment': 'Unecessary', 'commenter': 'astefanutti'}, {'comment': 'Ok', 'commenter': 'sverkera'}]"
1319,components/camel-cdi/src/main/java/org/apache/camel/cdi/CdiCamelExtension.java,"@@ -387,23 +394,25 @@ private void afterDeploymentValidation(@Observes AfterDeploymentValidation adv,
         }
 
         // Add routes to Camel contexts
-        boolean deploymentException = false;
-        Set<Bean<?>> routes = new HashSet<>(manager.getBeans(RoutesBuilder.class, ANY));
-        routes.addAll(manager.getBeans(RouteContainer.class, ANY));
-        for (Bean<?> context : manager.getBeans(CamelContext.class, ANY)) {
-            for (Bean<?> route : routes) {
-                Set<Annotation> qualifiers = new HashSet<>(context.getQualifiers());
-                qualifiers.retainAll(route.getQualifiers());
-                if (qualifiers.size() > 1) {
-                    deploymentException |= !addRouteToContext(route, context, manager, adv);
-                }
-            }
-        }
-        // Let's return to avoid starting misconfigured contexts
-        if (deploymentException) {
-            return;
+        if(configuration.autostartRoutes()) {","[{'comment': ""Make sure you've run checkstyle as indentation seems a bit off. "", 'commenter': 'astefanutti'}, {'comment': 'Ok', 'commenter': 'sverkera'}]"
1319,components/camel-cdi/src/test/java/org/apache/camel/cdi/test/CdiCamelConfigurationTest.java,"@@ -0,0 +1,68 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.cdi.test;
+
+import javax.enterprise.event.Observes;
+import javax.inject.Inject;
+
+import org.apache.camel.CamelContext;
+import org.apache.camel.cdi.CdiCamelConfiguration;
+import org.apache.camel.cdi.CdiCamelExtension;
+import org.jboss.arquillian.container.test.api.Deployment;
+import org.jboss.arquillian.junit.Arquillian;
+import org.jboss.shrinkwrap.api.Archive;
+import org.jboss.shrinkwrap.api.ShrinkWrap;
+import org.jboss.shrinkwrap.api.asset.EmptyAsset;
+import org.jboss.shrinkwrap.api.spec.JavaArchive;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import static org.junit.Assert.assertTrue;
+
+@RunWith(Arquillian.class)
+public class CdiCamelConfigurationTest {
+    private static boolean configMethodHasBeenCalled;
+
+    @Inject
+    private CamelContext context;
+    
+    @Deployment
+    static Archive<?> createTestArchive() {
+        return ShrinkWrap.create(JavaArchive.class)
+            // Camel CDI
+            .addPackage(CdiCamelExtension.class.getPackage())
+            // Test classes
+            .addClasses(CdiCamelConfigurationTest.class)
+            // Bean archive deployment descriptor
+            .addAsManifestResource(EmptyAsset.INSTANCE, ""beans.xml"");
+    }
+
+    static void configuration(@Observes CdiCamelConfiguration configuration) {
+        configMethodHasBeenCalled = true;
+        configuration.autoConfigureRoutes(false);
+    }
+
+    @Test
+    public void checkThatConfigMethodHasBeenCalled() {
+        assertTrue(""Config method has not been called"", configMethodHasBeenCalled);
+    }
+
+    @Test
+    public void checkThatNoRouteBuildersAddedToContext() {
+        assertTrue(""There are RouteBuilder instances in context"", context.getRoutes().isEmpty());","[{'comment': 'There should be at least a `RouteBuilder` bean added to the deployment that would be added to the Camel context for the test to be actually relevant, that is testing the configuration logic.', 'commenter': 'astefanutti'}, {'comment': 'Ok', 'commenter': 'sverkera'}]"
1319,components/camel-cdi/src/main/java/org/apache/camel/cdi/CdiCamelConfiguration.java,"@@ -0,0 +1,41 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.cdi;
+
+/**
+ * The Camel CDI configuration. Camel CDI fires a {@code CdiCamelConfiguration} event
+ * during the deployment phase that the application can observe and use to configure it.
+ *
+ * Note that the event fired can only be used within the observer method invocation context.
+ * Any attempt to call one of its methods outside of that context will result in an 
+ * `IllegalStateException` to be thrown.
+ */
+public interface CdiCamelConfiguration {
+
+    /**
+     * Overrides the Camel CDI behavior to automatically add all RouteBuilders to context.","[{'comment': 'to context -> to the corresponding Camel contexts', 'commenter': 'astefanutti'}, {'comment': 'Ok', 'commenter': 'sverkera'}]"
1384,components/camel-mongodb/src/main/java/org/apache/camel/component/mongodb/MongoDbEndpoint.java,"@@ -182,6 +188,9 @@ private void validateOptions(char role) throws IllegalArgumentException {
                 if (persistentTailTracking && (ObjectHelper.isEmpty(persistentId))) {
                     throw new IllegalArgumentException(""persistentId is compulsory for persistent tail tracking"");
                 }
+                if (persistentTailTracking && (ObjectHelper.isEmpty(persistentId))) {","[{'comment': 'Is there any specific reason for having two times the same check?', 'commenter': 'oscerd'}]"
1385,components/camel-spring-ws/src/main/java/org/apache/camel/component/spring/ws/SpringWebserviceConfiguration.java,"@@ -401,5 +403,22 @@ public boolean isAllowResponseHeaderOverride() {
     public void setAllowResponseHeaderOverride(boolean allowResponseHeaderOverride) {
         this.allowResponseHeaderOverride = allowResponseHeaderOverride;
     }
+    /**
+     * @return boolean - true, will override attachments with spring-ws response message attachments
+     */
+    public boolean isAllowResponseAttachmentOverride() {
+        return allowResponseAttachmentOverride;
+    }
 
+    /**
+     * Option to override soap response attachments in in/out exchange with attachments from the actual service layer.
+     * If the invoked service appends or rewrites the soap attachments this option when set to true, allows the modified
+     * soap attachments to be overwritten in in/out message attachments
+     * 
+     * @param allowResponseAttachmentOverride","[{'comment': 'Can you put the description on the same line as `@param` ', 'commenter': 'davsclaus'}]"
1385,components/camel-spring-ws/src/main/java/org/apache/camel/component/spring/ws/SpringWebserviceConfiguration.java,"@@ -401,5 +403,22 @@ public boolean isAllowResponseHeaderOverride() {
     public void setAllowResponseHeaderOverride(boolean allowResponseHeaderOverride) {
         this.allowResponseHeaderOverride = allowResponseHeaderOverride;
     }
+    /**","[{'comment': 'imho better to just have javadoc on the setter', 'commenter': 'davsclaus'}]"
1385,components/camel-spring-ws/src/main/java/org/apache/camel/component/spring/ws/SpringWebserviceProducer.java,"@@ -139,7 +149,18 @@ private void populateMessageHeaderFromResponse(Message message, SoapHeader soapH
 
         }
     }
-
+    /**
+     * Populates message attachments from soap response attachments 
+     * @param inOrOut {@link Message}
+     * @param soapMessage {@link SoapMessage}
+     */
+    private void populateMessageAttachmentsFromResponse(Message inOrOut, Iterator<Attachment> attachments) {","[{'comment': 'Looks like you may have checkstyle issues. Can you run \r\n\r\n   mvn compile -Psourcecheck', 'commenter': 'davsclaus'}, {'comment': 'I made those fixes you requested, even though i did not implemented the soap header part, i just added the attachment population. ;)\r\n\r\nBut anyway, let me know if you have any other change requests.\r\n\r\nRegards Marcus', 'commenter': 'marcusmesserkewill'}]"
1388,components/camel-jetty9/src/main/java/org/apache/camel/component/jetty9/JettyContentExchange9.java,"@@ -214,14 +220,28 @@ public void onFailure(Request request, Throwable failure) {
             }
 
         };
-        BufferingResponseListener responseListener = new BufferingResponseListener() {
+
+        InputStreamResponseListener responseListener = new InputStreamResponseListener() {
+            ByteArrayOutputStream baos = new ByteArrayOutputStream();
+
+            @Override
+            public void onContent(Response response, ByteBuffer content, Callback callback) {
+                if (response.getStatus() != SC_OK) {
+                    LOG.warn(""Response received {}: {}"", response.getStatus(), response.getReason());
+                }
+                byte[] buffer = new byte[content.limit()];
+                content.get(buffer);
+                baos.write(buffer, 0, buffer.length);
+
+                callback.succeeded();
+            }
 
             @Override
             public void onComplete(Result result) {
                 if (result.isFailed()) {
                     doTaskCompleted(result.getFailure());
                 } else {
-                    onResponseComplete(result, getContent(), getMediaType());
+                    onResponseComplete(result, baos.toByteArray(), null);","[{'comment': 'Is there a reason for null as media Type? Just curiosity :-)\r\n\r\nThanks, I will test and merge', 'commenter': 'oscerd'}, {'comment': 'onResponseComplete takes mediaType as a parameter, but does not use it.  BufferingResponseListener has a getMediaType method, but InputStreamResponseListener.  I could just remove it from onResponseComplete instead.  ', 'commenter': 'kevinearls'}]"
1388,components/camel-jetty9/src/main/java/org/apache/camel/component/jetty9/JettyContentExchange9.java,"@@ -214,14 +220,28 @@ public void onFailure(Request request, Throwable failure) {
             }
 
         };
-        BufferingResponseListener responseListener = new BufferingResponseListener() {
+
+        InputStreamResponseListener responseListener = new InputStreamResponseListener() {
+            ByteArrayOutputStream baos = new ByteArrayOutputStream();
+
+            @Override
+            public void onContent(Response response, ByteBuffer content, Callback callback) {
+                if (response.getStatus() != SC_OK) {","[{'comment': 'Why this WARN log, wont you be able to get some error and still get data. I would remove that WARN', 'commenter': 'davsclaus'}, {'comment': ""I wasn't sure what to do in the case of a non-200 status here.  Treating this as a failure (in this case calling doTaskCompleted()) caused a bunch of other tests to fail.  Should I treat this as a failure and update the other tests, or just ignore it?"", 'commenter': 'kevinearls'}, {'comment': 'How do you know that the response is finished? What if there is a lot of data, wont this onContent be called multiple times?', 'commenter': 'davsclaus'}, {'comment': ""When the response is finished onComplete is called.  I don't think there's anyway to know in onContent if you've received all the data."", 'commenter': 'kevinearls'}, {'comment': ""Ah okay but a byte array stream is unfortunately hard limited, so if onContent is called multiple times the buffer looses data etc. What is needed is to be able to store the data in a growing buffer.\r\n\r\nYou can try to do like the MarshalProcessor which uses Camel's stream cache to write to its buffer. Then when you are done, you can get the result from its build method."", 'commenter': 'davsclaus'}]"
1388,components/camel-jetty9/src/main/java/org/apache/camel/component/jetty9/JettyContentExchange9.java,"@@ -214,14 +220,28 @@ public void onFailure(Request request, Throwable failure) {
             }
 
         };
-        BufferingResponseListener responseListener = new BufferingResponseListener() {
+
+        InputStreamResponseListener responseListener = new InputStreamResponseListener() {
+            ByteArrayOutputStream baos = new ByteArrayOutputStream();
+
+            @Override
+            public void onContent(Response response, ByteBuffer content, Callback callback) {
+                if (response.getStatus() != SC_OK) {
+                    LOG.warn(""Response received {}: {}"", response.getStatus(), response.getReason());
+                }
+                byte[] buffer = new byte[content.limit()];","[{'comment': ""This will stream all the data into memory which is not what we want. Either we should use Camel's stream caching or some other kind of solution as people want to stream bigger data from jetty without having to have all the data in memory.\r\n\r\nCamel has a stream caching that can overflow to disk for big data. Which we use in data formats etc and other places.\r\n\r\nI wonder what others are doing with Jetty and this kind of listener."", 'commenter': 'davsclaus'}]"
1390,components/camel-cdi-jee/pom.xml,"@@ -0,0 +1,65 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--
+  Licensed to the Apache Software Foundation (ASF) under one or more
+  contributor license agreements.  See the NOTICE file distributed with
+  this work for additional information regarding copyright ownership.
+  The ASF licenses this file to You under the Apache License, Version 2.0
+  (the ""License""); you may not use this file except in compliance with
+  the License.  You may obtain a copy of the License at
+
+  http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an ""AS IS"" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>org.apache.camel</groupId>
+    <artifactId>components</artifactId>
+    <version>2.19.0-SNAPSHOT</version>
+  </parent>
+
+  <artifactId>camel-cdi-jee</artifactId>","[{'comment': 'In the `camel-cdi` module, there is the `xml` package that provides support for Camel XML DSL import. There is a the open point to cover support for  `TransactionErrorHandler`: https://github.com/apache/camel/blob/4c8eab4e7358865a8ba09bc395232fcadb9260f3/components/camel-cdi/src/main/java/org/apache/camel/cdi/xml/ErrorHandlerType.java#L57\r\n\r\nSo the new JTA `TransactionErrorHandler` should be used, which raises the question of the Camel CDI modularity. Indeed, it is not possible to import from `camel-cdi-jee` into `camel-cdi` as it creates a cyclic dependency.\r\n\r\nThere are two options:\r\n- Either we create a `transaction` (or an `ee`) package within the existing `camel-cdi` module, which would declare an optional dependency on JTA\r\n- Or we move the `xml` package into a separate `camel-cdi-xml`\r\n\r\nThe former would mimic what does the `camel-spring` module, that bundles the transaction support. The later should be possible as the `xml` package does not depend on the core `cdi` package. I would tend to favor the former as it would keep avoid creating very small modules. We can still break it later. But in that case, we may want to improve the error message when JTA is missing, like with `camel-core-xml`: https://github.com/apache/camel/blob/4c8eab4e7358865a8ba09bc395232fcadb9260f3/components/camel-cdi/src/main/java/org/apache/camel/cdi/CdiCamelExtension.java#L253-L256.', 'commenter': 'astefanutti'}]"
1390,components/camel-cdi-jee/src/main/java/org/apache/camel/cdi/JavaEECamelContext.java,"@@ -0,0 +1,59 @@
+package org.apache.camel.cdi;","[{'comment': 'Packages should not be split across multiple JARs', 'commenter': 'astefanutti'}]"
1390,components/camel-cdi-jee/src/main/java/org/apache/camel/cdi/JavaEECamelContext.java,"@@ -0,0 +1,59 @@
+package org.apache.camel.cdi;
+
+import java.util.logging.Logger;
+
+/**
+ * A Camel context specialized for JavaEE environments
+ */
+@Vetoed
+public class JavaEECamelContext extends CdiCamelContext {","[{'comment': 'Should the CDI Camel context be configured, It would preferably be done through `CdiCamelConfiguration`: https://github.com/apache/camel/blob/4c8eab4e7358865a8ba09bc395232fcadb9260f3/components/camel-cdi/src/main/java/org/apache/camel/cdi/CdiCamelConfiguration.java#L27.\r\n\r\nIt can be enriched with an API that disables the auto start of the Camel contexts.', 'commenter': 'astefanutti'}]"
1390,components/camel-cdi-jee/src/main/java/org/apache/camel/cdi/JavaEERouteBuilder.java,"@@ -0,0 +1,46 @@
+package org.apache.camel.cdi;
+
+import java.util.HashMap;
+import java.util.Map;
+
+import org.apache.camel.LoggingLevel;
+import org.apache.camel.builder.RouteBuilder;
+import org.apache.camel.cdi.transaction.JavaEETransactionErrorHandlerBuilder;
+import org.apache.camel.model.ModelCamelContext;
+
+/**
+ * An extension of the {@link RouteBuilder} to provide some additional helper
+ * methods
+ *
+ * @version
+ */
+public abstract class JavaEERouteBuilder extends RouteBuilder {
+
+    /**
+     * Creates a transaction error handler that will lookup in application
+     * context for an exiting transaction manager.
+     *
+     * @return the created error handler
+     */
+    public JavaEETransactionErrorHandlerBuilder transactionErrorHandler() {
+        return new JavaEETransactionErrorHandlerBuilder(false);
+    }
+
+    public JavaEERouteBuilder rollbackLoggingLevel(final LoggingLevel loggingLevel) {","[{'comment': ""Couldn't that be a method of the `JavaEETransactionErrorHandlerBuilder` fluent API instead of piggybacking the context properties? "", 'commenter': 'astefanutti'}]"
1390,components/camel-cdi-jee/src/main/java/org/apache/camel/cdi/JavaEERouteBuilder.java,"@@ -0,0 +1,46 @@
+package org.apache.camel.cdi;","[{'comment': 'Packages should not be split across multiple JARs.', 'commenter': 'astefanutti'}]"
1390,components/camel-cdi-jee/src/main/java/org/apache/camel/cdi/JavaEERouteBuilder.java,"@@ -0,0 +1,46 @@
+package org.apache.camel.cdi;
+
+import java.util.HashMap;
+import java.util.Map;
+
+import org.apache.camel.LoggingLevel;
+import org.apache.camel.builder.RouteBuilder;
+import org.apache.camel.cdi.transaction.JavaEETransactionErrorHandlerBuilder;
+import org.apache.camel.model.ModelCamelContext;
+
+/**
+ * An extension of the {@link RouteBuilder} to provide some additional helper
+ * methods
+ *
+ * @version
+ */
+public abstract class JavaEERouteBuilder extends RouteBuilder {","[{'comment': 'Depending on the outcome of the Camel CDI modularity question, we may want to revise the classes prefix convention.', 'commenter': 'astefanutti'}]"
1390,components/camel-cdi-jee/src/main/java/org/apache/camel/cdi/transaction/JavaEETransactionErrorHandlerBuilder.java,"@@ -0,0 +1,173 @@
+package org.apache.camel.cdi.transaction;
+
+import java.util.Map;
+
+import org.apache.camel.CamelContext;
+import org.apache.camel.LoggingLevel;
+import org.apache.camel.Processor;
+import org.apache.camel.RuntimeCamelException;
+import org.apache.camel.builder.DefaultErrorHandlerBuilder;
+import org.apache.camel.builder.ErrorHandlerBuilder;
+import org.apache.camel.spi.Policy;
+import org.apache.camel.spi.RouteContext;
+import org.apache.camel.spi.TransactedPolicy;
+import org.apache.camel.util.CamelLogger;
+import org.apache.camel.util.ObjectHelper;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * Builds transactional error handlers. This class is based on
+ * {@link org.apache.camel.spring.spi.TransactionErrorHandlerBuilder}.
+ */
+public class JavaEETransactionErrorHandlerBuilder extends DefaultErrorHandlerBuilder {
+
+    private static final Logger LOG = LoggerFactory.getLogger(JavaEETransactionErrorHandlerBuilder.class);
+
+    private static final String PROPAGATION_REQUIRED = ""PROPAGATION_REQUIRED"";
+
+    public static final String ROLLBACK_LOGGING_LEVEL_PROPERTY = JavaEETransactionErrorHandlerBuilder.class.getName()
+            + ""#rollbackLoggingLevel"";
+
+    private LoggingLevel rollbackLoggingLevel = LoggingLevel.WARN;
+
+    private JavaEETransactionPolicy transactionPolicy;
+
+    private String policyRef;
+
+    /**
+     * indicates whether this is a global builder (not wrapped) or a
+     * specialization for a specific route which wraps a given error handler.
+     */
+    private boolean wrapped;
+
+    public JavaEETransactionErrorHandlerBuilder(final boolean wrapped) {","[{'comment': 'We may need a default constructor for the Camel XML DSL.', 'commenter': 'astefanutti'}]"
1390,components/camel-cdi-jee/src/main/java/org/apache/camel/cdi/transaction/JavaEETransactionErrorHandlerBuilder.java,"@@ -0,0 +1,173 @@
+package org.apache.camel.cdi.transaction;
+
+import java.util.Map;
+
+import org.apache.camel.CamelContext;
+import org.apache.camel.LoggingLevel;
+import org.apache.camel.Processor;
+import org.apache.camel.RuntimeCamelException;
+import org.apache.camel.builder.DefaultErrorHandlerBuilder;
+import org.apache.camel.builder.ErrorHandlerBuilder;
+import org.apache.camel.spi.Policy;
+import org.apache.camel.spi.RouteContext;
+import org.apache.camel.spi.TransactedPolicy;
+import org.apache.camel.util.CamelLogger;
+import org.apache.camel.util.ObjectHelper;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * Builds transactional error handlers. This class is based on
+ * {@link org.apache.camel.spring.spi.TransactionErrorHandlerBuilder}.
+ */
+public class JavaEETransactionErrorHandlerBuilder extends DefaultErrorHandlerBuilder {
+
+    private static final Logger LOG = LoggerFactory.getLogger(JavaEETransactionErrorHandlerBuilder.class);
+
+    private static final String PROPAGATION_REQUIRED = ""PROPAGATION_REQUIRED"";
+
+    public static final String ROLLBACK_LOGGING_LEVEL_PROPERTY = JavaEETransactionErrorHandlerBuilder.class.getName()
+            + ""#rollbackLoggingLevel"";
+
+    private LoggingLevel rollbackLoggingLevel = LoggingLevel.WARN;
+
+    private JavaEETransactionPolicy transactionPolicy;
+
+    private String policyRef;
+
+    /**
+     * indicates whether this is a global builder (not wrapped) or a
+     * specialization for a specific route which wraps a given error handler.
+     */
+    private boolean wrapped;
+
+    public JavaEETransactionErrorHandlerBuilder(final boolean wrapped) {
+        super();
+        this.wrapped = wrapped;
+    }
+
+    public boolean supportTransacted() {","[{'comment': 'Add `@Override` for consistency', 'commenter': 'astefanutti'}]"
1390,components/camel-cdi-jee/src/main/java/org/apache/camel/cdi/transaction/JavaEETransactionErrorHandlerBuilder.java,"@@ -0,0 +1,173 @@
+package org.apache.camel.cdi.transaction;
+
+import java.util.Map;
+
+import org.apache.camel.CamelContext;
+import org.apache.camel.LoggingLevel;
+import org.apache.camel.Processor;
+import org.apache.camel.RuntimeCamelException;
+import org.apache.camel.builder.DefaultErrorHandlerBuilder;
+import org.apache.camel.builder.ErrorHandlerBuilder;
+import org.apache.camel.spi.Policy;
+import org.apache.camel.spi.RouteContext;
+import org.apache.camel.spi.TransactedPolicy;
+import org.apache.camel.util.CamelLogger;
+import org.apache.camel.util.ObjectHelper;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * Builds transactional error handlers. This class is based on
+ * {@link org.apache.camel.spring.spi.TransactionErrorHandlerBuilder}.
+ */
+public class JavaEETransactionErrorHandlerBuilder extends DefaultErrorHandlerBuilder {
+
+    private static final Logger LOG = LoggerFactory.getLogger(JavaEETransactionErrorHandlerBuilder.class);
+
+    private static final String PROPAGATION_REQUIRED = ""PROPAGATION_REQUIRED"";
+
+    public static final String ROLLBACK_LOGGING_LEVEL_PROPERTY = JavaEETransactionErrorHandlerBuilder.class.getName()
+            + ""#rollbackLoggingLevel"";
+
+    private LoggingLevel rollbackLoggingLevel = LoggingLevel.WARN;
+
+    private JavaEETransactionPolicy transactionPolicy;
+
+    private String policyRef;
+
+    /**
+     * indicates whether this is a global builder (not wrapped) or a
+     * specialization for a specific route which wraps a given error handler.
+     */
+    private boolean wrapped;","[{'comment': 'Could be final', 'commenter': 'astefanutti'}]"
1390,components/camel-cdi-jee/src/main/java/org/apache/camel/cdi/transaction/JavaEETransactionErrorHandlerBuilder.java,"@@ -0,0 +1,173 @@
+package org.apache.camel.cdi.transaction;
+
+import java.util.Map;
+
+import org.apache.camel.CamelContext;
+import org.apache.camel.LoggingLevel;
+import org.apache.camel.Processor;
+import org.apache.camel.RuntimeCamelException;
+import org.apache.camel.builder.DefaultErrorHandlerBuilder;
+import org.apache.camel.builder.ErrorHandlerBuilder;
+import org.apache.camel.spi.Policy;
+import org.apache.camel.spi.RouteContext;
+import org.apache.camel.spi.TransactedPolicy;
+import org.apache.camel.util.CamelLogger;
+import org.apache.camel.util.ObjectHelper;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * Builds transactional error handlers. This class is based on
+ * {@link org.apache.camel.spring.spi.TransactionErrorHandlerBuilder}.
+ */
+public class JavaEETransactionErrorHandlerBuilder extends DefaultErrorHandlerBuilder {
+
+    private static final Logger LOG = LoggerFactory.getLogger(JavaEETransactionErrorHandlerBuilder.class);
+
+    private static final String PROPAGATION_REQUIRED = ""PROPAGATION_REQUIRED"";
+
+    public static final String ROLLBACK_LOGGING_LEVEL_PROPERTY = JavaEETransactionErrorHandlerBuilder.class.getName()
+            + ""#rollbackLoggingLevel"";
+
+    private LoggingLevel rollbackLoggingLevel = LoggingLevel.WARN;
+
+    private JavaEETransactionPolicy transactionPolicy;
+
+    private String policyRef;
+
+    /**
+     * indicates whether this is a global builder (not wrapped) or a
+     * specialization for a specific route which wraps a given error handler.
+     */
+    private boolean wrapped;
+
+    public JavaEETransactionErrorHandlerBuilder(final boolean wrapped) {
+        super();","[{'comment': 'Call to `super()` is always done as per JLS.', 'commenter': 'astefanutti'}]"
1390,components/camel-cdi-jee/src/main/java/org/apache/camel/cdi/transaction/JavaEETransactionErrorHandlerBuilder.java,"@@ -0,0 +1,173 @@
+package org.apache.camel.cdi.transaction;
+
+import java.util.Map;
+
+import org.apache.camel.CamelContext;
+import org.apache.camel.LoggingLevel;
+import org.apache.camel.Processor;
+import org.apache.camel.RuntimeCamelException;
+import org.apache.camel.builder.DefaultErrorHandlerBuilder;
+import org.apache.camel.builder.ErrorHandlerBuilder;
+import org.apache.camel.spi.Policy;
+import org.apache.camel.spi.RouteContext;
+import org.apache.camel.spi.TransactedPolicy;
+import org.apache.camel.util.CamelLogger;
+import org.apache.camel.util.ObjectHelper;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * Builds transactional error handlers. This class is based on
+ * {@link org.apache.camel.spring.spi.TransactionErrorHandlerBuilder}.
+ */
+public class JavaEETransactionErrorHandlerBuilder extends DefaultErrorHandlerBuilder {
+
+    private static final Logger LOG = LoggerFactory.getLogger(JavaEETransactionErrorHandlerBuilder.class);
+
+    private static final String PROPAGATION_REQUIRED = ""PROPAGATION_REQUIRED"";
+
+    public static final String ROLLBACK_LOGGING_LEVEL_PROPERTY = JavaEETransactionErrorHandlerBuilder.class.getName()
+            + ""#rollbackLoggingLevel"";
+
+    private LoggingLevel rollbackLoggingLevel = LoggingLevel.WARN;
+
+    private JavaEETransactionPolicy transactionPolicy;
+
+    private String policyRef;
+
+    /**
+     * indicates whether this is a global builder (not wrapped) or a
+     * specialization for a specific route which wraps a given error handler.
+     */
+    private boolean wrapped;
+
+    public JavaEETransactionErrorHandlerBuilder(final boolean wrapped) {
+        super();
+        this.wrapped = wrapped;
+    }
+
+    public boolean supportTransacted() {
+        return true;
+    }
+
+    @Override
+    public ErrorHandlerBuilder cloneBuilder() {
+
+        final JavaEETransactionErrorHandlerBuilder answer = new JavaEETransactionErrorHandlerBuilder(true);
+        cloneBuilder(answer);
+        return answer;
+
+    }
+
+    @Override
+    protected void cloneBuilder(DefaultErrorHandlerBuilder other) {
+
+        super.cloneBuilder(other);
+        if (other instanceof JavaEETransactionErrorHandlerBuilder) {
+            final JavaEETransactionErrorHandlerBuilder otherTx = (JavaEETransactionErrorHandlerBuilder) other;
+            transactionPolicy = otherTx.transactionPolicy;
+            rollbackLoggingLevel = otherTx.rollbackLoggingLevel;
+        }
+
+    }
+
+    public Processor createErrorHandler(final RouteContext routeContext, final Processor processor) throws Exception {
+
+        // resolve policy reference, if given
+        if (transactionPolicy == null) {
+
+            if (policyRef != null) {
+
+                final TransactedDefinition transactedDefinition = new TransactedDefinition();
+                transactedDefinition.setRef(policyRef);
+                final Policy policy = transactedDefinition.resolvePolicy(routeContext);
+                if (policy != null) {
+                    if (!(policy instanceof JavaEETransactionPolicy)) {
+                        throw new RuntimeCamelException(""The configured policy '"" + policyRef + ""' is of type '""
+                                + policyRef.getClass().getName() + ""' but an instance of '""
+                                + JavaEETransactionPolicy.class.getName() + ""' is required!"");
+                    }
+                    transactionPolicy = (JavaEETransactionPolicy) policy;
+                }
+
+            }
+
+        }
+
+        // try to lookup default policy
+        if (transactionPolicy == null) {
+
+            LOG.debug(
+                    ""No TransactionTemplate configured on TransactionErrorHandlerBuilder. Will try find it in the registry."");
+
+            Map<String, TransactedPolicy> mapPolicy = routeContext.lookupByType(TransactedPolicy.class);
+            if (mapPolicy != null && mapPolicy.size() == 1) {
+                TransactedPolicy policy = mapPolicy.values().iterator().next();
+                if (policy != null && policy instanceof JavaEETransactionPolicy) {
+                    transactionPolicy = ((JavaEETransactionPolicy) policy);
+                }
+            }
+
+            if (transactionPolicy == null) {
+                TransactedPolicy policy = routeContext.lookup(PROPAGATION_REQUIRED, TransactedPolicy.class);
+                if (policy != null && policy instanceof JavaEETransactionPolicy) {
+                    transactionPolicy = ((JavaEETransactionPolicy) policy);
+                }
+            }
+
+            if (transactionPolicy != null) {
+                LOG.debug(""Found TransactionPolicy in registry to use: "" + transactionPolicy);
+            }
+
+        }
+
+        ObjectHelper.notNull(transactionPolicy, ""transactionPolicy"", this);
+
+        final CamelContext camelContext = routeContext.getCamelContext();
+        final Map<String, String> properties = camelContext.getProperties();
+        if ((properties != null) && properties.containsKey(ROLLBACK_LOGGING_LEVEL_PROPERTY)) {
+            rollbackLoggingLevel = LoggingLevel.valueOf(properties.get(ROLLBACK_LOGGING_LEVEL_PROPERTY));
+        }
+
+        RedeliveryErrorHandler answer = new RedeliveryErrorHandler(camelContext,
+                processor,
+                getLogger(),
+                getOnRedelivery(),
+                getRedeliveryPolicy(),
+                getExceptionPolicyStrategy(),
+                transactionPolicy,
+                getRetryWhilePolicy(camelContext),
+                getExecutorService(camelContext),
+                rollbackLoggingLevel,
+                getOnExceptionOccurred());
+
+        // configure error handler before we can use it
+        configure(routeContext, answer);
+        return answer;
+
+    }
+
+    public JavaEETransactionErrorHandlerBuilder setTransactionPolicy(final String ref) {
+        policyRef = ref;
+        return this;
+    }
+
+    public JavaEETransactionErrorHandlerBuilder setTransactionPolicy(final JavaEETransactionPolicy transactionPolicy) {
+        this.transactionPolicy = transactionPolicy;
+        return this;
+    }
+
+    protected CamelLogger createLogger() {
+        return new CamelLogger(LoggerFactory.getLogger(TransactionErrorHandler.class), LoggingLevel.ERROR);
+    }
+
+    @Override
+    public String toString() {
+        return ""TransactionErrorHandlerBuilder"";","[{'comment': 'Seems like a copy / paste to be updated', 'commenter': 'astefanutti'}]"
1390,components/camel-cdi-jee/src/main/java/org/apache/camel/cdi/transaction/JavaEETransactionErrorHandlerBuilder.java,"@@ -0,0 +1,173 @@
+package org.apache.camel.cdi.transaction;
+
+import java.util.Map;
+
+import org.apache.camel.CamelContext;
+import org.apache.camel.LoggingLevel;
+import org.apache.camel.Processor;
+import org.apache.camel.RuntimeCamelException;
+import org.apache.camel.builder.DefaultErrorHandlerBuilder;
+import org.apache.camel.builder.ErrorHandlerBuilder;
+import org.apache.camel.spi.Policy;
+import org.apache.camel.spi.RouteContext;
+import org.apache.camel.spi.TransactedPolicy;
+import org.apache.camel.util.CamelLogger;
+import org.apache.camel.util.ObjectHelper;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * Builds transactional error handlers. This class is based on
+ * {@link org.apache.camel.spring.spi.TransactionErrorHandlerBuilder}.
+ */
+public class JavaEETransactionErrorHandlerBuilder extends DefaultErrorHandlerBuilder {
+
+    private static final Logger LOG = LoggerFactory.getLogger(JavaEETransactionErrorHandlerBuilder.class);
+
+    private static final String PROPAGATION_REQUIRED = ""PROPAGATION_REQUIRED"";
+
+    public static final String ROLLBACK_LOGGING_LEVEL_PROPERTY = JavaEETransactionErrorHandlerBuilder.class.getName()
+            + ""#rollbackLoggingLevel"";
+
+    private LoggingLevel rollbackLoggingLevel = LoggingLevel.WARN;
+
+    private JavaEETransactionPolicy transactionPolicy;
+
+    private String policyRef;
+
+    /**
+     * indicates whether this is a global builder (not wrapped) or a
+     * specialization for a specific route which wraps a given error handler.
+     */
+    private boolean wrapped;
+
+    public JavaEETransactionErrorHandlerBuilder(final boolean wrapped) {
+        super();
+        this.wrapped = wrapped;
+    }
+
+    public boolean supportTransacted() {
+        return true;
+    }
+
+    @Override
+    public ErrorHandlerBuilder cloneBuilder() {
+
+        final JavaEETransactionErrorHandlerBuilder answer = new JavaEETransactionErrorHandlerBuilder(true);
+        cloneBuilder(answer);
+        return answer;
+
+    }
+
+    @Override
+    protected void cloneBuilder(DefaultErrorHandlerBuilder other) {
+
+        super.cloneBuilder(other);
+        if (other instanceof JavaEETransactionErrorHandlerBuilder) {
+            final JavaEETransactionErrorHandlerBuilder otherTx = (JavaEETransactionErrorHandlerBuilder) other;
+            transactionPolicy = otherTx.transactionPolicy;
+            rollbackLoggingLevel = otherTx.rollbackLoggingLevel;
+        }
+
+    }
+
+    public Processor createErrorHandler(final RouteContext routeContext, final Processor processor) throws Exception {
+
+        // resolve policy reference, if given
+        if (transactionPolicy == null) {
+
+            if (policyRef != null) {
+
+                final TransactedDefinition transactedDefinition = new TransactedDefinition();
+                transactedDefinition.setRef(policyRef);
+                final Policy policy = transactedDefinition.resolvePolicy(routeContext);
+                if (policy != null) {
+                    if (!(policy instanceof JavaEETransactionPolicy)) {
+                        throw new RuntimeCamelException(""The configured policy '"" + policyRef + ""' is of type '""
+                                + policyRef.getClass().getName() + ""' but an instance of '""
+                                + JavaEETransactionPolicy.class.getName() + ""' is required!"");
+                    }
+                    transactionPolicy = (JavaEETransactionPolicy) policy;
+                }
+
+            }
+
+        }
+
+        // try to lookup default policy
+        if (transactionPolicy == null) {
+
+            LOG.debug(
+                    ""No TransactionTemplate configured on TransactionErrorHandlerBuilder. Will try find it in the registry."");","[{'comment': '`TransactionTemplate` is rather a Spring concept. `TransactionErrorHandlerBuilder` seems like a copy / paste to be updated.', 'commenter': 'astefanutti'}]"
1390,components/camel-cdi-jee/src/main/java/org/apache/camel/cdi/transaction/JavaEETransactionErrorHandlerBuilder.java,"@@ -0,0 +1,173 @@
+package org.apache.camel.cdi.transaction;
+
+import java.util.Map;
+
+import org.apache.camel.CamelContext;
+import org.apache.camel.LoggingLevel;
+import org.apache.camel.Processor;
+import org.apache.camel.RuntimeCamelException;
+import org.apache.camel.builder.DefaultErrorHandlerBuilder;
+import org.apache.camel.builder.ErrorHandlerBuilder;
+import org.apache.camel.spi.Policy;
+import org.apache.camel.spi.RouteContext;
+import org.apache.camel.spi.TransactedPolicy;
+import org.apache.camel.util.CamelLogger;
+import org.apache.camel.util.ObjectHelper;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * Builds transactional error handlers. This class is based on
+ * {@link org.apache.camel.spring.spi.TransactionErrorHandlerBuilder}.
+ */
+public class JavaEETransactionErrorHandlerBuilder extends DefaultErrorHandlerBuilder {
+
+    private static final Logger LOG = LoggerFactory.getLogger(JavaEETransactionErrorHandlerBuilder.class);
+
+    private static final String PROPAGATION_REQUIRED = ""PROPAGATION_REQUIRED"";
+
+    public static final String ROLLBACK_LOGGING_LEVEL_PROPERTY = JavaEETransactionErrorHandlerBuilder.class.getName()
+            + ""#rollbackLoggingLevel"";
+
+    private LoggingLevel rollbackLoggingLevel = LoggingLevel.WARN;
+
+    private JavaEETransactionPolicy transactionPolicy;
+
+    private String policyRef;
+
+    /**
+     * indicates whether this is a global builder (not wrapped) or a
+     * specialization for a specific route which wraps a given error handler.
+     */
+    private boolean wrapped;
+
+    public JavaEETransactionErrorHandlerBuilder(final boolean wrapped) {
+        super();
+        this.wrapped = wrapped;
+    }
+
+    public boolean supportTransacted() {
+        return true;
+    }
+
+    @Override
+    public ErrorHandlerBuilder cloneBuilder() {
+
+        final JavaEETransactionErrorHandlerBuilder answer = new JavaEETransactionErrorHandlerBuilder(true);
+        cloneBuilder(answer);
+        return answer;
+
+    }
+
+    @Override
+    protected void cloneBuilder(DefaultErrorHandlerBuilder other) {
+
+        super.cloneBuilder(other);
+        if (other instanceof JavaEETransactionErrorHandlerBuilder) {
+            final JavaEETransactionErrorHandlerBuilder otherTx = (JavaEETransactionErrorHandlerBuilder) other;
+            transactionPolicy = otherTx.transactionPolicy;
+            rollbackLoggingLevel = otherTx.rollbackLoggingLevel;
+        }
+
+    }
+
+    public Processor createErrorHandler(final RouteContext routeContext, final Processor processor) throws Exception {
+
+        // resolve policy reference, if given
+        if (transactionPolicy == null) {
+
+            if (policyRef != null) {
+
+                final TransactedDefinition transactedDefinition = new TransactedDefinition();
+                transactedDefinition.setRef(policyRef);
+                final Policy policy = transactedDefinition.resolvePolicy(routeContext);
+                if (policy != null) {
+                    if (!(policy instanceof JavaEETransactionPolicy)) {
+                        throw new RuntimeCamelException(""The configured policy '"" + policyRef + ""' is of type '""
+                                + policyRef.getClass().getName() + ""' but an instance of '""
+                                + JavaEETransactionPolicy.class.getName() + ""' is required!"");
+                    }
+                    transactionPolicy = (JavaEETransactionPolicy) policy;
+                }
+
+            }
+
+        }
+
+        // try to lookup default policy
+        if (transactionPolicy == null) {
+
+            LOG.debug(
+                    ""No TransactionTemplate configured on TransactionErrorHandlerBuilder. Will try find it in the registry."");
+
+            Map<String, TransactedPolicy> mapPolicy = routeContext.lookupByType(TransactedPolicy.class);
+            if (mapPolicy != null && mapPolicy.size() == 1) {
+                TransactedPolicy policy = mapPolicy.values().iterator().next();
+                if (policy != null && policy instanceof JavaEETransactionPolicy) {
+                    transactionPolicy = ((JavaEETransactionPolicy) policy);
+                }
+            }
+
+            if (transactionPolicy == null) {
+                TransactedPolicy policy = routeContext.lookup(PROPAGATION_REQUIRED, TransactedPolicy.class);
+                if (policy != null && policy instanceof JavaEETransactionPolicy) {
+                    transactionPolicy = ((JavaEETransactionPolicy) policy);
+                }
+            }
+
+            if (transactionPolicy != null) {
+                LOG.debug(""Found TransactionPolicy in registry to use: "" + transactionPolicy);
+            }
+
+        }
+
+        ObjectHelper.notNull(transactionPolicy, ""transactionPolicy"", this);
+
+        final CamelContext camelContext = routeContext.getCamelContext();
+        final Map<String, String> properties = camelContext.getProperties();
+        if ((properties != null) && properties.containsKey(ROLLBACK_LOGGING_LEVEL_PROPERTY)) {
+            rollbackLoggingLevel = LoggingLevel.valueOf(properties.get(ROLLBACK_LOGGING_LEVEL_PROPERTY));
+        }
+
+        RedeliveryErrorHandler answer = new RedeliveryErrorHandler(camelContext,
+                processor,
+                getLogger(),
+                getOnRedelivery(),
+                getRedeliveryPolicy(),
+                getExceptionPolicyStrategy(),
+                transactionPolicy,
+                getRetryWhilePolicy(camelContext),
+                getExecutorService(camelContext),
+                rollbackLoggingLevel,
+                getOnExceptionOccurred());
+
+        // configure error handler before we can use it
+        configure(routeContext, answer);
+        return answer;
+
+    }
+
+    public JavaEETransactionErrorHandlerBuilder setTransactionPolicy(final String ref) {
+        policyRef = ref;
+        return this;
+    }
+
+    public JavaEETransactionErrorHandlerBuilder setTransactionPolicy(final JavaEETransactionPolicy transactionPolicy) {
+        this.transactionPolicy = transactionPolicy;
+        return this;
+    }
+
+    protected CamelLogger createLogger() {
+        return new CamelLogger(LoggerFactory.getLogger(TransactionErrorHandler.class), LoggingLevel.ERROR);
+    }
+
+    @Override
+    public String toString() {
+        return ""TransactionErrorHandlerBuilder"";
+    }
+
+    public boolean isWrapped() {","[{'comment': 'Is that used? it may be an internal.', 'commenter': 'astefanutti'}]"
1390,components/camel-cdi-jee/src/main/java/org/apache/camel/cdi/transaction/RedeliveryErrorHandler.java,"@@ -0,0 +1,48 @@
+package org.apache.camel.cdi.transaction;
+
+import java.util.concurrent.ScheduledExecutorService;
+
+import org.apache.camel.CamelContext;
+import org.apache.camel.LoggingLevel;
+import org.apache.camel.Predicate;
+import org.apache.camel.Processor;
+import org.apache.camel.processor.RedeliveryPolicy;
+import org.apache.camel.processor.exceptionpolicy.ExceptionPolicyStrategy;
+import org.apache.camel.util.CamelLogger;
+
+/**
+ * This error handler does redelivering. If the transaction fails it can be
+ * retried if configured to do so. In the Spring implementation redelivering is
+ * done within the transaction which is not appropriate in JavaEE since every
+ * error breaks the current transaction.
+ */
+public class RedeliveryErrorHandler extends org.apache.camel.processor.RedeliveryErrorHandler {","[{'comment': 'We may want to follow the current naming convention', 'commenter': 'astefanutti'}]"
1390,components/camel-cdi-jee/src/main/java/org/apache/camel/cdi/transaction/SupportsEETransactionPolicy.java,"@@ -0,0 +1,15 @@
+package org.apache.camel.cdi.transaction;
+
+import javax.inject.Named;
+
+@Named(""PROPAGATION_SUPPORTS"")
+public class SupportsEETransactionPolicy extends TransactionalJavaEETransactionPolicy {","[{'comment': 'Discrepancy with the naming convention', 'commenter': 'astefanutti'}]"
1390,components/camel-cdi-jee/src/main/java/org/apache/camel/cdi/transaction/JavaEETransactionPolicy.java,"@@ -0,0 +1,136 @@
+package org.apache.camel.cdi.transaction;
+
+import javax.annotation.Resource;
+import javax.transaction.TransactionManager;
+
+import org.apache.camel.Processor;
+import org.apache.camel.RuntimeCamelException;
+import org.apache.camel.builder.ErrorHandlerBuilder;
+import org.apache.camel.builder.ErrorHandlerBuilderRef;
+import org.apache.camel.model.ProcessorDefinition;
+import org.apache.camel.spi.RouteContext;
+import org.apache.camel.spi.TransactedPolicy;
+import org.apache.camel.util.ObjectHelper;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * Sets a proper error handler. This class is based on
+ * {@link org.apache.camel.spring.spi.SpringTransactionPolicy}.
+ * <p>
+ * This class requires the resource {@link TransactionManager} to be available
+ * through JNDI url &quot;java:/TransactionManager&quot;
+ */
+public abstract class JavaEETransactionPolicy implements TransactedPolicy {
+
+    private static final Logger LOG = LoggerFactory.getLogger(JavaEETransactionPolicy.class);
+
+    public static interface Runnable {
+        void run() throws Throwable;
+    }
+
+    @Resource(lookup = ""java:/TransactionManager"")","[{'comment': 'We may want to refine the strategy to lookup for the transaction manager. In a _micro service_ (or MicroProfile), we may want to use CDI and JTA only. So the lookup will be done through CDI and not JNDI. That being said, we can refine later on.', 'commenter': 'astefanutti'}]"
1390,components/camel-cdi-jee/src/main/java/org/apache/camel/cdi/transaction/TransactionErrorHandler.java,"@@ -0,0 +1,370 @@
+package org.apache.camel.cdi.transaction;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.concurrent.ScheduledExecutorService;
+
+import javax.transaction.TransactionRolledbackException;
+
+import org.apache.camel.AsyncCallback;
+import org.apache.camel.AsyncProcessor;
+import org.apache.camel.CamelContext;
+import org.apache.camel.Exchange;
+import org.apache.camel.LoggingLevel;
+import org.apache.camel.Navigate;
+import org.apache.camel.Processor;
+import org.apache.camel.RuntimeCamelException;
+import org.apache.camel.processor.ErrorHandlerSupport;
+import org.apache.camel.processor.exceptionpolicy.ExceptionPolicyStrategy;
+import org.apache.camel.spi.ShutdownPrepared;
+import org.apache.camel.util.ExchangeHelper;
+import org.apache.camel.util.ObjectHelper;
+import org.apache.camel.util.ServiceHelper;
+
+/**
+ * Does transactional execution according given policy. This class is based on
+ * {@link org.apache.camel.spring.spi.TransactionErrorHandler} excluding
+ * redelivery functionality. In the Spring implementation redelivering is done
+ * within the transaction which is not appropriate in JavaEE since every error
+ * breaks the current transaction.
+ */
+public class TransactionErrorHandler extends ErrorHandlerSupport","[{'comment': ""I wonder how much that'd make sense to factorise with Spring implementation. Just a comment, we can refactor later."", 'commenter': 'astefanutti'}]"
1390,components/camel-cdi-jee/.gitignore,"@@ -0,0 +1,4 @@
+.classpath","[{'comment': 'I think that file can be removed.', 'commenter': 'astefanutti'}]"
1390,components/camel-cdi-jee/pom.xml,"@@ -0,0 +1,65 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>","[{'comment': 'Add missing LICENSE header', 'commenter': 'davsclaus'}, {'comment': 'Added missing license header in pom file', 'commenter': 'hokutor'}]"
1390,components/camel-cdi-jee/src/main/resources/META-INF/beans.xml,"@@ -0,0 +1,3 @@
+<beans xmlns=""http://java.sun.com/xml/ns/javaee"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/beans_1_0.xsd"">","[{'comment': 'I think that file can be removed.', 'commenter': 'astefanutti'}]"
1390,components/camel-cdi/pom.xml,"@@ -115,6 +115,14 @@
       <optional>true</optional>
     </dependency>
 
+	<dependency>","[{'comment': 'Mind the formatting of POM files with spaces.', 'commenter': 'astefanutti'}]"
1390,components/camel-cdi/src/main/java/org/apache/camel/cdi/CdiCamelExtension.java,"@@ -415,16 +415,18 @@ private void afterDeploymentValidation(@Observes AfterDeploymentValidation adv,
             .forEach(bean -> getReference(manager, bean.getBeanClass(), bean).toString());
 
         // Start Camel contexts
-        for (CamelContext context : contexts) {
-            if (ServiceStatus.Started.equals(context.getStatus())) {
-                continue;
-            }
-            logger.info(""Camel CDI is starting Camel context [{}]"", context.getName());
-            try {
-                context.start();
-            } catch (Exception exception) {
-                adv.addDeploymentProblem(exception);
-            }
+        if (configuration.autoStartContexts()) {
+	        for (CamelContext context : contexts) {","[{'comment': 'Mind the formatting.', 'commenter': 'astefanutti'}]"
1390,components/camel-cdi/src/main/java/org/apache/camel/cdi/transaction/JavaEETransactionErrorHandler.java,"@@ -0,0 +1,48 @@
+package org.apache.camel.cdi.transaction;
+
+import java.util.concurrent.ScheduledExecutorService;
+
+import org.apache.camel.CamelContext;
+import org.apache.camel.LoggingLevel;
+import org.apache.camel.Predicate;
+import org.apache.camel.Processor;
+import org.apache.camel.processor.RedeliveryPolicy;
+import org.apache.camel.processor.exceptionpolicy.ExceptionPolicyStrategy;
+import org.apache.camel.util.CamelLogger;
+
+/**
+ * This error handler does redelivering. If the transaction fails it can be
+ * retried if configured to do so. In the Spring implementation redelivering is
+ * done within the transaction which is not appropriate in JavaEE since every
+ * error breaks the current transaction.
+ */
+public class JavaEETransactionErrorHandler extends org.apache.camel.processor.RedeliveryErrorHandler {","[{'comment': 'FQN could be imported.', 'commenter': 'astefanutti'}]"
1390,components/camel-cdi/src/main/java/org/apache/camel/cdi/transaction/TransactedDefinition.java,"@@ -0,0 +1,18 @@
+package org.apache.camel.cdi.transaction;
+
+import org.apache.camel.spi.Policy;
+import org.apache.camel.spi.RouteContext;
+
+/**
+ * Used to expose the method &apos;resolvePolicy&apos; used by
+ * {@link JavaEETransactionErrorHandlerBuilder} to resolve configured policy
+ * references.
+ */
+public class TransactedDefinition extends org.apache.camel.model.TransactedDefinition {","[{'comment': 'I would rename it `JtaTransactedDefinition` and remove the parent FQN.', 'commenter': 'astefanutti'}]"
1390,components/camel-cdi/src/main/java/org/apache/camel/cdi/JavaEERouteBuilder.java,"@@ -0,0 +1,24 @@
+package org.apache.camel.cdi;
+
+import org.apache.camel.builder.RouteBuilder;
+import org.apache.camel.cdi.transaction.JavaEETransactionErrorHandlerBuilder;
+
+/**
+ * An extension of the {@link RouteBuilder} to provide some additional helper
+ * methods
+ *
+ * @version
+ */
+public abstract class JavaEERouteBuilder extends RouteBuilder {","[{'comment': 'I would suggest to change every `JavaEE` suffixes to `Jta` to be more specific. ', 'commenter': 'astefanutti'}]"
1390,components/camel-cdi/src/main/java/org/apache/camel/cdi/transaction/TransactionalJavaEETransactionPolicy.java,"@@ -0,0 +1,121 @@
+package org.apache.camel.cdi.transaction;
+
+import javax.transaction.HeuristicMixedException;
+import javax.transaction.HeuristicRollbackException;
+import javax.transaction.RollbackException;
+import javax.transaction.Status;
+import javax.transaction.SystemException;
+import javax.transaction.Transaction;
+
+import org.apache.camel.CamelException;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * Helper methods for transaction handling
+ */
+public abstract class TransactionalJavaEETransactionPolicy extends JavaEETransactionPolicy {","[{'comment': ""I wonder to what extent that'd make sense to have that class merged with `JavaEETransactionPolicy` and have it renamed `JtaTransactionPolicy`. Indeed, I would not expect an non transactional JTA transaction policy."", 'commenter': 'astefanutti'}]"
1404,camel-core/src/main/java/org/apache/camel/api/management/mbean/ManagedThrottlingExceptionRoutePolicyMBean.java,"@@ -0,0 +1,55 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.api.management.mbean;
+
+import org.apache.camel.api.management.ManagedAttribute;
+
+public interface ManagedThrottlingExceptionRoutePolicyMBean extends ManagedServiceMBean {
+
+    @ManagedAttribute(description = ""how long to wait before moving open circuit to half open"")","[{'comment': 'Can you upper case the first letter of these descriptions', 'commenter': 'davsclaus'}, {'comment': 'will do, should have picked up on that from other code and the changes you made on last PR', 'commenter': 'CodeSmell'}]"
1404,camel-core/src/main/java/org/apache/camel/impl/ThrottlingExceptionRoutePolicy.java,"@@ -261,11 +261,11 @@ private void logState() {
     
     public String dumpState() {
         int num = state.get();
-        String state = stateAsString(num);
+        String routeState = stateAsString(num);
         if (failures.get() > 0) {
-            return String.format(""*** State %s, failures %d, last failure %d ms ago"", state, failures.get(), System.currentTimeMillis() - lastFailure);
+            return String.format(""*** State %s, failures %d, last failure %d ms ago"", routeState, failures.get(), System.currentTimeMillis() - lastFailure);","[{'comment': 'Can you remove the *** ', 'commenter': 'davsclaus'}, {'comment': ""I'm on it"", 'commenter': 'CodeSmell'}, {'comment': 'Will also add a test for JMX stuff', 'commenter': 'CodeSmell'}]"
1404,camel-core/src/main/java/org/apache/camel/impl/ThrottlingExceptionRoutePolicy.java,"@@ -71,11 +71,11 @@
     private ThrottlingExceptionHalfOpenHandler halfOpenHandler;
 
     // stateful information
-    private final AtomicInteger failures = new AtomicInteger();
-    private final AtomicInteger state = new AtomicInteger(STATE_CLOSED);
-    private volatile Timer halfOpenTimer;
-    private volatile long lastFailure;
-    private volatile long openedAt;
+    private Timer halfOpenTimer;","[{'comment': 'Please dont change this back as those changes are for threading, you need to use volatile when using primitives', 'commenter': 'davsclaus'}, {'comment': 'Sorry. Missed that in the merge when I had to make some other changes for the JMX management. That is an excellent catch.', 'commenter': 'CodeSmell'}]"
1404,camel-core/src/main/java/org/apache/camel/impl/ThrottlingExceptionRoutePolicy.java,"@@ -154,31 +157,31 @@ private void calculateState(Route route) {
         
         if (state.get() == STATE_CLOSED) {
             if (failureLimitReached) {
-                LOG.debug(""Opening circuit..."");
+                LOG.debug(""opening circuit..."");","[{'comment': 'Dont change these back, we dont use lower case logging', 'commenter': 'davsclaus'}]"
1422,components/camel-tika/src/main/java/org/apache/camel/component/tika/TikaProducer.java,"@@ -0,0 +1,168 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.tika;
+
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.io.OutputStreamWriter;
+import java.io.UnsupportedEncodingException;
+import java.io.Writer;
+import java.nio.charset.Charset;
+import java.nio.charset.StandardCharsets;
+import java.util.Locale;
+
+import javax.xml.transform.OutputKeys;
+import javax.xml.transform.TransformerConfigurationException;
+import javax.xml.transform.sax.SAXTransformerFactory;
+import javax.xml.transform.sax.TransformerHandler;
+import javax.xml.transform.stream.StreamResult;
+
+import org.xml.sax.ContentHandler;
+import org.xml.sax.SAXException;
+
+import org.apache.camel.Exchange;
+import org.apache.camel.impl.DefaultProducer;
+import org.apache.tika.config.TikaConfig;
+import org.apache.tika.detect.Detector;
+import org.apache.tika.exception.TikaException;
+import org.apache.tika.metadata.Metadata;
+import org.apache.tika.mime.MediaType;
+import org.apache.tika.parser.AutoDetectParser;
+import org.apache.tika.parser.ParseContext;
+import org.apache.tika.parser.Parser;
+import org.apache.tika.parser.html.BoilerpipeContentHandler;
+import org.apache.tika.sax.BodyContentHandler;
+import org.apache.tika.sax.ExpandedTitleContentHandler;
+
+public class TikaProducer extends DefaultProducer {
+
+    private final TikaConfiguration tikaConfiguration;
+
+    private final Parser parser;
+
+    private final Detector detector;
+
+    public TikaProducer(TikaEndpoint endpoint) {
+        super(endpoint);
+        this.tikaConfiguration = endpoint.getTikaConfiguration();
+        TikaConfig config = this.tikaConfiguration.getTikaConfig();
+        this.parser = new AutoDetectParser(config);
+        this.detector = config.getDetector();
+    }
+
+    @Override
+    public void process(Exchange exchange) throws Exception {
+        TikaOperation operation = this.tikaConfiguration.getOperation();
+        Object result;
+        switch (operation) {
+        case detect:
+            result = doDetect(exchange);
+            break;
+        case parse:
+            result = doParse(exchange);
+            break;
+        default:
+            throw new IllegalArgumentException(String.format(""Unknown operation %s"", tikaConfiguration.getOperation()));
+        }
+        // propagate headers
+        exchange.getOut().setHeaders(exchange.getIn().getHeaders());
+        exchange.getOut().setAttachments(exchange.getIn().getAttachments());
+        // and set result
+        exchange.getOut().setBody(result);
+    }
+
+    private Object doDetect(Exchange exchange) throws IOException {
+        InputStream inputStream = exchange.getIn().getBody(InputStream.class);
+        Metadata metadata = new Metadata();
+        MediaType result = this.detector.detect(inputStream, metadata);
+        convertMetadataToHeaders(metadata, exchange);
+        return result.toString();
+    }
+
+    private Object doParse(Exchange exchange)
+            throws TikaException, IOException, SAXException, TransformerConfigurationException {
+        InputStream inputStream = exchange.getIn().getBody(InputStream.class);
+        OutputStream result = new ByteArrayOutputStream();
+        ContentHandler contentHandler = getContentHandler(this.tikaConfiguration, result);
+        ParseContext context = new ParseContext();
+        context.set(Parser.class, this.parser);
+        Metadata metadata = new Metadata();
+        this.parser.parse(inputStream, contentHandler, metadata, context);
+        convertMetadataToHeaders(metadata, exchange);
+        return result;
+    }
+
+    private void convertMetadataToHeaders(Metadata metadata, Exchange exchange) {
+        if (metadata != null) {
+            for (String metaname : metadata.names()) {
+                exchange.getIn().setHeader(""Tika"" + metaname, metadata.get(metaname));
+            }
+        }
+    }
+
+    private ContentHandler getContentHandler(TikaConfiguration configuration, OutputStream outputStream)
+            throws TransformerConfigurationException, UnsupportedEncodingException {
+
+        ContentHandler result = null;
+
+        TikaParseOutputFormat outputFormat = configuration.getTikaParseOutputFormat();
+        String encoding = Charset.defaultCharset().name();
+        switch (outputFormat) {
+        case xml:
+            result = getTransformerHandler(outputStream, ""xml"", encoding, true);
+            break;
+        case text:
+            result = new BodyContentHandler(outputStream);
+            break;
+        case textMain:
+            result = new BoilerpipeContentHandler(getOutputWriter(outputStream, encoding));
+            break;
+        case html:
+            result = new ExpandedTitleContentHandler(getTransformerHandler(outputStream, ""html"", encoding, true));
+            break;
+        default:
+            throw new IllegalArgumentException(
+                    String.format(""Unknown format %s"", tikaConfiguration.getTikaParseOutputFormat()));
+        }
+        return result;
+    }
+
+    private TransformerHandler getTransformerHandler(OutputStream output, String method, String encoding,
+            boolean prettyPrint) throws TransformerConfigurationException {
+        SAXTransformerFactory factory = (SAXTransformerFactory) SAXTransformerFactory.newInstance();
+        TransformerHandler handler = factory.newTransformerHandler();
+        handler.getTransformer().setOutputProperty(OutputKeys.METHOD, method);
+        handler.getTransformer().setOutputProperty(OutputKeys.INDENT, prettyPrint ? ""yes"" : ""no"");
+        if (encoding != null) {
+            handler.getTransformer().setOutputProperty(OutputKeys.ENCODING, encoding);
+        }
+        handler.setResult(new StreamResult(output));
+        return handler;
+    }
+
+    private Writer getOutputWriter(OutputStream output, String encoding) throws UnsupportedEncodingException {
+        if (encoding != null) {
+            return new OutputStreamWriter(output, encoding);
+        } else if (System.getProperty(""os.name"").toLowerCase(Locale.ROOT).startsWith(""mac os x"")) {","[{'comment': 'Why are you doing this specially for mac ?\r\nAlso mind that system get property is slow and its maybe better to detect the os once, in doStart and then setup that default charset to use', 'commenter': 'davsclaus'}, {'comment': ""This is perhaps something unique to the TikaCLI that I pulled from here https://github.com/apache/tika/commit/ac74696e322fa93bdbec982f55226f717be66d24 .  I'm thinking perhaps the better option might be just to allow the developer to explicitly set the output content encoding via the url as follows: \r\ntika:parse?tikaParseOutputEncoding=UTF-8\r\n\r\nI think that might be preferable than doing something that the developer might not be aware of."", 'commenter': 'bobpaulin'}]"
1422,components/camel-tika/src/test/java/org/apache/camel/component/tika/TikaParseTest.java,"@@ -0,0 +1,141 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.tika;
+
+import java.io.File;
+import java.util.Map;
+
+import org.apache.camel.EndpointInject;
+import org.apache.camel.Exchange;
+import org.apache.camel.Predicate;
+import org.apache.camel.builder.RouteBuilder;
+import org.apache.camel.component.mock.MockEndpoint;
+import org.apache.camel.impl.JndiRegistry;
+import org.apache.camel.test.junit4.CamelTestSupport;
+import org.junit.Test;
+import static org.hamcrest.Matchers.*;
+
+public class TikaParseTest extends CamelTestSupport {
+
+    @EndpointInject(uri = ""mock:result"")
+    protected MockEndpoint resultEndpoint;
+
+    @Test
+    public void testDocumentParse() throws Exception {
+
+        File document = new File(""src/test/resources/test.doc"");
+        template.sendBody(""direct:start"", document);
+
+        resultEndpoint.setExpectedMessageCount(1);
+
+        resultEndpoint.expectedMessagesMatches(new Predicate() {
+            @Override
+            public boolean matches(Exchange exchange) {
+                Object body = exchange.getIn().getBody(String.class);
+                Map<String, Object> headerMap = exchange.getIn().getHeaders();
+                assertThat(body, instanceOf(String.class));
+                assertThat((String) body, containsString(""test""));
+                assertThat(headerMap.get(""TikaContent-Type""), equalTo(""application/msword""));
+                return true;
+            }
+        });
+        resultEndpoint.assertIsSatisfied();
+    }
+
+    @Test
+    public void testImageParse() throws Exception {
+        File document = new File(""src/test/resources/testGIF.gif"");
+        template.sendBody(""direct:start"", document);
+
+        resultEndpoint.setExpectedMessageCount(1);
+
+        resultEndpoint.expectedMessagesMatches(new Predicate() {
+            @Override
+            public boolean matches(Exchange exchange) {
+                Object body = exchange.getIn().getBody(String.class);
+                Map<String, Object> headerMap = exchange.getIn().getHeaders();
+                assertThat(body, instanceOf(String.class));
+                assertThat((String) body, containsString(""<body/>""));
+                assertThat(headerMap.get(""TikaContent-Type""), equalTo(""image/gif""));
+                return true;
+            }
+        });
+        resultEndpoint.assertIsSatisfied();
+    }
+
+    @Test
+    public void testEmptyConfigDocumentParse() throws Exception {
+        File document = new File(""src/test/resources/test.doc"");
+        template.sendBody(""direct:start3"", document);
+
+        resultEndpoint.setExpectedMessageCount(1);
+
+        resultEndpoint.expectedMessagesMatches(new Predicate() {
+            @Override
+            public boolean matches(Exchange exchange) {
+                Object body = exchange.getIn().getBody(String.class);
+                Map<String, Object> headerMap = exchange.getIn().getHeaders();
+                assertThat(body, instanceOf(String.class));
+                assertThat((String) body, containsString(""<body/>""));
+                assertThat(headerMap.get(""TikaContent-Type""), equalTo(""application/msword""));
+                return true;
+            }
+        });
+        resultEndpoint.assertIsSatisfied();
+    }
+
+    @Test
+    public void testRegistryConfigDocumentParse() throws Exception {
+        File document = new File(""src/test/resources/test.doc"");
+        template.sendBody(""direct:start3"", document);
+
+        resultEndpoint.setExpectedMessageCount(1);
+
+        resultEndpoint.expectedMessagesMatches(new Predicate() {
+            @Override
+            public boolean matches(Exchange exchange) {
+                Object body = exchange.getIn().getBody(String.class);
+                Map<String, Object> headerMap = exchange.getIn().getHeaders();
+                assertThat(body, instanceOf(String.class));
+                assertThat((String) body, containsString(""<body/>""));
+                assertThat(headerMap.get(""TikaContent-Type""), equalTo(""application/msword""));","[{'comment': 'I think we should use Content-Type as well as that is a common header, we have it on Exchange also, eg Exchange.CONTENT_TYPE', 'commenter': 'davsclaus'}, {'comment': ""Agreed.  I'm just going to remove the Tika prefix and pass these as headers as is.  "", 'commenter': 'bobpaulin'}]"
1422,components/camel-tika/src/main/java/org/apache/camel/component/tika/TikaParseOutputFormat.java,"@@ -0,0 +1,21 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.tika;
+
+public enum TikaParseOutputFormat {
+    xml, html, text, textMain;","[{'comment': 'What is the difference between text and textMain? Maybe you can add some details to the javadoc so we get that in the genersted documentation', 'commenter': 'davsclaus'}, {'comment': 'Agree.  I will update documentation to show this distinction.', 'commenter': 'bobpaulin'}]"
1422,components/camel-tika/src/main/java/org/apache/camel/component/tika/TikaEndpoint.java,"@@ -0,0 +1,61 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.tika;
+
+import org.apache.camel.Component;
+import org.apache.camel.Consumer;
+import org.apache.camel.Processor;
+import org.apache.camel.Producer;
+import org.apache.camel.impl.DefaultEndpoint;
+import org.apache.camel.spi.UriEndpoint;
+import org.apache.camel.spi.UriParam;
+
+@UriEndpoint(scheme = ""tika"", title = ""Tika"", syntax = ""tika:operation"", producerOnly = true, label = ""tika"")","[{'comment': 'Use something else than tika for label, the label can be one or more to categorize the component into groups. So maybe ""transformation"" is a better label?', 'commenter': 'davsclaus'}, {'comment': 'Agreed transformation seems fitting.', 'commenter': 'bobpaulin'}]"
1422,components/camel-tika/pom.xml,"@@ -0,0 +1,94 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--
+  Licensed to the Apache Software Foundation (ASF) under one or more
+  contributor license agreements.  See the NOTICE file distributed with
+  this work for additional information regarding copyright ownership.
+  The ASF licenses this file to You under the Apache License, Version 2.0
+  (the ""License""); you may not use this file except in compliance with
+  the License.  You may obtain a copy of the License at
+
+  http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an ""AS IS"" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+
+    <modelVersion>4.0.0</modelVersion>
+
+    <parent>
+        <groupId>org.apache.camel</groupId>
+        <artifactId>components</artifactId>
+        <version>2.19.0-SNAPSHOT</version>
+    </parent>
+
+    <artifactId>camel-tika</artifactId>
+    <packaging>jar</packaging>
+    <name>Camel :: Tika</name>
+    <description>This component integrates with Apache Tika to extract content and metadata from thousands of file types.</description>
+
+    <properties>
+        <camel.osgi.export.pkg>org.apache.camel.component.tika.*</camel.osgi.export.pkg>
+        <camel.osgi.export.service>org.apache.camel.spi.ComponentResolver;component=tika</camel.osgi.export.service>
+    </properties>
+
+    <dependencies>
+
+        <dependency>","[{'comment': 'Can you space this file nicely.', 'commenter': 'davsclaus'}, {'comment': 'Yes.  See you are expecting 2 space indents.  Will fix.', 'commenter': 'bobpaulin'}]"
1435,components/camel-elasticsearch5/src/main/java/org/apache/camel/component/elasticsearch5/ElasticsearchConfiguration.java,"@@ -0,0 +1,158 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.elasticsearch5;
+
+import java.util.List;
+
+import org.apache.camel.spi.Metadata;
+import org.apache.camel.spi.UriParam;
+import org.apache.camel.spi.UriParams;
+import org.apache.camel.spi.UriPath;
+import org.elasticsearch.common.transport.InetSocketTransportAddress;
+
+@UriParams
+public class ElasticsearchConfiguration {
+
+    private List<InetSocketTransportAddress> transportAddressesList;
+
+    @UriPath @Metadata(required = ""true"")
+    private String clusterName;
+    @UriParam(enums = ""INDEX, UPDATE, BULK, BULK_INDEX, GET_BY_ID, MULTIGET, DELETE, EXISTS, SEARCH, MULTISEARCH, DELETE_INDEX"")
+    private String operation;
+    @UriParam
+    private String indexName;
+    @UriParam
+    private String indexType;
+    @UriParam
+    private int waitForActiveShards = ElasticsearchConstants.DEFAULT_FOR_WAIT_ACTIVE_SHARDS;
+    @UriParam
+    private String ip;
+    @UriParam
+    private String transportAddresses;
+    @UriParam","[{'comment': 'Can you add the default value for this and also that waitForActiveShards option. ', 'commenter': 'davsclaus'}, {'comment': 'Ok, will fix it', 'commenter': 'dmvolod'}]"
1435,components/camel-elasticsearch5/src/main/java/org/apache/camel/component/elasticsearch5/ElasticsearchConfiguration.java,"@@ -0,0 +1,158 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.elasticsearch5;
+
+import java.util.List;
+
+import org.apache.camel.spi.Metadata;
+import org.apache.camel.spi.UriParam;
+import org.apache.camel.spi.UriParams;
+import org.apache.camel.spi.UriPath;
+import org.elasticsearch.common.transport.InetSocketTransportAddress;
+
+@UriParams
+public class ElasticsearchConfiguration {
+
+    private List<InetSocketTransportAddress> transportAddressesList;
+
+    @UriPath @Metadata(required = ""true"")
+    private String clusterName;
+    @UriParam(enums = ""INDEX, UPDATE, BULK, BULK_INDEX, GET_BY_ID, MULTIGET, DELETE, EXISTS, SEARCH, MULTISEARCH, DELETE_INDEX"")
+    private String operation;
+    @UriParam
+    private String indexName;
+    @UriParam
+    private String indexType;
+    @UriParam","[{'comment': ""It looks like this is a enum value which int you can use, can you add `enums = '1,2,3` for the possible values."", 'commenter': 'davsclaus'}, {'comment': ""No, its an available operations name, i.e. INDEX or SEARCH and it's not possible to use int values for this. I will create a separate ElasticSearch enum object for this..."", 'commenter': 'dmvolod'}]"
1435,components/camel-elasticsearch5/src/main/java/org/apache/camel/component/elasticsearch5/ElasticsearchConfiguration.java,"@@ -0,0 +1,158 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.elasticsearch5;
+
+import java.util.List;
+
+import org.apache.camel.spi.Metadata;
+import org.apache.camel.spi.UriParam;
+import org.apache.camel.spi.UriParams;
+import org.apache.camel.spi.UriPath;
+import org.elasticsearch.common.transport.InetSocketTransportAddress;
+
+@UriParams
+public class ElasticsearchConfiguration {
+
+    private List<InetSocketTransportAddress> transportAddressesList;
+
+    @UriPath @Metadata(required = ""true"")
+    private String clusterName;
+    @UriParam(enums = ""INDEX, UPDATE, BULK, BULK_INDEX, GET_BY_ID, MULTIGET, DELETE, EXISTS, SEARCH, MULTISEARCH, DELETE_INDEX"")
+    private String operation;
+    @UriParam
+    private String indexName;
+    @UriParam
+    private String indexType;
+    @UriParam
+    private int waitForActiveShards = ElasticsearchConstants.DEFAULT_FOR_WAIT_ACTIVE_SHARDS;
+    @UriParam
+    private String ip;
+    @UriParam
+    private String transportAddresses;
+    @UriParam
+    private int port = ElasticsearchConstants.DEFAULT_PORT;
+    @UriParam(defaultValue = ""true"")
+    private Boolean clientTransportSniff = true;
+
+    /**
+     * Name of the cluster
+     */
+    public String getClusterName() {
+        return clusterName;
+    }
+
+    public void setClusterName(String clusterName) {
+        this.clusterName = clusterName;
+    }
+
+    /**
+     * What operation to perform
+     */
+    public String getOperation() {
+        return operation;
+    }
+
+    public void setOperation(String operation) {
+        this.operation = operation;
+    }
+
+    /**
+     * The name of the index to act against
+     */
+    public String getIndexName() {
+        return indexName;
+    }
+
+    public void setIndexName(String indexName) {
+        this.indexName = indexName;
+    }
+
+    /**
+     * The type of the index to act against
+     */
+    public String getIndexType() {
+        return indexType;
+    }
+
+    public void setIndexType(String indexType) {
+        this.indexType = indexType;
+    }
+
+    /**
+     * The TransportClient remote host ip to use
+     */
+    public String getIp() {
+        return ip;
+    }
+
+    public void setIp(String ip) {
+        this.ip = ip;
+    }
+
+    /**
+     * Comma separated list with ip:port formatted remote transport addresses to use.
+     * The ip and port options must be left blank for transportAddresses to be considered instead.
+     */
+    public String getTransportAddresses() {
+        return transportAddresses;
+    }
+
+    public void setTransportAddresses(String transportAddresses) {
+        this.transportAddresses = transportAddresses;
+    }
+
+    /**
+     * The TransportClient remote port to use (defaults to 9300)
+     */
+    public int getPort() {
+        return port;
+    }
+
+    public void setPort(int port) {
+        this.port = port;
+    }
+    
+    /**","[{'comment': 'Can we improve the javadoc with a bit more documentation. For example for this you can document the various enums that are possible and what each of them mean/do.', 'commenter': 'davsclaus'}, {'comment': 'Ok, will fix it', 'commenter': 'dmvolod'}]"
1435,components/camel-elasticsearch5/src/main/java/org/apache/camel/component/elasticsearch5/ElasticsearchEndpoint.java,"@@ -0,0 +1,120 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.elasticsearch5;
+
+import java.net.InetAddress;
+import java.util.ArrayList;
+import java.util.List;
+
+import org.apache.camel.Consumer;
+import org.apache.camel.Processor;
+import org.apache.camel.Producer;
+import org.apache.camel.impl.DefaultEndpoint;
+import org.apache.camel.spi.UriEndpoint;
+import org.apache.camel.spi.UriParam;
+import org.elasticsearch.client.transport.TransportClient;
+import org.elasticsearch.common.settings.Settings;
+import org.elasticsearch.common.transport.InetSocketTransportAddress;
+import org.elasticsearch.common.transport.TransportAddress;
+import org.elasticsearch.transport.client.PreBuiltTransportClient;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * The elasticsearch component is used for interfacing with ElasticSearch server.
+ */
+@UriEndpoint(scheme = ""elasticsearch5"", title = ""Elasticsearch5"", syntax = ""elasticsearch5:clusterName"", producerOnly = true, label = ""monitoring,search"")
+public class ElasticsearchEndpoint extends DefaultEndpoint {
+
+    private static final Logger LOG = LoggerFactory.getLogger(ElasticsearchEndpoint.class);
+
+    private TransportClient client;
+    @UriParam
+    private ElasticsearchConfiguration configuration;
+
+    public ElasticsearchEndpoint(String uri, ElasticsearchComponent component, ElasticsearchConfiguration config, TransportClient client) throws Exception {
+        super(uri, component);
+        this.configuration = config;
+        this.client = client;
+    }
+
+    public Producer createProducer() throws Exception {
+        return new ElasticsearchProducer(this);
+    }
+
+    public Consumer createConsumer(Processor processor) throws Exception {
+        throw new UnsupportedOperationException(""Cannot consume from an ElasticsearchEndpoint: "" + getEndpointUri());
+    }
+    
+    public boolean isSingleton() {","[{'comment': 'It would be better to be singleton = true, and move that TransportClient to the producer, eg so its created when you create a producer. So the client is on the lifecycle of the producer. Generally we should avoid having any state on the endpoint, but let that be on the consumer or producer etc.', 'commenter': 'davsclaus'}, {'comment': 'Ok, will fix it', 'commenter': 'dmvolod'}]"
1435,components/camel-elasticsearch5/src/test/resources/log4j2.properties,"@@ -0,0 +1,28 @@
+## ---------------------------------------------------------------------------
+## Licensed to the Apache Software Foundation (ASF) under one or more
+## contributor license agreements.  See the NOTICE file distributed with
+## this work for additional information regarding copyright ownership.
+## The ASF licenses this file to You under the Apache License, Version 2.0
+## (the ""License""); you may not use this file except in compliance with
+## the License.  You may obtain a copy of the License at
+##
+## http://www.apache.org/licenses/LICENSE-2.0
+##
+## Unless required by applicable law or agreed to in writing, software
+## distributed under the License is distributed on an ""AS IS"" BASIS,
+## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+## See the License for the specific language governing permissions and
+## limitations under the License.
+## ---------------------------------------------------------------------------
+
+appender.file.type = File
+appender.file.name = file
+appender.file.fileName = target/camel-elasticsearch-test.log","[{'comment': 'elasticsearch5', 'commenter': 'davsclaus'}, {'comment': 'Ok, will fix it', 'commenter': 'dmvolod'}]"
1435,components/camel-elasticsearch5/pom.xml,"@@ -0,0 +1,101 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>","[{'comment': 'Can you add nicer copyright header. And also format the XML with only 2 or 4 spaces instead of tabs. ', 'commenter': 'davsclaus'}, {'comment': 'Ok, will fix it', 'commenter': 'dmvolod'}]"
1458,components/camel-rabbitmq/src/main/java/org/apache/camel/component/rabbitmq/RabbitMQEndpoint.java,"@@ -919,4 +943,9 @@ public void setExclusive(boolean exclusive) {
         this.exclusive = exclusive;
     }
 
+    public boolean isLenientProperties() {
+        // true to allow dynamic URI options to be configured
+        return true;","[{'comment': 'I dont think it ought to be lenient when all the new options are prefixed with arg.', 'commenter': 'davsclaus'}]"
1474,camel-core/src/main/java/org/apache/camel/model/dataformat/CsvDataFormat.java,"@@ -163,6 +171,16 @@ protected void configureDataFormat(DataFormat dataFormat, CamelContext camelCont
         if (quoteMode != null) {
             setProperty(camelContext, dataFormat, ""quoteMode"", quoteMode);
         }
+        Stream.of(""trim"", ""ignoreHeaderCase"", ""trailingDelimiter"")","[{'comment': 'Can you do like the existing code so its similar', 'commenter': 'davsclaus'}]"
1502,components/camel-kafka/src/main/java/org/apache/camel/processor/idempotent/kafka/KafkaIdempotentRepository.java,"@@ -0,0 +1,342 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.processor.idempotent.kafka;
+
+import java.util.Collections;
+import java.util.Map;
+import java.util.Properties;
+import java.util.UUID;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicLong;
+
+import org.apache.camel.CamelContext;
+import org.apache.camel.CamelContextAware;
+import org.apache.camel.api.management.ManagedOperation;
+import org.apache.camel.api.management.ManagedResource;
+import org.apache.camel.spi.ExecutorServiceManager;
+import org.apache.camel.spi.IdempotentRepository;
+import org.apache.camel.support.ServiceSupport;
+import org.apache.camel.util.LRUCache;
+import org.apache.camel.util.ObjectHelper;
+import org.apache.camel.util.StringHelper;
+
+import org.apache.kafka.clients.consumer.Consumer;
+import org.apache.kafka.clients.consumer.ConsumerConfig;
+import org.apache.kafka.clients.consumer.ConsumerRecord;
+import org.apache.kafka.clients.consumer.ConsumerRecords;
+import org.apache.kafka.clients.consumer.KafkaConsumer;
+import org.apache.kafka.clients.producer.KafkaProducer;
+import org.apache.kafka.clients.producer.Producer;
+import org.apache.kafka.clients.producer.ProducerConfig;
+import org.apache.kafka.clients.producer.ProducerRecord;
+import org.apache.kafka.common.serialization.StringDeserializer;
+import org.apache.kafka.common.serialization.StringSerializer;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+
+/**
+ * A Kafka topic-based implementation of {@link org.apache.camel.spi.IdempotentRepository}.
+ *
+ * Uses a local cache of previously seen Message IDs. All mutations of the cache are via a Kafka topic, on which
+ * additions and removals are broadcast. The topic used must be unique per repository instance. This class makes no
+ * assumptions about number of partitions (it is designed to consume from all at the same time), or replication factor.
+ * Each repository instance that uses the topic (e.g. on different machines running in parallel) controls its own
+ * consumer group.
+ *
+ * On startup, the instance subscribes to the topic and rewinds the offset to the beginning, rebuilding the cache to the
+ * latest state.
+ *
+ * To use, this repository must be placed in the Camel registry, either manually or by registration as a bean in
+ * Spring/Blueprint, as it is CamelContext aware.
+ *
+ * @author jkorab
+ */
+@ManagedResource(description = ""Kafka IdempotentRepository"")
+public class KafkaIdempotentRepository extends ServiceSupport implements IdempotentRepository<String>, CamelContextAware {
+
+    private static final int DEFAULT_MAXIMUM_CACHE_SIZE = 1000;
+
+    private final Logger log = LoggerFactory.getLogger(this.getClass());
+    private final Map<String, Object> cache;
+
+    private final AtomicLong duplicateCount = new AtomicLong(0);
+    private final String topic;
+    private final Properties producerConfig;
+    private final Properties consumerConfig;
+
+    private Consumer<String, String> consumer;
+    private Producer<String, String> producer;
+    private TopicPoller topicPoller;
+
+    private CamelContext camelContext;
+    private ExecutorService executorService;
+    private CountDownLatch cacheReadyLatch;
+
+    enum CacheAction {
+        add,
+        remove,
+        clear
+    }
+
+    public KafkaIdempotentRepository(String topic, String bootstrapServers) {
+        this(topic, bootstrapServers, DEFAULT_MAXIMUM_CACHE_SIZE);
+    }
+
+    public KafkaIdempotentRepository(String topic, String bootstrapServers, int maxCacheSize) {
+        StringHelper.notEmpty(topic, ""topic"");
+        StringHelper.notEmpty(bootstrapServers, ""bootstrapServers"");
+        Properties consumerConfig = new Properties();
+        consumerConfig.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);
+
+        Properties producerConfig = new Properties();
+        producerConfig.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);
+
+        this.topic = topic;
+        this.consumerConfig = consumerConfig;
+        this.producerConfig = producerConfig;
+        this.cache = Collections.synchronizedMap(new LRUCache<>(maxCacheSize));
+    }
+
+    public KafkaIdempotentRepository(String topic, Properties consumerConfig, Properties producerConfig) {
+        this(topic, consumerConfig, producerConfig, DEFAULT_MAXIMUM_CACHE_SIZE);
+    }
+
+    public KafkaIdempotentRepository(String topic, Properties consumerConfig, Properties producerConfig, int maxCacheSize) {
+        StringHelper.notEmpty(topic, ""topic"");
+        this.topic = topic;
+        ObjectHelper.notNull(consumerConfig, ""consumerConfig"");
+        this.consumerConfig = consumerConfig;
+        ObjectHelper.notNull(producerConfig, ""producerConfig"");
+        this.producerConfig = producerConfig;
+        this.cache = Collections.synchronizedMap(new LRUCache<>(maxCacheSize));
+    }
+
+    @Override
+    protected void doStart() throws Exception {
+        log.info(""Context: {}"", camelContext);","[{'comment': 'A better logging message would be nice. Something about starting XXX with YY setting (the important values)', 'commenter': 'davsclaus'}, {'comment': 'This was some redundant code that was left over from an early pass. Removing.\r\n', 'commenter': 'jkorab'}]"
1502,components/camel-kafka/src/main/java/org/apache/camel/processor/idempotent/kafka/KafkaIdempotentRepository.java,"@@ -0,0 +1,342 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.processor.idempotent.kafka;
+
+import java.util.Collections;
+import java.util.Map;
+import java.util.Properties;
+import java.util.UUID;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicLong;
+
+import org.apache.camel.CamelContext;
+import org.apache.camel.CamelContextAware;
+import org.apache.camel.api.management.ManagedOperation;
+import org.apache.camel.api.management.ManagedResource;
+import org.apache.camel.spi.ExecutorServiceManager;
+import org.apache.camel.spi.IdempotentRepository;
+import org.apache.camel.support.ServiceSupport;
+import org.apache.camel.util.LRUCache;
+import org.apache.camel.util.ObjectHelper;
+import org.apache.camel.util.StringHelper;
+
+import org.apache.kafka.clients.consumer.Consumer;
+import org.apache.kafka.clients.consumer.ConsumerConfig;
+import org.apache.kafka.clients.consumer.ConsumerRecord;
+import org.apache.kafka.clients.consumer.ConsumerRecords;
+import org.apache.kafka.clients.consumer.KafkaConsumer;
+import org.apache.kafka.clients.producer.KafkaProducer;
+import org.apache.kafka.clients.producer.Producer;
+import org.apache.kafka.clients.producer.ProducerConfig;
+import org.apache.kafka.clients.producer.ProducerRecord;
+import org.apache.kafka.common.serialization.StringDeserializer;
+import org.apache.kafka.common.serialization.StringSerializer;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+
+/**
+ * A Kafka topic-based implementation of {@link org.apache.camel.spi.IdempotentRepository}.
+ *
+ * Uses a local cache of previously seen Message IDs. All mutations of the cache are via a Kafka topic, on which
+ * additions and removals are broadcast. The topic used must be unique per repository instance. This class makes no
+ * assumptions about number of partitions (it is designed to consume from all at the same time), or replication factor.
+ * Each repository instance that uses the topic (e.g. on different machines running in parallel) controls its own
+ * consumer group.
+ *
+ * On startup, the instance subscribes to the topic and rewinds the offset to the beginning, rebuilding the cache to the
+ * latest state.
+ *
+ * To use, this repository must be placed in the Camel registry, either manually or by registration as a bean in
+ * Spring/Blueprint, as it is CamelContext aware.
+ *
+ * @author jkorab
+ */
+@ManagedResource(description = ""Kafka IdempotentRepository"")
+public class KafkaIdempotentRepository extends ServiceSupport implements IdempotentRepository<String>, CamelContextAware {
+
+    private static final int DEFAULT_MAXIMUM_CACHE_SIZE = 1000;
+
+    private final Logger log = LoggerFactory.getLogger(this.getClass());
+    private final Map<String, Object> cache;
+
+    private final AtomicLong duplicateCount = new AtomicLong(0);
+    private final String topic;
+    private final Properties producerConfig;
+    private final Properties consumerConfig;
+
+    private Consumer<String, String> consumer;
+    private Producer<String, String> producer;
+    private TopicPoller topicPoller;
+
+    private CamelContext camelContext;
+    private ExecutorService executorService;
+    private CountDownLatch cacheReadyLatch;
+
+    enum CacheAction {
+        add,
+        remove,
+        clear
+    }
+
+    public KafkaIdempotentRepository(String topic, String bootstrapServers) {
+        this(topic, bootstrapServers, DEFAULT_MAXIMUM_CACHE_SIZE);
+    }
+
+    public KafkaIdempotentRepository(String topic, String bootstrapServers, int maxCacheSize) {
+        StringHelper.notEmpty(topic, ""topic"");
+        StringHelper.notEmpty(bootstrapServers, ""bootstrapServers"");
+        Properties consumerConfig = new Properties();
+        consumerConfig.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);
+
+        Properties producerConfig = new Properties();
+        producerConfig.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);
+
+        this.topic = topic;
+        this.consumerConfig = consumerConfig;
+        this.producerConfig = producerConfig;
+        this.cache = Collections.synchronizedMap(new LRUCache<>(maxCacheSize));
+    }
+
+    public KafkaIdempotentRepository(String topic, Properties consumerConfig, Properties producerConfig) {
+        this(topic, consumerConfig, producerConfig, DEFAULT_MAXIMUM_CACHE_SIZE);
+    }
+
+    public KafkaIdempotentRepository(String topic, Properties consumerConfig, Properties producerConfig, int maxCacheSize) {
+        StringHelper.notEmpty(topic, ""topic"");
+        this.topic = topic;
+        ObjectHelper.notNull(consumerConfig, ""consumerConfig"");
+        this.consumerConfig = consumerConfig;
+        ObjectHelper.notNull(producerConfig, ""producerConfig"");
+        this.producerConfig = producerConfig;
+        this.cache = Collections.synchronizedMap(new LRUCache<>(maxCacheSize));
+    }
+
+    @Override
+    protected void doStart() throws Exception {
+        log.info(""Context: {}"", camelContext);
+
+        // each consumer instance must have control over its own offset, so assign a groupID at random
+        String groupId = UUID.randomUUID().toString();
+        log.debug(""Creating consumer with {}[{}]"", ConsumerConfig.GROUP_ID_CONFIG, groupId);
+
+        consumerConfig.put(ConsumerConfig.GROUP_ID_CONFIG, groupId);
+        consumerConfig.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, Boolean.TRUE.toString());
+        consumerConfig.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName());
+        consumerConfig.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName());
+
+        consumer = new KafkaConsumer<>(consumerConfig);
+
+        producerConfig.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());
+        producerConfig.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());
+        // set up the producer to remove all batching on send
+        producerConfig.putIfAbsent(ProducerConfig.ACKS_CONFIG, ""1"");
+        producerConfig.putIfAbsent(ProducerConfig.BATCH_SIZE_CONFIG, ""0"");
+        producer = new KafkaProducer<>(producerConfig);
+
+        cacheReadyLatch = new CountDownLatch(1);
+        topicPoller = new TopicPoller(consumer, cacheReadyLatch);
+    }
+
+    @Override
+    public void setCamelContext(CamelContext camelContext) {
+        // doStart() has already been called at this point
+        this.camelContext = camelContext;
+        ExecutorServiceManager executorServiceManager = camelContext.getExecutorServiceManager();","[{'comment': 'No dont do this in a setter!!! Place the startup logic in doStart that is what its for', 'commenter': 'davsclaus'}, {'comment': ""Not sure that's right - doesn't fit with the lifecycle that I'm seeing. CamelContextAware.setCamelContext() is called after doStart(), so I can't set up the polling thread there."", 'commenter': 'jkorab'}, {'comment': 'Doesnt matter we must not have code like that in a setter. Add a TODO and I will take a look why you dont get CamelContext injected prior to start lifecycle. ', 'commenter': 'davsclaus'}]"
1502,components/camel-kafka/src/main/java/org/apache/camel/processor/idempotent/kafka/KafkaIdempotentRepository.java,"@@ -0,0 +1,342 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.processor.idempotent.kafka;
+
+import java.util.Collections;
+import java.util.Map;
+import java.util.Properties;
+import java.util.UUID;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicLong;
+
+import org.apache.camel.CamelContext;
+import org.apache.camel.CamelContextAware;
+import org.apache.camel.api.management.ManagedOperation;
+import org.apache.camel.api.management.ManagedResource;
+import org.apache.camel.spi.ExecutorServiceManager;
+import org.apache.camel.spi.IdempotentRepository;
+import org.apache.camel.support.ServiceSupport;
+import org.apache.camel.util.LRUCache;
+import org.apache.camel.util.ObjectHelper;
+import org.apache.camel.util.StringHelper;
+
+import org.apache.kafka.clients.consumer.Consumer;
+import org.apache.kafka.clients.consumer.ConsumerConfig;
+import org.apache.kafka.clients.consumer.ConsumerRecord;
+import org.apache.kafka.clients.consumer.ConsumerRecords;
+import org.apache.kafka.clients.consumer.KafkaConsumer;
+import org.apache.kafka.clients.producer.KafkaProducer;
+import org.apache.kafka.clients.producer.Producer;
+import org.apache.kafka.clients.producer.ProducerConfig;
+import org.apache.kafka.clients.producer.ProducerRecord;
+import org.apache.kafka.common.serialization.StringDeserializer;
+import org.apache.kafka.common.serialization.StringSerializer;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+
+/**
+ * A Kafka topic-based implementation of {@link org.apache.camel.spi.IdempotentRepository}.
+ *
+ * Uses a local cache of previously seen Message IDs. All mutations of the cache are via a Kafka topic, on which
+ * additions and removals are broadcast. The topic used must be unique per repository instance. This class makes no
+ * assumptions about number of partitions (it is designed to consume from all at the same time), or replication factor.
+ * Each repository instance that uses the topic (e.g. on different machines running in parallel) controls its own
+ * consumer group.
+ *
+ * On startup, the instance subscribes to the topic and rewinds the offset to the beginning, rebuilding the cache to the
+ * latest state.
+ *
+ * To use, this repository must be placed in the Camel registry, either manually or by registration as a bean in
+ * Spring/Blueprint, as it is CamelContext aware.
+ *
+ * @author jkorab
+ */
+@ManagedResource(description = ""Kafka IdempotentRepository"")
+public class KafkaIdempotentRepository extends ServiceSupport implements IdempotentRepository<String>, CamelContextAware {
+
+    private static final int DEFAULT_MAXIMUM_CACHE_SIZE = 1000;
+
+    private final Logger log = LoggerFactory.getLogger(this.getClass());
+    private final Map<String, Object> cache;
+
+    private final AtomicLong duplicateCount = new AtomicLong(0);
+    private final String topic;
+    private final Properties producerConfig;
+    private final Properties consumerConfig;
+
+    private Consumer<String, String> consumer;
+    private Producer<String, String> producer;
+    private TopicPoller topicPoller;
+
+    private CamelContext camelContext;
+    private ExecutorService executorService;
+    private CountDownLatch cacheReadyLatch;
+
+    enum CacheAction {
+        add,
+        remove,
+        clear
+    }
+
+    public KafkaIdempotentRepository(String topic, String bootstrapServers) {
+        this(topic, bootstrapServers, DEFAULT_MAXIMUM_CACHE_SIZE);
+    }
+
+    public KafkaIdempotentRepository(String topic, String bootstrapServers, int maxCacheSize) {
+        StringHelper.notEmpty(topic, ""topic"");
+        StringHelper.notEmpty(bootstrapServers, ""bootstrapServers"");
+        Properties consumerConfig = new Properties();
+        consumerConfig.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);
+
+        Properties producerConfig = new Properties();
+        producerConfig.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);
+
+        this.topic = topic;
+        this.consumerConfig = consumerConfig;
+        this.producerConfig = producerConfig;
+        this.cache = Collections.synchronizedMap(new LRUCache<>(maxCacheSize));
+    }
+
+    public KafkaIdempotentRepository(String topic, Properties consumerConfig, Properties producerConfig) {
+        this(topic, consumerConfig, producerConfig, DEFAULT_MAXIMUM_CACHE_SIZE);
+    }
+
+    public KafkaIdempotentRepository(String topic, Properties consumerConfig, Properties producerConfig, int maxCacheSize) {
+        StringHelper.notEmpty(topic, ""topic"");
+        this.topic = topic;
+        ObjectHelper.notNull(consumerConfig, ""consumerConfig"");
+        this.consumerConfig = consumerConfig;
+        ObjectHelper.notNull(producerConfig, ""producerConfig"");
+        this.producerConfig = producerConfig;
+        this.cache = Collections.synchronizedMap(new LRUCache<>(maxCacheSize));
+    }
+
+    @Override
+    protected void doStart() throws Exception {
+        log.info(""Context: {}"", camelContext);
+
+        // each consumer instance must have control over its own offset, so assign a groupID at random
+        String groupId = UUID.randomUUID().toString();
+        log.debug(""Creating consumer with {}[{}]"", ConsumerConfig.GROUP_ID_CONFIG, groupId);
+
+        consumerConfig.put(ConsumerConfig.GROUP_ID_CONFIG, groupId);
+        consumerConfig.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, Boolean.TRUE.toString());
+        consumerConfig.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName());
+        consumerConfig.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName());
+
+        consumer = new KafkaConsumer<>(consumerConfig);
+
+        producerConfig.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());
+        producerConfig.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());
+        // set up the producer to remove all batching on send
+        producerConfig.putIfAbsent(ProducerConfig.ACKS_CONFIG, ""1"");
+        producerConfig.putIfAbsent(ProducerConfig.BATCH_SIZE_CONFIG, ""0"");
+        producer = new KafkaProducer<>(producerConfig);
+
+        cacheReadyLatch = new CountDownLatch(1);
+        topicPoller = new TopicPoller(consumer, cacheReadyLatch);
+    }
+
+    @Override
+    public void setCamelContext(CamelContext camelContext) {
+        // doStart() has already been called at this point
+        this.camelContext = camelContext;
+        ExecutorServiceManager executorServiceManager = camelContext.getExecutorServiceManager();
+        executorService = executorServiceManager.newFixedThreadPool(this, ""KafkaIdempotentRepository"", 1);
+        executorService.submit(topicPoller);
+        log.info(""Warming up cache"");
+        try {
+            if (cacheReadyLatch.await(30, TimeUnit.SECONDS)) {
+                log.info(""Cache OK"");
+            } else {
+                log.warn(""Timeout waiting for cache warm-up from topic {}. Proceeding anyway. ""
+                        + ""Duplicate records may not be detected."", topic);
+            }
+        } catch (InterruptedException e) {
+            e.printStackTrace();","[{'comment': 'Dont do this but use the logger to log the error', 'commenter': 'davsclaus'}, {'comment': 'Missed that, thanks.', 'commenter': 'jkorab'}]"
1502,components/camel-kafka/src/main/java/org/apache/camel/processor/idempotent/kafka/KafkaIdempotentRepository.java,"@@ -0,0 +1,342 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.processor.idempotent.kafka;
+
+import java.util.Collections;
+import java.util.Map;
+import java.util.Properties;
+import java.util.UUID;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicLong;
+
+import org.apache.camel.CamelContext;
+import org.apache.camel.CamelContextAware;
+import org.apache.camel.api.management.ManagedOperation;
+import org.apache.camel.api.management.ManagedResource;
+import org.apache.camel.spi.ExecutorServiceManager;
+import org.apache.camel.spi.IdempotentRepository;
+import org.apache.camel.support.ServiceSupport;
+import org.apache.camel.util.LRUCache;
+import org.apache.camel.util.ObjectHelper;
+import org.apache.camel.util.StringHelper;
+
+import org.apache.kafka.clients.consumer.Consumer;
+import org.apache.kafka.clients.consumer.ConsumerConfig;
+import org.apache.kafka.clients.consumer.ConsumerRecord;
+import org.apache.kafka.clients.consumer.ConsumerRecords;
+import org.apache.kafka.clients.consumer.KafkaConsumer;
+import org.apache.kafka.clients.producer.KafkaProducer;
+import org.apache.kafka.clients.producer.Producer;
+import org.apache.kafka.clients.producer.ProducerConfig;
+import org.apache.kafka.clients.producer.ProducerRecord;
+import org.apache.kafka.common.serialization.StringDeserializer;
+import org.apache.kafka.common.serialization.StringSerializer;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+
+/**
+ * A Kafka topic-based implementation of {@link org.apache.camel.spi.IdempotentRepository}.
+ *
+ * Uses a local cache of previously seen Message IDs. All mutations of the cache are via a Kafka topic, on which
+ * additions and removals are broadcast. The topic used must be unique per repository instance. This class makes no
+ * assumptions about number of partitions (it is designed to consume from all at the same time), or replication factor.
+ * Each repository instance that uses the topic (e.g. on different machines running in parallel) controls its own
+ * consumer group.
+ *
+ * On startup, the instance subscribes to the topic and rewinds the offset to the beginning, rebuilding the cache to the
+ * latest state.
+ *
+ * To use, this repository must be placed in the Camel registry, either manually or by registration as a bean in
+ * Spring/Blueprint, as it is CamelContext aware.
+ *
+ * @author jkorab
+ */
+@ManagedResource(description = ""Kafka IdempotentRepository"")
+public class KafkaIdempotentRepository extends ServiceSupport implements IdempotentRepository<String>, CamelContextAware {
+
+    private static final int DEFAULT_MAXIMUM_CACHE_SIZE = 1000;
+
+    private final Logger log = LoggerFactory.getLogger(this.getClass());
+    private final Map<String, Object> cache;
+
+    private final AtomicLong duplicateCount = new AtomicLong(0);
+    private final String topic;
+    private final Properties producerConfig;
+    private final Properties consumerConfig;
+
+    private Consumer<String, String> consumer;
+    private Producer<String, String> producer;
+    private TopicPoller topicPoller;
+
+    private CamelContext camelContext;
+    private ExecutorService executorService;
+    private CountDownLatch cacheReadyLatch;
+
+    enum CacheAction {
+        add,
+        remove,
+        clear
+    }
+
+    public KafkaIdempotentRepository(String topic, String bootstrapServers) {
+        this(topic, bootstrapServers, DEFAULT_MAXIMUM_CACHE_SIZE);
+    }
+
+    public KafkaIdempotentRepository(String topic, String bootstrapServers, int maxCacheSize) {
+        StringHelper.notEmpty(topic, ""topic"");
+        StringHelper.notEmpty(bootstrapServers, ""bootstrapServers"");
+        Properties consumerConfig = new Properties();
+        consumerConfig.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);
+
+        Properties producerConfig = new Properties();
+        producerConfig.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);
+
+        this.topic = topic;
+        this.consumerConfig = consumerConfig;
+        this.producerConfig = producerConfig;
+        this.cache = Collections.synchronizedMap(new LRUCache<>(maxCacheSize));
+    }
+
+    public KafkaIdempotentRepository(String topic, Properties consumerConfig, Properties producerConfig) {
+        this(topic, consumerConfig, producerConfig, DEFAULT_MAXIMUM_CACHE_SIZE);
+    }
+
+    public KafkaIdempotentRepository(String topic, Properties consumerConfig, Properties producerConfig, int maxCacheSize) {
+        StringHelper.notEmpty(topic, ""topic"");
+        this.topic = topic;
+        ObjectHelper.notNull(consumerConfig, ""consumerConfig"");
+        this.consumerConfig = consumerConfig;
+        ObjectHelper.notNull(producerConfig, ""producerConfig"");
+        this.producerConfig = producerConfig;
+        this.cache = Collections.synchronizedMap(new LRUCache<>(maxCacheSize));
+    }
+
+    @Override
+    protected void doStart() throws Exception {
+        log.info(""Context: {}"", camelContext);
+
+        // each consumer instance must have control over its own offset, so assign a groupID at random
+        String groupId = UUID.randomUUID().toString();
+        log.debug(""Creating consumer with {}[{}]"", ConsumerConfig.GROUP_ID_CONFIG, groupId);
+
+        consumerConfig.put(ConsumerConfig.GROUP_ID_CONFIG, groupId);
+        consumerConfig.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, Boolean.TRUE.toString());
+        consumerConfig.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName());
+        consumerConfig.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName());
+
+        consumer = new KafkaConsumer<>(consumerConfig);
+
+        producerConfig.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());
+        producerConfig.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());
+        // set up the producer to remove all batching on send
+        producerConfig.putIfAbsent(ProducerConfig.ACKS_CONFIG, ""1"");
+        producerConfig.putIfAbsent(ProducerConfig.BATCH_SIZE_CONFIG, ""0"");
+        producer = new KafkaProducer<>(producerConfig);
+
+        cacheReadyLatch = new CountDownLatch(1);
+        topicPoller = new TopicPoller(consumer, cacheReadyLatch);
+    }
+
+    @Override
+    public void setCamelContext(CamelContext camelContext) {
+        // doStart() has already been called at this point
+        this.camelContext = camelContext;
+        ExecutorServiceManager executorServiceManager = camelContext.getExecutorServiceManager();
+        executorService = executorServiceManager.newFixedThreadPool(this, ""KafkaIdempotentRepository"", 1);","[{'comment': 'Instead of queue size = 1 there is another method to create a single threaded pool', 'commenter': 'davsclaus'}, {'comment': 'newSingleThreadExecutor(). Done.', 'commenter': 'jkorab'}]"
1502,components/camel-kafka/src/main/java/org/apache/camel/processor/idempotent/kafka/KafkaIdempotentRepository.java,"@@ -0,0 +1,342 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.processor.idempotent.kafka;
+
+import java.util.Collections;
+import java.util.Map;
+import java.util.Properties;
+import java.util.UUID;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicLong;
+
+import org.apache.camel.CamelContext;
+import org.apache.camel.CamelContextAware;
+import org.apache.camel.api.management.ManagedOperation;
+import org.apache.camel.api.management.ManagedResource;
+import org.apache.camel.spi.ExecutorServiceManager;
+import org.apache.camel.spi.IdempotentRepository;
+import org.apache.camel.support.ServiceSupport;
+import org.apache.camel.util.LRUCache;
+import org.apache.camel.util.ObjectHelper;
+import org.apache.camel.util.StringHelper;
+
+import org.apache.kafka.clients.consumer.Consumer;
+import org.apache.kafka.clients.consumer.ConsumerConfig;
+import org.apache.kafka.clients.consumer.ConsumerRecord;
+import org.apache.kafka.clients.consumer.ConsumerRecords;
+import org.apache.kafka.clients.consumer.KafkaConsumer;
+import org.apache.kafka.clients.producer.KafkaProducer;
+import org.apache.kafka.clients.producer.Producer;
+import org.apache.kafka.clients.producer.ProducerConfig;
+import org.apache.kafka.clients.producer.ProducerRecord;
+import org.apache.kafka.common.serialization.StringDeserializer;
+import org.apache.kafka.common.serialization.StringSerializer;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+
+/**
+ * A Kafka topic-based implementation of {@link org.apache.camel.spi.IdempotentRepository}.
+ *
+ * Uses a local cache of previously seen Message IDs. All mutations of the cache are via a Kafka topic, on which
+ * additions and removals are broadcast. The topic used must be unique per repository instance. This class makes no
+ * assumptions about number of partitions (it is designed to consume from all at the same time), or replication factor.
+ * Each repository instance that uses the topic (e.g. on different machines running in parallel) controls its own
+ * consumer group.
+ *
+ * On startup, the instance subscribes to the topic and rewinds the offset to the beginning, rebuilding the cache to the
+ * latest state.
+ *
+ * To use, this repository must be placed in the Camel registry, either manually or by registration as a bean in
+ * Spring/Blueprint, as it is CamelContext aware.
+ *
+ * @author jkorab
+ */
+@ManagedResource(description = ""Kafka IdempotentRepository"")
+public class KafkaIdempotentRepository extends ServiceSupport implements IdempotentRepository<String>, CamelContextAware {
+
+    private static final int DEFAULT_MAXIMUM_CACHE_SIZE = 1000;
+
+    private final Logger log = LoggerFactory.getLogger(this.getClass());
+    private final Map<String, Object> cache;
+
+    private final AtomicLong duplicateCount = new AtomicLong(0);
+    private final String topic;
+    private final Properties producerConfig;
+    private final Properties consumerConfig;
+
+    private Consumer<String, String> consumer;
+    private Producer<String, String> producer;
+    private TopicPoller topicPoller;
+
+    private CamelContext camelContext;
+    private ExecutorService executorService;
+    private CountDownLatch cacheReadyLatch;
+
+    enum CacheAction {
+        add,
+        remove,
+        clear
+    }
+
+    public KafkaIdempotentRepository(String topic, String bootstrapServers) {
+        this(topic, bootstrapServers, DEFAULT_MAXIMUM_CACHE_SIZE);
+    }
+
+    public KafkaIdempotentRepository(String topic, String bootstrapServers, int maxCacheSize) {
+        StringHelper.notEmpty(topic, ""topic"");
+        StringHelper.notEmpty(bootstrapServers, ""bootstrapServers"");
+        Properties consumerConfig = new Properties();
+        consumerConfig.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);
+
+        Properties producerConfig = new Properties();
+        producerConfig.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);
+
+        this.topic = topic;
+        this.consumerConfig = consumerConfig;
+        this.producerConfig = producerConfig;
+        this.cache = Collections.synchronizedMap(new LRUCache<>(maxCacheSize));
+    }
+
+    public KafkaIdempotentRepository(String topic, Properties consumerConfig, Properties producerConfig) {
+        this(topic, consumerConfig, producerConfig, DEFAULT_MAXIMUM_CACHE_SIZE);
+    }
+
+    public KafkaIdempotentRepository(String topic, Properties consumerConfig, Properties producerConfig, int maxCacheSize) {
+        StringHelper.notEmpty(topic, ""topic"");
+        this.topic = topic;
+        ObjectHelper.notNull(consumerConfig, ""consumerConfig"");
+        this.consumerConfig = consumerConfig;
+        ObjectHelper.notNull(producerConfig, ""producerConfig"");
+        this.producerConfig = producerConfig;
+        this.cache = Collections.synchronizedMap(new LRUCache<>(maxCacheSize));
+    }
+
+    @Override
+    protected void doStart() throws Exception {
+        log.info(""Context: {}"", camelContext);
+
+        // each consumer instance must have control over its own offset, so assign a groupID at random
+        String groupId = UUID.randomUUID().toString();
+        log.debug(""Creating consumer with {}[{}]"", ConsumerConfig.GROUP_ID_CONFIG, groupId);
+
+        consumerConfig.put(ConsumerConfig.GROUP_ID_CONFIG, groupId);
+        consumerConfig.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, Boolean.TRUE.toString());
+        consumerConfig.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName());
+        consumerConfig.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName());
+
+        consumer = new KafkaConsumer<>(consumerConfig);
+
+        producerConfig.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());
+        producerConfig.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());
+        // set up the producer to remove all batching on send
+        producerConfig.putIfAbsent(ProducerConfig.ACKS_CONFIG, ""1"");
+        producerConfig.putIfAbsent(ProducerConfig.BATCH_SIZE_CONFIG, ""0"");
+        producer = new KafkaProducer<>(producerConfig);
+
+        cacheReadyLatch = new CountDownLatch(1);
+        topicPoller = new TopicPoller(consumer, cacheReadyLatch);
+    }
+
+    @Override
+    public void setCamelContext(CamelContext camelContext) {
+        // doStart() has already been called at this point
+        this.camelContext = camelContext;
+        ExecutorServiceManager executorServiceManager = camelContext.getExecutorServiceManager();
+        executorService = executorServiceManager.newFixedThreadPool(this, ""KafkaIdempotentRepository"", 1);
+        executorService.submit(topicPoller);","[{'comment': 'Also mind that submitting a task should maybe be done last so all the other stuff is created and ready', 'commenter': 'davsclaus'}, {'comment': 'Line 162 is currently at line 274. The cache, latched at line 280, is warmed up by the poller thread, so this is in the right place.', 'commenter': 'jkorab'}]"
1502,components/camel-kafka/src/main/java/org/apache/camel/processor/idempotent/kafka/KafkaIdempotentRepository.java,"@@ -0,0 +1,342 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.processor.idempotent.kafka;
+
+import java.util.Collections;
+import java.util.Map;
+import java.util.Properties;
+import java.util.UUID;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicLong;
+
+import org.apache.camel.CamelContext;
+import org.apache.camel.CamelContextAware;
+import org.apache.camel.api.management.ManagedOperation;
+import org.apache.camel.api.management.ManagedResource;
+import org.apache.camel.spi.ExecutorServiceManager;
+import org.apache.camel.spi.IdempotentRepository;
+import org.apache.camel.support.ServiceSupport;
+import org.apache.camel.util.LRUCache;
+import org.apache.camel.util.ObjectHelper;
+import org.apache.camel.util.StringHelper;
+
+import org.apache.kafka.clients.consumer.Consumer;
+import org.apache.kafka.clients.consumer.ConsumerConfig;
+import org.apache.kafka.clients.consumer.ConsumerRecord;
+import org.apache.kafka.clients.consumer.ConsumerRecords;
+import org.apache.kafka.clients.consumer.KafkaConsumer;
+import org.apache.kafka.clients.producer.KafkaProducer;
+import org.apache.kafka.clients.producer.Producer;
+import org.apache.kafka.clients.producer.ProducerConfig;
+import org.apache.kafka.clients.producer.ProducerRecord;
+import org.apache.kafka.common.serialization.StringDeserializer;
+import org.apache.kafka.common.serialization.StringSerializer;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+
+/**
+ * A Kafka topic-based implementation of {@link org.apache.camel.spi.IdempotentRepository}.
+ *
+ * Uses a local cache of previously seen Message IDs. All mutations of the cache are via a Kafka topic, on which
+ * additions and removals are broadcast. The topic used must be unique per repository instance. This class makes no
+ * assumptions about number of partitions (it is designed to consume from all at the same time), or replication factor.
+ * Each repository instance that uses the topic (e.g. on different machines running in parallel) controls its own
+ * consumer group.
+ *
+ * On startup, the instance subscribes to the topic and rewinds the offset to the beginning, rebuilding the cache to the
+ * latest state.
+ *
+ * To use, this repository must be placed in the Camel registry, either manually or by registration as a bean in
+ * Spring/Blueprint, as it is CamelContext aware.
+ *
+ * @author jkorab
+ */
+@ManagedResource(description = ""Kafka IdempotentRepository"")
+public class KafkaIdempotentRepository extends ServiceSupport implements IdempotentRepository<String>, CamelContextAware {
+
+    private static final int DEFAULT_MAXIMUM_CACHE_SIZE = 1000;
+
+    private final Logger log = LoggerFactory.getLogger(this.getClass());
+    private final Map<String, Object> cache;
+
+    private final AtomicLong duplicateCount = new AtomicLong(0);
+    private final String topic;
+    private final Properties producerConfig;
+    private final Properties consumerConfig;
+
+    private Consumer<String, String> consumer;
+    private Producer<String, String> producer;
+    private TopicPoller topicPoller;
+
+    private CamelContext camelContext;
+    private ExecutorService executorService;
+    private CountDownLatch cacheReadyLatch;
+
+    enum CacheAction {
+        add,
+        remove,
+        clear
+    }
+
+    public KafkaIdempotentRepository(String topic, String bootstrapServers) {
+        this(topic, bootstrapServers, DEFAULT_MAXIMUM_CACHE_SIZE);
+    }
+
+    public KafkaIdempotentRepository(String topic, String bootstrapServers, int maxCacheSize) {
+        StringHelper.notEmpty(topic, ""topic"");
+        StringHelper.notEmpty(bootstrapServers, ""bootstrapServers"");
+        Properties consumerConfig = new Properties();
+        consumerConfig.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);
+
+        Properties producerConfig = new Properties();
+        producerConfig.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);
+
+        this.topic = topic;
+        this.consumerConfig = consumerConfig;
+        this.producerConfig = producerConfig;
+        this.cache = Collections.synchronizedMap(new LRUCache<>(maxCacheSize));
+    }
+
+    public KafkaIdempotentRepository(String topic, Properties consumerConfig, Properties producerConfig) {
+        this(topic, consumerConfig, producerConfig, DEFAULT_MAXIMUM_CACHE_SIZE);
+    }
+
+    public KafkaIdempotentRepository(String topic, Properties consumerConfig, Properties producerConfig, int maxCacheSize) {
+        StringHelper.notEmpty(topic, ""topic"");
+        this.topic = topic;
+        ObjectHelper.notNull(consumerConfig, ""consumerConfig"");
+        this.consumerConfig = consumerConfig;
+        ObjectHelper.notNull(producerConfig, ""producerConfig"");
+        this.producerConfig = producerConfig;
+        this.cache = Collections.synchronizedMap(new LRUCache<>(maxCacheSize));
+    }
+
+    @Override
+    protected void doStart() throws Exception {
+        log.info(""Context: {}"", camelContext);
+
+        // each consumer instance must have control over its own offset, so assign a groupID at random
+        String groupId = UUID.randomUUID().toString();
+        log.debug(""Creating consumer with {}[{}]"", ConsumerConfig.GROUP_ID_CONFIG, groupId);
+
+        consumerConfig.put(ConsumerConfig.GROUP_ID_CONFIG, groupId);
+        consumerConfig.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, Boolean.TRUE.toString());
+        consumerConfig.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName());
+        consumerConfig.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName());
+
+        consumer = new KafkaConsumer<>(consumerConfig);
+
+        producerConfig.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());
+        producerConfig.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());
+        // set up the producer to remove all batching on send
+        producerConfig.putIfAbsent(ProducerConfig.ACKS_CONFIG, ""1"");
+        producerConfig.putIfAbsent(ProducerConfig.BATCH_SIZE_CONFIG, ""0"");
+        producer = new KafkaProducer<>(producerConfig);
+
+        cacheReadyLatch = new CountDownLatch(1);
+        topicPoller = new TopicPoller(consumer, cacheReadyLatch);
+    }
+
+    @Override
+    public void setCamelContext(CamelContext camelContext) {
+        // doStart() has already been called at this point
+        this.camelContext = camelContext;
+        ExecutorServiceManager executorServiceManager = camelContext.getExecutorServiceManager();
+        executorService = executorServiceManager.newFixedThreadPool(this, ""KafkaIdempotentRepository"", 1);
+        executorService.submit(topicPoller);
+        log.info(""Warming up cache"");
+        try {
+            if (cacheReadyLatch.await(30, TimeUnit.SECONDS)) {
+                log.info(""Cache OK"");
+            } else {
+                log.warn(""Timeout waiting for cache warm-up from topic {}. Proceeding anyway. ""
+                        + ""Duplicate records may not be detected."", topic);
+            }
+        } catch (InterruptedException e) {
+            e.printStackTrace();
+        }
+
+    }
+
+    @Override
+    public CamelContext getCamelContext() {
+        return this.camelContext;
+    }
+
+    @Override
+    protected void doStop() {
+        // stop the thread
+        topicPoller.setRunning(false);
+        try {
+            if (topicPoller.getShutdownLatch().await(30, TimeUnit.SECONDS)) {
+                log.info(""Expired waiting on topicPoller to shut down"");
+            }
+        } catch (InterruptedException e) {
+            log.info(""Interrupted waiting on latch: {}"", e.getMessage());
+        }
+        executorService.shutdown();","[{'comment': 'use camel context -> executor service manager -> has api to shutdown thread pool more safely', 'commenter': 'davsclaus'}, {'comment': 'camelContext.getExecutorServiceManager().shutdown(executorService);\r\n\r\nDone, thanks.', 'commenter': 'jkorab'}]"
1502,components/camel-kafka/src/main/java/org/apache/camel/processor/idempotent/kafka/KafkaIdempotentRepository.java,"@@ -0,0 +1,342 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.processor.idempotent.kafka;
+
+import java.util.Collections;
+import java.util.Map;
+import java.util.Properties;
+import java.util.UUID;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicLong;
+
+import org.apache.camel.CamelContext;
+import org.apache.camel.CamelContextAware;
+import org.apache.camel.api.management.ManagedOperation;
+import org.apache.camel.api.management.ManagedResource;
+import org.apache.camel.spi.ExecutorServiceManager;
+import org.apache.camel.spi.IdempotentRepository;
+import org.apache.camel.support.ServiceSupport;
+import org.apache.camel.util.LRUCache;
+import org.apache.camel.util.ObjectHelper;
+import org.apache.camel.util.StringHelper;
+
+import org.apache.kafka.clients.consumer.Consumer;
+import org.apache.kafka.clients.consumer.ConsumerConfig;
+import org.apache.kafka.clients.consumer.ConsumerRecord;
+import org.apache.kafka.clients.consumer.ConsumerRecords;
+import org.apache.kafka.clients.consumer.KafkaConsumer;
+import org.apache.kafka.clients.producer.KafkaProducer;
+import org.apache.kafka.clients.producer.Producer;
+import org.apache.kafka.clients.producer.ProducerConfig;
+import org.apache.kafka.clients.producer.ProducerRecord;
+import org.apache.kafka.common.serialization.StringDeserializer;
+import org.apache.kafka.common.serialization.StringSerializer;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+
+/**
+ * A Kafka topic-based implementation of {@link org.apache.camel.spi.IdempotentRepository}.
+ *
+ * Uses a local cache of previously seen Message IDs. All mutations of the cache are via a Kafka topic, on which
+ * additions and removals are broadcast. The topic used must be unique per repository instance. This class makes no
+ * assumptions about number of partitions (it is designed to consume from all at the same time), or replication factor.
+ * Each repository instance that uses the topic (e.g. on different machines running in parallel) controls its own
+ * consumer group.
+ *
+ * On startup, the instance subscribes to the topic and rewinds the offset to the beginning, rebuilding the cache to the
+ * latest state.
+ *
+ * To use, this repository must be placed in the Camel registry, either manually or by registration as a bean in
+ * Spring/Blueprint, as it is CamelContext aware.
+ *
+ * @author jkorab
+ */
+@ManagedResource(description = ""Kafka IdempotentRepository"")
+public class KafkaIdempotentRepository extends ServiceSupport implements IdempotentRepository<String>, CamelContextAware {
+
+    private static final int DEFAULT_MAXIMUM_CACHE_SIZE = 1000;
+
+    private final Logger log = LoggerFactory.getLogger(this.getClass());
+    private final Map<String, Object> cache;
+
+    private final AtomicLong duplicateCount = new AtomicLong(0);
+    private final String topic;
+    private final Properties producerConfig;
+    private final Properties consumerConfig;
+
+    private Consumer<String, String> consumer;
+    private Producer<String, String> producer;
+    private TopicPoller topicPoller;
+
+    private CamelContext camelContext;
+    private ExecutorService executorService;
+    private CountDownLatch cacheReadyLatch;
+
+    enum CacheAction {
+        add,
+        remove,
+        clear
+    }
+
+    public KafkaIdempotentRepository(String topic, String bootstrapServers) {
+        this(topic, bootstrapServers, DEFAULT_MAXIMUM_CACHE_SIZE);
+    }
+
+    public KafkaIdempotentRepository(String topic, String bootstrapServers, int maxCacheSize) {
+        StringHelper.notEmpty(topic, ""topic"");
+        StringHelper.notEmpty(bootstrapServers, ""bootstrapServers"");
+        Properties consumerConfig = new Properties();
+        consumerConfig.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);
+
+        Properties producerConfig = new Properties();
+        producerConfig.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);
+
+        this.topic = topic;
+        this.consumerConfig = consumerConfig;
+        this.producerConfig = producerConfig;
+        this.cache = Collections.synchronizedMap(new LRUCache<>(maxCacheSize));
+    }
+
+    public KafkaIdempotentRepository(String topic, Properties consumerConfig, Properties producerConfig) {
+        this(topic, consumerConfig, producerConfig, DEFAULT_MAXIMUM_CACHE_SIZE);
+    }
+
+    public KafkaIdempotentRepository(String topic, Properties consumerConfig, Properties producerConfig, int maxCacheSize) {
+        StringHelper.notEmpty(topic, ""topic"");
+        this.topic = topic;
+        ObjectHelper.notNull(consumerConfig, ""consumerConfig"");
+        this.consumerConfig = consumerConfig;
+        ObjectHelper.notNull(producerConfig, ""producerConfig"");
+        this.producerConfig = producerConfig;
+        this.cache = Collections.synchronizedMap(new LRUCache<>(maxCacheSize));
+    }
+
+    @Override
+    protected void doStart() throws Exception {
+        log.info(""Context: {}"", camelContext);
+
+        // each consumer instance must have control over its own offset, so assign a groupID at random
+        String groupId = UUID.randomUUID().toString();
+        log.debug(""Creating consumer with {}[{}]"", ConsumerConfig.GROUP_ID_CONFIG, groupId);
+
+        consumerConfig.put(ConsumerConfig.GROUP_ID_CONFIG, groupId);
+        consumerConfig.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, Boolean.TRUE.toString());
+        consumerConfig.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName());
+        consumerConfig.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName());
+
+        consumer = new KafkaConsumer<>(consumerConfig);
+
+        producerConfig.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());
+        producerConfig.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());
+        // set up the producer to remove all batching on send
+        producerConfig.putIfAbsent(ProducerConfig.ACKS_CONFIG, ""1"");
+        producerConfig.putIfAbsent(ProducerConfig.BATCH_SIZE_CONFIG, ""0"");
+        producer = new KafkaProducer<>(producerConfig);
+
+        cacheReadyLatch = new CountDownLatch(1);
+        topicPoller = new TopicPoller(consumer, cacheReadyLatch);
+    }
+
+    @Override
+    public void setCamelContext(CamelContext camelContext) {
+        // doStart() has already been called at this point
+        this.camelContext = camelContext;
+        ExecutorServiceManager executorServiceManager = camelContext.getExecutorServiceManager();
+        executorService = executorServiceManager.newFixedThreadPool(this, ""KafkaIdempotentRepository"", 1);
+        executorService.submit(topicPoller);
+        log.info(""Warming up cache"");
+        try {
+            if (cacheReadyLatch.await(30, TimeUnit.SECONDS)) {
+                log.info(""Cache OK"");
+            } else {
+                log.warn(""Timeout waiting for cache warm-up from topic {}. Proceeding anyway. ""
+                        + ""Duplicate records may not be detected."", topic);
+            }
+        } catch (InterruptedException e) {
+            e.printStackTrace();
+        }
+
+    }
+
+    @Override
+    public CamelContext getCamelContext() {
+        return this.camelContext;
+    }
+
+    @Override
+    protected void doStop() {
+        // stop the thread
+        topicPoller.setRunning(false);
+        try {
+            if (topicPoller.getShutdownLatch().await(30, TimeUnit.SECONDS)) {
+                log.info(""Expired waiting on topicPoller to shut down"");
+            }
+        } catch (InterruptedException e) {
+            log.info(""Interrupted waiting on latch: {}"", e.getMessage());
+        }
+        executorService.shutdown();
+
+        try {
+            consumer.close();","[{'comment': 'IOHelper has a close method', 'commenter': 'davsclaus'}, {'comment': 'Done, thanks. How many of these utility classes are there?! ;)', 'commenter': 'jkorab'}]"
1502,components/camel-kafka/src/main/java/org/apache/camel/processor/idempotent/kafka/KafkaIdempotentRepository.java,"@@ -0,0 +1,342 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.processor.idempotent.kafka;
+
+import java.util.Collections;
+import java.util.Map;
+import java.util.Properties;
+import java.util.UUID;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicLong;
+
+import org.apache.camel.CamelContext;
+import org.apache.camel.CamelContextAware;
+import org.apache.camel.api.management.ManagedOperation;
+import org.apache.camel.api.management.ManagedResource;
+import org.apache.camel.spi.ExecutorServiceManager;
+import org.apache.camel.spi.IdempotentRepository;
+import org.apache.camel.support.ServiceSupport;
+import org.apache.camel.util.LRUCache;
+import org.apache.camel.util.ObjectHelper;
+import org.apache.camel.util.StringHelper;
+
+import org.apache.kafka.clients.consumer.Consumer;
+import org.apache.kafka.clients.consumer.ConsumerConfig;
+import org.apache.kafka.clients.consumer.ConsumerRecord;
+import org.apache.kafka.clients.consumer.ConsumerRecords;
+import org.apache.kafka.clients.consumer.KafkaConsumer;
+import org.apache.kafka.clients.producer.KafkaProducer;
+import org.apache.kafka.clients.producer.Producer;
+import org.apache.kafka.clients.producer.ProducerConfig;
+import org.apache.kafka.clients.producer.ProducerRecord;
+import org.apache.kafka.common.serialization.StringDeserializer;
+import org.apache.kafka.common.serialization.StringSerializer;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+
+/**
+ * A Kafka topic-based implementation of {@link org.apache.camel.spi.IdempotentRepository}.
+ *
+ * Uses a local cache of previously seen Message IDs. All mutations of the cache are via a Kafka topic, on which
+ * additions and removals are broadcast. The topic used must be unique per repository instance. This class makes no
+ * assumptions about number of partitions (it is designed to consume from all at the same time), or replication factor.
+ * Each repository instance that uses the topic (e.g. on different machines running in parallel) controls its own
+ * consumer group.
+ *
+ * On startup, the instance subscribes to the topic and rewinds the offset to the beginning, rebuilding the cache to the
+ * latest state.
+ *
+ * To use, this repository must be placed in the Camel registry, either manually or by registration as a bean in
+ * Spring/Blueprint, as it is CamelContext aware.
+ *
+ * @author jkorab
+ */
+@ManagedResource(description = ""Kafka IdempotentRepository"")
+public class KafkaIdempotentRepository extends ServiceSupport implements IdempotentRepository<String>, CamelContextAware {
+
+    private static final int DEFAULT_MAXIMUM_CACHE_SIZE = 1000;
+
+    private final Logger log = LoggerFactory.getLogger(this.getClass());
+    private final Map<String, Object> cache;
+
+    private final AtomicLong duplicateCount = new AtomicLong(0);
+    private final String topic;
+    private final Properties producerConfig;
+    private final Properties consumerConfig;
+
+    private Consumer<String, String> consumer;
+    private Producer<String, String> producer;
+    private TopicPoller topicPoller;
+
+    private CamelContext camelContext;
+    private ExecutorService executorService;
+    private CountDownLatch cacheReadyLatch;
+
+    enum CacheAction {
+        add,
+        remove,
+        clear
+    }
+
+    public KafkaIdempotentRepository(String topic, String bootstrapServers) {
+        this(topic, bootstrapServers, DEFAULT_MAXIMUM_CACHE_SIZE);
+    }
+
+    public KafkaIdempotentRepository(String topic, String bootstrapServers, int maxCacheSize) {
+        StringHelper.notEmpty(topic, ""topic"");
+        StringHelper.notEmpty(bootstrapServers, ""bootstrapServers"");
+        Properties consumerConfig = new Properties();
+        consumerConfig.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);
+
+        Properties producerConfig = new Properties();
+        producerConfig.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);
+
+        this.topic = topic;
+        this.consumerConfig = consumerConfig;
+        this.producerConfig = producerConfig;
+        this.cache = Collections.synchronizedMap(new LRUCache<>(maxCacheSize));
+    }
+
+    public KafkaIdempotentRepository(String topic, Properties consumerConfig, Properties producerConfig) {
+        this(topic, consumerConfig, producerConfig, DEFAULT_MAXIMUM_CACHE_SIZE);
+    }
+
+    public KafkaIdempotentRepository(String topic, Properties consumerConfig, Properties producerConfig, int maxCacheSize) {
+        StringHelper.notEmpty(topic, ""topic"");
+        this.topic = topic;
+        ObjectHelper.notNull(consumerConfig, ""consumerConfig"");
+        this.consumerConfig = consumerConfig;
+        ObjectHelper.notNull(producerConfig, ""producerConfig"");
+        this.producerConfig = producerConfig;
+        this.cache = Collections.synchronizedMap(new LRUCache<>(maxCacheSize));
+    }
+
+    @Override
+    protected void doStart() throws Exception {
+        log.info(""Context: {}"", camelContext);
+
+        // each consumer instance must have control over its own offset, so assign a groupID at random
+        String groupId = UUID.randomUUID().toString();
+        log.debug(""Creating consumer with {}[{}]"", ConsumerConfig.GROUP_ID_CONFIG, groupId);
+
+        consumerConfig.put(ConsumerConfig.GROUP_ID_CONFIG, groupId);
+        consumerConfig.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, Boolean.TRUE.toString());
+        consumerConfig.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName());
+        consumerConfig.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName());
+
+        consumer = new KafkaConsumer<>(consumerConfig);
+
+        producerConfig.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());
+        producerConfig.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());
+        // set up the producer to remove all batching on send
+        producerConfig.putIfAbsent(ProducerConfig.ACKS_CONFIG, ""1"");
+        producerConfig.putIfAbsent(ProducerConfig.BATCH_SIZE_CONFIG, ""0"");
+        producer = new KafkaProducer<>(producerConfig);
+
+        cacheReadyLatch = new CountDownLatch(1);
+        topicPoller = new TopicPoller(consumer, cacheReadyLatch);
+    }
+
+    @Override
+    public void setCamelContext(CamelContext camelContext) {
+        // doStart() has already been called at this point
+        this.camelContext = camelContext;
+        ExecutorServiceManager executorServiceManager = camelContext.getExecutorServiceManager();
+        executorService = executorServiceManager.newFixedThreadPool(this, ""KafkaIdempotentRepository"", 1);
+        executorService.submit(topicPoller);
+        log.info(""Warming up cache"");
+        try {
+            if (cacheReadyLatch.await(30, TimeUnit.SECONDS)) {
+                log.info(""Cache OK"");
+            } else {
+                log.warn(""Timeout waiting for cache warm-up from topic {}. Proceeding anyway. ""
+                        + ""Duplicate records may not be detected."", topic);
+            }
+        } catch (InterruptedException e) {
+            e.printStackTrace();
+        }
+
+    }
+
+    @Override
+    public CamelContext getCamelContext() {
+        return this.camelContext;
+    }
+
+    @Override
+    protected void doStop() {
+        // stop the thread
+        topicPoller.setRunning(false);
+        try {
+            if (topicPoller.getShutdownLatch().await(30, TimeUnit.SECONDS)) {
+                log.info(""Expired waiting on topicPoller to shut down"");
+            }
+        } catch (InterruptedException e) {
+            log.info(""Interrupted waiting on latch: {}"", e.getMessage());
+        }
+        executorService.shutdown();
+
+        try {
+            consumer.close();
+        } finally {
+            producer.close();
+        }
+    }
+
+    @Override
+    public boolean add(String key) {
+        if (cache.containsKey(key)) {
+            duplicateCount.incrementAndGet();
+            return false;
+        } else {
+            broadcastAction(key, CacheAction.add);
+            return true;
+        }
+    }
+
+    private void broadcastAction(String key, CacheAction action) {
+        try {
+            log.debug(""Broadcasting action:{} for key:{}"", action, key);
+            producer.send(new ProducerRecord<>(topic, key, action.toString())).get(); // sync send
+        } catch (ExecutionException | InterruptedException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    @Override
+    @ManagedOperation(description = ""Does the store contain the given key"")
+    public boolean contains(String key) {
+        log.debug(""Checking cache for key:{}"", key);
+        boolean containsKey = cache.containsKey(key);
+        if (containsKey) {
+            duplicateCount.incrementAndGet();
+        }
+        return containsKey;
+    }
+
+    @Override
+    @ManagedOperation(description = ""Remove the key from the store"")
+    public boolean remove(String key) {
+        broadcastAction(key, CacheAction.remove);
+        return true;
+    }
+
+    @Override
+    public boolean confirm(String key) {
+        return true; // no-op
+    }
+
+    @Override
+    public void clear() {
+        broadcastAction(null, CacheAction.clear);
+    }
+
+    @ManagedOperation(description = ""Number of times duplicate messages have been detected"")
+    public long getDuplicateCount() {
+        return duplicateCount.get();
+    }
+
+    @ManagedOperation(description = ""Number of times duplicate messages have been detected"")
+    public boolean isPollerRunning() {
+        return topicPoller.getRunning();
+    }
+
+    private class TopicPoller implements Runnable {
+
+        private static final int POLL_DURATION_MS = 10;
+
+        private final Logger log = LoggerFactory.getLogger(this.getClass());
+        private final Consumer<String, String> consumer;
+        private final CountDownLatch cacheReadyLatch;
+
+        private CountDownLatch shutdownLatch = new CountDownLatch(1);
+        private AtomicBoolean running = new AtomicBoolean(true);
+
+        TopicPoller(Consumer<String, String> consumer, CountDownLatch cacheReadyLatch) {
+            this.consumer = consumer;
+            this.cacheReadyLatch = cacheReadyLatch;
+        }
+
+        @Override
+        public void run() {
+            log.debug(""Subscribing consumer to {}"", topic);
+            consumer.subscribe(Collections.singleton(topic));
+            log.debug(""Seeking to beginning"");
+            consumer.seekToBeginning(consumer.assignment());
+
+            POLL_LOOP: while (running.get()) {
+                log.trace(""Polling"");
+                ConsumerRecords<String, String> consumerRecords = consumer.poll(POLL_DURATION_MS);
+                if (consumerRecords.isEmpty()) {
+                    // the first time this happens, we can assume that we have consumed all
+                    // messages up to this point
+                    log.trace(""0 messages fetched on poll"");
+                    if (cacheReadyLatch.getCount() > 0) {
+                        log.debug(""Cache warmed up"");
+                        cacheReadyLatch.countDown();
+                    }
+                }
+                for (ConsumerRecord<String, String> consumerRecord: consumerRecords) {
+                    CacheAction action;
+                    try {
+                        action = CacheAction.valueOf(consumerRecord.value());
+                    } catch (IllegalArgumentException iax) {
+                        log.error(""Unexpected action value:\""{}\"" received on [topic:{}, partition:{}, offset:{}]. Shutting down."",
+                                consumerRecord.key(), consumerRecord.topic(), consumerRecord.partition(), consumerRecord.offset());
+                        setRunning(false);
+                        continue POLL_LOOP;
+                    }
+                    String messageId = consumerRecord.key();
+                    if (action == CacheAction.add) {
+                        log.debug(""Adding to cache messageId:{}"", messageId);
+                        cache.put(messageId, messageId);
+                    } else if (action == CacheAction.remove) {
+                        log.debug(""Removing from cache messageId:{}"", messageId);
+                        cache.remove(messageId);
+                    } else if (action == CacheAction.clear) {
+                        cache.clear();
+                    } else {
+                        // this should never happen
+                        log.error(""No idea how to {} a record. Shutting down."", action);","[{'comment': 'Maybe its a WARN ?', 'commenter': 'davsclaus'}, {'comment': 'Yes. Done.\r\n', 'commenter': 'jkorab'}]"
1502,components/camel-kafka/src/main/java/org/apache/camel/processor/idempotent/kafka/KafkaIdempotentRepository.java,"@@ -0,0 +1,342 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.processor.idempotent.kafka;
+
+import java.util.Collections;
+import java.util.Map;
+import java.util.Properties;
+import java.util.UUID;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicLong;
+
+import org.apache.camel.CamelContext;
+import org.apache.camel.CamelContextAware;
+import org.apache.camel.api.management.ManagedOperation;
+import org.apache.camel.api.management.ManagedResource;
+import org.apache.camel.spi.ExecutorServiceManager;
+import org.apache.camel.spi.IdempotentRepository;
+import org.apache.camel.support.ServiceSupport;
+import org.apache.camel.util.LRUCache;
+import org.apache.camel.util.ObjectHelper;
+import org.apache.camel.util.StringHelper;
+
+import org.apache.kafka.clients.consumer.Consumer;
+import org.apache.kafka.clients.consumer.ConsumerConfig;
+import org.apache.kafka.clients.consumer.ConsumerRecord;
+import org.apache.kafka.clients.consumer.ConsumerRecords;
+import org.apache.kafka.clients.consumer.KafkaConsumer;
+import org.apache.kafka.clients.producer.KafkaProducer;
+import org.apache.kafka.clients.producer.Producer;
+import org.apache.kafka.clients.producer.ProducerConfig;
+import org.apache.kafka.clients.producer.ProducerRecord;
+import org.apache.kafka.common.serialization.StringDeserializer;
+import org.apache.kafka.common.serialization.StringSerializer;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+
+/**
+ * A Kafka topic-based implementation of {@link org.apache.camel.spi.IdempotentRepository}.
+ *
+ * Uses a local cache of previously seen Message IDs. All mutations of the cache are via a Kafka topic, on which
+ * additions and removals are broadcast. The topic used must be unique per repository instance. This class makes no
+ * assumptions about number of partitions (it is designed to consume from all at the same time), or replication factor.
+ * Each repository instance that uses the topic (e.g. on different machines running in parallel) controls its own
+ * consumer group.
+ *
+ * On startup, the instance subscribes to the topic and rewinds the offset to the beginning, rebuilding the cache to the
+ * latest state.
+ *
+ * To use, this repository must be placed in the Camel registry, either manually or by registration as a bean in
+ * Spring/Blueprint, as it is CamelContext aware.
+ *
+ * @author jkorab
+ */
+@ManagedResource(description = ""Kafka IdempotentRepository"")
+public class KafkaIdempotentRepository extends ServiceSupport implements IdempotentRepository<String>, CamelContextAware {
+
+    private static final int DEFAULT_MAXIMUM_CACHE_SIZE = 1000;
+
+    private final Logger log = LoggerFactory.getLogger(this.getClass());
+    private final Map<String, Object> cache;
+
+    private final AtomicLong duplicateCount = new AtomicLong(0);
+    private final String topic;
+    private final Properties producerConfig;
+    private final Properties consumerConfig;
+
+    private Consumer<String, String> consumer;
+    private Producer<String, String> producer;
+    private TopicPoller topicPoller;
+
+    private CamelContext camelContext;
+    private ExecutorService executorService;
+    private CountDownLatch cacheReadyLatch;
+
+    enum CacheAction {
+        add,
+        remove,
+        clear
+    }
+
+    public KafkaIdempotentRepository(String topic, String bootstrapServers) {
+        this(topic, bootstrapServers, DEFAULT_MAXIMUM_CACHE_SIZE);
+    }
+
+    public KafkaIdempotentRepository(String topic, String bootstrapServers, int maxCacheSize) {
+        StringHelper.notEmpty(topic, ""topic"");
+        StringHelper.notEmpty(bootstrapServers, ""bootstrapServers"");
+        Properties consumerConfig = new Properties();
+        consumerConfig.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);
+
+        Properties producerConfig = new Properties();
+        producerConfig.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);
+
+        this.topic = topic;
+        this.consumerConfig = consumerConfig;
+        this.producerConfig = producerConfig;
+        this.cache = Collections.synchronizedMap(new LRUCache<>(maxCacheSize));
+    }
+
+    public KafkaIdempotentRepository(String topic, Properties consumerConfig, Properties producerConfig) {
+        this(topic, consumerConfig, producerConfig, DEFAULT_MAXIMUM_CACHE_SIZE);
+    }
+
+    public KafkaIdempotentRepository(String topic, Properties consumerConfig, Properties producerConfig, int maxCacheSize) {
+        StringHelper.notEmpty(topic, ""topic"");
+        this.topic = topic;
+        ObjectHelper.notNull(consumerConfig, ""consumerConfig"");
+        this.consumerConfig = consumerConfig;
+        ObjectHelper.notNull(producerConfig, ""producerConfig"");
+        this.producerConfig = producerConfig;
+        this.cache = Collections.synchronizedMap(new LRUCache<>(maxCacheSize));
+    }
+
+    @Override
+    protected void doStart() throws Exception {
+        log.info(""Context: {}"", camelContext);
+
+        // each consumer instance must have control over its own offset, so assign a groupID at random
+        String groupId = UUID.randomUUID().toString();
+        log.debug(""Creating consumer with {}[{}]"", ConsumerConfig.GROUP_ID_CONFIG, groupId);
+
+        consumerConfig.put(ConsumerConfig.GROUP_ID_CONFIG, groupId);
+        consumerConfig.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, Boolean.TRUE.toString());
+        consumerConfig.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName());
+        consumerConfig.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName());
+
+        consumer = new KafkaConsumer<>(consumerConfig);
+
+        producerConfig.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());
+        producerConfig.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());
+        // set up the producer to remove all batching on send
+        producerConfig.putIfAbsent(ProducerConfig.ACKS_CONFIG, ""1"");
+        producerConfig.putIfAbsent(ProducerConfig.BATCH_SIZE_CONFIG, ""0"");
+        producer = new KafkaProducer<>(producerConfig);
+
+        cacheReadyLatch = new CountDownLatch(1);
+        topicPoller = new TopicPoller(consumer, cacheReadyLatch);
+    }
+
+    @Override
+    public void setCamelContext(CamelContext camelContext) {
+        // doStart() has already been called at this point
+        this.camelContext = camelContext;
+        ExecutorServiceManager executorServiceManager = camelContext.getExecutorServiceManager();
+        executorService = executorServiceManager.newFixedThreadPool(this, ""KafkaIdempotentRepository"", 1);
+        executorService.submit(topicPoller);
+        log.info(""Warming up cache"");
+        try {
+            if (cacheReadyLatch.await(30, TimeUnit.SECONDS)) {
+                log.info(""Cache OK"");
+            } else {
+                log.warn(""Timeout waiting for cache warm-up from topic {}. Proceeding anyway. ""
+                        + ""Duplicate records may not be detected."", topic);
+            }
+        } catch (InterruptedException e) {
+            e.printStackTrace();
+        }
+
+    }
+
+    @Override
+    public CamelContext getCamelContext() {
+        return this.camelContext;
+    }
+
+    @Override
+    protected void doStop() {
+        // stop the thread
+        topicPoller.setRunning(false);
+        try {
+            if (topicPoller.getShutdownLatch().await(30, TimeUnit.SECONDS)) {
+                log.info(""Expired waiting on topicPoller to shut down"");
+            }
+        } catch (InterruptedException e) {
+            log.info(""Interrupted waiting on latch: {}"", e.getMessage());
+        }
+        executorService.shutdown();
+
+        try {
+            consumer.close();
+        } finally {
+            producer.close();
+        }
+    }
+
+    @Override
+    public boolean add(String key) {
+        if (cache.containsKey(key)) {
+            duplicateCount.incrementAndGet();
+            return false;
+        } else {
+            broadcastAction(key, CacheAction.add);
+            return true;
+        }
+    }
+
+    private void broadcastAction(String key, CacheAction action) {
+        try {
+            log.debug(""Broadcasting action:{} for key:{}"", action, key);
+            producer.send(new ProducerRecord<>(topic, key, action.toString())).get(); // sync send
+        } catch (ExecutionException | InterruptedException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    @Override
+    @ManagedOperation(description = ""Does the store contain the given key"")
+    public boolean contains(String key) {
+        log.debug(""Checking cache for key:{}"", key);
+        boolean containsKey = cache.containsKey(key);
+        if (containsKey) {
+            duplicateCount.incrementAndGet();
+        }
+        return containsKey;
+    }
+
+    @Override
+    @ManagedOperation(description = ""Remove the key from the store"")
+    public boolean remove(String key) {
+        broadcastAction(key, CacheAction.remove);
+        return true;
+    }
+
+    @Override
+    public boolean confirm(String key) {
+        return true; // no-op
+    }
+
+    @Override
+    public void clear() {
+        broadcastAction(null, CacheAction.clear);
+    }
+
+    @ManagedOperation(description = ""Number of times duplicate messages have been detected"")
+    public long getDuplicateCount() {
+        return duplicateCount.get();
+    }
+
+    @ManagedOperation(description = ""Number of times duplicate messages have been detected"")
+    public boolean isPollerRunning() {
+        return topicPoller.getRunning();
+    }
+
+    private class TopicPoller implements Runnable {
+
+        private static final int POLL_DURATION_MS = 10;
+
+        private final Logger log = LoggerFactory.getLogger(this.getClass());
+        private final Consumer<String, String> consumer;
+        private final CountDownLatch cacheReadyLatch;
+
+        private CountDownLatch shutdownLatch = new CountDownLatch(1);
+        private AtomicBoolean running = new AtomicBoolean(true);
+
+        TopicPoller(Consumer<String, String> consumer, CountDownLatch cacheReadyLatch) {
+            this.consumer = consumer;
+            this.cacheReadyLatch = cacheReadyLatch;
+        }
+
+        @Override
+        public void run() {
+            log.debug(""Subscribing consumer to {}"", topic);
+            consumer.subscribe(Collections.singleton(topic));
+            log.debug(""Seeking to beginning"");
+            consumer.seekToBeginning(consumer.assignment());
+
+            POLL_LOOP: while (running.get()) {
+                log.trace(""Polling"");
+                ConsumerRecords<String, String> consumerRecords = consumer.poll(POLL_DURATION_MS);
+                if (consumerRecords.isEmpty()) {
+                    // the first time this happens, we can assume that we have consumed all
+                    // messages up to this point
+                    log.trace(""0 messages fetched on poll"");
+                    if (cacheReadyLatch.getCount() > 0) {
+                        log.debug(""Cache warmed up"");
+                        cacheReadyLatch.countDown();
+                    }
+                }
+                for (ConsumerRecord<String, String> consumerRecord: consumerRecords) {
+                    CacheAction action;
+                    try {
+                        action = CacheAction.valueOf(consumerRecord.value());
+                    } catch (IllegalArgumentException iax) {
+                        log.error(""Unexpected action value:\""{}\"" received on [topic:{}, partition:{}, offset:{}]. Shutting down."",
+                                consumerRecord.key(), consumerRecord.topic(), consumerRecord.partition(), consumerRecord.offset());
+                        setRunning(false);
+                        continue POLL_LOOP;
+                    }
+                    String messageId = consumerRecord.key();
+                    if (action == CacheAction.add) {
+                        log.debug(""Adding to cache messageId:{}"", messageId);
+                        cache.put(messageId, messageId);
+                    } else if (action == CacheAction.remove) {
+                        log.debug(""Removing from cache messageId:{}"", messageId);
+                        cache.remove(messageId);
+                    } else if (action == CacheAction.clear) {
+                        cache.clear();
+                    } else {
+                        // this should never happen
+                        log.error(""No idea how to {} a record. Shutting down."", action);
+                        setRunning(false);
+                        continue POLL_LOOP;
+                    }
+                }
+
+            }
+            log.debug(""TopicPoller finished - triggering shutdown latch"");
+            shutdownLatch.countDown();
+        }
+
+        CountDownLatch getShutdownLatch() {
+            return shutdownLatch;
+        }
+
+        void setRunning(boolean running) {
+            this.running.set(running);
+        }
+
+        boolean getRunning() {","[{'comment': 'isRunning', 'commenter': 'davsclaus'}, {'comment': 'Done.', 'commenter': 'jkorab'}]"
1502,components/camel-kafka/src/main/java/org/apache/camel/processor/idempotent/kafka/KafkaIdempotentRepository.java,"@@ -0,0 +1,342 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.processor.idempotent.kafka;
+
+import java.util.Collections;
+import java.util.Map;
+import java.util.Properties;
+import java.util.UUID;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicLong;
+
+import org.apache.camel.CamelContext;
+import org.apache.camel.CamelContextAware;
+import org.apache.camel.api.management.ManagedOperation;
+import org.apache.camel.api.management.ManagedResource;
+import org.apache.camel.spi.ExecutorServiceManager;
+import org.apache.camel.spi.IdempotentRepository;
+import org.apache.camel.support.ServiceSupport;
+import org.apache.camel.util.LRUCache;
+import org.apache.camel.util.ObjectHelper;
+import org.apache.camel.util.StringHelper;
+
+import org.apache.kafka.clients.consumer.Consumer;
+import org.apache.kafka.clients.consumer.ConsumerConfig;
+import org.apache.kafka.clients.consumer.ConsumerRecord;
+import org.apache.kafka.clients.consumer.ConsumerRecords;
+import org.apache.kafka.clients.consumer.KafkaConsumer;
+import org.apache.kafka.clients.producer.KafkaProducer;
+import org.apache.kafka.clients.producer.Producer;
+import org.apache.kafka.clients.producer.ProducerConfig;
+import org.apache.kafka.clients.producer.ProducerRecord;
+import org.apache.kafka.common.serialization.StringDeserializer;
+import org.apache.kafka.common.serialization.StringSerializer;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+
+/**
+ * A Kafka topic-based implementation of {@link org.apache.camel.spi.IdempotentRepository}.
+ *
+ * Uses a local cache of previously seen Message IDs. All mutations of the cache are via a Kafka topic, on which
+ * additions and removals are broadcast. The topic used must be unique per repository instance. This class makes no
+ * assumptions about number of partitions (it is designed to consume from all at the same time), or replication factor.
+ * Each repository instance that uses the topic (e.g. on different machines running in parallel) controls its own
+ * consumer group.
+ *
+ * On startup, the instance subscribes to the topic and rewinds the offset to the beginning, rebuilding the cache to the
+ * latest state.
+ *
+ * To use, this repository must be placed in the Camel registry, either manually or by registration as a bean in
+ * Spring/Blueprint, as it is CamelContext aware.
+ *
+ * @author jkorab
+ */
+@ManagedResource(description = ""Kafka IdempotentRepository"")
+public class KafkaIdempotentRepository extends ServiceSupport implements IdempotentRepository<String>, CamelContextAware {
+
+    private static final int DEFAULT_MAXIMUM_CACHE_SIZE = 1000;
+
+    private final Logger log = LoggerFactory.getLogger(this.getClass());
+    private final Map<String, Object> cache;
+
+    private final AtomicLong duplicateCount = new AtomicLong(0);
+    private final String topic;
+    private final Properties producerConfig;
+    private final Properties consumerConfig;
+
+    private Consumer<String, String> consumer;
+    private Producer<String, String> producer;
+    private TopicPoller topicPoller;
+
+    private CamelContext camelContext;
+    private ExecutorService executorService;
+    private CountDownLatch cacheReadyLatch;
+
+    enum CacheAction {
+        add,
+        remove,
+        clear
+    }
+
+    public KafkaIdempotentRepository(String topic, String bootstrapServers) {
+        this(topic, bootstrapServers, DEFAULT_MAXIMUM_CACHE_SIZE);
+    }
+
+    public KafkaIdempotentRepository(String topic, String bootstrapServers, int maxCacheSize) {
+        StringHelper.notEmpty(topic, ""topic"");
+        StringHelper.notEmpty(bootstrapServers, ""bootstrapServers"");
+        Properties consumerConfig = new Properties();
+        consumerConfig.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);
+
+        Properties producerConfig = new Properties();
+        producerConfig.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);
+
+        this.topic = topic;
+        this.consumerConfig = consumerConfig;
+        this.producerConfig = producerConfig;
+        this.cache = Collections.synchronizedMap(new LRUCache<>(maxCacheSize));
+    }
+
+    public KafkaIdempotentRepository(String topic, Properties consumerConfig, Properties producerConfig) {
+        this(topic, consumerConfig, producerConfig, DEFAULT_MAXIMUM_CACHE_SIZE);
+    }
+
+    public KafkaIdempotentRepository(String topic, Properties consumerConfig, Properties producerConfig, int maxCacheSize) {
+        StringHelper.notEmpty(topic, ""topic"");
+        this.topic = topic;
+        ObjectHelper.notNull(consumerConfig, ""consumerConfig"");
+        this.consumerConfig = consumerConfig;
+        ObjectHelper.notNull(producerConfig, ""producerConfig"");
+        this.producerConfig = producerConfig;
+        this.cache = Collections.synchronizedMap(new LRUCache<>(maxCacheSize));
+    }
+
+    @Override
+    protected void doStart() throws Exception {
+        log.info(""Context: {}"", camelContext);
+
+        // each consumer instance must have control over its own offset, so assign a groupID at random
+        String groupId = UUID.randomUUID().toString();
+        log.debug(""Creating consumer with {}[{}]"", ConsumerConfig.GROUP_ID_CONFIG, groupId);
+
+        consumerConfig.put(ConsumerConfig.GROUP_ID_CONFIG, groupId);
+        consumerConfig.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, Boolean.TRUE.toString());
+        consumerConfig.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName());
+        consumerConfig.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName());
+
+        consumer = new KafkaConsumer<>(consumerConfig);
+
+        producerConfig.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());
+        producerConfig.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());
+        // set up the producer to remove all batching on send
+        producerConfig.putIfAbsent(ProducerConfig.ACKS_CONFIG, ""1"");
+        producerConfig.putIfAbsent(ProducerConfig.BATCH_SIZE_CONFIG, ""0"");
+        producer = new KafkaProducer<>(producerConfig);
+
+        cacheReadyLatch = new CountDownLatch(1);
+        topicPoller = new TopicPoller(consumer, cacheReadyLatch);
+    }
+
+    @Override
+    public void setCamelContext(CamelContext camelContext) {
+        // doStart() has already been called at this point
+        this.camelContext = camelContext;
+        ExecutorServiceManager executorServiceManager = camelContext.getExecutorServiceManager();
+        executorService = executorServiceManager.newFixedThreadPool(this, ""KafkaIdempotentRepository"", 1);
+        executorService.submit(topicPoller);
+        log.info(""Warming up cache"");
+        try {
+            if (cacheReadyLatch.await(30, TimeUnit.SECONDS)) {
+                log.info(""Cache OK"");
+            } else {
+                log.warn(""Timeout waiting for cache warm-up from topic {}. Proceeding anyway. ""
+                        + ""Duplicate records may not be detected."", topic);
+            }
+        } catch (InterruptedException e) {
+            e.printStackTrace();
+        }
+
+    }
+
+    @Override
+    public CamelContext getCamelContext() {
+        return this.camelContext;
+    }
+
+    @Override
+    protected void doStop() {
+        // stop the thread
+        topicPoller.setRunning(false);
+        try {
+            if (topicPoller.getShutdownLatch().await(30, TimeUnit.SECONDS)) {
+                log.info(""Expired waiting on topicPoller to shut down"");
+            }
+        } catch (InterruptedException e) {
+            log.info(""Interrupted waiting on latch: {}"", e.getMessage());
+        }
+        executorService.shutdown();
+
+        try {
+            consumer.close();
+        } finally {
+            producer.close();
+        }
+    }
+
+    @Override
+    public boolean add(String key) {
+        if (cache.containsKey(key)) {
+            duplicateCount.incrementAndGet();
+            return false;
+        } else {
+            broadcastAction(key, CacheAction.add);
+            return true;
+        }
+    }
+
+    private void broadcastAction(String key, CacheAction action) {
+        try {
+            log.debug(""Broadcasting action:{} for key:{}"", action, key);
+            producer.send(new ProducerRecord<>(topic, key, action.toString())).get(); // sync send
+        } catch (ExecutionException | InterruptedException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    @Override
+    @ManagedOperation(description = ""Does the store contain the given key"")
+    public boolean contains(String key) {
+        log.debug(""Checking cache for key:{}"", key);
+        boolean containsKey = cache.containsKey(key);
+        if (containsKey) {
+            duplicateCount.incrementAndGet();
+        }
+        return containsKey;
+    }
+
+    @Override
+    @ManagedOperation(description = ""Remove the key from the store"")
+    public boolean remove(String key) {
+        broadcastAction(key, CacheAction.remove);
+        return true;
+    }
+
+    @Override
+    public boolean confirm(String key) {
+        return true; // no-op
+    }
+
+    @Override
+    public void clear() {
+        broadcastAction(null, CacheAction.clear);
+    }
+
+    @ManagedOperation(description = ""Number of times duplicate messages have been detected"")
+    public long getDuplicateCount() {
+        return duplicateCount.get();
+    }
+
+    @ManagedOperation(description = ""Number of times duplicate messages have been detected"")
+    public boolean isPollerRunning() {
+        return topicPoller.getRunning();
+    }
+
+    private class TopicPoller implements Runnable {
+
+        private static final int POLL_DURATION_MS = 10;","[{'comment': 'Is this poll to short? Maybe users want to be able to configure this. Isnt this very chatty over network to do 100 polls per second', 'commenter': 'davsclaus'}, {'comment': ""Yeah, it's a trade-off against local cache liveness. If the poll duration is too long, it messes with the idempotentConsumer eager/non-eager semantics. \r\n\r\nI'll make it that the local cache is updated immediately, and change to 100ms so that any peer processes will be slightly behind, but not hammering the network. This seems like a reasonable poll frequency. \r\n\r\nWhat's the most Camel way to make this configurable? The repo already has quite a lot of constructor arguments. If it was just Java, I'd add a builder for the repository class, but with XML it feels like I'm straying into adding loads of setters."", 'commenter': 'jkorab'}, {'comment': 'This bit is now done.', 'commenter': 'jkorab'}]"
1502,components/camel-kafka/src/main/java/org/apache/camel/processor/idempotent/kafka/KafkaIdempotentRepository.java,"@@ -0,0 +1,344 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.processor.idempotent.kafka;
+
+import java.util.Collections;
+import java.util.Map;
+import java.util.Properties;
+import java.util.UUID;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicLong;
+
+import org.apache.camel.CamelContext;
+import org.apache.camel.CamelContextAware;
+import org.apache.camel.api.management.ManagedOperation;
+import org.apache.camel.api.management.ManagedResource;
+import org.apache.camel.spi.ExecutorServiceManager;
+import org.apache.camel.spi.IdempotentRepository;
+import org.apache.camel.support.ServiceSupport;
+import org.apache.camel.util.IOHelper;
+import org.apache.camel.util.LRUCache;
+import org.apache.camel.util.ObjectHelper;
+import org.apache.camel.util.StringHelper;
+
+import org.apache.kafka.clients.consumer.Consumer;
+import org.apache.kafka.clients.consumer.ConsumerConfig;
+import org.apache.kafka.clients.consumer.ConsumerRecord;
+import org.apache.kafka.clients.consumer.ConsumerRecords;
+import org.apache.kafka.clients.consumer.KafkaConsumer;
+import org.apache.kafka.clients.producer.KafkaProducer;
+import org.apache.kafka.clients.producer.Producer;
+import org.apache.kafka.clients.producer.ProducerConfig;
+import org.apache.kafka.clients.producer.ProducerRecord;
+import org.apache.kafka.common.serialization.StringDeserializer;
+import org.apache.kafka.common.serialization.StringSerializer;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+
+/**
+ * A Kafka topic-based implementation of {@link org.apache.camel.spi.IdempotentRepository}.
+ *
+ * Uses a local cache of previously seen Message IDs. All mutations of the cache are via a Kafka topic, on which
+ * additions and removals are broadcast. The topic used must be unique per repository instance. This class makes no
+ * assumptions about number of partitions (it is designed to consume from all at the same time), or replication factor.
+ * Each repository instance that uses the topic (e.g. on different machines running in parallel) controls its own
+ * consumer group.
+ *
+ * On startup, the instance subscribes to the topic and rewinds the offset to the beginning, rebuilding the cache to the
+ * latest state.
+ *
+ * To use, this repository must be placed in the Camel registry, either manually or by registration as a bean in
+ * Spring/Blueprint, as it is CamelContext aware.
+ *
+ * @author jkorab","[{'comment': 'Please remove author tags as we dont have them at ASF', 'commenter': 'davsclaus'}, {'comment': 'Cool.', 'commenter': 'jkorab'}]"
1502,components/camel-kafka/src/main/java/org/apache/camel/processor/idempotent/kafka/KafkaIdempotentRepository.java,"@@ -0,0 +1,344 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.processor.idempotent.kafka;
+
+import java.util.Collections;
+import java.util.Map;
+import java.util.Properties;
+import java.util.UUID;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicLong;
+
+import org.apache.camel.CamelContext;
+import org.apache.camel.CamelContextAware;
+import org.apache.camel.api.management.ManagedOperation;
+import org.apache.camel.api.management.ManagedResource;
+import org.apache.camel.spi.ExecutorServiceManager;
+import org.apache.camel.spi.IdempotentRepository;
+import org.apache.camel.support.ServiceSupport;
+import org.apache.camel.util.IOHelper;
+import org.apache.camel.util.LRUCache;
+import org.apache.camel.util.ObjectHelper;
+import org.apache.camel.util.StringHelper;
+
+import org.apache.kafka.clients.consumer.Consumer;
+import org.apache.kafka.clients.consumer.ConsumerConfig;
+import org.apache.kafka.clients.consumer.ConsumerRecord;
+import org.apache.kafka.clients.consumer.ConsumerRecords;
+import org.apache.kafka.clients.consumer.KafkaConsumer;
+import org.apache.kafka.clients.producer.KafkaProducer;
+import org.apache.kafka.clients.producer.Producer;
+import org.apache.kafka.clients.producer.ProducerConfig;
+import org.apache.kafka.clients.producer.ProducerRecord;
+import org.apache.kafka.common.serialization.StringDeserializer;
+import org.apache.kafka.common.serialization.StringSerializer;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+
+/**
+ * A Kafka topic-based implementation of {@link org.apache.camel.spi.IdempotentRepository}.
+ *
+ * Uses a local cache of previously seen Message IDs. All mutations of the cache are via a Kafka topic, on which
+ * additions and removals are broadcast. The topic used must be unique per repository instance. This class makes no
+ * assumptions about number of partitions (it is designed to consume from all at the same time), or replication factor.
+ * Each repository instance that uses the topic (e.g. on different machines running in parallel) controls its own
+ * consumer group.
+ *
+ * On startup, the instance subscribes to the topic and rewinds the offset to the beginning, rebuilding the cache to the
+ * latest state.
+ *
+ * To use, this repository must be placed in the Camel registry, either manually or by registration as a bean in
+ * Spring/Blueprint, as it is CamelContext aware.
+ *
+ * @author jkorab
+ */
+@ManagedResource(description = ""Kafka IdempotentRepository"")
+public class KafkaIdempotentRepository extends ServiceSupport implements IdempotentRepository<String>, CamelContextAware {
+
+    private static final int DEFAULT_MAXIMUM_CACHE_SIZE = 1000;
+
+    private final Logger log = LoggerFactory.getLogger(this.getClass());
+    private final Map<String, Object> cache;
+
+    private final AtomicLong duplicateCount = new AtomicLong(0);
+    private final String topic;
+    private final Properties producerConfig;
+    private final Properties consumerConfig;
+
+    private Consumer<String, String> consumer;
+    private Producer<String, String> producer;
+    private TopicPoller topicPoller;
+
+    private CamelContext camelContext;
+    private ExecutorService executorService;
+    private CountDownLatch cacheReadyLatch;
+
+    enum CacheAction {
+        add,
+        remove,
+        clear
+    }
+
+    public KafkaIdempotentRepository(String topic, String bootstrapServers) {
+        this(topic, bootstrapServers, DEFAULT_MAXIMUM_CACHE_SIZE);
+    }
+
+    public KafkaIdempotentRepository(String topic, String bootstrapServers, int maxCacheSize) {
+        StringHelper.notEmpty(topic, ""topic"");","[{'comment': 'Its better to move such logic to doStart and then just let ctr set the values in their setters.\r\n\r\nThen you have all init logic once in doStart that check for null / empty parameters and so on', 'commenter': 'davsclaus'}]"
1504,components/camel-rest-swagger/src/main/java/org/apache/camel/component/rest/swagger/RestSwaggerComponent.java,"@@ -0,0 +1,72 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.rest.swagger;
+
+import java.util.Map;
+
+import org.apache.camel.CamelContext;
+import org.apache.camel.Endpoint;
+import org.apache.camel.impl.DefaultComponent;
+import org.apache.camel.spi.RestProducerFactory;
+
+/**
+ * An awesome REST component backed by Swagger specifications. Creates endpoints that connect to REST APIs defined by
+ * Swagger specification. This component delegates to other {@link RestProducerFactory} components to act as REST
+ * clients, but it configures them from Swagger specification. Client needs to point to operation that it wants to
+ * invoke via REST, provide any additional HTTP headers as headers , and payload as the body of the incoming message.
+ * <p>
+ * Example usage using Java DSL:
+ * <p>
+ *
+ * <pre>
+ * from(""rest-swagger:getPetById?endpoint=https://api.petstore.com"").to(...)
+ * </pre>
+ *
+ * This relies on only one {@link RestProducerFactory} component being available to Camel, you can use specific, for
+ * instance preconfigured component by using the {@code componentName} endpoint property. For example using Undertow
+ * component in Java DSL:
+ * <p>
+ *
+ * <pre>
+ * Component petstore = new UndertowComponent();
+ * petstore.setSslContextParameters(...);
+ * //...
+ * camelContext.addComponent(""petstore"", petstore);
+ *
+ * from(""rest-swagger:getPetById?endpoint=https://api.petstore.com&componentName=petstore"").to(...)
+ * </pre>
+ */
+public class RestSwaggerComponent extends DefaultComponent {","[{'comment': 'It would maybe be nice to be able to configure the endpoint on the component level so you dont have to specify that in the uri, eg that api.petstore.com thingy. ', 'commenter': 'davsclaus'}]"
1504,components/camel-rest-swagger/src/main/java/org/apache/camel/component/rest/swagger/RestSwaggerEndpoint.java,"@@ -0,0 +1,313 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.rest.swagger;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.URISyntaxException;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Map.Entry;
+import java.util.Optional;
+import java.util.Properties;
+import java.util.stream.Collectors;
+
+import com.fasterxml.jackson.databind.JsonNode;
+import com.fasterxml.jackson.databind.ObjectMapper;
+
+import org.apache.camel.CamelContext;
+import org.apache.camel.Component;
+import org.apache.camel.Consumer;
+import org.apache.camel.ExchangePattern;
+import org.apache.camel.Processor;
+import org.apache.camel.Producer;
+import org.apache.camel.impl.DefaultEndpoint;
+import org.apache.camel.spi.Metadata;
+import org.apache.camel.spi.RestProducerFactory;
+import org.apache.camel.spi.UriEndpoint;
+import org.apache.camel.spi.UriParam;
+import org.apache.camel.spi.UriPath;
+import org.apache.camel.util.LoadPropertiesException;
+import org.apache.camel.util.ObjectHelper;
+import org.apache.camel.util.StringHelper;
+
+import io.swagger.models.HttpMethod;
+import io.swagger.models.Operation;
+import io.swagger.models.Path;
+import io.swagger.models.Swagger;
+import io.swagger.parser.SwaggerParser;
+import io.swagger.util.Json;
+
+/**
+ * An awesome REST endpoint backed by Swagger specifications.
+ */
+@UriEndpoint(firstVersion = ""2.19.0"", scheme = ""rest-swagger"", title = ""REST Swagger"",
+             syntax = ""rest-swagger:operationId:specificationPath"", label = ""rest,swagger,http"", producerOnly = true)
+public final class RestSwaggerEndpoint extends DefaultEndpoint {
+
+    private static final String DEFAULT_SPECIFICATION_PATH = ""swagger.json"";
+
+    static final String[] KNOWN_WORKING_COMPONENTS = new String[] {""http"", ""http4"", ""netty4-http"", ""restlet"", ""jetty"",
+            ""undertow""};
+
+    @UriParam(description = ""REST producer component to use, for instance `undertow`, if not defined it is expected that only one REST producer Camel component will be present on the classpath."",
+              label = ""producer"")
+    private String componentName;
+
+    @UriParam(description = ""Scheme, hostname and optionally port to use, in the form of `http[s]://hostname[:port]`"",
+              label = ""producer"")
+    private String endpoint;
+
+    @UriPath(description = ""ID of the operation from the Swagger specification"", label = ""producer"")
+    @Metadata(required = ""true"")
+    private String operationId;
+
+    @UriPath(description = ""Path to the Swagger specification file"", defaultValue = DEFAULT_SPECIFICATION_PATH,
+             defaultValueNote = ""By default loads `swagger.json` file"")
+    private String specificationPath = DEFAULT_SPECIFICATION_PATH;
+
+    public RestSwaggerEndpoint() {
+    }
+
+    public RestSwaggerEndpoint(final String uri, final String remaining, final RestSwaggerComponent component) {
+        super(uri, component);
+
+        operationId = Optional.ofNullable(StringHelper.before(remaining, "":"")).orElse(remaining);
+
+        specificationPath = Optional.ofNullable(StringHelper.after(remaining, "":"")).orElse(DEFAULT_SPECIFICATION_PATH);
+
+        setExchangePattern(ExchangePattern.InOut);
+    }
+
+    /**
+     * Loads the Swagger definition model from the given path. Tries to resolve the resource using Camel's resource
+     * loading support, if it fails uses Swagger's resource loading support instead.
+     *
+     * @param path
+     * @return
+     * @throws IOException
+     */
+    static Swagger loadSpecificationFrom(final String path) throws IOException {
+        final ObjectMapper mapper = Json.mapper();
+
+        final SwaggerParser swaggerParser = new SwaggerParser();
+
+        Swagger answer = null;
+        try (InputStream stream = ObjectHelper.loadResourceAsStream(path)) {","[{'comment': 'You may need to use the one that takes CamelContext or ClassLoader (cant remember) but those support osgi and other ""app servers""', 'commenter': 'davsclaus'}]"
1504,components/camel-rest-swagger/src/main/java/org/apache/camel/component/rest/swagger/RestSwaggerProducer.java,"@@ -0,0 +1,94 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.rest.swagger;
+
+import java.net.URI;
+import java.net.URISyntaxException;
+import java.util.Map;
+
+import com.damnhandy.uri.template.UriTemplate;
+
+import org.apache.camel.CamelContext;
+import org.apache.camel.Endpoint;
+import org.apache.camel.Exchange;
+import org.apache.camel.Message;
+import org.apache.camel.Producer;
+import org.apache.camel.impl.DefaultProducer;
+import org.apache.camel.spi.RestProducerFactory;
+import org.apache.camel.util.ServiceHelper;
+
+/**
+ * An awesome REST producer backed by Swagger specifications delegating to {@link RestProducerFactory} to create the
+ * REST client producer.
+ */
+public class RestSwaggerProducer extends DefaultProducer {
+
+    private final UriTemplate baseTemplate;
+
+    private final String method;
+
+    private final UriTemplate pathTemplate;
+
+    private Producer producer;
+
+    private final RestProducerFactory restProducerFactory;
+
+    public RestSwaggerProducer(final RestSwaggerEndpoint endpoint, final RestProducerFactory restProducerFactory,
+            final String restEndpoint, final String method, final String path) throws URISyntaxException {
+        super(endpoint);
+        this.restProducerFactory = restProducerFactory;
+        this.method = method;
+
+        baseTemplate = UriTemplate.fromTemplate(restEndpoint);
+
+        pathTemplate = UriTemplate.fromTemplate(path);
+    }
+
+    @Override
+    public void process(final Exchange exchange) throws Exception {
+        final Endpoint endpoint = getEndpoint();","[{'comment': 'Do you need all those empty lines, its a bit confusing to read', 'commenter': 'davsclaus'}]"
1504,components/camel-rest-swagger/src/main/java/org/apache/camel/component/rest/swagger/RestSwaggerProducer.java,"@@ -0,0 +1,94 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.rest.swagger;
+
+import java.net.URI;
+import java.net.URISyntaxException;
+import java.util.Map;
+
+import com.damnhandy.uri.template.UriTemplate;
+
+import org.apache.camel.CamelContext;
+import org.apache.camel.Endpoint;
+import org.apache.camel.Exchange;
+import org.apache.camel.Message;
+import org.apache.camel.Producer;
+import org.apache.camel.impl.DefaultProducer;
+import org.apache.camel.spi.RestProducerFactory;
+import org.apache.camel.util.ServiceHelper;
+
+/**
+ * An awesome REST producer backed by Swagger specifications delegating to {@link RestProducerFactory} to create the
+ * REST client producer.
+ */
+public class RestSwaggerProducer extends DefaultProducer {
+
+    private final UriTemplate baseTemplate;
+
+    private final String method;
+
+    private final UriTemplate pathTemplate;
+
+    private Producer producer;
+
+    private final RestProducerFactory restProducerFactory;
+
+    public RestSwaggerProducer(final RestSwaggerEndpoint endpoint, final RestProducerFactory restProducerFactory,
+            final String restEndpoint, final String method, final String path) throws URISyntaxException {
+        super(endpoint);
+        this.restProducerFactory = restProducerFactory;
+        this.method = method;
+
+        baseTemplate = UriTemplate.fromTemplate(restEndpoint);
+
+        pathTemplate = UriTemplate.fromTemplate(path);
+    }
+
+    @Override
+    public void process(final Exchange exchange) throws Exception {
+        final Endpoint endpoint = getEndpoint();
+
+        final CamelContext camelContext = endpoint.getCamelContext();
+
+        final Message in = exchange.getIn();
+        final Map<String, Object> headers = in.getHeaders();
+
+        final String expandedUri = baseTemplate.expand(headers);
+
+        final URI uri = URI.create(expandedUri);
+
+        final String host = new URI(uri.getScheme(), null, uri.getHost(), uri.getPort(), null, null, null).toString();
+
+        final String basePath = uri.getPath();
+
+        final String path = pathTemplate.expand(headers);
+
+        producer = restProducerFactory.createProducer(camelContext, host, method, basePath, path, null, null, null,","[{'comment': 'This is wrong as you create a NEW producer for every message. You should only create 1 producer. ', 'commenter': 'davsclaus'}]"
1504,components/camel-rest-swagger/src/test/java/org/apache/camel/component/rest/swagger/Pet.java,"@@ -0,0 +1,12 @@
+package org.apache.camel.component.rest.swagger;","[{'comment': 'license header', 'commenter': 'davsclaus'}]"
1508,components/camel-aws/src/main/java/org/apache/camel/component/aws/sns/SnsEndpoint.java,"@@ -92,6 +108,11 @@ public void doStart() throws Exception {
             LOG.trace(""Updating the SNS region with : {} "" + configuration.getAmazonSNSEndpoint());
             snsClient.setEndpoint(configuration.getAmazonSNSEndpoint());
         }
+
+        // check the setting the headerFilterStrategy
+        if (headerFilterStrategy == null) {
+            headerFilterStrategy = new SqsHeaderFilterStrategy();","[{'comment': 'This looks like a copy paste mistake, it should be Sns', 'commenter': 'davsclaus'}, {'comment': 'Yes you are right, I will update it', 'commenter': 'PeterOsudio'}]"
1508,components/camel-aws/src/main/java/org/apache/camel/component/aws/sns/SnsProducer.java,"@@ -79,21 +87,52 @@ private String determineMessageStructure(Exchange exchange) {
 
         return structure;
     }
-    
+
+    private Map<String, MessageAttributeValue> translateAttributes(Map<String, Object> headers, Exchange exchange) {
+        HashMap result = new HashMap();
+        HeaderFilterStrategy headerFilterStrategy = this.getEndpoint().getHeaderFilterStrategy();
+        Iterator var5 = headers.entrySet().iterator();","[{'comment': 'Could you rename var5 to be it or something better name', 'commenter': 'davsclaus'}, {'comment': 'Sure!', 'commenter': 'PeterOsudio'}]"
1508,components/camel-aws/src/main/java/org/apache/camel/component/aws/sns/SnsEndpoint.java,"@@ -92,6 +107,11 @@ public void doStart() throws Exception {
             LOG.trace(""Updating the SNS region with : {} "" + configuration.getAmazonSNSEndpoint());
             snsClient.setEndpoint(configuration.getAmazonSNSEndpoint());
         }
+
+        // check the setting the headerFilterStrategy
+        if (headerFilterStrategy == null) {
+            headerFilterStrategy = new SnsHeaderFilterStrategy();","[{'comment': 'It might be better to set the the header filter strategy to be Sns from the beginning eg in the top where the instance variable is declared.', 'commenter': 'davsclaus'}, {'comment': 'That might be true, but I just copied it from the SqsEndpoint implementation. As already said, I think it should be refactored, so the duplicate code is avoided, but I did not want to make the change too big.', 'commenter': 'PeterOsudio'}]"
1514,components/camel-sjms/src/main/java/org/apache/camel/component/sjms/SjmsEndpoint.java,"@@ -98,6 +99,9 @@
     private boolean persistent = true;
     @UriParam(label = ""consumer"")
     private String durableSubscriptionId;
+    private String subscriptionId;","[{'comment': 'You need to add UriParam for these new options as well. For the new options that are on for jms2 you can move to it instead of keeping it here on the old component', 'commenter': 'davsclaus'}]"
1514,components/camel-sjms2/src/main/docs/sjms2-component.adoc,"@@ -0,0 +1,128 @@
+## Simple JMS Component
+
+*Available as of Camel version 2.19*
+
+The Simple JMS 2.0 Component is an extension of the SJMS Component that adds support for JMS 2.0 features. See the link:../../../../camel-sjms/src/main/docs/readme.html[SJMS Component] for the full list of features and documentation.
+
+Maven users will need to add the following dependency to their `pom.xml`
+for this component:
+
+[source,xml]
+----
+<dependency>
+    <groupId>org.apache.camel</groupId>
+    <artifactId>camel-sjms2</artifactId>
+    <version>x.x.x</version>
+    <!-- use the same version as your Camel core version -->
+</dependency>
+----
+
+### URI format
+
+[source]
+----
+sjms2:[queue:|topic:]destinationName[?options]
+----
+
+Where `destinationName` is a JMS queue or topic name. By default, the
+`destinationName` is interpreted as a queue name. For example, to
+connect to the queue, `FOO.BAR` use:
+
+[source]
+----
+sjms2:FOO.BAR
+----
+
+You can include the optional `queue:` prefix, if you prefer:
+
+[source]
+----
+sjms2:queue:FOO.BAR
+----
+
+To connect to a topic, you _must_ include the `topic:` prefix. For
+example, to connect to the topic, `Stocks.Prices`, use:
+
+[source]
+----
+sjms2:topic:Stocks.Prices
+----
+
+You append query options to the URI using the following format,
+`?option=value&option=value&...`
+
+### Component Options and Configurations
+
+
+
+
+// component options: START
+[NOTE]","[{'comment': 'This will be auto generated so no NOTE here', 'commenter': 'davsclaus'}, {'comment': ""A pushed up what I have but I am having trouble with the docs it doesn't look like its generating the content and they are failing validation, I am probably missing something obvious."", 'commenter': 'ryeats'}]"
1514,components/camel-sjms2/src/main/java/org/apache/camel/component/sjms2/Sjms2Component.java,"@@ -0,0 +1,41 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.sjms2;
+
+import java.util.Map;
+
+import org.apache.camel.Endpoint;
+import org.apache.camel.component.sjms.SjmsComponent;
+import org.apache.camel.component.sjms.SjmsEndpoint;
+import org.apache.camel.component.sjms2.jms.Jms2ObjectFactory;
+
+/**
+ * The <a href=""http://camel.apache.org/sjms"">Simple JMS2</a> component.
+ */
+public class Sjms2Component extends SjmsComponent {","[{'comment': 'We need a Sjms2Endpoint class as well with @UriEndpoint and all that stuff', 'commenter': 'davsclaus'}]"
1514,components/camel-sjms2/src/main/java/org/apache/camel/component/sjms2/Sjms2Component.java,"@@ -0,0 +1,41 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.sjms2;
+
+import java.util.Map;
+
+import org.apache.camel.Endpoint;
+import org.apache.camel.component.sjms.SjmsComponent;
+import org.apache.camel.component.sjms.SjmsEndpoint;
+import org.apache.camel.component.sjms2.jms.Jms2ObjectFactory;
+
+/**
+ * The <a href=""http://camel.apache.org/sjms"">Simple JMS2</a> component.
+ */
+public class Sjms2Component extends SjmsComponent {
+
+    public Sjms2Component() {
+        super(SjmsEndpoint.class);
+    }
+
+    @Override
+    protected Endpoint createEndpoint(String uri, String remaining, Map<String, Object> parameters) throws Exception {","[{'comment': 'There is a afterConfiguration method you can use instead to change the jms object factory ', 'commenter': 'davsclaus'}, {'comment': 'I had to go a different route but good to know for the future.', 'commenter': 'ryeats'}]"
1514,components/camel-sjms2/src/main/resources/META-INF/services/org/apache/camel/component/sjms2,"@@ -0,0 +1 @@
+class=org.apache.camel.component.sjms2.Sjms2Component","[{'comment': 'Need ASF license headers like the other file has', 'commenter': 'davsclaus'}]"
1514,components/camel-sjms2/src/test/resources/log4j2.properties,"@@ -0,0 +1,7 @@
+","[{'comment': 'Need ASF license header', 'commenter': 'davsclaus'}, {'comment': 'And log to file like the other does', 'commenter': 'davsclaus'}]"
1514,tooling/apt/src/main/java/org/apache/camel/tools/apt/DocumentationHelper.java,"@@ -110,6 +110,8 @@ private static File jsonFile(String scheme, String extendsScheme) {
             return new File(""../camel-ftp/target/classes/org/apache/camel/component/file/remote/ftp.json"");
         } else if (""jms"".equals(extendsScheme)) {
             return new File(""../camel-jms/target/classes/org/apache/camel/component/jms/jms.json"");
+        } else if (""sjms"".equals(extendsScheme)) {","[{'comment': ""This didn't seem to resolve my docs issue either... still looking."", 'commenter': 'ryeats'}]"
1514,components/camel-sjms2/src/main/java/org/apache/camel/component/sjms2/Sjms2Component.java,"@@ -0,0 +1,56 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.sjms2;
+
+import java.util.Map;
+
+import org.apache.camel.Endpoint;
+import org.apache.camel.component.sjms.SjmsComponent;
+import org.apache.camel.component.sjms.SjmsEndpoint;
+
+/**
+ * The <a href=""http://camel.apache.org/sjms"">Simple JMS2</a> component.
+ */
+public class Sjms2Component extends SjmsComponent {
+
+    public Sjms2Component() {
+        super(SjmsEndpoint.class);
+    }
+
+    @Override
+    protected Endpoint createEndpoint(String uri, String remaining, Map<String, Object> parameters) throws Exception {
+        validateMepAndReplyTo(parameters);
+        Sjms2Endpoint endpoint = new Sjms2Endpoint(uri, this, remaining);","[{'comment': 'It would likely be easier to create a protected method in the camel-sjms component to create the endpoint class, we do that for some other components we extend. Then this component just need to create a new Sjms2Endpoint and set the jms2 object factory and all the other configuration below is the same and done on the base class ', 'commenter': 'davsclaus'}]"
1529,camel-core/src/main/java/org/apache/camel/component/file/GenericFileProducer.java,"@@ -274,7 +274,11 @@ public void writeFile(Exchange exchange, String fileName) throws GenericFileOper
             log.trace(""About to write [{}] to [{}] from exchange [{}]"", new Object[]{fileName, getEndpoint(), exchange});
         }
 
-        boolean success = operations.storeFile(fileName, exchange);","[{'comment': 'We do NOT want changes in the core file producer. Try to make changes only to the camel-zipfile component', 'commenter': 'davsclaus'}, {'comment': 'i believe you are right. i did not want such change IMHO as well. there reason why i went there was camel-zipfile was passing either ZipIterator or Outputstream to producer. For the case in the issue, iterator usage is required for Splitter EIP and Message is created with FILENAME header and conveyed to producer and core file producer does all the thing like creating directories and and files on the producer endpoint. What i did in camel-zipfile component to create a Message with FILENAME header <path> + ""."" which only indicated the target empty directory to be created. And core file producer already does manupulation like creating paths and files on producer endpoint. I just added a simple condition to bypass storeFile method call and directory creation for empty folders is OK. that was the purpose. I have not come up with an easier solution  and i did not feel like i would do something dirty on core file producer, therefore, i chose that path. If this does not make any sense, i can close the PR. ', 'commenter': 'onderson'}, {'comment': 'Yeah then please close', 'commenter': 'davsclaus'}]"
1529,components/camel-zipfile/src/main/java/org/apache/camel/dataformat/zipfile/ZipFileDataFormat.java,"@@ -72,6 +73,11 @@ public void marshal(final Exchange exchange, final Object graph, final OutputStr
 
     @Override
     public Object unmarshal(final Exchange exchange, final InputStream inputStream) throws Exception {
+        if (supportEmptyDirectory) {","[{'comment': 'Maybe a single line will be more beautiful :)\r\nexchange.getIn().setHeader(""unzipEmptyDirectorySupported"", isSupportEmptyDirectory());', 'commenter': 'zhurlik'}]"
1529,components/camel-zipfile/src/test/java/org/apache/camel/dataformat/zipfile/ZipFileDataFormatTest.java,"@@ -187,6 +217,35 @@ public void setUp() throws Exception {
         deleteDirectory(TEST_DIR);
         super.setUp();
     }
+    ","[{'comment': 'try-with-resources will simplify this code:\r\n\r\n`\r\n    private static void copy(File file, OutputStream out) throws IOException {\r\n        try (InputStream in = new FileInputStream(file)) {\r\n            copy(in, out);\r\n        }\r\n    }\r\n`\r\n\r\n`\r\n    private static void copy(InputStream in, File file) throws IOException {\r\n        try (OutputStream out = new FileOutputStream(file)) {\r\n            copy(in, out);\r\n        }\r\n    }\r\n`', 'commenter': 'zhurlik'}, {'comment': 'i am a bit old fashioned. fine suggestion. i did your way', 'commenter': 'onderson'}]"
1529,components/camel-zipfile/src/main/java/org/apache/camel/dataformat/zipfile/ZipFileDataFormat.java,"@@ -72,6 +73,7 @@ public void marshal(final Exchange exchange, final Object graph, final OutputStr
 
     @Override
     public Object unmarshal(final Exchange exchange, final InputStream inputStream) throws Exception {
+        exchange.getIn().setHeader(""unzipEmptyDirectorySupported"", isSupportEmptyDirectory());
         if (usingIterator) {
             return new ZipIterator(exchange.getIn());","[{'comment': 'Do not use a Camel message header for this, but set the option on the iterator using getter/setter\r\n\r\n    ZipIterator it = new ...\r\n    it.setUnzipEmptyDirectory(...)\r\n', 'commenter': 'davsclaus'}]"
1529,components/camel-zipfile/src/main/java/org/apache/camel/dataformat/zipfile/ZipFileDataFormat.java,"@@ -39,6 +39,7 @@
  */
 public class ZipFileDataFormat extends ServiceSupport implements DataFormat, DataFormatName {
     private boolean usingIterator;
+    private boolean supportIteratorForEmptyDirectory;","[{'comment': ""Can we rename this to `allowEmptyDirectory' to make it shorter and use similar name we have done for other such option"", 'commenter': 'davsclaus'}]"
1544,components/camel-rest-swagger/pom.xml,"@@ -0,0 +1,175 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--
+  Licensed to the Apache Software Foundation (ASF) under one or more
+  contributor license agreements.  See the NOTICE file distributed with
+  this work for additional information regarding copyright ownership.
+  The ASF licenses this file to You under the Apache License, Version 2.0
+  (the ""License""); you may not use this file except in compliance with
+  the License.  You may obtain a copy of the License at
+
+  http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an ""AS IS"" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
+  xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>org.apache.camel</groupId>
+    <artifactId>components</artifactId>
+    <version>2.19.0-SNAPSHOT</version>
+  </parent>
+
+  <artifactId>camel-rest-swagger</artifactId>
+
+  <name>Camel :: REST Swagger</name>
+  <description>Camel REST support using Swagger</description>
+
+  <properties>
+    <firstVersion>2.19.0</firstVersion>
+    <label>rest,api,http</label>
+    <camel.osgi.export.pkg>org.apache.camel.component.rest.swagger.*</camel.osgi.export.pkg>
+    <camel.osgi.export.service>org.apache.camel.spi.ComponentResolver;component=rest-swagger</camel.osgi.export.service>
+  </properties>
+
+  <dependencies>
+
+    <dependency>
+      <groupId>org.apache.camel</groupId>
+      <artifactId>camel-core</artifactId>
+    </dependency>
+
+    <dependency>
+      <groupId>io.swagger</groupId>
+      <artifactId>swagger-parser</artifactId>
+      <version>${swagger-java-parser-version}</version>
+      <exclusions>
+        <!--
+        Trying to keep transitive dependencies only to required ones.
+        -->
+        <exclusion>
+          <groupId>com.google.guava</groupId>
+          <artifactId>guava</artifactId>
+        </exclusion>
+        <exclusion>
+          <groupId>org.slf4j</groupId>
+          <artifactId>slf4j-ext</artifactId>
+        </exclusion>
+        <exclusion>
+          <groupId>io.swagger</groupId>
+          <artifactId>swagger-annotations</artifactId>
+        </exclusion>
+        <exclusion>
+          <groupId>javax.validation</groupId>
+          <artifactId>validation-api</artifactId>
+        </exclusion>
+      </exclusions>
+    </dependency>
+
+    <!-- test -->
+    <dependency>
+      <groupId>org.apache.camel</groupId>
+      <artifactId>camel-test</artifactId>
+      <scope>test</scope>
+    </dependency>
+
+    <dependency>
+      <groupId>junit</groupId>
+      <artifactId>junit</artifactId>
+      <scope>test</scope>
+    </dependency>
+
+    <dependency>
+      <groupId>org.mockito</groupId>
+      <artifactId>mockito-core</artifactId>
+      <scope>test</scope>
+    </dependency>
+
+    <dependency>
+      <groupId>org.assertj</groupId>
+      <artifactId>assertj-core</artifactId>
+      <version>3.6.2</version>","[{'comment': 'We have the versions in the parent/pom.xml file', 'commenter': 'davsclaus'}]"
1544,components/camel-rest-swagger/src/main/docs/rest-swagger-component.adoc,"@@ -0,0 +1,207 @@
+## REST Swagger Component
+
+*Available as of Camel version 2.19*
+
+
+// Licensed to the Apache Software Foundation (ASF) under one or more","[{'comment': 'Remove this LIC', 'commenter': 'davsclaus'}]"
1544,examples/camel-example-rest-swagger/pom.xml,"@@ -0,0 +1,102 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--
+    Licensed to the Apache Software Foundation (ASF) under one or more
+    contributor license agreements.  See the NOTICE file distributed with
+    this work for additional information regarding copyright ownership.
+    The ASF licenses this file to You under the Apache License, Version 2.0
+    (the ""License""); you may not use this file except in compliance with
+    the License.  You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an ""AS IS"" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
+  xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>org.apache.camel</groupId>
+    <artifactId>examples</artifactId>
+    <version>2.19.0-SNAPSHOT</version>
+  </parent>
+
+  <artifactId>camel-example-rest-swagger</artifactId>
+  <name>Camel :: Example :: REST Swagger</name>
+  <version>2.19.0-SNAPSHOT</version>
+
+  <properties>
+    <category>Beginner</category>
+
+    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
+    <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
+    <spring.boot-version>1.5.1.RELEASE</spring.boot-version>","[{'comment': 'Dont we use the spring boot version from parent/pom in the other examples?', 'commenter': 'davsclaus'}]"
1544,components/camel-rest-swagger/src/main/java/org/apache/camel/component/rest/swagger/RestSwaggerEndpoint.java,"@@ -0,0 +1,490 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.rest.swagger;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.URI;
+import java.net.URISyntaxException;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Map.Entry;
+import java.util.Optional;
+import java.util.stream.Collectors;
+
+import static java.util.Optional.ofNullable;
+
+import com.fasterxml.jackson.databind.JsonNode;
+import com.fasterxml.jackson.databind.ObjectMapper;
+
+import io.swagger.models.HttpMethod;
+import io.swagger.models.Operation;
+import io.swagger.models.Path;
+import io.swagger.models.Scheme;
+import io.swagger.models.Swagger;
+import io.swagger.parser.SwaggerParser;
+import io.swagger.util.Json;
+
+import org.apache.camel.CamelContext;
+import org.apache.camel.Consumer;
+import org.apache.camel.Endpoint;
+import org.apache.camel.ExchangePattern;
+import org.apache.camel.Processor;
+import org.apache.camel.Producer;
+import org.apache.camel.impl.DefaultEndpoint;
+import org.apache.camel.spi.Metadata;
+import org.apache.camel.spi.RestConfiguration;
+import org.apache.camel.spi.UriEndpoint;
+import org.apache.camel.spi.UriParam;
+import org.apache.camel.spi.UriPath;
+import org.apache.camel.util.ResourceHelper;
+
+import static org.apache.camel.component.rest.swagger.RestSwaggerHelper.isHostParam;
+import static org.apache.camel.component.rest.swagger.RestSwaggerHelper.isMediaRange;
+import static org.apache.camel.util.ObjectHelper.isNotEmpty;
+import static org.apache.camel.util.ObjectHelper.notNull;
+import static org.apache.camel.util.StringHelper.after;
+import static org.apache.camel.util.StringHelper.before;
+import static org.apache.camel.util.StringHelper.notEmpty;
+
+/**
+ * An awesome REST endpoint backed by Swagger specifications.
+ */
+@UriEndpoint(firstVersion = ""2.19.0"", scheme = ""rest-swagger"", title = ""REST Swagger"",
+    syntax = ""rest-swagger:[specificationUri#]operationId"", label = ""rest,swagger,http"", producerOnly = true)","[{'comment': 'The syntax must not have [ ] etc it should be `rest-swagger:specificationUri#operationId`. You cannot use [] to denote optional. The syntax is tooling driven.', 'commenter': 'davsclaus'}]"
1544,components/camel-rest-swagger/src/main/docs/rest-swagger-component.adoc,"@@ -0,0 +1,207 @@
+## REST Swagger Component
+
+*Available as of Camel version 2.19*
+
+
+// Licensed to the Apache Software Foundation (ASF) under one or more
+// contributor license agreements.  See the NOTICE file distributed with
+// this work for additional information regarding copyright ownership.
+// The ASF licenses this file to You under the Apache License, Version 2.0
+// (the ""License""); you may not use this file except in compliance with
+// the License.  You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an ""AS IS"" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+
+The *rest-swagger* configures rest Consumers from ","[{'comment': 'The component is producer only in camel - so this is a bit confusing when you say it can consume also', 'commenter': 'davsclaus'}]"
1544,components/camel-rest-swagger/src/main/java/org/apache/camel/component/rest/swagger/RestSwaggerComponent.java,"@@ -0,0 +1,191 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.rest.swagger;
+
+import java.net.URI;
+import java.util.Map;
+
+import org.apache.camel.CamelContext;
+import org.apache.camel.Endpoint;
+import org.apache.camel.impl.DefaultComponent;
+import org.apache.camel.spi.Metadata;
+import org.apache.camel.spi.RestProducerFactory;
+
+import static org.apache.camel.component.rest.swagger.RestSwaggerHelper.isHostParam;
+import static org.apache.camel.component.rest.swagger.RestSwaggerHelper.isMediaRange;
+import static org.apache.camel.util.ObjectHelper.notNull;
+import static org.apache.camel.util.StringHelper.notEmpty;
+
+/**
+ * An awesome REST component backed by Swagger specifications. Creates endpoints
+ * that connect to REST APIs defined by Swagger specification. This component
+ * delegates to other {@link RestProducerFactory} components to act as REST
+ * clients, but it configures them from Swagger specification. Client needs to
+ * point to operation that it wants to invoke via REST, provide any additional
+ * HTTP headers as headers in the Camel message, and any payload as the body of
+ * the incoming message.
+ * <p>
+ * Example usage using Java DSL:
+ * <p>
+ *
+ * <pre>
+ * from(""rest-swagger:http://petstore.swagger.io/v2/swagger.json#getPetById"").to(...)
+ * </pre>
+ *
+ * This relies on only one {@link RestProducerFactory} component being available
+ * to Camel, you can use specific, for instance preconfigured component by using
+ * the {@code componentName} endpoint property. For example using Undertow
+ * component in Java DSL:
+ * <p>
+ *
+ * <pre>
+ * Component undertow = new UndertowComponent();
+ * undertow.setSslContextParameters(...);
+ * //...
+ * camelContext.addComponent(""myUndertow"", undertow);
+ *
+ * from(""rest-swagger:http://petstore.swagger.io/v2/swagger.json#getPetById?componentName=myUndertow"").to(...)","[{'comment': 'Was it not producer only ?', 'commenter': 'davsclaus'}]"
1552,components/camel-opentracing/src/main/resources/otagent/apache-camel.btm,"@@ -0,0 +1,16 @@
+","[{'comment': ""We don't use log4j.properties on component level, but using it for tests but the format must be the same with other ones"", 'commenter': 'dmvolod'}]"
1552,components/camel-opentracing/src/test/java/org/apache/camel/opentracing/agent/InstallOpenTracingTracerRuleTest.java,"@@ -0,0 +1,98 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.opentracing.agent;
+
+import java.util.List;
+
+import io.opentracing.contrib.global.GlobalTracer;
+import io.opentracing.mock.MockSpan;
+import io.opentracing.mock.MockTracer;
+import io.opentracing.mock.MockTracer.Propagator;
+import io.opentracing.tag.Tags;
+
+import org.apache.camel.EndpointInject;
+import org.apache.camel.Produce;
+import org.apache.camel.ProducerTemplate;
+import org.apache.camel.builder.RouteBuilder;
+import org.apache.camel.component.mock.MockEndpoint;
+import org.apache.camel.test.junit4.CamelTestSupport;
+import org.junit.Before;
+import org.junit.BeforeClass;
+import org.junit.Test;
+
+/**
+ * @author gbrown","[{'comment': 'We dont have author tags in javadoc, would you kindly remove this', 'commenter': 'davsclaus'}]"
1583,camel-core/src/main/java/org/apache/camel/util/EndpointHelper.java,"@@ -363,8 +356,10 @@ public static boolean isReferenceParameter(String parameter) {
                 // The bean is a list
                 return (List) bean;
             } else {
-                // The bean is a list element
-                return Arrays.asList(elementType.cast(bean));
+            	// The bean is a list element","[{'comment': 'There seems to be a tab character here, so the Checkstyle check fails with:\r\n\r\n    camel-core/src/main/java/org/apache/camel/util/EndpointHelper.java:359:13: File contains tab characters (this is the first instance). [FileTabCharacter]\r\n\r\nCan you fix that? You can check with:\r\n\r\n    mvn -Psourcecheck verify', 'commenter': 'zregvart'}, {'comment': 'i am not sure why this is happening. I guess something is wrong with my checkstyle plugin on eclipse. cs fix will be coming soon. sorry about that.', 'commenter': 'onderson'}]"
1589,components/camel-soap/src/main/java/org/apache/camel/dataformat/soap/Soap11DataFormatAdapter.java,"@@ -199,8 +199,18 @@ private Exception createExceptionFromFault(Fault fault) {
                 throw new RuntimeCamelException(e);
             }
         }
+
+	Object detailObj = faultDetail.getAny().get(0);","[{'comment': ""There's a tab character here, we have a spaces policy, you can run source checks from Maven:\r\n\r\n    $ cd components/camel-soap; mvn -Psourcecheck clean verify\r\n\r\nThis is what I get now:\r\n\r\n    ...\r\n    [INFO] --- maven-checkstyle-plugin:2.17:checkstyle (validate) @ camel-soap ---\r\n    [INFO] Starting audit...\r\n    [ERROR] /home/zregvart/workspaces/camel/camel/components/camel-soap/src/main/java/org/apache/camel/dataformat/soap/Soap11DataFormatAdapter.java:203:1: File contains tab characters (this is the first instance). [FileTabCharacter]\r\n    Audit done.\r\n    ...\r\n"", 'commenter': 'zregvart'}]"
1589,components/camel-soap/src/main/java/org/apache/camel/dataformat/soap/Soap11DataFormatAdapter.java,"@@ -199,8 +199,18 @@ private Exception createExceptionFromFault(Fault fault) {
                 throw new RuntimeCamelException(e);
             }
         }
+
+	Object detailObj = faultDetail.getAny().get(0);
+
+        if (!JAXBIntrospector.isElement(detailObj)) {","[{'comment': 'This does not compile, `JAXBIntrospector.isElement` cannot be referenced as a static method, see [javadoc](https://docs.oracle.com/javaee/7/api/javax/xml/bind/JAXBIntrospector.html#isElement-java.lang.Object-).', 'commenter': 'zregvart'}, {'comment': 'Sorry - wrote this in a rush this morning and found that method. Will clean it up', 'commenter': 'linead'}]"
1611,components/camel-milo/src/main/docs/milo-server.adoc,"@@ -0,0 +1,111 @@
+[[MiloServer-OpcUaServerComponent]]
+
+Eclipse Milo Server Component
+~~~~~~~~~~~~~~~~~~~~~~~
+
+*Available as of Camel 2.18*","[{'comment': 'since Camel 2.18? it is commited on 2.19.0 branch, sure?', 'commenter': 'apupier'}, {'comment': 'True.', 'commenter': 'ctron'}, {'comment': 'And fixed.', 'commenter': 'ctron'}]"
1611,components/camel-milo/pom.xml,"@@ -0,0 +1,104 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--
+  Licensed to the Apache Software Foundation (ASF) under one or more
+  contributor license agreements.  See the NOTICE file distributed with
+  this work for additional information regarding copyright ownership.
+  The ASF licenses this file to You under the Apache License, Version 2.0
+  (the ""License""); you may not use this file except in compliance with
+  the License.  You may obtain a copy of the License at
+
+  http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an ""AS IS"" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+    <modelVersion>4.0.0</modelVersion>
+
+    <parent>
+        <groupId>org.apache.camel</groupId>
+        <artifactId>components</artifactId>
+        <version>2.19.0-SNAPSHOT</version>
+    </parent>
+
+    <artifactId>camel-milo</artifactId>
+    <packaging>jar</packaging>
+    <name>Camel :: Milo</name>
+    <description>Camel OPC UA support</description>
+
+    <properties>
+        <camel.osgi.export.pkg>
+            !*.internal.*,
+            org.apache.camel.component.milo.*
+        </camel.osgi.export.pkg>
+        <camel.osgi.import.before.defaults>
+            com.google.common.*;version=""19.0.0""","[{'comment': 'Must it be this precise, what if its 19.0.1 etc? Is not better to use some kind of version range?', 'commenter': 'davsclaus'}, {'comment': 'That should actually resolve to ""bigger than 19.0.0"" but there is no upper limit for this as google does not do semantic versioning as OSGi does. Be default this would generate a package import of ""bigger than 19.0.0 but smaller than 20.0.0"" And this would resolve to exactly on version of guava.', 'commenter': 'ctron'}, {'comment': 'Here is an explanation by @njbartlett :  http://stackoverflow.com/a/8354987/222044', 'commenter': 'ctron'}]"
1611,components/camel-milo/src/main/java/org/apache/camel/component/milo/client/MiloClientConfiguration.java,"@@ -0,0 +1,292 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.milo.client;
+
+import java.net.MalformedURLException;
+import java.net.URL;
+
+import org.apache.camel.component.milo.KeyStoreLoader;
+import org.apache.camel.spi.UriParam;
+import org.apache.camel.spi.UriParams;
+
+@UriParams
+public class MiloClientConfiguration implements Cloneable {
+
+	private static final String DEFAULT_APPLICATION_URI = ""http://camel.apache.org/EclipseMilo/Client"";
+
+	private static final String DEFAULT_APPLICATION_NAME = ""Apache Camel adapter for Eclipse Milo"";
+
+	private static final String DEFAULT_PRODUCT_URI = ""http://camel.apache.org/EclipseMilo"";
+
+	private String endpointUri;
+
+	@UriParam
+	private String clientId;
+
+	@UriParam(label = ""client"", defaultValue = DEFAULT_APPLICATION_NAME)
+	private String applicationName = DEFAULT_APPLICATION_NAME;
+
+	@UriParam(label = ""client"", defaultValue = DEFAULT_APPLICATION_URI)
+	private String applicationUri = DEFAULT_APPLICATION_URI;
+
+	@UriParam(label = ""client"", defaultValue = DEFAULT_PRODUCT_URI)
+	private String productUri = DEFAULT_PRODUCT_URI;
+
+	@UriParam(label = ""client"")
+	private Long requestTimeout;
+
+	@UriParam(label = ""client"")
+	private Long channelLifetime;
+
+	@UriParam(label = ""client"")
+	private String sessionName;
+
+	@UriParam(label = ""client"")
+	private Long sessionTimeout;
+
+	@UriParam(label = ""client"")
+	private Long maxPendingPublishRequests;
+
+	@UriParam(label = ""client"")
+	private Long maxResponseMessageSize;
+
+	@UriParam(label = ""client"")
+	private Boolean secureChannelReauthenticationEnabled;
+
+	@UriParam(label = ""client"")
+	private URL keyStoreUrl;
+
+	@UriParam(label = ""client"")
+	private String keyStoreType = KeyStoreLoader.DEFAULT_KEY_STORE_TYPE;
+
+	@UriParam(label = ""client"")
+	private String keyAlias;
+
+	@UriParam(label = ""client"")","[{'comment': 'secret = true for sensitive options. Also for password etc', 'commenter': 'davsclaus'}]"
1611,components/camel-milo/src/main/java/org/apache/camel/component/milo/client/MiloClientEndpoint.java,"@@ -0,0 +1,242 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.milo.client;
+
+import static org.eclipse.milo.opcua.stack.core.types.builtin.unsigned.Unsigned.ushort;
+
+import java.util.Objects;
+
+import org.apache.camel.Consumer;
+import org.apache.camel.Processor;
+import org.apache.camel.Producer;
+import org.apache.camel.component.milo.NamespaceId;
+import org.apache.camel.component.milo.PartialNodeId;
+import org.apache.camel.impl.DefaultEndpoint;
+import org.apache.camel.spi.Metadata;
+import org.apache.camel.spi.UriEndpoint;
+import org.apache.camel.spi.UriParam;
+import org.apache.camel.spi.UriPath;
+import org.eclipse.milo.opcua.stack.core.types.builtin.ExpandedNodeId;
+
+@UriEndpoint(scheme = ""milo-client"", syntax = ""milo-client:tcp://user:password@host:port/path/to/service?itemId=item.id&namespaceUri=urn:foo:bar"", title = ""Milo based OPC UA Client"", consumerClass = MiloClientConsumer.class, label = ""iot"")","[{'comment': 'The syntax should NOT be like that, I will fix that later as it refers to the names of the options, and no query parameters ', 'commenter': 'davsclaus'}]"
1611,components/camel-milo/src/main/java/org/apache/camel/component/milo/client/MiloClientEndpoint.java,"@@ -0,0 +1,242 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.milo.client;
+
+import static org.eclipse.milo.opcua.stack.core.types.builtin.unsigned.Unsigned.ushort;
+
+import java.util.Objects;
+
+import org.apache.camel.Consumer;
+import org.apache.camel.Processor;
+import org.apache.camel.Producer;
+import org.apache.camel.component.milo.NamespaceId;
+import org.apache.camel.component.milo.PartialNodeId;
+import org.apache.camel.impl.DefaultEndpoint;
+import org.apache.camel.spi.Metadata;
+import org.apache.camel.spi.UriEndpoint;
+import org.apache.camel.spi.UriParam;
+import org.apache.camel.spi.UriPath;
+import org.eclipse.milo.opcua.stack.core.types.builtin.ExpandedNodeId;
+
+@UriEndpoint(scheme = ""milo-client"", syntax = ""milo-client:tcp://user:password@host:port/path/to/service?itemId=item.id&namespaceUri=urn:foo:bar"", title = ""Milo based OPC UA Client"", consumerClass = MiloClientConsumer.class, label = ""iot"")
+public class MiloClientEndpoint extends DefaultEndpoint implements MiloClientItemConfiguration {
+
+	/**
+	 * The OPC UA server endpoint
+	 */
+	@UriPath
+	@Metadata(required = ""true"")
+	private final String endpointUri;
+
+	/**
+	 * The node ID as string ID **deprecated**
+	 *
+	 * @deprecated Use ""node"" instead
+	 */
+	@UriParam","[{'comment': 'Remove deprecated as this is a new camel component so we dont have old stuff from the beginning', 'commenter': 'davsclaus'}]"
1611,components/camel-milo/src/main/java/org/apache/camel/component/milo/server/MiloServerEndpoint.java,"@@ -0,0 +1,106 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.milo.server;
+
+import org.apache.camel.Component;
+import org.apache.camel.Consumer;
+import org.apache.camel.Processor;
+import org.apache.camel.Producer;
+import org.apache.camel.component.milo.server.internal.CamelNamespace;
+import org.apache.camel.component.milo.server.internal.CamelServerItem;
+import org.apache.camel.impl.DefaultEndpoint;
+import org.apache.camel.spi.Metadata;
+import org.apache.camel.spi.UriEndpoint;
+import org.apache.camel.spi.UriPath;
+
+/**
+ * OPC UA Server based endpoint
+ */
+@UriEndpoint(scheme = ""milo-server"", syntax = ""milo-server:itemId[?options]"", title = ""OPC UA Server"", consumerClass = MiloServerConsumer.class, label = ""iot"")","[{'comment': 'No query parameters in syntax', 'commenter': 'davsclaus'}]"
1617,components/camel-pubnub/src/main/java/org/apache/camel/component/pubnub/PubNubConsumer.java,"@@ -0,0 +1,139 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.pubnub;
+
+
+import java.util.Arrays;
+
+import com.pubnub.api.PubNub;
+import com.pubnub.api.callbacks.SubscribeCallback;
+import com.pubnub.api.models.consumer.PNStatus;
+import com.pubnub.api.models.consumer.pubsub.PNMessageResult;
+import com.pubnub.api.models.consumer.pubsub.PNPresenceEventResult;
+
+import org.apache.camel.Exchange;
+import org.apache.camel.Message;
+import org.apache.camel.Processor;
+import org.apache.camel.impl.DefaultConsumer;
+import org.apache.camel.impl.DefaultExchange;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import static com.pubnub.api.enums.PNStatusCategory.PNTimeoutCategory;
+import static com.pubnub.api.enums.PNStatusCategory.PNUnexpectedDisconnectCategory;
+
+import static org.apache.camel.component.pubnub.PubNubConstants.CHANNEL;
+import static org.apache.camel.component.pubnub.PubNubConstants.TIMETOKEN;
+
+public class PubNubConsumer extends DefaultConsumer {
+    private static final Logger LOG = LoggerFactory.getLogger(PubNubConsumer.class);
+    private final PubNubEndpoint endpoint;
+    private final PubNubConfiguration pubNubConfiguration;
+
+    public PubNubConsumer(PubNubEndpoint endpoint, Processor processor, PubNubConfiguration pubNubConfiguration) {
+        super(endpoint, processor);
+        this.endpoint = endpoint;
+        this.pubNubConfiguration = pubNubConfiguration;
+    }
+
+    private void initCommunication() throws Exception {
+        endpoint.getPubnub().addListener(new PubNubCallback());
+        if (pubNubConfiguration.withPresence()) {
+            endpoint.getPubnub().subscribe().channels(Arrays.asList(pubNubConfiguration.getChannel())).withPresence().execute();
+        } else {
+            endpoint.getPubnub().subscribe().channels(Arrays.asList(pubNubConfiguration.getChannel())).execute();
+        }
+    }
+
+    private void terminateCommunication() {
+        try {
+            endpoint.getPubnub().unsubscribe().channels(Arrays.asList(pubNubConfiguration.getChannel())).execute();
+        } catch (Exception e) {
+            // ignore
+        }
+    }
+
+    @Override
+    protected void doStart() throws Exception {
+        super.doStart();
+        initCommunication();
+    }
+
+    @Override
+    protected void doResume() throws Exception {
+        super.doResume();
+        initCommunication();
+    }
+
+    @Override
+    protected void doStop() throws Exception {
+        terminateCommunication();
+        super.doStop();
+    }
+
+    @Override
+    protected void doSuspend() throws Exception {
+        terminateCommunication();
+        super.doSuspend();
+    }
+
+    class PubNubCallback extends SubscribeCallback {
+
+        @Override
+        public void status(PubNub pubnub, PNStatus status) {
+            if (status.getCategory() == PNUnexpectedDisconnectCategory || status.getCategory() == PNTimeoutCategory) {
+                LOG.trace(""Got status : {}. Reconnecting to PubNub"", status);
+                pubnub.reconnect();
+            } else {
+                LOG.trace(""Status message : {}"", status);
+            }
+        }
+
+        @Override
+        public void message(PubNub pubnub, PNMessageResult message) {
+            Exchange exchange = new DefaultExchange(endpoint, endpoint.getExchangePattern());","[{'comment': 'Favor creating the exchange from the endpoint, eg endpoint.createExchange(...)', 'commenter': 'davsclaus'}]"
1617,components/camel-pubnub/src/main/java/org/apache/camel/component/pubnub/PubNubConfiguration.java,"@@ -0,0 +1,178 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.pubnub;
+
+
+import org.apache.camel.spi.Metadata;
+import org.apache.camel.spi.UriParam;
+import org.apache.camel.spi.UriParams;
+import org.apache.camel.spi.UriPath;
+
+@UriParams
+public class PubNubConfiguration {
+
+    @UriPath()
+    @Metadata(required = ""true"")
+    private String channel;
+
+    @UriParam(label = ""security"", secret = true)
+    private String publishKey;
+
+    @UriParam(label = ""security"", secret = true)
+    private String subscribeKey;
+
+    @UriParam(label = ""security"", secret = true)
+    private String secretKey;
+
+    @UriParam(label = ""security"", secret = true)
+    private String authKey;
+
+    @UriParam(label = ""security"", secret = true)
+    private String cipherKey;
+
+    @UriParam(defaultValue = ""true"")","[{'comment': 'should have label=security', 'commenter': 'davsclaus'}]"
1617,components/camel-pubnub/src/main/java/org/apache/camel/component/pubnub/PubNubConfiguration.java,"@@ -0,0 +1,178 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.pubnub;
+
+
+import org.apache.camel.spi.Metadata;
+import org.apache.camel.spi.UriParam;
+import org.apache.camel.spi.UriParams;
+import org.apache.camel.spi.UriPath;
+
+@UriParams
+public class PubNubConfiguration {
+
+    @UriPath()
+    @Metadata(required = ""true"")
+    private String channel;
+
+    @UriParam(label = ""security"", secret = true)
+    private String publishKey;
+
+    @UriParam(label = ""security"", secret = true)
+    private String subscribeKey;
+
+    @UriParam(label = ""security"", secret = true)
+    private String secretKey;
+
+    @UriParam(label = ""security"", secret = true)
+    private String authKey;
+
+    @UriParam(label = ""security"", secret = true)
+    private String cipherKey;
+
+    @UriParam(defaultValue = ""true"")
+    private boolean secure = true;
+
+    @UriParam()
+    private String uuid;
+
+    @UriParam(label = ""producer"", enums = ""HERENOW,WHERENOW,GETSTATE,SETSTATE,GETHISTORY,PUBLISH,FIRE"")
+    private String operation;
+
+    @UriParam(label = ""consumer"", defaultValue = ""false"")
+    private boolean withPresence;
+
+    /**
+     * The publish key obtained from your PubNub account. Required when publishing messages.
+     */
+    public String getPublishKey() {
+        return this.publishKey;
+    }
+
+    public void setPublishKey(String publishKey) {
+        this.publishKey = publishKey;
+    }
+
+    /**
+     * The subscribe key obtained from your PubNub account. Required when subscribing to channels or listening for presence events
+     */
+    public String getSubscribeKey() {
+        return this.subscribeKey;
+    }
+
+    public void setSubscribeKey(String subscribeKey) {
+        this.subscribeKey = subscribeKey;
+    }
+
+    /**
+     * The secret key used for message signing.
+     */
+    public String getSecretKey() {
+        return this.secretKey;
+    }
+
+    public void setSecretKey(String secretKey) {
+        this.secretKey = secretKey;
+    }
+
+    /**
+     * If Access Manager is utilized, client will use this authKey in all restricted requests.
+     */
+    public String getAuthKey() {
+        return authKey;
+    }
+
+    public void setAuthKey(String authKey) {
+        this.authKey = authKey;
+    }
+
+    /**
+     * If cipher is passed, all communicatons to/from PubNub will be encrypted.
+     */
+    public String getCipherKey() {
+        return cipherKey;
+    }
+
+    public void setCipherKey(String cipherKey) {
+        this.cipherKey = cipherKey;
+    }
+
+    /**
+     * Use ssl","[{'comment': 'Can you add a bit more documentation than just use ssl', 'commenter': 'davsclaus'}]"
1617,components/camel-pubnub/src/main/java/org/apache/camel/component/pubnub/PubNubEndpoint.java,"@@ -0,0 +1,108 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.pubnub;
+
+
+import com.pubnub.api.PNConfiguration;
+import com.pubnub.api.PubNub;
+
+import org.apache.camel.Consumer;
+import org.apache.camel.Processor;
+import org.apache.camel.Producer;
+import org.apache.camel.impl.DefaultEndpoint;
+import org.apache.camel.spi.UriEndpoint;
+import org.apache.camel.spi.UriParam;
+import org.apache.camel.util.ObjectHelper;
+
+@UriEndpoint(scheme = ""pubnub"", title = ""PubNub"", syntax = ""pubnub://channel"", consumerClass = PubNubConsumer.class, label = ""cloud,iot,messaging"")","[{'comment': 'syntax should just be pubnub:channel', 'commenter': 'davsclaus'}]"
1617,components/camel-pubnub/src/main/java/org/apache/camel/component/pubnub/PubNubEndpoint.java,"@@ -0,0 +1,108 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.pubnub;
+
+
+import com.pubnub.api.PNConfiguration;
+import com.pubnub.api.PubNub;
+
+import org.apache.camel.Consumer;
+import org.apache.camel.Processor;
+import org.apache.camel.Producer;
+import org.apache.camel.impl.DefaultEndpoint;
+import org.apache.camel.spi.UriEndpoint;
+import org.apache.camel.spi.UriParam;
+import org.apache.camel.util.ObjectHelper;
+
+@UriEndpoint(scheme = ""pubnub"", title = ""PubNub"", syntax = ""pubnub://channel"", consumerClass = PubNubConsumer.class, label = ""cloud,iot,messaging"")
+public class PubNubEndpoint extends DefaultEndpoint {
+
+    @UriParam
+    private PubNub pubnub;
+
+    @UriParam
+    private PubNubConfiguration configuration;
+
+    public PubNubEndpoint(String uri, PubNubComponent component, PubNubConfiguration configuration) {
+        super(uri, component);
+        this.configuration = configuration;
+    }
+","[{'comment': 'remove extra empty lines', 'commenter': 'davsclaus'}]"
1617,components/camel-pubnub/src/main/java/org/apache/camel/component/pubnub/PubNubEndpoint.java,"@@ -0,0 +1,108 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.pubnub;
+
+
+import com.pubnub.api.PNConfiguration;
+import com.pubnub.api.PubNub;
+
+import org.apache.camel.Consumer;
+import org.apache.camel.Processor;
+import org.apache.camel.Producer;
+import org.apache.camel.impl.DefaultEndpoint;
+import org.apache.camel.spi.UriEndpoint;
+import org.apache.camel.spi.UriParam;
+import org.apache.camel.util.ObjectHelper;
+
+@UriEndpoint(scheme = ""pubnub"", title = ""PubNub"", syntax = ""pubnub://channel"", consumerClass = PubNubConsumer.class, label = ""cloud,iot,messaging"")
+public class PubNubEndpoint extends DefaultEndpoint {
+
+    @UriParam
+    private PubNub pubnub;
+
+    @UriParam
+    private PubNubConfiguration configuration;
+
+    public PubNubEndpoint(String uri, PubNubComponent component, PubNubConfiguration configuration) {
+        super(uri, component);
+        this.configuration = configuration;
+    }
+
+    
+
+    @Override
+    public Producer createProducer() throws Exception {
+        return new PubNubProducer(this, configuration);
+    }
+
+    @Override
+    public Consumer createConsumer(Processor processor) throws Exception {
+        return new PubNubConsumer(this, processor, configuration);
+    }
+
+    @Override
+    public boolean isSingleton() {
+        return true;
+    }
+
+    public PubNubConfiguration getConfiguration() {
+        return configuration;
+    }
+
+    /**
+     * Reference to a Pubnub client in the registry.
+     */
+","[{'comment': 'remove empty line', 'commenter': 'davsclaus'}]"
1617,components/camel-pubnub/src/main/java/org/apache/camel/component/pubnub/PubNubEndpoint.java,"@@ -0,0 +1,108 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.pubnub;
+
+
+import com.pubnub.api.PNConfiguration;
+import com.pubnub.api.PubNub;
+
+import org.apache.camel.Consumer;
+import org.apache.camel.Processor;
+import org.apache.camel.Producer;
+import org.apache.camel.impl.DefaultEndpoint;
+import org.apache.camel.spi.UriEndpoint;
+import org.apache.camel.spi.UriParam;
+import org.apache.camel.util.ObjectHelper;
+
+@UriEndpoint(scheme = ""pubnub"", title = ""PubNub"", syntax = ""pubnub://channel"", consumerClass = PubNubConsumer.class, label = ""cloud,iot,messaging"")
+public class PubNubEndpoint extends DefaultEndpoint {
+
+    @UriParam","[{'comment': 'label = advanced as this is not a common option to use', 'commenter': 'davsclaus'}]"
1617,components/camel-pubnub/src/main/java/org/apache/camel/component/pubnub/PubNubProducer.java,"@@ -0,0 +1,261 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.pubnub;
+
+import java.util.Arrays;
+
+import com.pubnub.api.PubNubException;
+import com.pubnub.api.callbacks.PNCallback;
+import com.pubnub.api.models.consumer.PNPublishResult;
+import com.pubnub.api.models.consumer.PNStatus;
+import com.pubnub.api.models.consumer.history.PNHistoryResult;
+import com.pubnub.api.models.consumer.presence.PNGetStateResult;
+import com.pubnub.api.models.consumer.presence.PNHereNowResult;
+import com.pubnub.api.models.consumer.presence.PNSetStateResult;
+import com.pubnub.api.models.consumer.presence.PNWhereNowResult;
+
+import org.apache.camel.AsyncCallback;
+import org.apache.camel.CamelException;
+import org.apache.camel.Exchange;
+import org.apache.camel.impl.DefaultAsyncProducer;
+import org.apache.camel.util.ObjectHelper;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * The PubNub producer.
+ */
+public class PubNubProducer extends DefaultAsyncProducer {
+    private static final Logger LOG = LoggerFactory.getLogger(PubNubProducer.class);
+    private final PubNubEndpoint endpoint;
+    private final PubNubConfiguration pubnubConfiguration;
+
+    public PubNubProducer(PubNubEndpoint endpoint, PubNubConfiguration pubNubConfiguration) {
+        super(endpoint);
+        this.endpoint = endpoint;
+        this.pubnubConfiguration = pubNubConfiguration;
+    }
+
+    @Override
+    public boolean process(final Exchange exchange, final AsyncCallback callback) {
+
+        Operation operation = getOperation(exchange);
+
+        LOG.debug(""Executing {} operation"", operation);
+
+        switch (operation) {
+        case PUBLISH: {
+            doPublish(exchange, callback);
+            break;
+        }
+        case FIRE: {
+            doFire(exchange, callback);
+            break;
+        }
+        case GETHISTORY: {
+            doGetHistory(exchange, callback);
+            break;
+        }
+        case GETSTATE: {
+            doGetState(exchange, callback);
+            break;
+        }
+        case HERENOW: {
+            doHereNow(exchange, callback);
+            break;
+        }
+        case SETSTATE: {
+            doSetState(exchange, callback);
+            break;
+        }
+        case WHERENOW: {
+            doWhereNow(exchange, callback);
+            break;
+        }
+        default:
+            throw new UnsupportedOperationException(operation.toString());
+        }
+        if (exchange.getException() != null) {","[{'comment': 'This code should ideally be removed as you do this after you have send the message, instead its maybe a try .. catch you may need in case an exception was thrown before sending the message, which you then need to catch and call callback.done(true)', 'commenter': 'davsclaus'}]"
1617,components/camel-pubnub/pom.xml,"@@ -0,0 +1,89 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!-- Licensed to the Apache Software Foundation (ASF) under one or more contributor ","[{'comment': 'Add nicer license header, you can copy from one of the other existing pom.xml files', 'commenter': 'davsclaus'}]"
1663,components/camel-jaxb/src/main/java/org/apache/camel/converter/jaxb/JaxbDataFormat.java,"@@ -183,8 +183,22 @@ void marshal(Exchange exchange, Object graph, OutputStream stream, Marshaller ma
         throws XMLStreamException, JAXBException, NoTypeConversionAvailableException, IOException, InvalidPayloadException {
 
         Object element = graph;
-        if (partialClass != null && getPartNamespace() != null) {
-            element = new JAXBElement<Object>(getPartNamespace(), partialClass, graph);
+        QName  partNamespaceOnDataFormat = getPartNamespace();
+        String partClassFromHeader = (String)exchange.getIn().getHeader(JaxbConstants.JAXB_PART_CLASS);","[{'comment': ""Try to avoid type cast, but provide the String.class as parameter to getHeader so Camel know it's to type convert to this type."", 'commenter': 'davsclaus'}]"
1663,components/camel-jaxb/src/main/java/org/apache/camel/converter/jaxb/JaxbDataFormat.java,"@@ -183,8 +183,22 @@ void marshal(Exchange exchange, Object graph, OutputStream stream, Marshaller ma
         throws XMLStreamException, JAXBException, NoTypeConversionAvailableException, IOException, InvalidPayloadException {
 
         Object element = graph;
-        if (partialClass != null && getPartNamespace() != null) {
-            element = new JAXBElement<Object>(getPartNamespace(), partialClass, graph);
+        QName  partNamespaceOnDataFormat = getPartNamespace();","[{'comment': 'There is a double space', 'commenter': 'davsclaus'}]"
1680,components/camel-stomp/src/main/java/org/apache/camel/component/stomp/StompComponent.java,"@@ -55,6 +67,7 @@ protected Endpoint createEndpoint(String uri, String remaining, Map<String, Obje
         if (config.getSslContextParameters() == null) {
             config.setSslContextParameters(retrieveGlobalSslContextParameters());
         }
+        endpoint.setHeaderFilterStrategy(getHeaderFilterStrategy());","[{'comment': 'You must do this before you call setProperties on the endpoint, as otherwise you override any custom endpoint configured heater filter strategy with the one from the component', 'commenter': 'davsclaus'}, {'comment': ""Ok, I'll fix it later today. i followed like this because it was as Willem suggested so is it something wrong with this [line](https://github.com/apache/camel/blob/master/components/camel-jms/src/main/java/org/apache/camel/component/jms/JmsComponent.java#L1256)?"", 'commenter': 'onderson'}, {'comment': 'No it is on the configuration, not the enpoint. i got it.', 'commenter': 'onderson'}, {'comment': 'Ah yeah the jms component has the same problem, you should generally set component options on the endpoint first, and then let endpoint parameters override then if any is provided in the uri. But i guess its rare use-case to use a custom header filter strategy per endpoint and thus not noticed before.', 'commenter': 'davsclaus'}]"
1680,components/camel-stomp/src/main/java/org/apache/camel/component/stomp/StompEndpoint.java,"@@ -137,6 +144,10 @@ public void run() {
 
     protected void send(final Exchange exchange, final AsyncCallback callback) {
         final StompFrame frame = new StompFrame(SEND);
+        
+        // feature for CAMEL-7672","[{'comment': 'We dont really need comments to CAMEL tickets people can look in git commit history', 'commenter': 'davsclaus'}]"
1687,components/camel-mongodb/src/main/java/org/apache/camel/component/mongodb/MongoDbProducer.java,"@@ -293,6 +295,36 @@ private void processAndTransferResult(Object result, Exchange exchange, MongoDbO
         };
     }
 
+    private Function<Exchange, Object> createDoDistinct() {
+        return exchange -> {
+            Iterable<String> result = new ArrayList<>();
+            MongoCollection<BasicDBObject> dbCol = calculateCollection(exchange);
+            
+            // get the parameters out of the Exchange Header
+            String distinctFieldName = exchange.getIn().getHeader(MongoDbConstants.DISTINCT_QUERY_FIELD, String.class);
+            BasicDBObject query = null;
+            // do not run around looking for a type converter unless there is a need for it","[{'comment': 'This is not needed as Camel will check for null body', 'commenter': 'davsclaus'}]"
1687,components/camel-mongodb/src/test/java/org/apache/camel/component/mongodb/MongoDbFindOperationTest.java,"@@ -158,6 +158,7 @@ public void testFindAllIterationOperation() throws Exception {
             headers.put(MongoDbConstants.NUM_TO_SKIP, numToSkip);
             headers.put(MongoDbConstants.LIMIT, 100);
             Object result = template.requestBodyAndHeaders(""direct:findAll"", (Object) null, headers);
+            System.out.println(result.getClass());","[{'comment': 'Remove this or use LOG.info', 'commenter': 'davsclaus'}]"
1689,components/camel-opentracing/src/main/java/org/apache/camel/opentracing/decorators/RestSpanDecorator.java,"@@ -0,0 +1,108 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.opentracing.decorators;
+
+import java.io.UnsupportedEncodingException;
+import java.net.URLDecoder;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
+import io.opentracing.Span;
+
+import org.apache.camel.Endpoint;
+import org.apache.camel.Exchange;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class RestSpanDecorator extends AbstractHttpSpanDecorator {
+
+    private static final Logger LOG = LoggerFactory.getLogger(RestSpanDecorator.class);
+
+    @Override
+    public String getComponent() {
+        return ""rest"";
+    }
+
+    @Override
+    public String getOperationName(Exchange exchange, Endpoint endpoint) {
+        return getPath(endpoint.getEndpointUri());
+    }
+
+    @Override
+    public void pre(Span span, Exchange exchange, Endpoint endpoint) {
+        super.pre(span, exchange, endpoint);
+
+        getParameters(getPath(endpoint.getEndpointUri())).forEach(param -> {
+            Object value = exchange.getIn().getHeader(param);
+            if (value != null) {
+                if (value instanceof String) {
+                    span.setTag(param, (String)value);
+                } else if (value instanceof Number) {
+                    span.setTag(param, (Number)value);
+                } else if (value instanceof Boolean) {
+                    span.setTag(param, (Boolean)value);
+                }
+            }
+        });
+        
+    }
+
+    protected static String getPath(String uri) {
+        // Obtain the 'path' part of the URI format: rest://method:path[:uriTemplate]?[options]
+        String path = null;
+        int index = uri.indexOf(':');
+        if (index != -1) {
+            index = uri.indexOf(':', index + 1);
+            if (index != -1) {
+                path = uri.substring(index + 1);
+                index = path.indexOf('?');
+                if (index != -1) {
+                    path = path.substring(0, index);
+                }
+                path = path.replaceAll("":"", """");
+                try {
+                    path = URLDecoder.decode(path, ""UTF-8"");
+                } catch (UnsupportedEncodingException e) {
+                    LOG.error(""Failed to decode URL path '"" + path + ""'"", e);","[{'comment': 'Dont log at ERROR as there is nothing the user can do. Log a DEBUG or something and say in the error message that this exception is ignored.', 'commenter': 'davsclaus'}]"
1705,components/camel-grpc/src/main/docs/grpc-component.adoc,"@@ -81,6 +85,18 @@ The table below shows the types of objects in the message body, depending on the
 
 |=======================================================================
 
+### gRPC consumer headers (will be installed after the consumer invocation)
+
+[width=""100%"",cols=""25%,50,25%"",options=""header"",]
+|=======================================================================
+|Header name |Description|Possible values
+
+|*CamelGrpcMethodName*|Method name handled by the consumer service|
+|*CamelGrpcEventType*|Received event type from the sended request|onNext, onCompleted or onError","[{'comment': 'typo', 'commenter': 'nicolaferraro'}, {'comment': 'Thanks, fixed.', 'commenter': 'dmvolod'}]"
1705,components/camel-grpc/src/test/java/org/apache/camel/component/grpc/GrpcConsumerPropagationTest.java,"@@ -0,0 +1,148 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.grpc;
+
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+
+import io.grpc.ManagedChannel;
+import io.grpc.ManagedChannelBuilder;
+import io.grpc.stub.StreamObserver;
+import org.apache.camel.builder.RouteBuilder;
+import org.apache.camel.component.mock.MockEndpoint;
+import org.apache.camel.test.AvailablePortFinder;
+import org.apache.camel.test.junit4.CamelTestSupport;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class GrpcConsumerPropagationTest extends CamelTestSupport {
+    private static final Logger LOG = LoggerFactory.getLogger(GrpcConsumerPropagationTest.class);
+
+    private static final int GRPC_ASYNC_REQUEST_TEST_PORT = AvailablePortFinder.getNextAvailable();
+    private static final int GRPC_TEST_PING_ID = 1;
+    private static final String GRPC_TEST_PING_VALUE = ""PING"";
+    private static final String GRPC_TEST_PONG_VALUE = ""PONG"";
+
+    private ManagedChannel asyncRequestChannel;
+    private PingPongGrpc.PingPongStub asyncNonBlockingStub;
+
+    @Before
+    public void startGrpcChannels() {
+        asyncRequestChannel = ManagedChannelBuilder.forAddress(""localhost"", GRPC_ASYNC_REQUEST_TEST_PORT).usePlaintext(true).build();
+        asyncNonBlockingStub = PingPongGrpc.newStub(asyncRequestChannel);
+    }
+
+    @After
+    public void stopGrpcChannels() throws Exception {
+        asyncRequestChannel.shutdown().awaitTermination(5, TimeUnit.SECONDS);
+    }
+
+    @Test
+    public void testOnNextPropagation() throws Exception {
+        LOG.info(""gRPC pingAsyncSync method aync test start"");
+        
+        final CountDownLatch latch = new CountDownLatch(1);
+        PingRequest pingRequest = PingRequest.newBuilder().setPingName(GRPC_TEST_PING_VALUE).setPingId(GRPC_TEST_PING_ID).build();
+        PongResponseStreamObserver responseObserver = new PongResponseStreamObserver(latch);
+
+        StreamObserver<PingRequest> requestObserver = asyncNonBlockingStub.pingAsyncSync(responseObserver);
+        requestObserver.onNext(pingRequest);
+        latch.await(5, TimeUnit.SECONDS);
+
+        MockEndpoint mockEndpoint = getMockEndpoint(""mock:async-propagation"");
+        mockEndpoint.expectedMessageCount(1);
+        mockEndpoint.expectedHeaderValuesReceivedInAnyOrder(GrpcConstants.GRPC_EVENT_TYPE_HEADER, GrpcConstants.GRPC_EVENT_TYPE_ON_NEXT);
+        mockEndpoint.expectedHeaderValuesReceivedInAnyOrder(GrpcConstants.GRPC_METHOD_NAME_HEADER, ""pingAsyncSync"");
+        ","[{'comment': 'Here you should call `mockEndpoint.assertIsSatisfied()`, otherwise the expectations are not verified (please, check all other tests).', 'commenter': 'nicolaferraro'}, {'comment': 'Thanks, fixed.', 'commenter': 'dmvolod'}]"
1705,components/camel-grpc/src/main/java/org/apache/camel/component/grpc/server/GrpcRequestPropagationStreamObserver.java,"@@ -0,0 +1,65 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.grpc.server;
+
+import java.util.Map;
+
+import io.grpc.stub.StreamObserver;
+import org.apache.camel.component.grpc.GrpcConsumer;
+import org.apache.camel.component.grpc.GrpcEndpoint;
+
+/**
+ * gRPC request stream observer which is propagating every onNext(), onError()
+ * or onCompleted() calls to the Camel route
+ */
+public class GrpcRequestPropagationStreamObserver extends GrpcRequestAbstractStreamObserver {
+
+    public GrpcRequestPropagationStreamObserver(GrpcEndpoint endpoint, GrpcConsumer consumer, StreamObserver<Object> responseObserver, Map<String, Object> headers) {
+        super(endpoint, consumer, responseObserver, headers);
+    }
+
+    @Override
+    public void onNext(Object request) {
+        exchange = endpoint.createExchange();
+        exchange.getIn().setBody(request);
+        exchange.getIn().setHeaders(headers);
+        consumer.process(exchange, doneSync -> {","[{'comment': 'I think you should evaluate the response after the exchange has exited the route, that happens when the callback function is called. If you call it soon after pushing the message, the exchange may not be completed.', 'commenter': 'nicolaferraro'}, {'comment': ""I've added latch mechanism to avoid this situation. Please let me know, if any other version could be implemented."", 'commenter': 'dmvolod'}]"
1705,components/camel-grpc/src/main/java/org/apache/camel/component/grpc/server/GrpcRequestPropagationStreamObserver.java,"@@ -0,0 +1,65 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.grpc.server;
+
+import java.util.Map;
+
+import io.grpc.stub.StreamObserver;
+import org.apache.camel.component.grpc.GrpcConsumer;
+import org.apache.camel.component.grpc.GrpcEndpoint;
+
+/**
+ * gRPC request stream observer which is propagating every onNext(), onError()
+ * or onCompleted() calls to the Camel route
+ */
+public class GrpcRequestPropagationStreamObserver extends GrpcRequestAbstractStreamObserver {
+
+    public GrpcRequestPropagationStreamObserver(GrpcEndpoint endpoint, GrpcConsumer consumer, StreamObserver<Object> responseObserver, Map<String, Object> headers) {
+        super(endpoint, consumer, responseObserver, headers);
+    }
+
+    @Override
+    public void onNext(Object request) {
+        exchange = endpoint.createExchange();
+        exchange.getIn().setBody(request);
+        exchange.getIn().setHeaders(headers);
+        consumer.process(exchange, doneSync -> {
+        });
+        if (exchange.hasOut()) {
+            responseObserver.onNext(exchange.getOut().getBody());
+        } else {
+            responseObserver.onNext(exchange.getIn().getBody());
+        }
+        responseObserver.onCompleted();","[{'comment': 'If I understood it correctly, calling ""onCompleted"" after the first message has been processed would allow for only one response, regardless of the number of requests received in the stream. So methods with a `stream` response type will have a single response.', 'commenter': 'nicolaferraro'}, {'comment': 'This can cause confusion as output of the first exchange is used as response, while subsequent exchanges are ignored.', 'commenter': 'nicolaferraro'}, {'comment': ""Yes, you are completely right. I've added the check body type on response processing (the same in aggregation strategy). However, will need to think need to think about how to unleash strategies for requests and responses."", 'commenter': 'dmvolod'}]"
1705,components/camel-grpc/src/main/java/org/apache/camel/component/grpc/server/GrpcRequestAggregationStreamObserver.java,"@@ -0,0 +1,69 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.grpc.server;
+
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Map;
+
+import io.grpc.stub.StreamObserver;
+import org.apache.camel.component.grpc.GrpcConsumer;
+import org.apache.camel.component.grpc.GrpcEndpoint;
+
+/**
+ * gRPC request stream observer which is collecting received objects every
+ * onNext() call into the list and processing them in onCompleted()
+ */
+public class GrpcRequestAggregationStreamObserver extends GrpcRequestAbstractStreamObserver {
+    private List<Object> requestList = new LinkedList<>();
+
+    public GrpcRequestAggregationStreamObserver(GrpcEndpoint endpoint, GrpcConsumer consumer, StreamObserver<Object> responseObserver, Map<String, Object> headers) {
+        super(endpoint, consumer, responseObserver, headers);
+        exchange = endpoint.createExchange();
+    }
+
+    @Override
+    public void onNext(Object request) {
+        requestList.add(request);
+    }
+
+    @Override
+    public void onError(Throwable t) {
+        exchange.setException(t);
+    }
+
+    @Override
+    @SuppressWarnings(""unchecked"")
+    public void onCompleted() {
+        exchange.getIn().setBody(requestList);
+        exchange.getIn().setHeaders(headers);
+
+        consumer.process(exchange, doneSync -> {
+        });","[{'comment': 'Same as below. Response should be computed after the callback.', 'commenter': 'nicolaferraro'}, {'comment': ""I've added latch mechanism to avoid this situation."", 'commenter': 'dmvolod'}]"
1705,components/camel-grpc/src/main/java/org/apache/camel/component/grpc/GrpcConsumer.java,"@@ -0,0 +1,142 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.grpc;
+
+import java.lang.reflect.InvocationTargetException;
+import java.net.InetSocketAddress;
+
+import io.grpc.BindableService;
+import io.grpc.Server;
+import io.grpc.ServerInterceptor;
+import io.grpc.ServerInterceptors;
+import io.grpc.netty.NettyServerBuilder;
+import javassist.util.proxy.MethodHandler;
+import javassist.util.proxy.ProxyFactory;
+import org.apache.camel.AsyncCallback;
+import org.apache.camel.Exchange;
+import org.apache.camel.Processor;
+import org.apache.camel.component.grpc.server.GrpcHeaderInterceptor;
+import org.apache.camel.component.grpc.server.GrpcMethodHandler;
+import org.apache.camel.impl.DefaultConsumer;
+import org.apache.camel.util.ObjectHelper;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * Represents gRPC server consumer implementation
+ */
+public class GrpcConsumer extends DefaultConsumer {
+    private static final Logger LOG = LoggerFactory.getLogger(GrpcConsumer.class);
+
+    protected final GrpcConfiguration configuration;
+    protected final GrpcEndpoint endpoint;
+
+    private Server server;
+
+    public GrpcConsumer(GrpcEndpoint endpoint, Processor processor, GrpcConfiguration configuration) {
+        super(endpoint, processor);
+        this.endpoint = endpoint;
+        this.configuration = configuration;
+    }
+    
+    public GrpcConfiguration getConfiguration() {
+        return configuration;
+    }
+
+    @Override
+    protected void doStart() throws Exception {
+        super.doStart();
+        if (server == null) {
+            LOG.info(""Starting the gRPC server"");
+            initializeServer();
+            server.start();
+            LOG.info(""gRPC server started and listening on port: "" + server.getPort());
+        }
+    }
+
+    @Override
+    protected void doStop() throws Exception {
+        if (server != null) {
+            LOG.trace(""Terminating gRPC server"");
+            server.shutdown().shutdownNow();
+            server = null;
+        }
+        super.doStop();
+    }
+
+    protected void initializeServer() {
+        NettyServerBuilder serverBuilder = null;
+        BindableService bindableService = null;
+        ProxyFactory serviceProxy = new ProxyFactory();
+        ServerInterceptor headerInterceptor = new GrpcHeaderInterceptor();
+        MethodHandler methodHandler = new GrpcMethodHandler(endpoint, this);
+        
+        serviceProxy.setSuperclass(GrpcUtils.constructGrpcImplBaseClass(configuration.getServicePackage(), configuration.getServiceName()));
+        try {
+            bindableService = (BindableService)serviceProxy.create(new Class<?>[0], new Object[0], methodHandler);
+        } catch (NoSuchMethodException | IllegalArgumentException | InstantiationException | IllegalAccessException | InvocationTargetException e) {
+            throw new IllegalArgumentException(""Unable to create bindable proxy service for "" + configuration.getService());
+        }
+        
+        if (!ObjectHelper.isEmpty(configuration.getHost()) && !ObjectHelper.isEmpty(configuration.getPort())) {
+            LOG.info(""Building gRPC server on "" + configuration.getHost() + "":"" + configuration.getPort());
+            serverBuilder = NettyServerBuilder.forAddress(new InetSocketAddress(configuration.getHost(), configuration.getPort()));
+        } else if (ObjectHelper.isEmpty(configuration.getHost()) && !ObjectHelper.isEmpty(configuration.getPort())) {
+            LOG.info(""Building gRPC server on <any address>"" + "":"" + configuration.getPort());
+            serverBuilder = NettyServerBuilder.forPort(configuration.getPort());
+        } else {
+            throw new IllegalArgumentException(""No server start properties (host, port) specified"");
+        }
+        
+        server = serverBuilder.addService(ServerInterceptors.intercept(bindableService, headerInterceptor)).build();
+    }
+    
+    public boolean process(Exchange exchange, AsyncCallback callback) {
+        exchange.getIn().setHeader(GrpcConstants.GRPC_EVENT_TYPE_HEADER, GrpcConstants.GRPC_EVENT_TYPE_ON_NEXT);
+        return doSend(exchange, callback);
+    }
+    
+    public void onCompleted(Exchange exchange) {
+        exchange.getIn().setHeader(GrpcConstants.GRPC_EVENT_TYPE_HEADER, GrpcConstants.GRPC_EVENT_TYPE_ON_COMPLETED);","[{'comment': ""Probably it's better adding some flags (defaulting to false) to avoid forwarding empty exchanges with these information unless they are required by the users. Something like: https://github.com/apache/camel/blob/master/components/camel-reactive-streams/src/main/java/org/apache/camel/component/reactive/streams/ReactiveStreamsEndpoint.java#L50-L54"", 'commenter': 'nicolaferraro'}, {'comment': 'Thanks, added parameters based on your camel-reactive-streams component implementation.', 'commenter': 'dmvolod'}]"
1708,examples/camel-example-spring-boot-amq/readme.adoc,"@@ -0,0 +1,23 @@
+# Camel Example Spring Boot and ActiveMQ
+
+This example shows how to work with a simple Apache Camel application using Spring Boot and Apache ActiveMQ starter
+
+##prerequisites
+A running Apache ActiveMQ instance with openwire transportConnector opened on port 1234","[{'comment': 'Can you use the default 61616 port instead, so its much easier to try', 'commenter': 'davsclaus'}, {'comment': 'Sure but the purpose of using another port is to show the problem when overriding the default cf broker_url since localhost:61616 is default. For the example though it would be easier to use default, but to reproduce the cf issue you would have to use another port or host.', 'commenter': 'pax95'}]"
1708,examples/camel-example-spring-boot-amq/pom.xml,"@@ -0,0 +1,131 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!-- Licensed to the Apache Software Foundation (ASF) under one or more contributor ","[{'comment': 'Use a nicer looking license header, copy from one of the other', 'commenter': 'davsclaus'}]"
1708,examples/camel-example-spring-boot-amq/pom.xml,"@@ -0,0 +1,131 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!-- Licensed to the Apache Software Foundation (ASF) under one or more contributor 
+  license agreements. See the NOTICE file distributed with this work for additional 
+  information regarding copyright ownership. The ASF licenses this file to 
+  You under the Apache License, Version 2.0 (the ""License""); you may not use 
+  this file except in compliance with the License. You may obtain a copy of 
+  the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required 
+  by applicable law or agreed to in writing, software distributed under the 
+  License is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS 
+  OF ANY KIND, either express or implied. See the License for the specific 
+  language governing permissions and limitations under the License. -->
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
+  xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>org.apache.camel</groupId>
+    <artifactId>examples</artifactId>
+    <version>2.20.0-SNAPSHOT</version>
+  </parent>
+
+  <name>Camel :: Example :: Spring Boot</name>
+  <description>An example showing how to work with Camel, ActiveMq and Spring Boot</description>
+
+  <properties>","[{'comment': 'You need to add a category to this example - see pom.xml for the others.', 'commenter': 'davsclaus'}]"
1708,examples/camel-example-spring-boot-amq/pom.xml,"@@ -0,0 +1,131 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!-- Licensed to the Apache Software Foundation (ASF) under one or more contributor 
+  license agreements. See the NOTICE file distributed with this work for additional 
+  information regarding copyright ownership. The ASF licenses this file to 
+  You under the Apache License, Version 2.0 (the ""License""); you may not use 
+  this file except in compliance with the License. You may obtain a copy of 
+  the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required 
+  by applicable law or agreed to in writing, software distributed under the 
+  License is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS 
+  OF ANY KIND, either express or implied. See the License for the specific 
+  language governing permissions and limitations under the License. -->
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
+  xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>org.apache.camel</groupId>
+    <artifactId>examples</artifactId>
+    <version>2.20.0-SNAPSHOT</version>
+  </parent>
+
+  <name>Camel :: Example :: Spring Boot</name>
+  <description>An example showing how to work with Camel, ActiveMq and Spring Boot</description>
+
+  <properties>
+    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
+    <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
+    <spring.boot-version>${spring-boot-version}</spring.boot-version>
+  </properties>","[{'comment': 'Use empty lines between sections so its nicer looking', 'commenter': 'davsclaus'}]"
1708,examples/camel-example-spring-boot-amq/pom.xml,"@@ -0,0 +1,131 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!-- Licensed to the Apache Software Foundation (ASF) under one or more contributor 
+  license agreements. See the NOTICE file distributed with this work for additional 
+  information regarding copyright ownership. The ASF licenses this file to 
+  You under the Apache License, Version 2.0 (the ""License""); you may not use 
+  this file except in compliance with the License. You may obtain a copy of 
+  the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required 
+  by applicable law or agreed to in writing, software distributed under the 
+  License is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS 
+  OF ANY KIND, either express or implied. See the License for the specific 
+  language governing permissions and limitations under the License. -->
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
+  xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>org.apache.camel</groupId>
+    <artifactId>examples</artifactId>
+    <version>2.20.0-SNAPSHOT</version>
+  </parent>
+
+  <name>Camel :: Example :: Spring Boot</name>
+  <description>An example showing how to work with Camel, ActiveMq and Spring Boot</description>
+
+  <properties>
+    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
+    <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
+    <spring.boot-version>${spring-boot-version}</spring.boot-version>
+  </properties>
+  <dependencyManagement>
+    <dependencies>
+      <!-- Spring Boot BOM -->
+      <dependency>
+        <groupId>org.springframework.boot</groupId>
+        <artifactId>spring-boot-dependencies</artifactId>
+        <version>${spring.boot-version}</version>
+        <type>pom</type>
+        <scope>import</scope>
+      </dependency>
+      <!-- Camel BOM -->
+      <dependency>
+        <groupId>org.apache.camel</groupId>
+        <artifactId>camel-spring-boot-dependencies</artifactId>
+        <version>${project.version}</version>
+        <type>pom</type>
+        <scope>import</scope>
+      </dependency>
+    </dependencies>
+  </dependencyManagement>
+  <dependencies>
+    <!-- activemq -->
+    <dependency>
+      <groupId>org.springframework.boot</groupId>
+      <artifactId>spring-boot-starter-activemq</artifactId>
+      <exclusions>
+        <exclusion>
+          <groupId>org.apache.activemq</groupId>
+          <artifactId>activemq-broker</artifactId>
+        </exclusion>
+      </exclusions>
+    </dependency>
+    <!-- Camel -->
+    <dependency>
+      <groupId>org.apache.camel</groupId>
+      <artifactId>camel-spring-boot-starter</artifactId>
+    </dependency>
+    <dependency>
+      <groupId>org.apache.activemq</groupId>
+      <artifactId>activemq-camel</artifactId>
+      <!-- version>5.14.0</version-->
+      <exclusions>
+        <exclusion>
+          <groupId>org.apache.activemq</groupId>
+          <artifactId>activemq-broker</artifactId>
+        </exclusion>
+      </exclusions>
+    </dependency>
+    <!-- test -->
+    <dependency>
+      <groupId>org.springframework.boot</groupId>
+      <artifactId>spring-boot-starter-test</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.apache.camel</groupId>
+      <artifactId>camel-test-spring</artifactId>
+      <scope>test</scope>
+    </dependency>
+    
+  </dependencies>
+
+  <build>
+    <plugins>
+      <plugin>
+        <groupId>org.springframework.boot</groupId>
+        <artifactId>spring-boot-maven-plugin</artifactId>
+        <version>${spring-boot-version}</version>
+        <executions>
+          <execution>
+            <goals>
+              <goal>repackage</goal>
+            </goals>
+          </execution>
+        </executions>
+      </plugin>
+    </plugins>
+  </build>
+
+  <profiles>
+    <profile>
+      <id>jdk9-build</id>
+      <activation>
+        <jdk>9</jdk>
+      </activation>
+      <build>
+        <plugins>
+          <plugin>
+            <artifactId>maven-surefire-plugin</artifactId>
+            <configuration>
+              <argLine>--add-modules java.xml.bind --add-opens
+                java.base/java.lang=ALL-UNNAMED</argLine>
+            </configuration>
+          </plugin>
+        </plugins>
+      </build>
+    </profile>
+  </profiles>
+
+
+  <artifactId>camel-example-spring-boot-amq</artifactId>","[{'comment': 'This should be in the top', 'commenter': 'davsclaus'}]"
1708,examples/camel-example-spring-boot-amq/src/main/java/sample/camel/SampleAutowiredAmqRoute.java,"@@ -0,0 +1,35 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package sample.camel;
+
+import org.apache.camel.builder.RouteBuilder;
+import org.springframework.stereotype.Component;
+
+@Component
+public class SampleAutowiredAmqRoute extends RouteBuilder {
+
+    @Override
+    public void configure() throws Exception {
+        from(""activemq:foo"")
+            .to(""log:sample"");
+
+        from(""timer:bar"")
+            .setBody(constant(""hello from camel""))","[{'comment': 'Hello from Camel', 'commenter': 'davsclaus'}]"
1708,examples/camel-example-spring-boot-amq/src/main/resources/application.properties,"@@ -0,0 +1,17 @@
+## ---------------------------------------------------------------------------
+## Licensed to the Apache Software Foundation (ASF) under one or more
+## contributor license agreements.  See the NOTICE file distributed with
+## this work for additional information regarding copyright ownership.
+## The ASF licenses this file to You under the Apache License, Version 2.0
+## (the ""License""); you may not use this file except in compliance with
+## the License.  You may obtain a copy of the License at
+##
+##      http://www.apache.org/licenses/LICENSE-2.0
+##
+## Unless required by applicable law or agreed to in writing, software
+## distributed under the License is distributed on an ""AS IS"" BASIS,
+## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+## See the License for the specific language governing permissions and
+## limitations under the License.
+## ---------------------------------------------------------------------------
+spring.activemq.broker-url=tcp://localhost:1234","[{'comment': 'Use port 61616 so its the default port. And have empty line beforehand', 'commenter': 'davsclaus'}]"
1708,examples/pom.xml,"@@ -94,6 +94,7 @@
     <module>camel-example-splunk</module>
     <module>camel-example-spring</module>
     <module>camel-example-spring-boot</module>
+    <module>camel-example-spring-boot-amq</module>","[{'comment': 'Use activemq instead of amq', 'commenter': 'davsclaus'}]"
1708,examples/camel-example-spring-boot-amq/pom.xml,"@@ -0,0 +1,131 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!-- Licensed to the Apache Software Foundation (ASF) under one or more contributor 
+  license agreements. See the NOTICE file distributed with this work for additional 
+  information regarding copyright ownership. The ASF licenses this file to 
+  You under the Apache License, Version 2.0 (the ""License""); you may not use 
+  this file except in compliance with the License. You may obtain a copy of 
+  the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required 
+  by applicable law or agreed to in writing, software distributed under the 
+  License is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS 
+  OF ANY KIND, either express or implied. See the License for the specific 
+  language governing permissions and limitations under the License. -->
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
+  xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>org.apache.camel</groupId>
+    <artifactId>examples</artifactId>
+    <version>2.20.0-SNAPSHOT</version>
+  </parent>
+
+  <name>Camel :: Example :: Spring Boot</name>","[{'comment': 'Update name', 'commenter': 'davsclaus'}]"
1749,components/camel-sql/src/main/java/org/apache/camel/component/sql/stored/template/ast/ParseHelper.java,"@@ -21,29 +21,75 @@
 
 import org.apache.camel.component.sql.stored.template.generated.SSPTParserConstants;
 import org.apache.camel.component.sql.stored.template.generated.Token;
+import org.springframework.util.ClassUtils;
 import org.springframework.util.ReflectionUtils;
 
 public final class ParseHelper {
 
     private ParseHelper() {
     }
 
-    public static int parseSqlType(Token sqlType) {
+    public static int parseSqlType(Token sqlTypeToken) {
+
+        String sqlType = sqlTypeToken.toString();
 
         //if number then use it(probably Vendor spesific SQL-type)
-        if (sqlType.kind == SSPTParserConstants.NUMBER) {
-            return Integer.valueOf(sqlType.toString());
+        if (sqlTypeToken.kind == SSPTParserConstants.NUMBER) {
+            return Integer.valueOf(sqlType);
+        }
+
+        //if contains .
+        if (sqlType.contains(""."")) {
+            String className;
+            String fieldName;
+            try {
+                className = sqlType.substring(0, sqlType.lastIndexOf("".""));
+                fieldName = sqlType.substring(sqlType.lastIndexOf(""."") + 1);
+            } catch (Exception ex) {
+                throw new ParseRuntimeException(""Failed to parse class.field:"" + sqlType);
+            }
+            try {
+                Class clazz = ClassUtils.forName(className, ParseHelper.class.getClassLoader());","[{'comment': 'There is a ClassResolver via CamelContext you can get that we need to use instead to load classes. This ensures class loading works on different runtimes. This may require to add CamelContext as a parameter to this method, so you can use it.', 'commenter': 'davsclaus'}]"
1749,components/camel-sql/src/main/java/org/apache/camel/component/sql/stored/template/ast/ParseHelper.java,"@@ -21,29 +21,75 @@
 
 import org.apache.camel.component.sql.stored.template.generated.SSPTParserConstants;
 import org.apache.camel.component.sql.stored.template.generated.Token;
+import org.springframework.util.ClassUtils;
 import org.springframework.util.ReflectionUtils;
 
 public final class ParseHelper {
 
     private ParseHelper() {
     }
 
-    public static int parseSqlType(Token sqlType) {
+    public static int parseSqlType(Token sqlTypeToken) {
+
+        String sqlType = sqlTypeToken.toString();
 
         //if number then use it(probably Vendor spesific SQL-type)
-        if (sqlType.kind == SSPTParserConstants.NUMBER) {
-            return Integer.valueOf(sqlType.toString());
+        if (sqlTypeToken.kind == SSPTParserConstants.NUMBER) {
+            return Integer.valueOf(sqlType);
+        }
+
+        //if contains .
+        if (sqlType.contains(""."")) {
+            String className;
+            String fieldName;
+            try {
+                className = sqlType.substring(0, sqlType.lastIndexOf("".""));
+                fieldName = sqlType.substring(sqlType.lastIndexOf(""."") + 1);
+            } catch (Exception ex) {
+                throw new ParseRuntimeException(""Failed to parse class.field:"" + sqlType);
+            }
+            try {
+                Class clazz = ClassUtils.forName(className, ParseHelper.class.getClassLoader());
+                return getFieldInt(clazz, fieldName);
+            } catch (ClassNotFoundException e) {
+                throw new ParseRuntimeException(""Class for "" + className + "" not found"", e);
+
+            }
         }
 
         //Loop-up from ""Standard"" types
-        Field field = ReflectionUtils.findField(Types.class, sqlType.toString());
+        return getFieldInt(Types.class, sqlType);
+","[{'comment': 'Remove empty lines', 'commenter': 'davsclaus'}]"
1749,components/camel-sql/src/main/java/org/apache/camel/component/sql/stored/template/ast/ParseHelper.java,"@@ -21,29 +21,75 @@
 
 import org.apache.camel.component.sql.stored.template.generated.SSPTParserConstants;
 import org.apache.camel.component.sql.stored.template.generated.Token;
+import org.springframework.util.ClassUtils;
 import org.springframework.util.ReflectionUtils;
 
 public final class ParseHelper {
 
     private ParseHelper() {
     }
 
-    public static int parseSqlType(Token sqlType) {
+    public static int parseSqlType(Token sqlTypeToken) {
+
+        String sqlType = sqlTypeToken.toString();
 
         //if number then use it(probably Vendor spesific SQL-type)
-        if (sqlType.kind == SSPTParserConstants.NUMBER) {
-            return Integer.valueOf(sqlType.toString());
+        if (sqlTypeToken.kind == SSPTParserConstants.NUMBER) {
+            return Integer.valueOf(sqlType);
+        }
+
+        //if contains .
+        if (sqlType.contains(""."")) {
+            String className;
+            String fieldName;
+            try {
+                className = sqlType.substring(0, sqlType.lastIndexOf("".""));
+                fieldName = sqlType.substring(sqlType.lastIndexOf(""."") + 1);
+            } catch (Exception ex) {
+                throw new ParseRuntimeException(""Failed to parse class.field:"" + sqlType);
+            }
+            try {
+                Class clazz = ClassUtils.forName(className, ParseHelper.class.getClassLoader());
+                return getFieldInt(clazz, fieldName);
+            } catch (ClassNotFoundException e) {
+                throw new ParseRuntimeException(""Class for "" + className + "" not found"", e);
+
+            }
         }
 
         //Loop-up from ""Standard"" types
-        Field field = ReflectionUtils.findField(Types.class, sqlType.toString());
+        return getFieldInt(Types.class, sqlType);
+
+
+    }
+
+    public static Integer parseScale(Token token) {
+        try {
+            String str = token.toString();
+            return Integer.valueOf(str.substring(1, str.length() - 1));
+        } catch (Exception ex) {
+            throw new ParseRuntimeException(""Failed to parse scale from token:"" + token.toString(), ex);
+        }
+    }
+
+    private static int getFieldInt(Class clazz, String sqlType) {
+        Field field = ReflectionUtils.findField(clazz, sqlType);
         if (field == null) {
-            throw new ParseRuntimeException(""Field "" + sqlType + "" not found from java.procedureName.Types"");
+            throw new ParseRuntimeException(""Field "" + sqlType + "" not found from "" + clazz.getName());
         }
         try {
             return field.getInt(Types.class);
         } catch (IllegalAccessException e) {
             throw new ParseRuntimeException(e);
         }
     }
+
+
+    public static String removeQuotes(String token) {","[{'comment': 'There is a `removeLeadingAndEndingQuotes` method in camel-core from StringHelper which should be used instead', 'commenter': 'davsclaus'}]"
1749,components/camel-sql/src/main/java/org/apache/camel/component/sql/stored/template/ast/ParseHelper.java,"@@ -21,29 +21,75 @@
 
 import org.apache.camel.component.sql.stored.template.generated.SSPTParserConstants;
 import org.apache.camel.component.sql.stored.template.generated.Token;
+import org.springframework.util.ClassUtils;
 import org.springframework.util.ReflectionUtils;
 
 public final class ParseHelper {
 
     private ParseHelper() {
     }
 
-    public static int parseSqlType(Token sqlType) {
+    public static int parseSqlType(Token sqlTypeToken) {
+
+        String sqlType = sqlTypeToken.toString();
 
         //if number then use it(probably Vendor spesific SQL-type)
-        if (sqlType.kind == SSPTParserConstants.NUMBER) {
-            return Integer.valueOf(sqlType.toString());
+        if (sqlTypeToken.kind == SSPTParserConstants.NUMBER) {
+            return Integer.valueOf(sqlType);
+        }
+
+        //if contains .
+        if (sqlType.contains(""."")) {
+            String className;
+            String fieldName;
+            try {
+                className = sqlType.substring(0, sqlType.lastIndexOf("".""));
+                fieldName = sqlType.substring(sqlType.lastIndexOf(""."") + 1);
+            } catch (Exception ex) {
+                throw new ParseRuntimeException(""Failed to parse class.field:"" + sqlType);
+            }
+            try {
+                Class clazz = ClassUtils.forName(className, ParseHelper.class.getClassLoader());
+                return getFieldInt(clazz, fieldName);
+            } catch (ClassNotFoundException e) {
+                throw new ParseRuntimeException(""Class for "" + className + "" not found"", e);
+","[{'comment': 'Remove empty lines', 'commenter': 'davsclaus'}]"
1787,components/camel-grpc/src/main/docs/grpc-component.adoc,"@@ -108,30 +107,30 @@ Below is a simple synchronous method invoke with host and port parameters
 [source,java]
 -------------------------------------------------------------------------------
 from(""direct:grpc-sync"")
-.to(""grpc://org.apache.camel.component.grpc.PingPong?method=sendPing&host=localhost&port=1000&synchronous=true"");
+.to(""grpc://localhost:1101/org.apache.camel.component.grpc.PingPong?method=sendPing&synchronous=true"");","[{'comment': 'Just to avoid confusion, it might be better to use ""remotehost:1101"", instead of ""localhost:1101"" when explaining how to use a grpc producer.', 'commenter': 'nicolaferraro'}, {'comment': 'Also in following examples.', 'commenter': 'nicolaferraro'}, {'comment': 'Ok, will fix it.', 'commenter': 'dmvolod'}]"
1787,components/camel-grpc/src/main/java/org/apache/camel/component/grpc/GrpcUtils.java,"@@ -35,6 +35,14 @@
 
     private GrpcUtils() {
     }
+    
+    public static String extractServiceName(String service) {
+        return service.substring(service.lastIndexOf(""."") + 1);
+    }
+
+    public static String extractServicePackage(String service) {
+        return service.substring(0, service.lastIndexOf("".""));","[{'comment': ""If you don't include a package in the `.proto`, stubs and messages are put in the default package, so this may not work. You may want to add a simple test when fixing this (even if it's not a good practice to use the default package, it produces simpler URIs)."", 'commenter': 'nicolaferraro'}, {'comment': 'Ok, will try to add test reproduce it.', 'commenter': 'dmvolod'}]"
1822,tests/camel-jmh/src/test/java/org/apache/camel/itest/jmh/TypeConverterTest.java,"@@ -87,13 +102,59 @@ public void close() {
             }
         }
 
+        private String getResourceAsString(String resource) {
+            Scanner s = new Scanner(getClass().getClassLoader().getResourceAsStream(resource))
+                    .useDelimiter(""\\A"");","[{'comment': 'Is this a trick to look for a non existing delimiter to let the scanner read the entire file? We have IOHelper class in camel-core you can use to load a file as text, for example the loadText method.', 'commenter': 'davsclaus'}, {'comment': ""Yes :) \r\nI've replaced it by IOHelper as you suggested. Thanks"", 'commenter': 'MarcinLachowicz'}]"
1885,components/camel-asn1/src/main/java/org/apache/camel/dataformat/asn1/ASN1DataFormat.java,"@@ -0,0 +1,177 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.dataformat.asn1;
+
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+
+import org.apache.camel.Exchange;
+import org.apache.camel.spi.DataFormat;
+import org.apache.camel.spi.DataFormatName;
+import org.apache.camel.support.ServiceSupport;
+import org.apache.camel.util.IOHelper;
+import org.apache.camel.util.ObjectHelper;
+import org.bouncycastle.asn1.ASN1InputStream;
+import org.bouncycastle.asn1.ASN1Primitive;
+import org.openmuc.jasn1.ber.BerByteArrayOutputStream;
+
+public class ASN1DataFormat extends ServiceSupport implements DataFormat, DataFormatName {
+    private boolean usingIterator;
+    private Class<?> clazz;
+    private String clazzName;
+
+    public ASN1DataFormat() {
+        super();
+        this.usingIterator = false;
+    }
+
+    public ASN1DataFormat(String clazzName) {
+        super();
+        this.usingIterator = true;
+        this.clazzName = clazzName;
+    }
+
+    public ASN1DataFormat(Class<?> clazz) {
+        super();
+        this.usingIterator = true;
+        this.clazz = clazz;
+    }
+
+    @Override
+    public String getDataFormatName() {
+        return ""asn1"";
+    }
+
+    @Override
+    public void marshal(Exchange exchange, Object graph, OutputStream stream) throws Exception {
+        InputStream berOut = null;
+        if (usingIterator) {
+            if (clazzName != null || clazz != null) {
+                if (clazz != null && clazz.getName() != null) {
+                    clazzName = clazz.getName();
+                }
+                encodeGenericTypeObject(exchange, clazz, stream);
+                return;
+            }
+            Object record = exchange.getIn().getBody();
+            if (record instanceof ASN1Primitive) {
+                ASN1Primitive asn1Primitive = ObjectHelper.cast(ASN1Primitive.class, record);
+                berOut = new ByteArrayInputStream(asn1Primitive.getEncoded());
+            } else if (record instanceof byte[]) {
+                berOut = new ByteArrayInputStream(ObjectHelper.cast(byte[].class, record));
+            }
+        } else {
+            byte[] byteInput = exchange.getContext().getTypeConverter().mandatoryConvertTo(byte[].class, exchange, graph);
+            berOut = new ByteArrayInputStream(byteInput);
+        }
+        try {
+            IOHelper.copy(berOut, stream);
+        } finally {
+            IOHelper.close(berOut, stream);
+        }
+    }
+
+    @SuppressWarnings(""rawtypes"")
+    private void encodeGenericTypeObject(Exchange exchange, Class<?> clazz, OutputStream stream) 
+        throws NoSuchMethodException, SecurityException, 
+        IllegalAccessException, IllegalArgumentException, 
+        InvocationTargetException, IOException {
+        Class[] paramOut = new Class[1]; 
+        paramOut[0] = BerByteArrayOutputStream.class;
+        BerByteArrayOutputStream berOut = new BerByteArrayOutputStream(IOHelper.DEFAULT_BUFFER_SIZE / 256, true);
+        Method encodeMethod = exchange.getIn().getBody().getClass().getDeclaredMethod(""encode"", paramOut);
+        encodeMethod.invoke(exchange.getIn().getBody(), berOut);
+        stream.write(berOut.getArray());
+    }
+
+    @SuppressWarnings({""rawtypes"", ""unchecked""})
+    @Override
+    public Object unmarshal(Exchange exchange, InputStream stream) throws Exception {
+        if (usingIterator) {
+            if (clazzName != null || clazz != null) {
+                if (clazz != null && clazz.getName() != null) {
+                    clazzName = clazz.getName();
+                }
+                clazz = exchange.getContext().getClassResolver().resolveMandatoryClass(clazzName);
+                ASN1GenericIterator asn1GenericIterator = new ASN1GenericIterator(clazz, stream);
+                return asn1GenericIterator;
+            }
+            ASN1MessageIterator asn1MessageIterator = new ASN1MessageIterator(exchange, stream);
+            return asn1MessageIterator;
+        } else {
+            ASN1InputStream ais = new ASN1InputStream(stream);","[{'comment': 'Had a quick read. I think you may be able to save few lines using a try-with-resource statement for `ASN1InputStream` and `ByteArrayOutputStream`.', 'commenter': 'aldettinger'}]"
1885,components/camel-asn1/src/test/java/org/apache/camel/dataformat/asn1/ASN1DataFormatWithStreamIteratorClassTest.java,"@@ -0,0 +1,193 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.dataformat.asn1;
+
+import java.io.ByteArrayInputStream;
+import java.io.File;
+import java.util.Iterator;
+import java.util.List;
+
+import org.apache.camel.Exchange;
+import org.apache.camel.builder.RouteBuilder;
+import org.apache.camel.dataformat.asn1.model.testsmscbercdr.SmsCdr;
+import org.apache.camel.test.junit4.CamelTestSupport;
+import org.junit.Test;
+
+public class ASN1DataFormatWithStreamIteratorClassTest extends CamelTestSupport {
+
+    private ASN1DataFormat asn1;
+    private String fileName = ""src/test/resources/asn1_data/SMS_SINGLE.tt"";
+
+    private void baseUnmarshalReturnClassObjectTest(String mockEnpointName, String directEndpointName) throws Exception {
+        getMockEndpoint(mockEnpointName).expectedMessageCount(1);
+
+        File testFile = new File(fileName);
+        ByteArrayInputStream bais = ASN1DataFormatTestHelper.reteriveByteArrayInputStream(testFile);
+
+        template.sendBody(directEndpointName, bais);
+
+        List<Exchange> exchanges = getMockEndpoint(mockEnpointName).getExchanges();
+
+        assertTrue(exchanges.size() == 1);
+        for (Exchange exchange : exchanges) {
+            assertTrue(exchange.getIn().getBody() instanceof SmsCdr);
+        }
+
+        assertMockEndpointsSatisfied();
+    }
+
+    @Test
+    public void testUnmarshalReturnClassObject() throws Exception {
+        baseUnmarshalReturnClassObjectTest(""mock:unmarshal"", ""direct:unmarshal"");
+    }
+
+    @Test
+    public void testUnmarshalReturnClassObjectDsl() throws Exception {
+        baseUnmarshalReturnClassObjectTest(""mock:unmarshaldsl"", ""direct:unmarshaldsl"");
+    }
+
+    private void baseUnmarshalMarshalReturnOutputStreamTest(String mockEnpointName, String directEndpointName) throws Exception {
+        getMockEndpoint(mockEnpointName).expectedMessageCount(1);
+
+        File testFile = new File(fileName);
+        ByteArrayInputStream bais = ASN1DataFormatTestHelper.reteriveByteArrayInputStream(testFile);
+
+        template.sendBody(directEndpointName, bais);
+
+        List<Exchange> exchanges = getMockEndpoint(mockEnpointName).getExchanges();
+
+        assertTrue(exchanges.size() == 1);
+        for (Exchange exchange : exchanges) {
+            assertTrue(exchange.getIn().getBody() instanceof byte[]);
+            // assertTrue(Arrays.equals(FileUtils.readFileToByteArray(testFile),
+            // exchange.getIn().getBody(byte[].class)));
+
+            // FileOutputStream fos = new
+            // FileOutputStream(""src/test/resources/after_unmarshal_marshal_SMS_SINGLE.tt"");
+            // fos.write(ObjectHelper.cast(byte[].class,
+            // exchange.getIn().getBody()));
+            // fos.close();
+        }
+
+        assertMockEndpointsSatisfied();
+    }
+
+    @Test
+    public void testUnmarshalMarshalReturnOutputStream() throws Exception {
+        baseUnmarshalMarshalReturnOutputStreamTest(""mock:marshal"", ""direct:unmarshalthenmarshal"");
+    }
+
+    @Test
+    public void testUnmarshalMarshalReturnOutputStreamDsl() throws Exception {
+        baseUnmarshalMarshalReturnOutputStreamTest(""mock:marshaldsl"", ""direct:unmarshalthenmarshaldsl"");
+    }
+
+    // @Test","[{'comment': 'Found a commented test that could be deleted or annotated with `@Ignore`.', 'commenter': 'aldettinger'}]"
1885,components/camel-asn1/src/main/java/org/apache/camel/dataformat/asn1/ASN1DataFormat.java,"@@ -0,0 +1,177 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.dataformat.asn1;
+
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+
+import org.apache.camel.Exchange;
+import org.apache.camel.spi.DataFormat;
+import org.apache.camel.spi.DataFormatName;
+import org.apache.camel.support.ServiceSupport;
+import org.apache.camel.util.IOHelper;
+import org.apache.camel.util.ObjectHelper;
+import org.bouncycastle.asn1.ASN1InputStream;
+import org.bouncycastle.asn1.ASN1Primitive;
+import org.openmuc.jasn1.ber.BerByteArrayOutputStream;
+
+public class ASN1DataFormat extends ServiceSupport implements DataFormat, DataFormatName {
+    private boolean usingIterator;
+    private Class<?> clazz;
+    private String clazzName;
+
+    public ASN1DataFormat() {
+        super();","[{'comment': 'Those 3 implicit super() calls could be removed.', 'commenter': 'aldettinger'}]"
1885,components/camel-asn1/src/main/java/org/apache/camel/dataformat/asn1/ASN1DataFormat.java,"@@ -0,0 +1,177 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.dataformat.asn1;
+
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+
+import org.apache.camel.Exchange;
+import org.apache.camel.spi.DataFormat;
+import org.apache.camel.spi.DataFormatName;
+import org.apache.camel.support.ServiceSupport;
+import org.apache.camel.util.IOHelper;
+import org.apache.camel.util.ObjectHelper;
+import org.bouncycastle.asn1.ASN1InputStream;
+import org.bouncycastle.asn1.ASN1Primitive;
+import org.openmuc.jasn1.ber.BerByteArrayOutputStream;
+
+public class ASN1DataFormat extends ServiceSupport implements DataFormat, DataFormatName {
+    private boolean usingIterator;
+    private Class<?> clazz;
+    private String clazzName;
+
+    public ASN1DataFormat() {
+        super();
+        this.usingIterator = false;
+    }
+
+    public ASN1DataFormat(String clazzName) {
+        super();
+        this.usingIterator = true;
+        this.clazzName = clazzName;
+    }
+
+    public ASN1DataFormat(Class<?> clazz) {
+        super();
+        this.usingIterator = true;
+        this.clazz = clazz;
+    }
+
+    @Override
+    public String getDataFormatName() {
+        return ""asn1"";
+    }
+
+    @Override
+    public void marshal(Exchange exchange, Object graph, OutputStream stream) throws Exception {
+        InputStream berOut = null;
+        if (usingIterator) {
+            if (clazzName != null || clazz != null) {
+                if (clazz != null && clazz.getName() != null) {
+                    clazzName = clazz.getName();
+                }
+                encodeGenericTypeObject(exchange, clazz, stream);
+                return;
+            }
+            Object record = exchange.getIn().getBody();
+            if (record instanceof ASN1Primitive) {
+                ASN1Primitive asn1Primitive = ObjectHelper.cast(ASN1Primitive.class, record);
+                berOut = new ByteArrayInputStream(asn1Primitive.getEncoded());
+            } else if (record instanceof byte[]) {
+                berOut = new ByteArrayInputStream(ObjectHelper.cast(byte[].class, record));
+            }
+        } else {
+            byte[] byteInput = exchange.getContext().getTypeConverter().mandatoryConvertTo(byte[].class, exchange, graph);
+            berOut = new ByteArrayInputStream(byteInput);
+        }
+        try {
+            IOHelper.copy(berOut, stream);
+        } finally {
+            IOHelper.close(berOut, stream);
+        }
+    }
+
+    @SuppressWarnings(""rawtypes"")
+    private void encodeGenericTypeObject(Exchange exchange, Class<?> clazz, OutputStream stream) 
+        throws NoSuchMethodException, SecurityException, 
+        IllegalAccessException, IllegalArgumentException, 
+        InvocationTargetException, IOException {
+        Class[] paramOut = new Class[1]; 
+        paramOut[0] = BerByteArrayOutputStream.class;
+        BerByteArrayOutputStream berOut = new BerByteArrayOutputStream(IOHelper.DEFAULT_BUFFER_SIZE / 256, true);
+        Method encodeMethod = exchange.getIn().getBody().getClass().getDeclaredMethod(""encode"", paramOut);
+        encodeMethod.invoke(exchange.getIn().getBody(), berOut);
+        stream.write(berOut.getArray());
+    }
+
+    @SuppressWarnings({""rawtypes"", ""unchecked""})
+    @Override
+    public Object unmarshal(Exchange exchange, InputStream stream) throws Exception {
+        if (usingIterator) {
+            if (clazzName != null || clazz != null) {
+                if (clazz != null && clazz.getName() != null) {
+                    clazzName = clazz.getName();
+                }
+                clazz = exchange.getContext().getClassResolver().resolveMandatoryClass(clazzName);
+                ASN1GenericIterator asn1GenericIterator = new ASN1GenericIterator(clazz, stream);
+                return asn1GenericIterator;
+            }
+            ASN1MessageIterator asn1MessageIterator = new ASN1MessageIterator(exchange, stream);
+            return asn1MessageIterator;
+        } else {
+            ASN1InputStream ais = new ASN1InputStream(stream);
+            ASN1Primitive asn1Record = null;
+            ByteArrayOutputStream asn1Out = null;
+            try {
+                asn1Out = new ByteArrayOutputStream();
+                while (ais.available() > 0) {
+                    asn1Record = ais.readObject();
+                    asn1Out.write(asn1Record.getEncoded());
+                }
+            } finally {
+                if (asn1Out != null) {
+                    asn1Out.close();
+                }
+                if (ais != null) {
+                    ais.close();
+                }
+            }
+            return asn1Out.toByteArray();
+        }
+    }
+
+    public boolean isUsingIterator() {
+        return usingIterator;
+    }
+
+    public void setUsingIterator(boolean usingIterator) {
+        this.usingIterator = usingIterator;
+    }
+
+    @SuppressWarnings(""rawtypes"")","[{'comment': 'Returning Class<?> may discard the SuppressWarnings annotation.\r\nWill try to have a deeper look into this PR next week.', 'commenter': 'aldettinger'}]"
1885,components/camel-asn1/src/main/java/org/apache/camel/dataformat/asn1/ASN1DataFormat.java,"@@ -0,0 +1,177 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.dataformat.asn1;
+
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+
+import org.apache.camel.Exchange;
+import org.apache.camel.spi.DataFormat;
+import org.apache.camel.spi.DataFormatName;
+import org.apache.camel.support.ServiceSupport;
+import org.apache.camel.util.IOHelper;
+import org.apache.camel.util.ObjectHelper;
+import org.bouncycastle.asn1.ASN1InputStream;
+import org.bouncycastle.asn1.ASN1Primitive;
+import org.openmuc.jasn1.ber.BerByteArrayOutputStream;
+
+public class ASN1DataFormat extends ServiceSupport implements DataFormat, DataFormatName {
+    private boolean usingIterator;
+    private Class<?> clazz;
+    private String clazzName;
+
+    public ASN1DataFormat() {
+        super();
+        this.usingIterator = false;
+    }
+
+    public ASN1DataFormat(String clazzName) {
+        super();
+        this.usingIterator = true;
+        this.clazzName = clazzName;
+    }
+
+    public ASN1DataFormat(Class<?> clazz) {
+        super();
+        this.usingIterator = true;
+        this.clazz = clazz;
+    }
+
+    @Override
+    public String getDataFormatName() {
+        return ""asn1"";
+    }
+
+    @Override
+    public void marshal(Exchange exchange, Object graph, OutputStream stream) throws Exception {
+        InputStream berOut = null;
+        if (usingIterator) {
+            if (clazzName != null || clazz != null) {
+                if (clazz != null && clazz.getName() != null) {
+                    clazzName = clazz.getName();
+                }
+                encodeGenericTypeObject(exchange, clazz, stream);
+                return;
+            }
+            Object record = exchange.getIn().getBody();
+            if (record instanceof ASN1Primitive) {
+                ASN1Primitive asn1Primitive = ObjectHelper.cast(ASN1Primitive.class, record);
+                berOut = new ByteArrayInputStream(asn1Primitive.getEncoded());
+            } else if (record instanceof byte[]) {
+                berOut = new ByteArrayInputStream(ObjectHelper.cast(byte[].class, record));
+            }
+        } else {
+            byte[] byteInput = exchange.getContext().getTypeConverter().mandatoryConvertTo(byte[].class, exchange, graph);
+            berOut = new ByteArrayInputStream(byteInput);
+        }
+        try {
+            IOHelper.copy(berOut, stream);
+        } finally {
+            IOHelper.close(berOut, stream);
+        }
+    }
+
+    @SuppressWarnings(""rawtypes"")
+    private void encodeGenericTypeObject(Exchange exchange, Class<?> clazz, OutputStream stream) 
+        throws NoSuchMethodException, SecurityException, 
+        IllegalAccessException, IllegalArgumentException, 
+        InvocationTargetException, IOException {
+        Class[] paramOut = new Class[1]; 
+        paramOut[0] = BerByteArrayOutputStream.class;
+        BerByteArrayOutputStream berOut = new BerByteArrayOutputStream(IOHelper.DEFAULT_BUFFER_SIZE / 256, true);
+        Method encodeMethod = exchange.getIn().getBody().getClass().getDeclaredMethod(""encode"", paramOut);
+        encodeMethod.invoke(exchange.getIn().getBody(), berOut);
+        stream.write(berOut.getArray());
+    }
+
+    @SuppressWarnings({""rawtypes"", ""unchecked""})
+    @Override
+    public Object unmarshal(Exchange exchange, InputStream stream) throws Exception {
+        if (usingIterator) {
+            if (clazzName != null || clazz != null) {
+                if (clazz != null && clazz.getName() != null) {","[{'comment': 'I wonder if it could be a good idea to factorize this redudant code in getClassName() or constructor.', 'commenter': 'aldettinger'}]"
1885,components/camel-asn1/pom.xml,"@@ -0,0 +1,163 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one or more
+    contributor license agreements.  See the NOTICE file distributed with
+    this work for additional information regarding copyright ownership.
+    The ASF licenses this file to You under the Apache License, Version 2.0
+    (the ""License""); you may not use this file except in compliance with
+    the License.  You may obtain a copy of the License at
+
+         http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an ""AS IS"" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+
+-->
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>org.apache.camel</groupId>
+    <artifactId>components</artifactId>
+    <version>2.20.0-SNAPSHOT</version>
+  </parent>
+
+  <artifactId>camel-asn1</artifactId>
+  <packaging>jar</packaging>
+  <name>Camel :: ASN.1</name>
+  <description>Camel ASN.1 support</description>
+
+  <properties>
+    <camel.osgi.import>
+    	!org.apache.camel.dataformat.asn1,
+    	*
+    </camel.osgi.import>
+    <camel.osgi.export>
+    	org.apache.camel.dataformat.asn1;${camel.osgi.version}
+    </camel.osgi.export>
+    <camel.osgi.export.service>org.apache.camel.spi.DataFormatResolver;dataformat=asn1</camel.osgi.export.service>
+    
+  </properties>
+
+  <dependencies>
+    <dependency>
+      <groupId>org.apache.camel</groupId>
+      <artifactId>camel-core</artifactId>
+    </dependency>
+    <dependency>
+      <groupId>org.bouncycastle</groupId>
+      <artifactId>bcprov-jdk15on</artifactId>
+      <version>${bouncycastle-version}</version>
+    </dependency>
+    <dependency>
+      <groupId>org.openmuc</groupId>
+      <artifactId>jasn1</artifactId>
+      <version>${jasn1-version}</version>
+    </dependency>
+
+    <!-- test dependencies -->
+    <dependency>
+      <groupId>org.apache.camel</groupId>
+      <artifactId>camel-test</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.apache.camel</groupId>
+      <artifactId>camel-spring</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.apache.camel</groupId>
+      <artifactId>camel-test-spring</artifactId>
+      <scope>test</scope>
+    </dependency>  
+    <dependency>
+      <groupId>org.apache.logging.log4j</groupId>
+      <artifactId>log4j-api</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.apache.logging.log4j</groupId>
+      <artifactId>log4j-core</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.apache.logging.log4j</groupId>
+      <artifactId>log4j-slf4j-impl</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>commons-io</groupId>
+      <artifactId>commons-io</artifactId>
+      <scope>test</scope>
+    </dependency>
+  </dependencies>
+  
+  <build>
+    <plugins>
+      <plugin>
+        <groupId>org.codehaus.mojo</groupId>
+        <artifactId>exec-maven-plugin</artifactId>
+         <executions>
+           <execution>
+             <id>generate-test-sources</id>
+             <phase>generate-sources</phase>
+             <goals>
+               <goal>java</goal>
+             </goals>
+             <configuration>
+               <includeProjectDependencies>false</includeProjectDependencies>
+               <includePluginDependencies>true</includePluginDependencies>
+               <testSourceRoot>${basedir}/target/generated/src/test/java</testSourceRoot>
+               <executableDependency>
+                 <groupId>org.openmuc</groupId>
+                 <artifactId>jasn1-compiler</artifactId>
+               </executableDependency>
+               <mainClass>org.openmuc.jasn1.compiler.Compiler</mainClass>
+               <arguments>
+                 <argument>-o</argument>
+                 <argument>target/generated/src/test/java</argument>
+                 <argument>-p</argument>
+                 <argument>org.apache.camel.dataformat.asn1.model</argument>
+                 <argument>-f</argument>
+                 <argument>src/test/resources/asn1_structure/TestSMSCBerCdr.asn1</argument>
+                 <argument>-il</argument>
+               </arguments>
+             </configuration>
+           </execution>
+           <!-- 
+           <execution>
+             <id>generate-sources</id>
+             <phase>package</phase>
+             <goals>
+               <goal>java</goal>
+             </goals>
+           </execution>
+            -->
+         </executions>
+         <dependencies>
+           <dependency>
+             <groupId>org.openmuc</groupId>
+             <artifactId>jasn1-compiler</artifactId>
+             <version>${jasn1-version}</version>
+           </dependency>
+         </dependencies>
+      </plugin>
+","[{'comment': 'Spotted a comment below. useless ?', 'commenter': 'aldettinger'}]"
1885,parent/pom.xml,"@@ -829,6 +829,11 @@
         <artifactId>camel-amqp</artifactId>
         <version>${project.version}</version>
       </dependency>
+	  <dependency>
+        <groupId>org.apache.camel</groupId>
+        <artifactId>camel-asn1</artifactId>
+        <version>${project.version}</version>
+      </dependency>","[{'comment': 'Here you miss the camel-asn1-starter in the starters section', 'commenter': 'oscerd'}]"
1887,components/camel-ssh/src/main/java/org/apache/camel/component/ssh/ResourceBasedSSHKeyVerifier.java,"@@ -0,0 +1,211 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.ssh;
+
+import java.io.BufferedReader;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.math.BigInteger;
+import java.net.InetSocketAddress;
+import java.net.SocketAddress;
+import java.nio.charset.Charset;
+import java.security.NoSuchAlgorithmException;
+import java.security.PublicKey;
+import java.security.spec.InvalidKeySpecException;
+import java.util.Base64;
+import java.util.LinkedList;
+import java.util.List;
+
+import org.apache.camel.CamelContext;
+import org.apache.camel.util.ResourceHelper;
+import org.apache.sshd.ClientSession;
+import org.apache.sshd.client.ServerKeyVerifier;
+import org.bouncycastle.util.Arrays;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * ServerKeyVerifier that takes a camel resource as input file to validate the server key against.
+ *
+ */
+public class ResourceBasedSSHKeyVerifier implements ServerKeyVerifier {
+    protected final Logger log = LoggerFactory.getLogger(getClass());
+
+    private CamelContext camelContext;
+    private boolean failOnUnknownHost;
+    private String knownHostsResource;
+
+    public ResourceBasedSSHKeyVerifier(CamelContext camelContext, String knownHostsResource) {
+        this.camelContext = camelContext;","[{'comment': 'referencing camelContext here does not seem good practice to me. why not resolve the resource beforehand pass that reference here and use it?', 'commenter': 'onderson'}, {'comment': ""Hi,\r\n\r\nthanks for you suggestions.\r\n\r\nI wanted to parse the file on every connection attempt (this is the same behavior as other ssh clients). Therefore I can't parse it beforehand. \r\n\r\nAnother approach would be to resolve it to an URL by the ResourceHelper class - However I am not sure if this is possible for every URI. Would you prefer this approach?\r\n\r\nSascha"", 'commenter': 'sdirbach'}, {'comment': 'Any further feedback on this point?', 'commenter': 'sdirbach'}, {'comment': 'well, i would prefer your second suggestion. i did not comment any further, expected other reviewers would check as well..', 'commenter': 'onderson'}]"
1887,components/camel-ssh/src/main/java/org/apache/camel/component/ssh/SSHPublicKeyHolder.java,"@@ -0,0 +1,165 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.ssh;
+
+import java.math.BigInteger;
+import java.nio.charset.Charset;
+import java.security.KeyFactory;
+import java.security.NoSuchAlgorithmException;
+import java.security.PublicKey;
+import java.security.spec.DSAPublicKeySpec;
+import java.security.spec.InvalidKeySpecException;
+import java.security.spec.RSAPublicKeySpec;
+
+public class SSHPublicKeyHolder {
+    private static final String SSH_RSA = ""ssh-rsa"";
+    private static final String SSH_DSS = ""ssh-dss"";
+    private static final String SSH_ECDSA = ""ecdsa-sha2-nistp256"";
+    private static final String SSH_ED25519 = ""ssh-ed25519"";
+
+    private String keyType;
+
+    /* RSA key parts */
+    private BigInteger e;","[{'comment': 'more readable variable names is preferable.', 'commenter': 'onderson'}, {'comment': 'Hi, the variable names are directly derived from the KeySpec format (which are derived from the RSA/DSA specification)', 'commenter': 'sdirbach'}, {'comment': ""that's reasonable and good to go.."", 'commenter': 'onderson'}]"
1887,components/camel-ssh/src/main/java/org/apache/camel/component/ssh/SshProducer.java,"@@ -16,36 +16,38 @@
  */
 package org.apache.camel.component.ssh;
 
+import java.io.InputStream;
 import java.util.Map;
 
 import org.apache.camel.CamelExchangeException;
 import org.apache.camel.Exchange;
 import org.apache.camel.Message;
 import org.apache.camel.impl.DefaultProducer;
+import org.apache.camel.util.ResourceHelper;","[{'comment': 'is it unnecessary here?', 'commenter': 'onderson'}, {'comment': 'Yep, will remove this', 'commenter': 'sdirbach'}]"
1887,components/camel-ssh/src/test/java/org/apache/camel/component/ssh/SshComponentKnownHostTest.java,"@@ -0,0 +1,124 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.ssh;
+
+import org.apache.camel.builder.RouteBuilder;
+import org.apache.camel.component.mock.MockEndpoint;
+import org.junit.Test;
+
+public class SshComponentKnownHostTest extends SshComponentTestSupport {
+
+    @Test
+    public void testProducerWithValidFile() throws Exception {
+        final String msg = ""test\n"";
+
+        MockEndpoint mock = getMockEndpoint(""mock:password"");
+        mock.expectedMinimumMessageCount(1);
+        mock.expectedBodiesReceived(msg);
+        mock.expectedHeaderReceived(SshResult.EXIT_VALUE, 0);
+        mock.expectedHeaderReceived(SshResult.STDERR, ""Error:test\n"");
+
+        template.sendBody(""direct:ssh"", msg);
+
+        assertMockEndpointsSatisfied();
+    }
+
+    @Test
+    public void testProducerWithInvalidFile() throws Exception {
+        final String msg = ""test\n"";
+
+        MockEndpoint mock = getMockEndpoint(""mock:password"");
+        mock.expectedMessageCount(0);
+
+        template.sendBody(""direct:sshInvalid"", msg);
+
+        assertMockEndpointsSatisfied();
+    }
+
+    @Test
+    public void testProducerWithInvalidFileWarnOnly() throws Exception {
+        final String msg = ""test\n"";
+
+        MockEndpoint mock = getMockEndpoint(""mock:password"");
+        mock.expectedMinimumMessageCount(1);
+        mock.expectedBodiesReceived(msg);
+        mock.expectedHeaderReceived(SshResult.EXIT_VALUE, 0);
+        mock.expectedHeaderReceived(SshResult.STDERR, ""Error:test\n"");
+
+        template.sendBody(""direct:sshInvalidWarnOnly"", msg);
+
+        assertMockEndpointsSatisfied();
+    }
+    
+    @Test
+    public void testPollingConsumerWithValidKnownHostFile() throws Exception {
+        MockEndpoint mock = getMockEndpoint(""mock:result"");
+        mock.expectedMinimumMessageCount(1);
+        mock.expectedBodiesReceived(""test\r"");
+        mock.expectedHeaderReceived(SshResult.EXIT_VALUE, 0);
+        mock.expectedHeaderReceived(SshResult.STDERR, ""Error:test\r"");
+        assertMockEndpointsSatisfied();
+    }
+    
+    @Test
+    public void testPollingConsumerWithInvalidKnownHostFile() throws Exception {
+        MockEndpoint mock = getMockEndpoint(""mock:resultInvalid"");
+        mock.expectedMessageCount(0);
+        assertMockEndpointsSatisfied();
+    }
+    
+    @Test
+    public void testPollingConsumerWithInvalidKnownHostFileWarnOnly() throws Exception {
+        MockEndpoint mock = getMockEndpoint(""mock:resultInvalidWarnOnly"");
+        mock.expectedMinimumMessageCount(1);
+        mock.expectedBodiesReceived(""test\r"");
+        mock.expectedHeaderReceived(SshResult.EXIT_VALUE, 0);
+        mock.expectedHeaderReceived(SshResult.STDERR, ""Error:test\r"");
+        assertMockEndpointsSatisfied();
+    }
+
+    @Override
+    protected RouteBuilder createRouteBuilder() throws Exception {
+        return new RouteBuilder() {
+            @Override
+            public void configure() {
+                onException(Exception.class).handled(true).to(""mock:error"");
+
+                from(""ssh://smx:smx@localhost:"" + port + ""?useFixedDelay=true&delay=40000&pollCommand=test%0D&knownHostsResource=classpath:known_hosts_valid&failOnUnknownHost=true"")
+                    .to(""mock:result"");
+                
+                from(""ssh://smx:smx@localhost:"" + port + ""?useFixedDelay=true&delay=40000&pollCommand=test%0D&knownHostsResource=classpath:known_hosts_invalid&failOnUnknownHost=true"")","[{'comment': 'if know_hosts is a file in a classpath, the solution may work. how about if the resource is in somewhere else as stated in the issue, like http, ftp, etc...', 'commenter': 'onderson'}, {'comment': ""I don't see a problem with that, since it uses the well-tested ResourceHelper class from camel-core. According to the javadoc it supports file: and http: URIs"", 'commenter': 'sdirbach'}, {'comment': 'looks good then..', 'commenter': 'onderson'}]"
1887,components/camel-ssh/src/main/java/org/apache/camel/component/ssh/ResourceBasedSSHKeyVerifier.java,"@@ -0,0 +1,211 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.ssh;
+
+import java.io.BufferedReader;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.math.BigInteger;
+import java.net.InetSocketAddress;
+import java.net.SocketAddress;
+import java.nio.charset.Charset;
+import java.security.NoSuchAlgorithmException;
+import java.security.PublicKey;
+import java.security.spec.InvalidKeySpecException;
+import java.util.Base64;
+import java.util.LinkedList;
+import java.util.List;
+
+import org.apache.camel.CamelContext;
+import org.apache.camel.util.ResourceHelper;
+import org.apache.sshd.ClientSession;
+import org.apache.sshd.client.ServerKeyVerifier;
+import org.bouncycastle.util.Arrays;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * ServerKeyVerifier that takes a camel resource as input file to validate the server key against.
+ *
+ */
+public class ResourceBasedSSHKeyVerifier implements ServerKeyVerifier {
+    protected final Logger log = LoggerFactory.getLogger(getClass());
+
+    private CamelContext camelContext;
+    private boolean failOnUnknownHost;
+    private String knownHostsResource;
+
+    public ResourceBasedSSHKeyVerifier(CamelContext camelContext, String knownHostsResource) {
+        this.camelContext = camelContext;
+        this.knownHostsResource = knownHostsResource;
+        this.failOnUnknownHost = false;
+    }
+    
+    public ResourceBasedSSHKeyVerifier(CamelContext camelContext, String knownHostsResource,
+            boolean failOnUnknownHost) {
+        this.camelContext = camelContext;
+        this.knownHostsResource = knownHostsResource;
+        this.failOnUnknownHost = failOnUnknownHost;
+    }
+
+    @Override
+    public boolean verifyServerKey(ClientSession sshClientSession, SocketAddress remoteAddress, PublicKey serverKey) {
+        log.debug(""Trying to find known_hosts file %s"", knownHostsResource);
+        InputStream knownHostsInputStream = null;
+        try {
+            knownHostsInputStream = ResourceHelper.resolveMandatoryResourceAsInputStream(camelContext,
+                    knownHostsResource);
+            List<String> possibleTokens = getKnownHostsFileTokensForSocketAddress(remoteAddress);
+            log.debug(""Trying to mach PublicKey against provided known_hosts file"");
+            PublicKey matchingKey = findKeyForServerToken(knownHostsInputStream, possibleTokens);
+            if (matchingKey != null) {
+                log.debug(""Found PublicKey match for server"");
+                boolean match = Arrays.areEqual(matchingKey.getEncoded(), serverKey.getEncoded());
+                return match;
+            }
+        } catch (IOException ioException) {
+            log.debug(String.format(""Could not find known_hosts file %s"", knownHostsResource), ioException);
+        } finally {
+            if (knownHostsInputStream != null) {
+                try {
+                    knownHostsInputStream.close();
+                } catch (IOException e) {
+                    // Ignore
+                }
+            }
+        }
+        if (failOnUnknownHost) {
+            log.warn(""Could not find matching key for client session, connection will fail due to configuration"");
+            return false;
+        } else {
+            log.warn(
+                    ""Could not find matching key for client session, connection will continue anyway due to configuration"");
+            return true;
+        }
+    }
+
+    private PublicKey findKeyForServerToken(InputStream knownHostsInputStream, List<String> possibleTokens)
+            throws IOException {
+        List<String> knowHostsLines = readInputStreamToStringList(knownHostsInputStream);
+
+        for (String s : knowHostsLines) {
+            String[] parts = s.split("" "");
+            if (parts.length != 3) {
+                log.warn(""Found malformed entry in known_hosts file"");
+                continue;
+            }
+            String entry = parts[0];
+            String key = parts[2];
+            for (String serverToken : possibleTokens) {
+                if (entry.contains(serverToken)) {
+                    try {
+                        return loadKey(key);
+                    } catch (NoSuchAlgorithmException | InvalidKeySpecException e) {
+                        log.warn(String.format(""Could not load key for server token %s"", entry), e);
+                    }
+                }
+            }
+        }
+        return null;
+    }
+
+    private List<String> readInputStreamToStringList(InputStream knownHostsInputStream) throws IOException {
+        List<String> returnList = new LinkedList<>();
+        String line;
+        BufferedReader bufferedReader = new BufferedReader(
+                new InputStreamReader(knownHostsInputStream, Charset.forName(""UTF-8"")));
+        while ((line = bufferedReader.readLine()) != null) {
+            returnList.add(line);
+        }
+        return returnList;
+    }
+
+    private List<String> getKnownHostsFileTokensForSocketAddress(SocketAddress remoteAddress) {","[{'comment': ""this method is heavily based on String parsing. I don't know very well about known_hosts file's structure. Is this Ok with any file based know_hosts resource in the classpath? This makes code not very readable IMHO."", 'commenter': 'onderson'}, {'comment': ""The known_hosts file structure is line based with only basic String / Base64 content - therefore it should be safe.\r\nI don't really know how to improve this, thats why I implemented it that way."", 'commenter': 'sdirbach'}, {'comment': ""that's reasonable and good to go.."", 'commenter': 'onderson'}]"
1948,components/camel-ftp/src/main/java/org/apache/camel/component/file/remote/FtpUtils.java,"@@ -35,6 +35,19 @@
 
     private FtpUtils() {
     }
+    
+    public static String extractDirNameFromAbsolutePath(String path) {
+        // default is unix so try with '/'
+        // otherwise force File.separator
+        if (path.endsWith(""/"") || path.endsWith(File.separator)) {
+            path = path.substring(0, path.length() - 1);
+        }
+        int startIndex = path.lastIndexOf(File.separator);
+        if (startIndex == -1) {
+            startIndex = path.lastIndexOf(""/"");
+        }
+        return path.substring(startIndex + 1, path.length());","[{'comment': 'If there is no slash then start index is -1 and then I think we should make it more clear that we dont substring it then, eg\r\n\r\nif (startIndex != -1) {\r\n   ..\r\n} else {\r\n   // no directory then return file as-is\r\n   return path;\r\n}', 'commenter': 'davsclaus'}, {'comment': 'Also there is a stripPath method from FileUtil you can use for the last part: org.apache.camel.util.FileUtil#stripPath', 'commenter': 'davsclaus'}]"
1948,components/camel-ftp/src/main/java/org/apache/camel/component/file/remote/FtpConfiguration.java,"@@ -35,6 +35,8 @@
     private String activePortRange;
     @UriParam(label = ""producer,advanced"")
     private String chmod;
+    @UriParam(label = ""consumer,advanced"")
+    private boolean isDirectoryParseResultAbsolute;","[{'comment': 'dont use isXXX as the name. Naming in IT is hard, and to come up with a good name.\r\nMaybe the name should be something like `handleDirectoryParserAbsoluteResult` ?', 'commenter': 'davsclaus'}]"
1948,components/camel-ftp/src/main/java/org/apache/camel/component/file/remote/FtpConfiguration.java,"@@ -83,4 +85,16 @@ public void setChmod(String chmod) {
     public String getChmod() {
         return chmod;
     }
+
+    public boolean isDirectoryParseResultAbsolute() {
+        return isDirectoryParseResultAbsolute;
+    }
+
+    /**
+     * Allows you to set how the consumer will handle subfolders and files
+     * in the path if the directory parser results in with absolute paths","[{'comment': 'Maybe add a comment: Some FTP servers may return file names with absolute paths, and if so then the FTP component needs to handle this by converting the returned path into a relative path.', 'commenter': 'davsclaus'}]"
1954,components/camel-bindy/src/main/java/org/apache/camel/dataformat/bindy/BindyCsvFactory.java,"@@ -225,6 +228,44 @@ public void bind(List<String> tokens, Map<String, Object> model, int line) throw
                     value = getDefaultValueForPrimitive(field.getType());
                 }
             }
+            
+            if (value != null && !dataField.function().isEmpty()) {
+                Class<?> clazz;
+                Class paramType = field.getType();
+                if (dataField.function().contains(""."")) {
+                    ClassResolver cr = new DefaultClassResolver();","[{'comment': 'You need to use the ClassResolver you can get from `CamelContext` and not just create a new instance yourself', 'commenter': 'davsclaus'}, {'comment': 'This led me to add camelContext as a param to BindyFactory. Could you check if it would be OK?', 'commenter': 'onderson'}]"
1954,components/camel-bindy/src/main/docs/bindy-dataformat.adoc,"@@ -60,13 +60,13 @@ The Bindy dataformat supports 4 options which are listed below.
 
 
 [width=""100%"",cols=""2s,1m,1m,6"",options=""header""]
-|===
+|=======================================================================","[{'comment': 'Rebuild all the project so the docs are not changed, the tooling generate the docs a bit different now', 'commenter': 'davsclaus'}, {'comment': 'It take much time on my PC. Reverted doc update which already popped up due to local build.', 'commenter': 'onderson'}]"
1954,components/camel-bindy/src/main/java/org/apache/camel/dataformat/bindy/BindyCsvFactory.java,"@@ -225,6 +228,44 @@ public void bind(List<String> tokens, Map<String, Object> model, int line) throw
                     value = getDefaultValueForPrimitive(field.getType());
                 }
             }
+            
+            if (value != null && !dataField.function().isEmpty()) {
+                Class<?> clazz;
+                Class paramType = field.getType();
+                if (dataField.function().contains(""."")) {
+                    ClassResolver cr = new DefaultClassResolver();
+                    clazz = cr.resolveMandatoryClass(dataField.function().substring(0, dataField.function().lastIndexOf(""."")));
+                } else {
+                    clazz = field.getType();
+                }
+                boolean isMethodFound = false;
+                int numOfMethodParams = 0;
+                Method m = null;
+                String methodName = dataField.function().substring(dataField.function().lastIndexOf(""."") + 1,
+                                                                   dataField.function().length());
+                Method[] mList = clazz.getDeclaredMethods();","[{'comment': 'There is a findMethod on ReflectionHelper from camel-core that is maybe a bit better to find the method, you can then try to find with parameter, and then fallback to without a parameter. Also ObjectHelper has a invokeMethod method that deals with exception for you.', 'commenter': 'davsclaus'}, {'comment': 'Could you check once again?', 'commenter': 'onderson'}]"
1954,components/camel-bindy/src/test/java/org/apache/camel/dataformat/bindy/csv/BindySimpleCsvFunctionWithClassMethodTest.java,"@@ -0,0 +1,123 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.dataformat.bindy.csv;
+
+import java.io.Serializable;
+import java.math.BigDecimal;
+
+import org.apache.camel.EndpointInject;
+import org.apache.camel.RoutesBuilder;
+import org.apache.camel.builder.RouteBuilder;
+import org.apache.camel.component.mock.MockEndpoint;
+import org.apache.camel.dataformat.bindy.annotation.CsvRecord;
+import org.apache.camel.dataformat.bindy.annotation.DataField;
+import org.apache.camel.dataformat.bindy.util.ConverterUtils;
+import org.apache.camel.test.junit4.CamelTestSupport;
+import org.junit.Test;
+
+public class BindySimpleCsvFunctionWithClassMethodTest extends CamelTestSupport {
+    
+    @EndpointInject(uri = ""mock:resultMarshal1"")
+    private MockEndpoint mockEndPointMarshal1;
+    
+    @EndpointInject(uri = ""mock:resultUnMarshal1"")
+    private MockEndpoint mockEndPointUnMarshal1;
+    
+    @EndpointInject(uri = ""mock:resultMarshal2"")
+    private MockEndpoint mockEndPointMarshal2;
+    
+    @EndpointInject(uri = ""mock:resultUnMarshal2"")
+    private MockEndpoint mockEndPointUnMarshal2;
+    
+    @Test
+    public void testUnMarshallMessage() throws Exception {
+
+        mockEndPointMarshal1.expectedMessageCount(1);
+        mockEndPointMarshal1.expectedBodiesReceived(""\""123\"",\""\""\""foo\""\""\"",\""10\"""" + ConverterUtils.getStringCarriageReturn(""WINDOWS""));
+
+        BindyCsvRowFormat7621 body = new BindyCsvRowFormat7621();
+        body.setFirstField(""123"");
+        body.setSecondField(""\""\""foo\""\"""");
+        body.setNumber(new BigDecimal(10));
+        template.sendBody(""direct:startMarshal1"", body);
+        
+        assertMockEndpointsSatisfied();
+        
+        BindyCsvRowFormat7621 model = mockEndPointUnMarshal1.getReceivedExchanges().get(0).getIn().getBody(BindyCsvRowFormat7621.class);
+        
+        assertEquals(""123"", model.getFirstField());
+        assertEquals(""\""\""FOO\""\"""", model.getSecondField());
+        assertEquals(new BigDecimal(10), model.getNumber());
+    }
+
+    @Override
+    protected RoutesBuilder createRouteBuilder() throws Exception {
+        return new RouteBuilder() {
+            @Override
+            public void configure() throws Exception {
+                BindyCsvDataFormat camelDataFormat1 =
+                    new BindyCsvDataFormat(BindyCsvRowFormat7621.class);
+                
+                from(""direct:startMarshal1"")
+                    .marshal(camelDataFormat1)
+                    .to(""mock:resultMarshal1"")
+                    .to(""direct:middle1"");
+                
+                from(""direct:middle1"")
+                    .unmarshal(camelDataFormat1)
+                    .to(""mock:resultUnMarshal1"");
+            }
+        };
+    }
+
+    @CsvRecord(separator = "","", quote = ""\"""", quoting = true, quotingEscaped = false)
+    public static class BindyCsvRowFormat7621 implements Serializable {
+
+        @DataField(pos = 1)
+        private String firstField;
+
+        @DataField(pos = 2, function = ""toUpperCase"")","[{'comment': ""Maybe it should be called `method` or `methodCall` instead of `function` as its not really a function, its calling a method. Users may think a function you can do more like `if $it == 2 ? 'two' : 'not two'` etc."", 'commenter': 'davsclaus'}, {'comment': 'Yes, your suggestion is better. Updated.', 'commenter': 'onderson'}]"
1954,components/camel-bindy/src/main/java/org/apache/camel/dataformat/bindy/annotation/DataField.java,"@@ -146,4 +146,9 @@
      */
      String rounding() default ""CEILING"";
 
+     /**
+      * Method name to call to apply such customization
+      * on DataField","[{'comment': 'Add explanation that if you provide a FQN class name then its invoking that method (and it must be a static method) and if you do not provide a FQN its invoking the method on the value itself, eg toUpperCase on a String value etc.', 'commenter': 'davsclaus'}, {'comment': 'tried to address', 'commenter': 'onderson'}]"
1990,components/camel-dropbox/src/main/java/org/apache/camel/component/dropbox/core/DropboxAPIFacade.java,"@@ -54,37 +62,39 @@
 
     private static final Logger LOG = LoggerFactory.getLogger(DropboxAPIFacade.class);
 
-    private final DbxClient client;
+    private final DbxClientV2 client;
 
     private final Exchange exchange;
 
     /**
      * @param client the DbxClient performing dropbox low level operations
      * @param exchange the current Exchange
      */
-    public DropboxAPIFacade(DbxClient client, Exchange exchange) {
+    public DropboxAPIFacade(DbxClientV2 client, Exchange exchange) {
         this.client = client;
         this.exchange = exchange;
     }
 
     /**
      * Put or upload a new file or an entire directory to dropbox
-     * @param localPath  the file path or the dir path on the local filesystem
+     *
+     * @param localPath the file path or the dir path on the local filesystem
      * @param remotePath the remote path destination on dropbox
-     * @param mode how a file should be saved on dropbox;
-     *             in case of ""add"" the new file will be renamed in case
-     *             a file with the same name already exists on dropbox.
-     *             in case of ""force"" the file already existing with the same name will be overridden.
-     * @return a result object reporting for each remote path the result of the operation.
+     * @param mode how a file should be saved on dropbox; in case of ""add"" the
+     *            new file will be renamed in case a file with the same name
+     *            already exists on dropbox. in case of ""force"" the file already
+     *            existing with the same name will be overridden.
+     * @return a result object reporting for each remote path the result of the
+     *         operation.
      * @throws DropboxException
      */
     public DropboxFileUploadResult put(String localPath, String remotePath, DropboxUploadMode mode) throws DropboxException {
-        //in case the remote path is not specified, the remotePath = localPath
+        // in case the remote path is not specified, the remotePath = localPath
         String dropboxPath = remotePath == null ? localPath : remotePath;
 
-        DbxEntry entry;
+        UploadUploader entry;
         try {
-            entry = client.getMetadata(dropboxPath);
+            entry = client.files().upload(localPath);","[{'comment': 'Should be `dropboxPath`', 'commenter': 'davsclaus'}, {'comment': 'Ack, done the changes..', 'commenter': 'vrlgohel'}]"
1990,components/camel-dropbox/src/main/java/org/apache/camel/component/dropbox/core/DropboxAPIFacade.java,"@@ -96,15 +106,16 @@ public DropboxFileUploadResult put(String localPath, String remotePath, DropboxU
         }
     }
 
-    private DropboxFileUploadResult putFile(String localPath, DropboxUploadMode mode, String dropboxPath, DbxEntry entry) throws DropboxException {
+    private DropboxFileUploadResult putFile(String localPath, DropboxUploadMode mode, String dropboxPath, UploadUploader entry) throws DropboxException {
         File fileLocalPath = new File(localPath);
-        //verify uploading of a single file
+        // verify uploading of a single file
         if (fileLocalPath.isFile()) {
-            //check if dropbox file exists
-            if (entry != null && !entry.isFile()) {
+            // check if dropbox file exists","[{'comment': ""We don't know if the entry is a file or not, so we may have to remove this check"", 'commenter': 'davsclaus'}, {'comment': 'Well, if we are removing this, we will need to remove the \'entry\' checks, meaning remove these check code entirely ?\r\n\r\n// check if dropbox file exists\r\n            if (entry != null) {\r\n                throw new DropboxException(dropboxPath + "" exists on dropbox and is not a file!"");\r\n            }\r\n            // in case the entry not exists on dropbox check if the filename\r\n            // should be appended\r\n            if (entry == null) {\r\n                if (dropboxPath.endsWith(DropboxConstants.DROPBOX_FILE_SEPARATOR)) {\r\n                    dropboxPath = dropboxPath + fileLocalPath.getName();\r\n                }\r\n            }', 'commenter': 'vrlgohel'}]"
1990,components/camel-dropbox/src/main/java/org/apache/camel/component/dropbox/core/DropboxAPIFacade.java,"@@ -125,18 +136,18 @@ private DropboxFileUploadResult putFile(String localPath, DropboxUploadMode mode
             }
             return result;
         } else if (fileLocalPath.isDirectory()) {
-            //verify uploading of a list of files inside a dir
+            // verify uploading of a list of files inside a dir
             LOG.debug(""Uploading a dir..."");
-            //check if dropbox folder exists
-            if (entry != null && !entry.isFolder()) {
+            // check if dropbox folder exists","[{'comment': 'Should likely be removed as we dont know if the entry is folder or file', 'commenter': 'davsclaus'}, {'comment': 'As i understand, this can be removed, completely.\r\n\r\n if (entry != null) {\r\n                throw new DropboxException(dropboxPath + "" exists on dropbox and is not a folder!"");\r\n            }', 'commenter': 'vrlgohel'}]"
1990,components/camel-dropbox/src/main/java/org/apache/camel/component/dropbox/core/DropboxAPIFacade.java,"@@ -204,80 +216,86 @@ private DropboxFileUploadResult putBody(Exchange exchange, DropboxUploadMode mod
         return result;
     }
 
-    private DbxEntry.File putSingleFile(File inputFile, String dropboxPath, DropboxUploadMode mode) throws Exception {
+    private FileMetadata putSingleFile(File inputFile, String dropboxPath, DropboxUploadMode mode) throws Exception {
         FileInputStream inputStream = new FileInputStream(inputFile);
-        DbxEntry.File uploadedFile;
+        FileMetadata uploadedFile;
         try {
-            DbxWriteMode uploadMode;
+            WriteMode uploadMode;
             if (mode == DropboxUploadMode.force) {
-                uploadMode = DbxWriteMode.force();
+                uploadMode = WriteMode.OVERWRITE;
             } else {
-                uploadMode = DbxWriteMode.add();
+                uploadMode = WriteMode.ADD;
             }
-            uploadedFile = client.uploadFile(dropboxPath, uploadMode, inputFile.length(), inputStream);
+            uploadedFile = client.files().upload(dropboxPath).uploadAndFinish(inputStream, inputFile.length());","[{'comment': 'Use `uploadBuilder` which allows to use the uploadMode', 'commenter': 'davsclaus'}, {'comment': 'Done with the changes..', 'commenter': 'vrlgohel'}]"
1990,components/camel-dropbox/src/main/java/org/apache/camel/component/dropbox/core/DropboxAPIFacade.java,"@@ -204,80 +216,86 @@ private DropboxFileUploadResult putBody(Exchange exchange, DropboxUploadMode mod
         return result;
     }
 
-    private DbxEntry.File putSingleFile(File inputFile, String dropboxPath, DropboxUploadMode mode) throws Exception {
+    private FileMetadata putSingleFile(File inputFile, String dropboxPath, DropboxUploadMode mode) throws Exception {
         FileInputStream inputStream = new FileInputStream(inputFile);
-        DbxEntry.File uploadedFile;
+        FileMetadata uploadedFile;
         try {
-            DbxWriteMode uploadMode;
+            WriteMode uploadMode;
             if (mode == DropboxUploadMode.force) {
-                uploadMode = DbxWriteMode.force();
+                uploadMode = WriteMode.OVERWRITE;
             } else {
-                uploadMode = DbxWriteMode.add();
+                uploadMode = WriteMode.ADD;
             }
-            uploadedFile = client.uploadFile(dropboxPath, uploadMode, inputFile.length(), inputStream);
+            uploadedFile = client.files().upload(dropboxPath).uploadAndFinish(inputStream, inputFile.length());
             return uploadedFile;
         } finally {
             IOHelper.close(inputStream);
         }
     }
 
-    private DbxEntry.File putSingleBody(Exchange exchange, String dropboxPath, DropboxUploadMode mode) throws Exception {
+    private FileMetadata putSingleBody(Exchange exchange, String dropboxPath, DropboxUploadMode mode) throws Exception {
         byte[] data = exchange.getIn().getMandatoryBody(byte[].class);
         InputStream is = new ByteArrayInputStream(data);
         try {
-            DbxEntry.File uploadedFile;
-            DbxWriteMode uploadMode;
+            FileMetadata uploadedFile;
+            WriteMode uploadMode;
             if (mode == DropboxUploadMode.force) {
-                uploadMode = DbxWriteMode.force();
+                uploadMode = WriteMode.OVERWRITE;
             } else {
-                uploadMode = DbxWriteMode.add();
+                uploadMode = WriteMode.ADD;
             }
-            uploadedFile = client.uploadFile(dropboxPath, uploadMode, data.length, is);
+            uploadedFile = client.files().upload(dropboxPath).uploadAndFinish(is, data.length);","[{'comment': 'Use uploadBuilder which allows to use the uploadMode', 'commenter': 'davsclaus'}, {'comment': 'Ack, done ', 'commenter': 'vrlgohel'}]"
1990,components/camel-dropbox/src/main/java/org/apache/camel/component/dropbox/core/DropboxAPIFacade.java,"@@ -302,53 +321,37 @@ public DropboxMoveResult move(String remotePath, String newRemotePath) throws Dr
 
     /**
      * Get the content of every file inside the remote path.
+     *
      * @param remotePath the remote path where to download from
-     * @return a result object with the content (ByteArrayOutputStream) of every files inside the remote path.
+     * @return a result object with the content (ByteArrayOutputStream) of every
+     *         files inside the remote path.
      * @throws DropboxException
      */
     public DropboxFileDownloadResult get(String remotePath) throws DropboxException {
         return new DropboxFileDownloadResult(downloadFilesInFolder(remotePath));
     }
 
-    /**
-     * @deprecated not in use
-     */
-    @Deprecated
-    public boolean isDirectory(String path) throws DropboxException {
-        try {
-            DbxEntry.WithChildren listing = client.getMetadataWithChildren(path);
-            return listing.children != null;
-        } catch (DbxException e) {
-            throw new DropboxException(path + "" does not exist or can't obtain metadata"");
-        }
-    }
-
-
     private Map<String, Object> downloadFilesInFolder(String path) throws DropboxException {
         try {
-            DbxEntry.WithChildren listing = client.getMetadataWithChildren(path);
-            if (listing == null) {
-                return Collections.emptyMap();
-            } else if (listing.children == null) {
-                LOG.debug(""downloading a single file..."");
-                Map.Entry<String, Object> entry = downloadSingleFile(path);
-                return Collections.singletonMap(entry.getKey(), entry.getValue());
+            ListFolderResult folderResult = client.files().listFolder(path.equals(""/"") ? """" : path);
+            Map<String, Object> returnMap = new LinkedHashMap<>();
+            for (Metadata entry : folderResult.getEntries()) {
+                returnMap.put(entry.getPathDisplay(), downloadSingleFile(entry.getPathDisplay()).getValue());
             }
-            Map<String, Object> result = new HashMap<>();
-            for (DbxEntry entry : listing.children) {
-                if (entry.isFile()) {
-                    try {
-                        Map.Entry<String, Object> singleFile = downloadSingleFile(entry.path);
-                        result.put(singleFile.getKey(), singleFile.getValue());
-                    } catch (DropboxException e) {
-                        LOG.warn(""Cannot download from path={}, reason={}. This exception is ignored."", entry.path, e.getMessage());
-                    }
+            return returnMap;
+        } catch (ListFolderErrorException e) {","[{'comment': 'Can you explain why you catch this exception and then try again?', 'commenter': 'davsclaus'}, {'comment': ""This was based on my suggestion. I tried different ways but we don't have the method to get metadata that comes with a flag to fulfill isFile/isDirectory. It assumes you know what you are trying to get. \r\nSo the idea is to run listFolder, and if you get that Exception, the folder doesn't exist or it's a file.\r\nIt could be replaced by a new parameter and avoid the try/catch, but that would break current folder endpoints.\r\n\r\nI agree that this should be released in the next iteration. V1 was retired and the released component is completely broken.\r\n\r\nIf you guys need something, let me know."", 'commenter': 'bvolpato'}, {'comment': 'Thank you very much for the explanation. So lets go with this. And we can add a code comment that this code is on purpose.', 'commenter': 'davsclaus'}]"
2011,components/camel-box/camel-box-api/src/main/java/org/apache/camel/component/box/api/BoxFoldersManager.java,"@@ -189,6 +189,43 @@ public BoxFolder createFolder(String parentFolderId, String folderName) {
     }
 
     /**
+     * Create a folder specified by path from parent folder with given <code>parentFolderId</code>,
+     * creating intermediate directories as required.
+     *
+     * @param parentFolderId
+     *            - the id of parent folder.
+     * @param path
+     *            - Sequence of Box folder names from parent folder to returned
+     *            folder.
+     * @return The last folder in path, no fault will be thrown if it already exists.
+     */
+    public BoxFolder createFolder(String parentFolderId, String... path) {
+        try {
+            LOG.debug(""Creating folder with path '"" + path + ""' in parent_folder(id="" + parentFolderId + "")"");
+            if (parentFolderId == null) {
+                throw new IllegalArgumentException(""Parameter 'parentFolderId' can not be null"");
+            }
+            if (path == null) {
+                throw new IllegalArgumentException(""Paramerer 'path' can not be null"");
+            }
+            BoxFolder folder = new BoxFolder(boxConnection, parentFolderId);
+            searchPath: for (int folderIndex = 0; folderIndex < path.length; folderIndex++) {","[{'comment': ""Can we avoid using a goto via label, as its not as good to maintain - and we don't really use them in the other components."", 'commenter': 'davsclaus'}, {'comment': ""Absolutely, I just handled it the same way as was done previously in the same code base, but I'll revise."", 'commenter': 'fjollberg'}, {'comment': ""Ah okay didnt spot that, but we shouldn't rely on goto's so it would be good to fix anyway."", 'commenter': 'davsclaus'}]"
2011,components/camel-box/camel-box-api/src/main/java/org/apache/camel/component/box/api/BoxFoldersManager.java,"@@ -189,6 +189,43 @@ public BoxFolder createFolder(String parentFolderId, String folderName) {
     }
 
     /**
+     * Create a folder specified by path from parent folder with given <code>parentFolderId</code>,
+     * creating intermediate directories as required.
+     *
+     * @param parentFolderId
+     *            - the id of parent folder.
+     * @param path
+     *            - Sequence of Box folder names from parent folder to returned
+     *            folder.
+     * @return The last folder in path, no fault will be thrown if it already exists.
+     */
+    public BoxFolder createFolder(String parentFolderId, String... path) {
+        try {
+            LOG.debug(""Creating folder with path '"" + path + ""' in parent_folder(id="" + parentFolderId + "")"");","[{'comment': 'Use `{}` placeholders in the logger instead of `+` concat', 'commenter': 'davsclaus'}, {'comment': 'Also do the validation first, and then the log afterwards', 'commenter': 'davsclaus'}, {'comment': ""Absolutely, I just handled it the same way as was done previously in the same code base, but I'll revise."", 'commenter': 'fjollberg'}]"
2013,platforms/spring-boot/components-starter/pom.xml,"@@ -286,6 +287,7 @@
     <module>camel-spring-boot-starter</module>
     <module>camel-spring-cloud-netflix-starter</module>
     <module>camel-spring-cloud-starter</module>
+    <module>camel-spring-dm-starter</module>","[{'comment': 'I guess this one is not needed, maybe you still have the folder in your repo.', 'commenter': 'oscerd'}, {'comment': 'Yeah he didnt run git clean -d -f, anyway if you regen the project it will go away', 'commenter': 'davsclaus'}, {'comment': '@davsclaus  what do you mean by regen the project, is this a speciel maven cmd?', 'commenter': 'fharms'}]"
2013,parent/pom.xml,"@@ -200,8 +200,9 @@
     <elasticsearch-bundle-version>2.4.4_1</elasticsearch-bundle-version>
     <elasticsearch-guava-version>18.0</elasticsearch-guava-version>
     <elasticsearch-version>2.4.4</elasticsearch-version>
-    <elasticsearch5-version>5.5.2</elasticsearch5-version>
-    <elasticsearch5-bundle-version>5.5.2_1</elasticsearch5-bundle-version>
+    <elasticsearch5-version>5.6.1</elasticsearch5-version>
+    <elasticsearch-sniffer-version>5.6.2</elasticsearch-sniffer-version>
+    <elasticsearch5-bundle-version>5.6.2_1</elasticsearch5-bundle-version>","[{'comment': ""Actually this bundle doesn't exist"", 'commenter': 'oscerd'}]"
2013,components/camel-elasticsearch5-rest/pom.xml,"@@ -0,0 +1,102 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>","[{'comment': 'You need ASF license header', 'commenter': 'davsclaus'}]"
2013,components/camel-elasticsearch5-rest/pom.xml,"@@ -0,0 +1,102 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>org.apache.camel</groupId>
+    <artifactId>components</artifactId>
+    <version>2.20.0-SNAPSHOT</version>
+  </parent>
+
+  <groupId>org.apache.camel</groupId>
+  <artifactId>camel-elasticsearch5-rest</artifactId>
+  <packaging>jar</packaging>
+  <name>Camel :: ElasticSearch5 :: REST</name>
+  <description>Camel ElasticSearch 5.x REST support</description>
+
+  <properties>
+    <elasticsearch.version>${elasticsearch5-version}</elasticsearch.version>
+    <camel.osgi.export.pkg>org.apache.camel.component.elasticsearch5.*;${camel.osgi.version}</camel.osgi.export.pkg>
+    <camel.osgi.export.service>org.apache.camel.spi.ComponentResolver;component=elasticsearch5</camel.osgi.export.service>","[{'comment': 'The name should not clash with the other, eg should be `elasticsearch5-rest` or `elasticsearch-rest`', 'commenter': 'davsclaus'}]"
2013,components/camel-elasticsearch5-rest/src/main/java/org/apache/camel/component/elasticsearch5/ElasticsearchEndpoint.java,"@@ -0,0 +1,63 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.elasticsearch5;
+
+import org.apache.camel.Consumer;
+import org.apache.camel.Processor;
+import org.apache.camel.Producer;
+import org.apache.camel.impl.DefaultEndpoint;
+import org.apache.camel.spi.UriEndpoint;
+import org.apache.camel.spi.UriParam;
+import org.elasticsearch.client.RestClient;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * The elasticsearch component is used for interfacing with ElasticSearch server using 5.x REST API.
+ */
+@UriEndpoint(firstVersion = ""2.21.0"", scheme = ""elasticsearch5-rest"", title = ""Elasticsearch5-rest"", syntax = ""elasticsearch5-rest:clusterName"", producerOnly = true, label = ""monitoring,search"")
+public class ElasticsearchEndpoint extends DefaultEndpoint {
+
+    private static final Logger LOG = LoggerFactory.getLogger(ElasticsearchEndpoint.class);","[{'comment': 'The LOG is not in use', 'commenter': 'davsclaus'}]"
2013,components/camel-elasticsearch5-rest/src/main/java/org/apache/camel/component/elasticsearch5/ElasticsearchOperation.java,"@@ -0,0 +1,55 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.elasticsearch5;
+
+/**
+ * The ElasticSearch server operations list which are implemented
+ * 
+ * INDEX        - Index a document associated with a given index and type
+ * UPDATE       - Updates a document based on a script
+ * BULK         - Executes a bulk of index / delete operations
+ * BULK_INDEX   - Executes a bulk of index / delete operations
+ * GET_BY_ID    - Gets the document that was indexed from an index with a type and id
+ * MULTIGET     - Multiple get documents
+ * DELETE       - Deletes a document from the index based on the index, type and id
+ * SEARCH       - Search across one or more indices and one or more types with a query
+ * EXISTS       - Checks the index exists or not (using search with size=0 and terminate_after=1 parameters)
+ * 
+ */
+public enum ElasticsearchOperation {","[{'comment': 'I wonder if we should make these in Camel case so they are more readable? GetById, DeleteIndex ', 'commenter': 'davsclaus'}]"
2013,components/camel-elasticsearch5-rest/src/main/java/org/apache/camel/component/elasticsearch5/ElasticsearchProducer.java,"@@ -0,0 +1,295 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.elasticsearch5;
+
+import java.lang.reflect.InvocationTargetException;
+import java.net.UnknownHostException;
+import java.util.ArrayList;
+import java.util.List;
+
+import org.apache.camel.Exchange;
+import org.apache.camel.Message;
+import org.apache.camel.impl.DefaultProducer;
+import org.apache.http.HttpHost;
+import org.apache.http.auth.AuthScope;
+import org.apache.http.auth.UsernamePasswordCredentials;
+import org.apache.http.client.CredentialsProvider;
+import org.apache.http.impl.client.BasicCredentialsProvider;
+import org.elasticsearch.ElasticsearchStatusException;
+import org.elasticsearch.action.admin.indices.delete.DeleteIndexRequest;
+import org.elasticsearch.action.bulk.BulkItemResponse;
+import org.elasticsearch.action.bulk.BulkRequest;
+import org.elasticsearch.action.delete.DeleteRequest;
+import org.elasticsearch.action.get.GetRequest;
+import org.elasticsearch.action.get.MultiGetRequest;
+import org.elasticsearch.action.index.IndexRequest;
+import org.elasticsearch.action.search.SearchRequest;
+import org.elasticsearch.action.update.UpdateRequest;
+import org.elasticsearch.client.RestClient;
+import org.elasticsearch.client.RestClientBuilder;
+import org.elasticsearch.client.RestHighLevelClient;
+import org.elasticsearch.client.sniff.Sniffer;
+import org.elasticsearch.client.sniff.SnifferBuilder;
+import org.elasticsearch.rest.RestStatus;
+import org.elasticsearch.search.builder.SearchSourceBuilder;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+
+/**
+ * Represents an Elasticsearch producer.
+ */
+public class ElasticsearchProducer extends DefaultProducer {
+
+    private static final Logger LOG = LoggerFactory.getLogger(ElasticsearchProducer.class);
+
+    protected final ElasticsearchConfiguration configuration;
+    private RestClient client;
+    private Sniffer sniffer;
+
+    public ElasticsearchProducer(ElasticsearchEndpoint endpoint, ElasticsearchConfiguration configuration) {
+        super(endpoint);
+        this.configuration = configuration;
+        this.client = endpoint.getClient();
+    }
+
+    private ElasticsearchOperation resolveOperation(Exchange exchange) {
+        // 1. Operation can be driven by either (in order of preference):
+        // a. If the body is an ActionRequest the operation is set by the type
+        // of request.
+        // b. If the body is not an ActionRequest, the operation is set by the
+        // header if it exists.
+        // c. If neither the operation can not be derived from the body or
+        // header, the configuration is used.
+        // In the event we can't discover the operation from a, b or c we throw
+        // an error.
+        Object request = exchange.getIn().getBody();
+        if (request instanceof IndexRequest) {
+            return ElasticsearchOperation.INDEX;
+        } else if (request instanceof GetRequest) {
+            return ElasticsearchOperation.GET_BY_ID;
+        } else if (request instanceof MultiGetRequest) {
+            return ElasticsearchOperation.MULTIGET;
+        } else if (request instanceof UpdateRequest) {
+            return ElasticsearchOperation.UPDATE;
+        } else if (request instanceof BulkRequest) {
+            // do we want bulk or bulk_index?
+            if (configuration.getOperation() == ElasticsearchOperation.BULK_INDEX) {
+                return configuration.getOperation().BULK_INDEX;
+            } else {
+                return configuration.getOperation().BULK;
+            }
+        } else if (request instanceof DeleteRequest) {
+            return ElasticsearchOperation.DELETE;
+        } else if (request instanceof SearchRequest) {
+            return ElasticsearchOperation.SEARCH;
+        } else if (request instanceof DeleteIndexRequest) {
+            return ElasticsearchOperation.DELETE_INDEX;
+        }
+
+        ElasticsearchOperation operationConfig = exchange.getIn().getHeader(ElasticsearchConstants.PARAM_OPERATION, ElasticsearchOperation.class);
+        if (operationConfig == null) {
+            operationConfig = configuration.getOperation();
+        }
+        if (operationConfig == null) {
+            throw new IllegalArgumentException(ElasticsearchConstants.PARAM_OPERATION + "" value '"" + operationConfig + ""' is not supported"");
+        }
+        return operationConfig;
+    }
+
+    public void process(Exchange exchange) throws Exception {
+        if (configuration.getDisconnect() && client == null) {
+            startClient();
+        }
+        RestHighLevelClient restHighLevelClient = new RestHighLevelClient(client);
+        // 2. Index and type will be set by:
+        // a. If the incoming body is already an action request
+        // b. If the body is not an action request we will use headers if they
+        // are set.
+        // c. If the body is not an action request and the headers aren't set we
+        // will use the configuration.
+        // No error is thrown by the component in the event none of the above
+        // conditions are met. The java es client
+        // will throw.
+
+        Message message = exchange.getIn();
+        final ElasticsearchOperation operation = resolveOperation(exchange);
+
+        // Set the index/type headers on the exchange if necessary. This is used
+        // for type conversion.
+        boolean configIndexName = false;
+        String indexName = message.getHeader(ElasticsearchConstants.PARAM_INDEX_NAME, String.class);
+        if (indexName == null) {
+            message.setHeader(ElasticsearchConstants.PARAM_INDEX_NAME, configuration.getIndexName());
+            configIndexName = true;
+        }
+
+        boolean configIndexType = false;
+        String indexType = message.getHeader(ElasticsearchConstants.PARAM_INDEX_TYPE, String.class);
+        if (indexType == null) {
+            message.setHeader(ElasticsearchConstants.PARAM_INDEX_TYPE, configuration.getIndexType());
+            configIndexType = true;
+        }
+
+        boolean configWaitForActiveShards = false;
+        Integer waitForActiveShards = message.getHeader(ElasticsearchConstants.PARAM_WAIT_FOR_ACTIVE_SHARDS, Integer.class);
+        if (waitForActiveShards == null) {
+            message.setHeader(ElasticsearchConstants.PARAM_WAIT_FOR_ACTIVE_SHARDS, configuration.getWaitForActiveShards());
+            configWaitForActiveShards = true;
+        }
+
+        if (operation == ElasticsearchOperation.INDEX) {
+            IndexRequest indexRequest = message.getBody(IndexRequest.class);
+            message.setBody(restHighLevelClient.index(indexRequest).getId());
+        } else if (operation == ElasticsearchOperation.UPDATE) {
+            UpdateRequest updateRequest = message.getBody(UpdateRequest.class);
+            message.setBody(restHighLevelClient.update(updateRequest).getId());
+        } else if (operation == ElasticsearchOperation.GET_BY_ID) {
+            GetRequest getRequest = message.getBody(GetRequest.class);
+            message.setBody(restHighLevelClient.get(getRequest));
+        } else if (operation == ElasticsearchOperation.BULK) {
+            BulkRequest bulkRequest = message.getBody(BulkRequest.class);
+            message.setBody(restHighLevelClient.bulk(bulkRequest).getItems());
+        } else if (operation == ElasticsearchOperation.BULK_INDEX) {
+            BulkRequest bulkRequest = message.getBody(BulkRequest.class);
+            List<String> indexedIds = new ArrayList<>();
+            for (BulkItemResponse response : restHighLevelClient.bulk(bulkRequest).getItems()) {
+                indexedIds.add(response.getId());
+            }
+            message.setBody(indexedIds);
+        } else if (operation == ElasticsearchOperation.DELETE) {
+            DeleteRequest deleteRequest = message.getBody(DeleteRequest.class);
+            message.setBody(restHighLevelClient.delete(deleteRequest).getResult());
+        } else if (operation == ElasticsearchOperation.DELETE_INDEX) {
+            DeleteRequest deleteRequest = message.getBody(DeleteRequest.class);
+            message.setBody(client.performRequest(""DELETE"", deleteRequest.index()).getStatusLine().getStatusCode());
+        } else if (operation == ElasticsearchOperation.EXISTS) {
+            // ExistsRequest API is deprecated, using SearchRequest instead with size=0 and terminate_after=1
+            SearchSourceBuilder sourceBuilder = new SearchSourceBuilder();
+            sourceBuilder.size(0);
+            sourceBuilder.terminateAfter(1);
+            SearchRequest searchRequest = new SearchRequest(exchange.getIn().getHeader(ElasticsearchConstants.PARAM_INDEX_NAME, String.class));
+            searchRequest.source(sourceBuilder);
+            try {
+                restHighLevelClient.search(searchRequest);
+                message.setBody(true);
+            } catch (ElasticsearchStatusException e) {
+                if (e.status().equals(RestStatus.NOT_FOUND)) {
+                    message.setBody(false);
+                } else {
+                    throw new IllegalStateException(e);
+                }
+
+            }
+        } else if (operation == ElasticsearchOperation.SEARCH) {
+            SearchRequest searchRequest = message.getBody(SearchRequest.class);
+            message.setBody(restHighLevelClient.search(searchRequest).getHits());
+        } else {
+            throw new IllegalArgumentException(ElasticsearchConstants.PARAM_OPERATION + "" value '"" + operation + ""' is not supported"");
+        }
+
+        // If we set params via the configuration on this exchange, remove them
+        // now. This preserves legacy behavior for this component and enables a
+        // use case where one message can be sent to multiple elasticsearch
+        // endpoints where the user is relying on the endpoint configuration
+        // (index/type) rather than header values. If we do not clear this out
+        // sending the same message (index request, for example) to multiple
+        // elasticsearch endpoints would have the effect overriding any
+        // subsequent endpoint index/type with the first endpoint index/type.
+        if (configIndexName) {
+            message.removeHeader(ElasticsearchConstants.PARAM_INDEX_NAME);
+        }
+
+        if (configIndexType) {
+            message.removeHeader(ElasticsearchConstants.PARAM_INDEX_TYPE);
+        }
+
+        if (configWaitForActiveShards) {
+            message.removeHeader(ElasticsearchConstants.PARAM_WAIT_FOR_ACTIVE_SHARDS);
+        }
+        if (configuration.getDisconnect()) {
+            client.close();
+            client = null;
+            if (configuration.getEnableSniffer()) {
+                sniffer.close();
+                sniffer = null;
+            }
+        }
+
+    }
+
+    @Override
+    @SuppressWarnings(""unchecked"")
+    protected void doStart() throws Exception {
+        super.doStart();
+        if (!configuration.getDisconnect()) {
+            startClient();
+        }
+    }
+
+    private void startClient() throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, UnknownHostException {
+        if (client == null) {
+            LOG.info(""Connecting to the ElasticSearch cluster: "" + configuration.getClusterName());
+            if (configuration.getHostAddressesList() != null
+                && !configuration.getHostAddressesList().isEmpty()) {
+                client = createClient();
+            } else {
+                LOG.info(""Incorrect ip address and port parameters settings for ElasticSearch cluster"");","[{'comment': 'Should this not be WARN or some exception thrown? Instead of logging that the ip is incorrect. And maybe this validation should be done in the doStart method so its validated earlier', 'commenter': 'davsclaus'}]"
2013,components/camel-elasticsearch5-rest/src/main/java/org/apache/camel/component/elasticsearch5/ElasticsearchProducer.java,"@@ -0,0 +1,295 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.elasticsearch5;
+
+import java.lang.reflect.InvocationTargetException;
+import java.net.UnknownHostException;
+import java.util.ArrayList;
+import java.util.List;
+
+import org.apache.camel.Exchange;
+import org.apache.camel.Message;
+import org.apache.camel.impl.DefaultProducer;
+import org.apache.http.HttpHost;
+import org.apache.http.auth.AuthScope;
+import org.apache.http.auth.UsernamePasswordCredentials;
+import org.apache.http.client.CredentialsProvider;
+import org.apache.http.impl.client.BasicCredentialsProvider;
+import org.elasticsearch.ElasticsearchStatusException;
+import org.elasticsearch.action.admin.indices.delete.DeleteIndexRequest;
+import org.elasticsearch.action.bulk.BulkItemResponse;
+import org.elasticsearch.action.bulk.BulkRequest;
+import org.elasticsearch.action.delete.DeleteRequest;
+import org.elasticsearch.action.get.GetRequest;
+import org.elasticsearch.action.get.MultiGetRequest;
+import org.elasticsearch.action.index.IndexRequest;
+import org.elasticsearch.action.search.SearchRequest;
+import org.elasticsearch.action.update.UpdateRequest;
+import org.elasticsearch.client.RestClient;
+import org.elasticsearch.client.RestClientBuilder;
+import org.elasticsearch.client.RestHighLevelClient;
+import org.elasticsearch.client.sniff.Sniffer;
+import org.elasticsearch.client.sniff.SnifferBuilder;
+import org.elasticsearch.rest.RestStatus;
+import org.elasticsearch.search.builder.SearchSourceBuilder;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+
+/**
+ * Represents an Elasticsearch producer.
+ */
+public class ElasticsearchProducer extends DefaultProducer {
+
+    private static final Logger LOG = LoggerFactory.getLogger(ElasticsearchProducer.class);
+
+    protected final ElasticsearchConfiguration configuration;
+    private RestClient client;
+    private Sniffer sniffer;
+
+    public ElasticsearchProducer(ElasticsearchEndpoint endpoint, ElasticsearchConfiguration configuration) {
+        super(endpoint);
+        this.configuration = configuration;
+        this.client = endpoint.getClient();
+    }
+
+    private ElasticsearchOperation resolveOperation(Exchange exchange) {
+        // 1. Operation can be driven by either (in order of preference):
+        // a. If the body is an ActionRequest the operation is set by the type
+        // of request.
+        // b. If the body is not an ActionRequest, the operation is set by the
+        // header if it exists.
+        // c. If neither the operation can not be derived from the body or
+        // header, the configuration is used.
+        // In the event we can't discover the operation from a, b or c we throw
+        // an error.
+        Object request = exchange.getIn().getBody();
+        if (request instanceof IndexRequest) {
+            return ElasticsearchOperation.INDEX;
+        } else if (request instanceof GetRequest) {
+            return ElasticsearchOperation.GET_BY_ID;
+        } else if (request instanceof MultiGetRequest) {
+            return ElasticsearchOperation.MULTIGET;
+        } else if (request instanceof UpdateRequest) {
+            return ElasticsearchOperation.UPDATE;
+        } else if (request instanceof BulkRequest) {
+            // do we want bulk or bulk_index?
+            if (configuration.getOperation() == ElasticsearchOperation.BULK_INDEX) {
+                return configuration.getOperation().BULK_INDEX;
+            } else {
+                return configuration.getOperation().BULK;
+            }
+        } else if (request instanceof DeleteRequest) {
+            return ElasticsearchOperation.DELETE;
+        } else if (request instanceof SearchRequest) {
+            return ElasticsearchOperation.SEARCH;
+        } else if (request instanceof DeleteIndexRequest) {
+            return ElasticsearchOperation.DELETE_INDEX;
+        }
+
+        ElasticsearchOperation operationConfig = exchange.getIn().getHeader(ElasticsearchConstants.PARAM_OPERATION, ElasticsearchOperation.class);
+        if (operationConfig == null) {
+            operationConfig = configuration.getOperation();
+        }
+        if (operationConfig == null) {
+            throw new IllegalArgumentException(ElasticsearchConstants.PARAM_OPERATION + "" value '"" + operationConfig + ""' is not supported"");
+        }
+        return operationConfig;
+    }
+
+    public void process(Exchange exchange) throws Exception {
+        if (configuration.getDisconnect() && client == null) {
+            startClient();
+        }
+        RestHighLevelClient restHighLevelClient = new RestHighLevelClient(client);","[{'comment': 'I wonder if we should create a new `RestHighLevelClient` per message? Or is this just a facade and okay to do.', 'commenter': 'davsclaus'}, {'comment': ""High level REST client wraps an instance of the low level RestClient and allows to build requests and read responses. \r\nSo I think it's okay to create an instance per message"", 'commenter': 'fharms'}]"
2013,components/camel-elasticsearch5-rest/src/main/java/org/apache/camel/component/elasticsearch5/ElasticsearchProducer.java,"@@ -0,0 +1,295 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.elasticsearch5;
+
+import java.lang.reflect.InvocationTargetException;
+import java.net.UnknownHostException;
+import java.util.ArrayList;
+import java.util.List;
+
+import org.apache.camel.Exchange;
+import org.apache.camel.Message;
+import org.apache.camel.impl.DefaultProducer;
+import org.apache.http.HttpHost;
+import org.apache.http.auth.AuthScope;
+import org.apache.http.auth.UsernamePasswordCredentials;
+import org.apache.http.client.CredentialsProvider;
+import org.apache.http.impl.client.BasicCredentialsProvider;
+import org.elasticsearch.ElasticsearchStatusException;
+import org.elasticsearch.action.admin.indices.delete.DeleteIndexRequest;
+import org.elasticsearch.action.bulk.BulkItemResponse;
+import org.elasticsearch.action.bulk.BulkRequest;
+import org.elasticsearch.action.delete.DeleteRequest;
+import org.elasticsearch.action.get.GetRequest;
+import org.elasticsearch.action.get.MultiGetRequest;
+import org.elasticsearch.action.index.IndexRequest;
+import org.elasticsearch.action.search.SearchRequest;
+import org.elasticsearch.action.update.UpdateRequest;
+import org.elasticsearch.client.RestClient;
+import org.elasticsearch.client.RestClientBuilder;
+import org.elasticsearch.client.RestHighLevelClient;
+import org.elasticsearch.client.sniff.Sniffer;
+import org.elasticsearch.client.sniff.SnifferBuilder;
+import org.elasticsearch.rest.RestStatus;
+import org.elasticsearch.search.builder.SearchSourceBuilder;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+
+/**
+ * Represents an Elasticsearch producer.
+ */
+public class ElasticsearchProducer extends DefaultProducer {
+
+    private static final Logger LOG = LoggerFactory.getLogger(ElasticsearchProducer.class);
+
+    protected final ElasticsearchConfiguration configuration;
+    private RestClient client;
+    private Sniffer sniffer;
+
+    public ElasticsearchProducer(ElasticsearchEndpoint endpoint, ElasticsearchConfiguration configuration) {
+        super(endpoint);
+        this.configuration = configuration;
+        this.client = endpoint.getClient();
+    }
+
+    private ElasticsearchOperation resolveOperation(Exchange exchange) {
+        // 1. Operation can be driven by either (in order of preference):
+        // a. If the body is an ActionRequest the operation is set by the type
+        // of request.
+        // b. If the body is not an ActionRequest, the operation is set by the
+        // header if it exists.
+        // c. If neither the operation can not be derived from the body or
+        // header, the configuration is used.
+        // In the event we can't discover the operation from a, b or c we throw
+        // an error.
+        Object request = exchange.getIn().getBody();
+        if (request instanceof IndexRequest) {
+            return ElasticsearchOperation.INDEX;
+        } else if (request instanceof GetRequest) {
+            return ElasticsearchOperation.GET_BY_ID;
+        } else if (request instanceof MultiGetRequest) {
+            return ElasticsearchOperation.MULTIGET;
+        } else if (request instanceof UpdateRequest) {
+            return ElasticsearchOperation.UPDATE;
+        } else if (request instanceof BulkRequest) {
+            // do we want bulk or bulk_index?
+            if (configuration.getOperation() == ElasticsearchOperation.BULK_INDEX) {
+                return configuration.getOperation().BULK_INDEX;
+            } else {
+                return configuration.getOperation().BULK;
+            }
+        } else if (request instanceof DeleteRequest) {
+            return ElasticsearchOperation.DELETE;
+        } else if (request instanceof SearchRequest) {
+            return ElasticsearchOperation.SEARCH;
+        } else if (request instanceof DeleteIndexRequest) {
+            return ElasticsearchOperation.DELETE_INDEX;
+        }
+
+        ElasticsearchOperation operationConfig = exchange.getIn().getHeader(ElasticsearchConstants.PARAM_OPERATION, ElasticsearchOperation.class);
+        if (operationConfig == null) {
+            operationConfig = configuration.getOperation();
+        }
+        if (operationConfig == null) {
+            throw new IllegalArgumentException(ElasticsearchConstants.PARAM_OPERATION + "" value '"" + operationConfig + ""' is not supported"");
+        }
+        return operationConfig;
+    }
+
+    public void process(Exchange exchange) throws Exception {
+        if (configuration.getDisconnect() && client == null) {
+            startClient();
+        }
+        RestHighLevelClient restHighLevelClient = new RestHighLevelClient(client);
+        // 2. Index and type will be set by:
+        // a. If the incoming body is already an action request
+        // b. If the body is not an action request we will use headers if they
+        // are set.
+        // c. If the body is not an action request and the headers aren't set we
+        // will use the configuration.
+        // No error is thrown by the component in the event none of the above
+        // conditions are met. The java es client
+        // will throw.
+
+        Message message = exchange.getIn();
+        final ElasticsearchOperation operation = resolveOperation(exchange);
+
+        // Set the index/type headers on the exchange if necessary. This is used
+        // for type conversion.
+        boolean configIndexName = false;
+        String indexName = message.getHeader(ElasticsearchConstants.PARAM_INDEX_NAME, String.class);
+        if (indexName == null) {
+            message.setHeader(ElasticsearchConstants.PARAM_INDEX_NAME, configuration.getIndexName());
+            configIndexName = true;
+        }
+
+        boolean configIndexType = false;
+        String indexType = message.getHeader(ElasticsearchConstants.PARAM_INDEX_TYPE, String.class);
+        if (indexType == null) {
+            message.setHeader(ElasticsearchConstants.PARAM_INDEX_TYPE, configuration.getIndexType());
+            configIndexType = true;
+        }
+
+        boolean configWaitForActiveShards = false;
+        Integer waitForActiveShards = message.getHeader(ElasticsearchConstants.PARAM_WAIT_FOR_ACTIVE_SHARDS, Integer.class);
+        if (waitForActiveShards == null) {
+            message.setHeader(ElasticsearchConstants.PARAM_WAIT_FOR_ACTIVE_SHARDS, configuration.getWaitForActiveShards());
+            configWaitForActiveShards = true;
+        }
+
+        if (operation == ElasticsearchOperation.INDEX) {
+            IndexRequest indexRequest = message.getBody(IndexRequest.class);
+            message.setBody(restHighLevelClient.index(indexRequest).getId());
+        } else if (operation == ElasticsearchOperation.UPDATE) {
+            UpdateRequest updateRequest = message.getBody(UpdateRequest.class);
+            message.setBody(restHighLevelClient.update(updateRequest).getId());
+        } else if (operation == ElasticsearchOperation.GET_BY_ID) {
+            GetRequest getRequest = message.getBody(GetRequest.class);
+            message.setBody(restHighLevelClient.get(getRequest));
+        } else if (operation == ElasticsearchOperation.BULK) {
+            BulkRequest bulkRequest = message.getBody(BulkRequest.class);
+            message.setBody(restHighLevelClient.bulk(bulkRequest).getItems());
+        } else if (operation == ElasticsearchOperation.BULK_INDEX) {
+            BulkRequest bulkRequest = message.getBody(BulkRequest.class);
+            List<String> indexedIds = new ArrayList<>();
+            for (BulkItemResponse response : restHighLevelClient.bulk(bulkRequest).getItems()) {
+                indexedIds.add(response.getId());
+            }
+            message.setBody(indexedIds);
+        } else if (operation == ElasticsearchOperation.DELETE) {
+            DeleteRequest deleteRequest = message.getBody(DeleteRequest.class);
+            message.setBody(restHighLevelClient.delete(deleteRequest).getResult());
+        } else if (operation == ElasticsearchOperation.DELETE_INDEX) {
+            DeleteRequest deleteRequest = message.getBody(DeleteRequest.class);
+            message.setBody(client.performRequest(""DELETE"", deleteRequest.index()).getStatusLine().getStatusCode());
+        } else if (operation == ElasticsearchOperation.EXISTS) {
+            // ExistsRequest API is deprecated, using SearchRequest instead with size=0 and terminate_after=1
+            SearchSourceBuilder sourceBuilder = new SearchSourceBuilder();
+            sourceBuilder.size(0);
+            sourceBuilder.terminateAfter(1);
+            SearchRequest searchRequest = new SearchRequest(exchange.getIn().getHeader(ElasticsearchConstants.PARAM_INDEX_NAME, String.class));
+            searchRequest.source(sourceBuilder);
+            try {
+                restHighLevelClient.search(searchRequest);
+                message.setBody(true);
+            } catch (ElasticsearchStatusException e) {
+                if (e.status().equals(RestStatus.NOT_FOUND)) {
+                    message.setBody(false);
+                } else {
+                    throw new IllegalStateException(e);
+                }
+
+            }
+        } else if (operation == ElasticsearchOperation.SEARCH) {
+            SearchRequest searchRequest = message.getBody(SearchRequest.class);
+            message.setBody(restHighLevelClient.search(searchRequest).getHits());
+        } else {
+            throw new IllegalArgumentException(ElasticsearchConstants.PARAM_OPERATION + "" value '"" + operation + ""' is not supported"");
+        }
+
+        // If we set params via the configuration on this exchange, remove them
+        // now. This preserves legacy behavior for this component and enables a
+        // use case where one message can be sent to multiple elasticsearch
+        // endpoints where the user is relying on the endpoint configuration
+        // (index/type) rather than header values. If we do not clear this out
+        // sending the same message (index request, for example) to multiple
+        // elasticsearch endpoints would have the effect overriding any
+        // subsequent endpoint index/type with the first endpoint index/type.
+        if (configIndexName) {
+            message.removeHeader(ElasticsearchConstants.PARAM_INDEX_NAME);
+        }
+
+        if (configIndexType) {
+            message.removeHeader(ElasticsearchConstants.PARAM_INDEX_TYPE);
+        }
+
+        if (configWaitForActiveShards) {
+            message.removeHeader(ElasticsearchConstants.PARAM_WAIT_FOR_ACTIVE_SHARDS);
+        }
+        if (configuration.getDisconnect()) {
+            client.close();
+            client = null;
+            if (configuration.getEnableSniffer()) {
+                sniffer.close();
+                sniffer = null;
+            }
+        }
+
+    }
+
+    @Override
+    @SuppressWarnings(""unchecked"")
+    protected void doStart() throws Exception {
+        super.doStart();
+        if (!configuration.getDisconnect()) {
+            startClient();
+        }
+    }
+
+    private void startClient() throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, UnknownHostException {
+        if (client == null) {
+            LOG.info(""Connecting to the ElasticSearch cluster: "" + configuration.getClusterName());
+            if (configuration.getHostAddressesList() != null
+                && !configuration.getHostAddressesList().isEmpty()) {
+                client = createClient();
+            } else {
+                LOG.info(""Incorrect ip address and port parameters settings for ElasticSearch cluster"");
+            }
+        }
+    }
+
+    private RestClient createClient() throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {
+        final RestClientBuilder builder = RestClient.builder(configuration.getHostAddressesList().toArray(new HttpHost[0]));
+        builder.setMaxRetryTimeoutMillis(configuration.getMaxRetryTimeout());
+        builder.setRequestConfigCallback(requestConfigBuilder ->
+            requestConfigBuilder.setConnectTimeout(configuration.getConnectionTimeout()).setSocketTimeout(configuration.getSocketTimeout()));
+        if (configuration.getUser() != null && configuration.getPassword() != null) {
+            final CredentialsProvider credentialsProvider = new BasicCredentialsProvider();
+            credentialsProvider.setCredentials(AuthScope.ANY, new UsernamePasswordCredentials(configuration.getUser(), configuration.getPassword()));
+            builder.setHttpClientConfigCallback(httpClientBuilder -> {
+                httpClientBuilder.setDefaultCredentialsProvider(credentialsProvider);
+                return httpClientBuilder;
+            });
+        }
+        final RestClient restClient = builder.build();
+        if (configuration.getEnableSniffer()) {
+            SnifferBuilder snifferBuilder = Sniffer.builder(restClient);
+            snifferBuilder.setSniffIntervalMillis(configuration.getSnifferInterval());
+            snifferBuilder.setSniffAfterFailureDelayMillis(configuration.getSniffAfterFailureDelay());
+            sniffer = snifferBuilder.build();
+        }
+        return restClient;
+    }
+
+
+    @Override
+    protected void doStop() throws Exception {
+        if (client != null) {
+            LOG.info(""Disconnecting from ElasticSearch cluster: "" + configuration.getClusterName());","[{'comment': ""Use `{}` placeholders in the log message instead of '+'"", 'commenter': 'davsclaus'}]"
2013,components/camel-elasticsearch5-rest/src/main/java/org/apache/camel/component/elasticsearch5/converter/ElasticsearchActionRequestConverter.java,"@@ -0,0 +1,211 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.elasticsearch5.converter;
+
+import java.io.IOException;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+
+import com.fasterxml.jackson.databind.JsonNode;
+import com.fasterxml.jackson.databind.ObjectMapper;
+
+import org.apache.camel.Converter;
+import org.apache.camel.Exchange;
+import org.apache.camel.component.elasticsearch5.ElasticsearchConstants;
+import org.elasticsearch.action.bulk.BulkRequest;
+import org.elasticsearch.action.delete.DeleteRequest;
+import org.elasticsearch.action.get.GetRequest;
+import org.elasticsearch.action.index.IndexRequest;
+import org.elasticsearch.action.search.MultiSearchRequest;
+import org.elasticsearch.action.search.SearchRequest;
+import org.elasticsearch.action.update.UpdateRequest;
+import org.elasticsearch.common.xcontent.XContentBuilder;
+import org.elasticsearch.common.xcontent.XContentFactory;
+import org.elasticsearch.common.xcontent.XContentType;
+import org.elasticsearch.index.query.QueryBuilders;
+import org.elasticsearch.search.builder.SearchSourceBuilder;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+@Converter
+public final class ElasticsearchActionRequestConverter {
+    private static final Logger LOG = LoggerFactory.getLogger(ElasticsearchActionRequestConverter.class);
+
+    private ElasticsearchActionRequestConverter() {
+    }
+
+    // Update requests
+    private static UpdateRequest createUpdateRequest(Object document, Exchange exchange) {
+        if (document instanceof UpdateRequest) {
+            return (UpdateRequest)document;
+        }
+        UpdateRequest updateRequest = new UpdateRequest();
+        if (document instanceof byte[]) {
+            updateRequest.doc((byte[]) document);
+        } else if (document instanceof Map) {
+            updateRequest.doc((Map<String, Object>) document);
+        } else if (document instanceof String) {
+            updateRequest.doc((String) document);
+        } else if (document instanceof XContentBuilder) {
+            updateRequest.doc((XContentBuilder) document);
+        } else {
+            return null;
+        }
+
+        return updateRequest
+            .waitForActiveShards(exchange.getIn().getHeader(
+                ElasticsearchConstants.PARAM_WAIT_FOR_ACTIVE_SHARDS, Integer.class))
+            .parent(exchange.getIn().getHeader(
+                ElasticsearchConstants.PARENT, String.class))
+            .index(exchange.getIn().getHeader(
+                ElasticsearchConstants.PARAM_INDEX_NAME, String.class))
+            .type(exchange.getIn().getHeader(
+                ElasticsearchConstants.PARAM_INDEX_TYPE, String.class))
+            .id(exchange.getIn().getHeader(
+                ElasticsearchConstants.PARAM_INDEX_ID, String.class));
+    }
+
+    // Index requests
+    @SuppressWarnings(""unchecked"")
+    private static IndexRequest createIndexRequest(Object document, Exchange exchange) {
+        if (document instanceof IndexRequest) {
+            return (IndexRequest)document;
+        }
+        IndexRequest indexRequest = new IndexRequest();
+        if (document instanceof byte[]) {
+            indexRequest.source((byte[]) document);
+        } else if (document instanceof Map) {
+            indexRequest.source((Map<String, Object>) document);
+        } else if (document instanceof String) {
+            indexRequest.source((String) document);
+        } else if (document instanceof XContentBuilder) {
+            indexRequest.source((XContentBuilder) document);
+        } else {
+            return null;
+        }
+
+        return indexRequest
+            .waitForActiveShards(exchange.getIn().getHeader(
+                ElasticsearchConstants.PARAM_WAIT_FOR_ACTIVE_SHARDS, Integer.class))
+            .parent(exchange.getIn().getHeader(
+                ElasticsearchConstants.PARENT, String.class))
+            .index(exchange.getIn().getHeader(
+                ElasticsearchConstants.PARAM_INDEX_NAME, String.class))
+            .type(exchange.getIn().getHeader(
+                ElasticsearchConstants.PARAM_INDEX_TYPE, String.class));
+    }
+
+    @Converter
+    public static IndexRequest toIndexRequest(Object document, Exchange exchange) {
+        return createIndexRequest(document, exchange)
+            .id(exchange.getIn().getHeader(ElasticsearchConstants.PARAM_INDEX_ID, String.class));
+    }
+
+    @Converter
+    public static UpdateRequest toUpdateRequest(Object document, Exchange exchange) {
+        return createUpdateRequest(document, exchange)
+            .id(exchange.getIn().getHeader(ElasticsearchConstants.PARAM_INDEX_ID, String.class));
+    }
+
+    @Converter
+    public static GetRequest toGetRequest(String id, Exchange exchange) {
+        return new GetRequest(exchange.getIn().getHeader(
+            ElasticsearchConstants.PARAM_INDEX_NAME, String.class))
+            .type(exchange.getIn().getHeader(
+                ElasticsearchConstants.PARAM_INDEX_TYPE,
+                String.class)).id(id);
+    }
+
+    @SuppressWarnings(""unchecked"")
+    @Converter
+    public static MultiSearchRequest toMultiSearchRequest(Object document, Exchange exchange) {
+        List<SearchRequest> items = (List<SearchRequest>) document;
+        MultiSearchRequest multiSearchRequest = new MultiSearchRequest();
+        Iterator<SearchRequest> it = items.iterator();
+        while (it.hasNext()) {
+            SearchRequest item = it.next();
+            multiSearchRequest.add(item);
+        }
+        return multiSearchRequest;
+    }
+
+    @Converter
+    public static DeleteRequest toDeleteRequest(String id, Exchange exchange) {
+        return new DeleteRequest()
+            .index(exchange.getIn().getHeader(
+                ElasticsearchConstants.PARAM_INDEX_NAME,
+                String.class))
+            .type(exchange.getIn().getHeader(
+                ElasticsearchConstants.PARAM_INDEX_TYPE,
+                String.class)).id(id);
+    }
+
+    @Converter
+    public static SearchRequest toSearchRequest(Object queryObject, Exchange exchange) {
+        SearchRequest searchRequest = new SearchRequest(exchange.getIn()
+            .getHeader(ElasticsearchConstants.PARAM_INDEX_NAME, String.class))
+            .types(exchange.getIn().getHeader(ElasticsearchConstants.PARAM_INDEX_TYPE, String.class));
+
+        SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder();
+        String queryText = null;
+
+        if (queryObject instanceof Map<?, ?>) {
+            Map<String, Object> mapQuery = (Map<String, Object>)queryObject;
+            // Remove 'query' prefix from the query object for backward compatibility
+            if (mapQuery.containsKey(ElasticsearchConstants.ES_QUERY_DSL_PREFIX)) {
+                mapQuery = (Map<String, Object>)mapQuery.get(ElasticsearchConstants.ES_QUERY_DSL_PREFIX);
+            }
+            try {
+                XContentBuilder contentBuilder = XContentFactory.contentBuilder(XContentType.JSON);
+                queryText = contentBuilder.map(mapQuery).string();
+            } catch (IOException e) {
+                LOG.error(e.getMessage());","[{'comment': 'We should not just ignore exceptions like that. Always fail by letting the exception be thrown', 'commenter': 'davsclaus'}]"
2013,components/camel-elasticsearch5-rest/src/main/java/org/apache/camel/component/elasticsearch5/converter/ElasticsearchActionRequestConverter.java,"@@ -0,0 +1,211 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.elasticsearch5.converter;
+
+import java.io.IOException;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+
+import com.fasterxml.jackson.databind.JsonNode;
+import com.fasterxml.jackson.databind.ObjectMapper;
+
+import org.apache.camel.Converter;
+import org.apache.camel.Exchange;
+import org.apache.camel.component.elasticsearch5.ElasticsearchConstants;
+import org.elasticsearch.action.bulk.BulkRequest;
+import org.elasticsearch.action.delete.DeleteRequest;
+import org.elasticsearch.action.get.GetRequest;
+import org.elasticsearch.action.index.IndexRequest;
+import org.elasticsearch.action.search.MultiSearchRequest;
+import org.elasticsearch.action.search.SearchRequest;
+import org.elasticsearch.action.update.UpdateRequest;
+import org.elasticsearch.common.xcontent.XContentBuilder;
+import org.elasticsearch.common.xcontent.XContentFactory;
+import org.elasticsearch.common.xcontent.XContentType;
+import org.elasticsearch.index.query.QueryBuilders;
+import org.elasticsearch.search.builder.SearchSourceBuilder;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+@Converter
+public final class ElasticsearchActionRequestConverter {
+    private static final Logger LOG = LoggerFactory.getLogger(ElasticsearchActionRequestConverter.class);
+
+    private ElasticsearchActionRequestConverter() {
+    }
+
+    // Update requests
+    private static UpdateRequest createUpdateRequest(Object document, Exchange exchange) {
+        if (document instanceof UpdateRequest) {
+            return (UpdateRequest)document;
+        }
+        UpdateRequest updateRequest = new UpdateRequest();
+        if (document instanceof byte[]) {
+            updateRequest.doc((byte[]) document);
+        } else if (document instanceof Map) {
+            updateRequest.doc((Map<String, Object>) document);
+        } else if (document instanceof String) {
+            updateRequest.doc((String) document);
+        } else if (document instanceof XContentBuilder) {
+            updateRequest.doc((XContentBuilder) document);
+        } else {
+            return null;
+        }
+
+        return updateRequest
+            .waitForActiveShards(exchange.getIn().getHeader(
+                ElasticsearchConstants.PARAM_WAIT_FOR_ACTIVE_SHARDS, Integer.class))
+            .parent(exchange.getIn().getHeader(
+                ElasticsearchConstants.PARENT, String.class))
+            .index(exchange.getIn().getHeader(
+                ElasticsearchConstants.PARAM_INDEX_NAME, String.class))
+            .type(exchange.getIn().getHeader(
+                ElasticsearchConstants.PARAM_INDEX_TYPE, String.class))
+            .id(exchange.getIn().getHeader(
+                ElasticsearchConstants.PARAM_INDEX_ID, String.class));
+    }
+
+    // Index requests
+    @SuppressWarnings(""unchecked"")
+    private static IndexRequest createIndexRequest(Object document, Exchange exchange) {
+        if (document instanceof IndexRequest) {
+            return (IndexRequest)document;
+        }
+        IndexRequest indexRequest = new IndexRequest();
+        if (document instanceof byte[]) {
+            indexRequest.source((byte[]) document);
+        } else if (document instanceof Map) {
+            indexRequest.source((Map<String, Object>) document);
+        } else if (document instanceof String) {
+            indexRequest.source((String) document);
+        } else if (document instanceof XContentBuilder) {
+            indexRequest.source((XContentBuilder) document);
+        } else {
+            return null;
+        }
+
+        return indexRequest
+            .waitForActiveShards(exchange.getIn().getHeader(
+                ElasticsearchConstants.PARAM_WAIT_FOR_ACTIVE_SHARDS, Integer.class))
+            .parent(exchange.getIn().getHeader(
+                ElasticsearchConstants.PARENT, String.class))
+            .index(exchange.getIn().getHeader(
+                ElasticsearchConstants.PARAM_INDEX_NAME, String.class))
+            .type(exchange.getIn().getHeader(
+                ElasticsearchConstants.PARAM_INDEX_TYPE, String.class));
+    }
+
+    @Converter
+    public static IndexRequest toIndexRequest(Object document, Exchange exchange) {
+        return createIndexRequest(document, exchange)
+            .id(exchange.getIn().getHeader(ElasticsearchConstants.PARAM_INDEX_ID, String.class));
+    }
+
+    @Converter
+    public static UpdateRequest toUpdateRequest(Object document, Exchange exchange) {
+        return createUpdateRequest(document, exchange)
+            .id(exchange.getIn().getHeader(ElasticsearchConstants.PARAM_INDEX_ID, String.class));
+    }
+
+    @Converter
+    public static GetRequest toGetRequest(String id, Exchange exchange) {
+        return new GetRequest(exchange.getIn().getHeader(
+            ElasticsearchConstants.PARAM_INDEX_NAME, String.class))
+            .type(exchange.getIn().getHeader(
+                ElasticsearchConstants.PARAM_INDEX_TYPE,
+                String.class)).id(id);
+    }
+
+    @SuppressWarnings(""unchecked"")
+    @Converter
+    public static MultiSearchRequest toMultiSearchRequest(Object document, Exchange exchange) {
+        List<SearchRequest> items = (List<SearchRequest>) document;
+        MultiSearchRequest multiSearchRequest = new MultiSearchRequest();
+        Iterator<SearchRequest> it = items.iterator();
+        while (it.hasNext()) {
+            SearchRequest item = it.next();
+            multiSearchRequest.add(item);
+        }
+        return multiSearchRequest;
+    }
+
+    @Converter
+    public static DeleteRequest toDeleteRequest(String id, Exchange exchange) {
+        return new DeleteRequest()
+            .index(exchange.getIn().getHeader(
+                ElasticsearchConstants.PARAM_INDEX_NAME,
+                String.class))
+            .type(exchange.getIn().getHeader(
+                ElasticsearchConstants.PARAM_INDEX_TYPE,
+                String.class)).id(id);
+    }
+
+    @Converter
+    public static SearchRequest toSearchRequest(Object queryObject, Exchange exchange) {
+        SearchRequest searchRequest = new SearchRequest(exchange.getIn()
+            .getHeader(ElasticsearchConstants.PARAM_INDEX_NAME, String.class))
+            .types(exchange.getIn().getHeader(ElasticsearchConstants.PARAM_INDEX_TYPE, String.class));
+
+        SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder();
+        String queryText = null;
+
+        if (queryObject instanceof Map<?, ?>) {
+            Map<String, Object> mapQuery = (Map<String, Object>)queryObject;
+            // Remove 'query' prefix from the query object for backward compatibility
+            if (mapQuery.containsKey(ElasticsearchConstants.ES_QUERY_DSL_PREFIX)) {
+                mapQuery = (Map<String, Object>)mapQuery.get(ElasticsearchConstants.ES_QUERY_DSL_PREFIX);
+            }
+            try {
+                XContentBuilder contentBuilder = XContentFactory.contentBuilder(XContentType.JSON);
+                queryText = contentBuilder.map(mapQuery).string();
+            } catch (IOException e) {
+                LOG.error(e.getMessage());
+            }
+        } else if (queryObject instanceof String) {
+            queryText = (String)queryObject;
+            ObjectMapper mapper = new ObjectMapper();
+            try {
+                JsonNode jsonTextObject = mapper.readValue(queryText, JsonNode.class);
+                JsonNode parentJsonNode = jsonTextObject.get(ElasticsearchConstants.ES_QUERY_DSL_PREFIX);
+                if (parentJsonNode != null) {
+                    queryText = parentJsonNode.toString();
+                }
+            } catch (IOException e) {
+                LOG.error(e.getMessage());","[{'comment': 'We should not just ignore exceptions like that. Always fail by letting the exception be thrown', 'commenter': 'davsclaus'}]"
2013,components/camel-elasticsearch5-rest/src/main/java/org/apache/camel/component/elasticsearch5/converter/ElasticsearchActionRequestConverter.java,"@@ -0,0 +1,211 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.elasticsearch5.converter;
+
+import java.io.IOException;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+
+import com.fasterxml.jackson.databind.JsonNode;
+import com.fasterxml.jackson.databind.ObjectMapper;
+
+import org.apache.camel.Converter;
+import org.apache.camel.Exchange;
+import org.apache.camel.component.elasticsearch5.ElasticsearchConstants;
+import org.elasticsearch.action.bulk.BulkRequest;
+import org.elasticsearch.action.delete.DeleteRequest;
+import org.elasticsearch.action.get.GetRequest;
+import org.elasticsearch.action.index.IndexRequest;
+import org.elasticsearch.action.search.MultiSearchRequest;
+import org.elasticsearch.action.search.SearchRequest;
+import org.elasticsearch.action.update.UpdateRequest;
+import org.elasticsearch.common.xcontent.XContentBuilder;
+import org.elasticsearch.common.xcontent.XContentFactory;
+import org.elasticsearch.common.xcontent.XContentType;
+import org.elasticsearch.index.query.QueryBuilders;
+import org.elasticsearch.search.builder.SearchSourceBuilder;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+@Converter
+public final class ElasticsearchActionRequestConverter {","[{'comment': 'Its a bit misusing type converters to prepare for calling ES. Instead we should move this kind of logic into the producer / endpoint or some helper class IMHO - as those type converters are more internally and not something the end user would really use for converting.', 'commenter': 'davsclaus'}]"
2013,components/camel-elasticsearch5-rest/src/main/java/org/apache/camel/component/elasticsearch5/ElasticsearchComponent.java,"@@ -0,0 +1,89 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.elasticsearch5;
+
+import java.net.UnknownHostException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.Map;
+
+import org.apache.camel.CamelContext;
+import org.apache.camel.Endpoint;
+import org.apache.camel.impl.DefaultComponent;
+import org.apache.camel.spi.Metadata;
+import org.apache.http.HttpHost;
+import org.elasticsearch.client.RestClient;
+
+/**
+ * Represents the component that manages {@link ElasticsearchEndpoint}.
+ */
+public class ElasticsearchComponent extends DefaultComponent {","[{'comment': 'We should allow to configure the hostname and other details to the ES cluster on the component level, so you do not have to configure this on each endpoint. This also make it easier for SB users as you can then configure this via its application.properties.', 'commenter': 'davsclaus'}, {'comment': '@davsclaus do you have an example where you do this? or is just matter of creating getter and setters with @ Metadata on?', 'commenter': 'fharms'}, {'comment': 'Yes getter/setter with `@Metadata` and then in the create endpoint, you first configure the configuration with the values from the component, and then afterwards does the usual and configure from the endpoint uri parameters so they can override and take precedense', 'commenter': 'davsclaus'}]"
2013,components/camel-elasticsearch5-rest/src/main/java/org/apache/camel/component/elasticsearch5/ElasticsearchComponent.java,"@@ -0,0 +1,235 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.elasticsearch5;
+
+import java.net.UnknownHostException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.Map;
+
+import org.apache.camel.CamelContext;
+import org.apache.camel.Endpoint;
+import org.apache.camel.impl.DefaultComponent;
+import org.apache.camel.spi.Metadata;
+import org.apache.http.HttpHost;
+import org.elasticsearch.client.RestClient;
+
+/**
+ * Represents the component that manages {@link ElasticsearchEndpoint}.
+ */
+public class ElasticsearchComponent extends DefaultComponent {
+
+    @Metadata(label = ""advanced"")
+    private RestClient client;
+
+    @Metadata(label = ""advanced"")
+    private String hostAddresses;
+    @Metadata(label = ""advanced"", defaultValue = """" + ElasticsearchConstants.DEFAULT_SOCKET_TIMEOUT)
+    private int socketTimeout = ElasticsearchConstants.DEFAULT_SOCKET_TIMEOUT;
+    @Metadata(label = ""advanced"", defaultValue = """" + ElasticsearchConstants.MAX_RETRY_TIMEOUT)
+    private int maxRetryTimeout = ElasticsearchConstants.MAX_RETRY_TIMEOUT;
+    @Metadata(label = ""advanced"", defaultValue = """" + ElasticsearchConstants.DEFAULT_CONNECTION_TIMEOUT)
+    private int connectionTimeout = ElasticsearchConstants.DEFAULT_CONNECTION_TIMEOUT;
+
+    @Metadata(label = ""advance"")
+    private String user;
+    @Metadata(secret = true)
+    private String password;
+    @Metadata(label = ""advanced"", defaultValue = ""false"")
+    private Boolean enableSSL = false;","[{'comment': 'Use boolean type.', 'commenter': 'davsclaus'}]"
2013,components/camel-elasticsearch5-rest/pom.xml,"@@ -0,0 +1,120 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one or more
+    contributor license agreements.  See the NOTICE file distributed with
+    this work for additional information regarding copyright ownership.
+    The ASF licenses this file to You under the Apache License, Version 2.0
+    (the ""License""); you may not use this file except in compliance with
+    the License.  You may obtain a copy of the License at
+
+         http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an ""AS IS"" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+
+-->
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>org.apache.camel</groupId>
+    <artifactId>components</artifactId>
+    <version>2.20.0-SNAPSHOT</version>
+  </parent>
+
+  <groupId>org.apache.camel</groupId>
+  <artifactId>camel-elasticsearch5-rest</artifactId>
+  <packaging>jar</packaging>
+  <name>Camel :: ElasticSearch5 :: REST</name>
+  <description>Camel ElasticSearch 5.x REST support</description>
+
+  <properties>
+    <elasticsearch.version>${elasticsearch5-version}</elasticsearch.version>
+    <camel.osgi.export.pkg>org.apache.camel.component.elasticsearch5.*;${camel.osgi.version}</camel.osgi.export.pkg>
+    <camel.osgi.export.service>org.apache.camel.spi.ComponentResolver;component=elasticsearch5</camel.osgi.export.service>","[{'comment': 'Should be elastisearch5-rest eg the correct component name', 'commenter': 'davsclaus'}]"
2013,components/camel-elasticsearch5-rest/src/main/java/org/apache/camel/component/elasticsearch5/ElasticsearchComponent.java,"@@ -0,0 +1,235 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.elasticsearch5;
+
+import java.net.UnknownHostException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.Map;
+
+import org.apache.camel.CamelContext;
+import org.apache.camel.Endpoint;
+import org.apache.camel.impl.DefaultComponent;
+import org.apache.camel.spi.Metadata;
+import org.apache.http.HttpHost;
+import org.elasticsearch.client.RestClient;
+
+/**
+ * Represents the component that manages {@link ElasticsearchEndpoint}.
+ */
+public class ElasticsearchComponent extends DefaultComponent {
+
+    @Metadata(label = ""advanced"")
+    private RestClient client;
+
+    @Metadata(label = ""advanced"")
+    private String hostAddresses;
+    @Metadata(label = ""advanced"", defaultValue = """" + ElasticsearchConstants.DEFAULT_SOCKET_TIMEOUT)
+    private int socketTimeout = ElasticsearchConstants.DEFAULT_SOCKET_TIMEOUT;
+    @Metadata(label = ""advanced"", defaultValue = """" + ElasticsearchConstants.MAX_RETRY_TIMEOUT)
+    private int maxRetryTimeout = ElasticsearchConstants.MAX_RETRY_TIMEOUT;
+    @Metadata(label = ""advanced"", defaultValue = """" + ElasticsearchConstants.DEFAULT_CONNECTION_TIMEOUT)
+    private int connectionTimeout = ElasticsearchConstants.DEFAULT_CONNECTION_TIMEOUT;
+
+    @Metadata(label = ""advance"")
+    private String user;
+    @Metadata(secret = true)
+    private String password;
+    @Metadata(label = ""advanced"", defaultValue = ""false"")
+    private Boolean enableSSL = false;
+
+    @Metadata(label = ""advanced"", defaultValue = ""false"")
+    private Boolean enableSniffer = false;
+    @Metadata(label = ""advanced"", defaultValue = """" + ElasticsearchConstants.DEFAULT_SNIFFER_INTERVAL)
+    private int snifferInterval = ElasticsearchConstants.DEFAULT_SNIFFER_INTERVAL;
+    @Metadata(label = ""advanced"", defaultValue = """" +  ElasticsearchConstants.DEFAULT_AFTER_FAILURE_DELAY)
+    private int sniffAfterFailureDelay = ElasticsearchConstants.DEFAULT_AFTER_FAILURE_DELAY;","[{'comment': 'Just a note that the options on component may not have to be the same as on endpoint. Its often only global options that makes sense to configure once for all, which can be security or some thread pool settings. So if eg the sniffer stuff is good to just configure once then this is fine - which I assume it would be.', 'commenter': 'davsclaus'}, {'comment': 'What do I need to do too only let them configure it on the component level, when the attributes also defined in the ElasticsearchConfiguration and pasted to the producer?', 'commenter': 'fharms'}]"
2013,components/camel-elasticsearch5-rest/src/main/java/org/apache/camel/component/elasticsearch5/ElasticsearchConfiguration.java,"@@ -0,0 +1,250 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.elasticsearch5;
+
+import java.util.List;
+
+import org.apache.camel.spi.Metadata;
+import org.apache.camel.spi.UriParam;
+import org.apache.camel.spi.UriParams;
+import org.apache.camel.spi.UriPath;
+import org.apache.http.HttpHost;
+
+@UriParams
+public class ElasticsearchConfiguration {
+
+    private List<HttpHost> hostAddressesList;
+
+    @UriPath @Metadata(required = ""true"")
+    private String clusterName;
+    @UriParam
+    private ElasticsearchOperation operation;
+    @UriParam @Metadata(required = ""true"")
+    private String indexName;
+    @UriParam
+    private String indexType;
+    @UriParam(defaultValue = """" + ElasticsearchConstants.DEFAULT_FOR_WAIT_ACTIVE_SHARDS)
+    private int waitForActiveShards = ElasticsearchConstants.DEFAULT_FOR_WAIT_ACTIVE_SHARDS;
+    @UriParam @Metadata(required = ""true"")","[{'comment': 'This will not be required if you configure it on the component level, so remove required = true', 'commenter': 'davsclaus'}]"
2013,components/camel-elasticsearch5-rest/src/main/java/org/apache/camel/component/elasticsearch5/ElasticsearchConfiguration.java,"@@ -0,0 +1,250 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.elasticsearch5;
+
+import java.util.List;
+
+import org.apache.camel.spi.Metadata;
+import org.apache.camel.spi.UriParam;
+import org.apache.camel.spi.UriParams;
+import org.apache.camel.spi.UriPath;
+import org.apache.http.HttpHost;
+
+@UriParams
+public class ElasticsearchConfiguration {
+
+    private List<HttpHost> hostAddressesList;
+
+    @UriPath @Metadata(required = ""true"")
+    private String clusterName;
+    @UriParam
+    private ElasticsearchOperation operation;
+    @UriParam @Metadata(required = ""true"")
+    private String indexName;
+    @UriParam
+    private String indexType;
+    @UriParam(defaultValue = """" + ElasticsearchConstants.DEFAULT_FOR_WAIT_ACTIVE_SHARDS)
+    private int waitForActiveShards = ElasticsearchConstants.DEFAULT_FOR_WAIT_ACTIVE_SHARDS;
+    @UriParam @Metadata(required = ""true"")
+    private String hostAddresses;
+    @UriParam(defaultValue = """" + ElasticsearchConstants.DEFAULT_SOCKET_TIMEOUT)
+    private int socketTimeout = ElasticsearchConstants.DEFAULT_SOCKET_TIMEOUT;
+    @UriParam(defaultValue = """" + ElasticsearchConstants.MAX_RETRY_TIMEOUT)
+    private int maxRetryTimeout = ElasticsearchConstants.MAX_RETRY_TIMEOUT;
+    @UriParam(defaultValue = """" + ElasticsearchConstants.DEFAULT_CONNECTION_TIMEOUT)
+    private int connectionTimeout = ElasticsearchConstants.DEFAULT_CONNECTION_TIMEOUT;
+    @UriParam
+    private String user;
+    @UriParam(secret = true)
+    private String password;
+    @UriParam(defaultValue = ""false"")
+    private Boolean enableSSL = false;
+    @UriParam(defaultValue = ""false"")
+    private Boolean disconnect = false;
+    //Sniffer parameter.
+    @UriParam(defaultValue = ""false"")
+    private Boolean enableSniffer = false;","[{'comment': 'Favour using boolean instead of Boolean', 'commenter': 'davsclaus'}]"
2013,components/camel-elasticsearch5-rest/src/main/java/org/apache/camel/component/elasticsearch5/ElasticsearchConstants.java,"@@ -0,0 +1,39 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.camel.component.elasticsearch5;
+
+
+public interface ElasticsearchConstants {
+
+    String PARAM_OPERATION = ""operation"";
+    String PARAM_INDEX_ID = ""indexId"";
+    String PARAM_INDEX_NAME = ""indexName"";
+    String PARAM_INDEX_TYPE = ""indexType"";
+    String PARAM_WAIT_FOR_ACTIVE_SHARDS = ""waitForActiveShards"";
+    String PARENT = ""parent"";
+    int    DEFAULT_PORT = 9200;
+    int    DEFAULT_FOR_WAIT_ACTIVE_SHARDS = 1; // Meaning only wait for the primary shard
+    int    DEFAULT_SOCKET_TIMEOUT = 30000; // Meaning how long time to wait before the socket timeout
+    int    MAX_RETRY_TIMEOUT = 30000; // Meaning how long to wait before retry again
+    int    DEFAULT_CONNECTION_TIMEOUT = 30000; // Meaning how many seconds before it timeout when establish connection
+    int    DEFAULT_SNIFFER_INTERVAL = 60000 * 5; // Meaning how often it should search for elasticsearch nodes
+    int    DEFAULT_AFTER_FAILURE_DELAY = 60000; // Meaning when should the sniff execution scheduled after a failure
+    String TRANSPORT_ADDRESSES_SEPARATOR_REGEX = "","";","[{'comment': 'Do you really want a field for just a comma or colon?', 'commenter': 'davsclaus'}]"
2013,components/camel-elasticsearch5-rest/src/main/java/org/apache/camel/component/elasticsearch5/ElasticsearchConstants.java,"@@ -0,0 +1,39 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.camel.component.elasticsearch5;
+
+
+public interface ElasticsearchConstants {","[{'comment': 'These fields are ideally public fields that end users may use - if there is some internal then move them somewhere else.', 'commenter': 'davsclaus'}]"
2013,components/camel-elasticsearch5-rest/src/main/java/org/apache/camel/component/elasticsearch5/ElasticsearchEndpoint.java,"@@ -0,0 +1,61 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.elasticsearch5;
+
+import org.apache.camel.Consumer;
+import org.apache.camel.Processor;
+import org.apache.camel.Producer;
+import org.apache.camel.impl.DefaultEndpoint;
+import org.apache.camel.spi.UriEndpoint;
+import org.apache.camel.spi.UriParam;
+import org.elasticsearch.client.RestClient;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * The elasticsearch component is used for interfacing with ElasticSearch server using 5.x REST API.
+ */
+@UriEndpoint(firstVersion = ""2.21.0"", scheme = ""elasticsearch5-rest"", title = ""Elasticsearch5-rest"", syntax = ""elasticsearch5-rest:clusterName"", producerOnly = true, label = ""monitoring,search"")","[{'comment': 'Use a nicer title - Elastichsearch Rest or Elasticsearch 5 Rest', 'commenter': 'davsclaus'}]"
2013,components/camel-elasticsearch5-rest/src/main/java/org/apache/camel/component/elasticsearch5/ElasticsearchProducer.java,"@@ -0,0 +1,297 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.elasticsearch5;
+
+import java.lang.reflect.InvocationTargetException;
+import java.net.UnknownHostException;
+import java.util.Arrays;
+import java.util.List;
+import java.util.Map;
+import java.util.stream.Collectors;
+
+import org.apache.camel.Exchange;
+import org.apache.camel.Message;
+import org.apache.camel.component.elasticsearch5.converter.ElasticsearchActionRequestConverter;
+import org.apache.camel.impl.DefaultProducer;
+import org.apache.http.HttpHost;
+import org.apache.http.auth.AuthScope;
+import org.apache.http.auth.UsernamePasswordCredentials;
+import org.apache.http.client.CredentialsProvider;
+import org.apache.http.impl.client.BasicCredentialsProvider;
+import org.elasticsearch.ElasticsearchStatusException;
+import org.elasticsearch.action.admin.indices.delete.DeleteIndexRequest;
+import org.elasticsearch.action.bulk.BulkItemResponse;
+import org.elasticsearch.action.bulk.BulkRequest;
+import org.elasticsearch.action.delete.DeleteRequest;
+import org.elasticsearch.action.get.GetRequest;
+import org.elasticsearch.action.get.MultiGetRequest;
+import org.elasticsearch.action.index.IndexRequest;
+import org.elasticsearch.action.search.SearchRequest;
+import org.elasticsearch.action.update.UpdateRequest;
+import org.elasticsearch.client.RestClient;
+import org.elasticsearch.client.RestClientBuilder;
+import org.elasticsearch.client.RestHighLevelClient;
+import org.elasticsearch.client.sniff.Sniffer;
+import org.elasticsearch.client.sniff.SnifferBuilder;
+import org.elasticsearch.rest.RestStatus;
+import org.elasticsearch.search.builder.SearchSourceBuilder;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+
+/**
+ * Represents an Elasticsearch producer.
+ */
+public class ElasticsearchProducer extends DefaultProducer {
+
+    private static final Logger LOG = LoggerFactory.getLogger(ElasticsearchProducer.class);
+
+    protected final ElasticsearchConfiguration configuration;
+    private RestClient client;
+    private Sniffer sniffer;
+
+    public ElasticsearchProducer(ElasticsearchEndpoint endpoint, ElasticsearchConfiguration configuration) {
+        super(endpoint);
+        this.configuration = configuration;
+        this.client = endpoint.getClient();
+    }
+
+    private ElasticsearchOperation resolveOperation(Exchange exchange) {
+        // 1. Operation can be driven by either (in order of preference):
+        // a. If the body is an ActionRequest the operation is set by the type
+        // of request.
+        // b. If the body is not an ActionRequest, the operation is set by the
+        // header if it exists.
+        // c. If neither the operation can not be derived from the body or
+        // header, the configuration is used.
+        // In the event we can't discover the operation from a, b or c we throw
+        // an error.
+        Object request = exchange.getIn().getBody();
+        if (request instanceof IndexRequest) {
+            return ElasticsearchOperation.Index;
+        } else if (request instanceof GetRequest) {
+            return ElasticsearchOperation.GetById;
+        } else if (request instanceof MultiGetRequest) {
+            return ElasticsearchOperation.MultiGet;
+        } else if (request instanceof UpdateRequest) {
+            return ElasticsearchOperation.Update;
+        } else if (request instanceof BulkRequest) {
+            // do we want bulk or bulk_index?
+            if (configuration.getOperation() == ElasticsearchOperation.BulkIndex) {
+                return configuration.getOperation().BulkIndex;
+            } else {
+                return configuration.getOperation().Bulk;
+            }
+        } else if (request instanceof DeleteRequest) {
+            return ElasticsearchOperation.Delete;
+        } else if (request instanceof SearchRequest) {
+            return ElasticsearchOperation.Search;
+        } else if (request instanceof DeleteIndexRequest) {
+            return ElasticsearchOperation.DeleteIndex;
+        }
+
+        ElasticsearchOperation operationConfig = exchange.getIn().getHeader(ElasticsearchConstants.PARAM_OPERATION, ElasticsearchOperation.class);
+        if (operationConfig == null) {
+            operationConfig = configuration.getOperation();
+        }
+        if (operationConfig == null) {
+            throw new IllegalArgumentException(ElasticsearchConstants.PARAM_OPERATION + "" value '"" + operationConfig + ""' is not supported"");
+        }
+        return operationConfig;
+    }
+
+    public void process(Exchange exchange) throws Exception {
+        if (configuration.getDisconnect() && client == null) {
+            startClient();
+        }
+        RestHighLevelClient restHighLevelClient = new RestHighLevelClient(client);
+        // 2. Index and type will be set by:
+        // a. If the incoming body is already an action request
+        // b. If the body is not an action request we will use headers if they
+        // are set.
+        // c. If the body is not an action request and the headers aren't set we
+        // will use the configuration.
+        // No error is thrown by the component in the event none of the above
+        // conditions are met. The java es client
+        // will throw.
+
+        Message message = exchange.getIn();
+        final ElasticsearchOperation operation = resolveOperation(exchange);
+
+        // Set the index/type headers on the exchange if necessary. This is used
+        // for type conversion.
+        boolean configIndexName = false;
+        String indexName = message.getHeader(ElasticsearchConstants.PARAM_INDEX_NAME, String.class);
+        if (indexName == null) {
+            message.setHeader(ElasticsearchConstants.PARAM_INDEX_NAME, configuration.getIndexName());
+            configIndexName = true;
+        }
+
+        boolean configIndexType = false;
+        String indexType = message.getHeader(ElasticsearchConstants.PARAM_INDEX_TYPE, String.class);
+        if (indexType == null) {
+            message.setHeader(ElasticsearchConstants.PARAM_INDEX_TYPE, configuration.getIndexType());
+            configIndexType = true;
+        }
+
+        boolean configWaitForActiveShards = false;
+        Integer waitForActiveShards = message.getHeader(ElasticsearchConstants.PARAM_WAIT_FOR_ACTIVE_SHARDS, Integer.class);
+        if (waitForActiveShards == null) {
+            message.setHeader(ElasticsearchConstants.PARAM_WAIT_FOR_ACTIVE_SHARDS, configuration.getWaitForActiveShards());
+            configWaitForActiveShards = true;
+        }
+
+        if (operation == ElasticsearchOperation.Index) {
+            IndexRequest indexRequest = ElasticsearchActionRequestConverter.toIndexRequest(message.getBody(), exchange);
+            message.setBody(restHighLevelClient.index(indexRequest).getId());
+        } else if (operation == ElasticsearchOperation.Update) {
+            UpdateRequest updateRequest = ElasticsearchActionRequestConverter.toUpdateRequest(message.getBody(Map.class), exchange);
+            message.setBody(restHighLevelClient.update(updateRequest).getId());
+        } else if (operation == ElasticsearchOperation.GetById) {
+            GetRequest getRequest = ElasticsearchActionRequestConverter.toGetRequest(message.getBody(), exchange);
+            message.setBody(restHighLevelClient.get(getRequest));
+        } else if (operation == ElasticsearchOperation.Bulk) {
+            BulkRequest bulkRequest = message.getBody(BulkRequest.class);
+            message.setBody(restHighLevelClient.bulk(bulkRequest).getItems());
+        } else if (operation == ElasticsearchOperation.BulkIndex) {
+            BulkRequest bulkRequest = ElasticsearchActionRequestConverter.toBulkRequest(message.getBody(), exchange);
+            List<String> indexedIds = Arrays.stream(restHighLevelClient.bulk(bulkRequest).getItems())
+                .map(BulkItemResponse::getId)
+                .collect(Collectors.toList());
+            message.setBody(indexedIds);
+        } else if (operation == ElasticsearchOperation.Delete) {
+            DeleteRequest deleteRequest = ElasticsearchActionRequestConverter.toDeleteRequest(message.getBody(), exchange);
+            message.setBody(restHighLevelClient.delete(deleteRequest).getResult());
+        } else if (operation == ElasticsearchOperation.DeleteIndex) {
+            DeleteRequest deleteRequest = ElasticsearchActionRequestConverter.toDeleteRequest(message.getBody(), exchange);
+            message.setBody(client.performRequest(""Delete"", deleteRequest.index()).getStatusLine().getStatusCode());
+        } else if (operation == ElasticsearchOperation.Exists) {
+            // ExistsRequest API is deprecated, using SearchRequest instead with size=0 and terminate_after=1
+            SearchSourceBuilder sourceBuilder = new SearchSourceBuilder();
+            sourceBuilder.size(0);
+            sourceBuilder.terminateAfter(1);
+            SearchRequest searchRequest = new SearchRequest(exchange.getIn().getHeader(ElasticsearchConstants.PARAM_INDEX_NAME, String.class));
+            searchRequest.source(sourceBuilder);
+            try {
+                restHighLevelClient.search(searchRequest);
+                message.setBody(true);
+            } catch (ElasticsearchStatusException e) {
+                if (e.status().equals(RestStatus.NOT_FOUND)) {
+                    message.setBody(false);
+                } else {
+                    throw new IllegalStateException(e);
+                }
+
+            }
+        } else if (operation == ElasticsearchOperation.Search) {
+            SearchRequest searchRequest = ElasticsearchActionRequestConverter.toSearchRequest(message.getBody(), exchange);
+            message.setBody(restHighLevelClient.search(searchRequest).getHits());
+        } else {
+            throw new IllegalArgumentException(ElasticsearchConstants.PARAM_OPERATION + "" value '"" + operation + ""' is not supported"");
+        }
+
+        // If we set params via the configuration on this exchange, remove them
+        // now. This preserves legacy behavior for this component and enables a
+        // use case where one message can be sent to multiple elasticsearch
+        // endpoints where the user is relying on the endpoint configuration
+        // (index/type) rather than header values. If we do not clear this out
+        // sending the same message (index request, for example) to multiple
+        // elasticsearch endpoints would have the effect overriding any
+        // subsequent endpoint index/type with the first endpoint index/type.
+        if (configIndexName) {
+            message.removeHeader(ElasticsearchConstants.PARAM_INDEX_NAME);
+        }
+
+        if (configIndexType) {
+            message.removeHeader(ElasticsearchConstants.PARAM_INDEX_TYPE);
+        }
+
+        if (configWaitForActiveShards) {
+            message.removeHeader(ElasticsearchConstants.PARAM_WAIT_FOR_ACTIVE_SHARDS);
+        }
+        if (configuration.getDisconnect()) {
+            client.close();
+            client = null;
+            if (configuration.getEnableSniffer()) {
+                sniffer.close();
+                sniffer = null;
+            }
+        }
+
+    }
+
+    @Override
+    @SuppressWarnings(""unchecked"")
+    protected void doStart() throws Exception {
+        super.doStart();
+        if (!configuration.getDisconnect()) {
+            startClient();
+        }
+    }
+
+    private void startClient() throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, UnknownHostException {
+        if (client == null) {
+            LOG.info(""Connecting to the ElasticSearch cluster: "" + configuration.getClusterName());
+            if (configuration.getHostAddressesList() != null
+                && !configuration.getHostAddressesList().isEmpty()) {
+                client = createClient();
+            } else {
+                LOG.warn(""Incorrect ip address and port parameters settings for ElasticSearch cluster"");
+            }
+        }
+    }
+
+    private RestClient createClient() throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {
+        final RestClientBuilder builder = RestClient.builder(configuration.getHostAddressesList().toArray(new HttpHost[0]));
+        builder.setMaxRetryTimeoutMillis(configuration.getMaxRetryTimeout());
+        builder.setRequestConfigCallback(requestConfigBuilder ->
+            requestConfigBuilder.setConnectTimeout(configuration.getConnectionTimeout()).setSocketTimeout(configuration.getSocketTimeout()));
+        if (configuration.getUser() != null && configuration.getPassword() != null) {
+            final CredentialsProvider credentialsProvider = new BasicCredentialsProvider();
+            credentialsProvider.setCredentials(AuthScope.ANY, new UsernamePasswordCredentials(configuration.getUser(), configuration.getPassword()));
+            builder.setHttpClientConfigCallback(httpClientBuilder -> {
+                httpClientBuilder.setDefaultCredentialsProvider(credentialsProvider);
+                return httpClientBuilder;
+            });
+        }
+        final RestClient restClient = builder.build();
+        if (configuration.getEnableSniffer()) {
+            SnifferBuilder snifferBuilder = Sniffer.builder(restClient);
+            snifferBuilder.setSniffIntervalMillis(configuration.getSnifferInterval());
+            snifferBuilder.setSniffAfterFailureDelayMillis(configuration.getSniffAfterFailureDelay());
+            sniffer = snifferBuilder.build();
+        }
+        return restClient;
+    }
+
+
+    @Override
+    protected void doStop() throws Exception {
+        if (client != null) {
+            LOG.info(""Disconnecting from ElasticSearch cluster: {}"", configuration.getClusterName());
+            client.close();","[{'comment': 'If possible use IOHelper.close for these close calls', 'commenter': 'davsclaus'}]"
2018,components/camel-aws/src/main/java/org/apache/camel/component/aws/sqs/SqsComponent.java,"@@ -62,6 +62,10 @@ protected Endpoint createEndpoint(String uri, String remaining, Map<String, Obje
             throw new IllegalArgumentException(""Extending message visibility (extendMessageVisibility) requires visibilityTimeout to be set on the Endpoint."");
         }
         
+        if (configuration.isFifoQueue() && configuration.getMessageGroupIdStrategy() == null) {","[{'comment': 'Use ObjectHelper here instead of null checking', 'commenter': 'oscerd'}, {'comment': 'Will change to `ObjectHelper.isEmpty(configuration.getMessageGroupIdStrategy())`', 'commenter': 'jonmcewen'}]"
2018,components/camel-aws/src/main/java/org/apache/camel/component/aws/sqs/SqsConfiguration.java,"@@ -364,4 +380,44 @@ public Integer getProxyPort() {
     public void setProxyPort(Integer proxyPort) {
         this.proxyPort = proxyPort;
     }
+
+    /**
+     * Since *Camel 2.20*. Only for FIFO queues. Strategy for setting the messageGroupId on the message.
+     * Can be one of the following options: *useConstant*, *useExchangeId*, *useHeaderValue*.
+     * For the *useHeaderValue* option, the value of header ""CamelAwsMessageGroupId"" will be used.","[{'comment': 'Specify the SqsConstants entry here rather than the literal value of the header field.', 'commenter': 'CandleCandle'}, {'comment': 'Like this?\r\n\r\nFor the *useHeaderValue* option, the value of header SqsConstants.MESSAGE_GROUP_ID_HEADER will be used.', 'commenter': 'jonmcewen'}, {'comment': 'Sorry, just seen this response; something like that, yes. You can also use an `@see` javadoc annotation, which will generate a href to the constant when the javadoc tool is used.', 'commenter': 'CandleCandle'}]"
2018,components/camel-aws/src/main/java/org/apache/camel/component/aws/sqs/SqsConfiguration.java,"@@ -83,6 +87,18 @@
     private String redrivePolicy;
 
     /**
+     *  Whether or not the queue is a FIFO queue
+     */
+    public boolean isFifoQueue() {
+        // AWS docs suggest this is valid derivation.
+        // FIFO queue names must end with .fifo, and standard queues cannot
+        if (queueName.endsWith("".fifo"")) {","[{'comment': 'Please create a constant and also put it on the left side of the comparison. Thanks.', 'commenter': 'quiquep'}, {'comment': ""I don't think a constant would add any value here.  Also note that this is not an `equals()` comparison, and queueName cannot be null, as this is validated in `createEndpoint()`"", 'commenter': 'jonmcewen'}, {'comment': 'Makes sense. Thanks.', 'commenter': 'quiquep'}]"
2046,components/camel-amqp/src/main/java/org/apache/camel/component/amqp/AMQPConnectionDetails.java,"@@ -28,13 +28,19 @@
     public static final String AMQP_USERNAME = ""AMQP_SERVICE_USERNAME"";
 
     public static final String AMQP_PASSWORD = ""AMQP_SERVICE_PASSWORD"";
+    
+    private static final String KEYSTORE = ""./src/test/resources/broker.ks"";
+
+    private static final String TRUSTSTORE = ""./src/test/resources/broker.ks"";","[{'comment': 'Why are you pointing to test folder? I guess you need to define a different default value for these field', 'commenter': 'oscerd'}]"
2065,platforms/karaf/features/src/main/resources/features.xml,"@@ -1397,6 +1397,7 @@
     <bundle>mvn:org.apache.camel/camel-linkedin/${project.version}</bundle>
   </feature>
   <feature name='camel-leveldb' version='${project.version}' resolver='(obr)' start-level='50'>
+    <feature prerequisite=""true"">wrap</feature>","[{'comment': '@gnodet I have not seen this attribute before ` prerequisite` in use in karaf features. Is this a new thing or in other words does it work on karaf 4.0.x onwards or 4.1.x onwards. And what does it really do? ', 'commenter': 'davsclaus'}]"
2070,components/camel-yql/src/main/java/org/apache/camel/component/yql/YqlComponent.java,"@@ -0,0 +1,42 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.yql;
+
+import java.util.Map;
+import org.apache.camel.Endpoint;
+import org.apache.camel.component.yql.configuration.YqlConfiguration;
+import org.apache.camel.component.yql.configuration.YqlConfigurationValidator;
+import org.apache.camel.impl.DefaultComponent;
+
+public class YqlComponent extends DefaultComponent {
+
+    @Override
+    protected Endpoint createEndpoint(final String uri, final String remaining, final Map<String, Object> parameters) throws Exception {
+        final YqlConfiguration configuration = new YqlConfiguration();
+        configuration.setQuery(remaining);
+        configuration.setFormat((String) parameters.getOrDefault(""format"", ""json""));","[{'comment': 'Camel can do this automatic in the setProperties(configuration, parameters) you do further below. If you want to set default values then set them on the configuration class instead', 'commenter': 'davsclaus'}, {'comment': 'Done', 'commenter': 'carlphilipp'}]"
2070,components/camel-yql/src/main/java/org/apache/camel/component/yql/configuration/YqlConfiguration.java,"@@ -0,0 +1,83 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.yql.configuration;
+
+import org.apache.camel.spi.Metadata;
+import org.apache.camel.spi.UriParam;
+import org.apache.camel.spi.UriParams;
+import org.apache.camel.spi.UriPath;
+
+@UriParams
+public class YqlConfiguration {
+
+    @UriPath
+    @Metadata(required = ""true"")
+    private String query;
+
+    @UriParam
+    private String format;","[{'comment': 'Here you can set the default values. ', 'commenter': 'davsclaus'}]"
2070,components/camel-yql/src/main/java/org/apache/camel/component/yql/YqlEndpoint.java,"@@ -0,0 +1,56 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.yql;
+
+import org.apache.camel.Consumer;
+import org.apache.camel.Processor;
+import org.apache.camel.Producer;
+import org.apache.camel.component.yql.configuration.YqlConfiguration;
+import org.apache.camel.impl.DefaultEndpoint;
+import org.apache.camel.spi.UriEndpoint;
+import org.apache.camel.spi.UriParam;
+
+@UriEndpoint(firstVersion = ""2.21.0"", scheme = ""yql"", title = ""Yahoo Query Language"", syntax = ""yql:query"", producerOnly = true, label = ""api,http"")","[{'comment': 'The labels should likely be something better to caregorize what this component is', 'commenter': 'davsclaus'}, {'comment': 'is `label=""yql""` ok?', 'commenter': 'carlphilipp'}]"
2070,components/camel-yql/src/main/java/org/apache/camel/component/yql/client/YqlClient.java,"@@ -0,0 +1,60 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.yql.client;
+
+import java.net.URI;
+import org.apache.http.client.methods.CloseableHttpResponse;
+import org.apache.http.client.methods.HttpGet;
+import org.apache.http.client.utils.URIBuilder;
+import org.apache.http.impl.client.CloseableHttpClient;
+import org.apache.http.impl.client.HttpClients;
+import org.apache.http.util.EntityUtils;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class YqlClient {
+
+    private static final Logger LOG = LoggerFactory.getLogger(YqlClient.class);
+    private static final CloseableHttpClient HTTP_CLIENT = HttpClients.createDefault();
+
+    public YqlResponse get(final String query, final String format, final boolean diagnostics, final String callback) throws Exception {
+
+        final URI uri = new URIBuilder()
+                .setScheme(""http"")
+                .setHost(""query.yahooapis.com"")","[{'comment': 'Would you ever need to configure the host and path? If so then we can make them configurable on the component level.', 'commenter': 'davsclaus'}]"
2070,components/camel-yql/src/main/java/org/apache/camel/component/yql/client/YqlClient.java,"@@ -0,0 +1,60 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.yql.client;
+
+import java.net.URI;
+import org.apache.http.client.methods.CloseableHttpResponse;
+import org.apache.http.client.methods.HttpGet;
+import org.apache.http.client.utils.URIBuilder;
+import org.apache.http.impl.client.CloseableHttpClient;
+import org.apache.http.impl.client.HttpClients;
+import org.apache.http.util.EntityUtils;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class YqlClient {
+
+    private static final Logger LOG = LoggerFactory.getLogger(YqlClient.class);
+    private static final CloseableHttpClient HTTP_CLIENT = HttpClients.createDefault();
+
+    public YqlResponse get(final String query, final String format, final boolean diagnostics, final String callback) throws Exception {
+
+        final URI uri = new URIBuilder()
+                .setScheme(""http"")
+                .setHost(""query.yahooapis.com"")
+                .setPath(""/v1/public/yql"")
+                .setParameter(""format"", format)
+                .setParameter(""diagnostics"", Boolean.toString(diagnostics))
+                .setParameter(""env"", ""store://datatables.org/alltableswithkeys"")","[{'comment': 'Should env not be configurable?', 'commenter': 'davsclaus'}, {'comment': 'Yes it should, updated', 'commenter': 'carlphilipp'}]"
2070,components/camel-yql/src/test/resources/log4j2.properties,"@@ -0,0 +1,33 @@
+## ---------------------------------------------------------------------------
+## Licensed to the Apache Software Foundation (ASF) under one or more
+## contributor license agreements.  See the NOTICE file distributed with
+## this work for additional information regarding copyright ownership.
+## The ASF licenses this file to You under the Apache License, Version 2.0
+## (the ""License""); you may not use this file except in compliance with
+## the License.  You may obtain a copy of the License at
+##
+##      http://www.apache.org/licenses/LICENSE-2.0
+##
+## Unless required by applicable law or agreed to in writing, software
+## distributed under the License is distributed on an ""AS IS"" BASIS,
+## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+## See the License for the specific language governing permissions and
+## limitations under the License.
+## ---------------------------------------------------------------------------
+
+appender.file.type = File
+appender.file.name = file
+appender.file.fileName = target/camel-sql-component-test.log","[{'comment': 'The file name should be the component name', 'commenter': 'davsclaus'}, {'comment': 'Fixed', 'commenter': 'carlphilipp'}]"
2070,components/camel-yql/src/main/java/org/apache/camel/component/yql/client/YqlClient.java,"@@ -0,0 +1,60 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.yql.client;
+
+import java.net.URI;
+import org.apache.http.client.methods.CloseableHttpResponse;
+import org.apache.http.client.methods.HttpGet;
+import org.apache.http.client.utils.URIBuilder;
+import org.apache.http.impl.client.CloseableHttpClient;
+import org.apache.http.impl.client.HttpClients;
+import org.apache.http.util.EntityUtils;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class YqlClient {
+
+    private static final Logger LOG = LoggerFactory.getLogger(YqlClient.class);
+    private static final CloseableHttpClient HTTP_CLIENT = HttpClients.createDefault();","[{'comment': 'Can we avoid a static shared client in the JVM? This dont work well on app servers etc. Is the HTTP_CLIENT thread safe also? If it should be shared/reused then we can have a http client on the component that they producers can reuse. ', 'commenter': 'davsclaus'}, {'comment': 'Yes `CloseableHttpClient` is thread safe. I added a connection manager that can be set on the component.', 'commenter': 'carlphilipp'}]"
2070,components/camel-yql/src/main/java/org/apache/camel/component/yql/configuration/YqlConfiguration.java,"@@ -0,0 +1,83 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.yql.configuration;
+
+import org.apache.camel.spi.Metadata;
+import org.apache.camel.spi.UriParam;
+import org.apache.camel.spi.UriParams;
+import org.apache.camel.spi.UriPath;
+
+@UriParams
+public class YqlConfiguration {
+
+    @UriPath
+    @Metadata(required = ""true"")
+    private String query;
+
+    @UriParam
+    private String format;
+
+    @UriParam
+    private boolean diagnostics;
+
+    @UriParam
+    private String callback;
+
+    public String getQuery() {
+        return query;
+    }
+
+    /**
+     * Set the YQL query
+     */
+    public void setQuery(final String query) {
+        this.query = query;
+    }
+
+    public String getFormat() {
+        return format;
+    }
+
+    /**
+     * Set the YQL format, xml or json
+     */
+    public void setFormat(final String format) {
+        this.format = format;
+    }
+
+    public boolean isDiagnostics() {
+        return diagnostics;
+    }
+
+    /**
+     * Set if diagnostics should be included in the query
+     */
+    public void setDiagnostics(final boolean diagnostics) {
+        this.diagnostics = diagnostics;
+    }
+
+    public String getCallback() {
+        return callback;
+    }
+
+    /**
+     * Set the callback function","[{'comment': 'Can you add some more documentation what this callback function is used for? And also put some more into the adoc file about this, and maybe with an example.', 'commenter': 'davsclaus'}, {'comment': 'Added a bunch of comments', 'commenter': 'carlphilipp'}]"
2070,components/camel-yql/src/main/java/org/apache/camel/component/yql/YqlProducer.java,"@@ -0,0 +1,55 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.yql;
+
+import org.apache.camel.Exchange;
+import org.apache.camel.component.yql.client.YqlClient;
+import org.apache.camel.component.yql.client.YqlResponse;
+import org.apache.camel.component.yql.configuration.YqlConfiguration;
+import org.apache.camel.impl.DefaultProducer;
+
+/**
+ * A Producer that send messages to YQL
+ */
+public class YqlProducer extends DefaultProducer {
+
+    static final String CAMEL_YQL_HTTP_STATUS = ""CamelYqlHttpStatus"";
+    static final String CAMEL_YQL_HTTP_REQUEST = ""CamelYqlHttpRequest"";
+
+    private final YqlEndpoint endpoint;
+    private final YqlClient yahooClient;
+
+    YqlProducer(final YqlEndpoint endpoint) {
+        super(endpoint);
+        this.endpoint = endpoint;
+        this.yahooClient = new YqlClient();
+    }
+
+    @Override
+    public void process(final Exchange exchange) throws Exception {
+        final YqlConfiguration configuration = endpoint.getConfiguration();
+        final YqlResponse yqlResponse = yahooClient.get(
+                configuration.getQuery(),
+                configuration.getFormat(),
+                configuration.isDiagnostics(),
+                configuration.getCallback()
+        );
+        exchange.getIn().setHeader(CAMEL_YQL_HTTP_STATUS, yqlResponse.getStatus());
+        exchange.getIn().setHeader(CAMEL_YQL_HTTP_REQUEST, yqlResponse.getHttpRequest());
+        exchange.getIn().setBody(yqlResponse.getBody());","[{'comment': 'I wonder if there was an error, eg status code is 5xx, 4xx etc if we should not throw an exception instead by default. And then allow to turn this on|off - this is how the http components does it. Then its easier for Camel users to know if something went wrong.', 'commenter': 'davsclaus'}, {'comment': 'Updated that part of the code with a flag to turn the feature on|off', 'commenter': 'carlphilipp'}]"
2071,components/camel-aws-xray/pom.xml,"@@ -0,0 +1,101 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--
+    Licensed to the Apache Software Foundation (ASF) under one or more
+    contributor license agreements.  See the NOTICE file distributed with
+    this work for additional information regarding copyright ownership.
+    The ASF licenses this file to You under the Apache License, Version 2.0
+    (the ""License""); you may not use this file except in compliance with
+    the License.  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an ""AS IS"" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+<project xmlns=""http://maven.apache.org/POM/4.0.0""
+  xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
+  xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <artifactId>components</artifactId>
+    <groupId>org.apache.camel</groupId>
+    <version>2.19.2-SNAPSHOT</version>
+  </parent>
+
+  <artifactId>camel-aws-xray</artifactId>
+  <packaging>jar</packaging>
+
+  <name>Camel :: AWS :: XRay</name>
+  <description>Distributed tracing using AWS XRay</description>
+
+  <properties>
+    <aws-xray.version>1.2.0</aws-xray.version>
+    <firstVersion>2.19.2</firstVersion>
+    <label>monitoring,microservice</label>
+    <title>XRay</title>
+
+    <camel.osgi.export.pkg>org.apache.camel.aws-xray.*</camel.osgi.export.pkg>
+  </properties>
+
+  <dependencyManagement>
+    <dependencies>
+      <dependency>
+        <groupId>com.amazonaws</groupId>
+        <artifactId>aws-xray-recorder-sdk-bom</artifactId>
+        <version>${aws-xray.version}</version>
+        <type>pom</type>
+        <scope>import</scope>
+      </dependency>
+    </dependencies>
+  </dependencyManagement>
+
+  <dependencies>
+
+    <dependency>
+      <groupId>org.apache.camel</groupId>
+      <artifactId>camel-core</artifactId>
+    </dependency>
+
+    <!-- AWS XRay -->
+    <dependency>
+      <!-- Basic functionality for creating segments and transmitting segments. Includes
+           AWSXRayServletFilter for instrumenting incoming requests -->
+      <groupId>com.amazonaws</groupId>
+      <artifactId>aws-xray-recorder-sdk-core</artifactId>
+    </dependency>
+    <dependency>
+      <!-- Instruments calls to AWS services made with AWS SDK for Java clients by adding a tracing
+           client as a request handler -->
+      <groupId>com.amazonaws</groupId>
+      <artifactId>aws-xray-recorder-sdk-aws-sdk</artifactId>
+    </dependency>
+    <dependency>
+      <!-- Instruments outbound HTTP calls made with Apache HTTP clients -->
+      <groupId>com.amazonaws</groupId>
+      <artifactId>aws-xray-recorder-sdk-apache-http</artifactId>
+    </dependency>
+
+    <!-- test dependencies -->
+    <dependency>
+      <groupId>org.hamcrest</groupId>
+      <artifactId>hamcrest-all</artifactId>
+      <version>1.3</version>
+    </dependency>
+    <dependency>
+      <groupId>org.apache.camel</groupId>
+      <artifactId>camel-test-spring</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.json</groupId>","[{'comment': 'Afair then ASF does not accept the license of org.json, which is their own special license. So we would need you to remove this dependency and use some other library instead.', 'commenter': 'davsclaus'}]"
2071,components/camel-aws-xray/src/main/java/org/apache/camel/component/aws/xray/EIPTracingStrategy.java,"@@ -0,0 +1,58 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.aws.xray;
+
+import com.amazonaws.xray.AWSXRay;
+import com.amazonaws.xray.entities.Subsegment;
+import java.lang.invoke.MethodHandles;
+import org.apache.camel.CamelContext;
+import org.apache.camel.Exchange;
+import org.apache.camel.Processor;
+import org.apache.camel.model.ProcessorDefinition;
+import org.apache.camel.processor.DelegateAsyncProcessor;
+import org.apache.camel.spi.InterceptStrategy;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class EIPTracingStrategy implements InterceptStrategy {","[{'comment': 'This is not so good when using an InterceptStrategy. Look at how camel-zipkin or camel-opentracing are doing it with using a RoutePolicy and EventNotifier to better handle tracing more accurately', 'commenter': 'davsclaus'}]"
2072,components/camel-aws-xray/pom.xml,"@@ -0,0 +1,101 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--
+    Licensed to the Apache Software Foundation (ASF) under one or more
+    contributor license agreements.  See the NOTICE file distributed with
+    this work for additional information regarding copyright ownership.
+    The ASF licenses this file to You under the Apache License, Version 2.0
+    (the ""License""); you may not use this file except in compliance with
+    the License.  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an ""AS IS"" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+<project xmlns=""http://maven.apache.org/POM/4.0.0""
+  xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
+  xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <artifactId>components</artifactId>
+    <groupId>org.apache.camel</groupId>
+    <version>2.19.2-SNAPSHOT</version>","[{'comment': 'All the version should be 2.21.0-SNAPSHOT in this PR.', 'commenter': 'oscerd'}]"
2093,components/camel-spring/src/main/java/org/apache/camel/spring/spi/TransactionErrorHandler.java,"@@ -154,7 +154,7 @@ protected void processInTransaction(final Exchange exchange) throws Exception {
             if (log.isDebugEnabled()) {
                 // log exception if there was a cause exception so we have the stack trace
                 Exception cause = exchange.getException();
-                if (cause != null) {
+                if (cause != null && log.isDebugEnabled()) {","[{'comment': 'log debug enable is already checked above', 'commenter': 'davsclaus'}]"
2093,camel-core/src/test/java/org/apache/camel/LanguageTestSupport.java,"@@ -94,8 +94,9 @@ protected Object evaluateExpression(String expressionText, String expectedValue)
         } else {
             value = expression.evaluate(exchange, Object.class);
         }
-
-        log.debug(""Evaluated expression: {} on exchange: {} result: {}"", expression, exchange, value);
+        if (log.isDebugEnabled()) {","[{'comment': 'This is not needed when using {}', 'commenter': 'davsclaus'}]"
2093,components/camel-jms/src/main/java/org/apache/camel/component/jms/reply/QueueReplyManager.java,"@@ -131,7 +131,9 @@ protected AbstractMessageListenerContainer createListenerContainer() throws Exce
                 answer = new SharedQueueMessageListenerContainer(endpoint, fixedMessageSelector);
                 // must use cache level consumer for fixed message selector
                 answer.setCacheLevel(DefaultMessageListenerContainer.CACHE_CONSUMER);
-                log.debug(""Using shared queue: "" + endpoint.getReplyTo() + "" with fixed message selector ["" + fixedMessageSelector + ""] as reply listener: "" + answer);
+                if (log.isDebugEnabled()) {","[{'comment': 'We could use `{}` style here', 'commenter': 'davsclaus'}]"
2093,components/camel-test/src/main/java/org/apache/camel/test/junit4/LanguageTestSupport.java,"@@ -85,8 +85,9 @@ protected void assertExpression(String expressionText, String expectedValue, Str
         } else {
             value = expression.evaluate(exchange, Object.class);
         }
-
-        log.debug(""Evaluated expression: "" + expression + "" on exchange: "" + exchange + "" result: "" + value);
+        if (log.isDebugEnabled()) {","[{'comment': 'The rest is just unit tests and tooling so its not as important as runtime camel-core etc. However the changes are fine to do, but maybe favor using `{}` style', 'commenter': 'davsclaus'}, {'comment': 'In general, you do not recommend increasing complexity with the if statement. right? ', 'commenter': 'mehranhassani'}]"
2123,camel-core/src/main/java/org/apache/camel/processor/PollEnricher.java,"@@ -217,6 +220,18 @@ public boolean process(Exchange exchange, AsyncCallback callback) {
         Consumer delegate = consumer;
         if (consumer instanceof EventDrivenPollingConsumer) {
             delegate = ((EventDrivenPollingConsumer) consumer).getDelegateConsumer();
+
+            if (delegate instanceof GenericFileConsumer) {","[{'comment': ""This wont work, we cannot change the state of the consumer as you can have concurrent pollEnrich's. "", 'commenter': 'davsclaus'}, {'comment': '@davsclaus, indeed, as the consumer is shared between many exchanges that are poll enriched concurrently.\r\n\r\nAs I result, I can see no option for implementing the file filtering in the GenericFileConsumer.isMatched method as its state belongs to a different context. A simple solution is to apply another isMatched check in the PollEnricher.process, when the instance of the current exchange is available. However this would constitute a enhancement of the PollEnricher  instead of reusing an existing method. What do you think?', 'commenter': 'sermojohn'}]"
2123,camel-core/src/main/java/org/apache/camel/component/file/GenericFileConsumer.java,"@@ -53,6 +54,8 @@
     protected volatile boolean prepareOnStartup;
     private final Pattern includePattern;
     private final Pattern excludePattern;
+    private Pattern fileNamePattern;
+    private Predicate<GenericFile> fileNamePredicate;","[{'comment': 'Dont use java8s predicate as it confused with camel predicate. ', 'commenter': 'davsclaus'}]"
2123,camel-core/src/test/java/org/apache/camel/component/file/FileConsumePollEnrichFilePredicateTest.java,"@@ -0,0 +1,75 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.file;
+
+import java.util.function.Predicate;
+import org.apache.camel.ContextTestSupport;
+import org.apache.camel.Exchange;
+import org.apache.camel.builder.RouteBuilder;
+import org.apache.camel.component.mock.MockEndpoint;
+
+public class FileConsumePollEnrichFilePredicateTest extends ContextTestSupport {
+
+    @Override
+    protected void setUp() throws Exception {
+        deleteDirectory(""target/enrich"");
+        deleteDirectory(""target/enrichdata"");
+        super.setUp();
+    }
+
+    public void testPollEnrichFileReject() throws Exception {
+        MockEndpoint mock = getMockEndpoint(""mock:result"");
+        mock.expectedMessageCount(1);
+        mock.expectedBodiesReceived((Object) null);
+
+        template.sendBody(""seda:start"", ""Start"");
+        log.info(""Sleeping for 1/4 sec before writing enrichdata file"");
+        Thread.sleep(250);
+        template.sendBodyAndHeader(""file://target/enrichdata"", ""O"", Exchange.FILE_NAME, ""AAA.dat"");
+        log.info(""... write done"");
+
+        assertMockEndpointsSatisfied();
+    }
+
+    public void testPollEnrichFileAccept() throws Exception {
+        MockEndpoint mock = getMockEndpoint(""mock:result"");
+        mock.expectedMessageCount(1);
+        mock.expectedBodiesReceived(""Hi Camel!"");
+
+        template.sendBody(""seda:start"", ""Start"");
+        log.info(""Sleeping for 1/4 sec before writing enrichdata file"");
+        Thread.sleep(250);
+        template.sendBodyAndHeader(""file://target/enrichdata"", ""Hi Camel!"", Exchange.FILE_NAME, ""AAA.dat"");
+        log.info(""... write done"");
+
+        assertMockEndpointsSatisfied();
+    }
+
+    @Override
+    protected RouteBuilder createRouteBuilder() throws Exception {
+        return new RouteBuilder() {
+            @Override
+            public void configure() throws Exception {
+                from(""seda:start"")
+                    .setHeader(Exchange.FILE_PREDICATE, () -> (Predicate<GenericFile>) genericFile -> genericFile.getFileLength() > 4)","[{'comment': 'No we should not use a complex object like a predicate in a header, its for smaller objects like a text etc.', 'commenter': 'davsclaus'}, {'comment': 'I understand your point, but as the static typing did not prevent me, I kind of abused it :)\r\n\r\nWhat do you think about implementing this in the DSL (PollEnrichDefinition), so its possible to define a Predicate for filtering the exchanges handled by the PollEnricher before even aggregating into the original exchange?\r\n\r\n', 'commenter': 'sermojohn'}, {'comment': 'No I dont think we should complicate things even more, lets close this PR and the JIRA ticket at this moment.', 'commenter': 'davsclaus'}]"
2125,camel-core/src/main/java/org/apache/camel/component/direct/DirectComponent.java,"@@ -36,7 +36,7 @@
     // on DefaultCamelContext
     private final Map<String, DirectConsumer> consumers = new HashMap<String, DirectConsumer>();
     @Metadata(label = ""producer"")
-    private boolean block;
+    private boolean block = true;","[{'comment': 'Add defaultValue in Metadata', 'commenter': 'oscerd'}]"
2125,camel-core/src/main/java/org/apache/camel/component/direct/DirectEndpoint.java,"@@ -44,7 +44,7 @@
     private String name;
 
     @UriParam(label = ""producer"")
-    private boolean block;
+    private boolean block = true;","[{'comment': 'Add defaultValue in Metadata', 'commenter': 'oscerd'}]"
2125,camel-core/src/main/java/org/apache/camel/component/directvm/DirectVmComponent.java,"@@ -40,7 +40,7 @@
     // on DefaultCamelContext
     private static final ConcurrentMap<String, DirectVmConsumer> CONSUMERS = new ConcurrentHashMap<String, DirectVmConsumer>();
     @Metadata(label = ""producer"")
-    private boolean block;
+    private boolean block = true;","[{'comment': 'Add defaultValue in Metadata', 'commenter': 'oscerd'}]"
2125,camel-core/src/main/java/org/apache/camel/component/directvm/DirectVmEndpoint.java,"@@ -40,7 +40,7 @@
     private String name;
 
     @UriParam(label = ""producer"")
-    private boolean block;
+    private boolean block = true;","[{'comment': 'Add DefaultValue in Metadata', 'commenter': 'oscerd'}]"
2129,camel-core/src/main/java/org/apache/camel/builder/NotifyBuilder.java,"@@ -192,7 +192,7 @@ public boolean onExchange(Exchange exchange) {
                 // and just continue to route that on the consumer side, which causes the EventNotifier not to
                 // emit events when the consumer received the exchange, as its already done. For example by
                 // ProducerTemplate which creates the UoW before producing messages.
-                if (exchange.getFromEndpoint() != null && exchange.getFromEndpoint() instanceof DirectEndpoint) {
+                if (exchange.getFromEndpoint() instanceof DirectEndpoint) {
                     return true;","[{'comment': 'exchange.getFromEndpoint() would be idempotent most of the time, so this ok.', 'commenter': 'aldettinger'}]"
2129,camel-core/src/main/java/org/apache/camel/component/bean/AbstractBeanProcessor.java,"@@ -118,7 +118,7 @@ public boolean process(Exchange exchange, AsyncCallback callback) {
 
         // is the message proxied using a BeanInvocation?
         BeanInvocation beanInvoke = null;
-        if (in.getBody() != null && in.getBody() instanceof BeanInvocation) {
+        if (in.getBody() instanceof BeanInvocation) {","[{'comment': 'same for getBody() => ok', 'commenter': 'aldettinger'}]"
2129,camel-core/src/main/java/org/apache/camel/model/cloud/ServiceCallExpressionConfiguration.java,"@@ -248,13 +248,13 @@ public Expression newInstance(CamelContext camelContext) throws Exception {
 
                     parameters.replaceAll(
                         (k, v) -> {
-                            if (v != null && v instanceof String) {
+                            if (v instanceof String) {
                                 try {
                                     v = camelContext.resolvePropertyPlaceholders((String) v);
                                 } catch (Exception e) {
                                     throw new IllegalArgumentException(
-                                        String.format(""Exception while resolving %s (%s)"", k, v.toString()),
-                                        e
+                                            String.format(""Exception while resolving %s (%s)"", k, v.toString()),
+                                            e","[{'comment': 'However, I would remove this change, or explain why it is needed.', 'commenter': 'aldettinger'}, {'comment': ""Will remove spurious formatting, note this is because Camel no longer provides intellij IDE configs mentioned here: http://camel.apache.org/set-up-your-ide.html\r\nI'm completely liable (especially when using refactoring utils) to change details like this without being aware. Is there a something you can share then I can just re-run the refactoring from scratch and force-push to my repo."", 'commenter': 'drekbour'}]"
2129,camel-core/src/main/java/org/apache/camel/model/cloud/ServiceCallServiceChooserConfiguration.java,"@@ -164,13 +164,13 @@ public ServiceChooser newInstance(CamelContext camelContext) throws Exception {
 
                 parameters.replaceAll(
                     (k, v) -> {
-                        if (v != null && v instanceof String) {
+                        if (v instanceof String) {
                             try {
                                 v = camelContext.resolvePropertyPlaceholders((String) v);
                             } catch (Exception e) {
                                 throw new IllegalArgumentException(
-                                    String.format(""Exception while resolving %s (%s)"", k, v.toString()),
-                                    e
+                                        String.format(""Exception while resolving %s (%s)"", k, v.toString()),
+                                        e","[{'comment': 'same here', 'commenter': 'aldettinger'}]"
2129,camel-core/src/main/java/org/apache/camel/model/cloud/ServiceCallServiceDiscoveryConfiguration.java,"@@ -171,13 +171,13 @@ public ServiceDiscovery newInstance(CamelContext camelContext) throws Exception
 
                 parameters.replaceAll(
                     (k, v) -> {
-                        if (v != null && v instanceof String) {
+                        if (v instanceof String) {
                             try {
                                 v = camelContext.resolvePropertyPlaceholders((String) v);
                             } catch (Exception e) {
                                 throw new IllegalArgumentException(
-                                    String.format(""Exception while resolving %s (%s)"", k, v.toString()),
-                                    e
+                                        String.format(""Exception while resolving %s (%s)"", k, v.toString()),
+                                        e","[{'comment': 'same here', 'commenter': 'aldettinger'}]"
2129,camel-core/src/main/java/org/apache/camel/model/cloud/ServiceCallServiceFilterConfiguration.java,"@@ -164,13 +164,13 @@ public ServiceFilter newInstance(CamelContext camelContext) throws Exception {
 
                 parameters.replaceAll(
                     (k, v) -> {
-                        if (v != null && v instanceof String) {
+                        if (v instanceof String) {
                             try {
                                 v = camelContext.resolvePropertyPlaceholders((String) v);
                             } catch (Exception e) {
                                 throw new IllegalArgumentException(
-                                    String.format(""Exception while resolving %s (%s)"", k, v.toString()),
-                                    e
+                                        String.format(""Exception while resolving %s (%s)"", k, v.toString()),
+                                        e","[{'comment': 'same here', 'commenter': 'aldettinger'}]"
2129,camel-core/src/main/java/org/apache/camel/model/cloud/ServiceCallServiceLoadBalancerConfiguration.java,"@@ -164,13 +164,13 @@ public ServiceLoadBalancer newInstance(CamelContext camelContext) throws Excepti
 
                 parameters.replaceAll(
                     (k, v) -> {
-                        if (v != null && v instanceof String) {
+                        if (v instanceof String) {
                             try {
                                 v = camelContext.resolvePropertyPlaceholders((String) v);
                             } catch (Exception e) {
                                 throw new IllegalArgumentException(
-                                    String.format(""Exception while resolving %s (%s)"", k, v.toString()),
-                                    e
+                                        String.format(""Exception while resolving %s (%s)"", k, v.toString()),
+                                        e","[{'comment': 'same here', 'commenter': 'aldettinger'}]"
2129,camel-core/src/test/java/org/apache/camel/builder/ExpressionClauseTest.java,"@@ -83,8 +83,8 @@ public void configure() throws Exception {
     public final class Extractor {
         public String extractName(DataHandler body) {
             DataSource ds = (body != null) ? body.getDataSource() : null;
-            if (ds != null && ds instanceof FileDataSource) {
-                return ((FileDataSource)ds).getName();
+            if (ds instanceof FileDataSource) {
+                return ((FileDataSource) ds).getName();","[{'comment': 'Same pattern here. Could you please remove all of them across the PR ?', 'commenter': 'aldettinger'}]"
2130,components/camel-jaxb/src/main/java/org/apache/camel/converter/jaxb/JaxbDataFormat.java,"@@ -136,6 +136,10 @@ public void marshal(Exchange exchange, Object graph, OutputStream stream) throws
             String charset = exchange.getProperty(Exchange.CHARSET_NAME, String.class);
             if (charset == null) {
                 charset = encoding;
+                //Propagate the encoding of the exchange","[{'comment': 'This looks a bit ugly. ', 'commenter': 'oscerd'}, {'comment': 'Maybe we can find a better way.', 'commenter': 'oscerd'}, {'comment': '@oscerd \r\nOk, what is the appropriate way to communicate the encoding?\r\n\r\nI based this on what is done by the file endpoint, and AFAIK how that is able to accomplish the same feature:\r\n```   \r\n    /**\r\n     * Set up the exchange properties with the options of the file endpoint\r\n     */\r\n    public void configureExchange(Exchange exchange) {\r\n        // Now we just set the charset property here\r\n        if (getCharset() != null) {\r\n            exchange.setProperty(Exchange.CHARSET_NAME, getCharset());\r\n        }\r\n    }```', 'commenter': 'IIlllII'}]"
2136,components/camel-undertow/src/main/java/org/apache/camel/component/undertow/DefaultUndertowHost.java,"@@ -37,6 +38,7 @@
     private CamelRootHandler rootHandler;
     private Undertow undertow;
     private String hostString;
+    private boolean http2Enabled;","[{'comment': 'Would it not be better if `http2Enabled` was part of `UndertowHostOptions`?\r\n\r\nIt would be more consistent with how other Undertow server options are configured on the builder object.', 'commenter': 'jamesnetherton'}, {'comment': 'I agree', 'commenter': 'oscerd'}]"
2136,platforms/spring-boot/components-starter/camel-undertow-starter/src/main/java/org/apache/camel/component/undertow/springboot/UndertowComponentConfiguration.java,"@@ -123,6 +123,10 @@ public void setResolvePropertyPlaceholders(
          * Set if the Undertow host should use direct buffers.
          */
         private Boolean directBuffers;
+        /**
+         * Set if the Undertow host should use http2 protocol.
+         */
+        private Boolean http2Enabled;","[{'comment': 'Why adding the option on component level again? You already have it in undertowHostOptions.', 'commenter': 'oscerd'}, {'comment': ""Sorry andrea, I didn't modify this class. I believe it was modified with the field http2Enabled itself once I build the code.\r\nHowever, I believe it is set correctly.\r\n\r\nhttps://github.com/apache/camel/blob/master/platforms/spring-boot/components-starter/camel-undertow-starter/src/main/java/org/apache/camel/component/undertow/springboot/UndertowComponentConfiguration.java#L113"", 'commenter': '1984shekhar'}]"
2143,components/camel-jsonpath/src/main/docs/jsonpath-language.adoc,"@@ -31,9 +31,9 @@ The JSonPath language supports 7 options which are listed below.
 | Name | Default | Java Type | Description
 | resultType |  | String | Sets the class name of the result type (type from output)
 | suppressExceptions | false | Boolean | Whether to suppress exceptions such as PathNotFoundException.
-| allowSimple | true | Boolean | Whether to allow in inlined simple exceptions in the json path expression
+| allowSimple | true | Boolean | Whether to allow in inlined simple exceptions in the JSON path expression
 | allowEasyPredicate | true | Boolean | Whether to allow using the easy predicate parser to pre-parse predicates.
-| writeAsString | false | Boolean | Whether to write the output of each row/element as a JSon String value instead of a Map/POJO value.
+| writeAsString | false | Boolean | Whether to write the output of each row/element as a JSON String value instead of a Map/POJO value.","[{'comment': 'This documentation come from the Javadoc so you have to edit the Java Code comments and then rebuild the module', 'commenter': 'oscerd'}]"
2144,components/camel-undertow/src/main/java/org/apache/camel/component/undertow/UndertowConstants.java,"@@ -0,0 +1,82 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.undertow;
+
+/**
+ * @author <a href=""https://github.com/ppalaga"">Peter Palaga</a>","[{'comment': 'Remove author tags in javadoc', 'commenter': 'davsclaus'}, {'comment': 'Fixed in a85b3e3', 'commenter': 'ppalaga'}]"
2144,components/camel-undertow/src/main/java/org/apache/camel/component/undertow/UndertowEndpoint.java,"@@ -87,6 +92,14 @@
     private boolean optionsEnabled;
     @UriParam(label = ""producer"")
     private CookieHandler cookieHandler;
+    @UriParam(label = ""producer"")","[{'comment': 'Add websocket as 2nd label, eg ""producer,websocket"" and do that for the other new websocket options', 'commenter': 'davsclaus'}, {'comment': 'Fixed in a85b3e3', 'commenter': 'ppalaga'}]"
2144,components/camel-undertow/src/main/java/org/apache/camel/component/undertow/UndertowProducer.java,"@@ -77,81 +83,135 @@ public UndertowEndpoint getEndpoint() {
         return endpoint;
     }
 
+    boolean isSendToAll(Message in) {
+        // header may be null; have to be careful here (and fallback to use sendToAll option configured from endpoint)
+        Boolean value = in.getHeader(UndertowConstants.SEND_TO_ALL, endpoint.getSendToAll(), Boolean.class);
+        return value == null ? false : value;
+    }
+
     @Override
     public boolean process(final Exchange camelExchange, final AsyncCallback callback) {
-        final URI uri;
-        final HttpString method;
-        try {
-            final String exchangeUri = UndertowHelper.createURL(camelExchange, getEndpoint());
-            uri = UndertowHelper.createURI(camelExchange, exchangeUri, getEndpoint());
-            method = UndertowHelper.createMethod(camelExchange, endpoint, camelExchange.getIn().getBody() != null);
-        } catch (final URISyntaxException e) {
-            camelExchange.setException(e);
-            callback.done(true);
-            return true;
-        }
-
-        final String pathAndQuery = URISupport.pathAndQueryOf(uri);
-
-        final UndertowHttpBinding undertowHttpBinding = endpoint.getUndertowHttpBinding();
-
-        final CookieHandler cookieHandler = endpoint.getCookieHandler();
-        final Map<String, List<String>> cookieHeaders;
-        if (cookieHandler != null) {
+        if (endpoint.isWebSocket()) {
+            return processWebSocket(camelExchange, callback);
+        } else {
+            /* not a WebSocket */
+            final URI uri;
+            final HttpString method;
             try {
-                cookieHeaders = cookieHandler.loadCookies(camelExchange, uri);
-            } catch (final IOException e) {
+                final String exchangeUri = UndertowHelper.createURL(camelExchange, getEndpoint());
+                uri = UndertowHelper.createURI(camelExchange, exchangeUri, getEndpoint());
+                method = UndertowHelper.createMethod(camelExchange, endpoint, camelExchange.getIn().getBody() != null);
+            } catch (final URISyntaxException e) {
                 camelExchange.setException(e);
                 callback.done(true);
                 return true;
             }
-        } else {
-            cookieHeaders = Collections.emptyMap();
-        }
 
-        final ClientRequest request = new ClientRequest();
-        request.setMethod(method);
-        request.setPath(pathAndQuery);
+            final String pathAndQuery = URISupport.pathAndQueryOf(uri);
+
+            final UndertowHttpBinding undertowHttpBinding = endpoint.getUndertowHttpBinding();
+
+            final CookieHandler cookieHandler = endpoint.getCookieHandler();
+            final Map<String, List<String>> cookieHeaders;
+            if (cookieHandler != null) {
+                try {
+                    cookieHeaders = cookieHandler.loadCookies(camelExchange, uri);
+                } catch (final IOException e) {
+                    camelExchange.setException(e);
+                    callback.done(true);
+                    return true;
+                }
+            } else {
+                cookieHeaders = Collections.emptyMap();
+            }
 
-        final HeaderMap requestHeaders = request.getRequestHeaders();
+            final ClientRequest request = new ClientRequest();
+            request.setMethod(method);
+            request.setPath(pathAndQuery);
 
-        // Set the Host header
-        final Message message = camelExchange.getIn();
-        final String host = message.getHeader(Headers.HOST_STRING, String.class);
-        requestHeaders.put(Headers.HOST, Optional.ofNullable(host).orElseGet(() -> uri.getAuthority()));
+            final HeaderMap requestHeaders = request.getRequestHeaders();
 
-        final Object body = undertowHttpBinding.toHttpRequest(request, camelExchange.getIn());
+            // Set the Host header
+            final Message message = camelExchange.getIn();
+            final String host = message.getHeader(Headers.HOST_STRING, String.class);
+            requestHeaders.put(Headers.HOST, Optional.ofNullable(host).orElseGet(() -> uri.getAuthority()));
 
-        final TypeConverter tc = endpoint.getCamelContext().getTypeConverter();
-        final ByteBuffer bodyAsByte = tc.tryConvertTo(ByteBuffer.class, body);
+            final Object body = undertowHttpBinding.toHttpRequest(request, camelExchange.getIn());
 
-        // As tryConvertTo is used to convert the body, we should do null check
-        // or the call bodyAsByte.remaining() may throw an NPE
-        if (body != null && bodyAsByte != null) {
-            requestHeaders.put(Headers.CONTENT_LENGTH, bodyAsByte.remaining());
-        }
+            final TypeConverter tc = endpoint.getCamelContext().getTypeConverter();
+            final ByteBuffer bodyAsByte = tc.tryConvertTo(ByteBuffer.class, body);
 
-        for (final Map.Entry<String, List<String>> entry : cookieHeaders.entrySet()) {
-            requestHeaders.putAll(HttpString.tryFromString(entry.getKey()), entry.getValue());
-        }
+            // As tryConvertTo is used to convert the body, we should do null check
+            // or the call bodyAsByte.remaining() may throw an NPE
+            if (body != null && bodyAsByte != null) {
+                requestHeaders.put(Headers.CONTENT_LENGTH, bodyAsByte.remaining());
+            }
 
-        if (LOG.isDebugEnabled()) {
-            LOG.debug(""Executing http {} method: {}"", method, pathAndQuery);
+            for (final Map.Entry<String, List<String>> entry : cookieHeaders.entrySet()) {
+                requestHeaders.putAll(HttpString.tryFromString(entry.getKey()), entry.getValue());
+            }
+
+            if (LOG.isDebugEnabled()) {
+                LOG.debug(""Executing http {} method: {}"", method, pathAndQuery);
+            }
+
+            final UndertowClientCallback clientCallback = new UndertowClientCallback(camelExchange, callback, getEndpoint(),
+                request, bodyAsByte);
+
+            // when connect succeeds or fails UndertowClientCallback will
+            // get notified on a I/O thread run by Xnio worker. The writing
+            // of request and reading of response is performed also in the
+            // callback
+            client.connect(clientCallback, uri, worker, ssl, pool, options);
+
+            // the call above will proceed on Xnio I/O thread we will
+            // notify the exchange asynchronously when the HTTP exchange
+            // ends with success or failure from UndertowClientCallback
+            return false;
         }
 
-        final UndertowClientCallback clientCallback = new UndertowClientCallback(camelExchange, callback, getEndpoint(),
-            request, bodyAsByte);
+    }
 
-        // when connect succeeds or fails UndertowClientCallback will
-        // get notified on a I/O thread run by Xnio worker. The writing
-        // of request and reading of response is performed also in the
-        // callback
-        client.connect(clientCallback, uri, worker, ssl, pool, options);
+    private boolean processWebSocket(final Exchange camelExchange, final AsyncCallback camelCallback) {
+        final Message in = camelExchange.getIn();
+        try {
+            Object message = in.getBody();
+            if (!(message instanceof String || message instanceof byte[] || message instanceof Reader
+                    || message instanceof InputStream)) {
+                message = in.getBody(String.class);
+            }
 
-        // the call above will proceed on Xnio I/O thread we will
-        // notify the exchange asynchronously when the HTTP exchange
-        // ends with success or failure from UndertowClientCallback
-        return false;
+            if (message != null) {
+                final int timeout = endpoint.getSendTimeout();
+                if (isSendToAll(in)) {
+                    return webSocketHandler.send(peer -> true, message, timeout, camelExchange, camelCallback);
+                }
+                final List<String> connectionKeys = in.getHeader(UndertowConstants.CONNECTION_KEY_LIST, List.class);
+                if (connectionKeys != null) {
+                    return webSocketHandler.send(
+                        peer -> connectionKeys.contains(peer.getAttribute(UndertowConstants.CONNECTION_KEY)), message,
+                        timeout, camelExchange, camelCallback);
+                }
+                final String connectionKey = in.getHeader(UndertowConstants.CONNECTION_KEY, String.class);
+                if (connectionKey != null) {
+                    return webSocketHandler.send(
+                        peer -> connectionKey.equals(peer.getAttribute(UndertowConstants.CONNECTION_KEY)), message,
+                        timeout, camelExchange, camelCallback);
+                }
+                throw new IllegalStateException(
+                        String.format(""Cannot process message which has none of the headers %s, %s or %s set: %s"",
+                                UndertowConstants.SEND_TO_ALL, UndertowConstants.CONNECTION_KEY_LIST,
+                                UndertowConstants.CONNECTION_KEY, in));
+            } else {
+                /* nothing to do for a null body */
+                camelCallback.done(true);
+                return true;
+            }
+        } catch (IOException e) {","[{'comment': 'Catch all kinds of exceptions, eg Exception or Throwable', 'commenter': 'davsclaus'}, {'comment': 'Fixed in a85b3e3', 'commenter': 'ppalaga'}]"
2144,components/camel-undertow/src/main/java/org/apache/camel/component/undertow/handlers/CamelMethodHandler.java,"@@ -16,76 +16,127 @@
  */
 package org.apache.camel.component.undertow.handlers;
 
-import java.util.HashMap;
 import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
 
 import io.undertow.server.HttpHandler;
 import io.undertow.server.HttpServerExchange;
 import io.undertow.util.MimeMappings;
 import io.undertow.util.StatusCodes;
+
 import org.apache.camel.component.undertow.ExchangeHeaders;
 
 /**
  * A HttpHandler build a mapping between HTTP methods and handlers and dispatch requests along the map.
  */
 public class CamelMethodHandler implements HttpHandler {
-    private Map<String, HttpHandler> methodMap = new HashMap<String, HttpHandler>();
-    private HttpHandler defaultHandler;
+    /**
+     * A key to use for handlers with no method specified
+     */
+    private static final String DEFAULT_HANDLER_KEY = """";
+    private static final String[] DEFAULT_METHODS;
+    static {
+        DEFAULT_METHODS = new String[] {DEFAULT_HANDLER_KEY};
+    }
+
+    private final Map<String, MethodEntry> methodMap = new ConcurrentHashMap<>();
     private String handlerString;
 
+    CamelMethodHandler() {
+    }
+
     @Override
     public void handleRequest(HttpServerExchange exchange) throws Exception {
-        HttpHandler handler = methodMap.get(exchange.getRequestMethod().toString());
-        if (handler != null) {
+        HttpHandler handler = null;
+        /* No need to lock methodMap for read access in this method */
+        MethodEntry entry = methodMap.get(exchange.getRequestMethod().toString());
+        if (entry != null && (handler = entry.handler) != null) {
             handler.handleRequest(exchange);
-        } else if (defaultHandler != null) {
-            defaultHandler.handleRequest(exchange);
         } else {
-            exchange.setStatusCode(StatusCodes.METHOD_NOT_ALLOWED);
-            exchange.getResponseHeaders().put(ExchangeHeaders.CONTENT_TYPE, MimeMappings.DEFAULT_MIME_MAPPINGS.get(""txt""));
-            exchange.getResponseHeaders().put(ExchangeHeaders.CONTENT_LENGTH, 0);
-            exchange.endExchange();
+            entry = methodMap.get(DEFAULT_HANDLER_KEY);
+            if (entry != null && (handler = entry.handler) != null) {
+                handler.handleRequest(exchange);
+            } else {
+                exchange.setStatusCode(StatusCodes.METHOD_NOT_ALLOWED);
+                exchange.getResponseHeaders().put(ExchangeHeaders.CONTENT_TYPE, MimeMappings.DEFAULT_MIME_MAPPINGS.get(""txt""));
+                exchange.getResponseHeaders().put(ExchangeHeaders.CONTENT_LENGTH, 0);
+                exchange.endExchange();
+            }
         }
     }
 
-    public synchronized void add(String[] methods, HttpHandler handler) {
-        Map<String, HttpHandler> adding = new HashMap<String, HttpHandler>();
-        for (String method : methods) {
-            adding.put(method, handler);
+    public HttpHandler add(String methods, HttpHandler handler) {
+        HttpHandler result = null;
+        synchronized (methodMap) { // we lock on methodMap to get a reliable sum of refCounts in remove(String)
+            for (String method : splitMethods(methods)) {
+                MethodEntry en = methodMap.computeIfAbsent(method, m -> new MethodEntry());
+                result = en.addRef(handler, method);
+            }
         }
-        methodMap.putAll(adding);
         handlerString = null;
+        return result;
     }
 
-    public synchronized void remove(String[] methods) {
-        for (String method : methods) {
-            methodMap.remove(method);
+
+    public boolean remove(String methods) {
+        boolean result;
+        synchronized (methodMap) { // we lock on methodMap to get a reliable sum of refCounts
+            for (String method : splitMethods(methods)) {
+                final MethodEntry en = methodMap.get(method);
+                if (en != null) {
+                    en.removeRef();
+                }
+            }
+            result = methodMap.values().stream().mapToInt(en -> en.refCount).sum() == 0;
         }
         handlerString = null;
+        return result;
     }
 
-    public synchronized void addDefault(HttpHandler handler) {
-        if (defaultHandler != null) {
-            throw new IllegalArgumentException(String.format(
-                ""Duplicate default handler: '%s', '%s'"", defaultHandler, handler));
+    public String toString() {
+        if (handlerString == null) {
+            handlerString = ""CamelMethodHandler["" + methodMap + ""]"";
         }
-        defaultHandler = handler;
-        handlerString = null;
+        return handlerString;
     }
 
-    public synchronized void removeDefault() {
-        defaultHandler = null;
-        handlerString = null;
+    private String[] splitMethods(String methods) {
+        String[] result = methods != null ? methods.split("","") : DEFAULT_METHODS;
+        return result.length == 0 ? DEFAULT_METHODS : result;
     }
 
-    public boolean isEmpty() {
-        return defaultHandler == null && methodMap.isEmpty();
-    }
+    static class MethodEntry {
+        /**
+         * The number of references pointing to {@link #handler}
+         */
+        private int refCount;","[{'comment': 'Add a bit of empty lines so this code is formatted nice between fields, constructor, and methods', 'commenter': 'davsclaus'}, {'comment': 'Fixed in a85b3e3', 'commenter': 'ppalaga'}]"
2144,components/camel-undertow/src/main/java/org/apache/camel/component/undertow/handlers/ExtendedWebSocketCallback.java,"@@ -0,0 +1,35 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.undertow.handlers;
+
+import io.undertow.websockets.core.WebSocketCallback;
+import io.undertow.websockets.core.WebSocketChannel;
+
+/**
+ * An extension of {@link WebSocketCallback} that adds a notification for the situation when a {@link WebSocketChannel}
+ * is closed before any message could be sent to it.
+ *
+ * @author <a href=""https://github.com/ppalaga"">Peter Palaga</a>","[{'comment': 'Remove author tags, check other files where you may have that too', 'commenter': 'davsclaus'}, {'comment': '> Remove author tags\r\n\r\nWhy if I may ask?', 'commenter': 'ppalaga'}, {'comment': 'That is ASF policy', 'commenter': 'davsclaus'}, {'comment': 'Fixed in a85b3e3', 'commenter': 'ppalaga'}]"
2144,components/camel-undertow/src/test/java/org/apache/camel/component/undertow/ws/UndertowWssRouteTest.java,"@@ -0,0 +1,176 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.undertow.ws;
+
+import java.io.IOException;
+import java.net.URL;
+import java.security.GeneralSecurityException;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+
+import io.netty.handler.ssl.SslContext;
+import io.netty.handler.ssl.SslContextBuilder;
+import io.netty.handler.ssl.SslProvider;
+import io.netty.handler.ssl.util.InsecureTrustManagerFactory;
+
+import org.apache.camel.CamelContext;
+import org.apache.camel.SSLContextParametersAware;
+import org.apache.camel.builder.RouteBuilder;
+import org.apache.camel.component.undertow.BaseUndertowTest;
+import org.apache.camel.component.undertow.UndertowHttpsSpringTest;
+import org.apache.camel.util.jsse.KeyManagersParameters;
+import org.apache.camel.util.jsse.KeyStoreParameters;
+import org.apache.camel.util.jsse.SSLContextParameters;
+import org.apache.camel.util.jsse.SSLContextServerParameters;
+import org.apache.camel.util.jsse.TrustManagersParameters;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.DefaultAsyncHttpClient;
+import org.asynchttpclient.DefaultAsyncHttpClientConfig;
+import org.asynchttpclient.ws.WebSocket;
+import org.asynchttpclient.ws.WebSocketTextListener;
+import org.asynchttpclient.ws.WebSocketUpgradeHandler;
+import org.junit.AfterClass;
+import org.junit.BeforeClass;
+import org.junit.Test;
+
+public class UndertowWssRouteTest extends BaseUndertowTest {
+
+    @BeforeClass
+    public static void setUpJaas() throws Exception {
+        URL trustStoreUrl = UndertowHttpsSpringTest.class.getClassLoader().getResource(""ssl/keystore.jks"");
+        System.setProperty(""javax.net.ssl.trustStore"", trustStoreUrl.toURI().getPath());
+    }
+
+    @AfterClass
+    public static void tearDownJaas() throws Exception {
+        System.clearProperty(""java.security.auth.login.config"");
+    }
+
+    @Override
+    protected CamelContext createCamelContext() throws Exception {
+        CamelContext context = super.createCamelContext();
+        KeyStoreParameters ksp = new KeyStoreParameters();
+        ksp.setResource(""ssl/keystore.jks"");
+        ksp.setPassword(""password"");
+
+        KeyManagersParameters kmp = new KeyManagersParameters();
+        kmp.setKeyPassword(""password"");
+        kmp.setKeyStore(ksp);
+
+        TrustManagersParameters tmp = new TrustManagersParameters();
+        tmp.setKeyStore(ksp);
+
+        // NOTE: Needed since the client uses a loose trust configuration when no ssl context
+        // is provided.  We turn on WANT client-auth to prefer using authentication
+        SSLContextServerParameters scsp = new SSLContextServerParameters();
+
+        SSLContextParameters sslContextParameters = new SSLContextParameters();
+        sslContextParameters.setKeyManagers(kmp);
+        sslContextParameters.setTrustManagers(tmp);
+        sslContextParameters.setServerParameters(scsp);
+        context.setSSLContextParameters(sslContextParameters);
+
+        ((SSLContextParametersAware) context.getComponent(""undertow"")).setUseGlobalSslContextParameters(true);
+        return context;
+    }
+
+    protected AsyncHttpClient createAsyncHttpSSLClient() throws IOException, GeneralSecurityException {
+
+        AsyncHttpClient c;
+        AsyncHttpClientConfig config;
+
+        DefaultAsyncHttpClientConfig.Builder builder =
+                new DefaultAsyncHttpClientConfig.Builder();
+
+        SslContext sslContext = SslContextBuilder
+                .forClient()
+                .sslProvider(SslProvider.JDK)
+                .trustManager(InsecureTrustManagerFactory.INSTANCE)
+                .build();
+        builder.setSslContext(sslContext);
+        builder.setAcceptAnyCertificate(true);
+        config = builder.build();
+        c = new DefaultAsyncHttpClient(config);
+
+        return c;
+    }
+
+    @Test
+    public void testWSHttpCall() throws Exception {
+        final List<String> received = new ArrayList<String>();
+        final CountDownLatch latch = new CountDownLatch(10);
+
+        AsyncHttpClient c = createAsyncHttpSSLClient();
+        WebSocket websocket = c.prepareGet(""wss://localhost:"" + getPort() + ""/test"").execute(
+                new WebSocketUpgradeHandler.Builder()
+                        .addWebSocketListener(new WebSocketTextListener() {
+                            @Override
+                            public void onMessage(String message) {
+                                received.add(message);
+                                log.info(""received --> "" + message);
+                                latch.countDown();
+                            }","[{'comment': 'Remove all the extra empty lines below', 'commenter': 'davsclaus'}, {'comment': 'Fixed in a85b3e3', 'commenter': 'ppalaga'}]"
2149,components/camel-bindy/src/test/java/org/apache/camel/dataformat/bindy/csv/BindyMarshalEndWithLineBreakTest.java,"@@ -0,0 +1,87 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.dataformat.bindy.csv;
+
+import org.apache.camel.builder.RouteBuilder;
+import org.apache.camel.component.mock.MockEndpoint;
+import org.apache.camel.dataformat.bindy.annotation.CsvRecord;
+import org.apache.camel.dataformat.bindy.model.csv.MyCsvRecord;
+import org.apache.camel.dataformat.bindy.model.csv.MyCsvRecord2;
+import org.apache.camel.dataformat.bindy.util.ConverterUtils;
+import org.apache.camel.model.dataformat.BindyType;
+import org.apache.camel.test.junit4.CamelTestSupport;
+import org.junit.Test;
+
+/**
+ *
+ */
+public class BindyMarshalEndWithLineBreakTest extends CamelTestSupport {
+
+    @Test
+    public void testCsvWithEndingLineBreak() throws Exception {
+        final CsvRecord record = MyCsvRecord.class.getAnnotation(CsvRecord.class);
+        final MyCsvRecord csvRecord = new MyCsvRecord();
+        csvRecord.setAddressLine1(""221b Baker Street"");
+        csvRecord.setCity(""London"");
+        csvRecord.setCountry(""England"");
+        csvRecord.setAttention(""1"");
+        
+        MockEndpoint mock = getMockEndpoint(""mock:result"");
+        mock.expectedMessageCount(1);
+        mock.message(0).body().convertToString().endsWith(ConverterUtils.getStringCarriageReturn(record.crlf()));
+        
+        template.sendBody(""direct:withlb"", csvRecord);
+
+        assertMockEndpointsSatisfied();
+    }
+    
+    @Test
+    public void testCsvWithoutEndingLineBreak() throws Exception {
+        final CsvRecord record = MyCsvRecord2.class.getAnnotation(CsvRecord.class);
+        final MyCsvRecord2 csvRecord2 = new MyCsvRecord2();
+        csvRecord2.setAddressLine1(""221b Baker Street"");
+        csvRecord2.setCity(""London"");
+        csvRecord2.setCountry(""England"");
+        csvRecord2.setAttention(""1"");
+        
+        MockEndpoint mock = getMockEndpoint(""mock:result"");
+        mock.expectedMessageCount(1);
+        mock.message(0).body().convertToString().endsWith(record.separator());
+        
+        template.sendBody(""direct:withoutlb"", csvRecord2);
+
+        assertMockEndpointsSatisfied();        
+    }
+
+    @Override
+    protected RouteBuilder createRouteBuilder() throws Exception {
+        return new RouteBuilder() {
+            @Override
+            public void configure() throws Exception {
+                from(""direct:withoutlb"") //","[{'comment': 'Can you remove those trailing empty comments with //', 'commenter': 'davsclaus'}]"
2165,camel-core/src/main/java/org/apache/camel/impl/ThrottlingExceptionRoutePolicy.java,"@@ -291,6 +328,15 @@ public void setHalfOpenHandler(ThrottlingExceptionHalfOpenHandler halfOpenHandle
         this.halfOpenHandler = halfOpenHandler;
     }
 
+    public boolean getKeepOpen() {
+        return this.keepOpen.get();
+    }
+
+    public void setKeepOpen(boolean keepOpen) {
+        log.debug(""keep open:"" + keepOpen);","[{'comment': 'Can you use `{}` placeholders in logger', 'commenter': 'davsclaus'}]"
2165,camel-core/src/test/java/org/apache/camel/processor/ThrottlingExceptionRoutePolicyKeepOpenOnInitTest.java,"@@ -0,0 +1,98 @@
+package org.apache.camel.processor;","[{'comment': 'Add missing license header', 'commenter': 'davsclaus'}]"
2165,camel-core/src/test/java/org/apache/camel/processor/ThrottlingExceptionRoutePolicyKeepOpenOnInitTest.java,"@@ -0,0 +1,98 @@
+package org.apache.camel.processor;
+
+import org.apache.camel.ContextTestSupport;
+import org.apache.camel.builder.RouteBuilder;
+import org.apache.camel.component.mock.MockEndpoint;
+import org.apache.camel.impl.ThrottlingExceptionRoutePolicy;
+import org.junit.Before;
+import org.junit.Test;
+
+public class ThrottlingExceptionRoutePolicyKeepOpenOnInitTest extends ContextTestSupport {
+
+    private String url = ""seda:foo?concurrentConsumers=20"";
+    private MockEndpoint result;
+    private int size = 5;
+
+    private ThrottlingExceptionRoutePolicy policy;
+
+    @Override
+    @Before
+    public void setUp() throws Exception {
+        this.createPolicy();
+
+        super.setUp();
+        this.setUseRouteBuilder(true);
+        result = getMockEndpoint(""mock:result"");
+        context.getShutdownStrategy().setTimeout(1);
+    }
+
+    protected void createPolicy() {
+        int threshold = 2;
+        long failureWindow = 30;
+        long halfOpenAfter = 1000;
+        boolean keepOpen = true;
+        policy = new ThrottlingExceptionRoutePolicy(threshold, failureWindow, halfOpenAfter, null, keepOpen);
+    }
+
+    @Test
+    public void testThrottlingRoutePolicyStartWithAlwaysOpenOn() throws Exception {
+
+        log.debug(""---- sending some messages"");
+        for (int i = 0; i < size; i++) {
+            template.sendBody(url, ""Message "" + i);
+            Thread.sleep(3);
+        }
+
+        // gives time for policy half open check to run every second
+        // and should not close b/c keepOpen is true
+        Thread.sleep(2000);","[{'comment': 'Is there a way to not sleep for 2 seconds, eg this test takes 5+ seconds to run, and it would be nice with fast unit tests of camel-core. ', 'commenter': 'davsclaus'}]"
2165,camel-core/src/main/java/org/apache/camel/impl/ThrottlingExceptionRoutePolicy.java,"@@ -73,17 +74,27 @@
     // stateful information
     private final AtomicInteger failures = new AtomicInteger();
     private final AtomicInteger state = new AtomicInteger(STATE_CLOSED);
+    private AtomicBoolean keepOpen = new AtomicBoolean(false);","[{'comment': 'can this be final like the others', 'commenter': 'davsclaus'}, {'comment': 'good catch', 'commenter': 'CodeSmell'}]"
2165,camel-core/src/main/java/org/apache/camel/impl/ThrottlingExceptionRoutePolicy.java,"@@ -73,17 +74,27 @@
     // stateful information
     private final AtomicInteger failures = new AtomicInteger();
     private final AtomicInteger state = new AtomicInteger(STATE_CLOSED);
+    private AtomicBoolean keepOpen = new AtomicBoolean(false);
     private volatile Timer halfOpenTimer;
     private volatile long lastFailure;
     private volatile long openedAt;
-    
+
     public ThrottlingExceptionRoutePolicy(int threshold, long failureWindow, long halfOpenAfter, List<Class<?>> handledExceptions) {
         this.throttledExceptions = handledExceptions;
         this.failureWindow = failureWindow;
         this.halfOpenAfter = halfOpenAfter;
         this.failureThreshold = threshold;
+        this.keepOpen.set(false);","[{'comment': 'I would replace those statements above with `this(handledExceptions,failureWindow,halfOpenAfter,threshold,false)`.', 'commenter': 'aldettinger'}]"
2166,parent/pom.xml,"@@ -166,7 +166,7 @@
     <commons-text-version>1.2</commons-text-version>
     <commons-vfs2-version>2.0</commons-vfs2-version>
     <compress-lzf-version>1.0.4</compress-lzf-version>
-    <consul-client-version>0.16.3</consul-client-version>
+    <consul-client-version>1.0.0</consul-client-version>
     <consul-client-bundle-version>0.16.2_1</consul-client-bundle-version>","[{'comment': 'You need to change the bundle version too and check if the Karaf feature still work. Thanks.', 'commenter': 'oscerd'}]"
2166,components/camel-consul/src/main/java/org/apache/camel/component/consul/endpoint/ConsulEventConsumer.java,"@@ -98,8 +99,8 @@ private void onEvent(Event event) {
             if (event.getTagFilter().isPresent()) {
                 message.setHeader(ConsulConstants.CONSUL_TAG_FILTER, event.getTagFilter().get());
             }
-
-            message.setBody(event.getPayload().orNull());
+            
+            message.setBody(Optional.ofNullable(event.getPayload()));
 ","[{'comment': ""Doesn't looks similar, if I'm not mistaking this\r\n\r\n    event.getPayload().orNull()\r\n\r\nreturns the event payload or null, whereas\r\n\r\n    message.setBody(Optional.ofNullable(event.getPayload()));\r\n\r\ncreates an eventually empty Optional\r\n"", 'commenter': 'lburgazzoli'}]"
2175,components/camel-braintree/src/main/docs/braintree-component.adoc,"@@ -74,14 +74,15 @@ with the following path and query parameters:
 [width=""100%"",cols=""2,5,^1,2"",options=""header""]
 |===
 | Name | Description | Default | Type
-| *environment* (common) | *Required* The environment Either SANDBOX or PRODUCTION |  | String
+| *environment* (common) | The environment Either SANDBOX or PRODUCTION |  | String","[{'comment': 'The documentation is generated automatically. From your code I see that environment is still required, so probably you modified this by hand.\r\n\r\nhttps://github.com/nofuss/camel/blob/4523c406859d25aa3a47109cc5d350ec14c88a5b/components/camel-braintree/src/main/java/org/apache/camel/component/braintree/BraintreeConfiguration.java#L50', 'commenter': 'oscerd'}, {'comment': 'I I think I made some mistakes when preparing the pull request - reviewing now', 'commenter': 'nofuss'}, {'comment': 'I had left out a couple commits when preparing the pull request, so now the code and generated documentation should align', 'commenter': 'nofuss'}]"
2175,components/camel-braintree/src/main/java/org/apache/camel/component/braintree/BraintreeConfiguration.java,"@@ -104,7 +108,7 @@ public void setMethodName(String methodName) {
     }
 
     public String getEnvironment() {
-        return ObjectHelper.notNull(environment, ENVIRONMENT);
+        return environment;","[{'comment': 'for my understanding, why `ObjectHelper.notNull` has been removed ?', 'commenter': 'lburgazzoli'}, {'comment': 'The reason for this is because when using an Access Token, the environment option is no longer required.  The same thing was done for the merchantId, publicKey and privateKey options.\r\n\r\nI would have liked to have something like ""if configured using public and private keys, require environment, merchantId, publicKey and privateKey, and if configured using an access token, require only the access token"" but I couldn\'t figure out a way to do that.', 'commenter': 'nofuss'}, {'comment': 'Ok understood. It looks good for me but you may need to amend also the [ServiceNowComponentVerifierExtension](https://github.com/apache/camel/blob/master/components/camel-servicenow/camel-servicenow-component/src/main/java/org/apache/camel/component/servicenow/ServiceNowComponentVerifierExtension.java#L39-L47) and add conditional validation  according to what is given as properties', 'commenter': 'lburgazzoli'}, {'comment': 'The ServiceNow component is new to me, and I am not sure where I would even start. Is there any other component with conditional validation I might use as a model?', 'commenter': 'nofuss'}, {'comment': '[This](https://github.com/apache/camel/blob/master/components/camel-salesforce/camel-salesforce-component/src/main/java/org/apache/camel/component/salesforce/SalesforceComponentVerifierExtension.java#L43-L67) may help you , if you need any assistence ping me on irc', 'commenter': 'lburgazzoli'}, {'comment': ""I attempted setting up a VerifierExtension - I think it's ok, but feedback would be welcome.\r\n\r\nAlso, if the pull request needs to be squashed to one commit, let me know."", 'commenter': 'nofuss'}, {'comment': '@nofuss can you please squash in one commit and add a reference to the JIRA number in the commit message? Thanks.', 'commenter': 'oscerd'}, {'comment': 'done', 'commenter': 'nofuss'}]"
2180,components/camel-xchange/src/main/docs/weather-component.adoc,"@@ -0,0 +1,176 @@
+== Weather Component","[{'comment': 'Looks like the docs are from the weather component', 'commenter': 'oscerd'}, {'comment': ""I updated the docs with an initial draft. Some of the sections seem to be generated & I would need a little help on how to do this. Also, I'd like to use the name part of the URI, which for some reason in null in the configuration. Perhaps you could have a look at what I might have done wrong here."", 'commenter': 'tdiesler'}, {'comment': 'Is there a way to mark the component as preview? The API is still expected to change a lot while I move along.', 'commenter': 'tdiesler'}, {'comment': 'Actually you need to add a comment manually for the preview status. At first glance to generate the docs automatically with component and endpoint options, you need to name the .adoc with the component name, so xchange-component.adoc.', 'commenter': 'oscerd'}]"
2190,components/camel-wordpress/src/main/docs/wordpress-component.adoc,"@@ -0,0 +1,79 @@
+== Wordpress Component
+
+*Available as of Camel version 2.20.1*
+
+Camel component for https://developer.wordpress.org/rest-api/reference/[Wordpress API].
+
+=== Usage
+
+Currently only the **Posts** and **Users** operations are supported.
+
+==== Configure your route
+
+The `WordpressConfiguration` class can be used to set initial properties configuration to the component instead of passing it as query parameter. The following listing shows how to set the component to be used in your routes.
+
+[source,java]
+--------------------------------------------------
+public void configure() {
+    final WordpressConfiguration configuration = new WordpressConfiguration();
+    final WordpressComponent component = new WordpressComponent();
+    configuration.setApiVersion(""2"");
+    configuration.setUrl(""http://yoursite.com/wp-json/"");
+    component.setConfiguration(configuration);
+    getContext().addComponent(""wordpress"", component);
+    
+    from(""wordpress:post?id=1"")
+      .to(""mock:result"");
+}
+--------------------------------------------------
+==== Path Parameters","[{'comment': 'Like the other components you need to add the placeholders for component options and endpoint options\r\n\r\n// component options: START\r\n// component options: END\r\n\r\n// endpoint options: START\r\n//endpoint options: END\r\n\r\nThe docs will be generated automatically', 'commenter': 'oscerd'}]"
2190,components/camel-wordpress/src/main/java/org/apache/camel/component/wordpress/config/WordpressEndpointConfiguration.java,"@@ -0,0 +1,98 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.wordpress.config;
+
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Map;
+import org.apache.camel.spi.UriParam;
+import org.apache.camel.spi.UriParams;
+import org.apache.camel.util.IntrospectionSupport;
+import org.wordpress4j.model.SearchCriteria;
+
+@UriParams
+public class WordpressEndpointConfiguration extends WordpressComponentConfiguration {","[{'comment': 'Is there a particular reason to have two different configuration? ', 'commenter': 'oscerd'}]"
2206,components/camel-fhir/src/main/java/org/apache/camel/component/fhir/FhirEndpoint.java,"@@ -0,0 +1,46 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.fhir;
+
+import org.apache.camel.Consumer;
+import org.apache.camel.Processor;
+import org.apache.camel.Producer;
+import org.apache.camel.impl.DefaultEndpoint;
+import org.apache.camel.spi.UriEndpoint;
+
+/**
+ * Represents a fhir endpoint.
+ */
+@UriEndpoint(scheme = ""fhir"", title = ""FHIR"", syntax = ""fhir://"", label = ""fhir"", producerOnly = true)","[{'comment': 'This syntax is wrong, you need to use `fhir:xxx` where xxx is required `@UriPath` options ', 'commenter': 'davsclaus'}, {'comment': ""The FHIR endpoint doesn't have any path or options. It will only execute the provided [IClientExecutable](https://github.com/jamesagnew/hapi-fhir/blob/0352d487204bf2f5eb0f87e204e77e225d47420b/hapi-fhir-base/src/main/java/ca/uhn/fhir/rest/gclient/IClientExecutable.java#L64) contained in the message body and do some error handling.\r\n\r\n@davsclaus The reasoning is that HAPI-FHIR comes with a nice [RestfulClient](https://github.com/jamesagnew/hapi-fhir/blob/0352d487204bf2f5eb0f87e204e77e225d47420b/hapi-fhir-base/src/main/java/ca/uhn/fhir/rest/client/api/IRestfulClient.java#L31) that is instantiated with the server URL and is able to construct every request depending on what FHIR version the server is running. I don't see anything else to add for the moment.\r\n\r\nIf this feels weird I can remove the Endpoint and have the user execute the request in a processing step.\r\n\r\nLet me know what you think"", 'commenter': 'johnpoth'}]"
2206,components/camel-fhir/src/main/java/org/apache/camel/component/fhir/FhirEndpoint.java,"@@ -0,0 +1,46 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.fhir;
+
+import org.apache.camel.Consumer;
+import org.apache.camel.Processor;
+import org.apache.camel.Producer;
+import org.apache.camel.impl.DefaultEndpoint;
+import org.apache.camel.spi.UriEndpoint;
+
+/**
+ * Represents a fhir endpoint.","[{'comment': 'Update this javadoc to give a short summary what this does as we grab this for the component overview documentation', 'commenter': 'davsclaus'}]"
2206,components/camel-fhir/src/main/java/org/apache/camel/component/fhir/FhirProducer.java,"@@ -0,0 +1,51 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.fhir;
+
+import java.util.List;
+import ca.uhn.fhir.model.base.resource.BaseOperationOutcome;
+import ca.uhn.fhir.rest.gclient.IClientExecutable;
+import org.apache.camel.Exchange;
+import org.apache.camel.impl.DefaultProducer;
+
+/**
+ * The fhir producer. It simply retrieves a {@link IClientExecutable}, executes it and sets the result in the Camel exchange body.
+ */
+public class FhirProducer extends DefaultProducer {
+    
+    public FhirProducer(FhirEndpoint endpoint) {
+        super(endpoint);
+    }
+
+    public void process(Exchange exchange) throws Exception {
+        IClientExecutable clientExecutable = (IClientExecutable) exchange.getIn().getHeaders().get(FhirConstants.FHIR_REQUEST);
+        if (clientExecutable == null) {
+            throw new UnsupportedOperationException(""client executable must be set"");
+        }
+        Object result = clientExecutable.execute();
+        if (result instanceof BaseOperationOutcome) {
+            List<? extends BaseOperationOutcome.BaseIssue> issues = ((BaseOperationOutcome) result).getIssue();
+            if (!issues.isEmpty()) {
+                exchange.getOut().setFault(true);","[{'comment': 'Please do not use fault messages, this is really only for SOAP/JBI stuff and it should become deprcated and removed in the future (eg 3.0)', 'commenter': 'davsclaus'}, {'comment': 'Will set the exception on the exchange instead', 'commenter': 'johnpoth'}]"
2206,components/camel-fhir/src/main/java/org/apache/camel/component/fhir/FhirProducer.java,"@@ -0,0 +1,51 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.fhir;
+
+import java.util.List;
+import ca.uhn.fhir.model.base.resource.BaseOperationOutcome;
+import ca.uhn.fhir.rest.gclient.IClientExecutable;
+import org.apache.camel.Exchange;
+import org.apache.camel.impl.DefaultProducer;
+
+/**
+ * The fhir producer. It simply retrieves a {@link IClientExecutable}, executes it and sets the result in the Camel exchange body.
+ */
+public class FhirProducer extends DefaultProducer {
+    
+    public FhirProducer(FhirEndpoint endpoint) {
+        super(endpoint);
+    }
+
+    public void process(Exchange exchange) throws Exception {
+        IClientExecutable clientExecutable = (IClientExecutable) exchange.getIn().getHeaders().get(FhirConstants.FHIR_REQUEST);","[{'comment': 'This seems a bit odd to use a header for such a thing. How will this header to be configured? Headers should be part of the message contract, and not ""misused"" for client stuff', 'commenter': 'davsclaus'}, {'comment': ""I'll move this in the message body"", 'commenter': 'johnpoth'}]"
2206,components/camel-fhir/src/main/java/org/apache/camel/component/fhir/FhirTypeConverter.java,"@@ -0,0 +1,55 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.fhir;
+
+import ca.uhn.fhir.context.FhirContext;
+import ca.uhn.fhir.rest.api.MethodOutcome;
+import org.apache.camel.Converter;
+import org.apache.camel.Exchange;
+import org.hl7.fhir.instance.model.api.IBaseResource;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+@Converter
+public final class FhirTypeConverter {
+
+    private static final Logger LOGGER = LoggerFactory.getLogger(FhirTypeConverter.class.getName());
+
+    private FhirTypeConverter() {
+        // Helper class
+    }
+
+    @Converter
+    public static String resourceToString(IBaseResource iBaseResource, Exchange exchange) {","[{'comment': 'Hmm maybe such a type converter is not so idea when you require those stuff to be on the exchange property. Sometimes a type converter is not the best thing to add, they should really ideally just be for basic type conversions. Consider removing this if possible.', 'commenter': 'davsclaus'}, {'comment': 'Ah ok I\'ll remove it. I liked to use it for logging e.g: .log(""Executing ${body}"") - but this can be done in an application bean or something', 'commenter': 'johnpoth'}]"
2206,components/camel-fhir/src/main/resources/META-INF/services/org/apache/camel/component/fhir,"@@ -0,0 +1 @@
+class=org.apache.camel.component.fhir.FhirComponent","[{'comment': 'Need license header', 'commenter': 'davsclaus'}, {'comment': 'Done', 'commenter': 'johnpoth'}]"
2206,components/camel-fhir/src/test/java/org/apache/camel/component/fhir/FhirXmlDataFormatURITest.java,"@@ -0,0 +1,94 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.fhir;
+
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import ca.uhn.fhir.context.FhirContext;
+import org.apache.camel.Exchange;
+import org.apache.camel.builder.RouteBuilder;
+import org.apache.camel.component.mock.MockEndpoint;
+import org.apache.camel.test.junit4.CamelTestSupport;
+import org.hl7.fhir.dstu3.model.Address;
+import org.hl7.fhir.dstu3.model.Base;
+import org.hl7.fhir.dstu3.model.HumanName;
+import org.hl7.fhir.dstu3.model.Patient;
+import org.hl7.fhir.instance.model.api.IBaseResource;
+import org.junit.Before;
+import org.junit.Test;
+
+public class FhirXmlDataFormatURITest extends CamelTestSupport {
+    
+    private static final String PATIENT =
+            ""<Patient xmlns=\""http://hl7.org/fhir\"">""
+                    + ""<name><family value=\""Holmes\""/><given value=\""Sherlock\""/></name>""
+                    + ""<address><line value=\""221b Baker St, Marylebone, London NW1 6XE, UK\""/></address>""
+              + ""</Patient>"";
+    private MockEndpoint mockEndpoint;
+
+    @Override
+    @Before
+    public void setUp() throws Exception {
+        super.setUp();
+        mockEndpoint = resolveMandatoryEndpoint(""mock:result"", MockEndpoint.class);
+    }
+    
+    @Test
+    public void unmarshal() throws Exception {
+        template.sendBody(""direct:unmarshal"", PATIENT);
+        mockEndpoint.expectedMessageCount(1);
+        Exchange exchange = mockEndpoint.getExchanges().get(0);
+        Patient patient = (Patient) exchange.getIn().getBody();
+        assertTrue(""Patients should be equal!"", patient.equalsDeep(getPatient()));
+    }
+
+    @Test
+    public void marshal() throws Exception {
+        Patient patient = getPatient();
+        mockEndpoint.expectedMessageCount(1);
+        template.sendBody(""direct:marshal"", patient);
+        mockEndpoint.expectedMessageCount(1);
+        Exchange exchange = mockEndpoint.getExchanges().get(0);
+        InputStream inputStream = exchange.getIn().getBody(InputStream.class);
+        final IBaseResource iBaseResource = FhirContext.forDstu3().newXmlParser().parseResource(new InputStreamReader(inputStream));
+        assertTrue(""Patients should be equal!"", patient.equalsDeep((Base) iBaseResource));
+    }
+
+    private Patient getPatient() {
+        Patient patient = new Patient();
+        patient.addName(new HumanName().addGiven(""Sherlock"").setFamily(""Holmes"")).addAddress(new Address().addLine(""221b Baker St, Marylebone, London NW1 6XE, UK""));
+        return patient;
+    }
+
+    protected RouteBuilder createRouteBuilder() {
+        return new RouteBuilder() {
+            public void configure() {
+                FhirContext fhirContext = FhirContext.forDstu3();
+
+                from(""direct:marshal"")
+                        .setProperty(FhirConstants.FHIR_CONTEXT, constant(fhirContext))","[{'comment': 'This smells, can this context not be set on the data format itself, its bad that end users have to setup this themselves. All the other data formats dont do this kind', 'commenter': 'davsclaus'}, {'comment': 'Both options are available. You can set the context on the data formats itself.\r\n\r\nI added this because the ```Context``` was needed for the ```FhirTypeConverter```. But since we are removing it I can remove this as well.', 'commenter': 'johnpoth'}]"
2206,camel-core/src/main/java/org/apache/camel/model/dataformat/FhirJsonDataFormat.java,"@@ -0,0 +1,57 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.model.dataformat;
+
+import javax.xml.bind.annotation.XmlAccessType;
+import javax.xml.bind.annotation.XmlAccessorType;
+import javax.xml.bind.annotation.XmlRootElement;
+import javax.xml.bind.annotation.XmlTransient;
+import org.apache.camel.CamelContext;
+import org.apache.camel.model.DataFormatDefinition;
+import org.apache.camel.spi.DataFormat;
+import org.apache.camel.spi.Metadata;
+
+/**
+ * The FHIR JSON data format is used to marshall/unmarshall to/from FHIR objects to/from JSON.
+ */
+@Metadata(firstVersion = ""2.21.0"", label = ""dataformat,transformation,json"", title = ""FHIR JSON"")
+@XmlRootElement(name = ""fhir-json"")","[{'comment': 'We dont use dash in those xml names, and btw it should be the same as you define in DataFormatsDefinition, so it should be `fhirJson` etc and ditto for the XML guy', 'commenter': 'davsclaus'}, {'comment': 'Is this not for HL7, if so add ""hl7"" to the label as well', 'commenter': 'davsclaus'}]"
2206,components/camel-fhir/pom.xml,"@@ -0,0 +1,133 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>org.apache.camel</groupId>
+    <artifactId>components</artifactId>
+    <version>2.21.0-SNAPSHOT</version>
+  </parent>
+  
+  <artifactId>camel-fhir</artifactId>
+  <packaging>jar</packaging>
+
+  <name>Camel :: Fhir</name>
+  <description>Camel Fhir Component</description>","[{'comment': 'The description should say data format as its not a regular component', 'commenter': 'davsclaus'}]"
2206,components/camel-fhir/pom.xml,"@@ -0,0 +1,133 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>org.apache.camel</groupId>
+    <artifactId>components</artifactId>
+    <version>2.21.0-SNAPSHOT</version>
+  </parent>
+  
+  <artifactId>camel-fhir</artifactId>
+  <packaging>jar</packaging>
+
+  <name>Camel :: Fhir</name>
+  <description>Camel Fhir Component</description>
+
+  <properties>
+    <camel.osgi.export.service>
+      org.apache.camel.spi.DataFormatResolver;dataformat=fhir-json,
+      org.apache.camel.spi.DataFormatResolver;dataformat=fhir-xml,","[{'comment': 'Remove trailing comma', 'commenter': 'davsclaus'}]"
2206,camel-core/src/main/java/org/apache/camel/model/dataformat/FhirJsonDataFormat.java,"@@ -0,0 +1,57 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.model.dataformat;
+
+import javax.xml.bind.annotation.XmlAccessType;
+import javax.xml.bind.annotation.XmlAccessorType;
+import javax.xml.bind.annotation.XmlRootElement;
+import javax.xml.bind.annotation.XmlTransient;
+import org.apache.camel.CamelContext;
+import org.apache.camel.model.DataFormatDefinition;
+import org.apache.camel.spi.DataFormat;
+import org.apache.camel.spi.Metadata;
+
+/**
+ * The FHIR JSON data format is used to marshall/unmarshall to/from FHIR objects to/from JSON.
+ */
+@Metadata(firstVersion = ""2.21.0"", label = ""dataformat,transformation,json"", title = ""FHIR JSON"")
+@XmlRootElement(name = ""fhir-json"")
+@XmlAccessorType(XmlAccessType.FIELD)
+public class FhirJsonDataFormat extends DataFormatDefinition {
+
+    @XmlTransient
+    private Object fhirContext;","[{'comment': 'Is this not required, if so add `@Metadata(required = true)`', 'commenter': 'davsclaus'}, {'comment': 'Also this needs a way to configure this in XML by having an `@XmlAttribute` where you can specify the id of this fhir context to lookup in the registry, see some of the other data formats.', 'commenter': 'davsclaus'}, {'comment': 'In other words it should not be transient', 'commenter': 'davsclaus'}]"
2206,components/camel-fhir/src/main/java/org/apache/camel/component/fhir/FhirJsonDataFormat.java,"@@ -0,0 +1,98 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.fhir;
+
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.OutputStream;
+import java.io.OutputStreamWriter;
+
+import ca.uhn.fhir.context.FhirContext;
+import org.apache.camel.Exchange;
+import org.apache.camel.spi.DataFormat;
+import org.apache.camel.spi.DataFormatName;
+import org.apache.camel.support.ServiceSupport;
+import org.hl7.fhir.instance.model.api.IBaseResource;
+
+public class FhirJsonDataFormat extends ServiceSupport implements DataFormat, DataFormatName {
+
+    private FhirContext fhirContext;
+    private boolean contentTypeHeader = true;","[{'comment': 'This option should also be on the model so end users can configure it there too', 'commenter': 'davsclaus'}, {'comment': ""Isn't it defined by default through [inheritance](https://github.com/apache/camel/blob/a030a22314eacafe416af749eb17b6a1046c4236/camel-core/src/main/java/org/apache/camel/model/DataFormatDefinition.java#L52) ?"", 'commenter': 'johnpoth'}]"
2206,components/camel-fhir/src/main/java/org/apache/camel/component/fhir/FhirXmlDataFormat.java,"@@ -0,0 +1,98 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.fhir;
+
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.OutputStream;
+import java.io.OutputStreamWriter;
+
+import ca.uhn.fhir.context.FhirContext;
+import org.apache.camel.Exchange;
+import org.apache.camel.spi.DataFormat;
+import org.apache.camel.spi.DataFormatName;
+import org.apache.camel.support.ServiceSupport;
+import org.hl7.fhir.instance.model.api.IBaseResource;
+
+public class FhirXmlDataFormat extends ServiceSupport implements DataFormat, DataFormatName {
+    
+    private FhirContext fhirContext;
+    private boolean contentTypeHeader = true;","[{'comment': 'Ditto', 'commenter': 'davsclaus'}]"
2206,components/camel-fhir/src/test/resources/log4j2.properties,"@@ -0,0 +1,23 @@
+## ---------------------------------------------------------------------------
+## Licensed to the Apache Software Foundation (ASF) under one or more
+## contributor license agreements.  See the NOTICE file distributed with
+## this work for additional information regarding copyright ownership.
+## The ASF licenses this file to You under the Apache License, Version 2.0
+## (the ""License""); you may not use this file except in compliance with
+## the License.  You may obtain a copy of the License at
+##
+##      http://www.apache.org/licenses/LICENSE-2.0
+##
+## Unless required by applicable law or agreed to in writing, software
+## distributed under the License is distributed on an ""AS IS"" BASIS,
+## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+## See the License for the specific language governing permissions and
+## limitations under the License.
+## ---------------------------------------------------------------------------
+
+appender.out.type = Console
+appender.out.name = out
+appender.out.layout.type = PatternLayout
+appender.out.layout.pattern = [%30.30t] %-30.30c{1} %-5p %m%n
+rootLogger.level = INFO
+rootLogger.appenderRef.out.ref = out","[{'comment': 'Add logging to file as well, see the other data formats', 'commenter': 'davsclaus'}]"
2206,components/camel-fhir/src/test/resources/org/apache/camel/dataformat/fhir/json/FhirJsonDataFormatSpringTest.xml,"@@ -0,0 +1,44 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one or more
+    contributor license agreements.  See the NOTICE file distributed with
+    this work for additional information regarding copyright ownership.
+    The ASF licenses this file to You under the Apache License, Version 2.0
+    (the ""License""); you may not use this file except in compliance with
+    the License.  You may obtain a copy of the License at
+
+         http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an ""AS IS"" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+
+-->
+<beans xmlns=""http://www.springframework.org/schema/beans""
+       xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
+       xsi:schemaLocation=""
+       http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
+       http://camel.apache.org/schema/spring http://camel.apache.org/schema/spring/camel-spring.xsd
+    "">
+  <bean id=""fhirContext"" class=""ca.uhn.fhir.context.FhirContext"" factory-method=""forDstu3""/>","[{'comment': 'Find a way to make configuring this easier in XML - for example add some kind of way to just say ""forDstu3"" and Camel can do all this stuff for you. Only if you need to manually do something you can do all of this.', 'commenter': 'davsclaus'}]"
2209,components/camel-xchange/src/main/java/org/apache/camel/component/xchange/XChangeMarketDataProducer.java,"@@ -45,17 +40,15 @@ public XChangeEndpoint getEndpoint() {
     }
 
     @Override
-    protected int poll() throws Exception {
-        CurrencyPair pair = getEndpoint().getConfiguration().getCurrencyPair();
-        LOG.info(""Going to execute ticker query for {}"", pair);
-        
-        Ticker ticker = marketService.getTicker(pair);
-        
-        Exchange exchange = getEndpoint().createExchange();
-        exchange.getIn().setBody(ticker);
-        getProcessor().process(exchange);
+    public void process(Exchange exchange) throws Exception {
+
+        XChangeEndpoint endpoint = getEndpoint();
+        String method = endpoint.getConfiguration().getMethod();
         
-        return 1;
+        if (METHOD_TICKER.equals(method)) {
+            CurrencyPair pair = exchange.getIn().getHeader(HEADER_CURRENCY_PAIR, CurrencyPair.class);
+            Ticker ticker = marketService.getTicker(pair);
+            exchange.getOut().setBody(ticker);","[{'comment': 'Dont set on OUT like that as it losses headers and whatnot during routing.  See this FAQ: http://camel.apache.org/using-getin-or-getout-methods-on-exchange.html\r\n\r\nAnd there is a new getMessage() you can use btw', 'commenter': 'davsclaus'}, {'comment': 'Ok, got it.', 'commenter': 'tdiesler'}]"
2209,components/camel-xchange/src/main/java/org/apache/camel/component/xchange/XChangeMetaDataConsumer.java,"@@ -0,0 +1,56 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.xchange;
+
+import static org.apache.camel.component.xchange.XChangeConfiguration.METHOD_CURRENCIES;
+import static org.apache.camel.component.xchange.XChangeConfiguration.METHOD_CURRENCY_PAIRS;
+
+import org.apache.camel.Exchange;
+import org.apache.camel.Processor;
+import org.apache.camel.impl.DefaultConsumer;
+
+public class XChangeMetaDataConsumer extends DefaultConsumer {
+    
+    public XChangeMetaDataConsumer(XChangeEndpoint endpoint, Processor processor) {
+        super(endpoint, processor);
+    }
+
+    @Override
+    public XChangeEndpoint getEndpoint() {
+        return (XChangeEndpoint) super.getEndpoint();
+    }
+
+    @Override
+    protected void doStart() throws Exception {
+        super.doStart();
+
+        XChangeEndpoint endpoint = getEndpoint();
+        String method = endpoint.getConfiguration().getMethod();
+        
+        if (METHOD_CURRENCIES.equals(method)) {","[{'comment': 'This looks really wrong as this consumer is run only once. Before it was scheduled so it calls that once every X period. Why did you change this? If its not scheduled then the 3rd party library must have some kind of event behavior or scheduling on its own that triggers and calls this consumer to process the message in a Camel route', 'commenter': 'davsclaus'}, {'comment': 'Also the routing should never process in the start method. Those are for starting up resources and whatnot. Only after its started it should poll/trigger on events and route messages - not before.', 'commenter': 'davsclaus'}, {'comment': 'The [ticker](https://github.com/tdiesler/camel/blob/CAMEL-12167/components/camel-xchange/src/main/java/org/apache/camel/component/xchange/XChangeMarketDataProducer.java#L48) functionality is now an ordinary producer. The user ask for the current price of a currency pair when needed (i.e. poll) instead of the component doing these polls on a scheduled basis.', 'commenter': 'tdiesler'}, {'comment': ""The [metadata consumer](https://github.com/tdiesler/camel/blob/CAMEL-12167/components/camel-xchange/src/main/java/org/apache/camel/component/xchange/XChangeMetaDataConsumer.java) is indeed something I'm not at all sure about. Here I want to give access to metadata associated with the underlying XChange (not the Camel Exchange). This data becomes available when the endpoint is created and does not change during its lifetime. The low level API is [on the endpoint](https://github.com/tdiesler/camel/blob/CAMEL-12167/components/camel-xchange/src/main/java/org/apache/camel/component/xchange/XChangeEndpoint.java#L95)."", 'commenter': 'tdiesler'}, {'comment': 'Please see how the [test case](https://github.com/tdiesler/camel/blob/CAMEL-12167/components/camel-xchange/src/test/java/org/apache/camel/component/xchange/MetaDataConsumerTest.java) currently uses the metadata service', 'commenter': 'tdiesler'}]"
2209,components/camel-xchange/src/main/java/org/apache/camel/component/xchange/XChangeMetaDataProducer.java,"@@ -0,0 +1,56 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.xchange;
+
+import static org.apache.camel.component.xchange.XChangeConfiguration.HEADER_CURRENCY;
+import static org.apache.camel.component.xchange.XChangeConfiguration.HEADER_CURRENCY_PAIR;
+import static org.apache.camel.component.xchange.XChangeConfiguration.METHOD_CURRENCY_METADATA;
+import static org.apache.camel.component.xchange.XChangeConfiguration.METHOD_CURRENCY_PAIR_METADATA;
+
+import org.apache.camel.Exchange;
+import org.apache.camel.impl.DefaultProducer;
+import org.knowm.xchange.currency.Currency;
+import org.knowm.xchange.currency.CurrencyPair;
+
+public class XChangeMetaDataProducer extends DefaultProducer {
+    
+    public XChangeMetaDataProducer(XChangeEndpoint endpoint) {
+        super(endpoint);
+    }
+
+    @Override
+    public XChangeEndpoint getEndpoint() {
+        return (XChangeEndpoint) super.getEndpoint();
+    }
+
+    @Override
+    public void process(Exchange exchange) throws Exception {
+
+        XChangeEndpoint endpoint = getEndpoint();
+        String method = endpoint.getConfiguration().getMethod();
+        
+        if (METHOD_CURRENCY_METADATA.equals(method)) {
+            Currency curr = exchange.getIn().getHeader(HEADER_CURRENCY, Currency.class);
+            Object body = endpoint.getCurrencyMetaData(curr);
+            exchange.getOut().setBody(body);","[{'comment': 'See previous about IN vs OUT', 'commenter': 'davsclaus'}]"
2209,components/camel-xchange/src/main/java/org/apache/camel/component/xchange/XChangeEndpoint.java,"@@ -16,15 +16,27 @@
  */
 package org.apache.camel.component.xchange;
 
+import static org.apache.camel.component.xchange.XChangeConfiguration.SERVICE_MARKETDATA;
+import static org.apache.camel.component.xchange.XChangeConfiguration.SERVICE_METADATA;
+
+import java.util.List;
+import java.util.stream.Collectors;
+
 import org.apache.camel.Consumer;
 import org.apache.camel.Processor;
 import org.apache.camel.Producer;
-import org.apache.camel.impl.DefaultPollingEndpoint;
+import org.apache.camel.impl.DefaultEndpoint;
 import org.apache.camel.spi.UriEndpoint;
 import org.apache.camel.spi.UriParam;
+import org.knowm.xchange.currency.Currency;
+import org.knowm.xchange.currency.CurrencyPair;
+import org.knowm.xchange.dto.meta.CurrencyMetaData;
+import org.knowm.xchange.dto.meta.CurrencyPairMetaData;
+import org.knowm.xchange.dto.meta.ExchangeMetaData;
+import org.knowm.xchange.utils.Assert;
 
-@UriEndpoint(firstVersion = ""2.21.0"", scheme = ""xchange"", title = ""XChange"", syntax = ""xchange:name"", consumerClass = XChangeConsumer.class, label = ""api"")
-public class XChangeEndpoint extends DefaultPollingEndpoint {
+@UriEndpoint(firstVersion = ""2.21.0"", scheme = ""xchange"", title = ""XChange"", syntax = ""xchange:name"", label = ""api"")","[{'comment': 'You need to set consumerOnly = true, also label = ""api"" should be label = ""currency"" or ""crypto-currency"" or something that is a good label for this kind of components (think label = group)', 'commenter': 'davsclaus'}, {'comment': 'How about blockchain?', 'commenter': 'tdiesler'}]"
2209,components/camel-xchange/src/main/java/org/apache/camel/component/xchange/XChangeConfiguration.java,"@@ -17,23 +17,59 @@
 package org.apache.camel.component.xchange;
 
 
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
 import org.apache.camel.spi.Metadata;
 import org.apache.camel.spi.UriParam;
 import org.apache.camel.spi.UriParams;
 import org.apache.camel.spi.UriPath;
 import org.apache.camel.util.ObjectHelper;
+import org.knowm.xchange.Exchange;
+import org.knowm.xchange.currency.Currency;
 import org.knowm.xchange.currency.CurrencyPair;
+import org.knowm.xchange.utils.Assert;
 
 @UriParams
 public class XChangeConfiguration {
 
+    static final String SERVICE_MARKETDATA = ""marketdata"";
+    static final String SERVICE_METADATA = ""metadata"";
+    
+    static List<String> supportedServices = Arrays.asList(SERVICE_MARKETDATA, SERVICE_METADATA);
+    
+    static final String METHOD_CURRENCIES = ""currencies"";
+    static final String METHOD_CURRENCY_METADATA = ""currencyMetaData"";
+    static final String METHOD_CURRENCY_PAIRS = ""currencyPairs"";
+    static final String METHOD_CURRENCY_PAIR_METADATA = ""currencyPairMetaData"";
+    static final String METHOD_TICKER = ""ticker"";
+
+    static List<String> supportedMethods = Arrays.asList(
+            METHOD_CURRENCIES, METHOD_CURRENCY_METADATA, METHOD_CURRENCY_PAIRS, METHOD_CURRENCY_PAIR_METADATA, METHOD_TICKER);
+    
+    static final String HEADER_CURRENCY = ""Currency"";
+    static final String HEADER_CURRENCY_PAIR = ""CurrencyPair"";
+    
     @UriPath(description = ""The exchange to connect to"") @Metadata(required = ""true"")
     private String name;
+    @UriParam(description = ""The service to call"") @Metadata(required = ""true"")","[{'comment': 'You can add enum=""a,b,c"" with the valid values these can have, then its part of the meta-data and tooling would be able to know - we do this for other components.', 'commenter': 'davsclaus'}]"
2209,components/camel-xchange/src/main/java/org/apache/camel/component/xchange/XChangeConfiguration.java,"@@ -46,19 +82,57 @@ public void setName(String name) {
         this.name = name;
     }
 
+    public String getService() {
+        return service;
+    }
+
+    public void setService(String service) {
+        Assert.isTrue(supportedServices.contains(service), ""Unsupported service, we have: "" + supportedServices);","[{'comment': 'We tend to do this kind of validation in the doStart method of the component or when creating the producer / consumer (if specific to them) and there is a `ObjectHelper.notNull / notEmpty` we tend to use for this kind.', 'commenter': 'davsclaus'}, {'comment': ""Yes, I saw the ObjectHelper in Camel. The XChange library however also provides Assert.isTrue() which I couldn't find in Camel"", 'commenter': 'tdiesler'}]"
2216,components/camel-xchange/src/main/java/org/apache/camel/component/xchange/XChangeComponent.java,"@@ -36,15 +38,29 @@ protected Endpoint createEndpoint(String uri, String remaining, Map<String, Obje
         // Set the the required name of the exchange
         configuration.setName(remaining);
 
-        // Get the XChange implementation
-        Class<? extends Exchange> exchangeClass = configuration.getXChangeClass();
-        Assert.notNull(exchangeClass, ""XChange not supported: "" + configuration.getName());
-        
-        // Create the XChange and associated Endpoint
-        XChange exchange = new XChange(ExchangeFactory.INSTANCE.createExchange(exchangeClass));
+        XChange exchange = createXChange(configuration);
         XChangeEndpoint endpoint = new XChangeEndpoint(uri, this, configuration, exchange);
         
         return endpoint;
     }
 
+    public XChange getXChange() {
+        return exchange;
+    }
+    
+    private synchronized XChange createXChange(XChangeConfiguration configuration) {","[{'comment': 'Its better to do this in doStart so you dont need synchronized code blocks', 'commenter': 'davsclaus'}, {'comment': ""I'd like to create the XChange once so it can be shared among all endpoints. For this I'd need some piece of information that names the exchange. This is currently encoded in the URI and (if IIUC) becomes available when the endpoint is created.\r\n\r\nIf I do this initialization in Endpoint.doStart(), I'd still need to synchronize unless it is guaranteed that endpoints are not started in parallel (also in the future).\r\n\r\nIf I do this initialization in Component.doStart(), I'd not know how to get at the piece of information that names the exchange.\r\n"", 'commenter': 'tdiesler'}]"
2226,components/camel-aws/src/main/java/org/apache/camel/component/aws/s3/S3Component.java,"@@ -67,8 +67,8 @@ protected Endpoint createEndpoint(String uri, String remaining, Map<String, Obje
         if (ObjectHelper.isEmpty(configuration.getRegion())) {
             setRegion(region);
         }
-        if (configuration.getAmazonS3Client() == null && (configuration.getAccessKey() == null || configuration.getSecretKey() == null)) {
-            throw new IllegalArgumentException(""AmazonS3Client or accessKey and secretKey must be specified"");
+        if (configuration.isUseIAMCredentials() == false && configuration.getAmazonS3Client() == null && (configuration.getAccessKey() == null || configuration.getSecretKey() == null)) {
+            throw new IllegalArgumentException(""useIAMCredentials is set to false, AmazonS3Client or accessKey and secretKey must be specified"");","[{'comment': ""Since useIAMCredentials is not mandatory, it doesn't make sense to log that it has been set to false."", 'commenter': 'oscerd'}, {'comment': 'Well, it doesn\'t make sense with that perspective, but when I start to think about the code functionality, it becomes useful. For the record, I dont think AmazonS3Client is mandatory within the configuration string either and it sort of has the same logic for including isUseIAMCredentials.\r\n\r\nConsider the case when a user is expecting to use the ""isUseIAMCredentials"" option and therefore has not provided any accessKey, secretKey and AmazonS3Client, it would be beneficial to see within the logs (after failure) that the flag has not been set to use the IAMCredentials on the ec2 instance... Its a hint more or less that this is an option that you can consider instead of providing accessKey, secretKey or a custom client (as the only case that you cant provide the other three, you have to provide the iamCredentials). With all of that said, I could care less whether this log makes it into production :)', 'commenter': 'cpvandehey'}]"
2226,components/camel-aws/src/main/java/org/apache/camel/component/aws/s3/client/AWSS3ClientFactory.java,"@@ -0,0 +1,37 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.aws.s3.client;
+
+import org.apache.camel.component.aws.s3.S3Configuration;
+import org.apache.camel.component.aws.s3.client.impl.StandardAWSS3ClientImpl;
+import org.apache.camel.component.aws.s3.client.impl.IAMOptimizedAWSS3ClientImpl;
+
+/**
+ * Factory class to return the correct type of AWS S3 aws.
+ */
+public final class AWSS3ClientFactory {
+
+	/**
+	 * Return the correct aws s3 client (based on remote vs local).
+	 * @param maxConnections max connections
+	 * @return AWSS3Client
+	 */
+	public static AWSS3Client getAWSS3Client(S3Configuration configuration, int maxConnections) {","[{'comment': 'Maybe use a client Factory only for adding a call to a builder method is a bit overkill. The code in two classes is almost the same except for minor things. Maybe we can refactor next.', 'commenter': 'oscerd'}, {'comment': ""Hmm... Im very conflicted on this one. This decision will likely be a bit opinionated because there are pros and cons to each approach. I like the factory because its incredibly clean and easier to debug, but I also like the idea that you could have this all in one class (since it will likely only have 1 method (i.e. get client) and the differences aren't extreme by any means (not to say that there aren't significant differences)).\r\n\r\nTo me, this is more a shoulder shrug than anything. I prefer the factory because I am used to writing classes with this pattern in situations similar to this. I do see your point in regards to the refactoring/adding features to the client that may cause confusion when trying to do in multiple classes."", 'commenter': 'cpvandehey'}]"
2255,camel-core/src/main/java/org/apache/camel/builder/ExpressionBuilder.java,"@@ -764,7 +765,7 @@ public static Expression systemEnvironmentExpression(final String propertyName,
                                                          final String defaultValue) {
         return new ExpressionAdapter() {
             public Object evaluate(Exchange exchange) {
-                String text = simpleExpression(propertyName).evaluate(exchange, String.class);
+                String text = simpleExpression(propertyName.toUpperCase(Locale.ROOT)).evaluate(exchange, String.class);
                 String answer = System.getenv(text);","[{'comment': 'It should be `text` that is upper cased, eg the result of the simple expression', 'commenter': 'davsclaus'}]"
2255,camel-core/src/main/java/org/apache/camel/builder/ExpressionBuilder.java,"@@ -775,7 +776,7 @@ public Object evaluate(Exchange exchange) {
 
             @Override
             public String toString() {
-                return ""systemEnvironment("" + propertyName + "")"";
+                return ""systemEnvironment("" + propertyName.toUpperCase(Locale.ROOT) + "")"";","[{'comment': 'That is not needed here', 'commenter': 'davsclaus'}]"
2277,components/camel-jaxb/src/main/java/org/apache/camel/converter/jaxb/FilteringXmlStreamWriter.java,"@@ -36,13 +36,18 @@
     NonXmlCharFilterer nonXmlCharFilterer = new NonXmlCharFilterer();
 
     private XMLStreamWriter writer;
+    private String encoding;
 
     /**
      * @param writer
      *            target writer to wrap.
+     * @param encoding
+     *            the encoding to write in header
+     *
      */
-    public FilteringXmlStreamWriter(XMLStreamWriter writer) {","[{'comment': 'Keeping the old constructor along with the new one would avoid an API break. This way you would leverage the good implementation you have done in `writeStartDocument` overloads.', 'commenter': 'aldettinger'}]"
2277,components/camel-jaxb/src/main/java/org/apache/camel/converter/jaxb/FilteringXmlStreamWriter.java,"@@ -36,13 +36,18 @@
     NonXmlCharFilterer nonXmlCharFilterer = new NonXmlCharFilterer();
 
     private XMLStreamWriter writer;
+    private String encoding;
 
     /**
      * @param writer
      *            target writer to wrap.
+     * @param encoding
+     *            the encoding to write in header
+     *
      */
-    public FilteringXmlStreamWriter(XMLStreamWriter writer) {
+    public FilteringXmlStreamWriter(XMLStreamWriter writer, String encoding) {
         this.writer = writer;
+        this.encoding = encoding != null ? encoding.toUpperCase() : null;","[{'comment': 'Could you please explain why we would need to store it upper case please ?', 'commenter': 'aldettinger'}, {'comment': ""I thought it would nicer for consumers of the produced XML. While lowercase is allowed by the standard and parsers should support it, there are parsers that break on lowercase. None I know of that break on uppercase (this could be because I never have used Shift_JIS, or other encodings with lowercase IANA names, so I can see why forcing uppercase might be a bad idea).\r\n\r\nI originally thought all IANA names were uppercase, which they are not. And this will take the choice out of the users hands. I'll remove it."", 'commenter': 'IIlllII'}]"
2277,components/camel-jaxb/src/main/java/org/apache/camel/converter/jaxb/JaxbDataFormat.java,"@@ -258,6 +238,27 @@ void doMarshal(Exchange exchange, Object graph, OutputStream stream, Marshaller
         }
     }
 
+    private void performWrite(Exchange exchange, OutputStream stream, XMLStreamWriter writer, Marshaller marshaller, Object toMarshall) throws JAXBException {
+        if (asXmlStreamWriter(exchange)) {
+            marshaller.marshal(toMarshall, writer);
+        } else {
+            marshaller.marshal(toMarshall, stream);
+        }
+    }
+","[{'comment': 'With the proposed refactoring, getWriter is called at each marshall attempt (performance) and even when `asXmlStreamWriter(exchange)` is false (behavior change). I would not include this change.', 'commenter': 'aldettinger'}, {'comment': ""Thanks, missed that. I'll revert it."", 'commenter': 'IIlllII'}]"
2277,components/camel-jaxb/src/main/java/org/apache/camel/converter/jaxb/JaxbDataFormat.java,"@@ -258,6 +238,27 @@ void doMarshal(Exchange exchange, Object graph, OutputStream stream, Marshaller
         }
     }
 
+    private void performWrite(Exchange exchange, OutputStream stream, XMLStreamWriter writer, Marshaller marshaller, Object toMarshall) throws JAXBException {
+        if (asXmlStreamWriter(exchange)) {
+            marshaller.marshal(toMarshall, writer);
+        } else {
+            marshaller.marshal(toMarshall, stream);
+        }
+    }
+
+    private XMLStreamWriter getWriter(Exchange exchange, OutputStream stream) {
+        XMLStreamWriter writer = typeConverter.convertTo(XMLStreamWriter.class, exchange, stream);
+        if (needFiltering(exchange)) {","[{'comment': 'Moreover, it hides the interesting changes (I mean the 2 lines above)', 'commenter': 'aldettinger'}]"
2277,components/camel-jaxb/src/test/java/org/apache/camel/converter/jaxb/FilteringXmlStreamWriterTest.java,"@@ -42,7 +42,7 @@
 
     @Before
     public void setUp() {
-        filteringXmlStreamWriter = new FilteringXmlStreamWriter(xmlStreamWriterMock);
+        filteringXmlStreamWriter = new FilteringXmlStreamWriter(xmlStreamWriterMock, null);","[{'comment': 'Could be avoided by removing the API break mentioned earlier.', 'commenter': 'aldettinger'}]"
2277,components/camel-jaxb/src/test/java/org/apache/camel/example/ExplicitEncodingAndXMLCharFilteringTest.java,"@@ -0,0 +1,85 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.example;
+
+import java.io.FileInputStream;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.Reader;
+
+import javax.xml.bind.JAXBContext;
+import javax.xml.bind.Unmarshaller;
+
+import org.apache.camel.builder.RouteBuilder;
+import org.apache.camel.component.mock.MockEndpoint;
+import org.apache.camel.converter.jaxb.JaxbDataFormat;
+import org.apache.camel.test.junit4.CamelTestSupport;
+import org.junit.Test;
+
+
+/**
+ * @version 
+ */
+public class ExplicitEncodingAndXMLCharFilteringTest extends CamelTestSupport {
+
+    @Override
+    public void setUp() throws Exception {
+        deleteDirectory(""target/charset"");
+        super.setUp();
+    }
+
+    @Test
+    public void testIsoAndCharacterFiltering() throws Exception {
+        PurchaseOrder order = new PurchaseOrder();
+        //Data containing characters ÆØÅæøå that differ in utf-8 and iso + a spouting whale
+        String name = ""\u00c6\u00d8\u00C5\u00e6\u00f8\u00e5\uD83D\uDC33\uFFFD"";
+        String expected = ""\u00c6\u00d8\u00C5\u00e6\u00f8\u00e5  \uFFFD""; //Spouting whale has become spaces
+        order.setName(name);
+        order.setAmount(123.45);
+        order.setPrice(2.22);
+
+        MockEndpoint result = getMockEndpoint(""mock:file"");
+        result.expectedFileExists(""target/charset/output.xml"");
+","[{'comment': 'And indeed the resulting file does not contain the spouting whale anymore with your fix. Seems that it was UTF-8 encoded before. Good catch :+1:.', 'commenter': 'aldettinger'}]"
2277,components/camel-jaxb/src/main/java/org/apache/camel/converter/jaxb/FilteringXmlStreamWriter.java,"@@ -36,13 +36,18 @@
     NonXmlCharFilterer nonXmlCharFilterer = new NonXmlCharFilterer();
 
     private XMLStreamWriter writer;
+    private String encoding;
 
     /**
      * @param writer
      *            target writer to wrap.
+     * @param encoding
+     *            the encoding to write in header","[{'comment': ""At first read, I interpreted 'header' as 'camel header'. Did you mean xml prolog instead ?"", 'commenter': 'aldettinger'}]"
2277,components/camel-jaxb/src/main/java/org/apache/camel/converter/jaxb/FallbackTypeConverter.java,"@@ -295,11 +295,13 @@ protected void doStop() throws Exception {
             Marshaller marshaller = context.createMarshaller();
             Writer buffer = new StringWriter();
 
+","[{'comment': 'No big deal, but if you could avoid introducing blank line.', 'commenter': 'aldettinger'}]"
2277,components/camel-jaxb/src/main/java/org/apache/camel/converter/jaxb/JaxbDataFormat.java,"@@ -206,9 +206,10 @@ void doMarshal(Exchange exchange, Object graph, OutputStream stream, Marshaller
         // only marshal if its possible
         if (introspector.isElement(element)) {
             if (asXmlStreamWriter(exchange)) {
-                XMLStreamWriter writer = typeConverter.convertTo(XMLStreamWriter.class, stream);
+                XMLStreamWriter writer = typeConverter.convertTo(XMLStreamWriter.class, exchange, stream);
                 if (needFiltering(exchange)) {
-                    writer = new FilteringXmlStreamWriter(writer);
+                    String charset = exchange.getProperty(Exchange.CHARSET_NAME, String.class);","[{'comment': 'Could you please change the method signature to `doMarshal(..., OutputStream stream, String charset, ...)` and get the charset from there ?', 'commenter': 'aldettinger'}]"
2277,components/camel-jaxb/src/main/java/org/apache/camel/converter/jaxb/JaxbDataFormat.java,"@@ -226,9 +227,10 @@ void doMarshal(Exchange exchange, Object graph, OutputStream stream, Marshaller
                     if (instance != null) {
                         Object toMarshall = objectFactoryMethod.invoke(instance, element);
                         if (asXmlStreamWriter(exchange)) {
-                            XMLStreamWriter writer = typeConverter.convertTo(XMLStreamWriter.class, stream);
+                            XMLStreamWriter writer = typeConverter.convertTo(XMLStreamWriter.class, exchange, stream);
                             if (needFiltering(exchange)) {
-                                writer = new FilteringXmlStreamWriter(writer);
+                                String charset = exchange.getProperty(Exchange.CHARSET_NAME, String.class);","[{'comment': 'Same here , we could also remove this line.', 'commenter': 'aldettinger'}]"
2283,components/camel-consul/src/main/java/org/apache/camel/component/consul/endpoint/ConsulEventConsumer.java,"@@ -33,32 +36,46 @@
 import org.apache.camel.component.consul.ConsulEndpoint;
 
 public final class ConsulEventConsumer extends AbstractConsulConsumer<EventClient> {
+    private ScheduledExecutorService scheduledExecutorService;
 
     public ConsulEventConsumer(ConsulEndpoint endpoint, ConsulConfiguration configuration, Processor processor) {
         super(endpoint, configuration, processor, Consul::eventClient);
+        this.scheduledExecutorService = endpoint.getCamelContext().getExecutorServiceManager().newSingleThreadScheduledExecutor(this, ""ConsulEventConsumer"");
     }
 
     @Override
     protected Runnable createWatcher(EventClient client) throws Exception {
         return new EventWatcher(client);
     }
 
+    @Override
+    protected void doStop() throws Exception {
+        scheduledExecutorService.shutdown();","[{'comment': '@Gr1f0n6x , please use ExecutorServiceManager.shutdownGraceful there', 'commenter': 'dmvolod'}, {'comment': ""@dmvolod, did it. Thank you for hint, didn't notice this method before"", 'commenter': 'nryanov'}]"
2283,components/camel-consul/src/main/java/org/apache/camel/component/consul/endpoint/ConsulEventConsumer.java,"@@ -28,37 +30,54 @@
 import org.apache.camel.Exchange;
 import org.apache.camel.Message;
 import org.apache.camel.Processor;
+import org.apache.camel.spi.ExecutorServiceManager;
 import org.apache.camel.component.consul.ConsulConfiguration;
 import org.apache.camel.component.consul.ConsulConstants;
 import org.apache.camel.component.consul.ConsulEndpoint;
 
 public final class ConsulEventConsumer extends AbstractConsulConsumer<EventClient> {
+    private ExecutorServiceManager executorServiceManager;
+    private ScheduledExecutorService scheduledExecutorService;
 
     public ConsulEventConsumer(ConsulEndpoint endpoint, ConsulConfiguration configuration, Processor processor) {
         super(endpoint, configuration, processor, Consul::eventClient);
+        this.executorServiceManager = endpoint.getCamelContext().getExecutorServiceManager();
+        this.scheduledExecutorService = this.executorServiceManager.newSingleThreadScheduledExecutor(this, ""ConsulEventConsumer"");","[{'comment': 'We create these in the doStart method, so we have start/stop logic together, and the constructors are light-weight', 'commenter': 'davsclaus'}]"
2292,components/camel-twitter/src/main/java/org/apache/camel/component/twitter/TwitterConfiguration.java,"@@ -74,6 +74,8 @@
     private Double radius;
     @UriParam(label = ""consumer,advanced"", defaultValue = ""km"", enums = ""km,mi"")
     private String distanceMetric;
+    @UriParam(label = ""consumer,advanced"")","[{'comment': 'I dont think this is an advanced option', 'commenter': 'davsclaus'}]"
2292,components/camel-twitter/src/main/java/org/apache/camel/component/twitter/TwitterConfiguration.java,"@@ -395,5 +398,19 @@ public String getDistanceMetric() {
     public void setDistanceMetric(String distanceMetric) {
         this.distanceMetric = distanceMetric;
     }
+    
+    /**
+     * Used for enabling full text from twitter.
+     * <p/>","[{'comment': 'Remove this <p>', 'commenter': 'davsclaus'}]"
2292,components/camel-twitter/src/main/java/org/apache/camel/component/twitter/TwitterConfiguration.java,"@@ -395,5 +398,19 @@ public String getDistanceMetric() {
     public void setDistanceMetric(String distanceMetric) {
         this.distanceMetric = distanceMetric;
     }
+    
+    /**
+     * Used for enabling full text from twitter.
+     * <p/>
+     */
+    public void setExtendedMode(Boolean extendedMode) {
+        this.radius = radius;","[{'comment': 'This is the wrong field you set, eg copy/paste bug', 'commenter': 'davsclaus'}]"
2292,components/camel-twitter/src/main/java/org/apache/camel/component/twitter/TwitterConfiguration.java,"@@ -74,6 +74,8 @@
     private Double radius;
     @UriParam(label = ""consumer,advanced"", defaultValue = ""km"", enums = ""km,mi"")
     private String distanceMetric;
+    @UriParam(label = ""consumer,advanced"")
+    private Boolean extendedMode;
 ","[{'comment': 'In other components we use boolean', 'commenter': 'oscerd'}, {'comment': 'Yeah lets use lower-case `boolean`. Also I wonder if the extended mode should not be default, eg twitter is now > 140 chars by default also.', 'commenter': 'davsclaus'}]"
2299,camel-core/src/test/resources/org/apache/camel/model/routeGroup.xml,"@@ -0,0 +1,29 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--","[{'comment': 'This do not look like the regular license header. The RAT check may fail.', 'commenter': 'davsclaus'}]"
2312,components/camel-aws/src/main/java/org/apache/camel/component/aws/sqs/SqsEndpoint.java,"@@ -121,28 +121,30 @@ protected void doStart() throws Exception {
             headerFilterStrategy = new SqsHeaderFilterStrategy();
         }
 
-        // If both region and Account ID is provided the queue URL can be built manually.
-        // This allows accessing queues where you don't have permission to list queues or query queues
-        if (configuration.getRegion() != null && configuration.getQueueOwnerAWSAccountId() != null) {
-            String host = configuration.getAmazonAWSHost();
-            host = FileUtil.stripTrailingSeparator(host);
-            queueUrl = ""https://sqs."" + configuration.getRegion() + ""."" + host + ""/""
-                +  configuration.getQueueOwnerAWSAccountId() + ""/"" + configuration.getQueueName();
-        } else if (configuration.getQueueOwnerAWSAccountId() != null) {
-            GetQueueUrlRequest getQueueUrlRequest = new GetQueueUrlRequest();
-            getQueueUrlRequest.setQueueName(configuration.getQueueName());
-            getQueueUrlRequest.setQueueOwnerAWSAccountId(configuration.getQueueOwnerAWSAccountId());
-            GetQueueUrlResult getQueueUrlResult = client.getQueueUrl(getQueueUrlRequest);
-            queueUrl = getQueueUrlResult.getQueueUrl();
+        if (configuration.getQueueUrl() != null) {
+            queueUrl = configuration.getQueueUrl();
         } else {
-            // check whether the queue already exists
-            ListQueuesResult listQueuesResult = client.listQueues();
-            for (String url : listQueuesResult.getQueueUrls()) {
-                if (url.endsWith(""/"" + configuration.getQueueName())) {
-                    queueUrl = url;
-                    LOG.trace(""Queue available at '{}'."", queueUrl);
-                    break;
-                }
+            // If both region and Account ID is provided the queue URL can be built manually.
+            // This allows accessing queues where you don't have permission to list queues or query queues
+            if (configuration.getRegion() != null && configuration.getQueueOwnerAWSAccountId() != null) {
+                queueUrl = ""https://sqs."" + configuration.getRegion() + "".amazonaws.com/""","[{'comment': 'Why did you remove the host specification? Can you add it again? ', 'commenter': 'oscerd'}, {'comment': ""Sorry, I was not careful enough. We're still on 2.18.4, so my changes stem from this version and I missed that improvement. I will put the host back in."", 'commenter': 'DaniRey'}]"
2312,components/camel-aws/src/main/java/org/apache/camel/component/aws/sqs/SqsConfiguration.java,"@@ -63,6 +63,8 @@
     private boolean extendMessageVisibility;
     @UriParam(label = ""consumer"", defaultValue = ""1"")
     private int concurrentConsumers = 1;
+    @UriParam","[{'comment': 'This should be labelled as advanced. As its not a common thing to use.', 'commenter': 'davsclaus'}, {'comment': ""I was not aware of this possibility, that's a lot better."", 'commenter': 'DaniRey'}]"
2312,components/camel-aws/src/main/java/org/apache/camel/component/aws/sqs/SqsConfiguration.java,"@@ -345,6 +347,17 @@ public int getConcurrentConsumers() {
     public void setConcurrentConsumers(int concurrentConsumers) {
         this.concurrentConsumers = concurrentConsumers;
     }
+	
+    /**
+     *  To define the queueUrl explicitly. All other parameters, which would influence the queueUrl, are ignored.
+     */","[{'comment': 'Add better javadoc what the purpose of this is, eg for testing/mocking etc. That it should not be used normally.', 'commenter': 'davsclaus'}, {'comment': 'I tried to improve this. I hope the new text covers the purpose well enough.', 'commenter': 'DaniRey'}]"
2333,components/camel-kafka/src/main/java/org/apache/camel/component/kafka/KafkaConfiguration.java,"@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the ""License""); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
+ * <p>
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * <p>","[{'comment': ""don't change the license header, what we expect is https://github.com/apache/camel/blob/master/etc/apache-header.txt"", 'commenter': 'lburgazzoli'}, {'comment': 'done', 'commenter': 'tdanylchuk'}]"
2333,components/camel-kafka/src/main/java/org/apache/camel/component/kafka/KafkaConsumer.java,"@@ -423,6 +427,12 @@ public void onPartitionsAssigned(Collection<TopicPartition> partitions) {
         }
     }
 
+    private void propagateHeaders(ConsumerRecord<Object, Object> record, Exchange exchange, HeaderFilterStrategy headerFilterStrategy) {
+        StreamSupport.stream(record.headers().spliterator(), false)
+                .filter(header -> !headerFilterStrategy.applyFilterToCamelHeaders(header.key(), header.value(), exchange))","[{'comment': 'filter(keepIncludedHeaders)?', 'commenter': 'vasilievip'}, {'comment': 'ok, will add additional method for this purpose', 'commenter': 'tdanylchuk'}]"
2333,components/camel-kafka/src/main/java/org/apache/camel/component/kafka/KafkaHeaderFilterStrategy.java,"@@ -0,0 +1,37 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.kafka;
+
+import org.apache.camel.impl.DefaultHeaderFilterStrategy;
+
+public class KafkaHeaderFilterStrategy extends DefaultHeaderFilterStrategy {
+
+    public KafkaHeaderFilterStrategy() {
+        initialize();  
+    }
+
+    protected void initialize() {","[{'comment': 'if you assume super.initialize in ancestors, its better to keep this code in constructor and make initialize abstract and eliminate assumptions', 'commenter': 'vasilievip'}, {'comment': 'wanted to keep convention with other filter strategies\r\nhttps://github.com/apache/camel/blob/3505e718db48cc0d8be5b47f6c4030c958d93a5f/components/camel-sjms/src/main/java/org/apache/camel/component/sjms/SjmsHeaderFilterStrategy.java\r\nhttps://github.com/apache/camel/blob/3505e718db48cc0d8be5b47f6c4030c958d93a5f/components/camel-aws/src/main/java/org/apache/camel/component/aws/sqs/SqsHeaderFilterStrategy.java\r\n\r\nand other classes...', 'commenter': 'tdanylchuk'}]"
2333,components/camel-kafka/src/main/java/org/apache/camel/component/kafka/KafkaProducer.java,"@@ -194,11 +202,11 @@ public ProducerRecord next() {
                     Object value = tryConvertToSerializedType(exchange, next, endpoint.getConfiguration().getSerializerClass());
 
                     if (hasPartitionKey && hasMessageKey) {
-                        return new ProducerRecord(msgTopic, partitionKey, key, value);
+                        return new ProducerRecord(msgTopic, partitionKey, null, key, value, propagatedHeaders);","[{'comment': 'can you replace null with named constants?', 'commenter': 'vasilievip'}, {'comment': 'a lot of code would be added only for this purpose, is there a need for this?', 'commenter': 'tdanylchuk'}, {'comment': 'yes, this is better than new MyClass(null, null, null, null)...', 'commenter': 'vasilievip'}]"
2333,components/camel-kafka/src/main/java/org/apache/camel/component/kafka/KafkaProducer.java,"@@ -214,15 +222,39 @@ public void remove() {
 
         ProducerRecord record;
         if (hasPartitionKey && hasMessageKey) {
-            record = new ProducerRecord(topic, partitionKey, key, value);
+            record = new ProducerRecord(topic, partitionKey, null, key, value, propagatedHeaders);
         } else if (hasMessageKey) {
-            record = new ProducerRecord(topic, key, value);
+            record = new ProducerRecord(topic, null, null, key, value, propagatedHeaders);
         } else {
-            record = new ProducerRecord(topic, value);
+            record = new ProducerRecord(topic, null, null, null, value, propagatedHeaders);
         }
         return Collections.singletonList(record).iterator();
     }
 
+    private List<Header> getPropagatedHeaders(Exchange exchange, HeaderFilterStrategy headerFilterStrategy) {
+        return exchange.getIn().getHeaders().entrySet().stream()
+                .filter(entry -> !headerFilterStrategy.applyFilterToExternalHeaders(entry.getKey(), entry.getValue(), exchange))","[{'comment': 'filter(includedHeaders)?', 'commenter': 'vasilievip'}, {'comment': 'will add method', 'commenter': 'tdanylchuk'}]"
2333,components/camel-kafka/src/main/java/org/apache/camel/component/kafka/KafkaProducer.java,"@@ -214,15 +222,39 @@ public void remove() {
 
         ProducerRecord record;
         if (hasPartitionKey && hasMessageKey) {
-            record = new ProducerRecord(topic, partitionKey, key, value);
+            record = new ProducerRecord(topic, partitionKey, null, key, value, propagatedHeaders);
         } else if (hasMessageKey) {
-            record = new ProducerRecord(topic, key, value);
+            record = new ProducerRecord(topic, null, null, key, value, propagatedHeaders);
         } else {
-            record = new ProducerRecord(topic, value);
+            record = new ProducerRecord(topic, null, null, null, value, propagatedHeaders);
         }
         return Collections.singletonList(record).iterator();
     }
 
+    private List<Header> getPropagatedHeaders(Exchange exchange, HeaderFilterStrategy headerFilterStrategy) {
+        return exchange.getIn().getHeaders().entrySet().stream()
+                .filter(entry -> !headerFilterStrategy.applyFilterToExternalHeaders(entry.getKey(), entry.getValue(), exchange))
+                .map(entry -> new RecordHeader(entry.getKey(), getHeaderValue(entry.getValue())))
+                .collect(Collectors.toList());
+    }
+
+    private byte[] getHeaderValue(Object value) {","[{'comment': 'Is there particular reason to keep String, Long, integer and byte[]?\r\ncan I send Double or Byte or Boolean[]?', 'commenter': 'vasilievip'}, {'comment': 'https://kafka.apache.org/0110/javadoc/org/apache/kafka/common/header/Header.html\r\nalso this guy do not allow anything except byte[], so, why do you expect more?', 'commenter': 'vasilievip'}, {'comment': ""I've put most common types, so if you put unsupported one - value will be null.\r\nThe docs of kafka says that we need to bypass `byte[]` , but in camel headers we have `Object`, so I need somehow to know how to convert provided object to bytes.\r\n\r\nAlthough I agree, that `Double` also good to have supported."", 'commenter': 'tdanylchuk'}, {'comment': ""if value type is not supported you just silently put null value -- there is no reason for the dev why this doesn't work: no log or exception... i don't think this is nice"", 'commenter': 'Aloren'}, {'comment': 'agree\r\n+ added `warn` message \r\n+ added `Double` support', 'commenter': 'tdanylchuk'}]"
2333,components/camel-kafka/src/main/java/org/apache/camel/component/kafka/KafkaHeaderFilterStrategy.java,"@@ -0,0 +1,37 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.kafka;
+
+import org.apache.camel.impl.DefaultHeaderFilterStrategy;
+
+public class KafkaHeaderFilterStrategy extends DefaultHeaderFilterStrategy {
+
+    public KafkaHeaderFilterStrategy() {
+        initialize();  
+    }
+
+    protected void initialize() {
+        // filter out camel id and
+        getInFilter().add(""breadcrumbId"");","[{'comment': 'We should include this by default. If you do not want breadcrumbs then you can turn it off on CamelContext.', 'commenter': 'davsclaus'}, {'comment': ""Thought the purpose of this id is only keeping context linked within single instance.\r\nShould I add additional property for this need or let's rely on headers filter? "", 'commenter': 'tdanylchuk'}, {'comment': 'No its also to span over the network etc. So you should basically just remove those code lines.', 'commenter': 'davsclaus'}, {'comment': 'ok, will be done', 'commenter': 'tdanylchuk'}]"
2333,components/camel-kafka/src/main/java/org/apache/camel/component/kafka/KafkaProducer.java,"@@ -214,15 +223,49 @@ public void remove() {
 
         ProducerRecord record;
         if (hasPartitionKey && hasMessageKey) {
-            record = new ProducerRecord(topic, partitionKey, key, value);
+            record = new ProducerRecord(topic, partitionKey, null, key, value, propagatedHeaders);
         } else if (hasMessageKey) {
-            record = new ProducerRecord(topic, key, value);
+            record = new ProducerRecord(topic, null, null, key, value, propagatedHeaders);
         } else {
-            record = new ProducerRecord(topic, value);
+            record = new ProducerRecord(topic, null, null, null, value, propagatedHeaders);
         }
         return Collections.singletonList(record).iterator();
     }
 
+    private List<Header> getPropagatedHeaders(Exchange exchange, HeaderFilterStrategy headerFilterStrategy) {
+        return exchange.getIn().getHeaders().entrySet().stream()
+                .filter(entry -> shouldBeFiltered(entry, exchange, headerFilterStrategy))
+                .map(entry -> new RecordHeader(entry.getKey(), getHeaderValue(entry.getValue())))
+                .collect(Collectors.toList());
+    }
+
+    private boolean shouldBeFiltered(Map.Entry<String, Object> entry, Exchange exchange, HeaderFilterStrategy headerFilterStrategy) {
+        return !headerFilterStrategy.applyFilterToExternalHeaders(entry.getKey(), entry.getValue(), exchange);
+    }
+
+    private byte[] getHeaderValue(Object value) {
+        if (value instanceof String) {
+            return ((String) value).getBytes();
+        } else if (value instanceof Long) {
+            ByteBuffer buffer = ByteBuffer.allocate(Long.BYTES);
+            buffer.putLong((Long) value);
+            return buffer.array();
+        } else if (value instanceof Integer) {
+            ByteBuffer buffer = ByteBuffer.allocate(Integer.BYTES);
+            buffer.putInt((Integer) value);
+            return buffer.array();
+        } else if (value instanceof Double) {
+            ByteBuffer buffer = ByteBuffer.allocate(Double.BYTES);
+            buffer.putDouble((Double) value);
+            return buffer.array();
+        } else if (value instanceof byte[]) {
+            return (byte[]) value;
+        }
+        log.warn(""Cannot propagate header value of type[{}], null will be provided instead. "" +
+                ""Supported types: String, Integer, Long, Double, byte[]."", value != null ? value.getClass() : ""null"");
+        return null;","[{'comment': 'Do you really want a null value for unsupported headers. I think we should drop the header entirely. This is what eg JMS component do and others. Also we should consider avoiding logging noise, eg a WARN log will be for every header. So maybe log at DEBUG by default. And then have better documentation about which header types is supported in the docs.', 'commenter': 'davsclaus'}, {'comment': 'agree, keeping the same behaviour is a must, will skip unsupported headers and decrease logging level.', 'commenter': 'tdanylchuk'}]"
2344,components/camel-micrometer/src/main/java/org/apache/camel/component/micrometer/eventnotifier/MicrometerEventNotifierMBean.java,"@@ -14,22 +14,16 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */","[{'comment': 'Why are you moving a file of camel-metrics for a new component?', 'commenter': 'oscerd'}, {'comment': '* Move must have happened accidentally... I restored the original file\r\n* Maybe http://camel.apache.org/how-do-i-add-a-component.html needs an update for occasional Camel contributors like me?\r\n* umm, I did run -Psourcecheck before. Do you see any code style issues?', 'commenter': 'ohr'}, {'comment': 'The documentation is old, we are moving to a new website and we are maintaining docs directly on github to be able to be consistent.', 'commenter': 'oscerd'}]"
2366,camel-core/src/main/java/org/apache/camel/model/ProcessorDefinition.java,"@@ -2284,6 +2284,48 @@ public ThrottleDefinition throttle(Expression maximumRequestCount) {
         addOutput(answer);
         return answer;
     }
+
+    /**
+     * <a href=""http://camel.apache.org/throttler.html"">Throttler EIP:</a>
+     * Creates a throttler allowing you to ensure that a specific endpoint does not get overloaded,
+     * or that we don't exceed an agreed SLA with some external service.
+     * Here another parameter correlationExpressionKey is introduced for the functionality which
+     * will throttle based on the key expression to group exchanges. This will make key-based throttling
+     * instead of overall throttling.
+     * <p/>
+     * Will default use a time period of 1 second, so setting the maximumRequestCount to eg 10
+     * will default ensure at most 10 messages per second.
+     *
+     * @param maximumRequestCount  an expression to calculate the maximum request count
+     * @param correlationExpressionKey  is a correlation key that can throttle by the given key instead of overall throttling","[{'comment': 'The javadoc param should be in the same order as in the method signature', 'commenter': 'davsclaus'}]"
2366,camel-core/src/main/java/org/apache/camel/model/ProcessorDefinition.java,"@@ -2284,6 +2284,48 @@ public ThrottleDefinition throttle(Expression maximumRequestCount) {
         addOutput(answer);
         return answer;
     }
+
+    /**
+     * <a href=""http://camel.apache.org/throttler.html"">Throttler EIP:</a>
+     * Creates a throttler allowing you to ensure that a specific endpoint does not get overloaded,
+     * or that we don't exceed an agreed SLA with some external service.
+     * Here another parameter correlationExpressionKey is introduced for the functionality which
+     * will throttle based on the key expression to group exchanges. This will make key-based throttling
+     * instead of overall throttling.
+     * <p/>
+     * Will default use a time period of 1 second, so setting the maximumRequestCount to eg 10
+     * will default ensure at most 10 messages per second.
+     *
+     * @param maximumRequestCount  an expression to calculate the maximum request count
+     * @param correlationExpressionKey  is a correlation key that can throttle by the given key instead of overall throttling
+     * @return the builder
+     */
+    public ThrottleDefinition throttle(long correlationExpressionKey, Expression maximumRequestCount) {
+        ThrottleDefinition answer = new ThrottleDefinition(ExpressionBuilder.constantExpression(correlationExpressionKey), maximumRequestCount);
+        addOutput(answer);
+        return answer;
+    }
+
+    /**
+     * <a href=""http://camel.apache.org/throttler.html"">Throttler EIP:</a>
+     * Creates a throttler allowing you to ensure that a specific endpoint does not get overloaded,
+     * or that we don't exceed an agreed SLA with some external service.
+     * Here another parameter correlationExpressionKey is introduced for the functionality which
+     * will throttle based on the key expression to group exchanges. This will make key-based throttling
+     * instead of overall throttling.
+     * <p/>
+     * Will default use a time period of 1 second, so setting the maximumRequestCount to eg 10
+     * will default ensure at most 10 messages per second.
+     *
+     * @param maximumRequestCount  an expression to calculate the maximum request count
+     * @param correlationExpressionKey  is a correlation key as an expression that can throttle by the given key instead of overall throttling","[{'comment': 'The javadoc param should be in the same order as in the method signature', 'commenter': 'davsclaus'}]"
2366,camel-core/src/main/java/org/apache/camel/model/ThrottleDefinition.java,"@@ -55,14 +56,28 @@
     private Boolean callerRunsWhenRejected;
     @XmlAttribute
     private Boolean rejectExecution;
-    
+    @XmlElement(name = ""correlationExpression"")
+    private ExpressionSubElementDefinition correlationExpression;","[{'comment': ""I would move this up as the correlation expression before the XmlAttribute's"", 'commenter': 'davsclaus'}]"
2376,components/camel-spring/src/test/resources/org/apache/camel/spring/processor/ThrottlerGroupingTest.xml,"@@ -0,0 +1,69 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>","[{'comment': 'Globally, you have 2 issues. It is not valid against the xml schema, and the test is not the exact translation of the java DSL `ThrottlingGroupingTest` tests. Examples below.', 'commenter': 'aldettinger'}]"
2376,components/camel-spring/src/test/resources/org/apache/camel/spring/processor/ThrottlerGroupingTest.xml,"@@ -0,0 +1,69 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one or more
+    contributor license agreements.  See the NOTICE file distributed with
+    this work for additional information regarding copyright ownership.
+    The ASF licenses this file to You under the Apache License, Version 2.0
+    (the ""License""); you may not use this file except in compliance with
+    the License.  You may obtain a copy of the License at
+
+         http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an ""AS IS"" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+
+-->
+<beans xmlns=""http://www.springframework.org/schema/beans""
+       xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
+       xsi:schemaLocation=""
+       http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
+       http://camel.apache.org/schema/spring http://camel.apache.org/schema/spring/camel-spring.xsd
+    "">
+
+  <bean id=""myBean"" class=""org.apache.camel.spring.processor.SpringThrottlerMethodCallTest""/>","[{'comment': 'No sure it is used/useful', 'commenter': 'aldettinger'}, {'comment': 'Yes. True', 'commenter': 'onderson'}]"
2376,components/camel-spring/src/test/resources/org/apache/camel/spring/processor/ThrottlerGroupingTest.xml,"@@ -0,0 +1,69 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one or more
+    contributor license agreements.  See the NOTICE file distributed with
+    this work for additional information regarding copyright ownership.
+    The ASF licenses this file to You under the Apache License, Version 2.0
+    (the ""License""); you may not use this file except in compliance with
+    the License.  You may obtain a copy of the License at
+
+         http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an ""AS IS"" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+
+-->
+<beans xmlns=""http://www.springframework.org/schema/beans""
+       xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
+       xsi:schemaLocation=""
+       http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
+       http://camel.apache.org/schema/spring http://camel.apache.org/schema/spring/camel-spring.xsd
+    "">
+
+  <bean id=""myBean"" class=""org.apache.camel.spring.processor.SpringThrottlerMethodCallTest""/>
+
+  <camelContext xmlns=""http://camel.apache.org/schema/spring"">
+    <errorHandler id=""dlc"" deadLetterUri=""mock:dead"" type=""DeadLetterChannel""/>
+    <route errorHandlerRef=""dlc"">
+      <from uri=""seda:a""/>
+      <throttle timePeriodMillis=""1000"">
+        <correlationExpression>
+          <constant>1</constant>
+        </correlationExpression>
+        <header>max</header>
+        <to uri=""log:result""/>
+        <to uri=""mock:result""/>
+      </throttle>
+    </route>
+    
+    <route errorHandlerRef=""dlc"">
+      <from uri=""seda:b""/>
+      <throttle timePeriodMillis=""1000"">
+        <correlationExpression>
+          <constant>2</constant>
+        </correlationExpression>
+        <header>max</header>
+        <to uri=""log:result""/>
+        <to uri=""mock:result""/>
+      </throttle>
+    </route>
+    
+    <route errorHandlerRef=""dlc"">
+      <from uri=""seda:a""/>","[{'comment': 'The java DSL test states `seda:c` here', 'commenter': 'aldettinger'}]"
2376,components/camel-spring/src/test/resources/org/apache/camel/spring/processor/ThrottlerGroupingTest.xml,"@@ -0,0 +1,69 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one or more
+    contributor license agreements.  See the NOTICE file distributed with
+    this work for additional information regarding copyright ownership.
+    The ASF licenses this file to You under the Apache License, Version 2.0
+    (the ""License""); you may not use this file except in compliance with
+    the License.  You may obtain a copy of the License at
+
+         http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an ""AS IS"" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+
+-->
+<beans xmlns=""http://www.springframework.org/schema/beans""
+       xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
+       xsi:schemaLocation=""
+       http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
+       http://camel.apache.org/schema/spring http://camel.apache.org/schema/spring/camel-spring.xsd
+    "">
+
+  <bean id=""myBean"" class=""org.apache.camel.spring.processor.SpringThrottlerMethodCallTest""/>
+
+  <camelContext xmlns=""http://camel.apache.org/schema/spring"">
+    <errorHandler id=""dlc"" deadLetterUri=""mock:dead"" type=""DeadLetterChannel""/>
+    <route errorHandlerRef=""dlc"">
+      <from uri=""seda:a""/>
+      <throttle timePeriodMillis=""1000"">
+        <correlationExpression>
+          <constant>1</constant>
+        </correlationExpression>
+        <header>max</header>
+        <to uri=""log:result""/>
+        <to uri=""mock:result""/>
+      </throttle>
+    </route>
+    
+    <route errorHandlerRef=""dlc"">
+      <from uri=""seda:b""/>
+      <throttle timePeriodMillis=""1000"">
+        <correlationExpression>
+          <constant>2</constant>
+        </correlationExpression>
+        <header>max</header>
+        <to uri=""log:result""/>
+        <to uri=""mock:result""/>","[{'comment': 'The java DSL test states `mock:result2` here', 'commenter': 'aldettinger'}, {'comment': 'As xml dsl does not work properly, i did not bother making them the same yet. You are right they should be the same at the end.', 'commenter': 'onderson'}]"
2376,components/camel-spring/src/test/resources/org/apache/camel/spring/processor/ThrottlerGroupingTest.xml,"@@ -0,0 +1,69 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one or more
+    contributor license agreements.  See the NOTICE file distributed with
+    this work for additional information regarding copyright ownership.
+    The ASF licenses this file to You under the Apache License, Version 2.0
+    (the ""License""); you may not use this file except in compliance with
+    the License.  You may obtain a copy of the License at
+
+         http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an ""AS IS"" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+
+-->
+<beans xmlns=""http://www.springframework.org/schema/beans""
+       xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
+       xsi:schemaLocation=""
+       http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
+       http://camel.apache.org/schema/spring http://camel.apache.org/schema/spring/camel-spring.xsd
+    "">
+
+  <bean id=""myBean"" class=""org.apache.camel.spring.processor.SpringThrottlerMethodCallTest""/>
+
+  <camelContext xmlns=""http://camel.apache.org/schema/spring"">
+    <errorHandler id=""dlc"" deadLetterUri=""mock:dead"" type=""DeadLetterChannel""/>
+    <route errorHandlerRef=""dlc"">
+      <from uri=""seda:a""/>
+      <throttle timePeriodMillis=""1000"">
+        <correlationExpression>
+          <constant>1</constant>
+        </correlationExpression>
+        <header>max</header>
+        <to uri=""log:result""/>
+        <to uri=""mock:result""/>
+      </throttle>
+    </route>
+    
+    <route errorHandlerRef=""dlc"">
+      <from uri=""seda:b""/>
+      <throttle timePeriodMillis=""1000"">
+        <correlationExpression>
+          <constant>2</constant>
+        </correlationExpression>
+        <header>max</header>
+        <to uri=""log:result""/>
+        <to uri=""mock:result""/>
+      </throttle>
+    </route>
+    
+    <route errorHandlerRef=""dlc"">
+      <from uri=""seda:a""/>
+      <throttle timePeriodMillis=""1000"">","[{'comment': 'The java DSL test states 2000ms here', 'commenter': 'aldettinger'}]"
2376,components/camel-spring/src/test/resources/org/apache/camel/spring/processor/ThrottlerGroupingTest.xml,"@@ -0,0 +1,69 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one or more
+    contributor license agreements.  See the NOTICE file distributed with
+    this work for additional information regarding copyright ownership.
+    The ASF licenses this file to You under the Apache License, Version 2.0
+    (the ""License""); you may not use this file except in compliance with
+    the License.  You may obtain a copy of the License at
+
+         http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an ""AS IS"" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+
+-->
+<beans xmlns=""http://www.springframework.org/schema/beans""
+       xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
+       xsi:schemaLocation=""
+       http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
+       http://camel.apache.org/schema/spring http://camel.apache.org/schema/spring/camel-spring.xsd
+    "">
+
+  <bean id=""myBean"" class=""org.apache.camel.spring.processor.SpringThrottlerMethodCallTest""/>
+
+  <camelContext xmlns=""http://camel.apache.org/schema/spring"">
+    <errorHandler id=""dlc"" deadLetterUri=""mock:dead"" type=""DeadLetterChannel""/>
+    <route errorHandlerRef=""dlc"">
+      <from uri=""seda:a""/>
+      <throttle timePeriodMillis=""1000"">","[{'comment': 'As found by Willem, the current version of the camel-spring schema requires to put the correlationExpression after the last `to` of this route.', 'commenter': 'aldettinger'}]"
2376,camel-core/src/main/java/org/apache/camel/processor/Throttler.java,"@@ -61,25 +70,32 @@
 
     private static final String PROPERTY_EXCHANGE_QUEUED_TIMESTAMP = ""CamelThrottlerExchangeQueuedTimestamp"";
     private static final String PROPERTY_EXCHANGE_STATE = ""CamelThrottlerExchangeState"";
+    // (throttling grouping) defaulted as 1 because there will be only one queue which is similar to implementation
+    // when there is no grouping for throttling
+    private static final Integer NO_CORRELATION_QUEUE_ID = new Integer(1);","[{'comment': 'Does it mean that we mix the default group when a correlationExpression evaluates to 1 ?', 'commenter': 'aldettinger'}, {'comment': 'Yes, this is correct. Not sure if that would happen very easily. Could not come up with something brighter. Open to hear ideas.', 'commenter': 'onderson'}, {'comment': 'Maybe keep throttleRate/delayQueue for default group and throttleRatesMap/defaultQueueCache for other groups.\r\nPerhaps, put that in a dedicated class named `ThrottleRates` ?\r\nAnother idea could be to use a less common value, e.g. `NO_CORRELATION_QUEUE_ID = new Integer(Integer.MAX_VALUE)`.\r\nNote that having a `correlationExpression` that could evaluate to the default group key would allow dynamic inclusion in the default group.', 'commenter': 'aldettinger'}, {'comment': 'nice comments, addressed some of them.\r\nconsidering the ones(till others) left undone', 'commenter': 'onderson'}]"
2376,camel-core/src/main/java/org/apache/camel/processor/Throttler.java,"@@ -192,6 +217,26 @@ public boolean process(final Exchange exchange, final AsyncCallback callback) {
         }
     }
 
+    private DelayQueue<ThrottlePermit> locateDelayQueue(final Integer key) throws InterruptedException, ExecutionException {        ","[{'comment': 'Could you please elaborate on why you are using a CompletableFuture here ?', 'commenter': 'aldettinger'}, {'comment': 'I could call complete manually, to get the result. That was it.', 'commenter': 'onderson'}]"
2376,camel-core/src/main/java/org/apache/camel/model/ThrottleDefinition.java,"@@ -43,6 +44,8 @@
 public class ThrottleDefinition extends ExpressionNode implements ExecutorServiceAwareDefinition<ThrottleDefinition> {
     // TODO: Camel 3.0 Should not support outputs
 
+    @XmlElement(name = ""correlationExpression"")
+    private ExpressionSubElementDefinition correlationExpression;","[{'comment': ""This correlationExpression must be put after to element, you had to find a way to setup the right order for it.  I don't think you can do it by just extends the ExpressionNode."", 'commenter': 'WillemJiang'}, {'comment': 'Not sure if it is a must. We can impose order with xmlorder tag. I did try. It did not help.', 'commenter': 'onderson'}, {'comment': 'Yeah I would also put correlationExpression as 2nd, eg its a new option, and it makes more sense, as its optional.', 'commenter': 'davsclaus'}]"
2376,camel-core/src/main/java/org/apache/camel/processor/Throttler.java,"@@ -61,25 +70,32 @@
 
     private static final String PROPERTY_EXCHANGE_QUEUED_TIMESTAMP = ""CamelThrottlerExchangeQueuedTimestamp"";
     private static final String PROPERTY_EXCHANGE_STATE = ""CamelThrottlerExchangeState"";
+    // (throttling grouping) defaulted as 1 because there will be only one queue which is similar to implementation
+    // when there is no grouping for throttling
+    private static final Integer NO_CORRELATION_QUEUE_ID = new Integer(1);
 
     private enum State { SYNC, ASYNC, ASYNC_REJECTED }
 
     private final Logger log = LoggerFactory.getLogger(Throttler.class);
     private final CamelContext camelContext;
-    private final DelayQueue<ThrottlePermit> delayQueue = new DelayQueue<>();
     private final ExecutorService asyncExecutor;
     private final boolean shutdownAsyncExecutor;
 
     private volatile long timePeriodMillis;
-    private volatile int throttleRate;
     private String id;
     private Expression maxRequestsPerPeriodExpression;
     private boolean rejectExecution;
     private boolean asyncDelayed;
     private boolean callerRunsWhenRejected = true;
+    private Expression correlationExpression;
+    // below 2 fields added for (throttling grouping)
+    private Map<Integer, DelayQueue<ThrottlePermit>> delayQueueCache;","[{'comment': 'We may introduce memory leak issue, if we keep adding items to the map without clean them.', 'commenter': 'WillemJiang'}, {'comment': 'It is actually cleared in shutdown. And i dont expect extreme numbers of grouping. It is possible but not so likely', 'commenter': 'onderson'}]"
2376,camel-core/src/main/java/org/apache/camel/processor/Throttler.java,"@@ -192,6 +217,26 @@ public boolean process(final Exchange exchange, final AsyncCallback callback) {
         }
     }
 
+    private DelayQueue<ThrottlePermit> locateDelayQueue(final Integer key) throws InterruptedException, ExecutionException {        
+        CompletableFuture<DelayQueue<ThrottlePermit>> futureDelayQueue = new CompletableFuture<>();
+
+        delayQueueCacheExecutorService.submit(() -> {
+            futureDelayQueue.complete(findDelayQueue(key));
+        });
+        DelayQueue<ThrottlePermit> currentQueue = futureDelayQueue.get();   ","[{'comment': ""futrueDelayQueue.get() is wait for the future method to complete, it doesn't save us time."", 'commenter': 'WillemJiang'}, {'comment': 'My intention was not save time, was to fill up the throttle group async', 'commenter': 'onderson'}, {'comment': ""I agree with Willem, I don't see yet the value of doing this async."", 'commenter': 'aldettinger'}, {'comment': 'maybe not very big plus. and \r\ni disagree. In case of async routing, could be useful.', 'commenter': 'onderson'}]"
2376,camel-core/src/main/java/org/apache/camel/processor/Throttler.java,"@@ -235,20 +282,22 @@ protected void enqueuePermit(final ThrottlePermit permit, final Exchange exchang
     /**
      * Evaluates the maxRequestsPerPeriodExpression and adjusts the throttle rate up or down.
      */
-    protected void calculateAndSetMaxRequestsPerPeriod(final Exchange exchange) throws Exception {
+    protected void calculateAndSetMaxRequestsPerPeriod(DelayQueue<ThrottlePermit> delayQueue, final Exchange exchange, final Integer key) throws Exception {
         Integer newThrottle = maxRequestsPerPeriodExpression.evaluate(exchange, Integer.class);
 
         if (newThrottle != null && newThrottle < 0) {
             throw new IllegalStateException(""The maximumRequestsPerPeriod must be a positive number, was: "" + newThrottle);
         }
 
         synchronized (this) {","[{'comment': 'As we separate throttleRate by the correlation id, we could use throttleRate as a lock instead of using this throttle object.', 'commenter': 'WillemJiang'}, {'comment': 'CorrelationExpression may be even better?', 'commenter': 'onderson'}, {'comment': 'My understanding is that `correlationExpression` is always the same. Would the finer grained lock be the result of the evaluation then, so namely `key`?', 'commenter': 'aldettinger'}, {'comment': 'Yes i meant the evaluated correlationExpression. I agree', 'commenter': 'onderson'}]"
2376,camel-core/src/main/java/org/apache/camel/processor/Throttler.java,"@@ -111,13 +128,21 @@ public boolean process(final Exchange exchange, final AsyncCallback callback) {
                 throw new RejectedExecutionException(""Run is not allowed"");
             }
 
-            calculateAndSetMaxRequestsPerPeriod(exchange);
+            Integer key;
+            if (correlationExpression != null) {
+                key = correlationExpression.evaluate(exchange, Integer.class);","[{'comment': ""If we use `key` as a finer grain lock, I would make a defensive copy because I'm not sure that the reference returned by evaluate could be used as a lock by another thread for another purpose."", 'commenter': 'aldettinger'}, {'comment': 'good point', 'commenter': 'onderson'}]"
2376,camel-core/src/main/java/org/apache/camel/model/ThrottleDefinition.java,"@@ -55,14 +60,26 @@
     private Boolean callerRunsWhenRejected;
     @XmlAttribute
     private Boolean rejectExecution;
-    
+
     public ThrottleDefinition() {
     }
 
     public ThrottleDefinition(Expression maximumRequestsPerPeriod) {
         super(maximumRequestsPerPeriod);
     }
 
+    public ThrottleDefinition(Expression correlationExpression, Expression maximumRequestsPerPeriod) {","[{'comment': 'These 2 constructors are using different order of the parameters, eg it would be good to keep it consistent. As correlation expression is a new parameter, I would add it as 2nd.', 'commenter': 'davsclaus'}]"
2387,camel-core/src/main/java/org/apache/camel/processor/aggregate/AggregateProcessor.java,"@@ -1448,6 +1448,12 @@ protected void doStop() throws Exception {
         if (recoverService != null) {
             camelContext.getExecutorServiceManager().shutdown(recoverService);
         }
+        
+        if (timeoutCheckerExecutorService != null) {","[{'comment': ""@gsudharsan , I'm not sure, that it's related to the CAMEL-4037. I think the reason why the tests are fails, that shutdown of the executor timeoutCheckerExecutorService is controlled by  shutdownTimeoutCheckerExecutorService boolean flag but not null value of the instance itself.\r\n@davsclaus , @oscerd what do you think about this?"", 'commenter': 'dmvolod'}, {'comment': ""I guess you're right @dmvolod "", 'commenter': 'oscerd'}, {'comment': 'OK, I will change the code to check the boolean iso null check and run the tests again..', 'commenter': 'gsudharsan'}]"
2387,camel-core/src/main/java/org/apache/camel/processor/aggregate/AggregateProcessor.java,"@@ -1448,6 +1448,11 @@ protected void doStop() throws Exception {
         if (recoverService != null) {
             camelContext.getExecutorServiceManager().shutdown(recoverService);
         }
+
+        if (shutdownTimeoutCheckerExecutorService) {
+            camelContext.getExecutorServiceManager().shutdown(timeoutCheckerExecutorService);","[{'comment': 'Looks like tests require to set executor service to null and flag to false after shutdown', 'commenter': 'dmvolod'}, {'comment': 'Does not seem that simple. And I need to be doubly careful to touch the tests', 'commenter': 'gsudharsan'}, {'comment': '@gsudharsan , yes, you can try. I did the changes and pass mvn clean install with success...', 'commenter': 'dmvolod'}]"
2391,tooling/apt/src/main/java/org/apache/camel/tools/apt/CoreEipAnnotationProcessor.java,"@@ -219,8 +219,8 @@ protected EipModel findEipModelProperties(ProcessingEnvironment processingEnv, R
         boolean deprecated = classElement.getAnnotation(Deprecated.class) != null;
         model.setDeprecated(deprecated);
 
-        Metadata metadata = classElement.getAnnotation(Metadata.class);
-        if (metadata != null) {
+        Metadata[] metadataArray = classElement.getAnnotationsByType(Metadata.class);
+        for (Metadata metadata : metadataArray) {","[{'comment': 'I dont think we should just loop and override the label, eg we should get the metadata annotation that has no `key` set as that is what is used for components today. Or it should grab the first that is not empty.', 'commenter': 'davsclaus'}, {'comment': 'not sure what i was thinking. i will look into it again.', 'commenter': 'onderson'}, {'comment': '> I dont think we should just loop and override the label, eg we should get the metadata annotation that has no `key` set as that is what is used for components today. Or it should grab the first that is not empty.\r\n\r\n@davsclaus , i will try to get back to the old PR and rework on it. I have got a couple of questions.\r\nAs per your comment, \r\n\r\n1- below will result in that with only Metadata annotation with key=""platform"" will be taken care of and the other will be ignored.\r\n\r\n`@Metadata(key = ""platforms"", enums = { ""spring"", ""spring-boot"", ""osgi"" })`\r\n`@Metadata(types = { MyExtension.cass })`\r\n\r\n2-  below will result in that with only Metadata annotation with key=""platforms"" will be taken care of and the other will be ignored.\r\n`@Metadata(key = ""platforms"", enums = { ""spring"", ""spring-boot"", ""osgi"" })`\r\n`@Metadata(key = ""extensions"", types = { MyExtension.cass })`\r\n\r\n3- below will result in that with only Metadata annotation with enums will be taken care of and the other will be ignored.\r\n`@Metadata(enums = { ""spring"", ""spring-boot"", ""osgi"" })`\r\n`@Metadata(types = { MyExtension.cass })`\r\n\r\nSo it feels like using multiple Metadata annotation will make no difference.\r\nPossibly i am getting something missing. \r\nCould you please help me understand?\r\n\r\n@lburgazzoli , could you also comment in the JIRA issue about the purpose of use of multiple Metadata annotation and how it may affect the resulting json files?\r\n', 'commenter': 'onderson'}]"
2391,tooling/apt/src/main/java/org/apache/camel/tools/apt/EndpointAnnotationProcessor.java,"@@ -359,12 +359,22 @@ protected ComponentModel findComponentProperties(RoundEnvironment roundEnv, UriE
         model.setLenientProperties(uriEndpoint.lenientProperties());
         model.setAsync(implementsInterface(processingEnv, roundEnv, endpointClassElement, ""org.apache.camel.AsyncEndpoint""));
 
+        String deprecationNote = null;
         // what is the first version this component was added to Apache Camel
         String firstVersion = uriEndpoint.firstVersion();
-        if (Strings.isNullOrEmpty(firstVersion) && endpointClassElement.getAnnotation(Metadata.class) != null) {
-            // fallback to @Metadata if not from @UriEndpoint
-            firstVersion = endpointClassElement.getAnnotation(Metadata.class).firstVersion();
+        Metadata[] metadataArray = endpointClassElement.getAnnotationsByType(Metadata.class);
+        for(Metadata metadata : metadataArray) {","[{'comment': 'code formatting looks like a checkstyle problem here', 'commenter': 'davsclaus'}, {'comment': 'there was not checkstyle issue AFAIR. will check again.', 'commenter': 'onderson'}, {'comment': ""@onderson , please note, that right now -Psourcecheck option doesn't stop build and just print audit message warning and you need to check it manually."", 'commenter': 'dmvolod'}]"
2392,camel-core/src/test/java/org/apache/camel/component/seda/SedaBlockWhenFullTest.java,"@@ -30,7 +30,7 @@
     private static final int DELAY_LONG = 100;
     private static final String MOCK_URI = ""mock:blockWhenFullOutput"";
     private static final String SIZE_PARAM = ""?size=%d"";
-    private static final String BLOCK_WHEN_FULL_URI = ""seda:blockingFoo"" + String.format(SIZE_PARAM, QUEUE_SIZE) + ""&blockWhenFull=true&timeout=0"";
+    private static final String BLOCK_WHEN_FULL_URI = ""seda:blockingFoo"" + String.format(SIZE_PARAM, QUEUE_SIZE) + ""&blockWhenFull=true&timeout=0&offerTimeout=200"";","[{'comment': 'test with this new parameter and without it would be good to see.', 'commenter': 'onderson'}]"
2392,camel-core/src/main/java/org/apache/camel/component/seda/SedaProducer.java,"@@ -236,13 +238,20 @@ protected void addToQueue(Exchange exchange, boolean copy) throws SedaConsumerNo
         }
 
         log.trace(""Adding Exchange to queue: {}"", target);
-        if (blockWhenFull) {
+        if (blockWhenFull && offerTimeout == 0) {
             try {
                 queue.put(target);
             } catch (InterruptedException e) {
                 // ignore
                 log.debug(""Put interrupted, are we stopping? {}"", isStopping() || isStopped());
             }
+        } else if(blockWhenFull && offerTimeout > 0) {
+            try {
+                queue.offer(target, offerTimeout, TimeUnit.MILLISECONDS);","[{'comment': 'I would\'ve expected the result of this call to be checked. And on ""false"" throw an IllegalStateException. Otherwise there is no way for the caller to know if the message was successfully added.', 'commenter': 'ragnarotech'}, {'comment': 'Done . please review now\r\n', 'commenter': 'ramu11'}]"
2392,camel-core/src/main/java/org/apache/camel/component/seda/SedaProducer.java,"@@ -41,30 +41,32 @@
     private final WaitForTaskToComplete waitForTaskToComplete;
     private final long timeout;
     private final boolean blockWhenFull;
+    private final long offerTimeout;
 
     /**
      * @deprecated Use {@link #SedaProducer(SedaEndpoint, WaitForTaskToComplete, long, boolean) the other constructor}.
      */
     @Deprecated
     public SedaProducer(SedaEndpoint endpoint, BlockingQueue<Exchange> queue, WaitForTaskToComplete waitForTaskToComplete, long timeout) {
-        this(endpoint, waitForTaskToComplete, timeout, false);
+        this(endpoint, waitForTaskToComplete, timeout, false, 0);
     }
 
     /**
      * @deprecated Use {@link #SedaProducer(SedaEndpoint, WaitForTaskToComplete, long, boolean) the other constructor}.
      */
     @Deprecated
-    public SedaProducer(SedaEndpoint endpoint, BlockingQueue<Exchange> queue, WaitForTaskToComplete waitForTaskToComplete, long timeout, boolean blockWhenFull) {
-        this(endpoint, waitForTaskToComplete, timeout, blockWhenFull);
+    public SedaProducer(SedaEndpoint endpoint, BlockingQueue<Exchange> queue, WaitForTaskToComplete waitForTaskToComplete, long timeout, boolean blockWhenFull, long offerTimeout) {","[{'comment': ""I don't know the coding standards for this project.  But this change (and the next constructor) could be consider breaking changes since the signature of an existing constructor is being changed.  Is this behavior allowed on this project?"", 'commenter': 'ragnarotech'}, {'comment': '@davsclaus  could you please have a look and suggest ,if any changes required', 'commenter': 'ramu11'}, {'comment': 'This is fine in a new minor release', 'commenter': 'davsclaus'}]"
2392,camel-core/src/main/java/org/apache/camel/component/seda/SedaProducer.java,"@@ -236,13 +239,24 @@ protected void addToQueue(Exchange exchange, boolean copy) throws SedaConsumerNo
         }
 
         log.trace(""Adding Exchange to queue: {}"", target);
-        if (blockWhenFull) {
+        if (blockWhenFull && offerTimeout == 0) {
             try {
                 queue.put(target);
             } catch (InterruptedException e) {
                 // ignore
                 log.debug(""Put interrupted, are we stopping? {}"", isStopping() || isStopped());
             }
+        } else if (blockWhenFull && offerTimeout > 0) {
+            try {
+                offerTime = queue.offer(target, offerTimeout, TimeUnit.MILLISECONDS);
+                if (!offerTime) {
+                    throw new IllegalStateException("" Fails to Insert the specified element into this queue, ""","[{'comment': 'Remove leading whitespace. Also maybe improve the text a little bit such as `Failed to insert element into queue after timeout of X milliseconds`', 'commenter': 'davsclaus'}, {'comment': 'Btw the JDK does just this: \r\n\r\n    throw new IllegalStateException(""Queue full"");', 'commenter': 'davsclaus'}]"
2392,camel-core/src/main/java/org/apache/camel/component/seda/SedaProducer.java,"@@ -236,13 +239,24 @@ protected void addToQueue(Exchange exchange, boolean copy) throws SedaConsumerNo
         }
 
         log.trace(""Adding Exchange to queue: {}"", target);
-        if (blockWhenFull) {
+        if (blockWhenFull && offerTimeout == 0) {
             try {
                 queue.put(target);
             } catch (InterruptedException e) {
                 // ignore
                 log.debug(""Put interrupted, are we stopping? {}"", isStopping() || isStopped());
             }
+        } else if (blockWhenFull && offerTimeout > 0) {
+            try {
+                offerTime = queue.offer(target, offerTimeout, TimeUnit.MILLISECONDS);
+                if (!offerTime) {
+                    throw new IllegalStateException("" Fails to Insert the specified element into this queue, ""
+                            + ""unable to free the space within configured""  + offerTimeout + ""milliseconds time"");
+                }
+            } catch (InterruptedException e) {
+                // ignore
+                log.debug(""offer interrupted, are we stopping? {}"", isStopping() || isStopped());","[{'comment': 'Maybe upper case first letter, eg `Offer ...`', 'commenter': 'davsclaus'}]"
2415,components/camel-geocoder/src/main/java/org/apache/camel/component/geocoder/GeoCoderEndpoint.java,"@@ -158,6 +149,15 @@ public void setClientKey(String clientKey) {
         this.clientKey = clientKey;
     }
 
+
+    private String getApiKey() {
+        return apiKey;
+    }
+
+    public void setApiKey(String apiKey) {","[{'comment': 'missing javadoc and component validation fails.', 'commenter': 'onderson'}]"
2415,components/camel-geocoder/src/test/java/org/apache/camel/component/geocoder/GeoCoderComponentAddressTest.java,"@@ -39,10 +39,10 @@ protected RouteBuilder createRouteBuilder() throws Exception {
         return new RouteBuilder() {
             public void configure() {
                 from(""direct:start"")
-                    .to(""geocoder:address:Paris, France"")
-                    .to(""log:result"")
-                    .log(""Location ${header.CamelGeocoderAddress} is at lat/lng: ${header.CamelGeocoderLatlng} in city ${header.CamelGeocoderCity}"")
-                    .to(""mock:result"");
+                        .to(""geocoder:address: empty?apiKey="" + getApiKey())","[{'comment': 'tests do no run. not sure about this uri setting. ', 'commenter': 'onderson'}, {'comment': '@onderson are there other tests that require secrets?', 'commenter': 'jborza'}, {'comment': '@jborza , not sure, as i said no tests were run while doing the build for the component.', 'commenter': 'onderson'}]"
2424,components/camel-aws/src/test/java/org/apache/camel/component/aws/sqs/SqsComponentConfigurationTest.java,"@@ -73,9 +73,9 @@ public void createEndpointWithMinimalArnConfiguration() throws Exception {
         
         ((JndiRegistry) ((PropertyPlaceholderDelegateRegistry) context.getRegistry()).getRegistry()).bind(""amazonSQSClient"", mock);
         SqsComponent component = new SqsComponent(context);
-        SqsEndpoint endpoint = (SqsEndpoint) component.createEndpoint(""aws-sqs://arn:aws:sqs:region:account:MyQueue?amazonSQSClient=#amazonSQSClient&accessKey=xxx&secretKey=yyy"");
+        SqsEndpoint endpoint = (SqsEndpoint) component.createEndpoint(""aws-sqs://arn:aws:sqs:region:account:MyQueue?amazonSQSClient=#amazonSQSClient&accessKey=xxx&secretKey=yyy&region=US_EAST_2"");
 
-        assertEquals(""region"", endpoint.getConfiguration().getRegion());","[{'comment': 'Should not this assert be null before this change?', 'commenter': 'onderson'}, {'comment': 'Region value was taken from ARN which is wrong. Take a look at the source file changes.', 'commenter': 'saravanakumar1987'}, {'comment': 'Why not? sqs://arn:aws:sqs:US_EAST_2:account:MyQueue?amazonSQSClient=#amazonSQSClient&accessKey=xxx&secretKey=yyy', 'commenter': 'onderson'}, {'comment': 'ARN is actually created like “arn:aws:sqs:us-east-2:account:MyQueue”. You can try creating a SQS Queue in AWS and check the syntax of ARN. It’s not the right place to get Region. Later the value is directly used in com.amazonaws API and gives problem in enum. Check the error message I posted in CAMEL-12647. Also aws-sns does not have this problem.', 'commenter': 'saravanakumar1987'}, {'comment': ""In this case, region in ARN on sqs component possibly becomes irrelevant. Doesn't it? Maybe number of parts in ARN would require extre length checks and conditions control by this [line](https://github.com/apache/camel/pull/2424/files#diff-b27317b097ef229e2092bebe046882f9R60). What do you think @oscerd ?"", 'commenter': 'onderson'}, {'comment': 'Yes. camel aws-sqs component uses com.amazonaws.AmazonWebServiceClient and it does not require ARN to get instance of it. The required parameters are parsed by camel from the given ARN.\r\n', 'commenter': 'saravanakumar1987'}, {'comment': 'The example of arn for an sqs endpoint is arn:aws:sqs:us-east-1:123456789012:MyQueue. The problem is that we are using the enum value of the Regions class, so probably we may need to double check if the region is specified as arn, then we need to manipulate it to use it and make it compliant to be used for the enum.  In my opinion the PR must be reviewed in this way.', 'commenter': 'oscerd'}]"
2427,components/camel-kafka/src/main/java/org/apache/camel/component/kafka/KafkaConsumer.java,"@@ -16,21 +16,14 @@
  */
 package org.apache.camel.component.kafka;
 
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Properties;
-import java.util.Set;
-import java.util.UUID;
+import java.util.*;","[{'comment': 'Please avoid importing stuff  with *', 'commenter': 'oscerd'}, {'comment': 'done', 'commenter': 'tdanylchuk'}]"
2427,components/camel-kafka/src/test/java/org/apache/camel/component/kafka/serde/DefaultKafkaHeaderSerializerTest.java,"@@ -0,0 +1,47 @@
+package org.apache.camel.component.kafka.serde;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import java.util.Arrays;
+import java.util.Collection;
+
+import static org.junit.Assert.assertArrayEquals;
+
+@RunWith(Parameterized.class)
+public class DefaultKafkaHeaderSerializerTest {
+
+    private KafkaHeaderSerializer serializer = new DefaultKafkaHeaderSerializer();
+
+    private Object value;
+    private byte[] expectedResult;
+
+    public DefaultKafkaHeaderSerializerTest(Object value, byte[] expectedResult) {
+        this.value = value;
+        this.expectedResult = expectedResult;
+    }
+
+    @Test
+    public void serialize() {
+        byte[] result = serializer.serialize(""someKey"", value);
+
+        System.out.println(Arrays.toString(result));","[{'comment': ""Use a log and don't print on standard out please"", 'commenter': 'oscerd'}, {'comment': 'oh, forgot to remove', 'commenter': 'tdanylchuk'}]"
2431,components/camel-git/src/main/java/org/apache/camel/component/git/producer/GitProducer.java,"@@ -407,6 +413,28 @@ protected void doPush(Exchange exchange, String operation) throws Exception {
         updateExchange(exchange, result);
     }
 
+    protected void doPushTag(Exchange exchange, String operation) throws Exception {
+        Iterable<PushResult> result = null;
+        try {
+            if (ObjectHelper.isEmpty(endpoint.getRemoteName())) {
+                throw new IllegalArgumentException(""Remote name must be specified to execute "" + operation);
+            }
+            if (ObjectHelper.isEmpty(endpoint.getTagName())) {
+                throw new IllegalArgumentException(""Tag Name must be specified to execute "" + operation);
+            }
+            if (ObjectHelper.isNotEmpty(endpoint.getUsername()) && ObjectHelper.isNotEmpty(endpoint.getPassword())) {
+                UsernamePasswordCredentialsProvider credentials = new UsernamePasswordCredentialsProvider(endpoint.getUsername(), endpoint.getPassword());
+                result = git.push().setCredentialsProvider(credentials).setRemote(endpoint.getRemoteName()).add(Constants.R_TAGS + endpoint.getTagName()).call();
+            } else {
+                result = git.push().setRemote(endpoint.getRemoteName()).add(Constants.R_TAGS + endpoint.getTagName()).call();
+            }
+        } catch (Exception e) {
+            LOG.error(""There was an error in Git "" + operation + "" operation"");","[{'comment': 'It would be better to use LOG.error(""There was an error in Git {} operation"", operation); instead', 'commenter': 'dmvolod'}, {'comment': ""Sure! But it's was followed others methods: i do not want to have modified the current normalization form. Do i change this, anyway?"", 'commenter': 'valtoni'}, {'comment': '@valtoni , yes, you are right, I can see that all methods are using this style for logging.\r\nAnother suggestion, do you think about use one method for doPush and doPushTag to prevent copy/paste a large peace of common code?', 'commenter': 'dmvolod'}, {'comment': 'We can extract the common part in an util method, but I would leave the operations separated', 'commenter': 'oscerd'}, {'comment': 'If you permit me, all methods must be refactored to create a more easy and fluent way to create new methods to add operations like this. I propose that we do that in another issue to make the action more coherent. I can create it if you want.', 'commenter': 'valtoni'}]"
2432,components/camel-http4/src/main/java/org/apache/camel/component/http4/HttpPollingConsumer.java,"@@ -117,6 +129,25 @@ protected Exchange doReceive(int timeout) {
             }
         }
     }
+    
+    /**
+     * Strategy when executing the method (calling the remote server).
+     *
+     * @param httpRequest the http Request to execute
+     * @return the response
+     * @throws IOException can be thrown
+     */
+    protected HttpResponse executeMethod(HttpRequestBase httpRequest, HttpClientContext httpClientContext) throws IOException {
+       
+        if (getEndpoint().isAuthenticationPreemptive()) {
+            BasicScheme basicAuth = new BasicScheme();
+            httpClientContext.setAttribute(""preemptive-auth"", basicAuth);
+        }
+        if (httpContext != null) {
+            httpClientContext = new HttpClientContext(httpContext);
+        }
+        return httpClient.execute(httpRequest, httpClientContext);
+    }
 ","[{'comment': 'Can you add a test for the consumer?', 'commenter': 'oscerd'}]"
2432,components/camel-http4/src/main/java/org/apache/camel/component/http4/HttpPollingConsumer.java,"@@ -33,21 +33,33 @@
 import org.apache.http.client.methods.HttpGet;
 import org.apache.http.client.methods.HttpRequestBase;
 import org.apache.http.client.protocol.HttpClientContext;
+import org.apache.http.impl.auth.BasicScheme;
+import org.apache.http.protocol.HttpContext;
 import org.apache.http.util.EntityUtils;
 
 /**
  * A polling HTTP consumer which by default performs a GET
  *
  * @version 
  */
+@SuppressWarnings(""deprecation"")","[{'comment': ""I would not prefer supressing deprecation. Especially while we have java's 6 month release cycle.. "", 'commenter': 'onderson'}]"
2452,components/camel-ftp/src/main/java/org/apache/camel/component/file/remote/SftpOperations.java,"@@ -1074,4 +1096,70 @@ public synchronized boolean sendSiteCommand(String command) throws GenericFileOp
         // is not implemented
         return true;
     }
+
+    /*
+     * adapted from com.jcraft.jsch.Util.createSocket(String, int, int)
+     *
+     * added possibility to specify the address of the local network interface, against the
+     * connection should bind
+     */
+    static Socket createSocketUtil(String host, int port, String bindAddress, int timeout) {
+        Socket socket=null;
+        if(timeout==0){
+          try{
+            socket=bindAddress == null ? new Socket(host, port) : new Socket(InetAddress.getByName(host), port, InetAddress.getByName(bindAddress), 0);
+            return socket;
+          }
+          catch(Exception e){
+            String message=e.toString();
+            if(e instanceof Throwable)
+              throw new RuntimeException(message, (Throwable)e);
+            throw new RuntimeException(message);
+          }
+        }
+        final String _host=host;
+        final int _port=port;
+        final Socket[] sockp=new Socket[1];
+        final Exception[] ee=new Exception[1];
+        String message="""";
+        Thread tmp=new Thread(new Runnable(){","[{'comment': 'why new runnable needed? can you please elaborate on it?', 'commenter': 'onderson'}, {'comment': 'Ohh i see, i found a similar piece of this. \r\nhttps://github.com/rtyley/jsch/blob/master/src/com/jcraft/jsch/Util.java\r\nI think this is public static method, no copy paste needed i guess. it may be imported. i did not fully check..', 'commenter': 'onderson'}, {'comment': ""I wanted to stay as close as possible to the original socket creation implementation. Therefore I copied the mentioned Util method (which has package protected access, btw) and added the possibility to specify the bind address to it (the original method does not support specifying the bind address). I've also added a comment on the method with a link to the original method.\r\n\r\nThe runnable here is used to implement the timeout behavior."", 'commenter': 'ffeisst'}]"
2452,components/camel-ftp/src/main/java/org/apache/camel/component/file/remote/SftpOperations.java,"@@ -1074,4 +1096,70 @@ public synchronized boolean sendSiteCommand(String command) throws GenericFileOp
         // is not implemented
         return true;
     }
+
+    /*
+     * adapted from com.jcraft.jsch.Util.createSocket(String, int, int)
+     *
+     * added possibility to specify the address of the local network interface, against the
+     * connection should bind
+     */
+    static Socket createSocketUtil(String host, int port, String bindAddress, int timeout) {
+        Socket socket=null;
+        if(timeout==0){
+          try{
+            socket=bindAddress == null ? new Socket(host, port) : new Socket(InetAddress.getByName(host), port, InetAddress.getByName(bindAddress), 0);
+            return socket;
+          }
+          catch(Exception e){
+            String message=e.toString();
+            if(e instanceof Throwable)
+              throw new RuntimeException(message, (Throwable)e);
+            throw new RuntimeException(message);
+          }
+        }
+        final String _host=host;
+        final int _port=port;
+        final Socket[] sockp=new Socket[1];
+        final Exception[] ee=new Exception[1];
+        String message="""";
+        Thread tmp=new Thread(new Runnable(){
+            public void run(){
+              sockp[0]=null;
+              try{
+                sockp[0]=bindAddress == null ? new Socket(_host, _port) : new Socket(InetAddress.getByName(_host), _port, InetAddress.getByName(bindAddress), 0);
+              }
+              catch(Exception e){
+                ee[0]=e;
+                if(sockp[0]!=null && sockp[0].isConnected()){
+                  try{
+                    sockp[0].close();
+                  }
+                  catch(Exception eee){}
+                }
+                sockp[0]=null;
+              }
+            }
+          });
+        tmp.setName(""Opening Socket ""+host);
+        tmp.start();
+        try{
+          tmp.join(timeout);
+          message=""timeout: "";
+        }
+        catch(java.lang.InterruptedException eee){
+        }
+        if(sockp[0]!=null && sockp[0].isConnected()){
+          socket=sockp[0];
+        }
+        else{
+          message+=""socket is not established"";
+          if(ee[0]!=null){
+            message=ee[0].toString();
+          }
+          tmp.interrupt();
+          tmp=null;
+          throw new RuntimeException(message, ee[0]);","[{'comment': 'RuntimeCamelException would be bettter..', 'commenter': 'onderson'}, {'comment': ""Thanks for the review, I've changed this accordingly."", 'commenter': 'ffeisst'}]"
2452,components/camel-ftp/src/main/java/org/apache/camel/component/file/remote/SftpOperations.java,"@@ -1074,4 +1097,64 @@ public synchronized boolean sendSiteCommand(String command) throws GenericFileOp
         // is not implemented
         return true;
     }
+
+    /*
+     * adapted from com.jcraft.jsch.Util.createSocket(String, int, int)
+     *
+     * added possibility to specify the address of the local network interface, against the
+     * connection should bind
+     */
+    static Socket createSocketUtil(final String host, final int port, final String bindAddress, final int timeout) {","[{'comment': 'what you do is reasonably good as the class and method has default access modifers.', 'commenter': 'onderson'}]"
2452,components/camel-ftp/src/main/java/org/apache/camel/component/file/remote/SftpOperations.java,"@@ -1074,4 +1097,64 @@ public synchronized boolean sendSiteCommand(String command) throws GenericFileOp
         // is not implemented
         return true;
     }
+
+    /*
+     * adapted from com.jcraft.jsch.Util.createSocket(String, int, int)
+     *
+     * added possibility to specify the address of the local network interface, against the
+     * connection should bind
+     */
+    static Socket createSocketUtil(final String host, final int port, final String bindAddress, final int timeout) {
+        Socket socket = null;
+        if (timeout == 0) {
+            try {
+                socket = bindAddress == null ? new Socket(host, port) : new Socket(InetAddress.getByName(host), port, InetAddress.getByName(bindAddress), 0);
+                return socket;
+            } catch (Exception e) {
+                String message = e.toString();
+                if (e instanceof Throwable) {
+                    throw new RuntimeCamelException(message, (Throwable)e);
+                }
+                throw new RuntimeCamelException(message);
+            }
+        }
+        final Socket[] sockp = new Socket[1];
+        final Exception[] ee = new Exception[1];
+        String message = """";
+        Thread tmp = new Thread(new Runnable() {
+            public void run() {
+                sockp[0] = null;
+                try {
+                    sockp[0] = bindAddress == null ? new Socket(host, port) : new Socket(InetAddress.getByName(host), port, InetAddress.getByName(bindAddress), 0);","[{'comment': 'not sure if null check for the new configuration option would be nicer before creating&setting socket factory. othwerwise new Socket(host,port) will be created which may affect as-is users unless provide unit test case. I guess test case would be nicer to showcase your requirement.', 'commenter': 'onderson'}]"
2452,components/camel-ftp/src/main/java/org/apache/camel/component/file/remote/SftpOperations.java,"@@ -1074,4 +1099,64 @@ public synchronized boolean sendSiteCommand(String command) throws GenericFileOp
         // is not implemented
         return true;
     }
+
+    /*
+     * adapted from com.jcraft.jsch.Util.createSocket(String, int, int)
+     *
+     * added possibility to specify the address of the local network interface, against the
+     * connection should bind
+     */
+    static Socket createSocketUtil(final String host, final int port, final String bindAddress, final int timeout) {
+        Socket socket = null;
+        if (timeout == 0) {
+            try {
+                socket = new Socket(InetAddress.getByName(host), port, InetAddress.getByName(bindAddress), 0);
+                return socket;
+            } catch (Exception e) {
+                String message = e.toString();
+                if (e instanceof Throwable) {
+                    throw new RuntimeCamelException(message, (Throwable)e);
+                }
+                throw new RuntimeCamelException(message);
+            }
+        }
+        final Socket[] sockp = new Socket[1];
+        final Exception[] ee = new Exception[1];
+        String message = """";
+        Thread tmp = new Thread(new Runnable() {
+            public void run() {
+                sockp[0] = null;
+                try {
+                    sockp[0] = new Socket(InetAddress.getByName(host), port, InetAddress.getByName(bindAddress), 0);
+                } catch (Exception e) {
+                    ee[0] = e;
+                    if (sockp[0] != null && sockp[0].isConnected()) {
+                        try {
+                            sockp[0].close();
+                        } catch (Exception eee) { }
+                    }
+                    sockp[0] = null;
+                }
+            }
+        });
+        tmp.setName(""Opening Socket "" + host);
+        tmp.start();
+        try {
+            tmp.join(timeout);
+            message = ""timeout: "";
+        } catch (java.lang.InterruptedException eee) {
+        }","[{'comment': 'Can we at least add here a debug log?', 'commenter': 'onderson'}]"
2452,components/camel-ftp/src/main/java/org/apache/camel/component/file/remote/SftpOperations.java,"@@ -1074,4 +1099,64 @@ public synchronized boolean sendSiteCommand(String command) throws GenericFileOp
         // is not implemented
         return true;
     }
+
+    /*
+     * adapted from com.jcraft.jsch.Util.createSocket(String, int, int)
+     *
+     * added possibility to specify the address of the local network interface, against the
+     * connection should bind
+     */
+    static Socket createSocketUtil(final String host, final int port, final String bindAddress, final int timeout) {
+        Socket socket = null;
+        if (timeout == 0) {
+            try {
+                socket = new Socket(InetAddress.getByName(host), port, InetAddress.getByName(bindAddress), 0);
+                return socket;
+            } catch (Exception e) {
+                String message = e.toString();
+                if (e instanceof Throwable) {
+                    throw new RuntimeCamelException(message, (Throwable)e);
+                }
+                throw new RuntimeCamelException(message);
+            }
+        }
+        final Socket[] sockp = new Socket[1];
+        final Exception[] ee = new Exception[1];
+        String message = """";
+        Thread tmp = new Thread(new Runnable() {
+            public void run() {
+                sockp[0] = null;
+                try {
+                    sockp[0] = new Socket(InetAddress.getByName(host), port, InetAddress.getByName(bindAddress), 0);
+                } catch (Exception e) {
+                    ee[0] = e;
+                    if (sockp[0] != null && sockp[0].isConnected()) {
+                        try {
+                            sockp[0].close();
+                        } catch (Exception eee) { }
+                    }
+                    sockp[0] = null;
+                }
+            }
+        });
+        tmp.setName(""Opening Socket "" + host);
+        tmp.start();
+        try {
+            tmp.join(timeout);
+            message = ""timeout: "";
+        } catch (java.lang.InterruptedException eee) {
+        }
+        if (sockp[0] != null && sockp[0].isConnected()) {
+            socket = sockp[0];
+        } else {
+            message += ""socket is not established"";
+            if (ee[0] != null) {
+                message = ee[0].toString();
+            }
+            tmp.interrupt();
+            tmp = null;
+            throw new RuntimeCamelException(message, ee[0]);","[{'comment': 'Should this not be IOException and then let the method have throws IOException', 'commenter': 'davsclaus'}]"
2452,components/camel-ftp/src/main/java/org/apache/camel/component/file/remote/SftpConfiguration.java,"@@ -69,6 +69,8 @@
     private LoggingLevel jschLoggingLevel = LoggingLevel.WARN;
     @UriParam(label = ""advanced"")
     private Integer bulkRequests;
+    @UriParam(label = ""bindAddress"")","[{'comment': 'I guess this option is more common, so we can remove the label', 'commenter': 'davsclaus'}]"
2465,components/camel-script/pom.xml,"@@ -78,23 +78,14 @@
             <version>${jython-version}</version>
             <scope>test</scope>
         </dependency>
-        <!-- for camel-script groovy upgrade requires rework as camel-itest-karaf fails to succeed ","[{'comment': 'not really. because karaf itests uses the specific version. Please see this line;\r\nhttps://github.com/apache/camel/blob/master/platforms/karaf/features/src/main/resources/features.xml#L1943', 'commenter': 'onderson'}]"
2476,components/camel-kafka/src/main/java/org/apache/camel/component/kafka/KafkaConfiguration.java,"@@ -403,6 +405,7 @@ public Properties createConsumerProperties() {
         addPropertyIfNotNull(props, ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, getAutoOffsetReset());
         addPropertyIfNotNull(props, ConsumerConfig.CONNECTIONS_MAX_IDLE_MS_CONFIG, getConnectionMaxIdleMs());
         addPropertyIfNotNull(props, ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, isAutoCommitEnable());
+        addPropertyIfNotNull(props, ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, isAutoCommitStateEnable());","[{'comment': 'This is wrong where you override the same option', 'commenter': 'davsclaus'}]"
2497,components/camel-zipkin/src/main/java/org/apache/camel/zipkin/ZipkinTracer.java,"@@ -535,6 +538,8 @@ private void createTracingForService(String pattern, String serviceName) {
 
     private Tracing newTracing(String serviceName) {
         return Tracing.newBuilder()
+            .currentTraceContext(ThreadLocalCurrentTraceContext.newBuilder()
+            .addScopeDecorator(MDCScopeDecorator.create()).build())        ","[{'comment': 'We should add an option to turn on|off this MDC scope decorator', 'commenter': 'davsclaus'}]"
2497,components/camel-zipkin/src/main/java/org/apache/camel/zipkin/ZipkinTracer.java,"@@ -583,9 +588,12 @@ private void clientRequest(Tracing brave, String serviceName, ExchangeSendingEve
             TraceContext context = span.context();
             String traceId = """" + context.traceIdString();
             String spanId = """" + context.spanId();
+            MDC.put(""traceId"", traceId);","[{'comment': 'Beware that some of the code you added with MDC.put are only executed if you have DEBUG logging, so you need to move this outside, or fix it in another way. This happens in a few places in this source file.', 'commenter': 'davsclaus'}, {'comment': ' @davsclaus , Thanks for the review comments, will do changes ', 'commenter': 'ramu11'}]"
2503,camel-core/src/main/java/org/apache/camel/converter/jaxp/XMLStreamReaderInputStream.java,"@@ -108,7 +108,9 @@ private int ensureBuffering(int size) throws IOException {
                                                   reader.getAttributeValue(i));
                         }
                         for (int i = 0; i < reader.getNamespaceCount(); i++) {
-                            writer.writeNamespace(reader.getNamespacePrefix(i), reader.getNamespaceURI(i));
+                            String namespacePrefix = reader.getNamespacePrefix(i);
+                            String namespaceURI = reader.getNamespaceURI(i);
+                            writer.writeNamespace(namespacePrefix == null ? """" : namespacePrefix, namespaceURI == null ? """" : namespaceURI);","[{'comment': 'Maybe it would be better to use the ObjectHelper isEmpty method', 'commenter': 'oscerd'}, {'comment': '@oscerd  Actually the fix is to check for NULL for Namespace and substitute with empty.\r\n\r\n', 'commenter': 'ramu11'}]"
2522,components/camel-iota/pom.xml,"@@ -0,0 +1,106 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!-- Licensed to the Apache Software Foundation (ASF) under one or more contributor 
+	license agreements. See the NOTICE file distributed with this work for additional 
+	information regarding copyright ownership. The ASF licenses this file to 
+	You under the Apache License, Version 2.0 (the ""License""); you may not use 
+	this file except in compliance with the License. You may obtain a copy of 
+	the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required 
+	by applicable law or agreed to in writing, software distributed under the 
+	License is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS 
+	OF ANY KIND, either express or implied. See the License for the specific 
+	language governing permissions and limitations under the License. -->
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
+	xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+	<modelVersion>4.0.0</modelVersion>
+
+	<parent>
+		<groupId>org.apache.camel</groupId>
+		<artifactId>components</artifactId>
+		<version>2.23.0-SNAPSHOT</version>
+	</parent>
+
+	<artifactId>camel-iota</artifactId>
+	<packaging>jar</packaging>
+	<name>Camel :: IOTA</name>
+	<description>Camel IOTA component</description>
+
+	<properties>
+		<camel.osgi.export.pkg>org.apache.camel.component.iota.*</camel.osgi.export.pkg>
+		<camel.osgi.export.service>org.apache.camel.spi.ComponentResolver;component=iota</camel.osgi.export.service>
+	</properties>
+
+	<repositories>
+		<repository>
+		    <id>spring-plugin</id>
+		    <url>http://repo.spring.io/plugins-release</url>
+		</repository>
+	</repositories>
+","[{'comment': 'Is this repository really needed?', 'commenter': 'oscerd'}, {'comment': 'Hello, official maven repo contains an old version 0.9.7. Into spring.io repo you can find latest version!', 'commenter': 'Fabryprog'}, {'comment': ""We can't rely only on Spring.io repository. For the moment it's fine, but once we have 0.9.10 on central, this repo must be removed."", 'commenter': 'oscerd'}]"
2522,components/camel-iota/src/main/java/org/apache/camel/component/iota/IOTAComponent.java,"@@ -0,0 +1,50 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.iota;
+
+import java.util.Map;
+
+import org.apache.camel.CamelContext;
+import org.apache.camel.Endpoint;
+import org.apache.camel.impl.DefaultComponent;
+
+/**
+ * Represents the component that manages {@link IOTAEndpoint}.
+ */
+public class IOTAComponent extends DefaultComponent {
+
+    public IOTAComponent() {
+        this(null);
+    }
+
+    public IOTAComponent(CamelContext context) {
+        super(context);
+    }
+
+    protected Endpoint createEndpoint(String uri, String remaining, Map<String, Object> parameters) throws Exception {
+        IOTAEndpoint endpoint = new IOTAEndpoint(uri, this);
+        setProperties(endpoint, parameters);
+
+        return endpoint;
+    }
+
+    @Override
+    protected void doShutdown() throws Exception {","[{'comment': 'Seems useless', 'commenter': 'oscerd'}]"
2522,parent/pom.xml,"@@ -399,6 +399,7 @@
     <jmh-version>1.21</jmh-version>
     <jodatime-bundle-version>1.6.2</jodatime-bundle-version>
     <jodatime2-bundle-version>2.10</jodatime2-bundle-version>
+    <jota-bundle-version>0.9.10</jota-bundle-version>","[{'comment': 'Is Jota Java library a bundle? Not sure.', 'commenter': 'oscerd'}, {'comment': ""No it's a lib sorry! It is a mistake"", 'commenter': 'Fabryprog'}]"
2522,components/camel-iota/src/main/java/org/apache/camel/component/iota/IOTAConstants.java,"@@ -0,0 +1,40 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.iota;
+
+import jota.utils.Constants;
+
+public final class IOTAConstants {
+
+    public static final String SEED_HEADER = ""CamelIOTASeed"";
+    public static final String VALUE_HEADER = ""CamelIOTAValue"";
+    public static final String TO_ADDRESS_HEADER = ""CamelIOTAToAddress"";
+    public static final String ADDRESS_INDEX_HEADER = ""CamelIOTAAddressIndex"";
+
+    protected static final int MIN_WEIGHT_MAGNITUDE = 14;
+    protected static final int DEPTH = 9;
+
+    protected static final int TAG_LENGTH = Constants.TAG_LENGTH;","[{'comment': 'do we really need this?', 'commenter': 'onderson'}, {'comment': 'I think so', 'commenter': 'Fabryprog'}]"
2532,components/camel-cdi/src/main/java/org/apache/camel/cdi/CdiCamelExtension.java,"@@ -244,6 +253,22 @@ private void afterBeanDiscovery(@Observes AfterBeanDiscovery abd, BeanManager ma
         // The set of extra Camel CDI beans
         Set<SyntheticBean<?>> extraBeans = new HashSet<>();
 
+        // Find DefaultContextCreateStrategy
+        Bean<?> defaultContextCreateStrategy = cdiBeans.stream()
+            .filter(hasType(DefaultContextCreateStrategy.class))
+            .findFirst()
+            .orElse(null);","[{'comment': '`orElseThrow` could be used. ', 'commenter': 'astefanutti'}, {'comment': 'Done.', 'commenter': 'jamesnetherton'}]"
2532,components/camel-cdi/src/main/java/org/apache/camel/cdi/ContextCreateStrategyInjectionTarget.java,"@@ -0,0 +1,55 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.cdi;
+
+import java.util.function.Consumer;
+
+import javax.enterprise.inject.spi.Bean;
+import javax.enterprise.inject.spi.BeanManager;
+
+import org.apache.camel.impl.DefaultCamelContext;
+import static org.apache.camel.cdi.BeanManagerHelper.getReference;
+import static org.apache.camel.cdi.CdiSpiHelper.getAnnotatedClassLoader;
+
+public class ContextCreateStrategyInjectionTarget<T> extends SyntheticInjectionTarget<T> {","[{'comment': 'The class visibility should be packaged private.', 'commenter': 'astefanutti'}]"
2532,components/camel-cdi/src/main/java/org/apache/camel/cdi/DefaultContextCreateStrategy.java,"@@ -0,0 +1,30 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.cdi;
+
+import org.apache.camel.CamelContext;
+
+/**
+ * Default {@link ContextCreateStrategy} which returns the result of the {@link ContextCreateAction}
+ */
+final class DefaultContextCreateStrategy implements ContextCreateStrategy {","[{'comment': 'The class visibility should be packaged private.', 'commenter': 'astefanutti'}, {'comment': 'Done.', 'commenter': 'jamesnetherton'}]"
2532,components/camel-cdi/src/main/java/org/apache/camel/cdi/SyntheticAnnotated.java,"@@ -31,28 +31,43 @@
 import static org.apache.camel.cdi.CdiSpiHelper.isAnnotationType;
 
 @Vetoed
-final class SyntheticAnnotated implements Annotated {
+public final class SyntheticAnnotated implements Annotated {","[{'comment': 'The class visibility should be left packaged private.', 'commenter': 'astefanutti'}]"
2532,components/camel-cdi/src/main/java/org/apache/camel/cdi/DelegateProducer.java,"@@ -44,6 +44,10 @@ public void dispose(T instance) {
         return delegate.getInjectionPoints();
     }
 
+    public Producer<T> getDelegate() {","[{'comment': 'The method visibility can be package private, or the field can be declared protected and the method removed.', 'commenter': 'astefanutti'}]"
2532,components/camel-cdi/src/main/java/org/apache/camel/cdi/CamelContextProducer.java,"@@ -64,7 +66,15 @@
 
     @Override
     public T produce(CreationalContext<T> ctx) {
-        T context = super.produce(ctx);
+        T context;
+
+        if (getDelegate() instanceof ContextCreateStrategyInjectionTarget) {","[{'comment': 'The `if` statement reveals an asymmetrical design. Either `ContextCreateStrategyInjectionTarget` is composed everywhere, or it can be removed and the logic always applied in `CamelContextProducer`.', 'commenter': 'astefanutti'}, {'comment': ""This is where my CDI knowledge started to run out...\r\n\r\nWhen a CamelContext is created via a producer field / method, we don't get a ContextCreateStrategyInjectionTarget. And I wasn't sure how to create a similar thing for producers."", 'commenter': 'jamesnetherton'}]"
2532,components/camel-cdi/src/main/java/org/apache/camel/cdi/CdiCamelExtension.java,"@@ -244,6 +253,22 @@ private void afterBeanDiscovery(@Observes AfterBeanDiscovery abd, BeanManager ma
         // The set of extra Camel CDI beans
         Set<SyntheticBean<?>> extraBeans = new HashSet<>();
 
+        // Find DefaultContextCreateStrategy
+        Bean<?> defaultContextCreateStrategy = cdiBeans.stream()
+            .filter(hasType(DefaultContextCreateStrategy.class))
+            .findFirst()
+            .orElse(null);
+
+        if (defaultContextCreateStrategy == null) {
+            abd.addDefinitionError(new IllegalStateException(""Unable to find DefaultContextCreateStrategy bean""));
+        }
+
+        // Use custom ContextCreateStrategy if one exists
+        contextCreateStrategy = cdiBeans.stream()","[{'comment': 'The logic of resolving `ContextCreateStrategy` could be encapsulated in `ContextCreateStrategyInjectionTarget` and the corresponding field removed.', 'commenter': 'astefanutti'}]"
2532,components/camel-cdi/src/main/java/org/apache/camel/cdi/SyntheticAnnotated.java,"@@ -83,4 +94,8 @@ public Type getBaseType() {
     public boolean isAnnotationPresent(Class<? extends Annotation> type) {
         return annotations.stream().anyMatch(isAnnotationType(type));
     }
+
+    public Class<?> getJavaClass() {","[{'comment': 'Nit: could be package private', 'commenter': 'astefanutti'}]"
2547,components/camel-reactive-streams/pom.xml,"@@ -94,6 +94,12 @@
             <artifactId>junit</artifactId>
             <scope>test</scope>
         </dependency>
+        <dependency>
+            <groupId>org.assertj</groupId>
+            <artifactId>assertj-core</artifactId>
+            <version>3.11.1</version>","[{'comment': 'I think there is a property for the assertj version', 'commenter': 'lburgazzoli'}, {'comment': 'yes assertj-version', 'commenter': 'oscerd'}]"
2549,components/camel-ribbon/src/test/java/org/apache/camel/component/ribbon/cloud/SpringBeanServiceCallRouteTest.java,"@@ -42,5 +42,13 @@ public void testServiceCallConfiguration() throws Exception {
         RibbonServiceLoadBalancer loadBalancer = (RibbonServiceLoadBalancer)processor.getLoadBalancer();
         Assert.assertTrue(loadBalancer.getServiceDiscovery() instanceof StaticServiceDiscovery);
     }
+    
+    protected String getFirstPort() {
+        return ""9092"";","[{'comment': 'What do you think about using `ServerSocket` to get an available port. Something like:\r\n\r\n```\r\n    public static int getAvailablePort(int min, int max) {\r\n        for (int i = min; i <= max; i++) {\r\n            try (ServerSocket socket = new ServerSocket(i)) {\r\n                return socket.getLocalPort();\r\n            } catch (Exception e) {\r\n                System.err.println(""Port "" + i + "" not available, trying next one"");\r\n                continue; // try next port\r\n            }\r\n        }\r\n        throw new IllegalStateException(""Can\'t find available network ports"");\r\n    }\r\n```\r\n\r\nIt would create more robust tests, whatever ports are taken on the machine.\r\n\r\nThoughts ?', 'commenter': 'jbonofre'}, {'comment': 'I guess there is also  AvailablePortFinder as part of the camel test suite. \r\nThe problem is that you need to reuse such ports in the xml, @apupier can you see what can be done ?', 'commenter': 'lburgazzoli'}, {'comment': 'it requires to modify the xml dynamically which is possible but it means playing with filesystem.\r\nI would prefer to merge this PR and report the improvement in CAMEL tracker to tackle it in a second iteration as it is already providing less chance to encounter the issue.\r\nIf not agree, can be done on top of this PR but it is not part of my top priorities so not sure when I will handle it.', 'commenter': 'apupier'}, {'comment': 'maybe you can use properties ?', 'commenter': 'lburgazzoli'}, {'comment': 'It makes sense to use properties in this case', 'commenter': 'oscerd'}]"
2554,components/camel-swagger-java/src/main/java/org/apache/camel/swagger/servlet/RestSwaggerServlet.java,"@@ -209,7 +209,7 @@ protected void doGet(HttpServletRequest request, HttpServletResponse response) t
                 if (!match) {
                     adapter.noContent();
                 } else {
-                    support.renderResourceListing(adapter, swaggerConfig, name, route, json, yaml, classResolver, new RestConfiguration());
+                    support.renderResourceListing(adapter, swaggerConfig, name, route, json, yaml, null, classResolver, new RestConfiguration());","[{'comment': 'I think this would lead to `NullPointerException` in `RestSwaggerSupport::setupXForwardedHeaders`. We do have the `HttpServletRequest` here so we could pass HTTP headers as a `Map<String, String>` to `support.renderResourceListing(...)`.', 'commenter': 'zregvart'}, {'comment': 'That makes sense. I will change that.', 'commenter': 'thiagolocatelli'}, {'comment': 'I just made Map<String, Object> to match the exchange.getIn().getHeaders, which returns <String, Object> instead of <String, String>.', 'commenter': 'thiagolocatelli'}, {'comment': 'I think you missed a call to `getHeaders(request)` here', 'commenter': 'zregvart'}]"
2554,components/camel-swagger-java/src/main/java/org/apache/camel/swagger/RestSwaggerSupport.java,"@@ -194,7 +200,7 @@ public void initSwagger(BeanConfig swaggerConfig, Map<String, Object> config) {
     }
 
     public void renderResourceListing(RestApiResponseAdapter response, BeanConfig swaggerConfig, String contextId, String route, boolean json, boolean yaml,
-                                      ClassResolver classResolver, RestConfiguration configuration) throws Exception {
+    		Exchange exchange, ClassResolver classResolver, RestConfiguration configuration) throws Exception {","[{'comment': 'Perhaps instead of `Exchange` we could pass in a `Map<String, String>` of headers?', 'commenter': 'zregvart'}]"
2554,components/camel-swagger-java/src/main/java/org/apache/camel/swagger/RestSwaggerSupport.java,"@@ -344,5 +352,42 @@ private static void setupCorsHeaders(RestApiResponseAdapter response, Map<String
         response.setHeader(""Access-Control-Allow-Headers"", allowHeaders);
         response.setHeader(""Access-Control-Max-Age"", maxAge);
     }
+    
+    /**
+     * 
+     * @param swagger
+     * @param exchange
+     */
+	private void setupXForwardedHeaders(Swagger swagger, Exchange exchange) {","[{'comment': 'Perhaps: `setupXForwardedHeaders(Swagger swagger, Map<String, String> headers)`', 'commenter': 'zregvart'}]"
2554,components/camel-swagger-java/src/main/java/org/apache/camel/swagger/RestSwaggerSupport.java,"@@ -345,4 +353,36 @@ private static void setupCorsHeaders(RestApiResponseAdapter response, Map<String
         response.setHeader(""Access-Control-Max-Age"", maxAge);
     }
 
+    private void setupXForwardedHeaders(Swagger swagger, Map<String, Object> headers) {
+
+        String host = (String) headers.get(HEADER_HOST);
+        if(host != null && host.length() > 0) {
+            swagger.setHost(host);
+        }
+
+        String forwardedPrefix = (String) headers.get(HEADER_X_FORWARDED_PREFIX);
+        if (forwardedPrefix != null && forwardedPrefix.length() > 0) {
+            swagger.setBasePath(""/"" + forwardedPrefix.replace(""/"", """") + swagger.getBasePath());","[{'comment': 'I think this might lead to issues if the `forwardedPrefix` is `""a/b""` then `basePath` would be set to `""ab""` which is probably not what we want.\r\n\r\nPerhaps I\'m not following the logic here is the idea to have the resulting `basePath` equal `X-Forwarded-Prefix` + `basePath`?\r\n\r\nPerhaps we could use something like:\r\n\r\n```java\r\nString prefixedBasePath = ""/"" + URISupport.stripPrefix(forwardedPrefix, ""/"") + ""/"" URISupport.stripPrefix(swagger.getBasePath(), ""/"");\r\n```', 'commenter': 'zregvart'}]"
2554,components/camel-swagger-java/src/main/java/org/apache/camel/swagger/RestSwaggerSupport.java,"@@ -345,4 +353,36 @@ private static void setupCorsHeaders(RestApiResponseAdapter response, Map<String
         response.setHeader(""Access-Control-Max-Age"", maxAge);
     }
 
+    private void setupXForwardedHeaders(Swagger swagger, Map<String, Object> headers) {
+
+        String host = (String) headers.get(HEADER_HOST);
+        if(host != null && host.length() > 0) {","[{'comment': 'nitpick, could use:\r\n\r\n```java\r\nif (ObjectHelper.isNotEmpty(host)) {\r\n```', 'commenter': 'zregvart'}, {'comment': 'it should work, the prefix could also come with ""/"" at the end, I will apply this suggestion.', 'commenter': 'thiagolocatelli'}]"
2554,components/camel-swagger-java/src/main/java/org/apache/camel/swagger/RestSwaggerSupport.java,"@@ -345,4 +353,36 @@ private static void setupCorsHeaders(RestApiResponseAdapter response, Map<String
         response.setHeader(""Access-Control-Max-Age"", maxAge);
     }
 
+    private void setupXForwardedHeaders(Swagger swagger, Map<String, Object> headers) {
+
+        String host = (String) headers.get(HEADER_HOST);
+        if(host != null && host.length() > 0) {
+            swagger.setHost(host);
+        }
+
+        String forwardedPrefix = (String) headers.get(HEADER_X_FORWARDED_PREFIX);
+        if (forwardedPrefix != null && forwardedPrefix.length() > 0) {","[{'comment': 'nitpick, could use:\r\n\r\n```java\r\nif (ObjectHelper.isNotEmpty(forwardedPrefix)) {\r\n```', 'commenter': 'zregvart'}]"
2554,components/camel-swagger-java/src/main/java/org/apache/camel/swagger/RestSwaggerSupport.java,"@@ -345,4 +353,36 @@ private static void setupCorsHeaders(RestApiResponseAdapter response, Map<String
         response.setHeader(""Access-Control-Max-Age"", maxAge);
     }
 
+    private void setupXForwardedHeaders(Swagger swagger, Map<String, Object> headers) {
+
+        String host = (String) headers.get(HEADER_HOST);
+        if(host != null && host.length() > 0) {
+            swagger.setHost(host);
+        }
+
+        String forwardedPrefix = (String) headers.get(HEADER_X_FORWARDED_PREFIX);
+        if (forwardedPrefix != null && forwardedPrefix.length() > 0) {
+            swagger.setBasePath(""/"" + forwardedPrefix.replace(""/"", """") + swagger.getBasePath());
+        }
+
+        String forwardedHost = (String) headers.get(HEADER_X_FORWARDED_HOST);
+        if(forwardedHost != null && forwardedHost.length() > 0) {","[{'comment': 'nitpick, could use:\r\n\r\n```java\r\nif (ObjectHelper.isNotEmpty(forwardedHost)) {\r\n```', 'commenter': 'zregvart'}]"
2554,components/camel-swagger-java/src/main/java/org/apache/camel/swagger/RestSwaggerSupport.java,"@@ -345,4 +353,36 @@ private static void setupCorsHeaders(RestApiResponseAdapter response, Map<String
         response.setHeader(""Access-Control-Max-Age"", maxAge);
     }
 
+    private void setupXForwardedHeaders(Swagger swagger, Map<String, Object> headers) {
+
+        String host = (String) headers.get(HEADER_HOST);
+        if(host != null && host.length() > 0) {
+            swagger.setHost(host);
+        }
+
+        String forwardedPrefix = (String) headers.get(HEADER_X_FORWARDED_PREFIX);
+        if (forwardedPrefix != null && forwardedPrefix.length() > 0) {
+            swagger.setBasePath(""/"" + forwardedPrefix.replace(""/"", """") + swagger.getBasePath());
+        }
+
+        String forwardedHost = (String) headers.get(HEADER_X_FORWARDED_HOST);
+        if(forwardedHost != null && forwardedHost.length() > 0) {
+            swagger.setHost(forwardedHost);
+        }
+
+        String proto = (String) headers.get(HEADER_X_FORWARDED_PROTO);
+        if(proto != null && proto.length() > 0) {","[{'comment': 'nitpick, could use:\r\n\r\n```java\r\nif (ObjectHelper.isNotEmpty(proto)) {\r\n```', 'commenter': 'zregvart'}]"
2554,components/camel-swagger-java/src/main/java/org/apache/camel/swagger/RestSwaggerSupport.java,"@@ -345,4 +353,36 @@ private static void setupCorsHeaders(RestApiResponseAdapter response, Map<String
         response.setHeader(""Access-Control-Max-Age"", maxAge);
     }
 
+    private void setupXForwardedHeaders(Swagger swagger, Map<String, Object> headers) {
+
+        String host = (String) headers.get(HEADER_HOST);
+        if(host != null && host.length() > 0) {
+            swagger.setHost(host);
+        }
+
+        String forwardedPrefix = (String) headers.get(HEADER_X_FORWARDED_PREFIX);
+        if (forwardedPrefix != null && forwardedPrefix.length() > 0) {
+            swagger.setBasePath(""/"" + forwardedPrefix.replace(""/"", """") + swagger.getBasePath());
+        }
+
+        String forwardedHost = (String) headers.get(HEADER_X_FORWARDED_HOST);
+        if(forwardedHost != null && forwardedHost.length() > 0) {
+            swagger.setHost(forwardedHost);
+        }
+
+        String proto = (String) headers.get(HEADER_X_FORWARDED_PROTO);
+        if(proto != null && proto.length() > 0) {
+            String[] schemes = proto.split("","");
+            List<Scheme> schs = new ArrayList<>();
+            for(String scheme : schemes) {
+                String trimmedScheme = scheme.trim();
+                schs.add(Scheme.forValue(trimmedScheme));
+            }
+            swagger.setSchemes(schs);
+        }
+        else {
+            swagger.setSchemes(null);","[{'comment': ""Do we want to set the `scheme` if there's no `X-Forwarded-Proto` header given?"", 'commenter': 'zregvart'}, {'comment': 'In this case the default is not return anything when proto is not given.', 'commenter': 'thiagolocatelli'}]"
2581,components/camel-spring-boot/src/main/java/org/apache/camel/spring/boot/RoutesCollector.java,"@@ -84,7 +84,8 @@ public void onApplicationEvent(ContextRefreshedEvent event) {
         CamelContext camelContext = applicationContext.getBean(CamelContext.class);
 
         // only add and start Camel if its stopped (initial state)
-        if (camelContext.getStatus().isStopped()) {
+        if (((ContextRefreshedEvent) event).getApplicationContext().getId().equals(this.applicationContext.getId())","[{'comment': 'According to [the documentation](https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/context/ApplicationContext.html#getId--) `ApplicationContext::getId` can return `null`, this would result in `NullPointerException` thrown from this line.\r\n\r\n`event` is already a `ContextRefreshedEvent` no need to cast to it.\r\n\r\n```suggestion\r\n        if (event.getApplicationContext() == this.applicationContext)\r\n```', 'commenter': 'zregvart'}]"
2581,components/camel-spring/src/main/java/org/apache/camel/spring/SpringCamelContext.java,"@@ -159,7 +159,7 @@ public void stop() {
     public void onApplicationEvent(ApplicationEvent event) {
         LOG.debug(""onApplicationEvent: {}"", event);
 
-        if (event instanceof ContextRefreshedEvent) {
+        if (event instanceof ContextRefreshedEvent && ((ContextRefreshedEvent) event).getApplicationContext().getId().equals(this.applicationContext.getId())) {","[{'comment': 'We should watch out for `ApplicationContext::getId` returning `null`\r\n```suggestion\r\n        if (event instanceof ContextRefreshedEvent && ((ContextRefreshedEvent) event).getApplicationContext() == this.applicationContext) {\r\n```', 'commenter': 'zregvart'}]"
2607,components/camel-slack/src/test/java/org/apache/camel/component/slack/SlackConsumerTest.java,"@@ -18,27 +18,70 @@
 
 import org.apache.camel.builder.RouteBuilder;
 import org.apache.camel.component.mock.MockEndpoint;
+import org.apache.camel.component.slack.helper.SlackMessage;
 import org.apache.camel.test.junit4.CamelTestSupport;
-import org.junit.Ignore;
+import org.apache.http.HttpResponse;
+import org.apache.http.HttpStatus;
+import org.apache.http.client.HttpClient;
+import org.apache.http.client.methods.HttpPost;
+import org.apache.http.entity.StringEntity;
+import org.apache.http.impl.client.HttpClients;
+
+import org.junit.Assert;
+import org.junit.Assume;
+import org.junit.Before;
 import org.junit.Test;
 
-@Ignore
+import org.hamcrest.CoreMatchers;
+
+import java.io.IOException;
+
 public class SlackConsumerTest extends CamelTestSupport {
 
+    private String token;
+    private String hook;
+
+    @Before
+    public void setUp() throws Exception {
+        token = System.getProperty(""SLACK_TOKEN"");
+        hook = System.getProperty(""SLACK_HOOK"", ""https://hooks.slack.com/services/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"");","[{'comment': 'Where that hook come from?', 'commenter': 'oscerd'}, {'comment': 'It is reused from previous version of test. See https://github.com/apache/camel/blob/master/components/camel-slack/src/test/resources/OSGI-INF/blueprint/blueprint.xml#L23', 'commenter': 'bouskaJ'}]"
2616,platforms/spring-boot/components-starter/camel-ipfs-starter/src/main/java/org/apache/camel/component/ipfs/springboot/IPFSComponentConfiguration.java,"@@ -0,0 +1,55 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.ipfs.springboot;
+
+import javax.annotation.Generated;
+import org.apache.camel.spring.boot.ComponentConfigurationPropertiesCommon;
+import org.springframework.boot.context.properties.ConfigurationProperties;
+
+/**
+ * The camel-xchange component provide access to many bitcoin and altcoin","[{'comment': 'Looks like copy/paste from other component', 'commenter': 'dmvolod'}, {'comment': 'Removed springboot stuff from the initial commit', 'commenter': 'tdiesler'}]"
2616,components/camel-ipfs/src/main/java/org/apache/camel/component/ipfs/IPFSEndpoint.java,"@@ -0,0 +1,107 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.ipfs;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.nio.file.Path;
+import java.util.List;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.Future;
+
+import org.apache.camel.Consumer;
+import org.apache.camel.Processor;
+import org.apache.camel.Producer;
+import org.apache.camel.component.ipfs.IPFSConfiguration.IPFSCommand;
+import org.apache.camel.impl.DefaultEndpoint;
+import org.apache.camel.spi.UriEndpoint;
+import org.apache.camel.spi.UriParam;
+
+import io.nessus.ipfs.IPFSClient;
+
+/**
+ * The camel-xchange component provide access to many bitcoin and altcoin exchanges for trading and accessing market data.","[{'comment': 'Looks like copy/paste from other component', 'commenter': 'dmvolod'}, {'comment': 'Thanks for spotting this\r\n""The camel-ipfs component provides access to the Interplanetary File System (IPFS)""', 'commenter': 'tdiesler'}]"
2616,components/camel-ipfs/src/main/docs/ipfs-component.adoc,"@@ -0,0 +1,93 @@
+[[ipfs-component]]
+== IPFS Component
+
+*Available as of Camel version 2.23*
+
+The *ipfs:* component provides access to the Interplanetary File System https://ipfs.io/[(IPFS)].
+
+Maven users will need to add the following dependency to their `pom.xml`
+for this component:
+
+[source,xml]
+------------------------------------------------------------
+<dependency>
+    <groupId>org.apache.camel</groupId>
+    <artifactId>camel-ipfs</artifactId>
+    <version>x.x.x</version>
+    <!-- use the same version as your Camel core version -->
+</dependency>
+------------------------------------------------------------
+
+### URI format
+
+[source,java]
+---------------------------------
+ipfs://cmd?options
+---------------------------------
+
+### Options
+
+// component options: START
+The IPFS component has no options.
+// component options: END
+
+// endpoint options: START
+The IPFS endpoint is configured using URI syntax:
+
+----
+ipfs:cmd
+----
+
+with the following path and query parameters:
+
+==== Path Parameters (3 parameters):
+
+
+[width=""100%"",cols=""2,5,^1,2"",options=""header""]
+|===
+| Name | Description | Default | Type
+| *ipfsCmd* | The ipfs command |  | String
+| *ipfsHost* | The ipfs host |  | String
+| *ipfsPort* | The ipfs port |  | int
+|===
+
+
+==== Query Parameters (2 parameters):
+
+
+[width=""100%"",cols=""2,5,^1,2"",options=""header""]
+|===
+| Name | Description | Default | Type
+| *outdir* (producer) | The ipfs output directory |  | Path
+| *synchronous* (advanced) | Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported). | false | boolean
+|===
+// endpoint options: END
+// spring-boot-auto-configure options: START
+=== Spring Boot Auto-Configuration
+
+
+The component supports 2 options, which are listed below.
+
+[width=""100%"",cols=""2,5,^1,2"",options=""header""]
+|===
+| Name | Description | Default | Type
+| *camel.component.ipfs.enabled* | Whether to enable auto configuration of the ipfs component. This is enabled by default. |  | Boolean
+| *camel.component.ipfs.resolve-property-placeholders* | Whether the component should resolve property placeholders on itself when starting. Only properties which are of String type can use property placeholders. | true | Boolean
+|===
+// spring-boot-auto-configure options: END
+
+
+### Message Headers
+
+[TODO]
+
+### Samples
+
+In this sample we find the current Bitcoin market price in USDT:","[{'comment': 'Looks like copy/paste from other component', 'commenter': 'dmvolod'}, {'comment': '""In this sample we add a file to IPFS, get a file from IPFS and finally access the content of an IPFS file. ""\r\n', 'commenter': 'tdiesler'}]"
2616,components/camel-ipfs/src/main/java/org/apache/camel/component/ipfs/IPFSEndpoint.java,"@@ -0,0 +1,107 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.ipfs;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.nio.file.Path;
+import java.util.List;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.Future;
+
+import org.apache.camel.Consumer;
+import org.apache.camel.Processor;
+import org.apache.camel.Producer;
+import org.apache.camel.component.ipfs.IPFSConfiguration.IPFSCommand;
+import org.apache.camel.impl.DefaultEndpoint;
+import org.apache.camel.spi.UriEndpoint;
+import org.apache.camel.spi.UriParam;
+
+import io.nessus.ipfs.IPFSClient;
+
+/**
+ * The camel-xchange component provide access to many bitcoin and altcoin exchanges for trading and accessing market data.
+ */
+@UriEndpoint(firstVersion = ""2.23.0"", scheme = ""ipfs"", title = ""IPFS"", syntax = "":cmd"", producerOnly = true, label = ""file,ipfs"")","[{'comment': 'It would be nice to use host and port parameters in the syntax for better support in the cloud ready env (host:port combination ~> service in k8s or openshift) without default values', 'commenter': 'dmvolod'}, {'comment': 'Like so?\r\n\r\n```\r\nsyntax = "":cmd?host=127.0.0.1&port=5001""\r\n```', 'commenter': 'tdiesler'}, {'comment': ""@tdiesler , sorry, I'm missing that UriPath's parameters are correct and ready for cloud native apps, but syntax could be  'ipfs:host:port:cmd'.\r\nMay be remove default values from host and port to prevent confusing."", 'commenter': 'dmvolod'}]"
2616,components/camel-ipfs/src/test/resources/log4j2.properties,"@@ -0,0 +1,28 @@
+## ---------------------------------------------------------------------------
+## Licensed to the Apache Software Foundation (ASF) under one or more
+## contributor license agreements.  See the NOTICE file distributed with
+## this work for additional information regarding copyright ownership.
+## The ASF licenses this file to You under the Apache License, Version 2.0
+## (the ""License""); you may not use this file except in compliance with
+## the License.  You may obtain a copy of the License at
+##
+##      http://www.apache.org/licenses/LICENSE-2.0
+##
+## Unless required by applicable law or agreed to in writing, software
+## distributed under the License is distributed on an ""AS IS"" BASIS,
+## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+## See the License for the specific language governing permissions and
+## limitations under the License.
+## ---------------------------------------------------------------------------
+
+appender.file.type = File
+appender.file.name = file
+appender.file.fileName = target/camel-xchange-test.log","[{'comment': 'Here it should be camel-ipfs-test.log', 'commenter': 'oscerd'}, {'comment': 'done', 'commenter': 'tdiesler'}]"
2631,components/camel-websocket-jsr356/src/main/java/org/apache/camel/jsr356/JSR356Producer.java,"@@ -0,0 +1,90 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.jsr356;
+
+import static java.util.Optional.ofNullable;
+
+import java.io.IOException;
+import java.net.URI;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.CompletionStage;
+import java.util.function.BiConsumer;
+
+import javax.websocket.ClientEndpointConfig;
+import javax.websocket.Session;
+
+import org.apache.camel.AsyncCallback;
+import org.apache.camel.Exchange;
+import org.apache.camel.impl.DefaultAsyncProducer;
+
+public class JSR356Producer extends DefaultAsyncProducer {
+    private final int sessionCount;
+    private ClientSessions manager;
+    private BiConsumer<Exchange, AsyncCallback> onExchange;
+
+    JSR356Producer(final JSR356Endpoint jsr356Endpoint, final int sessionCount) {
+        super(jsr356Endpoint);
+        this.sessionCount = sessionCount;
+    }
+
+    @Override
+    public JSR356Endpoint getEndpoint() {
+        return JSR356Endpoint.class.cast(super.getEndpoint());
+    }
+
+    @Override
+    public boolean process(final Exchange exchange, final AsyncCallback callback) {
+        final Session session = exchange.getIn().getHeader(JSR356Constants.SESSION, Session.class);
+        if (session != null && exchange.getIn().getHeader(JSR356Constants.USE_INCOMING_SESSION, false, Boolean.class)) {
+            synchronized (session) {
+                doSend(exchange, session);
+            }
+        } else {
+            onExchange.accept(exchange, callback);
+        }
+        return true;
+    }
+
+    @Override
+    protected void doStart() throws Exception {
+        super.doStart();
+        final String endpointKey = getEndpoint().getEndpointUri().substring(""jsr356://"".length());
+        if (!endpointKey.contains(""://"")) { // we act as a client in all cases here
+            throw new IllegalArgumentException(""You should pass a client uri"");
+        }
+        final ClientEndpointConfig.Builder clientConfig = ClientEndpointConfig.Builder.create();
+        manager = new ClientSessions(sessionCount, URI.create(endpointKey), clientConfig.build(), null);
+        manager.prepare();
+        onExchange = (ex, cb) -> manager.execute(session -> doSend(ex, session));
+    }
+
+    private CompletionStage<Object> doSend(final Exchange ex, final Session session) {
+        final CompletableFuture<Object> future = new CompletableFuture<>();","[{'comment': ""what's the role of this completable future ?"", 'commenter': 'lburgazzoli'}, {'comment': 'dropped it, originally I thought using it to integrate with AsyncCallback but was not needed', 'commenter': 'rmannibucau'}]"
2631,components/camel-websocket-jsr356/src/main/java/org/apache/camel/jsr356/JSR356WebSocketComponent.java,"@@ -0,0 +1,100 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.jsr356;
+
+import static java.util.Optional.ofNullable;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.nio.ByteBuffer;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+
+import javax.websocket.Session;
+import javax.websocket.server.ServerContainer;
+
+import org.apache.camel.Endpoint;
+import org.apache.camel.impl.DefaultComponent;
+import org.apache.camel.spi.Metadata;
+
+public class JSR356WebSocketComponent extends DefaultComponent {
+    // didn't find a better way to handle that unless we can assume the CamelContext is in the ServletContext
+    private static final Map<String, ContextBag> SERVER_CONTAINERS = new ConcurrentHashMap<>();
+
+    @Metadata(label = ""sessionCount"")
+    protected int sessionCount;
+
+    @Override
+    protected Endpoint createEndpoint(final String uri, final String remaining, final Map<String, Object> parameters) {
+        return new JSR356Endpoint(this, uri);
+    }
+
+    public void sendMessage(final Session session, final Object message) throws IOException {
+        synchronized (session) {
+            // todo: handle async?
+            if (String.class.isInstance(message)) {
+                session.getBasicRemote().sendText(String.valueOf(message));
+            } else if (ByteBuffer.class.isInstance(message)) {
+                session.getBasicRemote().sendBinary(ByteBuffer.class.cast(message));
+            } else if (InputStream.class.isInstance(message)) {
+                int read;
+                final InputStream in = InputStream.class.cast(message);
+                final byte[] buffer = new byte[8192]; // todo: config
+                final OutputStream out = session.getBasicRemote().getSendStream();
+                while ((read = in.read(buffer)) >= 0) {
+                    out.write(buffer, 0, read);
+                }","[{'comment': ""I guess you can reuse some utilities from camel's org.apache.camel.util.IOHelper"", 'commenter': 'lburgazzoli'}]"
2631,components/camel-websocket-jsr356/src/main/java/org/apache/camel/jsr356/JSR356WebSocketComponent.java,"@@ -0,0 +1,100 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.jsr356;
+
+import static java.util.Optional.ofNullable;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.nio.ByteBuffer;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+
+import javax.websocket.Session;
+import javax.websocket.server.ServerContainer;
+
+import org.apache.camel.Endpoint;
+import org.apache.camel.impl.DefaultComponent;
+import org.apache.camel.spi.Metadata;
+
+public class JSR356WebSocketComponent extends DefaultComponent {
+    // didn't find a better way to handle that unless we can assume the CamelContext is in the ServletContext
+    private static final Map<String, ContextBag> SERVER_CONTAINERS = new ConcurrentHashMap<>();
+
+    @Metadata(label = ""sessionCount"")
+    protected int sessionCount;
+
+    @Override
+    protected Endpoint createEndpoint(final String uri, final String remaining, final Map<String, Object> parameters) {
+        return new JSR356Endpoint(this, uri);
+    }
+
+    public void sendMessage(final Session session, final Object message) throws IOException {","[{'comment': 'looks like a static method', 'commenter': 'lburgazzoli'}, {'comment': 'updated', 'commenter': 'rmannibucau'}]"
2631,components/camel-websocket-jsr356/src/main/java/org/apache/camel/jsr356/JSR356Endpoint.java,"@@ -0,0 +1,75 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.jsr356;
+
+import org.apache.camel.Consumer;
+import org.apache.camel.Processor;
+import org.apache.camel.Producer;
+import org.apache.camel.impl.DefaultEndpoint;
+import org.apache.camel.spi.UriEndpoint;
+import org.apache.camel.spi.UriParam;
+import org.apache.camel.spi.UriPath;
+
+@UriEndpoint(
+        firstVersion = ""2.23.0"", scheme = ""jsr356"", title = ""Javax Websocket"",
+        syntax = ""jsr356:/resourceUri"", consumerClass = JSR356Consumer.class, label = ""jsr356"")","[{'comment': 'jsr356 does not looks very nice as component scheme - IMHO', 'commenter': 'lburgazzoli'}, {'comment': 'Agree but websocket is taken, websocketx? Any good idea?', 'commenter': 'rmannibucau'}, {'comment': 'Yeah, or websocket-jsr356', 'commenter': 'oscerd'}, {'comment': 'or `websocket-java`?', 'commenter': 'nicolaferraro'}, {'comment': ""websocket-javax would be probably better than java which does not reference a particular impl but `websocket-jsr356` is at least explicit, let's try to make it merged/mergable with it - to avoid to keep changing the scheme - and once we all agree on the code we can revise it probably. Does it work for everybody this way?"", 'commenter': 'rmannibucau'}, {'comment': 'absolutely. There is still some work to do on adding the component to kit, but we may work on that after when it will be merged on master after the 2.23.0 release', 'commenter': 'oscerd'}]"
2635,components/camel-jgroups-raft/src/main/docs/jgroups-raft-component.adoc,"@@ -0,0 +1,195 @@
+[[jgroups-raft-component]]
+== JGroups raft Component
+*Available as of Camel version 2.24*","[{'comment': 'multiple ""available as of camel...."" doc lines. ', 'commenter': 'onderson'}, {'comment': 'Yeah better to remove the line and regen', 'commenter': 'oscerd'}]"
2635,components/camel-jgroups-raft/src/main/java/org/apache/camel/component/jgroups/raft/JGroupsRaftEndpoint.java,"@@ -0,0 +1,231 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.jgroups.raft;
+
+import java.util.Map;
+import java.util.concurrent.atomic.AtomicInteger;
+
+import org.apache.camel.Component;
+import org.apache.camel.Consumer;
+import org.apache.camel.Exchange;
+import org.apache.camel.Processor;
+import org.apache.camel.Producer;
+import org.apache.camel.component.jgroups.raft.utils.NopStateMachine;
+import org.apache.camel.impl.DefaultEndpoint;
+import org.apache.camel.spi.Metadata;
+import org.apache.camel.spi.UriEndpoint;
+import org.apache.camel.spi.UriParam;
+import org.apache.camel.spi.UriPath;
+import org.jgroups.JChannel;
+import org.jgroups.protocols.raft.StateMachine;
+import org.jgroups.raft.RaftHandle;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * The jgroups component provides exchange of messages between Camel and JGroups clusters.
+ */
+@UriEndpoint(firstVersion = ""2.23.0"", scheme = ""jgroups-raft"", title = ""JGroups raft"", syntax = ""jgroup-sraft:clusterName"", consumerClass = JGroupsRaftConsumer.class, label = ""clustering,messaging"")
+public class JGroupsRaftEndpoint extends DefaultEndpoint {
+    private static final Logger LOG = LoggerFactory.getLogger(JGroupsRaftEndpoint.class);
+
+    public static final String DEFAULT_JGROUPSRAFT_CONFIG = ""raft.xml"";","[{'comment': 'I would go ..Constants or something else.', 'commenter': 'onderson'}, {'comment': 'Probably you may also put all the constants in a constants file', 'commenter': 'oscerd'}]"
2635,components/readme.adoc,"@@ -2,7 +2,11 @@ Components
 ^^^^^^^^^^
 
 // components: START
+<<<<<<< HEAD","[{'comment': 'looks like conflict resolution left-over', 'commenter': 'onderson'}]"
2635,components/camel-jgroups-raft/pom.xml,"@@ -0,0 +1,101 @@
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one or more
+    contributor license agreements.  See the NOTICE file distributed with
+    this work for additional information regarding copyright ownership.
+    The ASF licenses this file to You under the Apache License, Version 2.0
+    (the ""License""); you may not use this file except in compliance with
+    the License.  You may obtain a copy of the License at
+
+         http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an ""AS IS"" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+
+-->
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"">
+
+    <modelVersion>4.0.0</modelVersion>
+
+    <parent>
+        <groupId>org.apache.camel</groupId>
+        <artifactId>components</artifactId>
+        <version>2.23.0-SNAPSHOT</version>
+    </parent>","[{'comment': 'Here probably it must be 2.24.0', 'commenter': 'oscerd'}]"
2635,docs/user-manual/en/SUMMARY.md,"@@ -481,6 +483,7 @@
 	* [Spring Cloud Consul](spring-cloud-consul.adoc)
 	* [Spring Cloud Netflix](spring-cloud-netflix.adoc)
 	* [Spring Cloud Zookeeper](spring-cloud-zookeeper.adoc)
+	* [Spring DM](spring-dm.adoc)","[{'comment': 'Probably you need to Regen after a git clean -d -f', 'commenter': 'oscerd'}]"
2635,apache-camel/src/main/descriptors/common-bin.xml,"@@ -152,6 +152,7 @@
         <include>org.apache.camel:camel-jetty</include>
         <include>org.apache.camel:camel-jetty9</include>
         <include>org.apache.camel:camel-jgroups</include>
+        <include>org.apache.camel:camel-jgroups-raft</include>","[{'comment': 'Here you need to add the starter too', 'commenter': 'oscerd'}]"
2635,components/camel-jgroups-raft/src/main/java/org/apache/camel/component/jgroups/raft/JGroupsRaftEndpoint.java,"@@ -0,0 +1,231 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.jgroups.raft;
+
+import java.util.Map;
+import java.util.concurrent.atomic.AtomicInteger;
+
+import org.apache.camel.Component;
+import org.apache.camel.Consumer;
+import org.apache.camel.Exchange;
+import org.apache.camel.Processor;
+import org.apache.camel.Producer;
+import org.apache.camel.component.jgroups.raft.utils.NopStateMachine;
+import org.apache.camel.impl.DefaultEndpoint;
+import org.apache.camel.spi.Metadata;
+import org.apache.camel.spi.UriEndpoint;
+import org.apache.camel.spi.UriParam;
+import org.apache.camel.spi.UriPath;
+import org.jgroups.JChannel;
+import org.jgroups.protocols.raft.StateMachine;
+import org.jgroups.raft.RaftHandle;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * The jgroups component provides exchange of messages between Camel and JGroups clusters.
+ */
+@UriEndpoint(firstVersion = ""2.23.0"", scheme = ""jgroups-raft"", title = ""JGroups raft"", syntax = ""jgroup-sraft:clusterName"", consumerClass = JGroupsRaftConsumer.class, label = ""clustering,messaging"")","[{'comment': ""Should be 'jgroups-raft' instead of 'jgroup-sraft' in syntax."", 'commenter': 'dmvolod'}]"
2635,components/camel-jgroups-raft/src/main/java/org/apache/camel/component/jgroups/raft/cluster/JGroupsRaftClusterView.java,"@@ -0,0 +1,149 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.jgroups.raft.cluster;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Optional;
+
+import org.apache.camel.cluster.CamelClusterMember;
+import org.apache.camel.cluster.CamelClusterService;
+import org.apache.camel.component.jgroups.raft.JGroupsRaftEndpoint;
+import org.apache.camel.component.jgroups.raft.utils.NopStateMachine;
+import org.apache.camel.impl.cluster.AbstractCamelClusterView;
+import org.jgroups.JChannel;
+import org.jgroups.raft.RaftHandle;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+
+public class JGroupsRaftClusterView extends AbstractCamelClusterView {
+
+    private static final transient Logger LOG = LoggerFactory.getLogger(JGroupsRaftClusterView.class);
+    private final CamelClusterMember localMember = new JGropusraftLocalMember();
+    private String jgroupsConfig;
+    private String jgroupsClusterName;
+    private RaftHandle raftHandle;
+    private String raftId;
+    private volatile boolean isMaster = false;
+
+    protected JGroupsRaftClusterView(CamelClusterService cluster, String namespace, String jgroupsConfig, String jgroupsClusterName, RaftHandle raftHandle, String raftId) {
+        super(cluster, namespace);
+
+        this.jgroupsConfig = jgroupsConfig;
+        this.jgroupsClusterName = jgroupsClusterName;
+        this.raftHandle = raftHandle;
+        this.raftId = raftId;
+    }
+
+    @Override
+    public Optional<CamelClusterMember> getLeader() {
+        if (isMaster) {
+            return Optional.of(localMember);
+        } else {
+            return Optional.empty();
+        }
+    }
+
+    @Override
+    public CamelClusterMember getLocalMember() {
+        return localMember;
+    }
+
+    @Override
+    public List<CamelClusterMember> getMembers() {
+        return new ArrayList<CamelClusterMember>() {{ add(localMember); }};
+    }
+
+    @Override
+    protected void doStart() throws Exception {
+        if (raftHandle == null && jgroupsConfig != null && !jgroupsConfig.isEmpty()) {
+            raftHandle = new RaftHandle( new JChannel(jgroupsConfig), new NopStateMachine()).raftId(raftId);
+        } else if(raftHandle == null) {","[{'comment': 'Please run with mvn with -Pcheckstyle for resolve code style issues   ', 'commenter': 'dmvolod'}]"
2635,components/camel-jgroups-raft/src/test/java/org/apache/camel/component/jgroups/raft/JGroupsraftAbstractTest.java,"@@ -0,0 +1,49 @@
+/**","[{'comment': ""It's better to upper-case raft in file name here"", 'commenter': 'dmvolod'}]"
2635,parent/pom.xml,"@@ -389,6 +389,10 @@
     <jettison-version>1.4.0</jettison-version>
     <jgit-version>5.1.3.201810200350-r</jgit-version>
     <jgroups-version>4.0.15.Final</jgroups-version>
+    <jgroups-raft-version>0.4.2.Final</jgroups-raft-version>
+    <jgroups-raft-jgroups-version>4.0.15.Final</jgroups-raft-jgroups-version>","[{'comment': 'We can use directly the jgroups-version in this case', 'commenter': 'oscerd'}, {'comment': 'The problem is that in the future the 2 might differ, jgroups-raft is not tided to jgroups releases so...', 'commenter': 'valdar'}, {'comment': 'Ok', 'commenter': 'oscerd'}]"
2635,platforms/karaf/features/src/main/resources/features.xml,"@@ -1244,6 +1244,17 @@
     <bundle>mvn:org.apache.camel/camel-jgroups/${project.version}</bundle>
     <bundle dependency='true'>mvn:org.jgroups/jgroups/${jgroups-version}</bundle>
   </feature>
+  <feature name='camel-jgroups-raft' version='${project.version}' resolver='(obr)' start-level='50'>
+    <feature version='${project.version}'>camel-core</feature>
+    <bundle dependency='true'>mvn:commons-io/commons-io/${commons-io-version}</bundle>
+    <bundle>mvn:org.apache.camel/camel-jgroups-raft/${project.version}</bundle>","[{'comment': ""In this case I guess dependency='true' is needed."", 'commenter': 'oscerd'}, {'comment': 'Which one? commons-io?', 'commenter': 'valdar'}, {'comment': 'The camel-jgroups one', 'commenter': 'oscerd'}, {'comment': 'done!', 'commenter': 'valdar'}]"
2635,components/camel-jgroups-raft/pom.xml,"@@ -0,0 +1,101 @@
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one or more
+    contributor license agreements.  See the NOTICE file distributed with
+    this work for additional information regarding copyright ownership.
+    The ASF licenses this file to You under the Apache License, Version 2.0
+    (the ""License""); you may not use this file except in compliance with
+    the License.  You may obtain a copy of the License at
+
+         http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an ""AS IS"" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+
+-->
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"">
+
+    <modelVersion>4.0.0</modelVersion>
+
+    <parent>
+        <groupId>org.apache.camel</groupId>
+        <artifactId>components</artifactId>
+        <version>2.23.0-SNAPSHOT</version>","[{'comment': 'Please set to 2.24.0-SNAPSHOT', 'commenter': 'dmvolod'}]"
2635,platforms/spring-boot/components-starter/camel-jgroups-raft-starter/pom.xml,"@@ -0,0 +1,53 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one or more
+    contributor license agreements.  See the NOTICE file distributed with
+    this work for additional information regarding copyright ownership.
+    The ASF licenses this file to You under the Apache License, Version 2.0
+    (the ""License""); you may not use this file except in compliance with
+    the License.  You may obtain a copy of the License at
+
+         http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an ""AS IS"" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+
+-->
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+  <modelVersion>4.0.0</modelVersion>
+  <parent>
+    <groupId>org.apache.camel</groupId>
+    <artifactId>components-starter</artifactId>
+    <version>2.23.0-SNAPSHOT</version>","[{'comment': 'Please also set to 2.24.0-SNAPSHOT', 'commenter': 'dmvolod'}]"
2640,components/camel-chatscript/pom.xml,"@@ -0,0 +1,87 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one or more
+    contributor license agreements.  See the NOTICE file distributed with
+    this work for additional information regarding copyright ownership.
+    The ASF licenses this file to You under the Apache License, Version 2.0
+    (the ""License""); you may not use this file except in compliance with
+    the License.  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an ""AS IS"" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+
+-->
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+
+  <modelVersion>4.0.0</modelVersion>
+
+  <groupId>org.apache.camel.component</groupId>
+  <artifactId>camel-chatscript</artifactId>
+  <packaging>jar</packaging>
+  <version>1.0-SNAPSHOT</version>","[{'comment': 'Wrong version. Currently we are at 2.23.0-SNAPSHOT', 'commenter': 'oscerd'}]"
2640,components/camel-chatscript/pom.xml,"@@ -0,0 +1,87 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one or more
+    contributor license agreements.  See the NOTICE file distributed with
+    this work for additional information regarding copyright ownership.
+    The ASF licenses this file to You under the Apache License, Version 2.0
+    (the ""License""); you may not use this file except in compliance with
+    the License.  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an ""AS IS"" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+
+-->
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+
+  <modelVersion>4.0.0</modelVersion>
+
+  <groupId>org.apache.camel.component</groupId>
+  <artifactId>camel-chatscript</artifactId>
+  <packaging>jar</packaging>
+  <version>1.0-SNAPSHOT</version>
+
+  <name>A Camel Component</name>
+  <url>http://www.myorganization.org</url>
+
+  <dependencies>
+    <dependency>
+      <groupId>org.apache.camel</groupId>
+      <artifactId>camel-core</artifactId>
+      <version>2.22.1</version>
+    </dependency>  ","[{'comment': '2.23.0-SNAPSHOT', 'commenter': 'oscerd'}]"
2640,components/camel-chatscript/pom.xml,"@@ -0,0 +1,87 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one or more
+    contributor license agreements.  See the NOTICE file distributed with
+    this work for additional information regarding copyright ownership.
+    The ASF licenses this file to You under the Apache License, Version 2.0
+    (the ""License""); you may not use this file except in compliance with
+    the License.  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an ""AS IS"" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+
+-->
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+
+  <modelVersion>4.0.0</modelVersion>
+
+  <groupId>org.apache.camel.component</groupId>
+  <artifactId>camel-chatscript</artifactId>
+  <packaging>jar</packaging>
+  <version>1.0-SNAPSHOT</version>
+
+  <name>A Camel Component</name>
+  <url>http://www.myorganization.org</url>
+
+  <dependencies>
+    <dependency>
+      <groupId>org.apache.camel</groupId>
+      <artifactId>camel-core</artifactId>
+      <version>2.22.1</version>
+    </dependency>  
+<dependency>
+    <groupId>org.apache.camel</groupId>
+    <artifactId>camel-netty4</artifactId>
+      <version>2.22.1</version>
+    <!-- use the same version as your Camel core version -->
+</dependency>
+    <!-- for testing -->
+    <dependency>
+      <groupId>org.apache.camel</groupId>
+      <artifactId>camel-test</artifactId>
+      <version>2.22.1</version>      ","[{'comment': 'The version should come from parent pom', 'commenter': 'oscerd'}]"
2640,components/camel-chatscript/pom.xml,"@@ -0,0 +1,87 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one or more
+    contributor license agreements.  See the NOTICE file distributed with
+    this work for additional information regarding copyright ownership.
+    The ASF licenses this file to You under the Apache License, Version 2.0
+    (the ""License""); you may not use this file except in compliance with
+    the License.  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an ""AS IS"" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+
+-->
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+
+  <modelVersion>4.0.0</modelVersion>
+
+  <groupId>org.apache.camel.component</groupId>
+  <artifactId>camel-chatscript</artifactId>","[{'comment': 'This must import the components pom\r\n\r\n```\r\n    <parent>\r\n        <groupId>org.apache.camel</groupId>\r\n        <artifactId>components</artifactId>\r\n        <version>2.23.0-SNAPSHOT</version>\r\n    </parent>\r\n```\r\n', 'commenter': 'oscerd'}]"
2640,components/camel-chatscript/src/main/java/META-INF/MANIFEST.MF,"@@ -0,0 +1,3 @@
+Manifest-Version: 1.0
+Class-Path: 
+","[{'comment': 'Here you need to declare service stuff, take a look at the other components in the repo', 'commenter': 'oscerd'}, {'comment': 'Hi, I checked the existing components and none of the components are having this file. I am planning to remove it. Please let me know if you have any concerns,', 'commenter': 'varunblaze'}, {'comment': 'Removed the file based  after reviewing other components', 'commenter': 'varunblaze'}]"
2640,components/camel-chatscript/src/main/docs/camel-chatscript-component.adoc,"@@ -0,0 +1,75 @@
+[[ChatScript-component]]
+== ChatScript Component
+
+*Available as of Camel version 2.23*
+
+The *ChatScript:* component allows you to interact with ChatScript Server and have converstations. This component is stateless and relies on ChatScript to maintain chat history. ","[{'comment': 'Small typo here: conversations\r\n```suggestion\r\nThe *ChatScript:* component allows you to interact with ChatScript Server and have conversations. This component is stateless and relies on ChatScript to maintain chat history. \r\n```', 'commenter': 'aldettinger'}]"
2640,components/camel-chatscript/src/main/docs/camel-chatscript-component.adoc,"@@ -0,0 +1,75 @@
+[[ChatScript-component]]
+== ChatScript Component
+
+*Available as of Camel version 2.23*
+
+The *ChatScript:* component allows you to interact with ChatScript Server and have converstations. This component is stateless and relies on ChatScript to maintain chat history. 
+
+Original ChatScript is available here : https://github.com/bwilcox-1234/ChatScript
+
+This component expects a JSON having the following fields:
+{
+username:
+botname:
+body:
+}
+
+Refer ChatScriptMessage.java and samples  
+
+Maven users will need to add the following dependency to their `pom.xml`
+for this component:
+
+[source,xml]
+------------------------------------------------------------
+<dependency>
+    <groupId>org.apache.camel</groupId>
+      <artifactId>camel-chatscript</artifactId>
+    <version>x.x.x</version>
+    <!-- use the same version as your Camel core version -->
+</dependency>
+------------------------------------------------------------
+
+### URI format
+[source,java]
+-------------------------------------------------------------------------------------------------------------------------
+ChatScript:host:[port]/BotName[?options]
+-------------------------------------------------------------------------------------------------------------------------
+
+### Options
+
+// component options: START
+This component has one option resetchat which when set to true will issue :reset command to CS when the EndPoing is created.","[{'comment': '```suggestion\r\nThis component has one option resetchat which when set to true will issue :reset command to CS when the EndPoint is created.\r\n```', 'commenter': 'aldettinger'}]"
2640,components/camel-chatscript/src/main/docs/camel-chatscript-component.adoc,"@@ -0,0 +1,75 @@
+[[ChatScript-component]]
+== ChatScript Component
+
+*Available as of Camel version 2.23*
+
+The *ChatScript:* component allows you to interact with ChatScript Server and have converstations. This component is stateless and relies on ChatScript to maintain chat history. 
+
+Original ChatScript is available here : https://github.com/bwilcox-1234/ChatScript
+
+This component expects a JSON having the following fields:
+{
+username:
+botname:
+body:
+}
+
+Refer ChatScriptMessage.java and samples  
+
+Maven users will need to add the following dependency to their `pom.xml`
+for this component:
+
+[source,xml]
+------------------------------------------------------------
+<dependency>
+    <groupId>org.apache.camel</groupId>
+      <artifactId>camel-chatscript</artifactId>
+    <version>x.x.x</version>
+    <!-- use the same version as your Camel core version -->
+</dependency>
+------------------------------------------------------------
+
+### URI format
+[source,java]
+-------------------------------------------------------------------------------------------------------------------------
+ChatScript:host:[port]/BotName[?options]
+-------------------------------------------------------------------------------------------------------------------------
+
+### Options
+
+// component options: START","[{'comment': 'It looks like component options have been written by hand. If I remember well, they should be auto-generated from annotations in the component class.', 'commenter': 'aldettinger'}, {'comment': 'Hi, Yes I created the document by copy pasting from another component. I will run a full build to check if the build is created correctly are not.', 'commenter': 'varunblaze'}]"
2640,components/camel-chatscript/src/main/java/org/chatscript/Bot/ChatScriptBot.java,"@@ -0,0 +1,76 @@
+package org.chatscript.Bot;
+
+import java.io.BufferedReader;
+import java.io.IOException;
+import java.io.InputStreamReader;
+import java.io.PrintWriter;
+import java.net.Socket;
+import java.util.HashMap;
+
+import org.apache.camel.component.ChatScriptProducer;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class ChatScriptBot {
+
+	String host=null;","[{'comment': 'did not check, but i can see indent differences.\r\ncould you please run,\r\n\r\nmvn clean install -Psourcecheck', 'commenter': 'onderson'}, {'comment': 'Hi, I see some issues being reported by sourcecheck. I will fix and commit the same.', 'commenter': 'varunblaze'}]"
2640,components/camel-chatscript/pom.xml,"@@ -0,0 +1,68 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one or more
+    contributor license agreements.  See the NOTICE file distributed with
+    this work for additional information regarding copyright ownership.
+    The ASF licenses this file to You under the Apache License, Version 2.0
+    (the ""License""); you may not use this file except in compliance with
+    the License.  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an ""AS IS"" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+
+-->
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+
+  <modelVersion>4.0.0</modelVersion>
+
+    <parent>
+    <groupId>org.apache.camel</groupId>
+    <artifactId>components</artifactId>
+    <version>2.23.0-SNAPSHOT</version>","[{'comment': 'Version need to be changed to 2.24.0-SNAPSHOT', 'commenter': 'dmvolod'}]"
2640,components/camel-chatscript/src/main/java/org/apache/camel/component/ChatScriptProducer.java,"@@ -0,0 +1,51 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component;
+
+import org.apache.camel.Exchange;
+import org.apache.camel.impl.DefaultProducer;
+import org.chatscript.Bot.ChatScriptBot;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * The ChatScript producer.
+ */
+public class ChatScriptProducer extends DefaultProducer {
+    private static final transient Logger LOG = LoggerFactory.getLogger(ChatScriptProducer.class);
+    private ChatScriptEndpoint endpoint;
+    private static  ChatScriptBot bot=null;
+    public ChatScriptProducer(ChatScriptEndpoint endpoint) {
+        super(endpoint);
+        this.endpoint = endpoint;
+        bot=new ChatScriptBot(endpoint.getHostname(),
+    			endpoint.getPort(),endpoint.getBotname(),
+    			endpoint.getChatusername());//TODO set proxy headers for end user recognition
+        bot.init(null);
+        if (endpoint.isResetchat())
+        {
+        	bot.reset();
+        }
+    }
+
+    public void process(Exchange exchange) throws Exception {
+    	String chatmessage=String.valueOf(exchange.getIn().getBody());","[{'comment': 'Camel has `exchange.getIn().getBody(String.class)` where all registered converters could help in transforming a lot of body type to a string.', 'commenter': 'aldettinger'}]"
2640,components/camel-chatscript/src/test/java/org/apache/camel/component/ChatScriptComponentTest.java,"@@ -0,0 +1,50 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component;
+
+import org.apache.camel.builder.RouteBuilder;
+import org.apache.camel.component.mock.MockEndpoint;
+import org.apache.camel.test.junit4.CamelTestSupport;
+import org.junit.Test;
+
+public class ChatScriptComponentTest extends CamelTestSupport {
+
+    @Test
+    public void testChatScript() throws Exception {
+        MockEndpoint mock = getMockEndpoint(""mock:result"");
+        mock.expectedMinimumMessageCount(1);       
+        Thread.sleep(100);
+        assertMockEndpointsSatisfied();
+    }
+
+    @Override
+    protected RouteBuilder createRouteBuilder() throws Exception {
+        return new RouteBuilder() {
+            public void configure() {
+            	  char nullChar = (char) 0;
+                from(""ChatScript://localhost:1024/Harry?chatusername=varun&resetchat=true"")","[{'comment': 'It looks that the scheme is sometime _ChatScript_ and sometime _chatscript_. I would always use _chatscript_ in lower case as the scheme in annotations, examples, services...', 'commenter': 'aldettinger'}]"
2640,components/camel-chatscript/src/main/java/org/apache/camel/component/ChatScriptConsumer.java,"@@ -0,0 +1,53 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component;
+
+import java.util.Date;
+
+import org.apache.camel.Exchange;
+import org.apache.camel.Processor;
+import org.apache.camel.impl.ScheduledPollConsumer;
+
+/**
+ * The ChatScript consumer.
+ */
+public class ChatScriptConsumer extends ScheduledPollConsumer {
+    private final ChatScriptEndpoint endpoint;
+    public ChatScriptConsumer(ChatScriptEndpoint endpoint, Processor processor) {
+        super(endpoint, processor);
+        this.endpoint = endpoint;
+    }
+  
+    @Override
+    protected int poll() throws Exception {
+        Exchange exchange = endpoint.createExchange();
+       
+        // create a message body
+        exchange.getIn().setBody( this.endpoint.getCHAT_INIT());","[{'comment': 'Then `from(""chatbot:xxx"").to(""file:lines.log"")` would simply create a file with a lot of CHAT_INIT messages.\r\nIt could be that chatbot is not able to consume messages, in this case we are dealing with a write-only endpoint.\r\n([NagiosEndpoint](https://github.com/apache/camel/blob/master/components/camel-nagios/src/main/java/org/apache/camel/component/nagios/NagiosEndpoint.java) is an example of a write-only component).', 'commenter': 'aldettinger'}, {'comment': ""+1 to @aldettinger\r\nTo create a polling consumer you can take care about concurrent threads which are reading the same messages. If client can do this, it's good, if not, use above suggestion"", 'commenter': 'dmvolod'}, {'comment': 'The same issues again with Java CamelCase :)', 'commenter': 'dmvolod'}, {'comment': 'Just now I have commited the new version. Pleae check.', 'commenter': 'varunblaze'}]"
2640,components/camel-chatscript/src/main/java/org/apache/camel/component/ChatScriptEndpoint.java,"@@ -0,0 +1,140 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component;
+
+import java.net.URI;
+import java.net.URISyntaxException;
+
+import org.apache.camel.Consumer;
+import org.apache.camel.Processor;
+import org.apache.camel.Producer;
+import org.apache.camel.impl.DefaultEndpoint;
+import org.apache.camel.spi.Metadata;
+import org.apache.camel.spi.UriEndpoint;
+import org.apache.camel.spi.UriParam;
+import org.apache.camel.spi.UriPath;
+
+/**
+ * Represents a ChatScript endpoint.
+ */
+@UriEndpoint(firstVersion = ""2.22.0"", scheme = ""chatscript"", title = ""ChatScript"", syntax = ""chatscript:hostname:port/botname"", consumerClass = ChatScriptConsumer.class, label = ""ai,chatscript"")
+public class ChatScriptEndpoint extends DefaultEndpoint {
+	
+    public static final int DEFAULT_PORT = 1024;
+    private final char nullChar = (char) 0;
+    private final String CHAT_INIT=nullChar + ""1"" + nullChar + nullChar;
+   
+    private static final String URI_ERROR = ""Invalid URI. Format must be of the form chatscript://hostname[:port]/botname?[options...]"";
+    @UriPath @Metadata(required = ""true"")
+    private String hostname;
+    @UriPath(defaultValue = """" + DEFAULT_PORT)
+    private int port;
+    @UriPath @Metadata(required = ""true"")
+    private String botname;
+    
+    @UriParam(label = ""username"",defaultValue=""camel"")
+    private String chatusername;
+    @UriParam(label = ""reset"",defaultValue=""false"")
+    private boolean resetchat;
+    
+    public boolean isResetchat() {
+		return resetchat;
+	}
+
+	public void setResetchat(boolean resetchat) {
+		this.resetchat = resetchat;
+	}
+
+	public String getChatusername() {
+		return chatusername;
+	}
+
+	public void setChatusername(String chatusername) {
+		this.chatusername = chatusername;
+	}
+
+	public ChatScriptEndpoint() {
+    }
+
+    public ChatScriptEndpoint(String uri,String remaining,
+    		ChatScriptComponent component) throws URISyntaxException {
+        super(uri, component);
+        
+        URI remainingUri = new URI(""tcp://"" + remaining);
+      port = remainingUri.getPort() == -1 ? DEFAULT_PORT : remainingUri.getPort();
+      if (remainingUri.getPath() == null || remainingUri.getPath().trim().length() == 0) {
+          throw new IllegalArgumentException(URI_ERROR);
+      }
+          hostname = remainingUri.getHost();
+          if (hostname == null) {
+              throw new IllegalArgumentException(URI_ERROR);
+          }
+          botname=remainingUri.getPath();
+              if (botname== null) {
+                  throw new IllegalArgumentException(URI_ERROR);
+              }
+          botname=botname.substring(1);   
+    
+}
+    public ChatScriptEndpoint(String endpointUri) {
+        super(endpointUri);
+    }
+
+    public Producer createProducer() throws Exception {
+        return new ChatScriptProducer(this);
+    }
+
+    public Consumer createConsumer(Processor processor) throws Exception {
+        return new ChatScriptConsumer(this, processor);
+    }
+
+    public boolean isSingleton() {
+        return true;
+    }
+
+	public String getHostname() {
+		return hostname;
+	}
+
+	public void setHostname(String hostname) {
+		this.hostname = hostname;
+	}
+
+	public int getPort() {
+		return port;
+	}
+
+	public void setPort(int port) {
+		this.port = port;
+	}
+
+	public String getBotname() {
+		return botname;
+	}
+
+	public void setBotname(String botname) {
+		this.botname = botname;
+	}
+
+	public static int getDefaultPort() {
+		return DEFAULT_PORT;
+	}
+
+	public String getCHAT_INIT() {","[{'comment': 'Incorrect CamelCase style in name', 'commenter': 'dmvolod'}, {'comment': 'Modified', 'commenter': 'varunblaze'}]"
2640,components/camel-chatscript/src/main/java/org/apache/camel/component/ChatScriptEndpoint.java,"@@ -0,0 +1,140 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component;
+
+import java.net.URI;
+import java.net.URISyntaxException;
+
+import org.apache.camel.Consumer;
+import org.apache.camel.Processor;
+import org.apache.camel.Producer;
+import org.apache.camel.impl.DefaultEndpoint;
+import org.apache.camel.spi.Metadata;
+import org.apache.camel.spi.UriEndpoint;
+import org.apache.camel.spi.UriParam;
+import org.apache.camel.spi.UriPath;
+
+/**
+ * Represents a ChatScript endpoint.
+ */
+@UriEndpoint(firstVersion = ""2.22.0"", scheme = ""chatscript"", title = ""ChatScript"", syntax = ""chatscript:hostname:port/botname"", consumerClass = ChatScriptConsumer.class, label = ""ai,chatscript"")
+public class ChatScriptEndpoint extends DefaultEndpoint {
+	
+    public static final int DEFAULT_PORT = 1024;
+    private final char nullChar = (char) 0;
+    private final String CHAT_INIT=nullChar + ""1"" + nullChar + nullChar;
+   
+    private static final String URI_ERROR = ""Invalid URI. Format must be of the form chatscript://hostname[:port]/botname?[options...]"";
+    @UriPath @Metadata(required = ""true"")
+    private String hostname;
+    @UriPath(defaultValue = """" + DEFAULT_PORT)
+    private int port;
+    @UriPath @Metadata(required = ""true"")
+    private String botname;
+    
+    @UriParam(label = ""username"",defaultValue=""camel"")","[{'comment': ""We don't need to store default user name"", 'commenter': 'dmvolod'}, {'comment': ""Didn't resolve or response"", 'commenter': 'dmvolod'}]"
2640,components/camel-chatscript/src/main/java/org/apache/camel/component/ChatScriptEndpoint.java,"@@ -0,0 +1,140 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component;
+
+import java.net.URI;
+import java.net.URISyntaxException;
+
+import org.apache.camel.Consumer;
+import org.apache.camel.Processor;
+import org.apache.camel.Producer;
+import org.apache.camel.impl.DefaultEndpoint;
+import org.apache.camel.spi.Metadata;
+import org.apache.camel.spi.UriEndpoint;
+import org.apache.camel.spi.UriParam;
+import org.apache.camel.spi.UriPath;
+
+/**
+ * Represents a ChatScript endpoint.
+ */
+@UriEndpoint(firstVersion = ""2.22.0"", scheme = ""chatscript"", title = ""ChatScript"", syntax = ""chatscript:hostname:port/botname"", consumerClass = ChatScriptConsumer.class, label = ""ai,chatscript"")
+public class ChatScriptEndpoint extends DefaultEndpoint {
+	
+    public static final int DEFAULT_PORT = 1024;
+    private final char nullChar = (char) 0;
+    private final String CHAT_INIT=nullChar + ""1"" + nullChar + nullChar;
+   
+    private static final String URI_ERROR = ""Invalid URI. Format must be of the form chatscript://hostname[:port]/botname?[options...]"";
+    @UriPath @Metadata(required = ""true"")
+    private String hostname;
+    @UriPath(defaultValue = """" + DEFAULT_PORT)
+    private int port;
+    @UriPath @Metadata(required = ""true"")
+    private String botname;
+    
+    @UriParam(label = ""username"",defaultValue=""camel"")
+    private String chatusername;
+    @UriParam(label = ""reset"",defaultValue=""false"")
+    private boolean resetchat;
+    
+    public boolean isResetchat() {
+		return resetchat;
+	}
+
+	public void setResetchat(boolean resetchat) {
+		this.resetchat = resetchat;
+	}
+
+	public String getChatusername() {
+		return chatusername;
+	}
+
+	public void setChatusername(String chatusername) {
+		this.chatusername = chatusername;
+	}
+
+	public ChatScriptEndpoint() {
+    }
+
+    public ChatScriptEndpoint(String uri,String remaining,
+    		ChatScriptComponent component) throws URISyntaxException {
+        super(uri, component);
+        
+        URI remainingUri = new URI(""tcp://"" + remaining);
+      port = remainingUri.getPort() == -1 ? DEFAULT_PORT : remainingUri.getPort();
+      if (remainingUri.getPath() == null || remainingUri.getPath().trim().length() == 0) {
+          throw new IllegalArgumentException(URI_ERROR);
+      }
+          hostname = remainingUri.getHost();
+          if (hostname == null) {
+              throw new IllegalArgumentException(URI_ERROR);
+          }
+          botname=remainingUri.getPath();
+              if (botname== null) {","[{'comment': 'We have ObjectHelper method to check is string is null or empty', 'commenter': 'dmvolod'}]"
2640,components/camel-chatscript/src/main/java/org/apache/camel/component/ChatScriptEndpoint.java,"@@ -0,0 +1,140 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component;
+
+import java.net.URI;
+import java.net.URISyntaxException;
+
+import org.apache.camel.Consumer;
+import org.apache.camel.Processor;
+import org.apache.camel.Producer;
+import org.apache.camel.impl.DefaultEndpoint;
+import org.apache.camel.spi.Metadata;
+import org.apache.camel.spi.UriEndpoint;
+import org.apache.camel.spi.UriParam;
+import org.apache.camel.spi.UriPath;
+
+/**
+ * Represents a ChatScript endpoint.
+ */
+@UriEndpoint(firstVersion = ""2.22.0"", scheme = ""chatscript"", title = ""ChatScript"", syntax = ""chatscript:hostname:port/botname"", consumerClass = ChatScriptConsumer.class, label = ""ai,chatscript"")
+public class ChatScriptEndpoint extends DefaultEndpoint {
+	
+    public static final int DEFAULT_PORT = 1024;
+    private final char nullChar = (char) 0;
+    private final String CHAT_INIT=nullChar + ""1"" + nullChar + nullChar;
+   
+    private static final String URI_ERROR = ""Invalid URI. Format must be of the form chatscript://hostname[:port]/botname?[options...]"";
+    @UriPath @Metadata(required = ""true"")
+    private String hostname;
+    @UriPath(defaultValue = """" + DEFAULT_PORT)
+    private int port;
+    @UriPath @Metadata(required = ""true"")
+    private String botname;
+    
+    @UriParam(label = ""username"",defaultValue=""camel"")
+    private String chatusername;
+    @UriParam(label = ""reset"",defaultValue=""false"")
+    private boolean resetchat;
+    
+    public boolean isResetchat() {
+		return resetchat;
+	}
+
+	public void setResetchat(boolean resetchat) {
+		this.resetchat = resetchat;
+	}
+
+	public String getChatusername() {
+		return chatusername;
+	}
+
+	public void setChatusername(String chatusername) {
+		this.chatusername = chatusername;
+	}
+
+	public ChatScriptEndpoint() {
+    }
+
+    public ChatScriptEndpoint(String uri,String remaining,
+    		ChatScriptComponent component) throws URISyntaxException {
+        super(uri, component);
+        
+        URI remainingUri = new URI(""tcp://"" + remaining);
+      port = remainingUri.getPort() == -1 ? DEFAULT_PORT : remainingUri.getPort();
+      if (remainingUri.getPath() == null || remainingUri.getPath().trim().length() == 0) {
+          throw new IllegalArgumentException(URI_ERROR);
+      }
+          hostname = remainingUri.getHost();
+          if (hostname == null) {
+              throw new IllegalArgumentException(URI_ERROR);
+          }
+          botname=remainingUri.getPath();
+              if (botname== null) {
+                  throw new IllegalArgumentException(URI_ERROR);
+              }
+          botname=botname.substring(1);   
+    
+}
+    public ChatScriptEndpoint(String endpointUri) {
+        super(endpointUri);
+    }
+
+    public Producer createProducer() throws Exception {
+        return new ChatScriptProducer(this);
+    }
+
+    public Consumer createConsumer(Processor processor) throws Exception {
+        return new ChatScriptConsumer(this, processor);
+    }
+
+    public boolean isSingleton() {
+        return true;
+    }
+
+	public String getHostname() {
+		return hostname;
+	}
+
+	public void setHostname(String hostname) {
+		this.hostname = hostname;
+	}
+
+	public int getPort() {
+		return port;
+	}
+
+	public void setPort(int port) {
+		this.port = port;
+	}
+
+	public String getBotname() {","[{'comment': 'CamelCase again', 'commenter': 'dmvolod'}, {'comment': 'modified', 'commenter': 'varunblaze'}]"
2640,components/camel-chatscript/src/main/java/org/chatscript/Bot/ChatScriptBot.java,"@@ -0,0 +1,76 @@
+package org.chatscript.Bot;
+
+import java.io.BufferedReader;
+import java.io.IOException;
+import java.io.InputStreamReader;
+import java.io.PrintWriter;
+import java.net.Socket;
+import java.util.HashMap;
+
+import org.apache.camel.component.ChatScriptProducer;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class ChatScriptBot {","[{'comment': 'What this class does? A large number of hardcoded values which are not clear.\r\nThe package must be start with org.apache.camel....', 'commenter': 'dmvolod'}]"
2640,components/camel-chatscript/src/main/docs/camel-chatscript-component.adoc,"@@ -0,0 +1,74 @@
+[[ChatScript-component]]
+== ChatScript Component
+
+*Available as of Camel version 2.23*","[{'comment': 'Must be 2.24', 'commenter': 'dmvolod'}]"
2653,components/camel-chatscript/pom.xml,"@@ -0,0 +1,73 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one or more
+    contributor license agreements.  See the NOTICE file distributed with
+    this work for additional information regarding copyright ownership.
+    The ASF licenses this file to You under the Apache License, Version 2.0
+    (the ""License""); you may not use this file except in compliance with
+    the License.  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an ""AS IS"" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+
+-->
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+
+  <modelVersion>4.0.0</modelVersion>
+  <parent>
+    <groupId>org.apache.camel</groupId>
+    <artifactId>components</artifactId>
+    <version>2.24.0-SNAPSHOT</version>
+</parent>
+    
+  <groupId>org.apache.camel.component</groupId>
+  <artifactId>camel-chatscript</artifactId>
+  <packaging>jar</packaging>
+
+  <name>Camel :: ChatScript</name>
+  <description>Camel support for ChatScript</description>
+
+  <properties>
+    <camel.osgi.export.pkg>org.apache.camel.component.chatscript.*</camel.osgi.export.pkg>
+    <camel.osgi.export.service>org.apache.camel.spi.ComponentResolver;component=chatscript</camel.osgi.export.service>
+</properties>
+  <dependencies>
+    <dependency>
+      <groupId>org.apache.camel</groupId>
+      <artifactId>camel-core</artifactId>
+    </dependency>  
+    <!-- for testing -->
+    <dependency>
+      <groupId>org.apache.camel</groupId>
+      <artifactId>camel-test</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <!-- logging -->
+    <dependency>
+      <groupId>org.slf4j</groupId>
+      <artifactId>slf4j-api</artifactId>
+    </dependency>      
+    <dependency>
+      <groupId>org.slf4j</groupId>
+      <artifactId>slf4j-log4j12</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>log4j</groupId> 
+      <artifactId>log4j</artifactId> 
+      <scope>test</scope> 
+    </dependency>
+	 <dependency> 
+    	<groupId>com.fasterxml.jackson.core</groupId>
+    	<artifactId>jackson-databind</artifactId>
+    	<version>2.9.7</version>","[{'comment': 'Version need to be placed inside parent/pom.xml or use already defined value', 'commenter': 'dmvolod'}, {'comment': 'modified now.', 'commenter': 'varunblaze'}]"
2653,components/camel-chatscript/src/main/java/org/apache/camel/component/chatscript/ChatScriptBot.java,"@@ -0,0 +1,148 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.chatscript;
+
+import java.io.BufferedReader;
+import java.io.IOException;
+import java.io.InputStreamReader;
+import java.io.PrintWriter;
+import java.net.Socket;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class ChatScriptBot {
+
+    private static final transient Logger LOG = LoggerFactory.getLogger(ChatScriptBot.class);
+    String host;
+    int port = 1024;
+    String message;
+    String botName;
+    String userName;
+    boolean initialized;
+
+    public ChatScriptBot(String iHost, int port, String iBotName, String iUserName) {
+        this.host = iHost;","[{'comment': 'What does hadrcoded port means?', 'commenter': 'dmvolod'}, {'comment': 'Hi, I have removed the hardcoding. 1024 is the default port number on which CS server will be listening to.', 'commenter': 'varunblaze'}]"
2653,components/camel-chatscript/src/main/java/org/apache/camel/component/chatscript/ChatScriptBot.java,"@@ -0,0 +1,148 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.chatscript;
+
+import java.io.BufferedReader;
+import java.io.IOException;
+import java.io.InputStreamReader;
+import java.io.PrintWriter;
+import java.net.Socket;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class ChatScriptBot {
+
+    private static final transient Logger LOG = LoggerFactory.getLogger(ChatScriptBot.class);
+    String host;
+    int port = 1024;
+    String message;
+    String botName;
+    String userName;
+    boolean initialized;
+
+    public ChatScriptBot(String iHost, int port, String iBotName, String iUserName) {
+        this.host = iHost;
+        this.port = port;
+        this.botName = iBotName;
+        this.userName = iUserName;
+    }
+
+    public String sendChat(String input) {
+        if (!initialized) {
+            return init(null);
+        }
+        ChatScriptMessage g = new ChatScriptMessage(this.userName, this.botName, input);
+        return doMessage(g.toCSFormat());
+    }
+
+    public String sendChat(ChatScriptMessage input) {
+        if (!initialized) {
+            return init(input);
+        }
+        return doMessage(input.toCSFormat());
+    }
+
+    private String doMessage(ChatScriptMessage msg) {
+        return doMessage(msg.toCSFormat());
+    }
+
+    private String doMessage(String msg) {
+        Socket echoSocket;
+        String resp = """";
+
+        try {
+            echoSocket = new Socket(this.host, this.port);
+            PrintWriter out = new PrintWriter(echoSocket.getOutputStream(), true);
+            BufferedReader in = new BufferedReader(new InputStreamReader(echoSocket.getInputStream()));
+            out.println(msg);
+            resp = in.readLine();
+            echoSocket.close();
+        } catch (IOException e) {
+            e.printStackTrace();
+            LOG.error(""Error: "" + e.getMessage());
+        }
+
+        return resp;
+
+    }
+
+    public String init(ChatScriptMessage input) {
+        ChatScriptMessage g = new ChatScriptMessage(input.getUserName(), this.botName, null);
+        String response = doMessage(g);
+        LOG.info(""Conversation started between the bot "" + this.botName + "" and "" + input.getUserName());
+        initialized = true;
+        return response;
+    }
+
+    public String getBotType() {
+        return ""ChatSCript"";
+    }
+
+    public void reset() {
+        //TODO
+    	}
+
+    public String getHost() {
+        return host;
+    }
+
+    public void setHost(String host) {
+        this.host = host;
+    }
+
+    public int getPort() {
+        return port;
+    }
+
+    public void setPort(int iPort) {
+        this.port = iPort;
+    }
+
+    public String getMessage() {
+        return message;
+    }
+
+    public void setMessage(String iMessage) {
+        this.message = iMessage;
+    }
+
+    public String getBotName() {
+        return botName;
+    }
+
+    public void setBotName(String iBotName) {
+        this.botName = iBotName;
+    }
+
+    public String getUsername() {","[{'comment': 'CamelCase again. setUserName', 'commenter': 'dmvolod'}, {'comment': 'Thanks for pointing out. Have fixed it now.', 'commenter': 'varunblaze'}]"
2653,components/camel-chatscript/src/main/java/org/apache/camel/component/chatscript/ChatScriptEndpoint.java,"@@ -0,0 +1,145 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.chatscript;
+
+import java.net.URI;
+import java.net.URISyntaxException;
+
+import org.apache.camel.Consumer;
+import org.apache.camel.Processor;
+import org.apache.camel.Producer;
+import org.apache.camel.impl.DefaultEndpoint;
+import org.apache.camel.spi.Metadata;
+import org.apache.camel.spi.UriEndpoint;
+import org.apache.camel.spi.UriParam;
+import org.apache.camel.spi.UriPath;
+import org.apache.camel.util.ObjectHelper;
+
+/**
+ * Represents a ChatScript endpoint.
+ */
+@UriEndpoint(firstVersion = ""2.24.0"", scheme = ""chatscript"", title = ""ChatScript"", syntax = ""chatscript:hostname:port/botname"",  producerOnly = true, label = ""ai,chatscript"")","[{'comment': ""It's enough host:port instead of hostname:port in syntax"", 'commenter': 'dmvolod'}, {'comment': 'Modified as requested.', 'commenter': 'varunblaze'}]"
2653,components/camel-chatscript/src/main/java/org/apache/camel/component/chatscript/ChatScriptEndpoint.java,"@@ -0,0 +1,145 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.chatscript;
+
+import java.net.URI;
+import java.net.URISyntaxException;
+
+import org.apache.camel.Consumer;
+import org.apache.camel.Processor;
+import org.apache.camel.Producer;
+import org.apache.camel.impl.DefaultEndpoint;
+import org.apache.camel.spi.Metadata;
+import org.apache.camel.spi.UriEndpoint;
+import org.apache.camel.spi.UriParam;
+import org.apache.camel.spi.UriPath;
+import org.apache.camel.util.ObjectHelper;
+
+/**
+ * Represents a ChatScript endpoint.
+ */
+@UriEndpoint(firstVersion = ""2.24.0"", scheme = ""chatscript"", title = ""ChatScript"", syntax = ""chatscript:hostname:port/botname"",  producerOnly = true, label = ""ai,chatscript"")
+public class ChatScriptEndpoint extends DefaultEndpoint {
+
+    public static final int DEFAULT_PORT = 1024;","[{'comment': ""It's better to use separate class/enum for constants"", 'commenter': 'dmvolod'}, {'comment': 'Moved the constants to new class', 'commenter': 'varunblaze'}]"
2653,components/camel-chatscript/src/main/java/org/apache/camel/component/chatscript/ChatScriptProducer.java,"@@ -0,0 +1,72 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.chatscript;
+import com.fasterxml.jackson.databind.ObjectMapper;
+import org.apache.camel.Exchange;
+import org.apache.camel.impl.DefaultProducer;
+
+/**
+ * The ChatScript producer.
+ */
+public class ChatScriptProducer extends DefaultProducer {
+    private ChatScriptEndpoint endpoint;
+    private ObjectMapper mapper = new ObjectMapper();
+    public ChatScriptProducer(ChatScriptEndpoint endpoint) {
+        super(endpoint);
+        this.endpoint = endpoint;
+
+        if (endpoint.isResetChat()) {
+            this.endpoint.getBot().reset();
+        }
+    }
+
+    public void process(Exchange exchange) throws Exception {
+
+        Object body = exchange.getIn().getBody();
+        ChatScriptMessage inputMessage = new ChatScriptMessage();
+        /* use can pass message object as json or the object it self */
+        if (!(body instanceof ChatScriptMessage)) {
+            inputMessage = buildMessage(body);
+        } else {
+            inputMessage = (ChatScriptMessage) body;
+        }
+        String response = this.endpoint.getBot().sendChat(inputMessage);
+        inputMessage.setReply(response);
+        exchange.getOut().setBody(inputMessage);
+    }
+
+    private ChatScriptMessage buildMessage(Object body) {
+
+        if (body instanceof String) {
+            return createMessage(body);
+        }
+        return null;
+    }
+
+    private ChatScriptMessage createMessage(Object body) {
+        ChatScriptMessage ret = null;
+        try {
+            ret = mapper.readValue(String.valueOf(body), ChatScriptMessage.class);
+        } catch (Exception e) {
+            // TODO Auto-generated catch block","[{'comment': ""It's a worth practice to skip exception there "", 'commenter': 'dmvolod'}]"
2653,components/camel-chatscript/src/test/resources/log4j.properties,"@@ -0,0 +1,33 @@
+## ---------------------------------------------------------------------------
+## Licensed to the Apache Software Foundation (ASF) under one or more
+## contributor license agreements.  See the NOTICE file distributed with
+## this work for additional information regarding copyright ownership.
+## The ASF licenses this file to You under the Apache License, Version 2.0
+## (the ""License""); you may not use this file except in compliance with
+## the License.  You may obtain a copy of the License at
+##
+##      http://www.apache.org/licenses/LICENSE-2.0
+##
+## Unless required by applicable law or agreed to in writing, software
+## distributed under the License is distributed on an ""AS IS"" BASIS,
+## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+## See the License for the specific language governing permissions and
+## limitations under the License.
+## ---------------------------------------------------------------------------
+
+# Root logger option
+log4j.rootLogger=DEBUG, file, console
+ 
+# Direct log messages to a log file
+log4j.appender.file=org.apache.log4j.FileAppender
+log4j.appender.file.file=target/test.log","[{'comment': 'Incorrect file name for log file, please check from other components for example', 'commenter': 'dmvolod'}, {'comment': 'Actually I copied this file from camel-azure component (https://github.com/apache/camel/tree/master/components/camel-azure/src/test/resources) . Please let me know if I need to move this file.\r\n\r\n', 'commenter': 'varunblaze'}]"
2653,components/camel-chatscript/src/test/resources/log4j2.properties,"@@ -0,0 +1,28 @@
+## ---------------------------------------------------------------------------
+## Licensed to the Apache Software Foundation (ASF) under one or more
+## contributor license agreements.  See the NOTICE file distributed with
+## this work for additional information regarding copyright ownership.
+## The ASF licenses this file to You under the Apache License, Version 2.0
+## (the ""License""); you may not use this file except in compliance with
+## the License.  You may obtain a copy of the License at
+##
+##      http://www.apache.org/licenses/LICENSE-2.0
+##
+## Unless required by applicable law or agreed to in writing, software
+## distributed under the License is distributed on an ""AS IS"" BASIS,
+## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+## See the License for the specific language governing permissions and
+## limitations under the License.
+## ---------------------------------------------------------------------------
+
+appender.file.type = File","[{'comment': 'We need just one log configuration file', 'commenter': 'dmvolod'}, {'comment': 'Actually I copied this file from camel-azure component (https://github.com/apache/camel/tree/master/components/camel-azure/src/test/resources) . Please let me know if I need to move this file.', 'commenter': 'varunblaze'}]"
2653,components/camel-chatscript/src/main/java/org/apache/camel/component/chatscript/ChatScriptEndpoint.java,"@@ -0,0 +1,145 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.chatscript;
+
+import java.net.URI;
+import java.net.URISyntaxException;
+
+import org.apache.camel.Consumer;
+import org.apache.camel.Processor;
+import org.apache.camel.Producer;
+import org.apache.camel.impl.DefaultEndpoint;
+import org.apache.camel.spi.Metadata;
+import org.apache.camel.spi.UriEndpoint;
+import org.apache.camel.spi.UriParam;
+import org.apache.camel.spi.UriPath;
+import org.apache.camel.util.ObjectHelper;
+
+/**
+ * Represents a ChatScript endpoint.
+ */
+@UriEndpoint(firstVersion = ""2.24.0"", scheme = ""chatscript"", title = ""ChatScript"", syntax = ""chatscript:hostname:port/botname"",  producerOnly = true, label = ""ai,chatscript"")
+public class ChatScriptEndpoint extends DefaultEndpoint {
+
+    public static final int DEFAULT_PORT = 1024;
+
+    private static final String URI_ERROR = ""Invalid URI. Format must be of the form chatscript://hostname[:port]/botname?[options...]"";
+    @UriPath (description = ""Hostname or IP of the server on which CS server is running"") 
+    @Metadata(required = ""true"")
+    private String hostname;
+    @UriPath(description = ""Port on which ChatScript is listening to"", defaultValue = """" + DEFAULT_PORT)
+    private int port;
+    @UriPath(description = ""Name of the Bot in CS to converse with"")
+    @Metadata(required = ""true"")
+    private String botname;
+    @UriParam(description = ""Username who initializes the CS conversation. To be set when chat is initialized from camel route"", label = ""username"")
+    private String chatusername;
+    @UriParam (description = ""Issues :reset command to start a new conversation everytime"", label = ""reset"", defaultValue = ""false"")
+    private boolean resetchat;
+    private ChatScriptBot bot;
+
+    public ChatScriptEndpoint(String endpointUri) {
+        super(endpointUri);
+    }
+    public ChatScriptEndpoint() {
+    }
+
+    public ChatScriptEndpoint(String uri, String remaining,
+            ChatScriptComponent component) throws URISyntaxException {
+        super(uri, component);
+
+        URI remainingUri = new URI(""tcp://"" + remaining);
+        port = remainingUri.getPort() == -1 ? DEFAULT_PORT : remainingUri.getPort();
+        if (ObjectHelper.isEmpty(remainingUri.getPath())) {
+            throw new IllegalArgumentException(URI_ERROR);
+        }
+        hostname = remainingUri.getHost();
+       if (ObjectHelper.isEmpty(hostname)) { 
+            throw new IllegalArgumentException(URI_ERROR);
+        }
+        botname = remainingUri.getPath();
+        if (ObjectHelper.isEmpty(botname)) {
+            throw new IllegalArgumentException(URI_ERROR);
+        }
+        botname = botname.substring(1);
+        setbot(new ChatScriptBot(getHostName(), getPort(), getBotName(), """"));
+
+    }
+    public boolean isResetChat() {
+        return resetchat;
+    }
+
+    public void setResetchat(boolean resetChat) {
+        this.resetchat = resetChat;
+    }
+
+    public String getChatUserName() {
+        return chatusername;
+    }
+
+    public void setChatUserName(String chatusername) {
+        this.chatusername = chatusername;
+    }
+
+    public Producer createProducer() throws Exception {
+        return new ChatScriptProducer(this);
+    }
+
+    public Consumer createConsumer(Processor processor) throws Exception {
+        throw new UnsupportedOperationException(""Chatscript consumer not supported"");","[{'comment': ""'ChatScript' instead of 'Chatscript'"", 'commenter': 'dmvolod'}]"
2653,components/camel-chatscript/src/main/java/org/apache/camel/component/chatscript/ChatScriptBot.java,"@@ -0,0 +1,148 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.chatscript;
+
+import java.io.BufferedReader;
+import java.io.IOException;
+import java.io.InputStreamReader;
+import java.io.PrintWriter;
+import java.net.Socket;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class ChatScriptBot {
+
+    private static final transient Logger LOG = LoggerFactory.getLogger(ChatScriptBot.class);
+    String host;
+    int port = 1024;
+    String message;
+    String botName;
+    String userName;
+    boolean initialized;
+
+    public ChatScriptBot(String iHost, int port, String iBotName, String iUserName) {
+        this.host = iHost;
+        this.port = port;
+        this.botName = iBotName;
+        this.userName = iUserName;
+    }
+
+    public String sendChat(String input) {
+        if (!initialized) {
+            return init(null);
+        }
+        ChatScriptMessage g = new ChatScriptMessage(this.userName, this.botName, input);
+        return doMessage(g.toCSFormat());
+    }
+
+    public String sendChat(ChatScriptMessage input) {
+        if (!initialized) {
+            return init(input);
+        }
+        return doMessage(input.toCSFormat());
+    }
+
+    private String doMessage(ChatScriptMessage msg) {
+        return doMessage(msg.toCSFormat());
+    }
+
+    private String doMessage(String msg) {
+        Socket echoSocket;
+        String resp = """";
+
+        try {
+            echoSocket = new Socket(this.host, this.port);
+            PrintWriter out = new PrintWriter(echoSocket.getOutputStream(), true);
+            BufferedReader in = new BufferedReader(new InputStreamReader(echoSocket.getInputStream()));
+            out.println(msg);
+            resp = in.readLine();
+            echoSocket.close();
+        } catch (IOException e) {
+            e.printStackTrace();
+            LOG.error(""Error: "" + e.getMessage());","[{'comment': 'Skip exception again?', 'commenter': 'dmvolod'}, {'comment': 'Modified the code to throw Exception ', 'commenter': 'varunblaze'}]"
2653,components/camel-chatscript/src/main/java/org/apache/camel/component/chatscript/ChatScriptBot.java,"@@ -0,0 +1,148 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.chatscript;
+
+import java.io.BufferedReader;
+import java.io.IOException;
+import java.io.InputStreamReader;
+import java.io.PrintWriter;
+import java.net.Socket;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class ChatScriptBot {
+
+    private static final transient Logger LOG = LoggerFactory.getLogger(ChatScriptBot.class);
+    String host;
+    int port = 1024;
+    String message;
+    String botName;
+    String userName;
+    boolean initialized;
+
+    public ChatScriptBot(String iHost, int port, String iBotName, String iUserName) {
+        this.host = iHost;
+        this.port = port;
+        this.botName = iBotName;
+        this.userName = iUserName;
+    }
+
+    public String sendChat(String input) {
+        if (!initialized) {
+            return init(null);
+        }
+        ChatScriptMessage g = new ChatScriptMessage(this.userName, this.botName, input);
+        return doMessage(g.toCSFormat());
+    }
+
+    public String sendChat(ChatScriptMessage input) {
+        if (!initialized) {
+            return init(input);
+        }
+        return doMessage(input.toCSFormat());
+    }
+
+    private String doMessage(ChatScriptMessage msg) {
+        return doMessage(msg.toCSFormat());
+    }
+
+    private String doMessage(String msg) {
+        Socket echoSocket;
+        String resp = """";
+
+        try {
+            echoSocket = new Socket(this.host, this.port);","[{'comment': ""I don't know how is ChatScript works. Is it free of auth mechanism?"", 'commenter': 'dmvolod'}, {'comment': 'There is no authentication mechanism for ChatScript. Applications which make use of CS must build the authentication.', 'commenter': 'varunblaze'}]"
2653,components/camel-chatscript/src/main/java/org/apache/camel/component/chatscript/ChatScriptBot.java,"@@ -0,0 +1,149 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.chatscript;
+
+import java.io.BufferedReader;
+import java.io.IOException;
+import java.io.InputStreamReader;
+import java.io.PrintWriter;
+import java.net.Socket;
+
+import org.apache.camel.component.chatscript.exception.ChatScriptDeliveryException;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class ChatScriptBot {
+
+    private static final transient Logger LOG = LoggerFactory.getLogger(ChatScriptBot.class);
+    String host;
+    int port;
+    String message;
+    String botName;
+    String userName;
+    boolean initialized;
+
+    public ChatScriptBot(String iHost, int port, String iBotName, String iUserName) {
+        this.host = iHost;
+        this.port = port;
+        this.botName = iBotName;
+        this.userName = iUserName;
+    }
+
+    public String sendChat(String input) throws ChatScriptDeliveryException {","[{'comment': 'You need to create own exception, when requires to change the default behavior. Please use a standard one for your use-case.', 'commenter': 'dmvolod'}, {'comment': 'modified.', 'commenter': 'varunblaze'}]"
2653,components/camel-chatscript/src/main/java/org/apache/camel/component/chatscript/ChatScriptProducer.java,"@@ -0,0 +1,73 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.chatscript;
+
+import com.fasterxml.jackson.databind.ObjectMapper;
+import org.apache.camel.Exchange;
+import org.apache.camel.component.chatscript.exception.InvalidInputMessage;
+import org.apache.camel.impl.DefaultProducer;
+
+/**
+ * The ChatScript producer.
+ */
+public class ChatScriptProducer extends DefaultProducer {
+    private ChatScriptEndpoint endpoint;
+    private ObjectMapper mapper = new ObjectMapper();
+    public ChatScriptProducer(ChatScriptEndpoint endpoint) {
+        super(endpoint);
+        this.endpoint = endpoint;
+
+        if (endpoint.isResetChat()) {
+            this.endpoint.getBot().reset();
+        }
+    }
+
+    public void process(Exchange exchange) throws Exception {
+
+        Object body = exchange.getIn().getBody();
+        ChatScriptMessage inputMessage = new ChatScriptMessage();
+        /* use can pass message object as json or the object it self */
+        if (!(body instanceof ChatScriptMessage)) {
+            inputMessage = buildMessage(body);
+        } else {
+            inputMessage = (ChatScriptMessage) body;
+        }
+        String response = this.endpoint.getBot().sendChat(inputMessage);
+        inputMessage.setReply(response);
+        exchange.getOut().setBody(inputMessage);
+    }
+
+    private ChatScriptMessage buildMessage(Object body) throws InvalidInputMessage {
+
+        if (body instanceof String) {
+            return createMessage(String.valueOf(body));
+        }
+        return null;
+    }
+
+    private ChatScriptMessage createMessage(String message) throws InvalidInputMessage {
+        ChatScriptMessage ret = null;
+        try {
+            ret = mapper.readValue(message, ChatScriptMessage.class);
+        } catch (Exception e) {
+            e.printStackTrace();
+            throw new InvalidInputMessage(""Unable to parse the input message. Error Message"" + e.getMessage());","[{'comment': 'You need to create own exception, when requires to change the default behavior. Please use a standard one for your use-case.', 'commenter': 'dmvolod'}, {'comment': 'modified.', 'commenter': 'varunblaze'}]"
2665,components/camel-ftp/src/test/java/org/apache/camel/component/file/remote/sftp/SftpConsumerProcessStrategyTest.java,"@@ -0,0 +1,96 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * <p>
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * <p>
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.file.remote.sftp;
+
+import org.apache.camel.Exchange;
+import org.apache.camel.component.file.GenericFile;
+import org.apache.camel.component.file.GenericFileEndpoint;
+import org.apache.camel.component.file.GenericFileOperations;
+import org.apache.camel.component.file.GenericFileProcessStrategy;
+import org.apache.camel.impl.JndiRegistry;
+import org.junit.Test;
+
+/**
+ * @author Seweryn Walendzik on 12/11/18.","[{'comment': 'please remove', 'commenter': 'onderson'}, {'comment': 'removed', 'commenter': 'swalendzik'}]"
2665,components/camel-ftp/src/test/java/org/apache/camel/component/file/remote/FtpConsumerProcessStrategyTest.java,"@@ -0,0 +1,93 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * <p>
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * <p>
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.file.remote;
+
+import org.apache.camel.Exchange;
+import org.apache.camel.component.file.GenericFile;
+import org.apache.camel.component.file.GenericFileEndpoint;
+import org.apache.camel.component.file.GenericFileOperations;
+import org.apache.camel.component.file.GenericFileProcessStrategy;
+import org.apache.camel.impl.JndiRegistry;
+import org.junit.Test;
+
+/**
+ * @author Seweryn Walendzik on 12/11/18.","[{'comment': 'please remove', 'commenter': 'onderson'}, {'comment': 'removed', 'commenter': 'swalendzik'}]"
2684,camel-core/src/main/java/org/apache/camel/component/file/strategy/FileChangedExclusiveReadLockStrategy.java,"@@ -71,6 +71,11 @@ public boolean acquireExclusiveReadLock(GenericFileOperations<File> operations,
                 }
             }
 
+            if(!target.exists()) {","[{'comment': '```suggestion\r\n        if (!target.exists()) {\r\n            CamelLogger.log(LOG, readLockLoggingLevel,\r\n                    ""Cannot acquire read lock because the file DOES NOT exist. Will skip the file: "" + file);\r\n            return false;\r\n        }\r\n```', 'commenter': 'onderson'}, {'comment': 'Maybe reword it as `the file no longer exists.`', 'commenter': 'davsclaus'}]"
2696,examples/camel-example-cxf-ws-security-signature/pom.xml,"@@ -0,0 +1,164 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one or more
+    contributor license agreements.  See the NOTICE file distributed with
+    this work for additional information regarding copyright ownership.
+    The ASF licenses this file to You under the Apache License, Version 2.0
+    (the ""License""); you may not use this file except in compliance with
+    the License.  You may obtain a copy of the License at
+
+         http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an ""AS IS"" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+
+-->
+<project
+	xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd""
+	xmlns=""http://maven.apache.org/POM/4.0.0""
+	xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"">
+	<modelVersion>4.0.0</modelVersion>
+	
+	<parent>
+      <groupId>org.apache.camel.example</groupId>
+      <artifactId>examples</artifactId>
+      <version>3.0.0-SNAPSHOT</version>
+    </parent>
+  
+	<artifactId>camel-example-cxf-ws-security-signature</artifactId>
+	<packaging>jar</packaging>
+	<name>Camel :: Example :: CXF ::WS-Security Signature  </name>","[{'comment': 'Cosmetic, add space after double colon and remove empty spaces at end of `<name>` tag', 'commenter': 'davsclaus'}]"
2696,examples/camel-example-cxf-ws-security-signature/pom.xml,"@@ -0,0 +1,164 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one or more
+    contributor license agreements.  See the NOTICE file distributed with
+    this work for additional information regarding copyright ownership.
+    The ASF licenses this file to You under the Apache License, Version 2.0
+    (the ""License""); you may not use this file except in compliance with
+    the License.  You may obtain a copy of the License at
+
+         http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an ""AS IS"" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+
+-->
+<project
+	xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd""
+	xmlns=""http://maven.apache.org/POM/4.0.0""
+	xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"">
+	<modelVersion>4.0.0</modelVersion>
+	
+	<parent>
+      <groupId>org.apache.camel.example</groupId>
+      <artifactId>examples</artifactId>
+      <version>3.0.0-SNAPSHOT</version>
+    </parent>
+  
+	<artifactId>camel-example-cxf-ws-security-signature</artifactId>
+	<packaging>jar</packaging>
+	<name>Camel :: Example :: CXF ::WS-Security Signature  </name>
+	<description>CXF example using WS-Security Signature Action</description>
+	
+	<properties>","[{'comment': 'We are using 2-spaces in the pom.xml files for indention, this file seems to use 8 or tabs', 'commenter': 'davsclaus'}]"
2696,examples/camel-example-cxf-ws-security-signature/src/main/java/org/apache/camel/example/cxf/ws/Client.java,"@@ -0,0 +1,55 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.example.cxf.ws;
+
+import java.io.ByteArrayOutputStream;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.net.URL;
+import java.net.URLConnection;
+
+import org.apache.commons.io.IOUtils;
+
+
+public class Client {
+    public static void main(String[] args) {
+        try {
+            new Client().sendRequest();
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+    }
+    
+    public void sendRequest() throws Exception {
+        URLConnection connection = new URL(""http://localhost:8181/cxf/HelloWorldSecurity"")
+                .openConnection();
+        connection.setDoInput(true);
+        connection.setDoOutput(true);
+        OutputStream os = connection.getOutputStream();
+        // Post the request file.
+        InputStream fis = getClass().getClassLoader().getResourceAsStream(""org/apache/camel/example/cxf/ws/request.xml"");
+        System.out.println(fis.toString());
+        IOUtils.copy(fis, os);
+        // Read the response.
+        InputStream is = connection.getInputStream();
+        ByteArrayOutputStream baos = new ByteArrayOutputStream();
+        IOUtils.copy(is, baos);
+        System.out.println(""the response is =====>"");","[{'comment': 'The response ...', 'commenter': 'davsclaus'}]"
2696,examples/pom.xml,"@@ -135,6 +135,7 @@
     <module>camel-example-widget-gadget-java</module>
     <module>camel-example-widget-gadget-xml</module>
     <module>camel-example-zipkin</module>
+    <module>camel-example-cxf-ws-security-signature</module>","[{'comment': 'Add it in the sorted A..Z location, and not at the bottom', 'commenter': 'davsclaus'}]"
2710,components/camel-elasticsearch-rest/src/main/java/org/apache/camel/component/elasticsearch/ElasticsearchConfiguration.java,"@@ -51,6 +51,10 @@
     private boolean disconnect;
     @UriParam(defaultValue = ""false"")
     private boolean enableSSL;
+    @UriParam(defaultValue = ""false"")
+    private boolean useScroll;
+    @UriParam(defaultValue = """" + ElasticsearchConstants.DEFAULT_SCROLL_KEEP_ALIVE_MS)
+    private int scrollKeepAliveMs;","[{'comment': 'If you declare the default scroll keep alive as default Value you have to set on the variable too.', 'commenter': 'oscerd'}, {'comment': 'Ok, I just pushed a fix for this and code style.\r\nThank you @oscerd.', 'commenter': 'ludovic-boutros'}]"
2719,components/camel-olingo4/camel-olingo4-component/src/main/java/org/apache/camel/component/olingo4/Olingo4Consumer.java,"@@ -82,7 +83,15 @@ public void onCanceled() {
                 throw error[0];
             }
 
-            return ApiConsumerHelper.getResultsProcessed(this, result[0], isSplitResult());
+            //
+            // Allow consumer idle properties to properly handle an empty polling response
+            //
+            int processed = ApiConsumerHelper.getResultsProcessed(this, result[0], isSplitResult());","[{'comment': 'We could maybe moved this where `return processed` is so its only evaluated if needed', 'commenter': 'davsclaus'}, {'comment': 'Fixed.', 'commenter': 'phantomjinx'}]"
2719,components/camel-olingo4/camel-olingo4-component/src/main/java/org/apache/camel/component/olingo4/Olingo4Consumer.java,"@@ -82,7 +83,15 @@ public void onCanceled() {
                 throw error[0];
             }
 
-            return ApiConsumerHelper.getResultsProcessed(this, result[0], isSplitResult());
+            //
+            // Allow consumer idle properties to properly handle an empty polling response
+            //
+            int processed = ApiConsumerHelper.getResultsProcessed(this, result[0], isSplitResult());
+            if (result[0] instanceof ClientEntitySet && (((ClientEntitySet) result[0]).getEntities().isEmpty())) {","[{'comment': 'Maybe put this code into `ApiConsumerHelper` as a new method with some kind of name, isEmptyResult or something?', 'commenter': 'davsclaus'}, {'comment': ""Unfortunately, that's not possible since that would pollute ApiConsumerHelper with a dependency on Olingo4 classes, ie. ClientEntitySet. By keeping it here it confines such dependencies."", 'commenter': 'phantomjinx'}]"
2730,examples/camel-example-telegram/pom.xml,"@@ -0,0 +1,47 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<project xmlns=""http://maven.apache.org/POM/4.0.0""
+         xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
+         xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"">
+    <modelVersion>4.0.0</modelVersion>
+
+    <groupId>org.apache.camel.example</groupId>
+    <artifactId>examples</artifactId>
+    <version>3.0.0-SNAPSHOT</version>
+    <properties>
+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
+        <camel.version>3.0.0-SNAPSHOT</camel.version>
+    </properties>
+
+    <dependencies>
+        <dependency>
+            <groupId>org.apache.camel</groupId>
+            <artifactId>camel-telegram</artifactId>
+            <version>${camel.version}</version>
+        </dependency>
+        <dependency>
+            <groupId>junit</groupId>
+            <artifactId>junit</artifactId>
+            <version>4.12</version>","[{'comment': ""Looks like we don't need to set junit version explicitly here"", 'commenter': 'dmvolod'}]"
2730,examples/camel-example-telegram/pom.xml,"@@ -0,0 +1,47 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<project xmlns=""http://maven.apache.org/POM/4.0.0""
+         xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
+         xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"">
+    <modelVersion>4.0.0</modelVersion>
+
+    <groupId>org.apache.camel.example</groupId>
+    <artifactId>examples</artifactId>
+    <version>3.0.0-SNAPSHOT</version>
+    <properties>
+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
+        <camel.version>3.0.0-SNAPSHOT</camel.version>
+    </properties>
+
+    <dependencies>
+        <dependency>
+            <groupId>org.apache.camel</groupId>
+            <artifactId>camel-telegram</artifactId>
+            <version>${camel.version}</version>
+        </dependency>
+        <dependency>
+            <groupId>junit</groupId>
+            <artifactId>junit</artifactId>
+            <version>4.12</version>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.slf4j</groupId>
+            <artifactId>slf4j-simple</artifactId>
+            <version>1.7.21</version>
+        </dependency>
+    </dependencies>
+
+    <build>
+        <plugins>
+            <plugin>
+                <groupId>org.apache.maven.plugins</groupId>
+                <artifactId>maven-compiler-plugin</artifactId>
+                <version>3.8.0</version>","[{'comment': 'The same for maven-compiler-plugin version?', 'commenter': 'dmvolod'}]"
2730,examples/camel-example-telegram/pom.xml,"@@ -0,0 +1,47 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<project xmlns=""http://maven.apache.org/POM/4.0.0""
+         xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
+         xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"">
+    <modelVersion>4.0.0</modelVersion>
+
+    <groupId>org.apache.camel.example</groupId>
+    <artifactId>examples</artifactId>
+    <version>3.0.0-SNAPSHOT</version>
+    <properties>
+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
+        <camel.version>3.0.0-SNAPSHOT</camel.version>
+    </properties>
+
+    <dependencies>
+        <dependency>
+            <groupId>org.apache.camel</groupId>
+            <artifactId>camel-telegram</artifactId>
+            <version>${camel.version}</version>
+        </dependency>
+        <dependency>
+            <groupId>junit</groupId>
+            <artifactId>junit</artifactId>
+            <version>4.12</version>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.slf4j</groupId>
+            <artifactId>slf4j-simple</artifactId>","[{'comment': 'The same for slf4j-simple version?', 'commenter': 'dmvolod'}]"
2730,examples/camel-example-telegram/src/main/java/org/apache/camel/example/telegram/Application.java,"@@ -0,0 +1,36 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.example.telegram;
+
+import org.apache.camel.CamelContext;
+import org.apache.camel.impl.DefaultCamelContext;
+
+public final class Application {
+
+    public static final String AUTHORIZATION_TOKEN = ""665977497:AAE_-dk0zgWEwBK404Y6dJh4B5W3E--qz1c"";","[{'comment': 'Understand, that need to refactor much more, but may be move AUTHORIZATION_TOKEN and CHAT_ID to some properties, configs, Java start props or others. You could work on this right now or later if you want.', 'commenter': 'dmvolod'}, {'comment': 'Maybe it would be better to leave this to the end users as properties then add directly into the code.', 'commenter': 'oscerd'}]"
2759,components/camel-telegram/src/main/java/org/apache/camel/component/telegram/model/SendLocationMessage.java,"@@ -51,14 +48,6 @@ public void setLivePeriod(Integer livePeriod) {
         this.livePeriod = livePeriod;
     }
 
-    public boolean isDisableNotification() {
-        return disableNotification;
-    }
-
-    public void setDisableNotification(boolean disableNotification) {
-        this.disableNotification = disableNotification;
-    }
-","[{'comment': 'Is there a reason to remove this field?', 'commenter': 'oscerd'}, {'comment': 'That field was added by mistake recently.\r\nThat fiels is inherited from: https://github.com/apache/camel/blob/0e0aa95517d117ba6f12504a40dc61492f89e988/components/camel-telegram/src/main/java/org/apache/camel/component/telegram/model/SendLocationMessage.java#L21\r\n\r\nhttps://github.com/apache/camel/blob/d0e04616cebee03ecdd5ed5333ed57a93237b62c/components/camel-telegram/src/main/java/org/apache/camel/component/telegram/model/OutgoingMessage.java#L34', 'commenter': 'DenisIstomin'}]"
2762,components/camel-olingo4/camel-olingo4-component/src/test/java/org/apache/camel/component/olingo4/Olingo4ComponentTest.java,"@@ -402,6 +409,49 @@ public void testProducerReadFilterAlreadySeen() throws Exception {
         }
     }
 
+    /**
+     * Read entity set of the People object and split the results
+     * into individual messages
+     */
+    @Test
+    public void testConsumerReadSplitResults() throws Exception {
+        final Map<String, Object> headers = new HashMap<>();
+        String endpoint = ""olingo4://read/People?consumer.splitResult=true"";
+        int expectedEntities = 20;
+        final ClientEntitySet entities = (ClientEntitySet)requestBodyAndHeaders(endpoint, null, headers);
+        assertNotNull(entities);
+        assertEquals(expectedEntities, entities.getEntities().size());
+
+        int expectedMsgCount = 3;
+        MockEndpoint mockEndpoint = getMockEndpoint(""mock:consumer-splitresult"");","[{'comment': 'You should set your mock expectations before you send data into Camel, so move these lines up in the beginning of the test method, then send data, and then assert on the mock. Do the same in the other unit tests.', 'commenter': 'davsclaus'}, {'comment': 'Done.', 'commenter': 'phantomjinx'}]"
2762,components/camel-olingo4/camel-olingo4-component/src/test/java/org/apache/camel/component/olingo4/Olingo4ComponentTest.java,"@@ -402,6 +409,49 @@ public void testProducerReadFilterAlreadySeen() throws Exception {
         }
     }
 
+    /**
+     * Read entity set of the People object and split the results
+     * into individual messages
+     */
+    @Test
+    public void testConsumerReadSplitResults() throws Exception {
+        final Map<String, Object> headers = new HashMap<>();
+        String endpoint = ""olingo4://read/People?consumer.splitResult=true"";
+        int expectedEntities = 20;
+        final ClientEntitySet entities = (ClientEntitySet)requestBodyAndHeaders(endpoint, null, headers);
+        assertNotNull(entities);
+        assertEquals(expectedEntities, entities.getEntities().size());
+
+        int expectedMsgCount = 3;
+        MockEndpoint mockEndpoint = getMockEndpoint(""mock:consumer-splitresult"");
+        mockEndpoint.expectedMinimumMessageCount(expectedMsgCount);
+        mockEndpoint.assertIsSatisfied();
+
+        //
+        // At least 3 individual messages in the exchange,
+        // each containing a different entity.
+        //
+        for (int i = 0; i < expectedMsgCount; ++i) {
+            Object body = mockEndpoint.getExchanges().get(i).getIn().getBody();
+            assertTrue(body instanceof ClientEntity);
+            ClientEntity entity = (ClientEntity)body;
+            ClientProperty nameProperty = entity.getProperty(""UserName"");
+            assertNotNull(nameProperty);
+
+            switch(i) {","[{'comment': 'There is likely a checkstyle issue here, run mvn install -P checkstyle to see its errors.', 'commenter': 'davsclaus'}, {'comment': 'Done.', 'commenter': 'phantomjinx'}]"
2777,components/camel-salesforce/camel-salesforce-maven-plugin/src/main/resources/sobject-pojo.vm,"@@ -127,24 +127,29 @@ public class $desc.Name extends AbstractDescribedSObjectBase {
         this.$propertyName = $propertyName;
     }
 
-#if ( $utility.isLookup($field) )## IS LOOKUP
+#if ( $utility.isLookup($field) )## EXTERNAL ID","[{'comment': '```suggestion\r\n#if ( $utility.isLookup($field) )## IS LOOKUP\r\n```', 'commenter': 'zregvart'}]"
2777,components/camel-salesforce/camel-salesforce-maven-plugin/src/main/resources/sobject-pojo.vm,"@@ -127,24 +127,29 @@ public class $desc.Name extends AbstractDescribedSObjectBase {
         this.$propertyName = $propertyName;
     }
 
-#if ( $utility.isLookup($field) )## IS LOOKUP
+#if ( $utility.isLookup($field) )## EXTERNAL ID
 #foreach ( $reference in $field.getReferenceTo() )## REFERENCE LOOP
-#foreach ( $externalIds in $utility.externalIdsOf($reference) )## EXTERNAL ID LOOP
-#set( $relationshipAsFieldName = $field.getRelationshipName() )
+#if ( $utility.hasExternalIds($reference) )## IS REFERENCE CONTAIN EXTERNAL ID","[{'comment': '```suggestion\r\n#if ( $utility.hasExternalIds($reference) )## HAS EXTERNAL IDS\r\n```', 'commenter': 'zregvart'}]"
2777,components/camel-salesforce/camel-salesforce-maven-plugin/src/main/resources/sobject-pojo.vm,"@@ -127,24 +127,29 @@ public class $desc.Name extends AbstractDescribedSObjectBase {
         this.$propertyName = $propertyName;
     }
 
-#if ( $utility.isLookup($field) )## IS LOOKUP
+#if ( $utility.isLookup($field) )## EXTERNAL ID
 #foreach ( $reference in $field.getReferenceTo() )## REFERENCE LOOP
-#foreach ( $externalIds in $utility.externalIdsOf($reference) )## EXTERNAL ID LOOP
-#set( $relationshipAsFieldName = $field.getRelationshipName() )
+#if ( $utility.hasExternalIds($reference) )## IS REFERENCE CONTAIN EXTERNAL ID
+#set( $fieldName = $field.getName() )
+#if ( $fieldName.endsWith(""Id"") )## JSON PROPERTY NAME SETTER
+#set( $jsonPropertyName = $fieldName.substring(0, $fieldName.length() - 2) )
+#else
+#set( $jsonPropertyName = $fieldName.replace(""__c"", ""__r"") )
+#end
 #set( $lookupObjectType = $reference )
-    private ${lookupObjectType}_Lookup $relationshipAsFieldName;
+    private ${lookupObjectType}_Lookup ${fieldName}_Lookup;
 
-    @JsonProperty(""$relationshipAsFieldName"")
-    public ${lookupObjectType}_Lookup get$relationshipAsFieldName() {
-        return this.$relationshipAsFieldName;
+    @JsonProperty(""$jsonPropertyName"")
+    public ${lookupObjectType}_Lookup get${fieldName}_Lookup() {
+        return this.${fieldName}_Lookup;
     }
 
-    @JsonProperty(""$relationshipAsFieldName"")
-    public void set$relationshipAsFieldName(${lookupObjectType}_Lookup $relationshipAsFieldName) {
-        this.$relationshipAsFieldName = $relationshipAsFieldName;
+    @JsonProperty(""$jsonPropertyName"")
+    public void set$fieldName(${lookupObjectType}_Lookup ${fieldName}_Lookup) {
+        this.${fieldName}_Lookup = ${fieldName}_Lookup;
     }
+#end## IS REFERENCE CONTAIN EXTERNAL ID","[{'comment': '```suggestion\r\n#end## HAS EXTERNAL IDS\r\n```', 'commenter': 'zregvart'}]"
2777,components/camel-salesforce/camel-salesforce-maven-plugin/src/main/resources/sobject-pojo.vm,"@@ -127,24 +127,29 @@ public class $desc.Name extends AbstractDescribedSObjectBase {
         this.$propertyName = $propertyName;
     }
 
-#if ( $utility.isLookup($field) )## IS LOOKUP
+#if ( $utility.isLookup($field) )## EXTERNAL ID
 #foreach ( $reference in $field.getReferenceTo() )## REFERENCE LOOP
-#foreach ( $externalIds in $utility.externalIdsOf($reference) )## EXTERNAL ID LOOP
-#set( $relationshipAsFieldName = $field.getRelationshipName() )
+#if ( $utility.hasExternalIds($reference) )## IS REFERENCE CONTAIN EXTERNAL ID
+#set( $fieldName = $field.getName() )
+#if ( $fieldName.endsWith(""Id"") )## JSON PROPERTY NAME SETTER","[{'comment': '```suggestion\r\n#if ( $fieldName.endsWith(""Id"") )## PROPERTY IS ID\r\n```', 'commenter': 'zregvart'}]"
2777,components/camel-salesforce/camel-salesforce-maven-plugin/src/main/resources/sobject-pojo.vm,"@@ -127,24 +127,29 @@ public class $desc.Name extends AbstractDescribedSObjectBase {
         this.$propertyName = $propertyName;
     }
 
-#if ( $utility.isLookup($field) )## IS LOOKUP
+#if ( $utility.isLookup($field) )## EXTERNAL ID
 #foreach ( $reference in $field.getReferenceTo() )## REFERENCE LOOP
-#foreach ( $externalIds in $utility.externalIdsOf($reference) )## EXTERNAL ID LOOP
-#set( $relationshipAsFieldName = $field.getRelationshipName() )
+#if ( $utility.hasExternalIds($reference) )## IS REFERENCE CONTAIN EXTERNAL ID
+#set( $fieldName = $field.getName() )
+#if ( $fieldName.endsWith(""Id"") )## JSON PROPERTY NAME SETTER
+#set( $jsonPropertyName = $fieldName.substring(0, $fieldName.length() - 2) )
+#else
+#set( $jsonPropertyName = $fieldName.replace(""__c"", ""__r"") )
+#end","[{'comment': '```suggestion\r\n#end ## PROPERTY IS ID\r\n```', 'commenter': 'zregvart'}]"
2777,components/camel-salesforce/camel-salesforce-maven-plugin/src/main/resources/sobject-pojo.vm,"@@ -127,24 +127,29 @@ public class $desc.Name extends AbstractDescribedSObjectBase {
         this.$propertyName = $propertyName;
     }
 
-#if ( $utility.isLookup($field) )## IS LOOKUP
+#if ( $utility.isLookup($field) )## EXTERNAL ID
 #foreach ( $reference in $field.getReferenceTo() )## REFERENCE LOOP
-#foreach ( $externalIds in $utility.externalIdsOf($reference) )## EXTERNAL ID LOOP
-#set( $relationshipAsFieldName = $field.getRelationshipName() )
+#if ( $utility.hasExternalIds($reference) )## IS REFERENCE CONTAIN EXTERNAL ID
+#set( $fieldName = $field.getName() )
+#if ( $fieldName.endsWith(""Id"") )## JSON PROPERTY NAME SETTER
+#set( $jsonPropertyName = $fieldName.substring(0, $fieldName.length() - 2) )","[{'comment': 'What happens here if the property is `""Id""`?', 'commenter': 'zregvart'}, {'comment': 'Then it would never be considered for this block of code - Id is a standard salesforce field and it never is a Lookup.', 'commenter': 'przemyslaw-lenik'}]"
2781,camel-core/src/main/java/org/apache/camel/model/rest/RestConfigurationDefinition.java,"@@ -773,6 +776,14 @@ public RestConfigurationDefinition corsAllowCredentials(boolean corsAllowCredent
     }
 
 
+    /**
+     * To specify whether to use X-Forward headers for Host and related setting
+     */
+    public RestConfigurationDefinition useXForwardHeaders(boolean useXForwardHeaders) {
+        setUseXForwardHeaders(useXForwardHeaders);
+        return this;
+    }
+
     // Implementation","[{'comment': 'Fix checkstyle issue here', 'commenter': 'davsclaus'}]"
2781,camel-core/src/main/java/org/apache/camel/model/rest/RestConfigurationDefinition.java,"@@ -907,7 +918,24 @@ public RestConfiguration asRestConfiguration(CamelContext context) throws Except
             }
             answer.setCorsHeaders(props);
         }
+        if (useXForwardHeaders != null) {
+            answer.setUseXForwardHeaders(useXForwardHeaders);
+        }
         return answer;
     }
 
+
+    public Boolean getUseXForwardHeaders() {
+        return useXForwardHeaders;
+    }
+
+    /**
+     * Whether to enable CORS headers in the HTTP response.
+     * <p/>
+     * The default value is false.","[{'comment': 'The comment say false, but its true', 'commenter': 'davsclaus'}]"
2781,camel-core/src/main/java/org/apache/camel/model/rest/RestConfigurationDefinition.java,"@@ -58,6 +58,9 @@
     @XmlAttribute
     private String apiHost;
 
+    @XmlAttribute","[{'comment': 'If this is true, then you need to add `@Metadata(defaultValue = ""true"")`', 'commenter': 'davsclaus'}]"
2792,components/camel-spring-redis/src/main/docs/spring-redis-component.adoc,"@@ -76,18 +76,6 @@ with the following path and query parameters:
 // spring-boot-auto-configure options: START
 === Spring Boot Auto-Configuration
 
-When using Spring Boot make sure to use the following Maven dependency to have support for auto configuration:
-
-[source,xml]
-----
-<dependency>
-  <groupId>org.apache.camel</groupId>
-  <artifactId>camel-spring-redis-starter</artifactId>
-  <version>x.x.x</version>
-  <!-- use the same version as your Camel core version -->
-</dependency>
-----
-","[{'comment': 'This must be maintained.', 'commenter': 'oscerd'}]"
2794,components/camel-jms/src/main/java/org/apache/camel/component/jms/reply/CorrelationTimeoutMap.java,"@@ -17,108 +17,62 @@
 package org.apache.camel.component.jms.reply;
 
 import java.util.concurrent.ExecutorService;
-import java.util.concurrent.ScheduledExecutorService;
 
-import org.apache.camel.support.DefaultTimeoutMap;
+import org.apache.camel.TimeoutMap;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 /**
  * A {@link org.apache.camel.TimeoutMap} which is used to track reply messages which
  * has been timed out, and thus should trigger the waiting {@link org.apache.camel.Exchange} to
- * timeout as well.
+ * timeout as well. Zero (or negative) timeout means infinite but is actually encoded as {@link Integer#MAX_VALUE}
+ * which is 24 days.
  */
-public class CorrelationTimeoutMap extends DefaultTimeoutMap<String, ReplyHandler> {
+public class CorrelationTimeoutMap implements TimeoutMap<String, ReplyHandler> {
 
-    private CorrelationListener listener;
-    private ExecutorService executorService;
+    private static final Logger log = LoggerFactory.getLogger(CorrelationTimeoutMap.class);
+    private final ExecutorService executorService;
+    private final TimeoutMap<String, ReplyHandler> delegate;
 
-    public CorrelationTimeoutMap(ScheduledExecutorService executor, long requestMapPollTimeMillis, ExecutorService executorService) {
-        super(executor, requestMapPollTimeMillis);
+    public CorrelationTimeoutMap(TimeoutMap<String, ReplyHandler> delegate, ExecutorService executorService) {
+        this.delegate = delegate;
+        delegate.addListener(this::onEviction);
         this.executorService = executorService;
     }
 
-    public void setListener(CorrelationListener listener) {
-        // there is only one listener needed
-        this.listener = listener;
+    private static long encode(long timeoutMillis) {
+        return timeoutMillis > 0 ? timeoutMillis : Integer.MAX_VALUE; // TODO why not Long.MAX_VALUE!","[{'comment': 'I can change to Long.MAX_VALUE if requested', 'commenter': 'drekbour'}]"
2794,core/camel-api/src/main/java/org/apache/camel/TimeoutMap.java,"@@ -19,7 +19,7 @@
 /**
  * Represents a map of values which timeout after a period of inactivity.
  */
-public interface TimeoutMap<K, V> extends Runnable {
+public interface TimeoutMap<K, V> extends Service {","[{'comment': ""Didn't really want to add `Service` here but it's required to decorate `DefaultTimeoutMap`"", 'commenter': 'drekbour'}]"
2794,core/camel-api/src/main/java/org/apache/camel/TimeoutMap.java,"@@ -67,16 +61,6 @@
      */
     V putIfAbsent(K key, V value, long timeoutMillis);
 
-    /**
-     * Callback when the value has been evicted
-     *
-     * @param key the key
-     * @param value the value
-     * @return <tt>true</tt> to remove the evicted value,
-     *         or <tt>false</tt> to veto the eviction and thus keep the value.
-     */
-    boolean onEviction(K key, V value);","[{'comment': '`purge` and `onEviction` are specific to `DefaultTimeoutMap` and were never accessed via the interface', 'commenter': 'drekbour'}]"
2794,core/camel-api/src/main/java/org/apache/camel/TimeoutMap.java,"@@ -29,13 +29,6 @@
      */
     V get(K key);
 
-    /**
-     * Returns a copy of the keys in the map
-     *
-     * @return the keys
-     */
-    Object[] getKeys();","[{'comment': 'Unused + there is no generic design purpose of returning an Object[] here.', 'commenter': 'drekbour'}]"
2794,core/camel-core/src/test/java/org/apache/camel/support/DefaultTimeoutMapTest.java,"@@ -71,15 +72,15 @@ public void testDefaultTimeoutMapPurge() throws Exception {
     @Test
     public void testDefaultTimeoutMapForcePurge() throws Exception {
         DefaultTimeoutMap<String, Integer> map = new DefaultTimeoutMap<>(executor, 100);
-        map.start();
+        // map.start(); // Do not start background purge","[{'comment': 'Was not testing the method call it claimed to', 'commenter': 'drekbour'}]"
2794,core/camel-core/src/test/java/org/apache/camel/support/DefaultTimeoutMapTest.java,"@@ -176,9 +159,6 @@ public boolean onEviction(String key, Integer value) {
 
         Thread.sleep(250);
 
-        // force purge","[{'comment': 'This call invalidated the test of polling behaviour by forcing the purge', 'commenter': 'drekbour'}]"
2794,core/camel-support/src/main/java/org/apache/camel/support/DefaultTimeoutMap.java,"@@ -90,91 +95,83 @@ public V get(K key) {
         }
         return entry.getValue();
     }
-    
+
     public V put(K key, V value, long timeoutMillis) {
         TimeoutMapEntry<K, V> entry = new TimeoutMapEntry<>(key, value, timeoutMillis);
         lock.lock();
         try {
             updateExpireTime(entry);
             TimeoutMapEntry<K, V> result = map.put(key, entry);
-            return result != null ? result.getValue() : null;
+            return unwrap(result);
         } finally {
             lock.unlock();
+            emitEvent(Put, key, value);
         }
     }
     
     public V putIfAbsent(K key, V value, long timeoutMillis) {
         TimeoutMapEntry<K, V> entry = new TimeoutMapEntry<>(key, value, timeoutMillis);
+        TimeoutMapEntry<K, V> result = null;
         lock.lock();
         try {
             updateExpireTime(entry);
             //Just make sure we don't override the old entry
-            TimeoutMapEntry<K, V> result = map.putIfAbsent(key, entry);
-            return result != null ? result.getValue() : null;
+            result = map.putIfAbsent(key, entry);
+            return unwrap(result);
         } finally {
             lock.unlock();
+            if (result != entry) {","[{'comment': 'To clarify, `Put` event emitted only if key was absent.', 'commenter': 'drekbour'}]"
2794,core/camel-support/src/main/java/org/apache/camel/support/DefaultTimeoutMap.java,"@@ -190,41 +188,18 @@ public void purge() {
             // if we found any expired then we need to sort, onEviction and remove
             if (!expired.isEmpty()) {
                 // sort according to the expired time so we got the first expired first
-                expired.sort(new Comparator<TimeoutMapEntry<K, V>>() {
-                    public int compare(TimeoutMapEntry<K, V> a, TimeoutMapEntry<K, V> b) {
-                        long diff = a.getExpireTime() - b.getExpireTime();
-                        if (diff == 0) {
-                            return 0;
-                        }
-                        return diff > 0 ? 1 : -1;
-                    }
-                });
-
-                List<K> evicts = new ArrayList<>(expired.size());
-                try {
-                    // now fire eviction notification
-                    for (TimeoutMapEntry<K, V> entry : expired) {
-                        boolean evict = false;
-                        try {
-                            evict = onEviction(entry.getKey(), entry.getValue());
-                        } catch (Throwable t) {
-                            log.warn(""Exception happened during eviction of entry ID {}, won't evict and will continue trying: {}"", 
-                                    entry.getValue(), t);
-                        }
-                        if (evict) {
-                            // okay this entry should be evicted
-                            evicts.add(entry.getKey());
-                        }
-                    }
-                } finally {
-                    // and must remove from list after we have fired the notifications
-                    for (K key : evicts) {
-                        map.remove(key);
-                    }
+                expired.sort(comparing(TimeoutMapEntry::getExpireTime));
+
+                // and must remove from list after we have fired the notifications
+                for (TimeoutMapEntry<K, V> entry : expired) {
+                    map.remove(entry.getKey());
                 }
             }
         } finally {
             lock.unlock();
+            for (TimeoutMapEntry<K, V> entry : expired) {","[{'comment': 'This is perhaps the only point of discussion. Notification occurs after eviction and _outside_ of the lock.', 'commenter': 'drekbour'}, {'comment': 'At first thought I think this is okay, as its only a notification, and you cannot veto an eviction', 'commenter': 'davsclaus'}]"
2794,components/camel-jms/src/main/java/org/apache/camel/component/jms/reply/MessageSelectorCreator.java,"@@ -70,18 +72,18 @@ public synchronized String get() {
         return answer;
     }
 
-    public void onPut(String key) {
-        dirty = true;
-        correlationIds.add(key);
-    }
-
-    public void onRemove(String key) {
+    // Changes to live correlation-ids invalidate existing message selector
+    private void timeoutEvent(TimeoutMap.Listener.Type type, String cid) {","[{'comment': 'Can we avoid the switch as its not common practice and maybe people dont know about how it works and would think that remove and put does nothing in this example etc. Make the code understandable and maintainable for everyone.', 'commenter': 'davsclaus'}, {'comment': ""To clarify, you want me remove the `Listener.Type` enum and add individual `onRemoved`, `onPut`, `onEvicted` methods?\r\n\r\nIt's a shame as, generally speaking, we lose the ability to specify the listener as a (private) method::reference and many users seem to always implement internal listener interfaces on their (public) class signature rather than creating an anon class to do the work behind the scenes. I guess those are the same users who will fail to pay attention to the `Type`. Is this really Camel's problem or theirs? Your call obviously :)\r\n"", 'commenter': 'drekbour'}, {'comment': 'No just rewrite the switch to use if .. elseif ... else style', 'commenter': 'davsclaus'}, {'comment': 'done, please check', 'commenter': 'drekbour'}]"
2794,components/camel-jms/src/main/java/org/apache/camel/component/jms/reply/ReplyManagerSupport.java,"@@ -267,7 +269,8 @@ protected void doStart() throws Exception {
         // timeout map to use for purging messages which have timed out, while waiting for an expected reply
         // when doing request/reply over JMS
         log.trace(""Using timeout checker interval with {} millis"", endpoint.getRequestTimeoutCheckerInterval());
-        correlation = new CorrelationTimeoutMap(scheduledExecutorService, endpoint.getRequestTimeoutCheckerInterval(), executorService);
+        TimeoutMap<String, ReplyHandler> timeoutMap = new DefaultTimeoutMap<>(scheduledExecutorService, endpoint.getRequestTimeoutCheckerInterval());","[{'comment': 'Its a bit map in map in map ;). Just wonder if we could avoid all the delegate/wrapping, and let it be so you can extend DefaultTimeoutMap as before', 'commenter': 'davsclaus'}, {'comment': 'Committed the change requested. I looked at both extensions and their additional function:\r\n1 trace logging - can be implemented in the local listener\r\n2 putIfAbsent() logging is redundant as the (sole) calling method repeats it org.apache.camel.component.rabbitmq.reply.ReplyManagerSupport#registerReply\r\n3 Support for -1 maximum timeout. This could be generalised into `DefaultTimeoutMap`? Currently default supports all negative timeouts as meaning ""accept but evict immediately in next poll"". There is a change in semantics if we mean negative to say ""never evict"" (+need to decide if this means `Integer.MAX_VALUE` or `Long.MAX_VALUE`)\r\n\r\nI have implemented 1 and 2. If we go for 3 then both extensions become nothing more than Factory Methods constructing a `DefaultTimeoutMap`', 'commenter': 'drekbour'}]"
2794,components/camel-rabbitmq/src/main/java/org/apache/camel/component/rabbitmq/reply/CorrelationTimeoutMap.java,"@@ -16,97 +16,58 @@
  */
 package org.apache.camel.component.rabbitmq.reply;
 
-import java.util.concurrent.ScheduledExecutorService;
-
-import org.apache.camel.support.DefaultTimeoutMap;
+import org.apache.camel.TimeoutMap;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 /**
  * A {@link org.apache.camel.TimeoutMap} which is used to track reply messages which
  * has been timed out, and thus should trigger the waiting {@link org.apache.camel.Exchange} to
  * timeout as well.
  */
-public class CorrelationTimeoutMap extends DefaultTimeoutMap<String, ReplyHandler> {
+public class CorrelationTimeoutMap implements TimeoutMap<String, ReplyHandler> {","[{'comment': 'Its a bit map in map in map ;). Just wonder if we could avoid all the delegate/wrapping, and let it be so you can extend DefaultTimeoutMap as before', 'commenter': 'davsclaus'}]"
2795,components/camel-ipfs/src/main/java/org/apache/camel/component/ipfs/IPFSComponent.java,"@@ -54,6 +59,11 @@ protected Endpoint createEndpoint(String urispec, String remaining, Map<String,
         config.setIpfsCmd(cmd);
 
         client = createClient(config);
+        try {","[{'comment': 'See JIRA comment about not having such logic here, but it belongs in doStart/doStop etc.', 'commenter': 'davsclaus'}]"
2795,components/camel-ipfs/src/main/java/org/apache/camel/component/ipfs/IPFSEndpoint.java,"@@ -117,6 +117,8 @@ Path ipfsGet(String cid, Path outdir) throws IOException, TimeoutException {
     }
 
     private IPFSClient ipfs() {
-        return getComponent().getIPFSClient();
+        IPFSClient client = getComponent().getIPFSClient();","[{'comment': 'Okay this is better where it can self-heal and reconnect. \r\n\r\nFix checkstyle issue however!', 'commenter': 'davsclaus'}]"
2802,components/camel-jooq/pom.xml,"@@ -0,0 +1,101 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<project xmlns=""http://maven.apache.org/POM/4.0.0""
+         xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
+         xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"">
+    <parent>
+        <artifactId>components</artifactId>
+        <groupId>org.apache.camel</groupId>
+        <version>3.0.0-SNAPSHOT</version>
+    </parent>
+    <modelVersion>4.0.0</modelVersion>
+
+    <artifactId>camel-jooq</artifactId>
+    <packaging>jar</packaging>
+    <name>Camel :: JOOQ</name>
+    <description>Camel JOOQ support</description>
+
+    <properties>
+        <org.jooq.version>3.11.9</org.jooq.version>","[{'comment': 'This property placeholder can be in parent/pom', 'commenter': 'oscerd'}, {'comment': 'Thanks, fixed', 'commenter': 'DenisIstomin'}]"
2802,components/camel-jooq/src/main/java/org/apache/camel/component/jooq/JooqConsumer.java,"@@ -0,0 +1,48 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.camel.component.jooq;
+
+import org.apache.camel.Endpoint;
+import org.apache.camel.Processor;
+import org.apache.camel.support.ScheduledPollConsumer;
+
+public class JooqConsumer extends ScheduledPollConsumer {
+    private final Processor processor;
+    private final JooqEndpoint jooqEndpoint;
+
+    public JooqConsumer(JooqEndpoint jooqEndpoint, Processor processor) {
+        super(jooqEndpoint, processor);
+        this.jooqEndpoint = jooqEndpoint;
+        this.processor = processor;
+    }
+
+    @Override
+    public Processor getProcessor() {
+        return processor;
+    }
+
+    @Override
+    public Endpoint getEndpoint() {
+        return jooqEndpoint;
+    }
+
+    @Override
+    protected int poll() {
+        return 0;","[{'comment': ""Why this consumer always return 0? If the consumer doesn't do anything, it's better to avoid its support."", 'commenter': 'oscerd'}, {'comment': 'you can raise an UnsupportedOperationException in your createConsumer.\r\n\r\n`throw new UnsupportedOperationException(""You cannot receive messages from this endpoint"");`', 'commenter': 'oscerd'}, {'comment': ""Yes, consumer doesn't do anything. I'll delete it. I'll implement it later with task CAMEL-13261."", 'commenter': 'DenisIstomin'}]"
2805,platforms/spring-boot/spring-boot-dm/camel-spring-boot-dependencies/pom.xml,"@@ -3431,7 +3431,7 @@
       <dependency>
         <groupId>org.apache.mina</groupId>
         <artifactId>mina-core</artifactId>
-        <version>2.0.17</version>
+        <version>2.0.20</version>","[{'comment': 'Did you check the Karaf feature :-)', 'commenter': 'oscerd'}]"
2805,pom.xml,"@@ -61,7 +61,7 @@
     <errorprone-version>2.5</errorprone-version>
     <mycila-license-version>3.0</mycila-license-version>
     <gmavenplus-plugin-version>1.6.2</gmavenplus-plugin-version>
-    <groovy-version>2.5.5</groovy-version>
+    <groovy-version>2.5.6</groovy-version>","[{'comment': 'Did you check the Karaf feature? :-)', 'commenter': 'oscerd'}]"
2805,components/camel-properties/src/main/java/org/apache/camel/component/properties/DefaultPropertiesParser.java,"@@ -318,7 +318,14 @@ private String doGetPropertyValue(String key) {
                 }
             }
             if (value == null && envMode == PropertiesComponent.ENVIRONMENT_VARIABLES_MODE_OVERRIDE) {
-                value = System.getenv(key);
+                // lookup OS env with upper case key","[{'comment': '@davsclaus , what do you think about to move common code to the separate function?', 'commenter': 'dmvolod'}, {'comment': 'Yeah we can do that', 'commenter': 'davsclaus'}]"
2810,core/camel-core/pom.xml,"@@ -323,11 +323,11 @@
             </lifecycleMappingMetadata>
           </configuration>
         </plugin>
+<!--  ","[{'comment': ""Why don't you remove? "", 'commenter': 'onderson'}, {'comment': 'sorry, missed that after testing it out', 'commenter': 'CodeSmell'}]"
2825,components/camel-jbpm/pom.xml,"@@ -156,11 +156,31 @@
         </dependency>
     </dependencies>
     <build>
+        <sourceDirectory>${project.build.directory}/generated-sources/java</sourceDirectory>
         <resources>
             <resource>
                 <directory>src/main/resources</directory>
                 <filtering>true</filtering>
             </resource>
         </resources>
+        <plugins>
+            <plugin>
+                <groupId>org.codehaus.mojo</groupId>
+                <artifactId>templating-maven-plugin</artifactId>","[{'comment': 'It would be nice to store templating-maven-plugin-version inside the parent/pom.xml for common update support\r\nOtherwise, LGTM', 'commenter': 'dmvolod'}]"
2835,tooling/maven/camel-maven-plugin/src/main/java/org/apache/camel/maven/RouteCoverageMojo.java,"@@ -192,12 +205,37 @@ public void execute() throws MojoExecutionException, MojoFailureException {
 
         List<CamelNodeDetails> routeIdTrees = routeTrees.stream().filter(t -> t.getRouteId() != null).collect(Collectors.toList());
         List<CamelNodeDetails> anonymousRouteTrees = routeTrees.stream().filter(t -> t.getRouteId() == null).collect(Collectors.toList());
-
+                
+     // creates the folder for the xml.file
+        
+        File file =  (new File(project.getBasedir() + ""/target/site/jacoco""));
+        if (file.exists()){","[{'comment': 'We dont need this info logging as its just annoying. Instead it can be something about ""generating jacoco report"".', 'commenter': 'davsclaus'}]"
2835,tooling/maven/camel-maven-plugin/src/main/java/org/apache/camel/maven/RouteCoverageMojo.java,"@@ -208,14 +246,60 @@ public void execute() throws MojoExecutionException, MojoFailureException {
                     List<RouteCoverageNode> coverage = gatherRouteCoverageSummary(Collections.singletonList(t), coverageData);
                     String out = templateCoverageData(fileName, routeId, coverage, notCovered);
                     getLog().info(""Route coverage summary:\n\n"" + out);
-                    getLog().info("""");
+                    getLog().info("""");                   ","[{'comment': 'Can all of this code below be moved into its own method', 'commenter': 'davsclaus'}]"
2835,tooling/maven/camel-maven-plugin/src/main/java/org/apache/camel/maven/RouteCoverageMojo.java,"@@ -348,10 +441,53 @@ private String templateCoverageData(String fileName, String routeId, List<RouteC
         double percentage = ((double) covered / (double) model.size()) * 100;
         sw.println();
         sw.println(""Coverage: "" + covered + "" out of "" + model.size() + "" ("" + String.format(""%.1f"", percentage) + ""%)"");
-        sw.println();
-
+              
         return bos.toString();
+    }    
+    
+    private Attr createAttrInt(Document doc, Element e, String name, Integer value) {
+    	Attr a = doc.createAttribute(name);
+    	a.setValue(value.toString());
+    	e.setAttributeNode(a);
+    	
+    	return a;
+    }
+    
+    private Attr createAttrString(Document doc, Element e, String name, String value) {
+    	Attr a = doc.createAttribute(name);
+    	a.setValue(value);
+    	e.setAttributeNode(a);
+    	
+    	return a;
+    }
+    
+    private Document createDocument() {
+    	Document document = null;
+    	try {	
+    	    DocumentBuilderFactory documentFactory = DocumentBuilderFactory.newInstance();        
+    	    DocumentBuilder documentBuilder = documentFactory.newDocumentBuilder();
+    	    document = documentBuilder.newDocument();
+        
+        } catch (ParserConfigurationException pce) {
+            pce.printStackTrace();","[{'comment': 'dont do this but let the exception be propagated  back up so we can have a better error reporting about not possible to generate jacoco report due to ....\r\n\r\nAlso these methods can be static methods', 'commenter': 'davsclaus'}]"
2837,components/camel-mllp/src/test/java/org/apache/camel/component/mllp/MllpEndpointTest.java,"@@ -16,33 +16,38 @@
  */
 package org.apache.camel.component.mllp;
 
-import org.junit.Before;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
 
 /**
  * Tests for the MllpEndpoint class.
+ *
+ * @author vishal423","[{'comment': ""Please remove the @author doc, we don't use it. Thanks"", 'commenter': 'oscerd'}, {'comment': 'sure', 'commenter': 'vishal423'}]"
2843,components/camel-stax/src/main/java/org/apache/camel/component/stax/StAXProcessor.java,"@@ -49,25 +51,34 @@ public StAXProcessor(ContentHandler contentHandler) {
 
     @Override
     public void process(Exchange exchange) throws Exception {
-        InputSource is = exchange.getIn().getMandatoryBody(InputSource.class);
-        XMLStreamReader stream = exchange.getIn().getMandatoryBody(XMLStreamReader.class);
-        XMLReader reader = new StaxStreamXMLReader(stream);
-
-        ContentHandler handler;
-        if (contentHandlerClass != null) {
-            handler = contentHandlerClass.newInstance();
-        } else {
-            handler = contentHandler;
-        }
-        reader.setContentHandler(handler);
-        reader.parse(is);
+        XMLStreamReader stream = null;
+        try {
+            stream = exchange.getIn().getMandatoryBody(XMLStreamReader.class);
+            StaxStreamXMLReader reader = new StaxStreamXMLReader(stream);
+            ContentHandler handler;
+            if (this.contentHandlerClass != null) {
+                handler = (ContentHandler) this.contentHandlerClass.newInstance();
+            } else {
+                handler = this.contentHandler;
+            }
 
-        if (ExchangeHelper.isOutCapable(exchange)) {
-            // preserve headers
-            exchange.getOut().setHeaders(exchange.getIn().getHeaders());
-            exchange.getOut().setBody(handler);
-        } else {
-            exchange.getIn().setBody(handler);
+            reader.setContentHandler(handler);
+            // InputSource is ignored anyway
+            reader.parse((InputSource) null);
+            if (ExchangeHelper.isOutCapable(exchange)) {
+                exchange.getOut().setHeaders(exchange.getIn().getHeaders());
+                exchange.getOut().setBody(handler);
+            } else {
+                exchange.getIn().setBody(handler);
+            }
+        } finally {
+            if (stream != null) {
+                stream.close();
+                if (stream instanceof ValidatingStreamReader) {
+                    // didn't find any method without using the woodstox package
+                    ((ValidatingStreamReader) stream).closeCompletely();","[{'comment': ""Doesn't find any other way to close the associated input source...."", 'commenter': 'asirbu2002'}]"
2843,components/camel-stax/src/main/java/org/apache/camel/component/stax/StAXProcessor.java,"@@ -49,25 +51,34 @@ public StAXProcessor(ContentHandler contentHandler) {
 
     @Override
     public void process(Exchange exchange) throws Exception {
-        InputSource is = exchange.getIn().getMandatoryBody(InputSource.class);","[{'comment': 'This lines open a new FileInputStream, but is not needed, as the method reader.parse(is) ignore this parameter', 'commenter': 'asirbu2002'}]"
2843,components/camel-stax/src/main/java/org/apache/camel/component/stax/StAXProcessor.java,"@@ -49,25 +51,34 @@ public StAXProcessor(ContentHandler contentHandler) {
 
     @Override
     public void process(Exchange exchange) throws Exception {
-        InputSource is = exchange.getIn().getMandatoryBody(InputSource.class);
-        XMLStreamReader stream = exchange.getIn().getMandatoryBody(XMLStreamReader.class);","[{'comment': 'This line also open a FileInputStream, which is not closed. \r\nThe only way I find to close it is by casting the stream to the woodstox class (see finally clause).', 'commenter': 'asirbu2002'}]"
2844,core/camel-core/src/main/java/org/apache/camel/impl/JsonApiDataFormat.java,"@@ -0,0 +1,88 @@
+package org.apache.camel.impl;
+
+import com.github.jasminb.jsonapi.JSONAPIDocument;
+import com.github.jasminb.jsonapi.ResourceConverter;
+import org.apache.camel.Exchange;
+import org.apache.camel.spi.DataFormat;
+import org.apache.camel.spi.DataFormatName;
+import org.apache.camel.spi.annotations.Dataformat;
+import org.apache.camel.support.service.ServiceSupport;
+
+import java.io.InputStream;
+import java.io.OutputStream;
+
+/**
+ * JsonApi {@link org.apache.camel.spi.DataFormat} for marshal/unmarshal
+ */
+@Dataformat(""jsonApi"")
+public class JsonApiDataFormat extends ServiceSupport implements DataFormat, DataFormatName {","[{'comment': 'Except model, this can be moved into another data format in components directory.', 'commenter': 'onderson'}]"
2844,core/camel-core/src/main/java/org/apache/camel/model/dataformat/JsonApiDataFormat.java,"@@ -0,0 +1,41 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.model.dataformat;
+
+import org.apache.camel.model.DataFormatDefinition;
+import org.apache.camel.spi.DataFormat;
+import org.apache.camel.spi.Metadata;
+import org.apache.camel.spi.RouteContext;
+
+import javax.xml.bind.annotation.XmlAccessType;
+import javax.xml.bind.annotation.XmlAccessorType;
+import javax.xml.bind.annotation.XmlRootElement;
+
+/**
+ * JSON API data format is used to unmarshal a JSON API payload to POJO or to marshal POJO back to JSON API payload.
+ */
+@Metadata(firstVersion = ""3.0.0"", label = ""dataformat,transformation,jsonapi"", title = ""JsonApi"")
+@XmlRootElement(name = ""jsonapi"")
+@XmlAccessorType(XmlAccessType.FIELD)
+public class JsonApiDataFormat extends DataFormatDefinition {","[{'comment': 'As above my comment, see other data formats like CSV, zip, tar etc..', 'commenter': 'onderson'}]"
2844,core/camel-core/src/test/java/org/apache/camel/impl/JsonApiDataFormatTest.java,"@@ -0,0 +1,149 @@
+package org.apache.camel.impl;
+
+import com.github.jasminb.jsonapi.exceptions.DocumentSerializationException;
+import com.github.jasminb.jsonapi.exceptions.UnregisteredTypeException;
+import org.apache.camel.CamelContext;
+import org.apache.camel.Exchange;
+import org.apache.camel.ProducerTemplate;
+import org.apache.camel.TestSupport;
+import org.apache.camel.support.DefaultExchange;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Ignore;
+import org.junit.Test;
+
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+
+public class JsonApiDataFormatTest extends TestSupport {
+
+    private CamelContext context;
+    private ProducerTemplate producer;
+    JsonApiDataFormat jsonApiDataFormat;
+
+    @Override
+    @Before
+    public void setUp() throws Exception {
+        context = new DefaultCamelContext();
+        context.setTracing(true);
+        producer = context.createProducerTemplate();
+        producer.start();
+    }
+
+    @Override
+    @After
+    public void tearDown() throws Exception {
+        producer.stop();
+        context.stop();
+    }
+
+    @Test
+    public void test_jsonApi_marshal() throws Exception {
+        Class<?>[] formats = { MyBook.class, MyAuthor.class };
+        jsonApiDataFormat = new JsonApiDataFormat();
+        jsonApiDataFormat.setDataFormatTypes(formats);
+
+        MyBook book = this.generateTestDataAsObject();
+
+        Exchange exchange = new DefaultExchange(context);
+        ByteArrayOutputStream baos = new ByteArrayOutputStream();
+        jsonApiDataFormat.marshal(exchange, book, baos);
+
+        String jsonApiOutput = baos.toString();
+        assertNotNull(jsonApiOutput);
+        assertEquals(this.generateTestDataAsString(), jsonApiOutput);
+    }
+
+    @Test(expected = DocumentSerializationException.class)
+    public void test_jsonApi_marshal_no_annotation_on_type() throws Exception {
+        Class<?>[] formats = { MyBook.class, MyAuthor.class };
+        jsonApiDataFormat = new JsonApiDataFormat();
+        jsonApiDataFormat.setDataFormatTypes(formats);
+
+        Exchange exchange = new DefaultExchange(context);
+        ByteArrayOutputStream baos = new ByteArrayOutputStream();
+        jsonApiDataFormat.marshal(exchange, new FooBar(), baos);
+    }
+
+    @Test(expected = DocumentSerializationException.class)
+    public void test_jsonApi_marshal_wrong_type() throws Exception {
+        Class<?>[] formats = { MyBook.class, MyAuthor.class };
+        jsonApiDataFormat = new JsonApiDataFormat();
+        jsonApiDataFormat.setDataFormatTypes(formats);
+
+        Exchange exchange = new DefaultExchange(context);
+        ByteArrayOutputStream baos = new ByteArrayOutputStream();
+        jsonApiDataFormat.marshal(exchange, new MyFooBar(""bar""), baos);
+    }
+
+    @Test
+    public void test_jsonApi_unmarshal() throws Exception {
+        Class<?>[] formats = { MyBook.class, MyAuthor.class };
+        jsonApiDataFormat = new JsonApiDataFormat();
+        jsonApiDataFormat.setDataFormatTypes(formats);
+        jsonApiDataFormat.setMainFormatType(MyBook.class);
+
+        String jsonApiInput = this.generateTestDataAsString();
+
+        Exchange exchange = new DefaultExchange(context);
+        Object outputObj = jsonApiDataFormat.unmarshal(exchange, new ByteArrayInputStream(jsonApiInput.getBytes()));
+
+        assertNotNull(outputObj);
+        MyBook book = (MyBook)outputObj;
+        assertEquals(""Camel in Action"", book.getTitle());
+        assertEquals(""1"", book.getAuthor().getAuthorId());
+    }
+
+    @Test(expected = UnregisteredTypeException.class)
+    public void test_jsonApi_unmarshal_wrong_type() throws Exception {
+        Class<?>[] formats = { MyBook.class, MyAuthor.class };
+        jsonApiDataFormat = new JsonApiDataFormat();
+        jsonApiDataFormat.setDataFormatTypes(formats);
+        jsonApiDataFormat.setMainFormatType(MyBook.class);
+
+        String jsonApiInput = ""{\""data\"":{\""type\"":\""animal\"",\""id\"":\""camel\"",\""attributes\"":{\""humps\"":\""2\""}}}"";
+
+        Exchange exchange = new DefaultExchange(context);
+        jsonApiDataFormat.unmarshal(exchange, new ByteArrayInputStream(jsonApiInput.getBytes()));
+    }
+
+    @Ignore
+    public void test_jsonApi_with_route() {
+        final String title = ""Hello Thai Elephant \u0E08"";
+
+        // context.addRoutes(new RouteBuilder() {","[{'comment': 'Can be removed', 'commenter': 'onderson'}, {'comment': 'of course. Was hoping to uncomment this once had some pointers on how make the DataFormat accessible in the route. ', 'commenter': 'CodeSmell'}]"
2847,components/camel-jsonapi/pom.xml,"@@ -0,0 +1,97 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one or more
+    contributor license agreements.  See the NOTICE file distributed with
+    this work for additional information regarding copyright ownership.
+    The ASF licenses this file to You under the Apache License, Version 2.0
+    (the ""License""); you may not use this file except in compliance with
+    the License.  You may obtain a copy of the License at
+
+         http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an ""AS IS"" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+
+-->
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
+         xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+  
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>org.apache.camel</groupId>
+    <artifactId>components</artifactId>
+    <version>3.0.0-SNAPSHOT</version>
+  </parent>
+
+  <artifactId>camel-jsonapi</artifactId>
+  <packaging>jar</packaging>
+  <name>Camel :: JsonApi</name>
+  <description>Camel JsonApi data format</description>
+
+<!--
+  <properties>
+    <camel.osgi.export.pkg>org.apache.camel.dataformat.thrift.*</camel.osgi.export.pkg>
+    <camel.osgi.export.service>org.apache.camel.spi.DataFormatResolver;dataformat=thrift</camel.osgi.export.service>
+  </properties>
+-->
+  <dependencies>
+    <dependency>
+      <groupId>org.apache.camel</groupId>
+      <artifactId>camel-core</artifactId>
+    </dependency>
+    
+    <dependency>
+        <groupId>com.github.jasminb</groupId>
+        <artifactId>jsonapi-converter</artifactId>
+        <!--
+        <version>${jasminb-jsonapi-version}</version>
+        
+        -->
+        <version>0.9</version>","[{'comment': 'This can be a property in parent/pom', 'commenter': 'oscerd'}]"
2849,components/camel-pulsar/src/main/java/org.apache.camel.component.pulsar/PulsarComponent.java,"@@ -0,0 +1,54 @@
+/**","[{'comment': 'We usually split the package path so you should have org/apache/camel/component/pulsar and not the dotted version', 'commenter': 'oscerd'}, {'comment': 'yeah I suspect that this is a git merge/rename artefact - I will correct it', 'commenter': 'foamdino'}, {'comment': 'done', 'commenter': 'foamdino'}]"
2849,components/camel-pulsar/src/main/java/org.apache.camel.component.pulsar/configuration/PulsarEndpointConfiguration.java,"@@ -0,0 +1,98 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.pulsar.configuration;
+
+import org.apache.camel.component.pulsar.utils.consumers.SubscriptionType;
+import org.apache.camel.spi.UriParam;
+import org.apache.camel.spi.UriParams;
+
+import static org.apache.camel.component.pulsar.utils.consumers.SubscriptionType.EXCLUSIVE;
+
+@UriParams
+public class PulsarEndpointConfiguration {","[{'comment': 'You can call this PulsarConfiguration', 'commenter': 'oscerd'}, {'comment': 'done', 'commenter': 'foamdino'}]"
2849,components/camel-pulsar/src/main/java/org.apache.camel.component.pulsar/configuration/PulsarEndpointConfiguration.java,"@@ -0,0 +1,98 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.pulsar.configuration;
+
+import org.apache.camel.component.pulsar.utils.consumers.SubscriptionType;
+import org.apache.camel.spi.UriParam;
+import org.apache.camel.spi.UriParams;
+
+import static org.apache.camel.component.pulsar.utils.consumers.SubscriptionType.EXCLUSIVE;
+
+@UriParams
+public class PulsarEndpointConfiguration {
+
+    @UriParam(label = ""consumer"", description = ""Name of the subscription to use"", defaultValue = ""subscription"")
+    private String subscriptionName = ""subs"";
+    @UriParam(label = ""consumer"", description = ""Type of the subscription"", enums = ""EXCLUSIVE, SHARED, FAILOVER"", defaultValue = ""EXCLUSIVE"")","[{'comment': 'you can take as example any other configuration, we usually add the description as javadoc, then this information will be picked up while generating the autodocumentation', 'commenter': 'oscerd'}]"
2849,components/camel-pulsar/src/main/java/org.apache.camel.component.pulsar/utils/AutoConfiguration.java,"@@ -0,0 +1,80 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.pulsar.utils;
+
+import org.apache.pulsar.client.admin.PulsarAdmin;
+import org.apache.pulsar.client.admin.PulsarAdminException;
+import org.apache.pulsar.client.admin.Tenants;
+import org.apache.pulsar.common.policies.data.TenantInfo;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.util.List;
+import java.util.Set;
+
+/**
+ * What is the purpose of this? Needs documentation here","[{'comment': 'Yes, what is the purpose of this? Make it a bit more clear would help', 'commenter': 'oscerd'}, {'comment': 'added documentation', 'commenter': 'foamdino'}]"
2849,components/camel-pulsar/src/main/java/org.apache.camel.component.pulsar/utils/consumers/CommonCreationStrategyUtils.java,"@@ -0,0 +1,42 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.pulsar.utils.consumers;
+
+import org.apache.camel.component.pulsar.PulsarConsumer;
+import org.apache.camel.component.pulsar.PulsarEndpoint;
+import org.apache.camel.component.pulsar.PulsarMessageListener;
+import org.apache.camel.component.pulsar.configuration.PulsarEndpointConfiguration;
+import org.apache.pulsar.client.api.ConsumerBuilder;
+
+// does this need to be called *Utils? It lives in a utils package after all","[{'comment': 'Remove this comment if done.', 'commenter': 'oscerd'}, {'comment': 'done', 'commenter': 'foamdino'}]"
2849,components/camel-pulsar/src/main/java/org.apache.camel.component.pulsar/utils/consumers/ExclusiveConsumerStrategy.java,"@@ -0,0 +1,59 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.pulsar.utils.consumers;
+
+import java.util.Collection;
+import java.util.Collections;
+import org.apache.camel.component.pulsar.PulsarConsumer;
+import org.apache.camel.component.pulsar.PulsarEndpoint;
+import org.apache.camel.component.pulsar.utils.retry.PulsarClientRetryPolicy;
+import org.apache.pulsar.client.api.Consumer;
+import org.apache.pulsar.client.api.ConsumerBuilder;
+import org.apache.pulsar.client.api.PulsarClientException;
+import org.apache.pulsar.client.api.SubscriptionType;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class ExclusiveConsumerStrategy implements ConsumerCreationStrategy {
+
+    private static final Logger LOGGER = LoggerFactory.getLogger(ExclusiveConsumerStrategy.class);
+
+    private final PulsarConsumer pulsarConsumer;
+    private final PulsarClientRetryPolicy retryPolicy;
+
+    ExclusiveConsumerStrategy(PulsarConsumer pulsarConsumer, PulsarClientRetryPolicy retryPolicy) {
+        this.pulsarConsumer = pulsarConsumer;
+        this.retryPolicy = retryPolicy;
+    }
+
+    @Override
+    public Collection<Consumer<byte[]>> create(final PulsarEndpoint pulsarEndpoint) {
+        String consumerName = pulsarEndpoint.getConfiguration().getConsumerName();
+
+        ConsumerBuilder<byte[]> builder = CommonCreationStrategyUtils.create(consumerName, pulsarEndpoint, pulsarConsumer);
+
+        try {
+            return Collections.singletonList(builder.subscriptionType(SubscriptionType.Exclusive).subscribe());
+        } catch (PulsarClientException exception) {
+            LOGGER.error(""An error occurred when creating the consumer {}"", exception);
+            // TODO what is the purpose of the retry policy?","[{'comment': 'Remove the comment or add some more information', 'commenter': 'oscerd'}]"
2849,components/camel-pulsar/src/main/java/org.apache.camel.component.pulsar/utils/retry/ExponentialRetryPolicy.java,"@@ -0,0 +1,25 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.pulsar.utils.retry;
+
+public class ExponentialRetryPolicy implements PulsarClientRetryPolicy {
+
+    @Override
+    public void retry() {
+        // TODO","[{'comment': ""This doesn't do anything. Since it is called here https://github.com/apache/camel/pull/2849/files#diff-0b5e1073c757a871674be324659401b2R43\r\n\r\nProbably it is better to use a different Default Retry Policy or remove this."", 'commenter': 'oscerd'}]"
2849,components/camel-pulsar/src/test/java/org/apache/camel/component/pulsar/PulsarComponentTest.java,"@@ -0,0 +1,72 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.pulsar;
+
+import org.apache.camel.component.pulsar.utils.AutoConfiguration;
+import org.apache.camel.component.pulsar.utils.consumers.SubscriptionType;
+import org.apache.camel.test.junit4.CamelTestSupport;
+import org.junit.Before;
+import org.junit.Test;
+import org.mockito.Matchers;
+
+import static org.mockito.Mockito.*;","[{'comment': 'Usually we avoid the * imports.', 'commenter': 'oscerd'}, {'comment': 'done', 'commenter': 'foamdino'}]"
2849,components/camel-pulsar/src/test/java/org/apache/camel/component/pulsar/PulsarConcurrentProducerInTest.java,"@@ -0,0 +1,119 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.pulsar;
+
+import org.apache.camel.Endpoint;
+import org.apache.camel.EndpointInject;
+import org.apache.camel.Produce;
+import org.apache.camel.ProducerTemplate;
+import org.apache.camel.builder.RouteBuilder;
+import org.apache.camel.component.mock.MockEndpoint;
+import org.apache.camel.component.pulsar.utils.AutoConfiguration;
+import org.apache.camel.impl.JndiRegistry;
+import org.apache.camel.test.junit4.CamelTestSupport;
+import org.apache.pulsar.client.api.PulsarClient;
+import org.apache.pulsar.client.api.PulsarClientException;
+import org.apache.pulsar.client.impl.ClientBuilderImpl;
+import org.junit.Ignore;
+import org.junit.Test;
+
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.TimeUnit;
+
+@Ignore //TODO use TestContainers to spin up local pulsar broker","[{'comment': 'We can add the support for testcontainers based tests. We are doing it for other components.', 'commenter': 'oscerd'}, {'comment': 'Remove the TODO please', 'commenter': 'oscerd'}, {'comment': 'FYI there is a module for Apache Pulsar, contributed by the developers of Apache Pulsar :)\r\nhttps://github.com/testcontainers/testcontainers-java/tree/master/modules/pulsar', 'commenter': 'bsideup'}]"
2849,examples/camel-example-spring-pulsar/pom.xml,"@@ -0,0 +1,152 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--
+  Licensed to the Apache Software Foundation (ASF) under one or more
+  contributor license agreements.  See the NOTICE file distributed with
+  this work for additional information regarding copyright ownership.
+  The ASF licenses this file to You under the Apache License, Version 2.0
+  (the ""License""); you may not use this file except in compliance with
+  the License.  You may obtain a copy of the License at
+
+  http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an ""AS IS"" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+
+    <modelVersion>4.0.0</modelVersion>
+    <parent>
+        <groupId>org.apache.camel</groupId>
+        <artifactId>examples</artifactId>
+        <version>2.17.3</version>","[{'comment': 'The version looks wrong please align', 'commenter': 'oscerd'}, {'comment': 'done', 'commenter': 'foamdino'}]"
2849,parent/pom.xml,"@@ -576,6 +576,7 @@
     <protobuf-maven-plugin-version>0.5.1</protobuf-maven-plugin-version>
     <protonpack-version>1.8</protonpack-version>
     <pubnub-version>4.21.0</pubnub-version>
+    <pulsar-client-version>2.2.1</pulsar-client-version>","[{'comment': 'the client property placeholder is present also at the line 760. Remove one of the two placeholder', 'commenter': 'oscerd'}, {'comment': 'done', 'commenter': 'foamdino'}]"
2849,components/camel-pulsar/src/main/java/org.apache.camel.component.pulsar/PulsarMessageListener.java,"@@ -0,0 +1,74 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.pulsar;
+
+import org.apache.camel.Exchange;
+import org.apache.camel.Processor;
+import org.apache.camel.component.pulsar.utils.message.PulsarMessageUtils;
+import org.apache.camel.spi.ExceptionHandler;
+import org.apache.pulsar.client.api.Consumer;
+import org.apache.pulsar.client.api.Message;
+import org.apache.pulsar.client.api.MessageListener;
+import org.apache.pulsar.client.api.PulsarClientException;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class PulsarMessageListener implements MessageListener<byte[]> {
+
+    private static final Logger LOGGER = LoggerFactory.getLogger(PulsarMessageListener.class);
+
+    private final PulsarEndpoint endpoint;
+    private final ExceptionHandler exceptionHandler;
+    private final Processor processor;
+
+    public PulsarMessageListener(PulsarEndpoint endpoint, ExceptionHandler exceptionHandler, Processor processor) {
+        this.endpoint = endpoint;
+        this.exceptionHandler = exceptionHandler;
+        this.processor = processor;
+    }
+
+    @Override
+    public void received(final Consumer<byte[]> consumer, final Message<byte[]> message) {
+        final Exchange exchange = PulsarMessageUtils.updateExchange(message, endpoint.createExchange());
+
+        try {
+            processor.process(exchange);
+            acknowledgeReceipt(consumer, message);
+        } catch (Exception exception) {
+            handleProcessorException(exchange, exception);
+        }
+    }
+
+    private void handleProcessorException(final Exchange exchange, final Exception exception) {
+        final Exchange exchangeWithException = PulsarMessageUtils
+            .updateExchangeWithException(exception, exchange);
+
+        exceptionHandler
+            .handleException(""An error occurred"", exchangeWithException, exception);
+
+        LOGGER.error(""An error occurred while processing this exchange :: {}"", exception);
+    }
+
+    private void acknowledgeReceipt(final Consumer<byte[]> consumer, final Message<byte[]> message) {
+        try {
+            consumer.acknowledge(message.getMessageId());
+        } catch (PulsarClientException exception) {
+            LOGGER.error(""An error occurred while acknowledging this message :: {}"", exception);
+            // TODO should we be doing anything else here?","[{'comment': 'please remove, and just throw if you will not handle here but handle in somewhere else.', 'commenter': 'onderson'}]"
2849,components/camel-pulsar/src/main/java/org.apache.camel.component.pulsar/utils/consumers/CommonCreationStrategyUtils.java,"@@ -0,0 +1,42 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.pulsar.utils.consumers;
+
+import org.apache.camel.component.pulsar.PulsarConsumer;
+import org.apache.camel.component.pulsar.PulsarEndpoint;
+import org.apache.camel.component.pulsar.PulsarMessageListener;
+import org.apache.camel.component.pulsar.configuration.PulsarEndpointConfiguration;
+import org.apache.pulsar.client.api.ConsumerBuilder;
+
+// does this need to be called *Utils? It lives in a utils package after all
+public final class CommonCreationStrategyUtils {","[{'comment': 'why not moving into single utils class..', 'commenter': 'onderson'}, {'comment': 'renamed', 'commenter': 'foamdino'}]"
2849,components/camel-pulsar/src/main/java/org.apache.camel.component.pulsar/utils/message/PulsarMessageHeaders.java,"@@ -0,0 +1,31 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.pulsar.utils.message;
+
+public class PulsarMessageHeaders {","[{'comment': 'interface is better', 'commenter': 'onderson'}, {'comment': 'done', 'commenter': 'foamdino'}]"
2849,components/camel-pulsar/src/test/java/org/apache/camel/component/pulsar/PulsarConcurrentProducerInTest.java,"@@ -0,0 +1,119 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.pulsar;
+
+import org.apache.camel.Endpoint;
+import org.apache.camel.EndpointInject;
+import org.apache.camel.Produce;
+import org.apache.camel.ProducerTemplate;
+import org.apache.camel.builder.RouteBuilder;
+import org.apache.camel.component.mock.MockEndpoint;
+import org.apache.camel.component.pulsar.utils.AutoConfiguration;
+import org.apache.camel.impl.JndiRegistry;
+import org.apache.camel.test.junit4.CamelTestSupport;
+import org.apache.pulsar.client.api.PulsarClient;
+import org.apache.pulsar.client.api.PulsarClientException;
+import org.apache.pulsar.client.impl.ClientBuilderImpl;
+import org.junit.Ignore;
+import org.junit.Test;
+
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.TimeUnit;
+
+@Ignore //TODO use TestContainers to spin up local pulsar broker
+public class PulsarConcurrentProducerInTest extends CamelTestSupport {
+    private static final String PULSAR_CLUSTER_URL = ""pulsar://localhost:6650"";
+
+    private static final String TOPIC_URI = ""persistent://public/default/camel-concurrent-producers-topic"";
+    private static final String PRODUCER = ""camel-producer"";
+
+    @Produce(uri = ""direct:start"")
+    private ProducerTemplate producerTemplate;
+
+    @EndpointInject(uri = ""pulsar:"" + TOPIC_URI
+        + ""?numberOfConsumers=3&subscriptionType=Shared""
+        + ""&subscriptionName=camel-subscription&consumerQueueSize=1""
+        + ""&consumerNamePrefix=camel-consumer""
+        + ""&producerName="" + PRODUCER
+    )
+    private Endpoint from;
+
+    @EndpointInject(uri = ""mock:result"")
+    private MockEndpoint to;
+
+    @Override
+    protected RouteBuilder createRouteBuilder() {
+        return new RouteBuilder() {
+
+            @Override
+            public void configure() {
+                from(""direct:start"").to(from);
+                from(from).to(to);
+            }
+        };
+    }
+
+    @Override
+    protected JndiRegistry createRegistry() throws Exception {
+        JndiRegistry jndi = super.createRegistry();
+
+        registerPulsarBeans(jndi);
+
+        return jndi;
+    }
+
+    private void registerPulsarBeans(final JndiRegistry jndi) throws PulsarClientException {
+        PulsarClient pulsarClient = givenPulsarClient();
+        AutoConfiguration autoConfiguration = new AutoConfiguration(null, null);
+
+        jndi.bind(""pulsarClient"", pulsarClient);
+        jndi.bind(""pulsar"", new PulsarComponent(context(), autoConfiguration, pulsarClient));
+    }
+
+    private PulsarClient givenPulsarClient() throws PulsarClientException {
+        return new ClientBuilderImpl()
+            .serviceUrl(PULSAR_CLUSTER_URL)
+            .ioThreads(1)
+            .listenerThreads(1)
+            .build();
+    }
+
+    @Test
+    public void givenARunningPulsarCluster_whenIPublishAMessagesConcurrentlyToRoute_verifyMessageIsSentToClusterAndThenConsumed() throws Exception {","[{'comment': 'i know naming is hard.  shorter name can be easy to read. like for example: testMultipleMessageConsumedByCluster', 'commenter': 'onderson'}]"
2849,components/camel-pulsar/src/test/java/org/apache/camel/component/pulsar/PulsarConsumerInTest.java,"@@ -0,0 +1,112 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.pulsar;
+
+import org.apache.camel.Endpoint;
+import org.apache.camel.EndpointInject;
+import org.apache.camel.Exchange;
+import org.apache.camel.Processor;
+import org.apache.camel.builder.RouteBuilder;
+import org.apache.camel.component.mock.MockEndpoint;
+import org.apache.camel.component.pulsar.utils.AutoConfiguration;
+import org.apache.camel.impl.JndiRegistry;
+import org.apache.camel.test.junit4.CamelTestSupport;
+import org.apache.pulsar.client.api.Producer;
+import org.apache.pulsar.client.api.PulsarClient;
+import org.apache.pulsar.client.api.PulsarClientException;
+import org.apache.pulsar.client.api.Schema;
+import org.apache.pulsar.client.impl.ClientBuilderImpl;
+import org.junit.Ignore;
+import org.junit.Test;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+@Ignore //TODO use TestContainers to spin up local pulsar broker
+public class PulsarConsumerInTest extends CamelTestSupport {","[{'comment': 'why not having, single test class. This is a fast review. I may not see the reason promptly', 'commenter': 'onderson'}]"
2849,components/camel-pulsar/pom.xml,"@@ -0,0 +1,81 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one or more
+    contributor license agreements.  See the NOTICE file distributed with
+    this work for additional information regarding copyright ownership.
+    The ASF licenses this file to You under the Apache License, Version 2.0
+    (the ""License""); you may not use this file except in compliance with
+    the License.  You may obtain a copy of the License at
+
+         http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an ""AS IS"" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+
+-->
+<project xmlns=""http://maven.apache.org/POM/4.0.0""
+  xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
+  xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"">
+  <parent>
+    <artifactId>components</artifactId>
+    <groupId>org.apache.camel</groupId>
+    <version>2.24.0-SNAPSHOT</version>
+  </parent>
+  <modelVersion>4.0.0</modelVersion>
+
+  <artifactId>camel-pulsar</artifactId>
+  <packaging>jar</packaging>
+  <name>Camel :: Pulsar</name>
+  <description>Camel Apache Pulsar Component</description>
+
+  <properties>
+    <maven.compiler.source>${jdk.version}</maven.compiler.source>","[{'comment': ""I think this shouldn't be here. Both source and target"", 'commenter': 'oscerd'}, {'comment': ""Yeah I'll try to get rid of these properties"", 'commenter': 'foamdino'}]"
2861,components/camel-jetty/src/main/docs/jetty-component.adoc,"@@ -1,4 +1,3 @@
-[[jetty-component]]","[{'comment': 'This update could be removed.', 'commenter': 'oscerd'}]"
2861,components/camel-soroush/ReadMe.txt,"@@ -0,0 +1,13 @@
+Camel Component Project","[{'comment': 'You can remove this', 'commenter': 'oscerd'}]"
2861,components/camel-soroush/pom.xml,"@@ -0,0 +1,278 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--
+  ~ Licensed to the Apache Software Foundation (ASF) under one or more
+  ~ contributor license agreements.  See the NOTICE file distributed with
+  ~ this work for additional information regarding copyright ownership.
+  ~ The ASF licenses this file to You under the Apache License, Version 2.0
+  ~ (the ""License""); you may not use this file except in compliance with
+  ~ the License.  You may obtain a copy of the License at
+  ~
+  ~     http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an ""AS IS"" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  ~
+  -->
+
+<project xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xmlns=""http://maven.apache.org/POM/4.0.0""
+         xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+
+    <modelVersion>4.0.0</modelVersion>
+
+    <parent>
+        <groupId>org.apache.camel</groupId>
+        <artifactId>components</artifactId>
+        <version>3.0.0-SNAPSHOT</version>
+    </parent>
+
+
+    <artifactId>camel-soroush</artifactId>
+    <packaging>jar</packaging>
+    <name>Camel :: SoroushBot</name>
+
+
+    <properties>
+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
+        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
+        <kotlin.version>1.3.21</kotlin.version>
+        <kotlin.compiler.incremental>true</kotlin.compiler.incremental>
+        <jersey-version>2.28</jersey-version>
+        <!--<jetty-version>9.4.15.v20190215</jetty-version>-->","[{'comment': 'If not used remove this, also all the properties placeholder must be placed in parent/POM and not specified here.', 'commenter': 'oscerd'}]"
2861,components/camel-soroush/pom.xml,"@@ -0,0 +1,278 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--
+  ~ Licensed to the Apache Software Foundation (ASF) under one or more
+  ~ contributor license agreements.  See the NOTICE file distributed with
+  ~ this work for additional information regarding copyright ownership.
+  ~ The ASF licenses this file to You under the Apache License, Version 2.0
+  ~ (the ""License""); you may not use this file except in compliance with
+  ~ the License.  You may obtain a copy of the License at
+  ~
+  ~     http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an ""AS IS"" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  ~
+  -->
+
+<project xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xmlns=""http://maven.apache.org/POM/4.0.0""
+         xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+
+    <modelVersion>4.0.0</modelVersion>
+
+    <parent>
+        <groupId>org.apache.camel</groupId>
+        <artifactId>components</artifactId>
+        <version>3.0.0-SNAPSHOT</version>
+    </parent>
+
+
+    <artifactId>camel-soroush</artifactId>
+    <packaging>jar</packaging>
+    <name>Camel :: SoroushBot</name>
+
+
+    <properties>
+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
+        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
+        <kotlin.version>1.3.21</kotlin.version>
+        <kotlin.compiler.incremental>true</kotlin.compiler.incremental>
+        <jersey-version>2.28</jersey-version>
+        <!--<jetty-version>9.4.15.v20190215</jetty-version>-->
+        <camel-version></camel-version>
+
+    </properties>
+
+
+    <!--","[{'comment': ""Remove this if it's not used"", 'commenter': 'oscerd'}]"
2861,components/camel-soroush/pom.xml,"@@ -0,0 +1,278 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--
+  ~ Licensed to the Apache Software Foundation (ASF) under one or more
+  ~ contributor license agreements.  See the NOTICE file distributed with
+  ~ this work for additional information regarding copyright ownership.
+  ~ The ASF licenses this file to You under the Apache License, Version 2.0
+  ~ (the ""License""); you may not use this file except in compliance with
+  ~ the License.  You may obtain a copy of the License at
+  ~
+  ~     http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an ""AS IS"" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  ~
+  -->
+
+<project xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xmlns=""http://maven.apache.org/POM/4.0.0""
+         xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+
+    <modelVersion>4.0.0</modelVersion>
+
+    <parent>
+        <groupId>org.apache.camel</groupId>
+        <artifactId>components</artifactId>
+        <version>3.0.0-SNAPSHOT</version>
+    </parent>
+
+
+    <artifactId>camel-soroush</artifactId>
+    <packaging>jar</packaging>
+    <name>Camel :: SoroushBot</name>
+
+
+    <properties>
+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
+        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
+        <kotlin.version>1.3.21</kotlin.version>
+        <kotlin.compiler.incremental>true</kotlin.compiler.incremental>
+        <jersey-version>2.28</jersey-version>
+        <!--<jetty-version>9.4.15.v20190215</jetty-version>-->
+        <camel-version></camel-version>
+
+    </properties>
+
+
+    <!--
+        <dependencyManagement>
+            <dependencies>
+                &lt;!&ndash; Camel BOM &ndash;&gt;
+                <dependency>
+                    <groupId>org.apache.camel</groupId>
+                    <artifactId>camel-parent</artifactId>
+                    <version>2.23.1</version>
+                    <scope>import</scope>
+                    <type>pom</type>
+                </dependency>
+            </dependencies>
+        </dependencyManagement>
+    -->
+
+    <dependencies>
+        <dependency>
+            <groupId>org.apache.camel</groupId>
+            <artifactId>camel-support</artifactId>
+        </dependency>
+        <dependency>
+            <groupId>org.glassfish.jersey.core</groupId>
+            <artifactId>jersey-client</artifactId>
+            <version>${jersey-version}</version>
+        </dependency>
+        <dependency>
+            <groupId>org.apache.camel</groupId>
+            <artifactId>camel-package-maven-plugin</artifactId>
+            <version>3.0.0-SNAPSHOT</version>","[{'comment': ""This is the project-version, don't use an explicit version in the pom"", 'commenter': 'oscerd'}]"
2861,components/camel-soroush/pom.xml,"@@ -0,0 +1,278 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--
+  ~ Licensed to the Apache Software Foundation (ASF) under one or more
+  ~ contributor license agreements.  See the NOTICE file distributed with
+  ~ this work for additional information regarding copyright ownership.
+  ~ The ASF licenses this file to You under the Apache License, Version 2.0
+  ~ (the ""License""); you may not use this file except in compliance with
+  ~ the License.  You may obtain a copy of the License at
+  ~
+  ~     http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an ""AS IS"" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  ~
+  -->
+
+<project xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xmlns=""http://maven.apache.org/POM/4.0.0""
+         xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+
+    <modelVersion>4.0.0</modelVersion>
+
+    <parent>
+        <groupId>org.apache.camel</groupId>
+        <artifactId>components</artifactId>
+        <version>3.0.0-SNAPSHOT</version>
+    </parent>
+
+
+    <artifactId>camel-soroush</artifactId>
+    <packaging>jar</packaging>
+    <name>Camel :: SoroushBot</name>
+
+
+    <properties>
+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
+        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
+        <kotlin.version>1.3.21</kotlin.version>
+        <kotlin.compiler.incremental>true</kotlin.compiler.incremental>
+        <jersey-version>2.28</jersey-version>
+        <!--<jetty-version>9.4.15.v20190215</jetty-version>-->
+        <camel-version></camel-version>
+
+    </properties>
+
+
+    <!--
+        <dependencyManagement>
+            <dependencies>
+                &lt;!&ndash; Camel BOM &ndash;&gt;
+                <dependency>
+                    <groupId>org.apache.camel</groupId>
+                    <artifactId>camel-parent</artifactId>
+                    <version>2.23.1</version>
+                    <scope>import</scope>
+                    <type>pom</type>
+                </dependency>
+            </dependencies>
+        </dependencyManagement>
+    -->
+
+    <dependencies>
+        <dependency>
+            <groupId>org.apache.camel</groupId>
+            <artifactId>camel-support</artifactId>
+        </dependency>
+        <dependency>
+            <groupId>org.glassfish.jersey.core</groupId>
+            <artifactId>jersey-client</artifactId>
+            <version>${jersey-version}</version>
+        </dependency>
+        <dependency>
+            <groupId>org.apache.camel</groupId>
+            <artifactId>camel-package-maven-plugin</artifactId>
+            <version>3.0.0-SNAPSHOT</version>
+        </dependency>
+        <dependency>
+            <groupId>org.glassfish.jersey.media</groupId>","[{'comment': 'Is Jersey the only possible solution here? Jersey is not OSGi friendly', 'commenter': 'oscerd'}, {'comment': '@oscerd \r\nNo, but we build most of our logic around Jersey. We only use Jersey client in main project. Is it still hard to integrate it with Apache Karaf?', 'commenter': 'hossein-nasr'}, {'comment': ""From what I remember it's not really OSGi-friendly, but you can try to create the karaf feature for this component and check if it works with an integration test like what we have in tests/camel-itest-karaf"", 'commenter': 'oscerd'}, {'comment': '@oscerd I add component to feature.xml and created and run a test it. Everything goes fine!', 'commenter': 'hossein-nasr'}]"
2861,components/camel-soroush/pom.xml,"@@ -0,0 +1,278 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--
+  ~ Licensed to the Apache Software Foundation (ASF) under one or more
+  ~ contributor license agreements.  See the NOTICE file distributed with
+  ~ this work for additional information regarding copyright ownership.
+  ~ The ASF licenses this file to You under the Apache License, Version 2.0
+  ~ (the ""License""); you may not use this file except in compliance with
+  ~ the License.  You may obtain a copy of the License at
+  ~
+  ~     http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an ""AS IS"" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  ~
+  -->
+
+<project xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xmlns=""http://maven.apache.org/POM/4.0.0""
+         xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+
+    <modelVersion>4.0.0</modelVersion>
+
+    <parent>
+        <groupId>org.apache.camel</groupId>
+        <artifactId>components</artifactId>
+        <version>3.0.0-SNAPSHOT</version>
+    </parent>
+
+
+    <artifactId>camel-soroush</artifactId>
+    <packaging>jar</packaging>
+    <name>Camel :: SoroushBot</name>
+
+
+    <properties>
+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
+        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
+        <kotlin.version>1.3.21</kotlin.version>
+        <kotlin.compiler.incremental>true</kotlin.compiler.incremental>
+        <jersey-version>2.28</jersey-version>
+        <!--<jetty-version>9.4.15.v20190215</jetty-version>-->
+        <camel-version></camel-version>
+
+    </properties>
+
+
+    <!--
+        <dependencyManagement>
+            <dependencies>
+                &lt;!&ndash; Camel BOM &ndash;&gt;
+                <dependency>
+                    <groupId>org.apache.camel</groupId>
+                    <artifactId>camel-parent</artifactId>
+                    <version>2.23.1</version>
+                    <scope>import</scope>
+                    <type>pom</type>
+                </dependency>
+            </dependencies>
+        </dependencyManagement>
+    -->
+
+    <dependencies>
+        <dependency>
+            <groupId>org.apache.camel</groupId>
+            <artifactId>camel-support</artifactId>
+        </dependency>
+        <dependency>
+            <groupId>org.glassfish.jersey.core</groupId>
+            <artifactId>jersey-client</artifactId>
+            <version>${jersey-version}</version>
+        </dependency>
+        <dependency>
+            <groupId>org.apache.camel</groupId>
+            <artifactId>camel-package-maven-plugin</artifactId>
+            <version>3.0.0-SNAPSHOT</version>
+        </dependency>
+        <dependency>
+            <groupId>org.glassfish.jersey.media</groupId>
+            <artifactId>jersey-media-json-jackson</artifactId>
+            <version>${jersey-version}</version>
+            <scope>runtime</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.glassfish.jersey.inject</groupId>
+            <artifactId>jersey-hk2</artifactId>
+            <version>${jersey-version}</version>
+        </dependency>
+        <dependency>
+            <groupId>org.glassfish.jersey.media</groupId>
+            <artifactId>jersey-media-sse</artifactId>
+            <version>${jersey-version}</version>
+        </dependency>
+        <dependency>
+            <groupId>org.glassfish.jersey.media</groupId>
+            <artifactId>jersey-media-multipart</artifactId>
+            <version>${jersey-version}</version>
+        </dependency>
+        <dependency>
+            <groupId>com.fasterxml.jackson.core</groupId>
+            <artifactId>jackson-databind</artifactId>
+        </dependency>
+
+        <dependency>
+            <groupId>com.fasterxml.jackson.core</groupId>
+            <artifactId>jackson-annotations</artifactId>
+        </dependency>
+
+        <dependency>
+            <groupId>com.fasterxml.jackson.jaxrs</groupId>
+            <artifactId>jackson-jaxrs-json-provider</artifactId>
+        </dependency>
+        <!-- support camel documentation -->
+        <dependency>
+            <groupId>org.apache.camel</groupId>","[{'comment': 'Please take as example any component we have on master', 'commenter': 'oscerd'}]"
2861,components/camel-soroush/pom.xml,"@@ -0,0 +1,278 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--
+  ~ Licensed to the Apache Software Foundation (ASF) under one or more
+  ~ contributor license agreements.  See the NOTICE file distributed with
+  ~ this work for additional information regarding copyright ownership.
+  ~ The ASF licenses this file to You under the Apache License, Version 2.0
+  ~ (the ""License""); you may not use this file except in compliance with
+  ~ the License.  You may obtain a copy of the License at
+  ~
+  ~     http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an ""AS IS"" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  ~
+  -->
+
+<project xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xmlns=""http://maven.apache.org/POM/4.0.0""
+         xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+
+    <modelVersion>4.0.0</modelVersion>
+
+    <parent>
+        <groupId>org.apache.camel</groupId>
+        <artifactId>components</artifactId>
+        <version>3.0.0-SNAPSHOT</version>
+    </parent>
+
+
+    <artifactId>camel-soroush</artifactId>
+    <packaging>jar</packaging>
+    <name>Camel :: SoroushBot</name>
+
+
+    <properties>
+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
+        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
+        <kotlin.version>1.3.21</kotlin.version>
+        <kotlin.compiler.incremental>true</kotlin.compiler.incremental>
+        <jersey-version>2.28</jersey-version>
+        <!--<jetty-version>9.4.15.v20190215</jetty-version>-->
+        <camel-version></camel-version>
+
+    </properties>
+
+
+    <!--
+        <dependencyManagement>
+            <dependencies>
+                &lt;!&ndash; Camel BOM &ndash;&gt;
+                <dependency>
+                    <groupId>org.apache.camel</groupId>
+                    <artifactId>camel-parent</artifactId>
+                    <version>2.23.1</version>
+                    <scope>import</scope>
+                    <type>pom</type>
+                </dependency>
+            </dependencies>
+        </dependencyManagement>
+    -->
+
+    <dependencies>
+        <dependency>
+            <groupId>org.apache.camel</groupId>
+            <artifactId>camel-support</artifactId>
+        </dependency>
+        <dependency>
+            <groupId>org.glassfish.jersey.core</groupId>
+            <artifactId>jersey-client</artifactId>
+            <version>${jersey-version}</version>
+        </dependency>
+        <dependency>
+            <groupId>org.apache.camel</groupId>
+            <artifactId>camel-package-maven-plugin</artifactId>
+            <version>3.0.0-SNAPSHOT</version>
+        </dependency>
+        <dependency>
+            <groupId>org.glassfish.jersey.media</groupId>
+            <artifactId>jersey-media-json-jackson</artifactId>
+            <version>${jersey-version}</version>
+            <scope>runtime</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.glassfish.jersey.inject</groupId>
+            <artifactId>jersey-hk2</artifactId>
+            <version>${jersey-version}</version>
+        </dependency>
+        <dependency>
+            <groupId>org.glassfish.jersey.media</groupId>
+            <artifactId>jersey-media-sse</artifactId>
+            <version>${jersey-version}</version>
+        </dependency>
+        <dependency>
+            <groupId>org.glassfish.jersey.media</groupId>
+            <artifactId>jersey-media-multipart</artifactId>
+            <version>${jersey-version}</version>
+        </dependency>
+        <dependency>
+            <groupId>com.fasterxml.jackson.core</groupId>
+            <artifactId>jackson-databind</artifactId>
+        </dependency>
+
+        <dependency>
+            <groupId>com.fasterxml.jackson.core</groupId>
+            <artifactId>jackson-annotations</artifactId>
+        </dependency>
+
+        <dependency>
+            <groupId>com.fasterxml.jackson.jaxrs</groupId>
+            <artifactId>jackson-jaxrs-json-provider</artifactId>
+        </dependency>
+        <!-- support camel documentation -->
+        <dependency>
+            <groupId>org.apache.camel</groupId>
+            <artifactId>apt</artifactId>
+        </dependency>
+
+        <!-- test dependencies-->
+        <dependency>","[{'comment': 'Why kotlin is used for testing purpose?', 'commenter': 'oscerd'}, {'comment': 'i remove it!', 'commenter': 'hossein-nasr'}]"
2861,components/camel-soroush/pom.xml,"@@ -0,0 +1,278 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--
+  ~ Licensed to the Apache Software Foundation (ASF) under one or more
+  ~ contributor license agreements.  See the NOTICE file distributed with
+  ~ this work for additional information regarding copyright ownership.
+  ~ The ASF licenses this file to You under the Apache License, Version 2.0
+  ~ (the ""License""); you may not use this file except in compliance with
+  ~ the License.  You may obtain a copy of the License at
+  ~
+  ~     http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an ""AS IS"" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  ~
+  -->
+
+<project xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xmlns=""http://maven.apache.org/POM/4.0.0""
+         xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+
+    <modelVersion>4.0.0</modelVersion>
+
+    <parent>
+        <groupId>org.apache.camel</groupId>
+        <artifactId>components</artifactId>
+        <version>3.0.0-SNAPSHOT</version>
+    </parent>
+
+
+    <artifactId>camel-soroush</artifactId>
+    <packaging>jar</packaging>
+    <name>Camel :: SoroushBot</name>
+
+
+    <properties>
+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
+        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
+        <kotlin.version>1.3.21</kotlin.version>
+        <kotlin.compiler.incremental>true</kotlin.compiler.incremental>
+        <jersey-version>2.28</jersey-version>
+        <!--<jetty-version>9.4.15.v20190215</jetty-version>-->
+        <camel-version></camel-version>
+
+    </properties>
+
+
+    <!--
+        <dependencyManagement>
+            <dependencies>
+                &lt;!&ndash; Camel BOM &ndash;&gt;
+                <dependency>
+                    <groupId>org.apache.camel</groupId>
+                    <artifactId>camel-parent</artifactId>
+                    <version>2.23.1</version>
+                    <scope>import</scope>
+                    <type>pom</type>
+                </dependency>
+            </dependencies>
+        </dependencyManagement>
+    -->
+
+    <dependencies>
+        <dependency>
+            <groupId>org.apache.camel</groupId>
+            <artifactId>camel-support</artifactId>
+        </dependency>
+        <dependency>
+            <groupId>org.glassfish.jersey.core</groupId>
+            <artifactId>jersey-client</artifactId>
+            <version>${jersey-version}</version>
+        </dependency>
+        <dependency>
+            <groupId>org.apache.camel</groupId>
+            <artifactId>camel-package-maven-plugin</artifactId>
+            <version>3.0.0-SNAPSHOT</version>
+        </dependency>
+        <dependency>
+            <groupId>org.glassfish.jersey.media</groupId>
+            <artifactId>jersey-media-json-jackson</artifactId>
+            <version>${jersey-version}</version>
+            <scope>runtime</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.glassfish.jersey.inject</groupId>
+            <artifactId>jersey-hk2</artifactId>
+            <version>${jersey-version}</version>
+        </dependency>
+        <dependency>
+            <groupId>org.glassfish.jersey.media</groupId>
+            <artifactId>jersey-media-sse</artifactId>
+            <version>${jersey-version}</version>
+        </dependency>
+        <dependency>
+            <groupId>org.glassfish.jersey.media</groupId>
+            <artifactId>jersey-media-multipart</artifactId>
+            <version>${jersey-version}</version>
+        </dependency>
+        <dependency>
+            <groupId>com.fasterxml.jackson.core</groupId>
+            <artifactId>jackson-databind</artifactId>
+        </dependency>
+
+        <dependency>
+            <groupId>com.fasterxml.jackson.core</groupId>
+            <artifactId>jackson-annotations</artifactId>
+        </dependency>
+
+        <dependency>
+            <groupId>com.fasterxml.jackson.jaxrs</groupId>
+            <artifactId>jackson-jaxrs-json-provider</artifactId>
+        </dependency>
+        <!-- support camel documentation -->
+        <dependency>
+            <groupId>org.apache.camel</groupId>
+            <artifactId>apt</artifactId>
+        </dependency>
+
+        <!-- test dependencies-->
+        <dependency>
+            <groupId>org.jetbrains.kotlin</groupId>
+            <artifactId>kotlin-stdlib</artifactId>
+            <version>${kotlin.version}</version>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.apache.camel</groupId>
+            <artifactId>camel-test</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.eclipse.jetty</groupId>
+            <artifactId>jetty-server</artifactId>
+            <version>${jetty-version}</version>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.eclipse.jetty</groupId>
+            <artifactId>jetty-servlet</artifactId>
+            <version>${jetty-version}</version>
+            <scope>test</scope>
+        </dependency>
+        <!-- logging -->
+        <dependency>
+            <groupId>org.apache.logging.log4j</groupId>
+            <artifactId>log4j-api</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.apache.logging.log4j</groupId>
+            <artifactId>log4j-core</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.apache.logging.log4j</groupId>
+            <artifactId>log4j-slf4j-impl</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.glassfish.jersey.core</groupId>
+            <artifactId>jersey-server</artifactId>
+            <version>${jersey-version}</version>
+        </dependency>
+        <dependency>
+            <groupId>org.glassfish.jersey.containers</groupId>
+            <artifactId>jersey-container-servlet-core</artifactId>
+            <version>${jersey-version}</version>
+        </dependency>
+        <dependency>
+            <groupId>org.glassfish.jersey.containers</groupId>
+            <artifactId>jersey-container-servlet</artifactId>
+            <version>${jersey-version}</version>
+        </dependency>
+        <dependency>
+            <groupId>org.glassfish.jersey.media</groupId>
+            <artifactId>jersey-media-moxy</artifactId>
+            <version>${jersey-version}</version>
+        </dependency>
+    </dependencies>
+
+    <build>
+        <defaultGoal>install</defaultGoal>
+
+        <plugins>
+            <plugin>
+                <groupId>org.jetbrains.kotlin</groupId>
+                <artifactId>kotlin-maven-plugin</artifactId>
+                <version>${kotlin.version}</version>
+                <executions>
+                    <execution>
+                        <id>compile</id>
+                        <goals>
+                            <goal>compile</goal>
+                        </goals>
+                        <configuration>
+                            <sourceDirs>
+                                <sourceDir>${project.basedir}/src/main/kotlin</sourceDir>
+                                <sourceDir>${project.basedir}/src/main/java</sourceDir>
+                            </sourceDirs>
+                        </configuration>
+                    </execution>
+                    <execution>
+                        <id>test-compile</id>
+                        <goals>
+                            <goal>test-compile</goal>
+                        </goals>
+                        <configuration>
+                            <sourceDirs>
+                                <sourceDir>${project.basedir}/src/test/kotlin</sourceDir>
+                                <sourceDir>${project.basedir}/src/test/java</sourceDir>
+                            </sourceDirs>
+                        </configuration>
+                    </execution>
+                </executions>
+            </plugin>
+            <plugin>
+                <groupId>org.apache.maven.plugins</groupId>
+                <artifactId>maven-compiler-plugin</artifactId>
+                <version>3.8.0</version>
+                <configuration>
+                    <source>1.8</source>
+                    <target>1.8</target>
+                </configuration>
+            </plugin>
+
+            <plugin>
+                <groupId>org.apache.maven.plugins</groupId>
+                <artifactId>maven-resources-plugin</artifactId>
+                <version>3.0.2</version>","[{'comment': 'This is specified in parent pom, no need for explicit version', 'commenter': 'oscerd'}, {'comment': 'I deleted it completely!', 'commenter': 'hossein-nasr'}]"
2861,components/camel-soroush/pom.xml,"@@ -0,0 +1,278 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--
+  ~ Licensed to the Apache Software Foundation (ASF) under one or more
+  ~ contributor license agreements.  See the NOTICE file distributed with
+  ~ this work for additional information regarding copyright ownership.
+  ~ The ASF licenses this file to You under the Apache License, Version 2.0
+  ~ (the ""License""); you may not use this file except in compliance with
+  ~ the License.  You may obtain a copy of the License at
+  ~
+  ~     http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an ""AS IS"" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  ~
+  -->
+
+<project xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xmlns=""http://maven.apache.org/POM/4.0.0""
+         xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+
+    <modelVersion>4.0.0</modelVersion>
+
+    <parent>
+        <groupId>org.apache.camel</groupId>
+        <artifactId>components</artifactId>
+        <version>3.0.0-SNAPSHOT</version>
+    </parent>
+
+
+    <artifactId>camel-soroush</artifactId>
+    <packaging>jar</packaging>
+    <name>Camel :: SoroushBot</name>
+
+
+    <properties>
+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
+        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
+        <kotlin.version>1.3.21</kotlin.version>
+        <kotlin.compiler.incremental>true</kotlin.compiler.incremental>
+        <jersey-version>2.28</jersey-version>
+        <!--<jetty-version>9.4.15.v20190215</jetty-version>-->
+        <camel-version></camel-version>
+
+    </properties>
+
+
+    <!--
+        <dependencyManagement>
+            <dependencies>
+                &lt;!&ndash; Camel BOM &ndash;&gt;
+                <dependency>
+                    <groupId>org.apache.camel</groupId>
+                    <artifactId>camel-parent</artifactId>
+                    <version>2.23.1</version>
+                    <scope>import</scope>
+                    <type>pom</type>
+                </dependency>
+            </dependencies>
+        </dependencyManagement>
+    -->
+
+    <dependencies>
+        <dependency>
+            <groupId>org.apache.camel</groupId>
+            <artifactId>camel-support</artifactId>
+        </dependency>
+        <dependency>
+            <groupId>org.glassfish.jersey.core</groupId>
+            <artifactId>jersey-client</artifactId>
+            <version>${jersey-version}</version>
+        </dependency>
+        <dependency>
+            <groupId>org.apache.camel</groupId>
+            <artifactId>camel-package-maven-plugin</artifactId>
+            <version>3.0.0-SNAPSHOT</version>
+        </dependency>
+        <dependency>
+            <groupId>org.glassfish.jersey.media</groupId>
+            <artifactId>jersey-media-json-jackson</artifactId>
+            <version>${jersey-version}</version>
+            <scope>runtime</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.glassfish.jersey.inject</groupId>
+            <artifactId>jersey-hk2</artifactId>
+            <version>${jersey-version}</version>
+        </dependency>
+        <dependency>
+            <groupId>org.glassfish.jersey.media</groupId>
+            <artifactId>jersey-media-sse</artifactId>
+            <version>${jersey-version}</version>
+        </dependency>
+        <dependency>
+            <groupId>org.glassfish.jersey.media</groupId>
+            <artifactId>jersey-media-multipart</artifactId>
+            <version>${jersey-version}</version>
+        </dependency>
+        <dependency>
+            <groupId>com.fasterxml.jackson.core</groupId>
+            <artifactId>jackson-databind</artifactId>
+        </dependency>
+
+        <dependency>
+            <groupId>com.fasterxml.jackson.core</groupId>
+            <artifactId>jackson-annotations</artifactId>
+        </dependency>
+
+        <dependency>
+            <groupId>com.fasterxml.jackson.jaxrs</groupId>
+            <artifactId>jackson-jaxrs-json-provider</artifactId>
+        </dependency>
+        <!-- support camel documentation -->
+        <dependency>
+            <groupId>org.apache.camel</groupId>
+            <artifactId>apt</artifactId>
+        </dependency>
+
+        <!-- test dependencies-->
+        <dependency>
+            <groupId>org.jetbrains.kotlin</groupId>
+            <artifactId>kotlin-stdlib</artifactId>
+            <version>${kotlin.version}</version>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.apache.camel</groupId>
+            <artifactId>camel-test</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.eclipse.jetty</groupId>
+            <artifactId>jetty-server</artifactId>
+            <version>${jetty-version}</version>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.eclipse.jetty</groupId>
+            <artifactId>jetty-servlet</artifactId>
+            <version>${jetty-version}</version>
+            <scope>test</scope>
+        </dependency>
+        <!-- logging -->
+        <dependency>
+            <groupId>org.apache.logging.log4j</groupId>
+            <artifactId>log4j-api</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.apache.logging.log4j</groupId>
+            <artifactId>log4j-core</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.apache.logging.log4j</groupId>
+            <artifactId>log4j-slf4j-impl</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.glassfish.jersey.core</groupId>
+            <artifactId>jersey-server</artifactId>
+            <version>${jersey-version}</version>
+        </dependency>
+        <dependency>
+            <groupId>org.glassfish.jersey.containers</groupId>
+            <artifactId>jersey-container-servlet-core</artifactId>
+            <version>${jersey-version}</version>
+        </dependency>
+        <dependency>
+            <groupId>org.glassfish.jersey.containers</groupId>
+            <artifactId>jersey-container-servlet</artifactId>
+            <version>${jersey-version}</version>
+        </dependency>
+        <dependency>
+            <groupId>org.glassfish.jersey.media</groupId>
+            <artifactId>jersey-media-moxy</artifactId>
+            <version>${jersey-version}</version>
+        </dependency>
+    </dependencies>
+
+    <build>
+        <defaultGoal>install</defaultGoal>
+
+        <plugins>
+            <plugin>
+                <groupId>org.jetbrains.kotlin</groupId>
+                <artifactId>kotlin-maven-plugin</artifactId>
+                <version>${kotlin.version}</version>
+                <executions>
+                    <execution>
+                        <id>compile</id>
+                        <goals>
+                            <goal>compile</goal>
+                        </goals>
+                        <configuration>
+                            <sourceDirs>
+                                <sourceDir>${project.basedir}/src/main/kotlin</sourceDir>
+                                <sourceDir>${project.basedir}/src/main/java</sourceDir>
+                            </sourceDirs>
+                        </configuration>
+                    </execution>
+                    <execution>
+                        <id>test-compile</id>
+                        <goals>
+                            <goal>test-compile</goal>
+                        </goals>
+                        <configuration>
+                            <sourceDirs>
+                                <sourceDir>${project.basedir}/src/test/kotlin</sourceDir>
+                                <sourceDir>${project.basedir}/src/test/java</sourceDir>
+                            </sourceDirs>
+                        </configuration>
+                    </execution>
+                </executions>
+            </plugin>
+            <plugin>
+                <groupId>org.apache.maven.plugins</groupId>
+                <artifactId>maven-compiler-plugin</artifactId>
+                <version>3.8.0</version>
+                <configuration>
+                    <source>1.8</source>
+                    <target>1.8</target>
+                </configuration>
+            </plugin>
+
+            <plugin>
+                <groupId>org.apache.maven.plugins</groupId>
+                <artifactId>maven-resources-plugin</artifactId>
+                <version>3.0.2</version>
+                <configuration>
+                    <encoding>UTF-8</encoding>
+                </configuration>
+            </plugin>
+
+            <!-- generate components meta-data and validate component includes documentation etc -->","[{'comment': ""Remove this if it's not used."", 'commenter': 'oscerd'}]"
2861,components/camel-soroush/pom.xml,"@@ -0,0 +1,278 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--
+  ~ Licensed to the Apache Software Foundation (ASF) under one or more
+  ~ contributor license agreements.  See the NOTICE file distributed with
+  ~ this work for additional information regarding copyright ownership.
+  ~ The ASF licenses this file to You under the Apache License, Version 2.0
+  ~ (the ""License""); you may not use this file except in compliance with
+  ~ the License.  You may obtain a copy of the License at
+  ~
+  ~     http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an ""AS IS"" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  ~
+  -->
+
+<project xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xmlns=""http://maven.apache.org/POM/4.0.0""
+         xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+
+    <modelVersion>4.0.0</modelVersion>
+
+    <parent>
+        <groupId>org.apache.camel</groupId>
+        <artifactId>components</artifactId>
+        <version>3.0.0-SNAPSHOT</version>
+    </parent>
+
+
+    <artifactId>camel-soroush</artifactId>
+    <packaging>jar</packaging>
+    <name>Camel :: SoroushBot</name>
+
+
+    <properties>
+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
+        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
+        <kotlin.version>1.3.21</kotlin.version>
+        <kotlin.compiler.incremental>true</kotlin.compiler.incremental>
+        <jersey-version>2.28</jersey-version>
+        <!--<jetty-version>9.4.15.v20190215</jetty-version>-->
+        <camel-version></camel-version>
+
+    </properties>
+
+
+    <!--
+        <dependencyManagement>
+            <dependencies>
+                &lt;!&ndash; Camel BOM &ndash;&gt;
+                <dependency>
+                    <groupId>org.apache.camel</groupId>
+                    <artifactId>camel-parent</artifactId>
+                    <version>2.23.1</version>
+                    <scope>import</scope>
+                    <type>pom</type>
+                </dependency>
+            </dependencies>
+        </dependencyManagement>
+    -->
+
+    <dependencies>
+        <dependency>
+            <groupId>org.apache.camel</groupId>
+            <artifactId>camel-support</artifactId>
+        </dependency>
+        <dependency>
+            <groupId>org.glassfish.jersey.core</groupId>
+            <artifactId>jersey-client</artifactId>
+            <version>${jersey-version}</version>
+        </dependency>
+        <dependency>
+            <groupId>org.apache.camel</groupId>
+            <artifactId>camel-package-maven-plugin</artifactId>
+            <version>3.0.0-SNAPSHOT</version>
+        </dependency>
+        <dependency>
+            <groupId>org.glassfish.jersey.media</groupId>
+            <artifactId>jersey-media-json-jackson</artifactId>
+            <version>${jersey-version}</version>
+            <scope>runtime</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.glassfish.jersey.inject</groupId>
+            <artifactId>jersey-hk2</artifactId>
+            <version>${jersey-version}</version>
+        </dependency>
+        <dependency>
+            <groupId>org.glassfish.jersey.media</groupId>
+            <artifactId>jersey-media-sse</artifactId>
+            <version>${jersey-version}</version>
+        </dependency>
+        <dependency>
+            <groupId>org.glassfish.jersey.media</groupId>
+            <artifactId>jersey-media-multipart</artifactId>
+            <version>${jersey-version}</version>
+        </dependency>
+        <dependency>
+            <groupId>com.fasterxml.jackson.core</groupId>
+            <artifactId>jackson-databind</artifactId>
+        </dependency>
+
+        <dependency>
+            <groupId>com.fasterxml.jackson.core</groupId>
+            <artifactId>jackson-annotations</artifactId>
+        </dependency>
+
+        <dependency>
+            <groupId>com.fasterxml.jackson.jaxrs</groupId>
+            <artifactId>jackson-jaxrs-json-provider</artifactId>
+        </dependency>
+        <!-- support camel documentation -->
+        <dependency>
+            <groupId>org.apache.camel</groupId>
+            <artifactId>apt</artifactId>
+        </dependency>
+
+        <!-- test dependencies-->
+        <dependency>
+            <groupId>org.jetbrains.kotlin</groupId>
+            <artifactId>kotlin-stdlib</artifactId>
+            <version>${kotlin.version}</version>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.apache.camel</groupId>
+            <artifactId>camel-test</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.eclipse.jetty</groupId>
+            <artifactId>jetty-server</artifactId>
+            <version>${jetty-version}</version>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.eclipse.jetty</groupId>
+            <artifactId>jetty-servlet</artifactId>
+            <version>${jetty-version}</version>
+            <scope>test</scope>
+        </dependency>
+        <!-- logging -->
+        <dependency>
+            <groupId>org.apache.logging.log4j</groupId>
+            <artifactId>log4j-api</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.apache.logging.log4j</groupId>
+            <artifactId>log4j-core</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.apache.logging.log4j</groupId>
+            <artifactId>log4j-slf4j-impl</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.glassfish.jersey.core</groupId>
+            <artifactId>jersey-server</artifactId>
+            <version>${jersey-version}</version>
+        </dependency>
+        <dependency>
+            <groupId>org.glassfish.jersey.containers</groupId>
+            <artifactId>jersey-container-servlet-core</artifactId>
+            <version>${jersey-version}</version>
+        </dependency>
+        <dependency>
+            <groupId>org.glassfish.jersey.containers</groupId>
+            <artifactId>jersey-container-servlet</artifactId>
+            <version>${jersey-version}</version>
+        </dependency>
+        <dependency>
+            <groupId>org.glassfish.jersey.media</groupId>
+            <artifactId>jersey-media-moxy</artifactId>
+            <version>${jersey-version}</version>
+        </dependency>
+    </dependencies>
+
+    <build>
+        <defaultGoal>install</defaultGoal>
+
+        <plugins>
+            <plugin>
+                <groupId>org.jetbrains.kotlin</groupId>
+                <artifactId>kotlin-maven-plugin</artifactId>
+                <version>${kotlin.version}</version>
+                <executions>
+                    <execution>
+                        <id>compile</id>
+                        <goals>
+                            <goal>compile</goal>
+                        </goals>
+                        <configuration>
+                            <sourceDirs>
+                                <sourceDir>${project.basedir}/src/main/kotlin</sourceDir>
+                                <sourceDir>${project.basedir}/src/main/java</sourceDir>
+                            </sourceDirs>
+                        </configuration>
+                    </execution>
+                    <execution>
+                        <id>test-compile</id>
+                        <goals>
+                            <goal>test-compile</goal>
+                        </goals>
+                        <configuration>
+                            <sourceDirs>
+                                <sourceDir>${project.basedir}/src/test/kotlin</sourceDir>
+                                <sourceDir>${project.basedir}/src/test/java</sourceDir>
+                            </sourceDirs>
+                        </configuration>
+                    </execution>
+                </executions>
+            </plugin>
+            <plugin>
+                <groupId>org.apache.maven.plugins</groupId>
+                <artifactId>maven-compiler-plugin</artifactId>
+                <version>3.8.0</version>
+                <configuration>
+                    <source>1.8</source>
+                    <target>1.8</target>
+                </configuration>
+            </plugin>
+
+            <plugin>
+                <groupId>org.apache.maven.plugins</groupId>
+                <artifactId>maven-resources-plugin</artifactId>
+                <version>3.0.2</version>
+                <configuration>
+                    <encoding>UTF-8</encoding>
+                </configuration>
+            </plugin>
+
+            <!-- generate components meta-data and validate component includes documentation etc -->
+            <!--
+                        <plugin>
+                            <groupId>org.apache.camel</groupId>
+                            <artifactId>camel-package-maven-plugin</artifactId>
+                            <version>3.0.0-SNAPSHOT</version>
+                            <executions>
+                                <execution>
+                                    <id>prepare</id>
+                                    <goals>
+                                        <goal>prepare-components</goal>
+                                    </goals>
+                                    <phase>generate-resources</phase>
+                                </execution>
+                                <execution>
+                                    <id>validate</id>
+                                    <goals>
+                                        <goal>validate-components</goal>
+                                    </goals>
+                                    <phase>prepare-package</phase>
+                                </execution>
+                            </executions>
+                        </plugin>
+            -->
+
+            <!-- to generate the MANIFEST-FILE of the bundle -->
+            <plugin>
+                <groupId>org.apache.felix</groupId>
+                <artifactId>maven-bundle-plugin</artifactId>
+                <version>3.5.1</version>","[{'comment': 'This is specified in Parent POM, no need for explicit version here', 'commenter': 'oscerd'}, {'comment': 'I deleted it!', 'commenter': 'hossein-nasr'}]"
2861,components/camel-soroush/src/main/java/org/apache/camel/component/soroushbot/component/SoroushBotAbstractConsumer.java,"@@ -0,0 +1,155 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.camel.component.soroushbot.component;
+
+import javax.ws.rs.client.Client;
+import javax.ws.rs.client.ClientBuilder;
+import javax.ws.rs.client.WebTarget;
+import javax.ws.rs.core.MediaType;
+
+import com.fasterxml.jackson.databind.ObjectMapper;
+import org.apache.camel.Exchange;
+import org.apache.camel.Processor;
+import org.apache.camel.component.soroushbot.models.ConnectionType;
+import org.apache.camel.component.soroushbot.models.SoroushMessage;
+import org.apache.camel.component.soroushbot.service.SoroushService;
+import org.apache.camel.support.DefaultConsumer;
+import org.glassfish.jersey.client.ClientProperties;
+import org.glassfish.jersey.media.sse.EventInput;
+import org.glassfish.jersey.media.sse.InboundEvent;
+import org.glassfish.jersey.media.sse.SseFeature;
+
+import static org.apache.camel.component.soroushbot.utils.StringUtils.ordinal;
+
+/**
+ * this component handle logic for getting message from Soroush server and for each message
+ * it calls abstract function {@link SoroushBotAbstractConsumer#sendExchange(Exchange)}
+ * each subclass should handle how it will start the processing of the exchange
+ */
+public abstract class SoroushBotAbstractConsumer extends DefaultConsumer {
+    SoroushBotEndpoint endpoint;
+    /**
+     * {@link ObjectMapper} for parse message JSON
+     */
+    ObjectMapper objectMapper = new ObjectMapper();
+
+    public SoroushBotAbstractConsumer(SoroushBotEndpoint endpoint, Processor processor) {
+        super(endpoint, processor);
+        this.endpoint = endpoint;
+    }
+
+    /**
+     * create an {@link EventInput} that connect to soroush SSE server and read events
+     *
+     * @param target
+     * @return
+     */
+    private EventInput createEvent(WebTarget target) {
+        EventInput eventInput = target.request().get(EventInput.class);
+        eventInput.setChunkType(MediaType.SERVER_SENT_EVENTS);
+        return eventInput;
+    }
+
+    @Override
+    public void doStart() {
+//     create new Thread for listening to Soroush SSE Server so that it release the main camel thread.
+        Thread thread = new Thread(//this while handle connectionRetry if connection failed or get closed.","[{'comment': ""Please remove the comment inside the code, it's really ugly :-)"", 'commenter': 'oscerd'}]"
2861,components/camel-soroush/src/main/java/org/apache/camel/component/soroushbot/component/SoroushBotSingleThreadConsumer.java,"@@ -0,0 +1,50 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.camel.component.soroushbot.component;
+
+import org.apache.camel.Exchange;
+import org.apache.camel.Processor;
+
+/**
+ * The SoroushBot consumer. if concurrentConsumer set to 1, this Consumer will be Instantiated
+ * every message will be processed in order of their arrival time
+ * this consumer support both Sync and Async processors.
+ */
+public class SoroushBotSingleThreadConsumer extends SoroushBotAbstractConsumer {
+    public SoroushBotSingleThreadConsumer(SoroushBotEndpoint endpoint, Processor processor) {
+        super(endpoint, processor);
+    }
+
+    @Override
+    protected void sendExchange(Exchange exchange) {
+        try {
+            if (endpoint.isSynchronous()) {
+                getProcessor().process(exchange);
+            } else {
+                getAsyncProcessor().process(exchange);
+            }
+        } catch (Exception e) {
+            if (exchange.getException() != null) {
+                getExceptionHandler().handleException(""Error processing exchange"",
+                        exchange, exchange.getException());
+            } else { //should never come here","[{'comment': 'Remove the comment.', 'commenter': 'oscerd'}]"
2861,components/camel-soroush/src/main/java/org/apache/camel/component/soroushbot/models/ConnectionType.java,"@@ -0,0 +1,35 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.camel.component.soroushbot.models;
+
+public enum ConnectionType {","[{'comment': 'This seems to be more an operation type than a connection', 'commenter': 'oscerd'}, {'comment': 'I changed the name!', 'commenter': 'hossein-nasr'}]"
2861,components/camel-soroush/pom.xml,"@@ -0,0 +1,155 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--","[{'comment': 'This license header should be like the others, so copy from another component', 'commenter': 'davsclaus'}]"
2861,components/camel-soroush/pom.xml,"@@ -0,0 +1,155 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--
+  ~ Licensed to the Apache Software Foundation (ASF) under one or more
+  ~ contributor license agreements.  See the NOTICE file distributed with
+  ~ this work for additional information regarding copyright ownership.
+  ~ The ASF licenses this file to You under the Apache License, Version 2.0
+  ~ (the ""License""); you may not use this file except in compliance with
+  ~ the License.  You may obtain a copy of the License at
+  ~
+  ~     http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an ""AS IS"" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  ~
+  -->
+
+<project xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xmlns=""http://maven.apache.org/POM/4.0.0""
+         xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+
+    <modelVersion>4.0.0</modelVersion>
+
+    <parent>
+        <groupId>org.apache.camel</groupId>
+        <artifactId>components</artifactId>
+        <version>3.0.0-SNAPSHOT</version>
+    </parent>
+
+
+    <artifactId>camel-soroush</artifactId>
+    <packaging>jar</packaging>
+    <name>Camel :: SoroushBot</name>
+    <description>Camel Soroush Support</description>
+
+
+    <properties>","[{'comment': 'i think these can be removed', 'commenter': 'davsclaus'}]"
2861,components/camel-soroush/src/main/docs/soroush-component.adoc,"@@ -0,0 +1,248 @@
+[[soroush-component]]
+== SoroushBot Component
+
+*Available as of Camel version 3.0.0-SNAPSHOT*","[{'comment': '3.0', 'commenter': 'davsclaus'}]"
2861,components/camel-soroush/src/main/java/org/apache/camel/component/soroushbot/component/SoroushBotAbstractConsumer.java,"@@ -0,0 +1,157 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.camel.component.soroushbot.component;
+
+import javax.ws.rs.client.Client;
+import javax.ws.rs.client.ClientBuilder;
+import javax.ws.rs.client.WebTarget;
+import javax.ws.rs.core.MediaType;
+
+import com.fasterxml.jackson.databind.ObjectMapper;
+import org.apache.camel.Exchange;
+import org.apache.camel.Processor;
+import org.apache.camel.component.soroushbot.models.Endpoint;
+import org.apache.camel.component.soroushbot.models.SoroushMessage;
+import org.apache.camel.component.soroushbot.service.SoroushService;
+import org.apache.camel.support.DefaultConsumer;
+import org.glassfish.jersey.client.ClientProperties;
+import org.glassfish.jersey.media.sse.EventInput;
+import org.glassfish.jersey.media.sse.InboundEvent;
+import org.glassfish.jersey.media.sse.SseFeature;
+
+import static org.apache.camel.component.soroushbot.utils.StringUtils.ordinal;
+
+/**
+ * this component handle logic for getting message from Soroush server and for each message
+ * it calls abstract function {@link SoroushBotAbstractConsumer#sendExchange(Exchange)}
+ * each subclass should handle how it will start the processing of the exchange
+ */
+public abstract class SoroushBotAbstractConsumer extends DefaultConsumer {
+    SoroushBotEndpoint endpoint;
+    /**
+     * {@link ObjectMapper} for parse message JSON
+     */
+    ObjectMapper objectMapper = new ObjectMapper();
+
+    public SoroushBotAbstractConsumer(SoroushBotEndpoint endpoint, Processor processor) {
+        super(endpoint, processor);
+        this.endpoint = endpoint;
+    }
+
+    /**
+     * create an {@link EventInput} that connect to soroush SSE server and read events
+     *
+     * @param target
+     * @return
+     */
+    private EventInput createEvent(WebTarget target) {
+        EventInput eventInput = target.request().get(EventInput.class);
+        eventInput.setChunkType(MediaType.SERVER_SENT_EVENTS);
+        return eventInput;
+    }
+
+    @Override
+    public void doStart() {
+//     create new Thread for listening to Soroush SSE Server so that it release the main camel thread.
+        Thread thread = new Thread(() -> {","[{'comment': ""Should use Camel's ExecutorServiceStrategy to create a single thread instead, which you can get via the camel context"", 'commenter': 'davsclaus'}]"
2861,components/camel-soroush/src/main/java/org/apache/camel/component/soroushbot/component/SoroushBotAbstractConsumer.java,"@@ -0,0 +1,157 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.camel.component.soroushbot.component;
+
+import javax.ws.rs.client.Client;
+import javax.ws.rs.client.ClientBuilder;
+import javax.ws.rs.client.WebTarget;
+import javax.ws.rs.core.MediaType;
+
+import com.fasterxml.jackson.databind.ObjectMapper;
+import org.apache.camel.Exchange;
+import org.apache.camel.Processor;
+import org.apache.camel.component.soroushbot.models.Endpoint;
+import org.apache.camel.component.soroushbot.models.SoroushMessage;
+import org.apache.camel.component.soroushbot.service.SoroushService;
+import org.apache.camel.support.DefaultConsumer;
+import org.glassfish.jersey.client.ClientProperties;
+import org.glassfish.jersey.media.sse.EventInput;
+import org.glassfish.jersey.media.sse.InboundEvent;
+import org.glassfish.jersey.media.sse.SseFeature;
+
+import static org.apache.camel.component.soroushbot.utils.StringUtils.ordinal;
+
+/**
+ * this component handle logic for getting message from Soroush server and for each message
+ * it calls abstract function {@link SoroushBotAbstractConsumer#sendExchange(Exchange)}
+ * each subclass should handle how it will start the processing of the exchange
+ */
+public abstract class SoroushBotAbstractConsumer extends DefaultConsumer {
+    SoroushBotEndpoint endpoint;
+    /**
+     * {@link ObjectMapper} for parse message JSON
+     */
+    ObjectMapper objectMapper = new ObjectMapper();
+
+    public SoroushBotAbstractConsumer(SoroushBotEndpoint endpoint, Processor processor) {
+        super(endpoint, processor);
+        this.endpoint = endpoint;
+    }
+
+    /**
+     * create an {@link EventInput} that connect to soroush SSE server and read events
+     *
+     * @param target
+     * @return
+     */
+    private EventInput createEvent(WebTarget target) {
+        EventInput eventInput = target.request().get(EventInput.class);
+        eventInput.setChunkType(MediaType.SERVER_SENT_EVENTS);
+        return eventInput;
+    }
+
+    @Override
+    public void doStart() {
+//     create new Thread for listening to Soroush SSE Server so that it release the main camel thread.
+        Thread thread = new Thread(() -> {
+            try {
+                SoroushBotAbstractConsumer.this.run();
+            } catch (InterruptedException e) {
+                e.printStackTrace();","[{'comment': 'should likely just ignore if its interrupted which may happen during shutdown', 'commenter': 'davsclaus'}]"
2861,components/camel-soroush/src/main/java/org/apache/camel/component/soroushbot/utils/MultiQueueWithTopicThreadPool.java,"@@ -0,0 +1,144 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.camel.component.soroushbot.utils;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.RejectedExecutionException;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * a simple thread pool that send each job to a thread based on the jobs topic,
+ */
+public class MultiQueueWithTopicThreadPool {","[{'comment': ""Why not use either commons-pool, or use Java's ExecutorService which is also a thread pool"", 'commenter': 'davsclaus'}, {'comment': 'Since we want that every message from the same user to be processed one by one, i.e. no 2 message from the same user execute concurrently, we create a new simple thread pool that let us select a thread by a topic. It guarantees that all tasks with the same `topic` execute in the same thread. We use `userIds` as the topic of each task.', 'commenter': 'hossein-nasr'}, {'comment': 'Ah okay, could you add the above to the javadoc so its a bit more clear why we are doing this, thanks.', 'commenter': 'davsclaus'}]"
2861,components/camel-soroush/src/test/resources/log4j2.properties,"@@ -0,0 +1,22 @@
+## ---------------------------------------------------------------------------
+## Licensed to the Apache Software Foundation (ASF) under one or more
+## contributor license agreements.  See the NOTICE file distributed with
+## this work for additional information regarding copyright ownership.
+## The ASF licenses this file to You under the Apache License, Version 2.0
+## (the ""License""); you may not use this file except in compliance with
+## the License.  You may obtain a copy of the License at
+##
+##      http://www.apache.org/licenses/LICENSE-2.0
+##
+## Unless required by applicable law or agreed to in writing, software
+## distributed under the License is distributed on an ""AS IS"" BASIS,
+## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+## See the License for the specific language governing permissions and
+## limitations under the License.
+## ---------------------------------------------------------------------------
+appender.out.type=Console","[{'comment': 'You should add a logging to file by default, see how we do this in other camel components', 'commenter': 'davsclaus'}]"
2885,components/camel-pulsar/src/main/java/org/apache/camel/component/pulsar/PulsarProducer.java,"@@ -16,57 +16,72 @@
  */
 package org.apache.camel.component.pulsar;
 
-import java.util.Map;
-
 import org.apache.camel.Exchange;
 import org.apache.camel.Message;
 import org.apache.camel.NoTypeConversionAvailableException;
 import org.apache.camel.TypeConversionException;
-import org.apache.camel.component.pulsar.utils.message.PulsarMessageHeaders;
 import org.apache.camel.component.pulsar.utils.message.PulsarMessageUtils;
-import org.apache.camel.support.DefaultProducer;
+import org.apache.camel.impl.DefaultProducer;
 import org.apache.pulsar.client.api.Producer;
 import org.apache.pulsar.client.api.ProducerBuilder;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 public class PulsarProducer extends DefaultProducer {
 
+    private static final Logger LOGGER = LoggerFactory.getLogger(PulsarProducer.class);
+
     private final PulsarEndpoint pulsarEndpoint;
+    private Producer<byte[]> producer;
 
     public PulsarProducer(PulsarEndpoint pulsarEndpoint) {
         super(pulsarEndpoint);
-
         this.pulsarEndpoint = pulsarEndpoint;
     }
 
+    public static PulsarProducer create(final PulsarEndpoint pulsarEndpoint) {","[{'comment': 'This is never used as far as I see.\r\n\r\nAlso the producer is already created in the PulsarEndpoint.\r\n\r\nhttps://github.com/apache/camel/blob/master/components/camel-pulsar/src/main/java/org/apache/camel/component/pulsar/PulsarEndpoint.java#L60', 'commenter': 'oscerd'}, {'comment': 'Sorry an issue with cherry-picking a commit has brought in some deleted code will re-remove', 'commenter': 'rshermanTHG'}]"
2885,components/camel-pulsar/src/main/java/org/apache/camel/component/pulsar/PulsarProducer.java,"@@ -16,57 +16,72 @@
  */
 package org.apache.camel.component.pulsar;
 
-import java.util.Map;
-
 import org.apache.camel.Exchange;
 import org.apache.camel.Message;
 import org.apache.camel.NoTypeConversionAvailableException;
 import org.apache.camel.TypeConversionException;
-import org.apache.camel.component.pulsar.utils.message.PulsarMessageHeaders;
 import org.apache.camel.component.pulsar.utils.message.PulsarMessageUtils;
-import org.apache.camel.support.DefaultProducer;
+import org.apache.camel.impl.DefaultProducer;","[{'comment': 'Will revert this change', 'commenter': 'rshermanTHG'}]"
2888,examples/camel-example-artemis/src/main/java/org/apache/camel/example/artemis/ArtemisMain.java,"@@ -0,0 +1,64 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.example.artemis;
+
+import org.apache.camel.component.jms.*;","[{'comment': 'This may break the codestyle. You can run mvn clean install -Psourcecheck to find the issues and fix them', 'commenter': 'oscerd'}]"
2888,examples/camel-example-artemis/README.md,"@@ -0,0 +1,81 @@
+# Widget and Gadget Example - Plain Java","[{'comment': 'The title should likely by ... - Apache Artemis', 'commenter': 'davsclaus'}]"
2891,components/camel-coap/src/main/resources/META-INF/services/org/apache/camel/component/coaps,"@@ -0,0 +1,18 @@
+#","[{'comment': 'on master the META-INF is generated automatically during the component build, so you can safely remove this', 'commenter': 'oscerd'}, {'comment': 'What is it automatically generated from? If I remove it then the build fails (mvn clean install in components/camel-coap)? ', 'commenter': 'coheigea'}, {'comment': 'you need to add the coaps scheme here:\r\n\r\nhttps://github.com/apache/camel/pull/2891/files#diff-aa2b51fc80674de4afee8a0e0374a3e3R47\r\n\r\nSo it needs to look like:\r\n\r\n`@Component(""coap,coaps"")`', 'commenter': 'oscerd'}, {'comment': 'Thanks, fixed.', 'commenter': 'coheigea'}]"
2913,tests/camel-blueprint-cxf-test/src/test/java/org/apache/camel/test/cxf/blueprint/CxfRsEndpointBeansTest.java,"@@ -43,7 +57,40 @@ public void testCxfBusInjection() {
         JAXRSClientFactoryBean client = serviceEndpoint.createJAXRSClientFactoryBean();
         assertEquals(""These cxfrs endpoints don't share the same bus"", server.getBus().getId(), client.getBus().getId());
     }
-    
 
+    @Test
+    public void testDestinationOverrideURLHandling() {
+
+        try {
+            context.getRouteController().startRoute(""url-override-route"");
+        } catch (Exception e) {
+            fail(e.getMessage());
+        }
+
+        List<String> expected = Arrays.asList(
+                                              ""foo1"",
+                                              ""foo2"",
+                                              ""foo1"",
+                                              ""foo2"",
+                                              ""foo1"");
+
+        expected.forEach(host -> pT.send(exchange -> {
+            Message in = exchange.getIn();
+            in.setHeader(CxfConstants.CAMEL_CXF_RS_USING_HTTP_API, false);
+            in.setHeader(CxfConstants.OPERATION_NAME, ""getCustomer"");
+            in.setBody(""Scott"");
+            in.setHeader(Exchange.ACCEPT_CONTENT_TYPE, ""application/json"");
+            in.setHeader(Exchange.DESTINATION_OVERRIDE_URL, ""http://"" + host);
+            in.setHeader(Exchange.HTTP_METHOD, ""GET"");
+        }));
+
+        MockEndpoint mockEndpoint = getMockEndpoint(""mock:resultURLOverride"");
+        Assert.assertArrayEquals(expected.toArray(),
+                                 mockEndpoint.getExchanges().stream()
+                                     .map(exchange -> exchange.getProperty(Exchange.EXCEPTION_CAUGHT, ProcessingException.class).getCause().toString())
+                                     .map(exceptionMessage -> exceptionMessage.split(""\\: "")[1])
+                                     .collect(Collectors.toList()).toArray());
+
+    }","[{'comment': 'I think here you may need to run maven with the sourcechek profile and fix eventually found Code style issues.', 'commenter': 'oscerd'}, {'comment': 'I have done before the PR and seems ok.\r\n```\r\n[INFO] --- maven-checkstyle-plugin:3.0.0:checkstyle (default-cli) @ camel-blueprint-cxf-test ---\r\n[INFO] Starting audit...\r\nAudit done.\r\n\r\n```', 'commenter': 'agagliardi'}]"
2915,platforms/karaf/features/src/main/resources/features.xml,"@@ -1465,6 +1465,13 @@
     <bundle dependency='true'>mvn:org.apache.servicemix.bundles/org.apache.servicemix.bundles.jing/${jing-bundle-version}</bundle>
     <bundle>mvn:org.apache.camel/camel-jing/${project.version}</bundle>
   </feature>
+  <feature name='camel-jira' version='${project.version}' start-level='50'>
+    <feature version='${project.version}'>camel-core</feature>
+    <bundle dependency='true'>mvn:org.apache.servicemix.bundles/org.apache.servicemix.bundles.ant/${ant-bundle-version}</bundle>
+    <bundle dependency='true'>mvn:org.apache.servicemix.bundles/org.apache.servicemix.bundles.isorelax/${isorelax-bundle-version}</bundle>
+    <bundle dependency='true'>mvn:org.apache.servicemix.bundles/org.apache.servicemix.bundles.jira-rest/${jira-rest-bundle-version}</bundle>","[{'comment': ""This jira-rest bundle doesn't exist.\r\n\r\nhttp://repo2.maven.org/maven2/org/apache/servicemix/bundles/\r\n\r\nThis looks like the old camel-jira feature? We need a new one, I guess. I think the guava version used in the component will create problem to the feature."", 'commenter': 'oscerd'}, {'comment': 'There is no jira bundle there, so I removed the entry from xml.', 'commenter': 'claudio4j'}]"
2915,tests/camel-itest-karaf/src/test/java/org/apache/camel/itest/karaf/CamelJiraRestTest.java,"@@ -0,0 +1,33 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.itest.karaf;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.ops4j.pax.exam.junit.PaxExam;
+
+@RunWith(PaxExam.class)
+public class CamelJiraRestTest extends BaseKarafTest {","[{'comment': 'Is this one working? The test should be CamelJiraTest, because the feature has been named camel-jira as the component', 'commenter': 'oscerd'}, {'comment': 'Just removed it, as there is no bundle.', 'commenter': 'claudio4j'}]"
2915,parent/pom.xml,"@@ -385,6 +386,8 @@
         <jgroups-raft-jgroups-version>4.0.15.Final</jgroups-raft-jgroups-version>
         <jgroups-raft-leveldbjni-version>1.8</jgroups-raft-leveldbjni-version>
         <jgroups-raft-mapdb-version>1.0.8</jgroups-raft-mapdb-version>
+        <jira-guava-version>26.0-jre</jira-guava-version>
+        <jira-rest-client-api-version>5.1.2-2bd0a62e</jira-rest-client-api-version>","[{'comment': ""Just noticed this: is this a final version or stuff like that? Because if it's something like a dev build, we cannot rely on their maven repository."", 'commenter': 'oscerd'}, {'comment': 'We already had not really good experience with external maven repo\r\n', 'commenter': 'oscerd'}, {'comment': 'Changed to atlassian jira client 5.1.0, the differences between 5.1.2 and 5.1.0 are minimal and tests passing. ', 'commenter': 'claudio4j'}]"
2924,parent/pom.xml,"@@ -253,13 +253,13 @@
         <google-mail-guava-version>17.0</google-mail-guava-version>
         <google-truth-version>0.30</google-truth-version>
         <grizzly-websockets-version>2.3.25</grizzly-websockets-version>
-        <grpc-version>1.15.0</grpc-version>
-        <grpc-google-auth-library-version>0.9.0</grpc-google-auth-library-version>
-        <grpc-guava-version>20.0</grpc-guava-version>
+        <grpc-version>1.20.0</grpc-version>
+        <grpc-google-auth-library-version>0.13.0</grpc-google-auth-library-version>
+        <grpc-guava-version>26.0-android</grpc-guava-version>
         <grpc-java-jwt-version>3.2.0</grpc-java-jwt-version>
-        <grpc-netty-tcnative-boringssl-static-version>2.0.18.Final</grpc-netty-tcnative-boringssl-static-version>
-        <grpc-bundle-version>1.15.0_1</grpc-bundle-version>
-        <grpc-errorprone-version>2.2.0</grpc-errorprone-version>
+        <grpc-netty-tcnative-boringssl-static-version>2.0.22.Final</grpc-netty-tcnative-boringssl-static-version>
+        <grpc-bundle-version>1.20.0_1</grpc-bundle-version>
+        <grpc-errorprone-version>2.3.0</grpc-errorprone-version>","[{'comment': 'Looks like <grpc-errorprone-version> must be 2.3.2', 'commenter': 'dmvolod'}]"
2947,components/camel-file/src/main/docs/file-component.adoc,"@@ -113,6 +113,7 @@ with the following path and query parameters:
 | *probeContentType* (consumer) | Whether to enable probing of the content type. If enable then the consumer uses Files#probeContentType(java.nio.file.Path) to determine the content-type of the file, and store that as a header with key Exchange#FILE_CONTENT_TYPE on the Message. | false | boolean
 | *processStrategy* (consumer) | A pluggable org.apache.camel.component.file.GenericFileProcessStrategy allowing you to implement your own readLock option or similar. Can also be used when special conditions must be met before a file can be consumed, such as a special ready file exists. If this option is set then the readLock option does not apply. |  | GenericFileProcess Strategy
 | *startingDirectoryMustExist* (consumer) | Whether the starting directory must exist. Mind that the autoCreate option is default enabled, which means the starting directory is normally auto created if it doesn't exist. You can disable autoCreate and enable this to ensure the starting directory must exist. Will thrown an exception if the directory doesn't exist. | false | boolean
+| *startingDirectoryMustHave Access* (consumer) | Whether the starting directory has access permissions. Mind that the startingDirectoryMustExist parameter must be set to true in order to verify that the directory exists. Will thrown an exception if the directory doesn't have read and write permissions. | false | boolean","[{'comment': 'Typo', 'commenter': 'onderson'}]"
2947,core/camel-core/src/test/java/org/apache/camel/component/file/FileConsumerStartingDirectoryMustHaveAccessTest.java,"@@ -0,0 +1,64 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.file;
+
+import java.io.File;
+import java.io.IOException;
+import org.apache.camel.ContextTestSupport;
+import org.apache.camel.Endpoint;
+import org.apache.camel.Exchange;
+import org.apache.camel.Processor;
+import org.junit.Test;
+
+public class FileConsumerStartingDirectoryMustHaveAccessTest extends ContextTestSupport {
+
+  @Override
+  public void setUp() throws Exception {
+    File file1 = new File(""./target/noAccess"");
+    if (file1.exists()) {
+      file1.setReadable(true);
+    }
+    deleteDirectory(""target/noAccess"");
+    file1.mkdirs();
+    file1.setReadable(false);
+    super.setUp();
+  }
+
+  @Override
+  public void tearDown() throws Exception {
+    File file1 = new File(""./target/noAccess"");
+    if (file1.exists()) {
+      file1.setReadable(true);
+    }
+    super.tearDown();
+  }
+
+  @Test","[{'comment': 'Expected exception could have been set here instead of doing assertion on exception message', 'commenter': 'onderson'}]"
2948,components/camel-grok/src/test/resources/org/apache/camel/component/grok/data/access_log,"@@ -0,0 +1,1536 @@
+64.242.88.10 - - [07/Mar/2004:16:05:49 -0800] ""GET /twiki/bin/edit/Main/Double_bounce_sender?topicparent=Main.ConfigurationVariables HTTP/1.1"" 401 12846","[{'comment': 'I guess this is a file to be ignored to check-in', 'commenter': 'onderson'}, {'comment': 'This file is used in GrokFileUnmarshalTest. But it was quite large, I have trimmed it to more reasonable 5 lines.', 'commenter': 'bedlaj'}]"
2948,components/readme.adoc,"@@ -936,6 +936,8 @@ Number of Data Formats: 43 in 35 JAR artifacts (0 deprecated)
 
 | link:camel-flatpack/src/main/docs/flatpack-dataformat.adoc[Flatpack] (camel-flatpack) | 2.1 | The Flatpack data format is used for working with flat payloads (such as CSV, delimited, or fixed length formats).
 
+| link:camel-grok/src/main/docs/grok-dataformat.adoc[Grok] (camel-grok) | 3.0 | To use a grok data format.","[{'comment': 'This adoc file seems to be absent. It would be good to add one.', 'commenter': 'onderson'}, {'comment': 'True, adoc and javadocs added in e707a61d6051be9b8f84ddebaac2b6975934eefd', 'commenter': 'bedlaj'}]"
2948,components/camel-grok/src/main/java/org/apache/camel/component/grok/GrokDataFormat.java,"@@ -0,0 +1,185 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.grok;
+
+import java.io.BufferedReader;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.OutputStream;
+import java.nio.CharBuffer;
+import java.util.*;","[{'comment': 'There is a checkstyle issue here I think', 'commenter': 'davsclaus'}, {'comment': 'Strange, Maven plugin doesnt see this.\r\n\r\n> [INFO] --- maven-checkstyle-plugin:3.0.0:checkstyle (default-cli) @ camel-grok ---\r\n[INFO] Starting audit...\r\nAudit done.\r\n\r\nI expect you mean that I should expand that java.util.* import, right? ', 'commenter': 'bedlaj'}, {'comment': 'java.util looks excluded from AvoidStarImport module - https://github.com/apache/camel/blob/master/buildingtools/src/main/resources/camel-checkstyle.xml', 'commenter': 'bedlaj'}, {'comment': 'Ah ok', 'commenter': 'davsclaus'}]"
2950,components/camel-ahc/src/main/docs/ahc-component.adoc,"@@ -3,11 +3,11 @@
 
 *Available as of Camel version 2.8*
 
-The ahc: component provides HTTP based endpoints
+The *ahc:* component provides HTTP based endpoints
 for consuming external HTTP resources (as a client to call external","[{'comment': 'The *ahc:* is not rendered well on the website. \r\n\r\nhttps://camel.apache.org/staging/', 'commenter': 'oscerd'}, {'comment': 'Changed to capitals.', 'commenter': 'akoufoudakis'}]"
2952,parent/pom.xml,"@@ -384,7 +384,7 @@
         <jgroups-raft-jgroups-version>4.0.15.Final</jgroups-raft-jgroups-version>
         <jgroups-raft-leveldbjni-version>1.8</jgroups-raft-leveldbjni-version>
         <jgroups-raft-mapdb-version>1.0.8</jgroups-raft-mapdb-version>
-        <jira-guava-version>26.0-jre</jira-guava-version>
+        <jira-guava-version>20.0</jira-guava-version>","[{'comment': 'Why this one was changed ? Just curiosity', 'commenter': 'oscerd'}, {'comment': ""The jira rest java client (JRJC) 5.1.0 doesn't define a guava version. As previously I used JRJC 5.1.2, its pom.xml defined the guava version, but when I changed to 5.1.0, I forgot to add the guava version.\r\nhttps://bitbucket.org/atlassian/jira-rest-java-client/src/jira-rest-java-client-parent-5.1.0/pom.xml"", 'commenter': 'claudio4j'}, {'comment': 'ok. thanks', 'commenter': 'oscerd'}]"
2952,components/camel-jira/src/main/java/org/apache/camel/component/jira/consumer/NewCommentsConsumer.java,"@@ -43,15 +43,17 @@
 
     public NewCommentsConsumer(JiraEndpoint endpoint, Processor processor) {
         super(endpoint, processor);
-        LOG.info(""JIRA NewCommentsConsumer: Indexing current issue comments..."");
-        getComments(false);
+        LOG.info(""JIRA NewCommentsConsumer: Indexing current issue comments."");","[{'comment': 'We should move such tasks to doStart and not in constructors', 'commenter': 'davsclaus'}, {'comment': 'Done. Thanks for the review.', 'commenter': 'claudio4j'}]"
2952,components/camel-jira/src/main/java/org/apache/camel/component/jira/consumer/AbstractJiraConsumer.java,"@@ -47,7 +47,7 @@ public AbstractJiraConsumer(JiraEndpoint endpoint, Processor processor) {
 
     // Ignore maxResults if it's <= 0.
     protected List<Issue> getIssues(String jql, int start, int maxPerQuery, int maxResults) {
-        LOG.info(""Indexing current JIRA issues..."");
+        LOG.info(""Start indexing current JIRA issues..."");","[{'comment': 'Do we really need this INFO logging noise? If this method is invoked frequently you get spammed with logs. Can we lower this to DEBUG', 'commenter': 'davsclaus'}, {'comment': 'Done. Thanks for the review.', 'commenter': 'claudio4j'}]"
2952,components/camel-jira/src/main/java/org/apache/camel/component/jira/consumer/NewCommentsConsumer.java,"@@ -60,21 +62,25 @@ protected int poll() throws Exception {
     }
 
     // In the end, we want *new* comments oldest to newest.
-    private Stack<Comment> getComments(boolean loadComments) {
-        Stack<Comment> newComments = new Stack<>();
+    @SuppressWarnings(""ConstantConditions"")
+    private List<Comment> getComments() {
+        LOG.info(""Start: Jira NewCommentsConsumer: retrieving issue comments. Last comment id: {}"", lastCommentId);","[{'comment': 'Do we really need this INFO logging noise? If this method is invoked frequently you get spammed with logs. Can we lower this to DEBUG', 'commenter': 'davsclaus'}]"
2970,core/camel-support/src/main/java/org/apache/camel/support/PropertyBindingSupport.java,"@@ -287,9 +323,22 @@ public static boolean bindProperties(CamelContext camelContext, Object target, M
 
         for (Iterator<Map.Entry<String, Object>> iter = properties.entrySet().iterator(); iter.hasNext();) {
             Map.Entry<String, Object> entry = iter.next();
-            if (bindProperty(camelContext, target, entry.getKey(), entry.getValue(), nesting, deepNesting, fluentBuilder, reference, placeholder)) {
-                iter.remove();
-                rc = true;
+            String key = entry.getKey();
+            Object value = entry.getValue();
+
+            if (isNotEmpty(optionPrefix)) {
+                if (!key.startsWith(optionPrefix)) {
+                    return false;","[{'comment': 'I think this is wrong, we should just skip keys without the prefix, and not return', 'commenter': 'davsclaus'}, {'comment': 'oh yes, taken fomr the introspection support, thx for spotting', 'commenter': 'lburgazzoli'}]"
2970,core/camel-support/src/main/java/org/apache/camel/support/PropertyBindingSupport.java,"@@ -16,6 +16,9 @@
  */
 package org.apache.camel.support;
 
+import static org.apache.camel.support.IntrospectionSupport.findSetterMethods;","[{'comment': 'Checkstyle issues here', 'commenter': 'davsclaus'}, {'comment': 'As the import order is changed now', 'commenter': 'davsclaus'}]"
2970,core/camel-support/src/main/java/org/apache/camel/support/PropertyBindingSupport.java,"@@ -258,11 +257,25 @@ private static boolean doAutowireSingletonPropertiesFromRegistry(CamelContext ca
      * @return              true if one or more properties was bound
      */
     public static boolean bindProperties(CamelContext camelContext, Object target, Map<String, Object> properties) {
-        return bindProperties(camelContext, target, properties, true, true, true, true, true);
+        return bindProperties(camelContext, target, properties, null);
     }
 
     /**
-     * Binds the properties to the target object, and removes the property that was bound from properties.
+     * Binds the properties with the given prefix to the target object, and removes the property that was bound from properties.
+     * Note that the prefix is removed from the key before the property is bound.
+     *
+     * @param camelContext  the camel context
+     * @param target        the target object
+     * @param properties    the properties where the bound properties will be removed from
+     * @param optionPrefix  the prefix used to filter properties","[{'comment': 'Also add the optionPrefix to the Builder (see top of class) so you can use this style as well', 'commenter': 'davsclaus'}]"
2971,components/camel-ahc/src/test/java/org/apache/camel/component/ahc/AhcProducerSessionTest.java,"@@ -77,6 +78,7 @@ public void testProducerInstanceSession() throws Exception {
     }
 
     @Test
+    @org.junit.Ignore(""Failing cookie test with Jetty 9.4"")","[{'comment': 'These two tests are not fixed.', 'commenter': 'oscerd'}, {'comment': ""@oscerd Yeah I couldn't figure out how to get these tests to pass. The tests make a call and set a cookie and then make another call. With the upgrade, the cookie is not set for the second call. I'm not sure if it's an issue with the test setup or a genuine bug."", 'commenter': 'coheigea'}, {'comment': 'Understood, lets check later on this.', 'commenter': 'oscerd'}]"
2971,components/camel-ahc/src/test/java/org/apache/camel/component/ahc/BaseAhcTest.java,"@@ -88,55 +88,52 @@ protected SSLContextParameters createSSLContextParameters() {
         sslContextParameters.setKeyManagers(kmp);
         sslContextParameters.setTrustManagers(tmp);
         sslContextParameters.setServerParameters(scsp);
-        // use SSLv3 to avoid issue with (eg disable TLS)
-        // Caused by: javax.net.ssl.SSLException: bad record MAC
-        sslContextParameters.setSecureSocketProtocol(""SSLv3"");","[{'comment': 'I think this will break the build on JDK 11, so this still need to be there. @johnpoth can you confirm?', 'commenter': 'oscerd'}, {'comment': 'The tests pass with JDK 11', 'commenter': 'coheigea'}]"
2971,components/camel-jetty/src/test/java/org/apache/camel/component/jetty/HttpBridgeEncodedPathTest.java,"@@ -44,6 +44,7 @@ public void testEncodedQuery() throws Exception {
     }
 
     @Test
+    @org.junit.Ignore(""This test fails with a httpclient upgrade"")","[{'comment': 'This test is not fixed.', 'commenter': 'oscerd'}, {'comment': 'Actually this test was already ignored on master, so I will remove this ignore', 'commenter': 'coheigea'}]"
2978,components/camel-twitter/src/main/docs/twitter-search-component.adoc,"@@ -31,6 +31,15 @@ The Twitter Search component supports 10 options, which are listed below.
 
 ### Endpoint Options
 
+The search keywords query should be specified accordingly to https://developer.twitter.com/en/docs/tweets/search/guides/standard-operators[twitter search operators].
+
+Examples of a search query:
+
+* `syndesis OR fuse`","[{'comment': 'Can we provide some other examples that are dogs and cats like, eg not referring to a commercial vendors product name', 'commenter': 'davsclaus'}, {'comment': 'Done.', 'commenter': 'claudio4j'}]"
2982,core/camel-core/src/main/java/org/apache/camel/reifier/ProcessorReifier.java,"@@ -187,11 +187,15 @@
     protected final Logger log = LoggerFactory.getLogger(getClass());
 
     protected final T definition;
-    
+
     public ProcessorReifier(T definition) {
         this.definition = definition;
     }
 
+    public static void registerReifier(Class<?> dataFormatClass, Function<ProcessorDefinition<?>, ProcessorReifier<? extends ProcessorDefinition<?>>> creator) {","[{'comment': 'This is a copy/paste mistake with data format ;)', 'commenter': 'davsclaus'}, {'comment': 'should be fixed now', 'commenter': 'lburgazzoli'}]"
2984,components/camel-mongodb3/src/main/java/org/apache/camel/component/mongodb3/MongoDbTailingProcess.java,"@@ -205,8 +206,8 @@ private void doRun() {
 
     private void awaitStopped() throws InterruptedException {
         if (!stopped) {
-            LOG.info(""Going to wait for stopping"");
-            stoppedLatch.await();
+            LOG.info(""Going to wait for stopping, timeout set to 10 seconds"");
+            stoppedLatch.await(10, TimeUnit.SECONDS);","[{'comment': 'make it configurable', 'commenter': 'lburgazzoli'}]"
2984,components/camel-mongodb3/src/main/java/org/apache/camel/component/mongodb3/MongoDbEndpoint.java,"@@ -289,7 +290,9 @@ public Exchange createMongoDbExchange(Document dbObj) {
     
     @Override
     protected void doStart() throws Exception {
-        mongoConnection = CamelContextHelper.mandatoryLookup(getCamelContext(), connectionBean, MongoClient.class);
+        if( mongoConnection == null ) {
+            mongoConnection = CamelContextHelper.mandatoryLookup(getCamelContext(), connectionBean, MongoClient.class);
+        }
         log.debug(""Resolved the connection with the name {} as {}"", connectionBean, mongoConnection);","[{'comment': 'this is misleading as the `mongoConnection` is now unrelated from the `connectionBean` parameter', 'commenter': 'lburgazzoli'}, {'comment': 'Maybe creating a new URIParam beside mongoConnection? but in that way we may end up having 2 connection beans... I don\'t like that either. What if we get the `mongoConnection` as originally was and if that is null ""fallback"" to the one set by properties? I\'d like to make backward compatible change and leave default behavior as it was before the change.', 'commenter': 'squakez'}, {'comment': 'I would say the opposite so your implementation is correct. \r\nMy reasoning is that assuming I have a statement like:\r\n\r\n    to(""mongodb:test?mongoConnection=#myConnection"")\r\n\r\nthen I do expect that the endpoint uses `myConnection` as I explicit set it. Doing the opposite is going to cause some headhake.\r\n\r\nMy comment was more about the log entry that could be wrong in case the connections comes from the `mongoConnection` parameter :-)', 'commenter': 'lburgazzoli'}]"
2984,components/camel-mongodb3/src/test/java/org/apache/camel/component/mongodb3/MongoDbOperationsWithConnectionPropertyTest.java,"@@ -0,0 +1,47 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.mongodb3;
+
+import java.util.Properties;
+
+import org.apache.camel.CamelContext;
+import org.apache.camel.component.properties.PropertiesComponent;
+import org.apache.camel.spring.SpringCamelContext;
+import org.springframework.context.annotation.AnnotationConfigApplicationContext;
+
+import com.mongodb.MongoClient;
+
+public class MongoDbOperationsWithConnectionPropertyTest extends MongoDbOperationsTest {
+
+    @Override
+    protected CamelContext createCamelContext() throws Exception {
+        applicationContext = new AnnotationConfigApplicationContext(EmbedMongoConfiguration.class);","[{'comment': 'I think this can be simplified by using the camel registry to lookup the bean you are looking for.', 'commenter': 'lburgazzoli'}, {'comment': 'I replicated the previous test cases that was using the same logic. I could work it around but I should refactor the previous test cases as well...', 'commenter': 'squakez'}, {'comment': 'not strictly needed, you can invoke `super.createCamelContext()` here and grab `myDb` and properties component via camel registry', 'commenter': 'lburgazzoli'}, {'comment': ""The first version was like that but I ended up copying the entire method as I was not aware I could use context to get the property beans! Thanks, I'll try that!"", 'commenter': 'squakez'}]"
2984,components/camel-mongodb3/src/test/java/org/apache/camel/component/mongodb3/MongoDbOperationsWithConnectionPropertyTest.java,"@@ -0,0 +1,47 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.mongodb3;
+
+import java.util.Properties;
+
+import org.apache.camel.CamelContext;
+import org.apache.camel.component.properties.PropertiesComponent;
+import org.apache.camel.spring.SpringCamelContext;
+import org.springframework.context.annotation.AnnotationConfigApplicationContext;
+
+import com.mongodb.MongoClient;
+
+public class MongoDbOperationsWithConnectionPropertyTest extends MongoDbOperationsTest {
+
+    @Override
+    protected CamelContext createCamelContext() throws Exception {
+        applicationContext = new AnnotationConfigApplicationContext(EmbedMongoConfiguration.class);
+        @SuppressWarnings(""deprecation"")
+        CamelContext ctx = SpringCamelContext.springCamelContext(applicationContext, true);
+        PropertiesComponent pc = new PropertiesComponent(""classpath:mongodb.test.properties"");
+        MongoClient cli = (MongoClient) applicationContext.getBean(""myDb"");
+        Properties initialProperties = pc.getInitialProperties();
+        if ( initialProperties == null ) {
+            initialProperties = new Properties();
+            pc.setInitialProperties(initialProperties);
+        }
+        log.info(""Setting connection bean {} as mongoConnection property."", cli);
+        pc.getInitialProperties().put(""mongoConnection"", cli);","[{'comment': 'there should be a test that ensure the mongo connection is the one you have set through the `mongoConnection` parameter.', 'commenter': 'lburgazzoli'}]"
2984,components/camel-mongodb3/src/main/java/org/apache/camel/component/mongodb3/MongoDbTailingProcess.java,"@@ -0,0 +1,214 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.mongodb3;
+
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+
+import com.mongodb.CursorType;
+import com.mongodb.MongoCursorNotFoundException;
+import com.mongodb.client.MongoCollection;
+import com.mongodb.client.MongoCursor;
+import org.apache.camel.Exchange;
+import org.bson.Document;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import static com.mongodb.client.model.Filters.gt;
+import static org.apache.camel.component.mongodb3.MongoDbConstants.MONGO_ID;
+
+public class MongoDbTailingProcess implements Runnable {","[{'comment': 'I do not see any reference of this class being used ? am I wrong ?', 'commenter': 'lburgazzoli'}, {'comment': ""Not sure why github is marking the entire class as changed... I've just added the await() method adding a timeout in the last method."", 'commenter': 'squakez'}, {'comment': 'I do not see this class at all on github', 'commenter': 'lburgazzoli'}]"
2984,components/camel-mongodb3/src/main/java/org/apache/camel/component/mongodb3/MongoDbEndpoint.java,"@@ -302,8 +303,12 @@ public Exchange createMongoDbExchange(Document dbObj) {
     
     @Override
     protected void doStart() throws Exception {
-        mongoConnection = CamelContextHelper.mandatoryLookup(getCamelContext(), connectionBean, MongoClient.class);
-        log.debug(""Resolved the connection with the name {} as {}"", connectionBean, mongoConnection);
+        if( mongoConnection == null ) {
+            mongoConnection = CamelContextHelper.mandatoryLookup(getCamelContext(), connectionBean, MongoClient.class);
+            log.debug(""Resolved the connection provided by {} context reference as {}"", connectionBean, mongoConnection);
+        }else {","[{'comment': 'I think this will give an error on the codestyle. Can you run the sourcecheck profile and fix the errors? Thanks', 'commenter': 'oscerd'}]"
2984,components/camel-mongodb3/src/main/docs/mongodb3-component.adoc,"@@ -152,7 +154,7 @@ The component supports 3 options, which are listed below.
 // spring-boot-auto-configure options: END
 
 
-Note on options of MongoDB component
+Note on options of MoongoDB component ","[{'comment': 'Is that correct ?', 'commenter': 'lburgazzoli'}, {'comment': 'Fixed!', 'commenter': 'squakez'}]"
2995,docs/components/modules/ROOT/pages/aws-s3-component.adoc,"@@ -87,7 +87,7 @@ with the following path and query parameters:
 [width=""100%"",cols=""2,5,^1,2"",options=""header""]
 |===
 | Name | Description | Default | Type
-| *amazonS3Client* (common) | Reference to a com.amazonaws.services.s3.AmazonS3 in the xref:registry.adocRegistry. |  | AmazonS3
+| *amazonS3Client* (common) | Reference to a com.amazonaws.services.s3.AmazonS3 in the xref:registry.adoc [Registry]. |  | AmazonS3","[{'comment': 'This is part of the javadoc.. you need to modify the javadoc and rebuild', 'commenter': 'oscerd'}, {'comment': 'Thank you Mr.Andrea, Did you mean to use mvn package command?', 'commenter': 'Nayananga'}, {'comment': 'when I use mvn package command every change I did revert back to where I was before.How can I fix that?', 'commenter': 'Nayananga'}, {'comment': 'You need to edit the javadoc related to that parameter in the S3Configuration Java class', 'commenter': 'oscerd'}, {'comment': 'Okay, I found the reason from camel-website readMe. But still not clear about javadoc thing,', 'commenter': 'Nayananga'}, {'comment': 'If you modify the s3configuration class, you need to rebuild the module components/camel-aws-s3 with mvn clean install. After that you can go back to docs folder and run mvn clean package to have the updated adoc under ROOT', 'commenter': 'oscerd'}, {'comment': 'Okay, got it, so do i have to do this for each of every component I`ve changed?', 'commenter': 'Nayananga'}, {'comment': 'Yes.', 'commenter': 'oscerd'}]"
3001,components/camel-aws-s3/src/main/docs/aws-s3-component.adoc,"@@ -87,7 +87,7 @@ with the following path and query parameters:
 [width=""100%"",cols=""2,5,^1,2"",options=""header""]
 |===
 | Name | Description | Default | Type
-| *amazonS3Client* (common) | Reference to a com.amazonaws.services.s3.AmazonS3 in the link:registry.htmlRegistry. |  | AmazonS3
+| *amazonS3Client* (common) | Reference to a com.amazonaws.services.s3.AmazonS3 in the xref:registry.adocRegistry. |  | AmazonS3","[{'comment': 'This seems to be wrong', 'commenter': 'oscerd'}, {'comment': 'even I change s3 configuration class as xref:registry.adoc[Registry] (notice the brackets).It the .adoc generate just like that. Any solutions?', 'commenter': 'Nayananga'}, {'comment': 'or should I keep it as it is?', 'commenter': 'Nayananga'}, {'comment': ""We can check later the way it is generated. It's just minor stuff"", 'commenter': 'oscerd'}, {'comment': 'ok so what should I do now regarding this matter?', 'commenter': 'Nayananga'}, {'comment': 'For the moment leave it as is. We can re-work the docs', 'commenter': 'oscerd'}, {'comment': 'okay, Thank you. (going back to my other tasks)', 'commenter': 'Nayananga'}, {'comment': 'I would just change the doc to say .. in the registry. And then dont have any link. This is how we do it in all the other Camel components.', 'commenter': 'davsclaus'}, {'comment': 'Hello Mr@davsclaus can you take a look now?', 'commenter': 'Nayananga'}]"
3005,components/camel-pg-replication-slot/src/main/java/org/apache/camel/component/pg_replication_slot/PgReplicationSlotComponent.java,"@@ -0,0 +1,42 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.pg_replication_slot;","[{'comment': ""just a personal opinion. i don't like underscores in package names. by name, it is hard to think of one. i would replace underscores with dots which would give more directory depth. i think it is something nicer. don't have a reason, though"", 'commenter': 'onderson'}, {'comment': 'What about `.pg.replicationslot`?', 'commenter': 'bahaa'}, {'comment': 'yes good. thanks for doing it.', 'commenter': 'onderson'}]"
3005,components/camel-pg-replication-slot/src/main/java/org/apache/camel/component/pg_replication_slot/PgReplicationSlotConsumer.java,"@@ -0,0 +1,257 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.pg_replication_slot;
+
+import java.net.SocketException;
+import java.nio.ByteBuffer;
+import java.sql.Connection;
+import java.sql.ResultSet;
+import java.sql.SQLException;
+import java.sql.Statement;
+import java.util.Properties;
+import java.util.concurrent.ScheduledExecutorService;
+import java.util.concurrent.ScheduledFuture;
+import java.util.concurrent.TimeUnit;
+
+import org.apache.camel.Exchange;
+import org.apache.camel.Message;
+import org.apache.camel.Processor;
+import org.apache.camel.spi.Synchronization;
+import org.apache.camel.support.ScheduledPollConsumer;
+import org.postgresql.PGConnection;
+import org.postgresql.replication.PGReplicationStream;
+import org.postgresql.replication.fluent.logical.ChainedLogicalStreamBuilder;
+import org.postgresql.util.PSQLException;
+
+/**
+ * The pg-replication-slot consumer.
+ */
+public class PgReplicationSlotConsumer extends ScheduledPollConsumer {
+
+    private final PgReplicationSlotEndpoint endpoint;
+
+    private Connection connection;
+    private PGConnection pgConnection;
+    private PGReplicationStream replicationStream;
+
+    private ScheduledExecutorService scheduledExecutor;
+
+    private byte[] payload;
+
+    PgReplicationSlotConsumer(PgReplicationSlotEndpoint endpoint, Processor processor) {
+        super(endpoint, processor);
+        this.endpoint = endpoint;
+    }
+
+    @Override
+    protected void doStart() throws Exception {
+        super.doStart();
+
+        this.connect();
+
+        if (this.scheduledExecutor == null) {
+            this.scheduledExecutor = this.getEndpoint().getCamelContext().getExecutorServiceManager()
+                    .newSingleThreadScheduledExecutor(this, ""PgReplicationStatusUpdateSender"");
+        }
+    }
+
+    @Override
+    protected void doStop() throws Exception {
+        super.doStop();
+
+        if (this.connection != null) {
+            this.connection.close();
+            this.connection = null;
+        }
+
+        if (this.scheduledExecutor != null) {
+            this.getEndpoint().getCamelContext().getExecutorServiceManager().shutdownNow(this.scheduledExecutor);
+            this.scheduledExecutor = null;
+        }
+    }
+
+    @Override
+    protected int poll() throws Exception {
+        PGReplicationStream stream = getStream();
+
+        if (stream == null) {
+            return 0;
+        }
+
+        try {
+            // The same payload will be sent again and again until the processing is completed successfully.
+            // We should not read another payload before that to guarantee the order of processing.
+            if (this.payload == null) {
+                ByteBuffer msg = stream.readPending();
+
+                if (msg == null) {
+                    return 0;
+                }
+
+                int offset = msg.arrayOffset();
+                byte[] source = msg.array();
+                int length = source.length - offset;
+
+                this.payload = new byte[length];
+                System.arraycopy(source, offset, this.payload, 0, length);
+            }
+        } catch (PSQLException e) {
+            validateConnection(e);
+            throw e;
+        }
+
+        Exchange exchange = this.endpoint.createExchange();
+        exchange.setExchangeId(stream.getLastReceiveLSN().asString());
+
+        Message message = exchange.getIn();
+        message.setBody(this.payload);
+
+        final long delay = this.endpoint.getStatusInterval();
+        ScheduledFuture<?> scheduledFuture = this.scheduledExecutor.scheduleAtFixedRate(() -> {
+            try {
+                log.debug(""Processing took too long. Sending status update to avoid disconnect."");
+                stream.forceUpdateStatus();
+            } catch (SQLException e) {
+                log.error(e.getMessage(), e);
+            }
+        }, delay, delay, TimeUnit.SECONDS);
+
+        exchange.addOnCompletion(new Synchronization() {
+            @Override
+            public void onComplete(Exchange exchange) {
+                processCommit(exchange);
+                scheduledFuture.cancel(true);
+            }
+
+            @Override
+            public void onFailure(Exchange exchange) {
+                processRollback(exchange);
+                scheduledFuture.cancel(true);
+            }
+        });
+
+        getProcessor().process(exchange);
+
+        return 1;
+    }
+
+    private void processCommit(Exchange exchange) {
+        try {
+            PGReplicationStream stream = getStream();
+
+            if (stream == null) {
+                return;
+            }
+
+            stream.setAppliedLSN(stream.getLastReceiveLSN());
+            stream.setFlushedLSN(stream.getLastReceiveLSN());
+            stream.forceUpdateStatus();
+
+            this.payload = null;
+        } catch (PSQLException e) {","[{'comment': 'single catch with | notation can be an option. both exception seems closer, may be good to reconsider this part to simplify and save a couple if lines.', 'commenter': 'onderson'}]"
3005,components/camel-pg-replication-slot/src/main/java/org/apache/camel/component/pg_replication_slot/PgReplicationSlotConsumer.java,"@@ -0,0 +1,257 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.pg_replication_slot;
+
+import java.net.SocketException;
+import java.nio.ByteBuffer;
+import java.sql.Connection;
+import java.sql.ResultSet;
+import java.sql.SQLException;
+import java.sql.Statement;
+import java.util.Properties;
+import java.util.concurrent.ScheduledExecutorService;
+import java.util.concurrent.ScheduledFuture;
+import java.util.concurrent.TimeUnit;
+
+import org.apache.camel.Exchange;
+import org.apache.camel.Message;
+import org.apache.camel.Processor;
+import org.apache.camel.spi.Synchronization;
+import org.apache.camel.support.ScheduledPollConsumer;
+import org.postgresql.PGConnection;
+import org.postgresql.replication.PGReplicationStream;
+import org.postgresql.replication.fluent.logical.ChainedLogicalStreamBuilder;
+import org.postgresql.util.PSQLException;
+
+/**
+ * The pg-replication-slot consumer.
+ */
+public class PgReplicationSlotConsumer extends ScheduledPollConsumer {
+
+    private final PgReplicationSlotEndpoint endpoint;
+
+    private Connection connection;
+    private PGConnection pgConnection;
+    private PGReplicationStream replicationStream;
+
+    private ScheduledExecutorService scheduledExecutor;
+
+    private byte[] payload;
+
+    PgReplicationSlotConsumer(PgReplicationSlotEndpoint endpoint, Processor processor) {
+        super(endpoint, processor);
+        this.endpoint = endpoint;
+    }
+
+    @Override
+    protected void doStart() throws Exception {
+        super.doStart();
+
+        this.connect();
+
+        if (this.scheduledExecutor == null) {
+            this.scheduledExecutor = this.getEndpoint().getCamelContext().getExecutorServiceManager()
+                    .newSingleThreadScheduledExecutor(this, ""PgReplicationStatusUpdateSender"");
+        }
+    }
+
+    @Override
+    protected void doStop() throws Exception {
+        super.doStop();
+
+        if (this.connection != null) {
+            this.connection.close();
+            this.connection = null;
+        }
+
+        if (this.scheduledExecutor != null) {
+            this.getEndpoint().getCamelContext().getExecutorServiceManager().shutdownNow(this.scheduledExecutor);
+            this.scheduledExecutor = null;
+        }
+    }
+
+    @Override
+    protected int poll() throws Exception {
+        PGReplicationStream stream = getStream();
+
+        if (stream == null) {
+            return 0;
+        }
+
+        try {
+            // The same payload will be sent again and again until the processing is completed successfully.
+            // We should not read another payload before that to guarantee the order of processing.
+            if (this.payload == null) {
+                ByteBuffer msg = stream.readPending();
+
+                if (msg == null) {
+                    return 0;
+                }
+
+                int offset = msg.arrayOffset();
+                byte[] source = msg.array();
+                int length = source.length - offset;
+
+                this.payload = new byte[length];
+                System.arraycopy(source, offset, this.payload, 0, length);
+            }
+        } catch (PSQLException e) {
+            validateConnection(e);
+            throw e;
+        }
+
+        Exchange exchange = this.endpoint.createExchange();
+        exchange.setExchangeId(stream.getLastReceiveLSN().asString());
+
+        Message message = exchange.getIn();
+        message.setBody(this.payload);
+
+        final long delay = this.endpoint.getStatusInterval();
+        ScheduledFuture<?> scheduledFuture = this.scheduledExecutor.scheduleAtFixedRate(() -> {
+            try {
+                log.debug(""Processing took too long. Sending status update to avoid disconnect."");
+                stream.forceUpdateStatus();
+            } catch (SQLException e) {
+                log.error(e.getMessage(), e);
+            }
+        }, delay, delay, TimeUnit.SECONDS);
+
+        exchange.addOnCompletion(new Synchronization() {
+            @Override
+            public void onComplete(Exchange exchange) {
+                processCommit(exchange);
+                scheduledFuture.cancel(true);
+            }
+
+            @Override
+            public void onFailure(Exchange exchange) {
+                processRollback(exchange);
+                scheduledFuture.cancel(true);
+            }
+        });
+
+        getProcessor().process(exchange);
+
+        return 1;
+    }
+
+    private void processCommit(Exchange exchange) {
+        try {
+            PGReplicationStream stream = getStream();
+
+            if (stream == null) {
+                return;
+            }
+
+            stream.setAppliedLSN(stream.getLastReceiveLSN());
+            stream.setFlushedLSN(stream.getLastReceiveLSN());
+            stream.forceUpdateStatus();
+
+            this.payload = null;
+        } catch (PSQLException e) {
+            validateConnection(e);
+        } catch (SQLException e) {
+            getExceptionHandler().handleException(""Exception while sending feedback to PostgreSQL."", exchange, e);
+        }
+    }
+
+    private void processRollback(Exchange exchange) {
+        Exception cause = exchange.getException();
+        if (cause != null) {
+            getExceptionHandler().handleException(""Error during processing exchange. Will attempt to process the message on next poll."", exchange, cause);
+        }
+    }
+
+    private void createSlot() throws SQLException {
+        this.pgConnection.getReplicationAPI()
+                .createReplicationSlot()
+                .logical()
+                .withSlotName(this.endpoint.getSlot())
+                .withOutputPlugin(this.endpoint.getOutputPlugin())
+                .make();
+    }
+
+    private boolean isSlotCreated() throws SQLException {
+        String sql = String.format(""SELECT count(*) FROM pg_replication_slots WHERE slot_name = '%s';"", this.endpoint.getSlot());
+
+        try (Statement statement = this.connection.createStatement(); ResultSet resultSet = statement.executeQuery(sql)) {
+            resultSet.next();
+            return resultSet.getInt(1) > 0;
+        }
+    }
+
+    private PGReplicationStream getStream() throws SQLException {
+        if (this.replicationStream != null && !this.replicationStream.isClosed()) {
+            return this.replicationStream;
+        }
+
+        if (isSlotActive()) {
+            log.info(String.format(""Slot: %s is active. Waiting for it to be available."", this.endpoint.getSlot()));
+            return null;
+        }
+
+        ChainedLogicalStreamBuilder streamBuilder = this.pgConnection.getReplicationAPI()
+                .replicationStream()
+                .logical()
+                .withSlotName(this.endpoint.getSlot())
+                .withStatusInterval(this.endpoint.getStatusInterval(), TimeUnit.SECONDS);
+
+        Properties slotOptions = new Properties();
+        slotOptions.putAll(this.endpoint.getSlotOptions());
+        streamBuilder.withSlotOptions(slotOptions);
+
+        this.replicationStream = streamBuilder.start();
+
+        return this.replicationStream;
+    }
+
+    private boolean isSlotActive() throws SQLException {
+        String sql = String.format(""SELECT count(*) FROM pg_replication_slots where slot_name = '%s' AND active = true;"",
+                this.endpoint.getSlot());
+
+        try (Statement statement = this.connection.createStatement(); ResultSet resultSet = statement.executeQuery(sql)) {
+            resultSet.next();
+            return resultSet.getInt(1) > 0;
+        }
+    }
+
+    private void connect() throws SQLException {
+        if (this.connection != null) {
+            this.connection.close();
+        }
+
+        this.connection = this.endpoint.newDbConnection();
+        this.pgConnection = this.connection.unwrap(PGConnection.class);
+        this.replicationStream = null;
+
+        if (this.endpoint.getAutoCreateSlot() && !this.isSlotCreated()) {
+            this.createSlot();
+        }
+    }
+    
+    private void validateConnection(PSQLException exception) {
+        try {
+            if (exception.getCause() instanceof SocketException) {","[{'comment': 'for potential reconnect logic, you can take a look the connection reestablishment logics in other components, camel-sql mongo etc. by the looks of it, the first req will fail and reestablish the connection where failing the first request in case of socket exception may be a bit of redundant, and can be improved. this can be of course logged and improved later. not a big worry.', 'commenter': 'onderson'}, {'comment': 'I will do that ASAP.', 'commenter': 'bahaa'}, {'comment': 'Can be improved later on.(As there will be a single connection) No need to mind at the moment.', 'commenter': 'onderson'}]"
3005,components/camel-pg-replication-slot/src/main/java/org/apache/camel/component/pg_replication_slot/PgReplicationSlotConsumer.java,"@@ -0,0 +1,257 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.pg_replication_slot;
+
+import java.net.SocketException;
+import java.nio.ByteBuffer;
+import java.sql.Connection;
+import java.sql.ResultSet;
+import java.sql.SQLException;
+import java.sql.Statement;
+import java.util.Properties;
+import java.util.concurrent.ScheduledExecutorService;
+import java.util.concurrent.ScheduledFuture;
+import java.util.concurrent.TimeUnit;
+
+import org.apache.camel.Exchange;
+import org.apache.camel.Message;
+import org.apache.camel.Processor;
+import org.apache.camel.spi.Synchronization;
+import org.apache.camel.support.ScheduledPollConsumer;
+import org.postgresql.PGConnection;
+import org.postgresql.replication.PGReplicationStream;
+import org.postgresql.replication.fluent.logical.ChainedLogicalStreamBuilder;
+import org.postgresql.util.PSQLException;
+
+/**
+ * The pg-replication-slot consumer.
+ */
+public class PgReplicationSlotConsumer extends ScheduledPollConsumer {
+
+    private final PgReplicationSlotEndpoint endpoint;
+
+    private Connection connection;
+    private PGConnection pgConnection;
+    private PGReplicationStream replicationStream;
+
+    private ScheduledExecutorService scheduledExecutor;
+
+    private byte[] payload;
+
+    PgReplicationSlotConsumer(PgReplicationSlotEndpoint endpoint, Processor processor) {
+        super(endpoint, processor);
+        this.endpoint = endpoint;
+    }
+
+    @Override
+    protected void doStart() throws Exception {
+        super.doStart();
+
+        this.connect();
+
+        if (this.scheduledExecutor == null) {
+            this.scheduledExecutor = this.getEndpoint().getCamelContext().getExecutorServiceManager()
+                    .newSingleThreadScheduledExecutor(this, ""PgReplicationStatusUpdateSender"");
+        }
+    }
+
+    @Override
+    protected void doStop() throws Exception {
+        super.doStop();
+
+        if (this.connection != null) {
+            this.connection.close();
+            this.connection = null;
+        }
+
+        if (this.scheduledExecutor != null) {
+            this.getEndpoint().getCamelContext().getExecutorServiceManager().shutdownNow(this.scheduledExecutor);
+            this.scheduledExecutor = null;
+        }
+    }
+
+    @Override
+    protected int poll() throws Exception {
+        PGReplicationStream stream = getStream();
+
+        if (stream == null) {
+            return 0;
+        }
+
+        try {
+            // The same payload will be sent again and again until the processing is completed successfully.
+            // We should not read another payload before that to guarantee the order of processing.
+            if (this.payload == null) {
+                ByteBuffer msg = stream.readPending();
+
+                if (msg == null) {
+                    return 0;
+                }
+
+                int offset = msg.arrayOffset();
+                byte[] source = msg.array();
+                int length = source.length - offset;
+
+                this.payload = new byte[length];
+                System.arraycopy(source, offset, this.payload, 0, length);
+            }
+        } catch (PSQLException e) {
+            validateConnection(e);
+            throw e;
+        }
+
+        Exchange exchange = this.endpoint.createExchange();
+        exchange.setExchangeId(stream.getLastReceiveLSN().asString());
+
+        Message message = exchange.getIn();
+        message.setBody(this.payload);
+
+        final long delay = this.endpoint.getStatusInterval();
+        ScheduledFuture<?> scheduledFuture = this.scheduledExecutor.scheduleAtFixedRate(() -> {
+            try {
+                log.debug(""Processing took too long. Sending status update to avoid disconnect."");
+                stream.forceUpdateStatus();
+            } catch (SQLException e) {
+                log.error(e.getMessage(), e);
+            }
+        }, delay, delay, TimeUnit.SECONDS);
+
+        exchange.addOnCompletion(new Synchronization() {
+            @Override
+            public void onComplete(Exchange exchange) {
+                processCommit(exchange);
+                scheduledFuture.cancel(true);
+            }
+
+            @Override
+            public void onFailure(Exchange exchange) {
+                processRollback(exchange);
+                scheduledFuture.cancel(true);
+            }
+        });
+
+        getProcessor().process(exchange);
+
+        return 1;
+    }
+
+    private void processCommit(Exchange exchange) {
+        try {
+            PGReplicationStream stream = getStream();
+
+            if (stream == null) {
+                return;
+            }
+
+            stream.setAppliedLSN(stream.getLastReceiveLSN());
+            stream.setFlushedLSN(stream.getLastReceiveLSN());
+            stream.forceUpdateStatus();
+
+            this.payload = null;
+        } catch (PSQLException e) {
+            validateConnection(e);
+        } catch (SQLException e) {
+            getExceptionHandler().handleException(""Exception while sending feedback to PostgreSQL."", exchange, e);
+        }
+    }
+
+    private void processRollback(Exchange exchange) {
+        Exception cause = exchange.getException();
+        if (cause != null) {
+            getExceptionHandler().handleException(""Error during processing exchange. Will attempt to process the message on next poll."", exchange, cause);
+        }
+    }
+
+    private void createSlot() throws SQLException {
+        this.pgConnection.getReplicationAPI()
+                .createReplicationSlot()
+                .logical()
+                .withSlotName(this.endpoint.getSlot())
+                .withOutputPlugin(this.endpoint.getOutputPlugin())
+                .make();
+    }
+
+    private boolean isSlotCreated() throws SQLException {
+        String sql = String.format(""SELECT count(*) FROM pg_replication_slots WHERE slot_name = '%s';"", this.endpoint.getSlot());
+
+        try (Statement statement = this.connection.createStatement(); ResultSet resultSet = statement.executeQuery(sql)) {
+            resultSet.next();
+            return resultSet.getInt(1) > 0;
+        }
+    }
+
+    private PGReplicationStream getStream() throws SQLException {
+        if (this.replicationStream != null && !this.replicationStream.isClosed()) {
+            return this.replicationStream;
+        }
+
+        if (isSlotActive()) {
+            log.info(String.format(""Slot: %s is active. Waiting for it to be available."", this.endpoint.getSlot()));
+            return null;
+        }
+
+        ChainedLogicalStreamBuilder streamBuilder = this.pgConnection.getReplicationAPI()
+                .replicationStream()
+                .logical()
+                .withSlotName(this.endpoint.getSlot())
+                .withStatusInterval(this.endpoint.getStatusInterval(), TimeUnit.SECONDS);
+
+        Properties slotOptions = new Properties();
+        slotOptions.putAll(this.endpoint.getSlotOptions());
+        streamBuilder.withSlotOptions(slotOptions);
+
+        this.replicationStream = streamBuilder.start();
+
+        return this.replicationStream;
+    }
+
+    private boolean isSlotActive() throws SQLException {
+        String sql = String.format(""SELECT count(*) FROM pg_replication_slots where slot_name = '%s' AND active = true;"",
+                this.endpoint.getSlot());
+
+        try (Statement statement = this.connection.createStatement(); ResultSet resultSet = statement.executeQuery(sql)) {
+            resultSet.next();
+            return resultSet.getInt(1) > 0;
+        }
+    }
+
+    private void connect() throws SQLException {
+        if (this.connection != null) {
+            this.connection.close();
+        }
+
+        this.connection = this.endpoint.newDbConnection();","[{'comment': 'will there be a single connection, or a pool of connections can be considered?', 'commenter': 'onderson'}, {'comment': ""Replication stream connections by nature are long-running single-threaded (to preserve order) connections. So, I don't think using a connection pool will benefit the application as the streams won't be released frequently. We use the approach above in production for a long time and we didn't face any problems so far. I'll give it more research time though."", 'commenter': 'bahaa'}, {'comment': 'fair enough. that may be an improvement which can be done later', 'commenter': 'onderson'}]"
3022,components/camel-any23/pom.xml,"@@ -0,0 +1,83 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one or more
+    contributor license agreements.  See the NOTICE file distributed with
+    this work for additional information regarding copyright ownership.
+    The ASF licenses this file to You under the Apache License, Version 2.0
+    (the ""License""); you may not use this file except in compliance with
+    the License.  You may obtain a copy of the License at
+
+         http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an ""AS IS"" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+
+-->
+<project xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xmlns=""http://maven.apache.org/POM/4.0.0""
+         xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>org.apache.camel</groupId>
+    <artifactId>components</artifactId>
+    <version>3.0.0-SNAPSHOT</version>
+  </parent>
+
+  <artifactId>camel-any23</artifactId>
+  <packaging>jar</packaging>
+  <name>Camel :: Any23</name>
+  <description>Camel Any23 support</description>
+
+  <properties>
+  </properties>
+
+  <dependencies>
+
+    <dependency>
+      <groupId>org.apache.camel</groupId>
+      <artifactId>camel-support</artifactId>
+    </dependency>
+
+
+    <!-- test dependencies -->
+    <dependency>
+      <groupId>org.apache.camel</groupId>
+      <artifactId>camel-test</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.apache.logging.log4j</groupId>
+      <artifactId>log4j-api</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.apache.logging.log4j</groupId>
+      <artifactId>log4j-core</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.apache.logging.log4j</groupId>
+      <artifactId>log4j-slf4j-impl</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>junit</groupId>
+      <artifactId>junit</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.apache.any23</groupId>
+      <artifactId>apache-any23-core</artifactId>
+      <version>2.3</version>
+    </dependency>
+    <dependency>
+      <groupId>org.eclipse.rdf4j</groupId>
+      <artifactId>rdf4j-rio-rdfxml</artifactId>
+      <version>3.0.0-M1</version>","[{'comment': 'This one can be a property placeholder in parent/POM', 'commenter': 'oscerd'}]"
3022,components/camel-any23/src/main/java/org/apache/camel/dataformat/any23/Any23DataFormat.java,"@@ -0,0 +1,198 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.dataformat.any23;
+
+import java.io.InputStream;
+import java.io.OutputStream;
+import org.apache.any23.Any23;
+import org.apache.any23.configuration.DefaultConfiguration;
+import org.apache.any23.configuration.ModifiableConfiguration;
+import org.apache.any23.source.DocumentSource;
+import org.apache.any23.source.StringDocumentSource;
+import org.apache.any23.writer.JSONLDWriter;
+import org.apache.any23.writer.NQuadsWriter;
+import org.apache.any23.writer.NTriplesWriter;
+import org.apache.any23.writer.RDFXMLWriter;
+import org.apache.any23.writer.TripleHandler;
+import org.apache.any23.writer.TurtleWriter;
+
+import org.apache.camel.Exchange;
+import org.apache.camel.spi.DataFormat;
+import org.apache.camel.spi.DataFormatName;
+import org.apache.camel.spi.annotations.Dataformat;
+import org.apache.camel.support.ExchangeHelper;
+import org.apache.camel.support.service.ServiceSupport;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * Dataformat for any23 .. This dataformat is intended to convert HTML from a
+ * site (or file) into rdf.
+ */
+@Dataformat(""any23"")
+public class Any23DataFormat extends ServiceSupport implements DataFormat, DataFormatName {
+
+  /*
+     * Our Logger
+   */
+  private static final Logger LOG = LoggerFactory.getLogger(Any23DataFormat.class);
+
+  private Any23 any23;
+  private Any23OutputFormat format = Any23OutputFormat.RDFXML;
+  private ModifiableConfiguration conf;
+  private String[] extractorsList;
+
+  private String configurations;
+  private String extractors;
+  private String outputFormat;
+  private String documentIRI = ""http://mock.foo/bar"";
+
+  @Override
+  public String getDataFormatName() {
+    return ""any23"";
+  }
+
+  /**
+   * Marshal data. Generate RDF.
+   */
+  public void marshal(Exchange exchange, Object object, OutputStream outputStream) throws Exception {
+    final String payload = ExchangeHelper.convertToMandatoryType(exchange, String.class, object);
+    DocumentSource source = new StringDocumentSource(payload, documentIRI);
+    TripleHandler handler;
+    switch (format) {
+      case NTRIPLES:
+        handler = new NTriplesWriter(outputStream);
+        break;
+      case TURTLE:
+        handler = new TurtleWriter(outputStream);
+        break;
+      case NQUADS:
+        handler = new NQuadsWriter(outputStream);
+        break;
+      case RDFXML:
+        handler = new RDFXMLWriter(outputStream);
+        break;
+      case JSONLD:
+        handler = new JSONLDWriter(outputStream);
+        break;
+      case MODEL:
+        handler = new NTriplesWriter(outputStream);
+        break;
+      default:
+        handler = new NTriplesWriter(outputStream);
+    }
+    any23.extract(source, handler);
+    handler.close();
+  }
+
+  /**
+   * Unmarshal the data
+   */
+  public Object unmarshal(Exchange exchange, InputStream inputStream) throws Exception {
+    //TODO","[{'comment': 'No unmarshall?', 'commenter': 'oscerd'}]"
3022,components/camel-any23/src/test/resources/org/apache/camel/dataformat/any23/microformat/vcard.html,"@@ -0,0 +1,65 @@
+<!DOCTYPE html PUBLIC ""-//W3C//DTD XHTML 1.0 Transitional//EN"" ""http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"">","[{'comment': 'Apache License header is missing', 'commenter': 'oscerd'}]"
3022,components/camel-browse/src/main/docs/browse-component.adoc,"@@ -64,7 +64,6 @@ with the following path and query parameters:
 | *bridgeErrorHandler* (consumer) | Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored. | false | boolean
 | *exceptionHandler* (consumer) | To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored. |  | ExceptionHandler
 | *exchangePattern* (consumer) | Sets the exchange pattern when the consumer creates an exchange. |  | ExchangePattern
-| *lazyStartProducer* (producer) | Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing. | false | boolean","[{'comment': 'I think you need to fully rebuild camel because the lazyStartProducer is still an option. ', 'commenter': 'oscerd'}]"
3022,components/camel-controlbus/src/main/docs/controlbus-component.adoc,"@@ -87,15 +87,14 @@ with the following path and query parameters:
 |===
 
 
-==== Query Parameters (8 parameters):
+==== Query Parameters (7 parameters):
 
 
 [width=""100%"",cols=""2,5,^1,2"",options=""header""]
 |===
 | Name | Description | Default | Type
 | *action* (producer) | To denote an action that can be either: start, stop, or status. To either start or stop a route, or to get the status of the route as output in the message body. You can use suspend and resume from Camel 2.11.1 onwards to either suspend or resume a route. And from Camel 2.11.1 onwards you can use stats to get performance statics returned in XML format; the routeId option can be used to define which route to get the performance stats for, if routeId is not defined, then you get statistics for the entire CamelContext. The restart action will restart the route. |  | String
 | *async* (producer) | Whether to execute the control bus task asynchronously. Important: If this option is enabled, then any result from the task is not set on the Exchange. This is only possible if executing tasks synchronously. | false | boolean
-| *lazyStartProducer* (producer) | Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing. | false | boolean","[{'comment': 'ditto', 'commenter': 'oscerd'}]"
3022,components/camel-dataformat/src/main/docs/dataformat-component.adoc,"@@ -57,13 +57,12 @@ with the following path and query parameters:
 |===
 
 
-==== Query Parameters (3 parameters):
+==== Query Parameters (2 parameters):
 
 
 [width=""100%"",cols=""2,5,^1,2"",options=""header""]
 |===
 | Name | Description | Default | Type
-| *lazyStartProducer* (producer) | Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing. | false | boolean","[{'comment': 'ditto', 'commenter': 'oscerd'}]"
3022,components/camel-dataset/src/main/docs/dataset-component.adoc,"@@ -92,7 +92,6 @@ with the following path and query parameters:
 | *consumeDelay* (producer) | Allows a delay to be specified which causes a delay when a message is consumed by the producer (to simulate slow processing) | 0 | long
 | *assertPeriod* (producer) | Sets a grace period after which the mock endpoint will re-assert to ensure the preliminary assertion is still valid. This is used for example to assert that exactly a number of messages arrives. For example if expectedMessageCount(int) was set to 5, then the assertion is satisfied when 5 or more message arrives. To ensure that exactly 5 messages arrives, then you would need to wait a little period to ensure no further message arrives. This is what you can use this method for. By default this period is disabled. | 0 | long
 | *expectedCount* (producer) | Specifies the expected number of message exchanges that should be received by this endpoint. Beware: If you want to expect that 0 messages, then take extra care, as 0 matches when the tests starts, so you need to set a assert period time to let the test run for a while to make sure there are still no messages arrived; for that use setAssertPeriod(long). An alternative is to use NotifyBuilder, and use the notifier to know when Camel is done routing some messages, before you call the assertIsSatisfied() method on the mocks. This allows you to not use a fixed assert period, to speedup testing times. If you want to assert that exactly n'th message arrives to this mock endpoint, then see also the setAssertPeriod(long) method for further details. | -1 | int
-| *lazyStartProducer* (producer) | Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing. | false | boolean","[{'comment': 'ditto', 'commenter': 'oscerd'}]"
3022,components/camel-dataset/src/main/docs/dataset-test-component.adoc,"@@ -85,7 +85,6 @@ with the following path and query parameters:
 | *timeout* (producer) | The timeout to use when polling for message bodies from the URI | 2000 | long
 | *assertPeriod* (producer) | Sets a grace period after which the mock endpoint will re-assert to ensure the preliminary assertion is still valid. This is used for example to assert that exactly a number of messages arrives. For example if expectedMessageCount(int) was set to 5, then the assertion is satisfied when 5 or more message arrives. To ensure that exactly 5 messages arrives, then you would need to wait a little period to ensure no further message arrives. This is what you can use this method for. By default this period is disabled. | 0 | long
 | *expectedCount* (producer) | Specifies the expected number of message exchanges that should be received by this endpoint. Beware: If you want to expect that 0 messages, then take extra care, as 0 matches when the tests starts, so you need to set a assert period time to let the test run for a while to make sure there are still no messages arrived; for that use setAssertPeriod(long). An alternative is to use NotifyBuilder, and use the notifier to know when Camel is done routing some messages, before you call the assertIsSatisfied() method on the mocks. This allows you to not use a fixed assert period, to speedup testing times. If you want to assert that exactly n'th message arrives to this mock endpoint, then see also the setAssertPeriod(long) method for further details. | -1 | int
-| *lazyStartProducer* (producer) | Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing. | false | boolean","[{'comment': 'ditto', 'commenter': 'oscerd'}]"
3022,components/camel-direct/src/main/docs/direct-component.adoc,"@@ -77,7 +77,6 @@ with the following path and query parameters:
 | *exchangePattern* (consumer) | Sets the exchange pattern when the consumer creates an exchange. |  | ExchangePattern
 | *block* (producer) | If sending a message to a direct endpoint which has no active consumer, then we can tell the producer to block and wait for the consumer to become active. | true | boolean
 | *failIfNoConsumers* (producer) | Whether the producer should fail by throwing an exception, when sending to a DIRECT endpoint with no active consumers. | false | boolean
-| *lazyStartProducer* (producer) | Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing. | false | boolean","[{'comment': 'ditto', 'commenter': 'oscerd'}]"
3022,components/camel-directvm/src/main/docs/direct-vm-component.adoc,"@@ -90,7 +90,6 @@ with the following path and query parameters:
 | *exchangePattern* (consumer) | Sets the exchange pattern when the consumer creates an exchange. |  | ExchangePattern
 | *block* (producer) | If sending a message to a direct endpoint which has no active consumer, then we can tell the producer to block and wait for the consumer to become active. | true | boolean
 | *failIfNoConsumers* (producer) | Whether the producer should fail by throwing an exception, when sending to a Direct-VM endpoint with no active consumers. | false | boolean
-| *lazyStartProducer* (producer) | Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing. | false | boolean","[{'comment': 'ditto', 'commenter': 'oscerd'}]"
3022,components/camel-language/src/main/docs/language-component.adoc,"@@ -80,7 +80,6 @@ with the following path and query parameters:
 | *binary* (producer) | Whether the script is binary content or text content. By default the script is read as text content (eg java.lang.String) | false | boolean
 | *cacheScript* (producer) | Whether to cache the compiled script and reuse Notice reusing the script can cause side effects from processing one Camel org.apache.camel.Exchange to the next org.apache.camel.Exchange. | false | boolean
 | *contentCache* (producer) | Sets whether to use resource content cache or not | false | boolean
-| *lazyStartProducer* (producer) | Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing. | false | boolean","[{'comment': 'ditto', 'commenter': 'oscerd'}]"
3022,components/camel-log/src/main/docs/log-component.adoc,"@@ -104,7 +104,6 @@ with the following path and query parameters:
 | *groupDelay* (producer) | Set the initial delay for stats (in millis) |  | Long
 | *groupInterval* (producer) | If specified will group message stats by this time interval (in millis) |  | Long
 | *groupSize* (producer) | An integer that specifies a group size for throughput logging. |  | Integer
-| *lazyStartProducer* (producer) | Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing. | false | boolean","[{'comment': 'ditto', 'commenter': 'oscerd'}]"
3022,components/camel-ref/src/main/docs/ref-component.adoc,"@@ -62,7 +62,6 @@ with the following path and query parameters:
 | *bridgeErrorHandler* (consumer) | Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored. | false | boolean
 | *exceptionHandler* (consumer) | To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored. |  | ExceptionHandler
 | *exchangePattern* (consumer) | Sets the exchange pattern when the consumer creates an exchange. |  | ExchangePattern
-| *lazyStartProducer* (producer) | Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing. | false | boolean","[{'comment': 'ditto', 'commenter': 'oscerd'}]"
3022,components/camel-saga/src/main/docs/saga-component.adoc,"@@ -52,13 +52,12 @@ with the following path and query parameters:
 |===
 
 
-==== Query Parameters (3 parameters):
+==== Query Parameters (2 parameters):
 
 
 [width=""100%"",cols=""2,5,^1,2"",options=""header""]
 |===
 | Name | Description | Default | Type
-| *lazyStartProducer* (producer) | Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing. | false | boolean","[{'comment': 'ditto', 'commenter': 'oscerd'}]"
3022,components/camel-seda/src/main/docs/seda-component.adoc,"@@ -94,7 +94,6 @@ with the following path and query parameters:
 | *blockWhenFull* (producer) | Whether a thread that sends messages to a full SEDA queue will block until the queue's capacity is no longer exhausted. By default, an exception will be thrown stating that the queue is full. By enabling this option, the calling thread will instead block and wait until the message can be accepted. | false | boolean
 | *discardIfNoConsumers* (producer) | Whether the producer should discard the message (do not add the message to the queue), when sending to a queue with no active consumers. Only one of the options discardIfNoConsumers and failIfNoConsumers can be enabled at the same time. | false | boolean
 | *failIfNoConsumers* (producer) | Whether the producer should fail by throwing an exception, when sending to a queue with no active consumers. Only one of the options discardIfNoConsumers and failIfNoConsumers can be enabled at the same time. | false | boolean
-| *lazyStartProducer* (producer) | Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing. | false | boolean","[{'comment': 'ditto', 'commenter': 'oscerd'}]"
3022,components/camel-stub/src/main/docs/stub-component.adoc,"@@ -84,7 +84,6 @@ with the following path and query parameters:
 | *blockWhenFull* (producer) | Whether a thread that sends messages to a full SEDA queue will block until the queue's capacity is no longer exhausted. By default, an exception will be thrown stating that the queue is full. By enabling this option, the calling thread will instead block and wait until the message can be accepted. | false | boolean
 | *discardIfNoConsumers* (producer) | Whether the producer should discard the message (do not add the message to the queue), when sending to a queue with no active consumers. Only one of the options discardIfNoConsumers and failIfNoConsumers can be enabled at the same time. | false | boolean
 | *failIfNoConsumers* (producer) | Whether the producer should fail by throwing an exception, when sending to a queue with no active consumers. Only one of the options discardIfNoConsumers and failIfNoConsumers can be enabled at the same time. | false | boolean
-| *lazyStartProducer* (producer) | Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing. | false | boolean","[{'comment': 'ditto', 'commenter': 'oscerd'}]"
3022,components/camel-validator/src/main/docs/validator-component.adoc,"@@ -81,7 +81,6 @@ with the following path and query parameters:
 | *failOnNullBody* (producer) | Whether to fail if no body exists. | true | boolean
 | *failOnNullHeader* (producer) | Whether to fail if no header exists when validating against a header. | true | boolean
 | *headerName* (producer) | To validate against a header instead of the message body. |  | String
-| *lazyStartProducer* (producer) | Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing. | false | boolean","[{'comment': 'ditto', 'commenter': 'oscerd'}]"
3022,components/camel-vm/src/main/docs/vm-component.adoc,"@@ -97,7 +97,6 @@ with the following path and query parameters:
 | *blockWhenFull* (producer) | Whether a thread that sends messages to a full SEDA queue will block until the queue's capacity is no longer exhausted. By default, an exception will be thrown stating that the queue is full. By enabling this option, the calling thread will instead block and wait until the message can be accepted. | false | boolean
 | *discardIfNoConsumers* (producer) | Whether the producer should discard the message (do not add the message to the queue), when sending to a queue with no active consumers. Only one of the options discardIfNoConsumers and failIfNoConsumers can be enabled at the same time. | false | boolean
 | *failIfNoConsumers* (producer) | Whether the producer should fail by throwing an exception, when sending to a queue with no active consumers. Only one of the options discardIfNoConsumers and failIfNoConsumers can be enabled at the same time. | false | boolean
-| *lazyStartProducer* (producer) | Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing. | false | boolean","[{'comment': 'ditto', 'commenter': 'oscerd'}]"
3022,components/camel-xslt/src/main/docs/xslt-component.adoc,"@@ -89,7 +89,6 @@ with the following path and query parameters:
 | *contentCache* (producer) | Cache for the resource content (the stylesheet file) when it is loaded. If set to false Camel will reload the stylesheet file on each message processing. This is good for development. A cached stylesheet can be forced to reload at runtime via JMX using the clearCachedStylesheet operation. | true | boolean
 | *deleteOutputFile* (producer) | If you have output=file then this option dictates whether or not the output file should be deleted when the Exchange is done processing. For example suppose the output file is a temporary file, then it can be a good idea to delete it after use. | false | boolean
 | *failOnNullBody* (producer) | Whether or not to throw an exception if the input body is null. | true | boolean
-| *lazyStartProducer* (producer) | Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing. | false | boolean","[{'comment': 'ditto', 'commenter': 'oscerd'}]"
3022,core/camel-core/src/main/java/org/apache/camel/model/dataformat/Any23DataFormat.java,"@@ -0,0 +1,103 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.model.dataformat;
+
+import javax.xml.bind.annotation.XmlAccessType;
+import javax.xml.bind.annotation.XmlAccessorType;
+import javax.xml.bind.annotation.XmlAttribute;
+import javax.xml.bind.annotation.XmlRootElement;
+import org.apache.camel.model.DataFormatDefinition;
+import org.apache.camel.spi.Metadata;
+
+/**
+ * Any23 data format is used for parsing data to RDF.
+ */
+@Metadata(firstVersion = ""1.0.0"", label = ""dataformat,transformation"", title = ""Any23"")","[{'comment': 'the firstVersion here should be 3.0.0', 'commenter': 'oscerd'}]"
3022,core/camel-core/src/main/java/org/apache/camel/reifier/dataformat/Any23DataFormatReifier.java,"@@ -0,0 +1,40 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.reifier.dataformat;
+
+import org.apache.camel.CamelContext;
+import org.apache.camel.model.DataFormatDefinition;
+import org.apache.camel.model.dataformat.Any23DataFormat;
+import org.apache.camel.spi.DataFormat;
+
+public class Any23DataFormatReifier extends DataFormatReifier<Any23DataFormat> {
+
+  public Any23DataFormatReifier(DataFormatDefinition definition) {
+    super((Any23DataFormat) definition);
+  }
+
+  @Override
+  protected void configureDataFormat(DataFormat dataFormat, CamelContext camelContext) {","[{'comment': 'Here you need to implement doCreateDataFormat and configureDataFormat, take as example the other reifier', 'commenter': 'oscerd'}, {'comment': 'The doCreateDataFormat is still missing.', 'commenter': 'oscerd'}]"
3022,core/camel-endpointdsl/src/main/java/org/apache/camel/builder/endpoint/dsl/BrowseEndpointBuilderFactory.java,"@@ -209,46 +209,6 @@ default AdvancedBrowseEndpointConsumerBuilder synchronous(
         default AdvancedBrowseEndpointProducerBuilder advanced() {
             return (AdvancedBrowseEndpointProducerBuilder) this;
         }
-        /**","[{'comment': 'You have to rebuild the project fully, that option should be there https://github.com/apache/camel/blob/master/core/camel-endpointdsl/src/main/java/org/apache/camel/builder/endpoint/dsl/BrowseEndpointBuilderFactory.java#L213', 'commenter': 'oscerd'}]"
3022,components/camel-any23/src/main/java/org/apache/camel/dataformat/any23/Any23DataFormat.java,"@@ -0,0 +1,198 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.dataformat.any23;
+
+import java.io.InputStream;
+import java.io.OutputStream;
+import org.apache.any23.Any23;
+import org.apache.any23.configuration.DefaultConfiguration;
+import org.apache.any23.configuration.ModifiableConfiguration;
+import org.apache.any23.source.DocumentSource;
+import org.apache.any23.source.StringDocumentSource;
+import org.apache.any23.writer.JSONLDWriter;
+import org.apache.any23.writer.NQuadsWriter;
+import org.apache.any23.writer.NTriplesWriter;
+import org.apache.any23.writer.RDFXMLWriter;
+import org.apache.any23.writer.TripleHandler;
+import org.apache.any23.writer.TurtleWriter;
+
+import org.apache.camel.Exchange;
+import org.apache.camel.spi.DataFormat;
+import org.apache.camel.spi.DataFormatName;
+import org.apache.camel.spi.annotations.Dataformat;
+import org.apache.camel.support.ExchangeHelper;
+import org.apache.camel.support.service.ServiceSupport;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * Dataformat for any23 .. This dataformat is intended to convert HTML from a
+ * site (or file) into rdf.
+ */
+@Dataformat(""any23"")
+public class Any23DataFormat extends ServiceSupport implements DataFormat, DataFormatName {
+
+  /*
+     * Our Logger
+   */
+  private static final Logger LOG = LoggerFactory.getLogger(Any23DataFormat.class);
+
+  private Any23 any23;
+  private Any23OutputFormat format = Any23OutputFormat.RDFXML;
+  private ModifiableConfiguration conf;
+  private String[] extractorsList;
+
+  private String configurations;
+  private String extractors;
+  private String outputFormat;
+  private String documentIRI = ""http://mock.foo/bar"";","[{'comment': 'Looks like must be documentURI? Do you need fake non empty init?', 'commenter': 'dmvolod'}]"
3022,components/camel-any23/src/test/resources/log4j2.properties,"@@ -0,0 +1,28 @@
+## ---------------------------------------------------------------------------
+## Licensed to the Apache Software Foundation (ASF) under one or more
+## contributor license agreements.  See the NOTICE file distributed with
+## this work for additional information regarding copyright ownership.
+## The ASF licenses this file to You under the Apache License, Version 2.0
+## (the ""License""); you may not use this file except in compliance with
+## the License.  You may obtain a copy of the License at
+##
+##      http://www.apache.org/licenses/LICENSE-2.0
+##
+## Unless required by applicable law or agreed to in writing, software
+## distributed under the License is distributed on an ""AS IS"" BASIS,
+## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+## See the License for the specific language governing permissions and
+## limitations under the License.
+## ---------------------------------------------------------------------------
+
+appender.file.type = File
+appender.file.name = file
+appender.file.fileName = target/camel-atom-test.log","[{'comment': 'Should be camel-any23-test.log', 'commenter': 'dmvolod'}]"
3022,components/camel-any23/src/main/docs/any23-dataformat.adoc,"@@ -0,0 +1,120 @@
+[[any23-dataformat]]
+== Any23 DataFormat
+== TidyMarkup DataFormat
+*Available as of Camel version 1.0*
+
+
+*Available as of Camel version 1.0*","[{'comment': 'This is not correct info, please define the correct one.', 'commenter': 'dmvolod'}]"
3022,components/camel-any23/src/main/docs/any23-dataformat.adoc,"@@ -0,0 +1,120 @@
+[[any23-dataformat]]
+== Any23 DataFormat
+== TidyMarkup DataFormat
+*Available as of Camel version 1.0*
+
+
+*Available as of Camel version 1.0*
+
+TidyMarkup is a Data Format that uses the
+http://www.ccil.org/~cowan/XML/tagsoup/[TagSoup] to tidy up HTML. It can
+be used to parse ugly HTML and return it as pretty wellformed HTML.
+
+*Camel eats our own -dog food- soap*","[{'comment': 'What is it?', 'commenter': 'dmvolod'}]"
3022,components/camel-any23/pom.xml,"@@ -0,0 +1,88 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one or more
+    contributor license agreements.  See the NOTICE file distributed with
+    this work for additional information regarding copyright ownership.
+    The ASF licenses this file to You under the Apache License, Version 2.0
+    (the ""License""); you may not use this file except in compliance with
+    the License.  You may obtain a copy of the License at
+
+         http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an ""AS IS"" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+
+-->
+<project xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xmlns=""http://maven.apache.org/POM/4.0.0""
+         xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>org.apache.camel</groupId>
+    <artifactId>components</artifactId>
+    <version>3.0.0-SNAPSHOT</version>
+  </parent>
+
+  <artifactId>camel-any23</artifactId>
+  <packaging>jar</packaging>
+  <name>Camel :: Any23</name>
+  <description>Camel Any23 support</description>
+
+  <properties>
+  </properties>
+
+  <dependencies>
+
+    <dependency>
+      <groupId>org.apache.camel</groupId>
+      <artifactId>camel-support</artifactId>
+    </dependency>
+
+
+    <!-- test dependencies -->
+    <dependency>
+      <groupId>org.apache.camel</groupId>
+      <artifactId>camel-test</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.apache.logging.log4j</groupId>
+      <artifactId>log4j-api</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.apache.logging.log4j</groupId>
+      <artifactId>log4j-core</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.apache.logging.log4j</groupId>
+      <artifactId>log4j-slf4j-impl</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>junit</groupId>
+      <artifactId>junit</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.apache.any23</groupId>
+      <artifactId>apache-any23-core</artifactId>
+      <version>2.3</version>
+    </dependency>
+    <dependency>
+      <groupId>org.eclipse.rdf4j</groupId>
+      <artifactId>rdf4j-rio-rdfxml</artifactId>
+      <version>3.0.0-M1</version>
+    </dependency>
+    <dependency>
+      <groupId>org.eclipse.rdf4j</groupId>
+      <artifactId>rdf4j-rio-turtle</artifactId>
+      <version>3.0.0-M1</version>","[{'comment': 'This can be a property in parent/POM too', 'commenter': 'oscerd'}]"
3022,components/camel-any23/src/main/java/org/apache/camel/dataformat/any23/Any23DataFormat.java,"@@ -0,0 +1,161 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.dataformat.any23;
+
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.util.List;
+import java.util.Map;
+import java.util.Map.Entry;
+import org.apache.any23.Any23;
+import org.apache.any23.configuration.DefaultConfiguration;
+import org.apache.any23.configuration.ModifiableConfiguration;
+import org.apache.any23.source.DocumentSource;
+import org.apache.any23.source.StringDocumentSource;
+import org.apache.any23.writer.TripleHandler;
+
+import org.apache.camel.Exchange;
+import org.apache.camel.dataformat.any23.utils.Any23Utils;
+import org.apache.camel.spi.DataFormat;
+import org.apache.camel.spi.DataFormatName;
+import org.apache.camel.spi.annotations.Dataformat;
+import org.apache.camel.support.ExchangeHelper;
+import org.apache.camel.support.service.ServiceSupport;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * Dataformat for any23 .. This dataformat is intended to convert HTML from a
+ * site (or file) into rdf.
+ */
+@Dataformat(""any23"")
+public class Any23DataFormat extends ServiceSupport implements DataFormat, DataFormatName {
+
+  /*
+     * Our Logger
+   */
+  private static final Logger LOG = LoggerFactory.getLogger(Any23DataFormat.class);
+
+  private Any23 any23;
+
+  private Map<String, String> configurations;
+  private List<String> extractors;
+  private Any23OutputFormat outputFormat;
+  private String baseURI;
+","[{'comment': ""You're missing constructors here. Take a  look at how the other dataformats are implemented."", 'commenter': 'oscerd'}]"
3022,components/camel-any23/src/main/java/org/apache/camel/dataformat/any23/Any23DataFormat.java,"@@ -0,0 +1,161 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.dataformat.any23;
+
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.util.List;
+import java.util.Map;
+import java.util.Map.Entry;
+import org.apache.any23.Any23;
+import org.apache.any23.configuration.DefaultConfiguration;
+import org.apache.any23.configuration.ModifiableConfiguration;
+import org.apache.any23.source.DocumentSource;
+import org.apache.any23.source.StringDocumentSource;
+import org.apache.any23.writer.TripleHandler;
+
+import org.apache.camel.Exchange;
+import org.apache.camel.dataformat.any23.utils.Any23Utils;
+import org.apache.camel.spi.DataFormat;
+import org.apache.camel.spi.DataFormatName;
+import org.apache.camel.spi.annotations.Dataformat;
+import org.apache.camel.support.ExchangeHelper;
+import org.apache.camel.support.service.ServiceSupport;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * Dataformat for any23 .. This dataformat is intended to convert HTML from a
+ * site (or file) into rdf.
+ */
+@Dataformat(""any23"")
+public class Any23DataFormat extends ServiceSupport implements DataFormat, DataFormatName {
+
+  /*
+     * Our Logger
+   */
+  private static final Logger LOG = LoggerFactory.getLogger(Any23DataFormat.class);
+
+  private Any23 any23;
+
+  private Map<String, String> configurations;","[{'comment': 'What are the configurations and why a map of configurations?', 'commenter': 'oscerd'}]"
3031,core/camel-core/src/test/java/org/apache/camel/converter/ObjectConverterTest.java,"@@ -17,8 +17,11 @@
 package org.apache.camel.converter;
 
 import java.math.BigInteger;
+import java.util.AbstractMap.*;","[{'comment': 'Please avoid * in imports', 'commenter': 'oscerd'}]"
3032,examples/camel-example-cdi/README.md,"@@ -16,7 +16,7 @@ You will need to compile this example first:
 $ mvn compile
 ```
 
-### Run
+scala-dsl-supported-languages### Run","[{'comment': ""I'm not sure about this change, a typo?"", 'commenter': 'zregvart'}]"
3032,core/camel-endpointdsl/src/main/java/org/apache/camel/builder/endpoint/dsl/RestSwaggerEndpointBuilderFactory.java,"@@ -120,7 +120,7 @@ default AdvancedRestSwaggerEndpointBuilder synchronous(
      * tries to load swagger.json resource from the classpath. Note that the
      * host defined on the component and endpoint of this Component should
      * contain the scheme, hostname and optionally the port in the URI syntax
-     * (i.e. http://api.example.com:8080). Overrides component configuration.
+     * (i.e. \http://api.example.com:8080). Overrides component configuration.","[{'comment': ""I don't think we need to escape URLs in JavaDoc, this should be taken care of by the latest changes in the `camel-package-maven-plugin`\r\n```suggestion\r\n     * (i.e. http://api.example.com:8080). Overrides component configuration.\r\n```"", 'commenter': 'zregvart'}]"
3032,platforms/spring-boot/components-starter/camel-rest-swagger-starter/src/main/java/org/apache/camel/component/rest/swagger/springboot/RestSwaggerComponentConfiguration.java,"@@ -82,7 +82,7 @@
      * load swagger.json resource. Note that the host defined on the component
      * and endpoint of this Component should contain the scheme, hostname and
      * optionally the port in the URI syntax (i.e.
-     * https://api.example.com:8080). Can be overridden in endpoint
+     * \https://api.example.com:8080). Can be overridden in endpoint","[{'comment': 'This will be regenerated by the build without escape when the suggested change in `core/camel-endpointdsl/src/main/java/org/apache/camel/builder/endpoint/dsl/RestSwaggerEndpointBuilderFactory.java`', 'commenter': 'zregvart'}, {'comment': 'Okay Mr.Zoran, can you check now?', 'commenter': 'Nayananga'}, {'comment': 'I ran ./mvnw -Pfastinstall install after doing above change, but this also unescaped according to the above change, is it okay?', 'commenter': 'Nayananga'}]"
3033,components/camel-cmis/src/main/java/org/apache/camel/component/cmis/CMISProducer.java,"@@ -57,12 +57,11 @@ public CMISEndpoint getEndpoint() {
     }
 
     public void process(Exchange exchange) throws Exception {
-        CmisObject cmisObject = createNode(exchange);
-        log.debug(""Created node with id: {}"", cmisObject.getId());
 
-        // copy the header of in message to the out message
-        exchange.getOut().copyFrom(exchange.getIn());
-        exchange.getOut().setBody(cmisObject.getId());
+        CamelCMISActions action = exchange.getIn().getHeader(CamelCMISConstants.CMIS_ACTION, CamelCMISActions.class);
+
+        this.getClass().getDeclaredMethod(action.getMethodName(), Exchange.class).invoke(this , exchange);","[{'comment': 'Agree with @oscerd about tests as reflection is actively using.\r\nMay be better to use ObjectHelper.invokeMethod or  ObjectHelper.invokeMethodSafe here?', 'commenter': 'dmvolod'}, {'comment': ""I'd use invokeMethod here."", 'commenter': 'oscerd'}, {'comment': 'I cant build the project and I cant run the existing tests. Maybe if I fix this problem I will write some tests...\r\n', 'commenter': 'cherepnalkovski'}, {'comment': 'What is the error you have?', 'commenter': 'oscerd'}, {'comment': 'It fails on last module. \r\nCannot resolve  com.atlassian.jira:jira-rest-java-client-api:jar:5.1.0 , com.atlassian.httpclient:atlassian-httpclient-api:jar:2.0.0-m1 .....\r\nCamel-cmis is successfully built, but if I open CMISProducer.class for example, DefaultProducer, Exchange, Message... it can resolve them, cant find the source. \r\n![image](https://user-images.githubusercontent.com/15361682/61290315-e2fde300-a7cb-11e9-9e15-1777afe3f1e2.png)\r\n', 'commenter': 'cherepnalkovski'}, {'comment': 'You need to have core projects open.', 'commenter': 'oscerd'}, {'comment': 'How do you mean open ? \r\nI am opening camel project with all modules, not just camel-cmis', 'commenter': 'cherepnalkovski'}, {'comment': 'It seems you are using IntelliJ Idea. Do CTRL+SHIFT+A and choose ""Reimport all maven projects"". If this does not help, run in root camel folder ""mvn clean install -Pfastinstall"" and then reimport. ', 'commenter': 'bedlaj'}]"
3033,components/camel-cmis/src/main/java/org/apache/camel/component/cmis/CMISProducer.java,"@@ -113,6 +112,226 @@ private CmisObject createNode(Exchange exchange) throws Exception {
         }
     }
 
+    private List<String> deleteFolder(Exchange exchange) throws Exception {
+        validateRequiredHeader(exchange, PropertyIds.OBJECT_ID);
+
+        Message message = exchange.getIn();
+
+        String objectId = message.getHeader(PropertyIds.OBJECT_ID, String.class);
+        Folder folder = (Folder) getSessionFacade().getObjectById(objectId);
+        return folder.deleteTree(true, UnfileObject.DELETE, true);
+    }
+
+    private void deleteDocument(Exchange exchange) throws Exception {
+        validateRequiredHeader(exchange, PropertyIds.OBJECT_ID);
+
+        Message message = exchange.getIn();
+
+        String objectId = message.getHeader(PropertyIds.OBJECT_ID, String.class);
+        Document document = (Document) getSessionFacade().getObjectById(objectId);
+
+        document.deleteAllVersions();
+    }
+
+    private void moveDocument(Exchange exchange) throws Exception
+    {
+        validateRequiredHeader(exchange, CamelCMISConstants.CMIS_DESTIONATION_FOLDER_ID);
+        validateRequiredHeader(exchange, CamelCMISConstants.CMIS_SOURCE_FOLDER_ID);
+        validateRequiredHeader(exchange, CamelCMISConstants.CMIS_OBJECT_ID);
+
+        Message message = exchange.getIn();
+
+        String destinationFolderId = message.getHeader(CamelCMISConstants.CMIS_DESTIONATION_FOLDER_ID, String.class);
+        String sourceFolderId = message.getHeader(CamelCMISConstants.CMIS_SOURCE_FOLDER_ID, String.class);
+        String objectId = message.getHeader(CamelCMISConstants.CMIS_OBJECT_ID, String.class);
+
+
+        Folder sourceFolder = (Folder) getSessionFacade().getObjectById(sourceFolderId);
+        Folder targetFolder = (Folder) getSessionFacade().getObjectById(destinationFolderId);
+
+        Document document = (Document) getSessionFacade().getObjectById(objectId);
+
+        if(document != null)
+        {
+            if(document.getAllowableActions().getAllowableActions().contains(Action.CAN_MOVE_OBJECT) == false)
+            {
+                throw new CmisUnauthorizedException(""Current user does not have permission to move "" + objectId + document.getName());","[{'comment': ""Usually, we don't use third party exceptions in components. You can choose another one and see example from other components. "", 'commenter': 'dmvolod'}]"
3033,components/camel-cmis/src/main/java/org/apache/camel/component/cmis/CMISProducer.java,"@@ -113,6 +112,226 @@ private CmisObject createNode(Exchange exchange) throws Exception {
         }
     }
 
+    private List<String> deleteFolder(Exchange exchange) throws Exception {
+        validateRequiredHeader(exchange, PropertyIds.OBJECT_ID);
+
+        Message message = exchange.getIn();
+
+        String objectId = message.getHeader(PropertyIds.OBJECT_ID, String.class);
+        Folder folder = (Folder) getSessionFacade().getObjectById(objectId);
+        return folder.deleteTree(true, UnfileObject.DELETE, true);
+    }
+
+    private void deleteDocument(Exchange exchange) throws Exception {
+        validateRequiredHeader(exchange, PropertyIds.OBJECT_ID);
+
+        Message message = exchange.getIn();
+
+        String objectId = message.getHeader(PropertyIds.OBJECT_ID, String.class);
+        Document document = (Document) getSessionFacade().getObjectById(objectId);
+
+        document.deleteAllVersions();
+    }
+
+    private void moveDocument(Exchange exchange) throws Exception
+    {
+        validateRequiredHeader(exchange, CamelCMISConstants.CMIS_DESTIONATION_FOLDER_ID);
+        validateRequiredHeader(exchange, CamelCMISConstants.CMIS_SOURCE_FOLDER_ID);
+        validateRequiredHeader(exchange, CamelCMISConstants.CMIS_OBJECT_ID);
+
+        Message message = exchange.getIn();
+
+        String destinationFolderId = message.getHeader(CamelCMISConstants.CMIS_DESTIONATION_FOLDER_ID, String.class);
+        String sourceFolderId = message.getHeader(CamelCMISConstants.CMIS_SOURCE_FOLDER_ID, String.class);
+        String objectId = message.getHeader(CamelCMISConstants.CMIS_OBJECT_ID, String.class);
+
+
+        Folder sourceFolder = (Folder) getSessionFacade().getObjectById(sourceFolderId);
+        Folder targetFolder = (Folder) getSessionFacade().getObjectById(destinationFolderId);
+
+        Document document = (Document) getSessionFacade().getObjectById(objectId);
+
+        if(document != null)
+        {
+            if(document.getAllowableActions().getAllowableActions().contains(Action.CAN_MOVE_OBJECT) == false)
+            {
+                throw new CmisUnauthorizedException(""Current user does not have permission to move "" + objectId + document.getName());
+            }
+
+            try {
+                document.move(sourceFolder, targetFolder);
+                log.info(""Moved document from "" + sourceFolder.getName() + "" to "" + targetFolder.getName() );
+            }
+            catch (CmisRuntimeException e)
+            {
+                log.error(""Cannot move document to folder "" + targetFolder.getName() + "" : "" + e.getMessage());
+            }
+        }
+        else
+        {
+            log.error(""Document is null, cannot move!"");
+        }
+    }
+
+    private void moveFolder(Exchange exchange) throws Exception
+    {
+        validateRequiredHeader(exchange, CamelCMISConstants.CMIS_DESTIONATION_FOLDER_ID);
+        validateRequiredHeader(exchange, CamelCMISConstants.CMIS_OBJECT_ID);
+
+        Message message = exchange.getIn();
+
+        String destinationFolderId = message.getHeader(CamelCMISConstants.CMIS_DESTIONATION_FOLDER_ID, String.class);
+        String objectId = message.getHeader(CamelCMISConstants.CMIS_OBJECT_ID, String.class);
+
+        Folder toBeMoved = (Folder) getSessionFacade().getObjectById(objectId);
+        Folder targetFolder = (Folder) getSessionFacade().getObjectById(destinationFolderId);
+
+        copyFolderRecursive(targetFolder, toBeMoved);
+        toBeMoved.deleteTree(true, UnfileObject.DELETE, true);
+    }
+
+    private void copyDocument(Exchange exchange) throws Exception
+    {
+        validateRequiredHeader(exchange, PropertyIds.OBJECT_ID);
+        validateRequiredHeader(exchange, CamelCMISConstants.CMIS_DESTIONATION_FOLDER_ID);
+
+        Message message = exchange.getIn();
+
+        String destinationFolderId = message.getHeader(CamelCMISConstants.CMIS_DESTIONATION_FOLDER_ID, String.class);
+        String objectId = message.getHeader(PropertyIds.OBJECT_ID, String.class);
+        Folder destinationFolder = (Folder) getSessionFacade().getObjectById(destinationFolderId);
+
+        Document document = (Document) getSessionFacade().getObjectById(objectId);
+
+        document.copy(destinationFolder);
+    }
+
+    private void copyFolder(Exchange exchange) throws Exception
+    {
+        validateRequiredHeader(exchange, CamelCMISConstants.CMIS_DESTIONATION_FOLDER_ID);
+        validateRequiredHeader(exchange, PropertyIds.OBJECT_ID);
+
+        Message message = exchange.getIn();
+
+        String destinationFolderId = message.getHeader(CamelCMISConstants.CMIS_DESTIONATION_FOLDER_ID, String.class);
+        String toCopyFolderId = message.getHeader(PropertyIds.OBJECT_ID, String.class);
+
+        Folder destinationFolder = (Folder) getSessionFacade().getObjectById(destinationFolderId);
+        Folder toCopyFolder = (Folder) getSessionFacade().getObjectById(toCopyFolderId);
+
+        copyFolderRecursive(destinationFolder, toCopyFolder);
+    }
+
+    public void copyFolderRecursive(Folder destinationFolder, Folder toCopyFolder)
+    {
+        Map<String, Object> folderProperties = new HashMap<String, Object>();
+        folderProperties.put(PropertyIds.NAME, toCopyFolder.getName());
+        folderProperties.put(PropertyIds.OBJECT_TYPE_ID, toCopyFolder.getBaseTypeId().value());
+        Folder newFolder = destinationFolder.createFolder(folderProperties);
+        copyChildren(newFolder, toCopyFolder);
+    }
+
+    public void copyChildren(Folder destinationFolder, Folder toCopyFolder)
+    {
+        ItemIterable<CmisObject> immediateChildren = toCopyFolder.getChildren();
+        for (CmisObject child : immediateChildren)
+        {
+            if (child instanceof Document)
+            {
+                ((Document) child).copy(destinationFolder);
+            } else if (child instanceof Folder)
+            {
+                copyFolderRecursive(destinationFolder, (Folder) child);
+            }
+        }
+    }
+
+    private void renameDocument(Exchange exchange) throws Exception
+    {
+        validateRequiredHeader(exchange, PropertyIds.NAME);
+        validateRequiredHeader(exchange, CamelCMISConstants.CMIS_OBJECT_ID);
+
+        Message message = exchange.getIn();
+
+        String newName = message.getHeader(PropertyIds.NAME, String.class);
+        String objectId = message.getHeader(CamelCMISConstants.CMIS_OBJECT_ID, String.class);
+        try {
+            Document document = (Document) getSessionFacade().getObjectById(objectId);
+            document.rename(newName);
+        }
+        catch (Exception e)
+        {
+            throw new CmisObjectNotFoundException(""Document with id: "" + objectId + "" can not be found!"");","[{'comment': 'The same as previous comment.', 'commenter': 'dmvolod'}]"
3033,components/camel-cmis/src/main/java/org/apache/camel/component/cmis/CamelCMISConstants.java,"@@ -19,9 +19,15 @@
 public interface CamelCMISConstants {
     String CMIS_DOCUMENT = ""cmis:document"";
     String CMIS_FOLDER = ""cmis:folder"";
+    String CMIS_ACTION = ""cmis:action"";
     String CMIS_FOLDER_PATH = ""CamelCMISFolderPath"";
+    String CMIS_OBJECT_ID = ""ObjectId"";","[{'comment': 'Could be very common name and intersect with another/custom/third-party component or customer route header name.', 'commenter': 'dmvolod'}]"
3033,components/camel-cmis/src/main/java/org/apache/camel/component/cmis/CamelCMISConstants.java,"@@ -19,9 +19,15 @@
 public interface CamelCMISConstants {
     String CMIS_DOCUMENT = ""cmis:document"";
     String CMIS_FOLDER = ""cmis:folder"";
+    String CMIS_ACTION = ""cmis:action"";
     String CMIS_FOLDER_PATH = ""CamelCMISFolderPath"";
+    String CMIS_OBJECT_ID = ""CMISObjectId"";","[{'comment': 'May be use the common names for all CMIS component constants, i.e. CamelCMISObjectId?', 'commenter': 'dmvolod'}, {'comment': 'I will change this in next commit\r\n', 'commenter': 'cherepnalkovski'}]"
3033,components/camel-cmis/src/main/java/org/apache/camel/component/cmis/CMISProducer.java,"@@ -57,12 +62,12 @@ public CMISEndpoint getEndpoint() {
     }
 
     public void process(Exchange exchange) throws Exception {
-        CmisObject cmisObject = createNode(exchange);
-        log.debug(""Created node with id: {}"", cmisObject.getId());
 
-        // copy the header of in message to the out message
-        exchange.getOut().copyFrom(exchange.getIn());
-        exchange.getOut().setBody(cmisObject.getId());
+        CamelCMISActions action = exchange.getIn().getHeader(CamelCMISConstants.CMIS_ACTION, CamelCMISActions.class);
+
+        Class[] paramMethod = null;","[{'comment': 'This is working, but the correct one looks like Exchange.class...', 'commenter': 'dmvolod'}, {'comment': 'paramMethod should be Exchange.class type ? ', 'commenter': 'cherepnalkovski'}, {'comment': 'Yes\r\n```suggestion\r\n        Class[] paramMethod = {Exchange.class};\r\n```', 'commenter': 'dmvolod'}]"
3033,components/camel-cmis/src/main/java/org/apache/camel/component/cmis/CMISProducer.java,"@@ -113,6 +118,201 @@ private CmisObject createNode(Exchange exchange) throws Exception {
         }
     }
 
+    public List<String> deleteFolder(Exchange exchange) throws Exception {
+        validateRequiredHeader(exchange, CamelCMISConstants.CMIS_OBJECT_ID);
+
+        Message message = exchange.getIn();
+
+        String objectId = message.getHeader(CamelCMISConstants.CMIS_OBJECT_ID, String.class);
+        Folder folder = (Folder) getSessionFacade().getObjectById(objectId);
+        return folder.deleteTree(true, UnfileObject.DELETE, true);
+    }
+
+    public void deleteDocument(Exchange exchange) throws Exception {
+        validateRequiredHeader(exchange, CamelCMISConstants.CMIS_OBJECT_ID);
+
+        Message message = exchange.getIn();
+
+        String objectId = message.getHeader(CamelCMISConstants.CMIS_OBJECT_ID, String.class);
+        Document document = (Document) getSessionFacade().getObjectById(objectId);
+
+        document.deleteAllVersions();
+    }
+
+    public void moveDocument(Exchange exchange) throws Exception {
+        validateRequiredHeader(exchange, CamelCMISConstants.CMIS_DESTIONATION_FOLDER_ID);
+        validateRequiredHeader(exchange, CamelCMISConstants.CMIS_SOURCE_FOLDER_ID);
+        validateRequiredHeader(exchange, CamelCMISConstants.CMIS_OBJECT_ID);
+
+        Message message = exchange.getIn();
+
+        String destinationFolderId = message.getHeader(CamelCMISConstants.CMIS_DESTIONATION_FOLDER_ID, String.class);
+        String sourceFolderId = message.getHeader(CamelCMISConstants.CMIS_SOURCE_FOLDER_ID, String.class);
+        String objectId = message.getHeader(CamelCMISConstants.CMIS_OBJECT_ID, String.class);
+
+
+        Folder sourceFolder = (Folder) getSessionFacade().getObjectById(sourceFolderId);
+        Folder targetFolder = (Folder) getSessionFacade().getObjectById(destinationFolderId);
+
+        Document document = (Document) getSessionFacade().getObjectById(objectId);
+
+        if (document != null) {
+            if (!document.getAllowableActions().getAllowableActions().contains(Action.CAN_MOVE_OBJECT)) {
+                throw new CmisUnauthorizedException(""Current user does not have permission to move "" + objectId + document.getName());
+            }
+
+            try {
+                document.move(sourceFolder, targetFolder);
+                log.info(""Moved document from "" + sourceFolder.getName() + "" to "" + targetFolder.getName());
+            } catch (CmisRuntimeException e) {
+                log.error(""Cannot move document to folder "" + targetFolder.getName() + "" : "" + e.getMessage());
+            }
+        } else {
+            log.error(""Document is null, cannot move!"");
+        }
+    }
+
+    public void moveFolder(Exchange exchange) throws Exception {
+        validateRequiredHeader(exchange, CamelCMISConstants.CMIS_DESTIONATION_FOLDER_ID);
+        validateRequiredHeader(exchange, CamelCMISConstants.CMIS_OBJECT_ID);
+
+        Message message = exchange.getIn();
+
+        String destinationFolderId = message.getHeader(CamelCMISConstants.CMIS_DESTIONATION_FOLDER_ID, String.class);
+        String objectId = message.getHeader(CamelCMISConstants.CMIS_OBJECT_ID, String.class);
+
+        Folder toBeMoved = (Folder) getSessionFacade().getObjectById(objectId);
+        Folder targetFolder = (Folder) getSessionFacade().getObjectById(destinationFolderId);
+
+        copyFolderRecursive(targetFolder, toBeMoved);
+        toBeMoved.deleteTree(true, UnfileObject.DELETE, true);
+    }
+
+    public void copyDocument(Exchange exchange) throws Exception {
+        validateRequiredHeader(exchange, CamelCMISConstants.CMIS_OBJECT_ID);
+        validateRequiredHeader(exchange, CamelCMISConstants.CMIS_DESTIONATION_FOLDER_ID);
+
+        Message message = exchange.getIn();
+
+        String destinationFolderId = message.getHeader(CamelCMISConstants.CMIS_DESTIONATION_FOLDER_ID, String.class);
+        String objectId = message.getHeader(CamelCMISConstants.CMIS_OBJECT_ID, String.class);
+        Folder destinationFolder = (Folder) getSessionFacade().getObjectById(destinationFolderId);
+
+        Document document = (Document) getSessionFacade().getObjectById(objectId);
+
+        document.copy(destinationFolder);
+    }
+
+    public void copyFolder(Exchange exchange) throws Exception {
+        validateRequiredHeader(exchange, CamelCMISConstants.CMIS_DESTIONATION_FOLDER_ID);
+        validateRequiredHeader(exchange, CamelCMISConstants.CMIS_OBJECT_ID);
+
+        Message message = exchange.getIn();
+
+        String destinationFolderId = message.getHeader(CamelCMISConstants.CMIS_DESTIONATION_FOLDER_ID, String.class);
+        String toCopyFolderId = message.getHeader(CamelCMISConstants.CMIS_OBJECT_ID, String.class);
+
+        Folder destinationFolder = (Folder) getSessionFacade().getObjectById(destinationFolderId);
+        Folder toCopyFolder = (Folder) getSessionFacade().getObjectById(toCopyFolderId);
+
+        copyFolderRecursive(destinationFolder, toCopyFolder);
+    }
+
+    public void copyFolderRecursive(Folder destinationFolder, Folder toCopyFolder) {
+        Map<String, Object> folderProperties = new HashMap<String, Object>();
+        folderProperties.put(PropertyIds.NAME, toCopyFolder.getName());
+        folderProperties.put(PropertyIds.OBJECT_TYPE_ID, toCopyFolder.getBaseTypeId().value());
+        Folder newFolder = destinationFolder.createFolder(folderProperties);
+        copyChildren(newFolder, toCopyFolder);
+    }
+
+    public void copyChildren(Folder destinationFolder, Folder toCopyFolder) {
+        ItemIterable<CmisObject> immediateChildren = toCopyFolder.getChildren();
+        for (CmisObject child : immediateChildren) {
+            if (child instanceof Document) {
+                ((Document) child).copy(destinationFolder);
+            } else if (child instanceof Folder) {
+                copyFolderRecursive(destinationFolder, (Folder) child);
+            }
+        }
+    }
+
+    public void renameDocument(Exchange exchange) throws Exception {
+        validateRequiredHeader(exchange, PropertyIds.NAME);
+        validateRequiredHeader(exchange, CamelCMISConstants.CMIS_OBJECT_ID);
+
+        Message message = exchange.getIn();
+
+        String newName = message.getHeader(PropertyIds.NAME, String.class);
+        String objectId = message.getHeader(CamelCMISConstants.CMIS_OBJECT_ID, String.class);
+        try {
+            Document document = (Document) getSessionFacade().getObjectById(objectId);
+            document.rename(newName);
+        } catch (Exception e) {
+            throw new CmisObjectNotFoundException(""Document with id: "" + objectId + "" can not be found!"");
+        }
+    }
+
+    public void renameFolder(Exchange exchange) throws Exception {
+        validateRequiredHeader(exchange, PropertyIds.NAME);
+        validateRequiredHeader(exchange, CamelCMISConstants.CMIS_OBJECT_ID);
+
+        Message message = exchange.getIn();
+
+        String newName = message.getHeader(PropertyIds.NAME, String.class);
+        String objectId = message.getHeader(CamelCMISConstants.CMIS_OBJECT_ID, String.class);
+
+        try {
+            Folder folder = (Folder) getSessionFacade().getObjectById(objectId);
+            folder.rename(newName);","[{'comment': 'These two rename methods are almost the same. If you remove that unneded cast to Folder, then you can have just one method _rename_, instead of _renameDocument_ and _renameFolder_. \r\n\r\n`CmisObject object = getSessionFacade().getObjectById(objectId); object.rename(newName);`\r\nrename method is implemented on the scope of CmisObject', 'commenter': 'bedlaj'}, {'comment': 'Good catch, I will change in next commit. Thanks', 'commenter': 'cherepnalkovski'}]"
3033,components/camel-cmis/src/main/java/org/apache/camel/component/cmis/CMISProducer.java,"@@ -92,12 +97,12 @@ public void process(Exchange exchange) throws Exception {
         return result;
     }
 
-    private CmisObject createNode(Exchange exchange) throws Exception {
+    public CmisObject createNode(Exchange exchange) throws Exception {","[{'comment': 'Please annotate all these methods called via reflection with `@SuppressWarnings(""unused"")`, also add javadoc stating that the method is called via reflection. It must be clear, that the method is not safe to rename or delete.', 'commenter': 'bedlaj'}]"
3033,components/camel-cmis/src/main/java/org/apache/camel/component/cmis/CMISProducer.java,"@@ -113,6 +118,201 @@ private CmisObject createNode(Exchange exchange) throws Exception {
         }
     }
 
+    public List<String> deleteFolder(Exchange exchange) throws Exception {
+        validateRequiredHeader(exchange, CamelCMISConstants.CMIS_OBJECT_ID);
+
+        Message message = exchange.getIn();
+
+        String objectId = message.getHeader(CamelCMISConstants.CMIS_OBJECT_ID, String.class);
+        Folder folder = (Folder) getSessionFacade().getObjectById(objectId);
+        return folder.deleteTree(true, UnfileObject.DELETE, true);
+    }
+
+    public void deleteDocument(Exchange exchange) throws Exception {
+        validateRequiredHeader(exchange, CamelCMISConstants.CMIS_OBJECT_ID);
+
+        Message message = exchange.getIn();
+
+        String objectId = message.getHeader(CamelCMISConstants.CMIS_OBJECT_ID, String.class);
+        Document document = (Document) getSessionFacade().getObjectById(objectId);
+
+        document.deleteAllVersions();
+    }
+
+    public void moveDocument(Exchange exchange) throws Exception {
+        validateRequiredHeader(exchange, CamelCMISConstants.CMIS_DESTIONATION_FOLDER_ID);
+        validateRequiredHeader(exchange, CamelCMISConstants.CMIS_SOURCE_FOLDER_ID);
+        validateRequiredHeader(exchange, CamelCMISConstants.CMIS_OBJECT_ID);
+
+        Message message = exchange.getIn();
+
+        String destinationFolderId = message.getHeader(CamelCMISConstants.CMIS_DESTIONATION_FOLDER_ID, String.class);
+        String sourceFolderId = message.getHeader(CamelCMISConstants.CMIS_SOURCE_FOLDER_ID, String.class);
+        String objectId = message.getHeader(CamelCMISConstants.CMIS_OBJECT_ID, String.class);
+
+
+        Folder sourceFolder = (Folder) getSessionFacade().getObjectById(sourceFolderId);
+        Folder targetFolder = (Folder) getSessionFacade().getObjectById(destinationFolderId);
+
+        Document document = (Document) getSessionFacade().getObjectById(objectId);
+
+        if (document != null) {
+            if (!document.getAllowableActions().getAllowableActions().contains(Action.CAN_MOVE_OBJECT)) {
+                throw new CmisUnauthorizedException(""Current user does not have permission to move "" + objectId + document.getName());
+            }
+
+            try {
+                document.move(sourceFolder, targetFolder);
+                log.info(""Moved document from "" + sourceFolder.getName() + "" to "" + targetFolder.getName());
+            } catch (CmisRuntimeException e) {
+                log.error(""Cannot move document to folder "" + targetFolder.getName() + "" : "" + e.getMessage());
+            }
+        } else {
+            log.error(""Document is null, cannot move!"");
+        }
+    }
+
+    public void moveFolder(Exchange exchange) throws Exception {
+        validateRequiredHeader(exchange, CamelCMISConstants.CMIS_DESTIONATION_FOLDER_ID);
+        validateRequiredHeader(exchange, CamelCMISConstants.CMIS_OBJECT_ID);
+
+        Message message = exchange.getIn();
+
+        String destinationFolderId = message.getHeader(CamelCMISConstants.CMIS_DESTIONATION_FOLDER_ID, String.class);
+        String objectId = message.getHeader(CamelCMISConstants.CMIS_OBJECT_ID, String.class);
+
+        Folder toBeMoved = (Folder) getSessionFacade().getObjectById(objectId);
+        Folder targetFolder = (Folder) getSessionFacade().getObjectById(destinationFolderId);
+
+        copyFolderRecursive(targetFolder, toBeMoved);
+        toBeMoved.deleteTree(true, UnfileObject.DELETE, true);
+    }
+
+    public void copyDocument(Exchange exchange) throws Exception {
+        validateRequiredHeader(exchange, CamelCMISConstants.CMIS_OBJECT_ID);
+        validateRequiredHeader(exchange, CamelCMISConstants.CMIS_DESTIONATION_FOLDER_ID);
+
+        Message message = exchange.getIn();
+
+        String destinationFolderId = message.getHeader(CamelCMISConstants.CMIS_DESTIONATION_FOLDER_ID, String.class);
+        String objectId = message.getHeader(CamelCMISConstants.CMIS_OBJECT_ID, String.class);
+        Folder destinationFolder = (Folder) getSessionFacade().getObjectById(destinationFolderId);
+
+        Document document = (Document) getSessionFacade().getObjectById(objectId);
+
+        document.copy(destinationFolder);
+    }
+
+    public void copyFolder(Exchange exchange) throws Exception {
+        validateRequiredHeader(exchange, CamelCMISConstants.CMIS_DESTIONATION_FOLDER_ID);
+        validateRequiredHeader(exchange, CamelCMISConstants.CMIS_OBJECT_ID);
+
+        Message message = exchange.getIn();
+
+        String destinationFolderId = message.getHeader(CamelCMISConstants.CMIS_DESTIONATION_FOLDER_ID, String.class);
+        String toCopyFolderId = message.getHeader(CamelCMISConstants.CMIS_OBJECT_ID, String.class);
+
+        Folder destinationFolder = (Folder) getSessionFacade().getObjectById(destinationFolderId);
+        Folder toCopyFolder = (Folder) getSessionFacade().getObjectById(toCopyFolderId);
+
+        copyFolderRecursive(destinationFolder, toCopyFolder);
+    }
+
+    public void copyFolderRecursive(Folder destinationFolder, Folder toCopyFolder) {
+        Map<String, Object> folderProperties = new HashMap<String, Object>();","[{'comment': 'We are targetting Java 8+, you can use diamond here `new HashMap<>()`', 'commenter': 'bedlaj'}]"
3033,components/camel-cmis/src/main/java/org/apache/camel/component/cmis/CMISProducer.java,"@@ -113,6 +118,201 @@ private CmisObject createNode(Exchange exchange) throws Exception {
         }
     }
 
+    public List<String> deleteFolder(Exchange exchange) throws Exception {
+        validateRequiredHeader(exchange, CamelCMISConstants.CMIS_OBJECT_ID);
+
+        Message message = exchange.getIn();
+
+        String objectId = message.getHeader(CamelCMISConstants.CMIS_OBJECT_ID, String.class);
+        Folder folder = (Folder) getSessionFacade().getObjectById(objectId);
+        return folder.deleteTree(true, UnfileObject.DELETE, true);
+    }
+
+    public void deleteDocument(Exchange exchange) throws Exception {
+        validateRequiredHeader(exchange, CamelCMISConstants.CMIS_OBJECT_ID);
+
+        Message message = exchange.getIn();
+
+        String objectId = message.getHeader(CamelCMISConstants.CMIS_OBJECT_ID, String.class);
+        Document document = (Document) getSessionFacade().getObjectById(objectId);
+
+        document.deleteAllVersions();
+    }
+
+    public void moveDocument(Exchange exchange) throws Exception {
+        validateRequiredHeader(exchange, CamelCMISConstants.CMIS_DESTIONATION_FOLDER_ID);
+        validateRequiredHeader(exchange, CamelCMISConstants.CMIS_SOURCE_FOLDER_ID);
+        validateRequiredHeader(exchange, CamelCMISConstants.CMIS_OBJECT_ID);
+
+        Message message = exchange.getIn();
+
+        String destinationFolderId = message.getHeader(CamelCMISConstants.CMIS_DESTIONATION_FOLDER_ID, String.class);
+        String sourceFolderId = message.getHeader(CamelCMISConstants.CMIS_SOURCE_FOLDER_ID, String.class);
+        String objectId = message.getHeader(CamelCMISConstants.CMIS_OBJECT_ID, String.class);
+
+
+        Folder sourceFolder = (Folder) getSessionFacade().getObjectById(sourceFolderId);
+        Folder targetFolder = (Folder) getSessionFacade().getObjectById(destinationFolderId);
+
+        Document document = (Document) getSessionFacade().getObjectById(objectId);
+
+        if (document != null) {
+            if (!document.getAllowableActions().getAllowableActions().contains(Action.CAN_MOVE_OBJECT)) {
+                throw new CmisUnauthorizedException(""Current user does not have permission to move "" + objectId + document.getName());
+            }
+
+            try {
+                document.move(sourceFolder, targetFolder);
+                log.info(""Moved document from "" + sourceFolder.getName() + "" to "" + targetFolder.getName());
+            } catch (CmisRuntimeException e) {
+                log.error(""Cannot move document to folder "" + targetFolder.getName() + "" : "" + e.getMessage());
+            }
+        } else {
+            log.error(""Document is null, cannot move!"");
+        }
+    }
+
+    public void moveFolder(Exchange exchange) throws Exception {
+        validateRequiredHeader(exchange, CamelCMISConstants.CMIS_DESTIONATION_FOLDER_ID);
+        validateRequiredHeader(exchange, CamelCMISConstants.CMIS_OBJECT_ID);
+
+        Message message = exchange.getIn();
+
+        String destinationFolderId = message.getHeader(CamelCMISConstants.CMIS_DESTIONATION_FOLDER_ID, String.class);
+        String objectId = message.getHeader(CamelCMISConstants.CMIS_OBJECT_ID, String.class);
+
+        Folder toBeMoved = (Folder) getSessionFacade().getObjectById(objectId);
+        Folder targetFolder = (Folder) getSessionFacade().getObjectById(destinationFolderId);
+
+        copyFolderRecursive(targetFolder, toBeMoved);
+        toBeMoved.deleteTree(true, UnfileObject.DELETE, true);
+    }
+
+    public void copyDocument(Exchange exchange) throws Exception {
+        validateRequiredHeader(exchange, CamelCMISConstants.CMIS_OBJECT_ID);
+        validateRequiredHeader(exchange, CamelCMISConstants.CMIS_DESTIONATION_FOLDER_ID);
+
+        Message message = exchange.getIn();
+
+        String destinationFolderId = message.getHeader(CamelCMISConstants.CMIS_DESTIONATION_FOLDER_ID, String.class);
+        String objectId = message.getHeader(CamelCMISConstants.CMIS_OBJECT_ID, String.class);
+        Folder destinationFolder = (Folder) getSessionFacade().getObjectById(destinationFolderId);
+
+        Document document = (Document) getSessionFacade().getObjectById(objectId);
+
+        document.copy(destinationFolder);
+    }
+
+    public void copyFolder(Exchange exchange) throws Exception {
+        validateRequiredHeader(exchange, CamelCMISConstants.CMIS_DESTIONATION_FOLDER_ID);
+        validateRequiredHeader(exchange, CamelCMISConstants.CMIS_OBJECT_ID);
+
+        Message message = exchange.getIn();
+
+        String destinationFolderId = message.getHeader(CamelCMISConstants.CMIS_DESTIONATION_FOLDER_ID, String.class);
+        String toCopyFolderId = message.getHeader(CamelCMISConstants.CMIS_OBJECT_ID, String.class);
+
+        Folder destinationFolder = (Folder) getSessionFacade().getObjectById(destinationFolderId);
+        Folder toCopyFolder = (Folder) getSessionFacade().getObjectById(toCopyFolderId);
+
+        copyFolderRecursive(destinationFolder, toCopyFolder);
+    }
+
+    public void copyFolderRecursive(Folder destinationFolder, Folder toCopyFolder) {
+        Map<String, Object> folderProperties = new HashMap<String, Object>();
+        folderProperties.put(PropertyIds.NAME, toCopyFolder.getName());
+        folderProperties.put(PropertyIds.OBJECT_TYPE_ID, toCopyFolder.getBaseTypeId().value());
+        Folder newFolder = destinationFolder.createFolder(folderProperties);
+        copyChildren(newFolder, toCopyFolder);
+    }
+
+    public void copyChildren(Folder destinationFolder, Folder toCopyFolder) {
+        ItemIterable<CmisObject> immediateChildren = toCopyFolder.getChildren();
+        for (CmisObject child : immediateChildren) {
+            if (child instanceof Document) {
+                ((Document) child).copy(destinationFolder);
+            } else if (child instanceof Folder) {
+                copyFolderRecursive(destinationFolder, (Folder) child);
+            }
+        }
+    }
+
+    public void renameDocument(Exchange exchange) throws Exception {
+        validateRequiredHeader(exchange, PropertyIds.NAME);
+        validateRequiredHeader(exchange, CamelCMISConstants.CMIS_OBJECT_ID);
+
+        Message message = exchange.getIn();
+
+        String newName = message.getHeader(PropertyIds.NAME, String.class);
+        String objectId = message.getHeader(CamelCMISConstants.CMIS_OBJECT_ID, String.class);
+        try {
+            Document document = (Document) getSessionFacade().getObjectById(objectId);
+            document.rename(newName);
+        } catch (Exception e) {
+            throw new CmisObjectNotFoundException(""Document with id: "" + objectId + "" can not be found!"");
+        }
+    }
+
+    public void renameFolder(Exchange exchange) throws Exception {
+        validateRequiredHeader(exchange, PropertyIds.NAME);
+        validateRequiredHeader(exchange, CamelCMISConstants.CMIS_OBJECT_ID);
+
+        Message message = exchange.getIn();
+
+        String newName = message.getHeader(PropertyIds.NAME, String.class);
+        String objectId = message.getHeader(CamelCMISConstants.CMIS_OBJECT_ID, String.class);
+
+        try {
+            Folder folder = (Folder) getSessionFacade().getObjectById(objectId);
+            folder.rename(newName);
+        } catch (Exception e) {
+            throw new CmisObjectNotFoundException(""Folder with id: "" + objectId + "" can not be found!"");
+        }
+    }
+
+    public void checkIn(Exchange exchange) throws Exception {
+        validateRequiredHeader(exchange, CamelCMISConstants.CMIS_OBJECT_ID);
+
+        Message message = exchange.getIn();
+
+        String objectId = message.getHeader(CamelCMISConstants.CMIS_OBJECT_ID, String.class);
+        String checkInComment = message.getHeader(PropertyIds.CHECKIN_COMMENT, String.class);
+        String fileName = message.getHeader(PropertyIds.NAME, String.class);
+        String mimeType = getMimeType(message);
+        InputStream inputStream = (InputStream) message.getBody();
+
+        byte[] bytes = StreamUtils.copyToByteArray(inputStream);","[{'comment': 'There is type converter for this. You can do just `message.getBody(byte[].class)` to get bytes from InputStream.', 'commenter': 'bedlaj'}]"
3033,components/camel-cmis/src/main/java/org/apache/camel/component/cmis/CMISProducer.java,"@@ -121,6 +321,14 @@ private Folder getFolderOnPath(Exchange exchange, String path) throws Exception
         }
     }
 
+    private Document getDocumentOnPath(Exchange exchange, String path) throws Exception {","[{'comment': 'Unused method', 'commenter': 'bedlaj'}]"
3033,components/camel-cmis/src/main/java/org/apache/camel/component/cmis/exception/CmisObjectNotFoundException.java,"@@ -0,0 +1,39 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.cmis.exception;
+
+public class CmisObjectNotFoundException extends CmisException {","[{'comment': 'It is confusing, that this exception have the same name as the library one. And this can be confusing for the users too, when implementing `onException` block. Is there better name? Maybe `CamelCmisObjectNotFoundException`', 'commenter': 'bedlaj'}]"
3033,components/camel-cmis/src/main/java/org/apache/camel/component/cmis/exception/CmisUnauthorizedException.java,"@@ -0,0 +1,39 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.cmis.exception;
+
+public class CmisUnauthorizedException extends CmisException {","[{'comment': 'ditto', 'commenter': 'bedlaj'}]"
3033,components/camel-cmis/src/main/java/org/apache/camel/component/cmis/CMISProducer.java,"@@ -113,6 +118,201 @@ private CmisObject createNode(Exchange exchange) throws Exception {
         }
     }
 
+    public List<String> deleteFolder(Exchange exchange) throws Exception {
+        validateRequiredHeader(exchange, CamelCMISConstants.CMIS_OBJECT_ID);
+
+        Message message = exchange.getIn();
+
+        String objectId = message.getHeader(CamelCMISConstants.CMIS_OBJECT_ID, String.class);
+        Folder folder = (Folder) getSessionFacade().getObjectById(objectId);
+        return folder.deleteTree(true, UnfileObject.DELETE, true);
+    }
+
+    public void deleteDocument(Exchange exchange) throws Exception {
+        validateRequiredHeader(exchange, CamelCMISConstants.CMIS_OBJECT_ID);
+
+        Message message = exchange.getIn();
+
+        String objectId = message.getHeader(CamelCMISConstants.CMIS_OBJECT_ID, String.class);
+        Document document = (Document) getSessionFacade().getObjectById(objectId);
+
+        document.deleteAllVersions();
+    }
+
+    public void moveDocument(Exchange exchange) throws Exception {
+        validateRequiredHeader(exchange, CamelCMISConstants.CMIS_DESTIONATION_FOLDER_ID);
+        validateRequiredHeader(exchange, CamelCMISConstants.CMIS_SOURCE_FOLDER_ID);
+        validateRequiredHeader(exchange, CamelCMISConstants.CMIS_OBJECT_ID);
+
+        Message message = exchange.getIn();
+
+        String destinationFolderId = message.getHeader(CamelCMISConstants.CMIS_DESTIONATION_FOLDER_ID, String.class);
+        String sourceFolderId = message.getHeader(CamelCMISConstants.CMIS_SOURCE_FOLDER_ID, String.class);
+        String objectId = message.getHeader(CamelCMISConstants.CMIS_OBJECT_ID, String.class);
+
+
+        Folder sourceFolder = (Folder) getSessionFacade().getObjectById(sourceFolderId);
+        Folder targetFolder = (Folder) getSessionFacade().getObjectById(destinationFolderId);
+
+        Document document = (Document) getSessionFacade().getObjectById(objectId);
+
+        if (document != null) {
+            if (!document.getAllowableActions().getAllowableActions().contains(Action.CAN_MOVE_OBJECT)) {
+                throw new CmisUnauthorizedException(""Current user does not have permission to move "" + objectId + document.getName());
+            }
+
+            try {
+                document.move(sourceFolder, targetFolder);
+                log.info(""Moved document from "" + sourceFolder.getName() + "" to "" + targetFolder.getName());
+            } catch (CmisRuntimeException e) {
+                log.error(""Cannot move document to folder "" + targetFolder.getName() + "" : "" + e.getMessage());
+            }
+        } else {
+            log.error(""Document is null, cannot move!"");
+        }
+    }
+
+    public void moveFolder(Exchange exchange) throws Exception {
+        validateRequiredHeader(exchange, CamelCMISConstants.CMIS_DESTIONATION_FOLDER_ID);
+        validateRequiredHeader(exchange, CamelCMISConstants.CMIS_OBJECT_ID);
+
+        Message message = exchange.getIn();
+
+        String destinationFolderId = message.getHeader(CamelCMISConstants.CMIS_DESTIONATION_FOLDER_ID, String.class);
+        String objectId = message.getHeader(CamelCMISConstants.CMIS_OBJECT_ID, String.class);
+
+        Folder toBeMoved = (Folder) getSessionFacade().getObjectById(objectId);
+        Folder targetFolder = (Folder) getSessionFacade().getObjectById(destinationFolderId);
+
+        copyFolderRecursive(targetFolder, toBeMoved);
+        toBeMoved.deleteTree(true, UnfileObject.DELETE, true);
+    }
+
+    public void copyDocument(Exchange exchange) throws Exception {
+        validateRequiredHeader(exchange, CamelCMISConstants.CMIS_OBJECT_ID);
+        validateRequiredHeader(exchange, CamelCMISConstants.CMIS_DESTIONATION_FOLDER_ID);
+
+        Message message = exchange.getIn();
+
+        String destinationFolderId = message.getHeader(CamelCMISConstants.CMIS_DESTIONATION_FOLDER_ID, String.class);
+        String objectId = message.getHeader(CamelCMISConstants.CMIS_OBJECT_ID, String.class);
+        Folder destinationFolder = (Folder) getSessionFacade().getObjectById(destinationFolderId);
+
+        Document document = (Document) getSessionFacade().getObjectById(objectId);
+
+        document.copy(destinationFolder);
+    }
+
+    public void copyFolder(Exchange exchange) throws Exception {
+        validateRequiredHeader(exchange, CamelCMISConstants.CMIS_DESTIONATION_FOLDER_ID);
+        validateRequiredHeader(exchange, CamelCMISConstants.CMIS_OBJECT_ID);
+
+        Message message = exchange.getIn();
+
+        String destinationFolderId = message.getHeader(CamelCMISConstants.CMIS_DESTIONATION_FOLDER_ID, String.class);
+        String toCopyFolderId = message.getHeader(CamelCMISConstants.CMIS_OBJECT_ID, String.class);
+
+        Folder destinationFolder = (Folder) getSessionFacade().getObjectById(destinationFolderId);
+        Folder toCopyFolder = (Folder) getSessionFacade().getObjectById(toCopyFolderId);
+
+        copyFolderRecursive(destinationFolder, toCopyFolder);
+    }
+
+    public void copyFolderRecursive(Folder destinationFolder, Folder toCopyFolder) {
+        Map<String, Object> folderProperties = new HashMap<String, Object>();
+        folderProperties.put(PropertyIds.NAME, toCopyFolder.getName());
+        folderProperties.put(PropertyIds.OBJECT_TYPE_ID, toCopyFolder.getBaseTypeId().value());
+        Folder newFolder = destinationFolder.createFolder(folderProperties);
+        copyChildren(newFolder, toCopyFolder);
+    }
+
+    public void copyChildren(Folder destinationFolder, Folder toCopyFolder) {","[{'comment': 'this method can be private', 'commenter': 'bedlaj'}]"
3033,components/camel-cmis/src/main/java/org/apache/camel/component/cmis/CMISProducer.java,"@@ -113,6 +118,201 @@ private CmisObject createNode(Exchange exchange) throws Exception {
         }
     }
 
+    public List<String> deleteFolder(Exchange exchange) throws Exception {
+        validateRequiredHeader(exchange, CamelCMISConstants.CMIS_OBJECT_ID);
+
+        Message message = exchange.getIn();
+
+        String objectId = message.getHeader(CamelCMISConstants.CMIS_OBJECT_ID, String.class);
+        Folder folder = (Folder) getSessionFacade().getObjectById(objectId);
+        return folder.deleteTree(true, UnfileObject.DELETE, true);
+    }
+
+    public void deleteDocument(Exchange exchange) throws Exception {
+        validateRequiredHeader(exchange, CamelCMISConstants.CMIS_OBJECT_ID);
+
+        Message message = exchange.getIn();
+
+        String objectId = message.getHeader(CamelCMISConstants.CMIS_OBJECT_ID, String.class);
+        Document document = (Document) getSessionFacade().getObjectById(objectId);
+
+        document.deleteAllVersions();
+    }
+
+    public void moveDocument(Exchange exchange) throws Exception {
+        validateRequiredHeader(exchange, CamelCMISConstants.CMIS_DESTIONATION_FOLDER_ID);
+        validateRequiredHeader(exchange, CamelCMISConstants.CMIS_SOURCE_FOLDER_ID);
+        validateRequiredHeader(exchange, CamelCMISConstants.CMIS_OBJECT_ID);
+
+        Message message = exchange.getIn();
+
+        String destinationFolderId = message.getHeader(CamelCMISConstants.CMIS_DESTIONATION_FOLDER_ID, String.class);
+        String sourceFolderId = message.getHeader(CamelCMISConstants.CMIS_SOURCE_FOLDER_ID, String.class);
+        String objectId = message.getHeader(CamelCMISConstants.CMIS_OBJECT_ID, String.class);
+
+
+        Folder sourceFolder = (Folder) getSessionFacade().getObjectById(sourceFolderId);
+        Folder targetFolder = (Folder) getSessionFacade().getObjectById(destinationFolderId);
+
+        Document document = (Document) getSessionFacade().getObjectById(objectId);
+
+        if (document != null) {
+            if (!document.getAllowableActions().getAllowableActions().contains(Action.CAN_MOVE_OBJECT)) {
+                throw new CmisUnauthorizedException(""Current user does not have permission to move "" + objectId + document.getName());
+            }
+
+            try {
+                document.move(sourceFolder, targetFolder);
+                log.info(""Moved document from "" + sourceFolder.getName() + "" to "" + targetFolder.getName());
+            } catch (CmisRuntimeException e) {
+                log.error(""Cannot move document to folder "" + targetFolder.getName() + "" : "" + e.getMessage());
+            }
+        } else {
+            log.error(""Document is null, cannot move!"");
+        }
+    }
+
+    public void moveFolder(Exchange exchange) throws Exception {
+        validateRequiredHeader(exchange, CamelCMISConstants.CMIS_DESTIONATION_FOLDER_ID);
+        validateRequiredHeader(exchange, CamelCMISConstants.CMIS_OBJECT_ID);
+
+        Message message = exchange.getIn();
+
+        String destinationFolderId = message.getHeader(CamelCMISConstants.CMIS_DESTIONATION_FOLDER_ID, String.class);
+        String objectId = message.getHeader(CamelCMISConstants.CMIS_OBJECT_ID, String.class);
+
+        Folder toBeMoved = (Folder) getSessionFacade().getObjectById(objectId);
+        Folder targetFolder = (Folder) getSessionFacade().getObjectById(destinationFolderId);
+
+        copyFolderRecursive(targetFolder, toBeMoved);
+        toBeMoved.deleteTree(true, UnfileObject.DELETE, true);
+    }
+
+    public void copyDocument(Exchange exchange) throws Exception {
+        validateRequiredHeader(exchange, CamelCMISConstants.CMIS_OBJECT_ID);
+        validateRequiredHeader(exchange, CamelCMISConstants.CMIS_DESTIONATION_FOLDER_ID);
+
+        Message message = exchange.getIn();
+
+        String destinationFolderId = message.getHeader(CamelCMISConstants.CMIS_DESTIONATION_FOLDER_ID, String.class);
+        String objectId = message.getHeader(CamelCMISConstants.CMIS_OBJECT_ID, String.class);
+        Folder destinationFolder = (Folder) getSessionFacade().getObjectById(destinationFolderId);
+
+        Document document = (Document) getSessionFacade().getObjectById(objectId);
+
+        document.copy(destinationFolder);
+    }
+
+    public void copyFolder(Exchange exchange) throws Exception {
+        validateRequiredHeader(exchange, CamelCMISConstants.CMIS_DESTIONATION_FOLDER_ID);
+        validateRequiredHeader(exchange, CamelCMISConstants.CMIS_OBJECT_ID);
+
+        Message message = exchange.getIn();
+
+        String destinationFolderId = message.getHeader(CamelCMISConstants.CMIS_DESTIONATION_FOLDER_ID, String.class);
+        String toCopyFolderId = message.getHeader(CamelCMISConstants.CMIS_OBJECT_ID, String.class);
+
+        Folder destinationFolder = (Folder) getSessionFacade().getObjectById(destinationFolderId);
+        Folder toCopyFolder = (Folder) getSessionFacade().getObjectById(toCopyFolderId);
+
+        copyFolderRecursive(destinationFolder, toCopyFolder);
+    }
+
+    public void copyFolderRecursive(Folder destinationFolder, Folder toCopyFolder) {","[{'comment': 'this method can be private', 'commenter': 'bedlaj'}]"
3033,components/camel-cmis/src/main/java/org/apache/camel/component/cmis/CMISProducer.java,"@@ -113,6 +118,201 @@ private CmisObject createNode(Exchange exchange) throws Exception {
         }
     }
 
+    public List<String> deleteFolder(Exchange exchange) throws Exception {
+        validateRequiredHeader(exchange, CamelCMISConstants.CMIS_OBJECT_ID);
+
+        Message message = exchange.getIn();
+
+        String objectId = message.getHeader(CamelCMISConstants.CMIS_OBJECT_ID, String.class);
+        Folder folder = (Folder) getSessionFacade().getObjectById(objectId);
+        return folder.deleteTree(true, UnfileObject.DELETE, true);
+    }
+
+    public void deleteDocument(Exchange exchange) throws Exception {
+        validateRequiredHeader(exchange, CamelCMISConstants.CMIS_OBJECT_ID);
+
+        Message message = exchange.getIn();
+
+        String objectId = message.getHeader(CamelCMISConstants.CMIS_OBJECT_ID, String.class);
+        Document document = (Document) getSessionFacade().getObjectById(objectId);
+
+        document.deleteAllVersions();
+    }
+
+    public void moveDocument(Exchange exchange) throws Exception {
+        validateRequiredHeader(exchange, CamelCMISConstants.CMIS_DESTIONATION_FOLDER_ID);
+        validateRequiredHeader(exchange, CamelCMISConstants.CMIS_SOURCE_FOLDER_ID);
+        validateRequiredHeader(exchange, CamelCMISConstants.CMIS_OBJECT_ID);
+
+        Message message = exchange.getIn();
+
+        String destinationFolderId = message.getHeader(CamelCMISConstants.CMIS_DESTIONATION_FOLDER_ID, String.class);
+        String sourceFolderId = message.getHeader(CamelCMISConstants.CMIS_SOURCE_FOLDER_ID, String.class);
+        String objectId = message.getHeader(CamelCMISConstants.CMIS_OBJECT_ID, String.class);
+
+
+        Folder sourceFolder = (Folder) getSessionFacade().getObjectById(sourceFolderId);
+        Folder targetFolder = (Folder) getSessionFacade().getObjectById(destinationFolderId);
+
+        Document document = (Document) getSessionFacade().getObjectById(objectId);
+
+        if (document != null) {
+            if (!document.getAllowableActions().getAllowableActions().contains(Action.CAN_MOVE_OBJECT)) {
+                throw new CmisUnauthorizedException(""Current user does not have permission to move "" + objectId + document.getName());
+            }
+
+            try {
+                document.move(sourceFolder, targetFolder);
+                log.info(""Moved document from "" + sourceFolder.getName() + "" to "" + targetFolder.getName());
+            } catch (CmisRuntimeException e) {
+                log.error(""Cannot move document to folder "" + targetFolder.getName() + "" : "" + e.getMessage());","[{'comment': 'Is logging enough? I would expect exception to propagate. If it is intended, please change that log to `log.error(""xxx"", e)`. This way you loose stacktrace, which can be important for troubleshooting ', 'commenter': 'bedlaj'}]"
3033,components/camel-cmis/src/main/java/org/apache/camel/component/cmis/CMISProducer.java,"@@ -29,11 +31,14 @@
 import org.apache.camel.support.DefaultProducer;
 import org.apache.camel.support.ExchangeHelper;
 import org.apache.camel.support.MessageHelper;
+import org.apache.camel.util.ObjectHelper;","[{'comment': 'The correct one with `invokeMethod` is `org.apache.camel.support.ObjectHelper`', 'commenter': 'bedlaj'}]"
3037,components/camel-netty4-http/src/main/java/org/apache/camel/component/netty4/http/ChunkedHttpRequest.java,"@@ -0,0 +1,75 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.netty4.http;
+
+import io.netty.buffer.ByteBufAllocator;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.handler.codec.http.DefaultHttpRequest;
+import io.netty.handler.codec.http.HttpChunkedInput;
+import io.netty.handler.codec.http.HttpContent;
+import io.netty.handler.stream.ChunkedInput;
+import io.netty.handler.stream.ChunkedStream;
+
+import java.io.InputStream;
+
+/**
+ * @author <a href=""mailto:zfeng@redhat.com"">Zheng Feng</a>
+ */","[{'comment': 'Please remove author', 'commenter': 'oscerd'}]"
3037,components/camel-netty4-http/src/main/java/org/apache/camel/component/netty4/http/ChunkedHttpResponse.java,"@@ -0,0 +1,75 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.camel.component.netty4.http;
+
+import io.netty.buffer.ByteBufAllocator;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.handler.codec.http.DefaultHttpResponse;
+import io.netty.handler.codec.http.HttpChunkedInput;
+import io.netty.handler.codec.http.HttpContent;
+import io.netty.handler.stream.ChunkedInput;
+import io.netty.handler.stream.ChunkedStream;
+
+import java.io.InputStream;
+
+/**
+ * @author <a href=""mailto:zfeng@redhat.com"">Zheng Feng</a>","[{'comment': 'Please remove author', 'commenter': 'oscerd'}]"
3037,components/camel-netty4-http/src/main/java/org/apache/camel/component/netty4/http/CustomChunkedWriteHandler.java,"@@ -0,0 +1,37 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.netty4.http;
+
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.ChannelPromise;
+import io.netty.handler.stream.ChunkedWriteHandler;
+
+/**
+ * @author <a href=""mailto:zfeng@redhat.com"">Zheng Feng</a>","[{'comment': 'Please remove author', 'commenter': 'oscerd'}]"
3048,components/camel-mongodb3/src/main/java/org/apache/camel/component/mongodb3/MongoDbComponent.java,"@@ -47,14 +53,32 @@ public MongoDbComponent(CamelContext context) {
     }
 
     protected Endpoint createEndpoint(String uri, String remaining, Map<String, Object> parameters) throws Exception {
-
         MongoDbEndpoint endpoint = new MongoDbEndpoint(uri, this);
         endpoint.setConnectionBean(remaining);
+        endpoint.setMongoConnection(mongoConnection);
         setProperties(endpoint, parameters);
 
         return endpoint;
     }
 
+    /**
+     * Get the client used for connection
+     *
+     * @return the client using for connection to db
+     */
+    public MongoClient getMongoConnection() {
+        return mongoConnection;
+    }
+
+    /**
+     * Set the client used for connection","[{'comment': 'Can this javadoc be updated to tell that this is for using a shared mongo client for all the endpoints.', 'commenter': 'davsclaus'}]"
3048,components/camel-mongodb3/src/main/java/org/apache/camel/component/mongodb3/MongoDbComponent.java,"@@ -47,14 +53,32 @@ public MongoDbComponent(CamelContext context) {
     }
 
     protected Endpoint createEndpoint(String uri, String remaining, Map<String, Object> parameters) throws Exception {
-
         MongoDbEndpoint endpoint = new MongoDbEndpoint(uri, this);
         endpoint.setConnectionBean(remaining);
+        endpoint.setMongoConnection(mongoConnection);
         setProperties(endpoint, parameters);
 
         return endpoint;
     }
 
+    /**
+     * Get the client used for connection
+     *
+     * @return the client using for connection to db
+     */
+    public MongoClient getMongoConnection() {
+        return mongoConnection;
+    }
+
+    /**
+     * Set the client used for connection
+     *
+     * @param mongoConnection","[{'comment': 'Remove dangling param', 'commenter': 'davsclaus'}]"
3051,components/camel-sql/src/main/java/org/apache/camel/component/sql/stored/template/generated/SSPTParser.java,"@@ -1,31 +1,11 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
 /* Generated By:JavaCC: Do not edit this line. SSPTParser.java */
 package org.apache.camel.component.sql.stored.template.generated;
 
-import org.apache.camel.component.sql.stored.template.ast.InOutParameter;
-import org.apache.camel.component.sql.stored.template.ast.InParameter;
-import org.apache.camel.component.sql.stored.template.ast.OutParameter;
-import org.apache.camel.component.sql.stored.template.ast.ParseHelper;
-import org.apache.camel.component.sql.stored.template.ast.Template;
-import org.apache.camel.spi.ClassResolver;
-
 import java.io.Reader;
 
+import org.apache.camel.spi.ClassResolver;
+import org.apache.camel.component.sql.stored.template.ast.*;
+
 public class SSPTParser implements SSPTParserConstants {","[{'comment': ""Not sure about this change (what caused it), but we seem to have lost the ASF license header and I think Checkstyle won't allow star imports. Perhaps just revert changes to this file?"", 'commenter': 'zregvart'}, {'comment': 'Hello Mr.Zoran I have no idea what caused to this, I just ran ./mvnw -Pfastinstall install.', 'commenter': 'Nayananga'}]"
3051,components/camel-sql/src/main/java/org/apache/camel/component/sql/stored/template/generated/SSPTParserConstants.java,"@@ -1,19 +1,3 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
 /* Generated By:JavaCC: Do not edit this line. SSPTParserConstants.java */
 package org.apache.camel.component.sql.stored.template.generated;","[{'comment': 'Here we lost the ASF license header, perhaps revert this change?', 'commenter': 'zregvart'}, {'comment': ""Hello Mr.Zoran I have no idea what caused to this, I just ran ./mvnw -Pfastinstall install. I'll do a revert"", 'commenter': 'Nayananga'}, {'comment': 'Hello, Mr.Zoran I reverted that whole commit, can you check now?\r\n', 'commenter': 'Nayananga'}]"
3051,components/camel-sql/src/main/java/org/apache/camel/component/sql/stored/template/generated/SSPTParserTokenManager.java,"@@ -1,19 +1,3 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
 /* Generated By:JavaCC: Do not edit this line. SSPTParserTokenManager.java */
 package org.apache.camel.component.sql.stored.template.generated;","[{'comment': 'Here we lost the ASF license header, perhaps revert this change?', 'commenter': 'zregvart'}]"
3058,components/camel-bean/src/main/docs/bean-language.adoc,"@@ -20,7 +20,7 @@ methods.
 The xref:manual::bean-binding.adoc[Bean Binding] rules are used to bind the
 xref:manual::message.adoc[Message] Exchange to the method parameters; so you can
 annotate the bean to extract headers or other expressions such as
-xref:components::xpath-language.adoc[XPath] or xref:components::xquery-language.adoc[XQuery] from the message.
+xref:xpath-language.adoc[XPath] or xref:xquery-language.adoc[XQuery] from the message.","[{'comment': ""I don't think these are correct, both of these are in the `components` module. Try:\r\n\r\n```shell\r\n$ find . -name xpath-language.adoc -o -name xquery-language.adoc\r\n./docs/components/modules/ROOT/pages/xquery-language.adoc\r\n./docs/components/modules/ROOT/pages/xpath-language.adoc\r\n./components/camel-saxon/src/main/docs/xquery-language.adoc\r\n./components/camel-xpath/src/main/docs/xpath-language.adoc\r\n./catalog/camel-catalog/target/classes/org/apache/camel/catalog/docs/xquery-language.adoc\r\n./catalog/camel-catalog/target/classes/org/apache/camel/catalog/docs/xpath-language.adoc\r\n```"", 'commenter': 'zregvart'}, {'comment': 'These languages come from components so best not change this.', 'commenter': 'zregvart'}, {'comment': ""Hello Mr.Zoran, I think since bean-language.adoc try to cross-reference xpath-language .adoc and xquery-language.adoc which are in the same module(components) they do not require to specify which module they belong to.\r\nSo once I change this and ran link check it didn't report any errors as well, \r\nmay I undo this?\r\n"", 'commenter': 'Nayananga'}, {'comment': 'I think, when I was fixing those errors they were there, but when I try to push my changes to the camel It showed me conflictions, I accept some of the incomming changes and some of the current changes which I thought the best approach. Then after I saw that Mr.Zoran has pushed fixes just 1  hour before.\r\nMay I revert this commit?', 'commenter': 'Nayananga'}, {'comment': 'Yup, please do.', 'commenter': 'zregvart'}, {'comment': 'Yup, please do.', 'commenter': 'zregvart'}, {'comment': 'Hello Mr.Zoran, can you check now?', 'commenter': 'Nayananga'}]"
3060,components/camel-aws-sns/src/main/java/org/apache/camel/component/aws/sns/SnsProducer.java,"@@ -104,6 +106,13 @@ private String determineMessageStructure(Exchange exchange) {
                     mav.setDataType(""String"");
                     mav.withStringValue(value.toString());
                     result.put(entry.getKey(), mav);
+                } else if (value instanceof List && ((List) value).size()>0) {
+                    // Avoiding reliance on .toString()
+                    String delimiter = ""\"", \"""", prefix = ""[\"""", suffix = ""\""]"";
+                    MessageAttributeValue mav = new MessageAttributeValue();
+                    mav.setDataType(""String.Array"");
+                    mav.withStringValue((String) ((List)value).stream().map(Object::toString).collect(Collectors.joining(delimiter, prefix, suffix)));","[{'comment': 'If you cast `value` to `List<?>` instead of raw List, the compiler warning will disapear and you will not need that cast to String ', 'commenter': 'bedlaj'}, {'comment': '+1', 'commenter': 'oscerd'}, {'comment': 'Done', 'commenter': 'sshivampp'}]"
3060,components/camel-aws-sns/src/main/java/org/apache/camel/component/aws/sns/SnsProducer.java,"@@ -104,6 +106,13 @@ private String determineMessageStructure(Exchange exchange) {
                     mav.setDataType(""String"");
                     mav.withStringValue(value.toString());
                     result.put(entry.getKey(), mav);
+                } else if (value instanceof List && ((List) value).size()>0) {
+                    // Avoiding reliance on .toString()
+                    String delimiter = ""\"", \"""", prefix = ""[\"""", suffix = ""\""]"";","[{'comment': 'This can be on multiple lines, for clarity', 'commenter': 'oscerd'}, {'comment': 'done', 'commenter': 'sshivampp'}]"
3060,components/camel-aws-sns/src/main/java/org/apache/camel/component/aws/sns/SnsProducer.java,"@@ -17,10 +17,7 @@
 package org.apache.camel.component.aws.sns;
 
 import java.nio.ByteBuffer;
-import java.util.Date;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
+import java.util.*;","[{'comment': 'Please avoid * imports.', 'commenter': 'oscerd'}, {'comment': 'My intellij is on default setting and trying to be smart here :D. Do I need to change ?', 'commenter': 'sshivampp'}, {'comment': 'If you run the maven install with sourcecheck profile activated that imports will be reported as invalid. So it would be better to add explicit imports', 'commenter': 'oscerd'}, {'comment': 'understood, done', 'commenter': 'sshivampp'}]"
3060,components/camel-aws-sns/src/main/java/org/apache/camel/component/aws/sns/SnsProducer.java,"@@ -104,6 +107,26 @@ private String determineMessageStructure(Exchange exchange) {
                     mav.setDataType(""String"");
                     mav.withStringValue(value.toString());
                     result.put(entry.getKey(), mav);
+                } else if (value instanceof List) {
+                    List<?> valueList = ((List<?>) value).stream().filter(Objects::nonNull).collect(Collectors.toList());","[{'comment': 'With null check I meant to support `null` keyword, not excluding null values. null is according to documentation of `String.Array` valid value. Eg for list `Arrays.asList(null, ""element1"", ""element2"", null)` the result should be `[null, ""element1"", ""element2"", null]`.\r\n\r\nI think this can be replaced with something like this:\r\n\r\n```\r\nString result = ((List<?>)values).stream()\r\n    .map(o -> o instanceof String ? String.format(""\\""%s\\"""", o) : Objects.toString(o)) // null instanceof String is false and Objects.toString(null) returns String null - this is what we want\r\n    .collect(Collectors.joining("", ""));`\r\n\r\nMessageAttributeValue mav = new MessageAttributeValue();\r\nmav.setDataType(""String.Array"");\r\nmav.withStringValue(""["" + result + ""]"");\r\nresult.put(entry.getKey(), mav);\r\n```\r\n', 'commenter': 'bedlaj'}, {'comment': 'But aws doc says otherwise.\r\n\r\n""Name, type, and value must not be empty or null.""\r\n\r\nhttps://docs.aws.amazon.com/sns/latest/dg/sns-message-attributes.html', 'commenter': 'sshivampp'}, {'comment': 'But the value will not be empty, the value will be `[null, ""element1"", ""element2"", null]`. I am looking into same documentation and it says: \r\n\r\n> String.Array – An array, formatted as a string, that can contain multiple values. The values can be strings, numbers, or the keywords true, false, and **null**.', 'commenter': 'bedlaj'}, {'comment': 'Oh, I missed that. Will make null a valid value then. \r\nDone\r\n', 'commenter': 'sshivampp'}]"
3063,components/camel-consul/src/test/java/org/apache/camel/component/consul/ConsulRegistryTest.java,"@@ -49,19 +55,26 @@ public String hello(String name) {
         }
     }
 
+   
     @BeforeClass
     public static void setUp() {
-        container = ConsulTestSupport.consulContainer();
-        container.start();
+        if (DockerMachineClient.instance().isInstalled())  {","[{'comment': '@ramu11 , can we move this check to the camel-testcontainers level to prevent using this logic in each component?', 'commenter': 'dmvolod'}, {'comment': ""What happen if I don't have docker-machine installed on my machine? I don't have docker-machine on Linux. I think we are in the same situation."", 'commenter': 'oscerd'}, {'comment': '+1', 'commenter': 'oscerd'}, {'comment': 'I have tested this by removing docker machine(do not have docker at all) .it is skipping tests', 'commenter': 'ramu11'}, {'comment': ""This class is not extending 'camel-testcontainers' test class"", 'commenter': 'ramu11'}, {'comment': ' This class do not extends camel-testcontainers test class. And the class has both @BeforeClass and @AfterClass methods where the solution do not work. I already tested the scenario', 'commenter': 'ramu11'}, {'comment': '@ramu11 , in this case, may be create a super abstract class for this in camel-testcontainers?', 'commenter': 'dmvolod'}]"
3071,core/camel-support/src/main/java/org/apache/camel/support/builder/TokenXMLExpressionIterator.java,"@@ -239,7 +239,31 @@ String getNext(boolean first) {
             
             return next;
         }
-
+        
+        private String getMissingInherritNamespaces(final String text) {
+            if (text == null) {
+                return """";
+            }
+            final String namespaces = getNamespacesFromNamespaceToken(text);
+            final String[] containedNamespaces = namespaces == null ? new String[0] : namespaces.split("" "");
+            final StringBuilder sb = new StringBuilder();","[{'comment': 'You can use CollectionStringBuilder from Camel to add a bunch of stuff together with a separator and it deals with the ""first"" issue etc.', 'commenter': 'davsclaus'}, {'comment': 'The CollectionStringBuilder wont work here because if already a part of multiple childnamespaces are available it is required to add a separator even it is the first match. \r\n\r\ne.g. Input\r\n```\r\n<orders xmlns=""http:acme.com"" xmlns:foo=""http:foo.com"">\r\n  <order id=""1"" xmlns=""http:acme.com"">Camel in Action</order>\r\n</orders>\r\n```\r\n\r\nwill be with CollectionStringBuffer without separation\r\n```\r\n  <order id=""1"" xmlns=""http:acme.com""xmlns:foo=""http:foo.com"">Camel in Action</order>\r\n```\r\nbut should be with a additional separator\r\n```\r\n  <order id=""1"" xmlns=""http:acme.com""xmlns:foo=""http:foo.com"">Camel in Action</order>\r\n```\r\n\r\n', 'commenter': 'drmaniac'}]"
3071,core/camel-support/src/main/java/org/apache/camel/support/builder/TokenXMLExpressionIterator.java,"@@ -203,7 +203,8 @@ void init() {
         String getNext(boolean first) {
             // initialize inherited namespaces on first
             if (first && inheritNamespaceToken != null && !wrapToken) {
-                rootTokenNamespaces =  getNamespacesFromNamespaceToken(scanner.findWithinHorizon(inheritNamespaceTokenPattern, 0));
+            	String rootTokenNamespacesString = getNamespacesFromNamespaceToken(scanner.findWithinHorizon(inheritNamespaceTokenPattern, 0));
+                rootTokenNamespaces =  rootTokenNamespacesString == null ? null : rootTokenNamespacesString.split("" "");","[{'comment': 'Remove double space', 'commenter': 'davsclaus'}]"
3071,core/camel-support/src/main/java/org/apache/camel/support/builder/TokenXMLExpressionIterator.java,"@@ -239,7 +239,31 @@ String getNext(boolean first) {
             
             return next;
         }
-
+        
+        private String getMissingInherritNamespaces(final String text) {
+            if (text == null) {
+                return """";
+            }
+            final String namespaces = getNamespacesFromNamespaceToken(text);
+            final String[] containedNamespaces = namespaces == null ? new String[0] : namespaces.split("" "");
+            final StringBuilder sb = new StringBuilder();
+            boolean first = true;
+            for (String rn : rootTokenNamespaces) {
+                boolean nsExists = false;
+                for (String cn : containedNamespaces) {
+                    if (rn.equals(cn)) {
+                        nsExists = true;
+                        first = false;
+                        break;
+                    }
+                }
+                if (!nsExists) {
+                    sb.append(first ? rn : "" "" + rn);
+                    first = false;
+                }
+            }
+            return sb.toString();
+        }","[{'comment': 'Add empty line before next method', 'commenter': 'davsclaus'}]"
3071,core/camel-core/src/test/java/org/apache/camel/language/TokenXMLPairNamespaceSplitTest.java,"@@ -66,7 +66,7 @@ public void testTokenXMLPair2() throws Exception {
     protected String createBody() {
         StringBuilder sb = new StringBuilder(""<?xml version=\""1.0\""?>\n"");
         sb.append(""<orders xmlns=\""http:acme.com\"">\n"");
-        sb.append(""  <order id=\""1\"">Camel in Action</order>\n"");
+        sb.append(""  <order id=\""1\"" xmlns=\""http:acme.com\"">Camel in Action</order>\n"");","[{'comment': 'It would be better to duplicate the test and keep the original as-is and then in the new test check for inherited root namespace so we test both conditions', 'commenter': 'davsclaus'}]"
3073,components/camel-undertow/src/main/java/org/apache/camel/component/undertow/UndertowConsumer.java,"@@ -198,14 +200,18 @@ private void sendResponse(HttpServerExchange httpExchange, Exchange camelExchang
      * {@code connectionKey}.
      *
      * @param connectionKey an identifier of {@link WebSocketChannel} through which the {@code message} was received
+     * @param channel the {@link WebSocketChannel} through which the {@code message} was received
      * @param message the message received via the {@link WebSocketChannel}
      */
-    public void sendMessage(final String connectionKey, final Object message) {
+    public void sendMessage(final String connectionKey, WebSocketChannel channel, final Object message) {
 
         final Exchange exchange = getEndpoint().createExchange();
 
         // set header and body
         exchange.getIn().setHeader(UndertowConstants.CONNECTION_KEY, connectionKey);
+        if(channel != null) {","[{'comment': 'Please run with the sourcecheck profile enabled and fix the code style.', 'commenter': 'oscerd'}, {'comment': 'done', 'commenter': 'nhoughto'}]"
3073,components/camel-undertow/src/main/java/org/apache/camel/component/undertow/UndertowConsumer.java,"@@ -223,16 +229,23 @@ public void done(boolean doneSync) {
      * Send a notification related a WebSocket peer.
      *
      * @param connectionKey of WebSocket peer
+     * @param transportExchange the exchange for the websocket transport, only available for ON_OPEN events
+     * @param channel the {@link WebSocketChannel} through which the {@code message} was received
      * @param eventType the type of the event
      */
-    public void sendEventNotification(String connectionKey, EventType eventType) {
+    public void sendEventNotification(String connectionKey, WebSocketHttpExchange transportExchange, WebSocketChannel channel, EventType eventType) {
         final Exchange exchange = getEndpoint().createExchange();
 
         final Message in = exchange.getIn();
         in.setHeader(UndertowConstants.CONNECTION_KEY, connectionKey);
         in.setHeader(UndertowConstants.EVENT_TYPE, eventType.getCode());
         in.setHeader(UndertowConstants.EVENT_TYPE_ENUM, eventType);
-
+        if(channel != null){","[{'comment': 'ditto', 'commenter': 'oscerd'}, {'comment': 'done', 'commenter': 'nhoughto'}]"
3073,components/camel-undertow/src/main/java/org/apache/camel/component/undertow/UndertowConsumer.java,"@@ -223,16 +229,23 @@ public void done(boolean doneSync) {
      * Send a notification related a WebSocket peer.
      *
      * @param connectionKey of WebSocket peer
+     * @param transportExchange the exchange for the websocket transport, only available for ON_OPEN events
+     * @param channel the {@link WebSocketChannel} through which the {@code message} was received
      * @param eventType the type of the event
      */
-    public void sendEventNotification(String connectionKey, EventType eventType) {
+    public void sendEventNotification(String connectionKey, WebSocketHttpExchange transportExchange, WebSocketChannel channel, EventType eventType) {
         final Exchange exchange = getEndpoint().createExchange();
 
         final Message in = exchange.getIn();
         in.setHeader(UndertowConstants.CONNECTION_KEY, connectionKey);
         in.setHeader(UndertowConstants.EVENT_TYPE, eventType.getCode());
         in.setHeader(UndertowConstants.EVENT_TYPE_ENUM, eventType);
-
+        if(channel != null){
+            in.setHeader(UndertowConstants.CHANNEL, channel);
+        }
+        if(transportExchange != null){","[{'comment': 'ditto', 'commenter': 'oscerd'}, {'comment': 'done', 'commenter': 'nhoughto'}]"
3076,components/camel-jms/src/main/java/org/apache/camel/component/jms/JmsConfiguration.java,"@@ -479,7 +479,10 @@
 
     @UriParam(label = ""producer"", description = ""Sets whether JMS date properties should be formatted according to the ISO 8601 standard."")
     private boolean formatDateHeadersToIso8601;
-
+    
+    @UriParam(label = ""deliveryDelay"", description = ""set delivey delay for jms"")","[{'comment': 'The label should be ""producer"". \r\n\r\nAtribute description is used for generating documentation - please fix typos and format it as sentence with uppercase S and dot in the end. It would be also nice to be a bit more detailed with some words mentioning, that this feature requires JMS 2.0.\r\n\r\nPlease add `defaultValue = ""-1""` into UriParam annotation', 'commenter': 'bedlaj'}, {'comment': 'In current latest commit is still wrong label - it should be ""producer"" instead of ""deliveryDelay"". \r\n\r\nDescription should contain JMS 2.0 warning. I suggest this: ""This option requires JMS 2.0 compliant broker.""', 'commenter': 'bedlaj'}, {'comment': 'ok. can you check it?', 'commenter': 'MKdir98'}]"
3076,components/camel-jms/src/main/java/org/apache/camel/component/jms/JmsConfiguration.java,"@@ -2156,4 +2163,12 @@ public void setFormatDateHeadersToIso8601(boolean formatDateHeadersToIso8601) {
         this.formatDateHeadersToIso8601 = formatDateHeadersToIso8601;
     }
 
+    public long getDeliveryDelay() {
+        return deliveryDelay;
+    }
+
+    public void setDeliveryDelay(long deliveryDelay) {","[{'comment': 'Please add javadoc - It can be the same as description in UriParam annotation', 'commenter': 'bedlaj'}]"
3076,components/camel-jms/src/main/java/org/apache/camel/component/jms/JmsConfiguration.java,"@@ -479,7 +479,10 @@
 
     @UriParam(label = ""producer"", description = ""Sets whether JMS date properties should be formatted according to the ISO 8601 standard."")
     private boolean formatDateHeadersToIso8601;
-
+    ","[{'comment': 'Please remove these whitespaces', 'commenter': 'bedlaj'}]"
3076,components/camel-jms/src/main/java/org/apache/camel/component/jms/JmsConfiguration.java,"@@ -649,6 +652,7 @@ public JmsOperations createInOutTemplate(JmsEndpoint endpoint, boolean pubSubDom
                 // default to AUTO
                 jmsTemplate.setSessionAcknowledgeMode(Session.AUTO_ACKNOWLEDGE);
             }
+            jmsTemplate.setDeliveryDelay(deliveryDelay);","[{'comment': 'It does not make sense to set it here again for InOut. This method calls `createInOnlyTemplate` as first statement which returns JmsTemplate with already set delay. This can be removed.', 'commenter': 'bedlaj'}]"
3080,components/camel-salesforce/camel-salesforce-component/src/test/java/org/apache/camel/component/salesforce/CompositeApiBatchIntegrationTest.java,"@@ -43,6 +34,10 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized.Parameters;
 
+import java.io.IOException;
+import java.util.*;","[{'comment': ""Please don't use * imports."", 'commenter': 'oscerd'}]"
3080,components/camel-salesforce/camel-salesforce-component/src/test/java/org/apache/camel/component/salesforce/CompositeApiBatchIntegrationTest.java,"@@ -155,7 +155,9 @@ public void shouldSupportLimits() {
         final Map<String, String> apiRequests = (Map<String, String>) limits.get(""DailyApiRequests"");
 
         // for JSON value will be Integer, for XML (no type information) it will be String
-        assertEquals(""15000"", String.valueOf(apiRequests.get(""Max"")));
+        // This number can be different per org, and future releases,
+        // so let's just make sure it's greater than zero
+        assert(Integer.valueOf(String.valueOf(apiRequests.get(""Max""))) > 0);","[{'comment': 'Please do not use Java **assert** keyword. Java Assertions are disabled by default in maven-surefire. I am pretty sure that your test will pass even with `assert(false)`. Use JUnit method assertTrue instead.', 'commenter': 'bedlaj'}, {'comment': 'ok', 'commenter': 'jeremyross'}]"
3084,components/camel-test-junit5/pom.xml,"@@ -0,0 +1,73 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!-- Licensed to the Apache Software Foundation (ASF) under one or more contributor 
+	license agreements. See the NOTICE file distributed with this work for additional 
+	information regarding copyright ownership. The ASF licenses this file to 
+	You under the Apache License, Version 2.0 (the ""License""); you may not use 
+	this file except in compliance with the License. You may obtain a copy of 
+	the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required 
+	by applicable law or agreed to in writing, software distributed under the 
+	License is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS 
+	OF ANY KIND, either express or implied. See the License for the specific 
+	language governing permissions and limitations under the License. -->","[{'comment': 'I think this creates problem in codestyle validation', 'commenter': 'oscerd'}, {'comment': 'Checkstyle issues are fixed now.', 'commenter': 'aldettinger'}]"
3084,components/camel-test-junit5/pom.xml,"@@ -0,0 +1,73 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!-- Licensed to the Apache Software Foundation (ASF) under one or more contributor 
+	license agreements. See the NOTICE file distributed with this work for additional 
+	information regarding copyright ownership. The ASF licenses this file to 
+	You under the Apache License, Version 2.0 (the ""License""); you may not use 
+	this file except in compliance with the License. You may obtain a copy of 
+	the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required 
+	by applicable law or agreed to in writing, software distributed under the 
+	License is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS 
+	OF ANY KIND, either express or implied. See the License for the specific 
+	language governing permissions and limitations under the License. -->
+<project xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
+	xmlns=""http://maven.apache.org/POM/4.0.0""
+	xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"">
+	<modelVersion>4.0.0</modelVersion>
+
+	<parent>
+		<groupId>org.apache.camel</groupId>
+		<artifactId>components</artifactId>
+		<version>3.0.0-SNAPSHOT</version>
+	</parent>
+
+	<artifactId>camel-test-junit5</artifactId>
+	<packaging>jar</packaging>
+
+	<name>Camel :: Test :: JUnit5</name>
+	<description>Camel unit testing with JUnit 5</description>
+
+	<properties>
+		<firstVersion>3.0.0</firstVersion>
+		<label>testing,java</label>
+
+	</properties>
+
+	<dependencies>
+
+		<dependency>
+			<groupId>org.apache.camel</groupId>
+			<artifactId>camel-core</artifactId>
+		</dependency>
+		<dependency>
+			<groupId>org.apache.camel</groupId>
+			<artifactId>camel-management-impl</artifactId>
+		</dependency>
+		<dependency>
+			<groupId>org.junit.jupiter</groupId>
+			<artifactId>junit-jupiter-api</artifactId>
+			<version>5.4.2</version>
+		</dependency>
+		<dependency>
+			<groupId>org.junit.jupiter</groupId>
+			<artifactId>junit-jupiter-engine</artifactId>
+			<version>5.4.2</version>","[{'comment': 'This can be in parent pom', 'commenter': 'oscerd'}, {'comment': 'The version', 'commenter': 'oscerd'}]"
3092,components/camel-olingo4/camel-olingo4-api/src/main/java/org/apache/camel/component/olingo4/api/impl/Olingo4AppImpl.java,"@@ -40,14 +40,7 @@
 import org.apache.commons.io.IOUtils;
 import org.apache.commons.io.LineIterator;
 import org.apache.commons.lang3.StringUtils;
-import org.apache.http.Consts;
-import org.apache.http.Header;
-import org.apache.http.HttpException;
-import org.apache.http.HttpHeaders;
-import org.apache.http.HttpResponse;
-import org.apache.http.HttpResponseFactory;
-import org.apache.http.HttpVersion;
-import org.apache.http.StatusLine;
+import org.apache.http.*;","[{'comment': 'Please run build with ""sourcecheck"" profile and fix reported problems. * import will be one of reported problems', 'commenter': 'bedlaj'}, {'comment': ""I did and expected the build to abort if something is not ok. But it didn't... fixed now."", 'commenter': 'kayuma'}]"
3092,components/camel-olingo4/camel-olingo4-api/src/test/java/org/apache/camel/component/olingo4/Olingo4AppAPITest.java,"@@ -405,6 +414,70 @@ public void testBatchRequest() throws Exception {
         assertEquals(HttpStatusCode.NOT_FOUND.getStatusCode(), responseParts.get(7).getStatusCode());
     }
 
+    @Test
+    public void testUnboundActionRequest() throws Exception {
+        final TestOlingo4ResponseHandler<HttpStatusCode> responseHandler = new TestOlingo4ResponseHandler<>();
+        olingoApp.action(edm, TEST_UNBOUND_ACTION_RESETDATASOURCE, null, null, responseHandler);
+
+        final HttpStatusCode statusCode = responseHandler.await(15, TimeUnit.MINUTES);","[{'comment': 'Is there really needed await for 15 minutes? I dont feel comfortable waiting 15 minutes for test to fail.', 'commenter': 'bedlaj'}, {'comment': 'No, no reason. Just a copy & paste from batch test issue. Fixed now.', 'commenter': 'kayuma'}]"
3092,components/camel-olingo4/camel-olingo4-api/src/test/java/org/apache/camel/component/olingo4/Olingo4AppAPITest.java,"@@ -405,6 +414,70 @@ public void testBatchRequest() throws Exception {
         assertEquals(HttpStatusCode.NOT_FOUND.getStatusCode(), responseParts.get(7).getStatusCode());
     }
 
+    @Test
+    public void testUnboundActionRequest() throws Exception {
+        final TestOlingo4ResponseHandler<HttpStatusCode> responseHandler = new TestOlingo4ResponseHandler<>();
+        olingoApp.action(edm, TEST_UNBOUND_ACTION_RESETDATASOURCE, null, null, responseHandler);
+
+        final HttpStatusCode statusCode = responseHandler.await(15, TimeUnit.MINUTES);
+        assertEquals(204, statusCode.getStatusCode());
+    }
+
+    @Test
+    public void testBoundActionRequest() throws Exception {
+        final ClientEntity clientEntity = objFactory.newEntity(null);
+        clientEntity.getProperties().add(objFactory.newPrimitiveProperty(""userName"", objFactory.newPrimitiveValueBuilder().buildString(""scottketchum"")));
+        clientEntity.getProperties().add(objFactory.newPrimitiveProperty(""tripId"", objFactory.newPrimitiveValueBuilder().buildInt32(0)));
+
+        final TestOlingo4ResponseHandler<HttpStatusCode> responseHandler = new TestOlingo4ResponseHandler<>();
+        olingoApp.action(edm, TEST_BOUND_ACTION_PEOPLE_SHARETRIP, null, clientEntity, responseHandler);
+
+        final HttpStatusCode statusCode = responseHandler.await(15, TimeUnit.MINUTES);","[{'comment': 'ditto', 'commenter': 'bedlaj'}, {'comment': 'Fixed now.', 'commenter': 'kayuma'}]"
3092,components/camel-olingo4/camel-olingo4-api/src/test/java/org/apache/camel/component/olingo4/Olingo4AppAPITest.java,"@@ -405,6 +414,70 @@ public void testBatchRequest() throws Exception {
         assertEquals(HttpStatusCode.NOT_FOUND.getStatusCode(), responseParts.get(7).getStatusCode());
     }
 
+    @Test
+    public void testUnboundActionRequest() throws Exception {
+        final TestOlingo4ResponseHandler<HttpStatusCode> responseHandler = new TestOlingo4ResponseHandler<>();
+        olingoApp.action(edm, TEST_UNBOUND_ACTION_RESETDATASOURCE, null, null, responseHandler);
+
+        final HttpStatusCode statusCode = responseHandler.await(15, TimeUnit.MINUTES);
+        assertEquals(204, statusCode.getStatusCode());
+    }
+
+    @Test
+    public void testBoundActionRequest() throws Exception {
+        final ClientEntity clientEntity = objFactory.newEntity(null);
+        clientEntity.getProperties().add(objFactory.newPrimitiveProperty(""userName"", objFactory.newPrimitiveValueBuilder().buildString(""scottketchum"")));
+        clientEntity.getProperties().add(objFactory.newPrimitiveProperty(""tripId"", objFactory.newPrimitiveValueBuilder().buildInt32(0)));
+
+        final TestOlingo4ResponseHandler<HttpStatusCode> responseHandler = new TestOlingo4ResponseHandler<>();
+        olingoApp.action(edm, TEST_BOUND_ACTION_PEOPLE_SHARETRIP, null, clientEntity, responseHandler);
+
+        final HttpStatusCode statusCode = responseHandler.await(15, TimeUnit.MINUTES);
+        assertEquals(204, statusCode.getStatusCode());
+    }
+
+
+    // Unfortunately there is no action that returns a client entity. So we fake one
+    @Test
+    public void testBoundActionRequestWithClientEntityResponse() throws Exception {
+        final ODataClient odataClient = ODataClientFactory.getClient();
+        final ODataWriter odataWriter = odataClient.getWriter();
+
+        final HttpClientBuilder httpClientBuilder = HttpClientBuilder.create();
+        httpClientBuilder.addInterceptorFirst(new HttpResponseInterceptor() {
+            @Override
+            public void process(HttpResponse response, HttpContext context) throws HttpException, IOException {
+                if (response.getStatusLine().getStatusCode() == 204) {
+                    try {
+                        response.setEntity(
+                                new InputStreamEntity(
+                                        odataWriter.writeEntity(createEntity(), ContentType.JSON),
+                                        org.apache.http.entity.ContentType.parse(ContentType.JSON.toContentTypeString())));
+                        response.setStatusCode(200);
+                    } catch (ODataSerializerException e) {
+                        throw new IOException(e);
+                    }
+                }
+            }
+        });
+        final Olingo4App olingoApp = new Olingo4AppImpl(getRealServiceUrl(TEST_SERVICE_BASE_URL), httpClientBuilder);
+        olingoApp.setContentType(TEST_FORMAT_STRING);
+
+        final TestOlingo4ResponseHandler<Edm> responseHandler = new TestOlingo4ResponseHandler<>();
+        olingoApp.read(null, Constants.METADATA, null, null, responseHandler);
+        final Edm edm = responseHandler.await();
+
+        final ClientEntity clientEntity = objFactory.newEntity(null);
+        clientEntity.getProperties().add(objFactory.newPrimitiveProperty(""userName"", objFactory.newPrimitiveValueBuilder().buildString(""scottketchum"")));
+        clientEntity.getProperties().add(objFactory.newPrimitiveProperty(""tripId"", objFactory.newPrimitiveValueBuilder().buildInt32(0)));
+
+        final TestOlingo4ResponseHandler<ClientEntity> actionResponseHandler = new TestOlingo4ResponseHandler<>();
+        olingoApp.action(edm, TEST_BOUND_ACTION_PEOPLE_SHARETRIP, null, clientEntity, actionResponseHandler);
+
+        final ClientEntity result = actionResponseHandler.await(15, TimeUnit.MINUTES);","[{'comment': 'ditto', 'commenter': 'bedlaj'}, {'comment': 'Fixed now.', 'commenter': 'kayuma'}]"
3092,components/camel-olingo4/camel-olingo4-api/src/main/java/org/apache/camel/component/olingo4/api/impl/Olingo4AppImpl.java,"@@ -511,6 +519,19 @@ private AbstractHttpEntity writeContent(final Edm edm, final UriInfo uriInfo, fi
             List<UriResource> listResource = uriInfo.getUriResourceParts();
             UriResourceKind lastResourceKind = listResource.get(listResource.size() - 1).getKind();
             switch (lastResourceKind) {
+            case action:","[{'comment': '@kayuma looks like the code for action and entitySet are the same, may be use common code for both?', 'commenter': 'dmvolod'}, {'comment': 'Done', 'commenter': 'kayuma'}]"
3092,components/camel-olingo4/camel-olingo4-api/src/test/java/org/apache/camel/component/olingo4/Olingo4AppAPITest.java,"@@ -405,6 +414,70 @@ public void testBatchRequest() throws Exception {
         assertEquals(HttpStatusCode.NOT_FOUND.getStatusCode(), responseParts.get(7).getStatusCode());
     }
 
+    @Test
+    public void testUnboundActionRequest() throws Exception {
+        final TestOlingo4ResponseHandler<HttpStatusCode> responseHandler = new TestOlingo4ResponseHandler<>();
+        olingoApp.action(edm, TEST_UNBOUND_ACTION_RESETDATASOURCE, null, null, responseHandler);
+
+        final HttpStatusCode statusCode = responseHandler.await();
+        assertEquals(204, statusCode.getStatusCode());
+    }
+
+    @Test
+    public void testBoundActionRequest() throws Exception {
+        final ClientEntity clientEntity = objFactory.newEntity(null);
+        clientEntity.getProperties().add(objFactory.newPrimitiveProperty(""userName"", objFactory.newPrimitiveValueBuilder().buildString(""scottketchum"")));
+        clientEntity.getProperties().add(objFactory.newPrimitiveProperty(""tripId"", objFactory.newPrimitiveValueBuilder().buildInt32(0)));
+
+        final TestOlingo4ResponseHandler<HttpStatusCode> responseHandler = new TestOlingo4ResponseHandler<>();
+        olingoApp.action(edm, TEST_BOUND_ACTION_PEOPLE_SHARETRIP, null, clientEntity, responseHandler);
+
+        final HttpStatusCode statusCode = responseHandler.await();
+        assertEquals(204, statusCode.getStatusCode());
+    }
+
+
+    // Unfortunately there is no action that returns a client entity. So we fake one
+    @Test
+    public void testBoundActionRequestWithClientEntityResponse() throws Exception {
+        final ODataClient odataClient = ODataClientFactory.getClient();
+        final ODataWriter odataWriter = odataClient.getWriter();
+
+        final HttpClientBuilder httpClientBuilder = HttpClientBuilder.create();
+        httpClientBuilder.addInterceptorFirst(new HttpResponseInterceptor() {
+            @Override
+            public void process(HttpResponse response, HttpContext context) throws HttpException, IOException {
+                if (response.getStatusLine().getStatusCode() == 204) {
+                    try {
+                        response.setEntity(
+                                new InputStreamEntity(
+                                        odataWriter.writeEntity(createEntity(), ContentType.JSON),
+                                        org.apache.http.entity.ContentType.parse(ContentType.JSON.toContentTypeString())));
+                        response.setStatusCode(200);","[{'comment': 'It would be nice to change values to the HttpStatusCode... constants for better understanding ', 'commenter': 'dmvolod'}, {'comment': 'Done', 'commenter': 'kayuma'}]"
3093,components/camel-xj/pom.xml,"@@ -0,0 +1,68 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--
+  ~ Licensed to the Apache Software Foundation (ASF) under one or more
+  ~ contributor license agreements.  See the NOTICE file distributed with
+  ~ this work for additional information regarding copyright ownership.
+  ~ The ASF licenses this file to You under the Apache License, Version 2.0
+  ~ (the ""License""); you may not use this file except in compliance with
+  ~ the License.  You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an ""AS IS"" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  -->
+<project xmlns=""http://maven.apache.org/POM/4.0.0""
+         xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
+         xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"">
+    <modelVersion>4.0.0</modelVersion>
+
+    <parent>
+        <groupId>org.apache.camel</groupId>
+        <artifactId>components</artifactId>
+        <version>3.0.0-SNAPSHOT</version>
+    </parent>
+
+    <artifactId>camel-xj</artifactId>
+    <packaging>jar</packaging>
+
+    <name>Camel :: XJ</name>
+    <description>Camel XJ component</description>
+
+    <dependencies>
+        <dependency>
+            <groupId>org.apache.camel</groupId>
+            <artifactId>camel-xslt</artifactId>
+        </dependency>
+        <dependency>
+            <groupId>com.fasterxml.jackson.core</groupId>
+            <artifactId>jackson-databind</artifactId>
+        </dependency>
+
+        <dependency>
+            <groupId>org.apache.camel</groupId>
+            <artifactId>camel-test</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>commons-io</groupId>
+            <artifactId>commons-io</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.skyscreamer</groupId>
+            <artifactId>jsonassert</artifactId>
+            <version>1.5.0</version>","[{'comment': 'Please move versions inside parent/pom.xml', 'commenter': 'dmvolod'}, {'comment': 'done.', 'commenter': 'kayuma'}]"
3093,components/camel-xj/src/main/java/org/apache/camel/component/xj/JsonXmlStreamReader.java,"@@ -0,0 +1,605 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.camel.component.xj;
+
+import com.fasterxml.jackson.core.JsonParser;
+import com.fasterxml.jackson.core.JsonToken;
+
+import javax.xml.namespace.NamespaceContext;
+import javax.xml.namespace.QName;
+import javax.xml.stream.Location;
+import javax.xml.stream.XMLStreamException;
+import javax.xml.stream.XMLStreamReader;
+import javax.xml.stream.events.XMLEvent;
+import java.io.IOException;
+import java.util.*;
+import java.util.stream.Collectors;
+
+/**
+ * XML Json bridge. Explicitly using XMLStreamReader and not XMLEventReader because saxon wants that.
+ */
+public class JsonXmlStreamReader implements XMLStreamReader {
+
+    private static final Location LOCATION = new Location() {
+        @Override
+        public int getLineNumber() {
+            return -1;
+        }
+
+        @Override
+        public int getColumnNumber() {
+            return -1;
+        }
+
+        @Override
+        public int getCharacterOffset() {
+            return -1;
+        }
+
+        @Override
+        public String getPublicId() {
+            return null;
+        }
+
+        @Override
+        public String getSystemId() {
+            return null;
+        }
+    };
+
+    private final JsonParser jsonParser;
+
+    private Deque<StackElement> tokenStack = new ArrayDeque<>();
+    private boolean eof = false;
+
+    public JsonXmlStreamReader(JsonParser jsonParser) {
+        this.jsonParser = jsonParser;
+    }
+
+    @Override
+    public Object getProperty(String name) throws IllegalArgumentException {
+        return null;
+    }
+
+    @Override
+    public int next() throws XMLStreamException {
+        try {
+            final StackElement previousElement = tokenStack.peek();
+            if (previousElement != null) {
+                switch (previousElement.jsonToken) {
+                    case VALUE_STRING:
+                    case VALUE_NUMBER_INT:
+                    case VALUE_NUMBER_FLOAT:
+                    case VALUE_NULL:
+                    case VALUE_TRUE:
+                    case VALUE_FALSE: {
+                        switch (previousElement.xmlEvent) {
+                            case XMLEvent.START_ELEMENT:
+                                previousElement.xmlEvent = XMLEvent.CHARACTERS;
+                                return XMLEvent.CHARACTERS;
+
+                            case XMLEvent.CHARACTERS:
+                                removeStackElement(previousElement.jsonToken);
+                                removeStackElement(JsonToken.FIELD_NAME);
+
+                                tokenStack.peek().xmlEvent = XMLEvent.END_ELEMENT;
+                                return XMLEvent.END_ELEMENT;
+
+                            default:
+                                throw new IllegalStateException(""illegal state"");
+                        }
+                    }
+                }
+            }
+
+            if (eof) {
+                return END_DOCUMENT;
+            }
+
+            JsonToken currentToken = jsonParser.nextToken();
+            if (currentToken == null) {
+                throw new IllegalStateException(""End of document"");
+            }
+
+            StackElement stackElement = new StackElement(currentToken, toXmlString(jsonParser.getCurrentName()));
+            tokenStack.push(stackElement);
+
+            if (currentToken == JsonToken.FIELD_NAME) {
+                currentToken = jsonParser.nextToken();
+
+                stackElement = new StackElement(currentToken, toXmlString(jsonParser.getCurrentName()));
+                tokenStack.push(stackElement);
+            }
+
+            switch (currentToken) {
+                case START_OBJECT:
+                case START_ARRAY:
+                    stackElement.xmlEvent = XMLEvent.START_ELEMENT;
+
+                    return XMLEvent.START_ELEMENT;
+                case END_OBJECT:
+                    removeStackElement(JsonToken.END_OBJECT);
+                    removeStackElement(JsonToken.START_OBJECT);
+                    removeStackElement(JsonToken.FIELD_NAME);
+                    eof = tokenStack.size() == 0;
+
+                    return XMLEvent.END_ELEMENT;
+                case END_ARRAY:
+                    removeStackElement(JsonToken.END_ARRAY);
+                    removeStackElement(JsonToken.START_ARRAY);
+                    removeStackElement(JsonToken.FIELD_NAME);
+                    eof = tokenStack.size() == 0;
+
+                    return XMLEvent.END_ELEMENT;
+                case VALUE_STRING:
+                case VALUE_NUMBER_INT:
+                case VALUE_NUMBER_FLOAT:
+                case VALUE_NULL:
+                case VALUE_TRUE:
+                case VALUE_FALSE:
+                    stackElement.xmlEvent = XMLEvent.START_ELEMENT;
+
+                    return XMLEvent.START_ELEMENT;
+                default:
+                    throw new IllegalStateException(""JsonToken: "" + currentToken);
+            }
+
+        } catch (IOException e) {
+            throw new XMLStreamException(e);
+        }
+    }
+
+    private void removeStackElement(JsonToken jsonToken) {
+        final StackElement stackElement = tokenStack.peek();
+        if (stackElement == null || (stackElement.jsonToken != jsonToken)) {
+            if (stackElement != null && jsonToken == JsonToken.FIELD_NAME && (stackElement.jsonToken == JsonToken.START_ARRAY)) {
+                // anonym array
+                return;
+            }
+
+            if (stackElement == null && jsonToken == JsonToken.FIELD_NAME) {
+                // root object / array
+                return;
+            }
+
+            final String stackElements = tokenStack.stream().map(StackElement::toString).collect(Collectors.joining(""\n""));
+            throw new IllegalStateException(""Stack element did not match expected ("" + jsonToken + "") one. Stack:\n"" + stackElements);
+        }
+
+        tokenStack.pop();
+    }
+
+    @Override
+    public void require(int type, String namespaceURI, String localName) throws XMLStreamException {
+        throw new UnsupportedOperationException(XJConstants.UNSUPPORTED_OPERATION_EXCEPTION_MESSAGE);
+    }
+
+    @Override
+    public String getElementText() throws XMLStreamException {
+        throw new UnsupportedOperationException(XJConstants.UNSUPPORTED_OPERATION_EXCEPTION_MESSAGE);
+    }
+
+    @Override
+    public int nextTag() throws XMLStreamException {
+        int evt;
+        do {
+            evt = next();
+        } while (evt != XMLEvent.START_ELEMENT && evt != XMLEvent.END_ELEMENT);
+
+        return evt;
+    }
+
+    @Override
+    public boolean hasNext() throws XMLStreamException {
+        return !eof;
+    }
+
+    @Override
+    public void close() throws XMLStreamException {
+        try {
+            jsonParser.close();
+        } catch (IOException e) {
+            throw new XMLStreamException(e);
+        }
+    }
+
+    @Override
+    public String getNamespaceURI(String prefix) {
+        return null;
+    }
+
+    @Override
+    public boolean isStartElement() {
+        final StackElement stackElement = tokenStack.peek();
+        if (stackElement == null) {
+            return false;
+        }
+
+        return stackElement.xmlEvent == XMLEvent.START_ELEMENT;
+    }
+
+    @Override
+    public boolean isEndElement() {
+        final StackElement stackElement = tokenStack.peek();
+        if (stackElement == null) {
+            return false;
+        }
+
+        return stackElement.xmlEvent == XMLEvent.END_ELEMENT;
+    }
+
+    @Override
+    public boolean isCharacters() {
+        final StackElement stackElement = tokenStack.peek();
+        if (stackElement == null) {
+            return false;
+        }
+
+        return stackElement.xmlEvent == XMLEvent.CHARACTERS;
+    }
+
+    @Override
+    public boolean isWhiteSpace() {
+        return false;
+    }
+
+    @Override
+    public String getAttributeValue(String namespaceURI, String localName) {
+        throw new UnsupportedOperationException(XJConstants.UNSUPPORTED_OPERATION_EXCEPTION_MESSAGE);
+    }
+
+    @Override
+    public int getAttributeCount() {
+        final StackElement stackElement = tokenStack.peek();
+        if (stackElement == null || (stackElement.xmlEvent != XMLEvent.START_ELEMENT)) {
+            throw new IllegalStateException();
+        }
+
+        return stackElement.getAttributeCount();
+    }
+
+    @Override
+    public QName getAttributeName(int index) {
+        final StackElement stackElement = tokenStack.peek();
+        if (stackElement == null || (stackElement.xmlEvent != XMLEvent.START_ELEMENT)) {
+            throw new IllegalStateException();
+        }
+
+        return stackElement.getAttribute(index);
+    }
+
+    @Override
+    public String getAttributeNamespace(int index) {
+        final StackElement stackElement = tokenStack.peek();
+        if (stackElement == null || (stackElement.xmlEvent != XMLEvent.START_ELEMENT)) {
+            throw new IllegalStateException();
+        }
+
+        return stackElement.getAttribute(index).getNamespaceURI();
+    }
+
+    @Override
+    public String getAttributeLocalName(int index) {
+        final StackElement stackElement = tokenStack.peek();
+        if (stackElement == null || (stackElement.xmlEvent != XMLEvent.START_ELEMENT)) {
+            throw new IllegalStateException();
+        }
+
+        return stackElement.getAttribute(index).getLocalPart();
+    }
+
+    @Override
+    public String getAttributePrefix(int index) {
+        final StackElement stackElement = tokenStack.peek();
+        if (stackElement == null || (stackElement.xmlEvent != XMLEvent.START_ELEMENT)) {
+            throw new IllegalStateException();
+        }
+
+        return stackElement.getAttribute(index).getPrefix();
+    }
+
+    @Override
+    public String getAttributeType(int index) {
+        final StackElement stackElement = tokenStack.peek();
+        if (stackElement == null || (stackElement.xmlEvent != XMLEvent.START_ELEMENT)) {
+            throw new IllegalStateException();
+        }
+
+        return ""CDATA"";
+    }
+
+    @Override
+    public String getAttributeValue(int index) {
+        final StackElement stackElement = tokenStack.peek();
+        if (stackElement == null || (stackElement.xmlEvent != XMLEvent.START_ELEMENT)) {
+            throw new IllegalStateException();
+        }
+
+        return tokenStack.peek().getAttributeValue(index);
+    }
+
+    @Override
+    public boolean isAttributeSpecified(int index) {
+        return false;
+    }
+
+    @Override
+    public int getNamespaceCount() {
+        // declare ns on root element
+        if (tokenStack.size() == 1) {
+            return 1;
+        }
+
+        return 0;
+    }
+
+    @Override
+    public String getNamespacePrefix(int index) {
+        final StackElement stackElement = tokenStack.peek();
+        if (stackElement == null || (stackElement.xmlEvent != XMLEvent.START_ELEMENT && stackElement.xmlEvent != XMLEvent.END_ELEMENT)) {
+            throw new IllegalStateException();
+        }
+
+        return XJConstants.NS_PREFIX_XJ;
+    }
+
+    @Override
+    public String getNamespaceURI(int index) {
+        final StackElement stackElement = tokenStack.peek();
+        if (stackElement == null || (stackElement.xmlEvent != XMLEvent.START_ELEMENT && stackElement.xmlEvent != XMLEvent.END_ELEMENT)) {
+            throw new IllegalStateException();
+        }
+
+        return XJConstants.NS_XJ;
+    }
+
+    @Override
+    public NamespaceContext getNamespaceContext() {
+        throw new UnsupportedOperationException(XJConstants.UNSUPPORTED_OPERATION_EXCEPTION_MESSAGE);
+    }
+
+    @Override
+    public int getEventType() {
+        if (eof) {
+            return XMLEvent.END_DOCUMENT;
+        }
+
+        if (tokenStack.size() == 0) {
+            return XMLEvent.START_DOCUMENT;
+        }
+
+        return tokenStack.peek().xmlEvent;
+    }
+
+    @Override
+    public String getText() {
+        return new String(getTextCharacters());
+    }
+
+    @Override
+    public char[] getTextCharacters() {
+        final StackElement stackElement = tokenStack.peek();
+        if (stackElement == null || stackElement.xmlEvent != XMLEvent.CHARACTERS) {
+            throw new IllegalStateException();","[{'comment': 'Please add some exception message.', 'commenter': 'bedlaj'}, {'comment': 'done.', 'commenter': 'kayuma'}]"
3093,components/camel-xj/src/main/java/org/apache/camel/component/xj/JsonXmlStreamReader.java,"@@ -0,0 +1,605 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.camel.component.xj;
+
+import com.fasterxml.jackson.core.JsonParser;
+import com.fasterxml.jackson.core.JsonToken;
+
+import javax.xml.namespace.NamespaceContext;
+import javax.xml.namespace.QName;
+import javax.xml.stream.Location;
+import javax.xml.stream.XMLStreamException;
+import javax.xml.stream.XMLStreamReader;
+import javax.xml.stream.events.XMLEvent;
+import java.io.IOException;
+import java.util.*;
+import java.util.stream.Collectors;
+
+/**
+ * XML Json bridge. Explicitly using XMLStreamReader and not XMLEventReader because saxon wants that.
+ */
+public class JsonXmlStreamReader implements XMLStreamReader {
+
+    private static final Location LOCATION = new Location() {
+        @Override
+        public int getLineNumber() {
+            return -1;
+        }
+
+        @Override
+        public int getColumnNumber() {
+            return -1;
+        }
+
+        @Override
+        public int getCharacterOffset() {
+            return -1;
+        }
+
+        @Override
+        public String getPublicId() {
+            return null;
+        }
+
+        @Override
+        public String getSystemId() {
+            return null;
+        }
+    };
+
+    private final JsonParser jsonParser;
+
+    private Deque<StackElement> tokenStack = new ArrayDeque<>();
+    private boolean eof = false;
+
+    public JsonXmlStreamReader(JsonParser jsonParser) {
+        this.jsonParser = jsonParser;
+    }
+
+    @Override
+    public Object getProperty(String name) throws IllegalArgumentException {
+        return null;
+    }
+
+    @Override
+    public int next() throws XMLStreamException {
+        try {
+            final StackElement previousElement = tokenStack.peek();
+            if (previousElement != null) {
+                switch (previousElement.jsonToken) {
+                    case VALUE_STRING:
+                    case VALUE_NUMBER_INT:
+                    case VALUE_NUMBER_FLOAT:
+                    case VALUE_NULL:
+                    case VALUE_TRUE:
+                    case VALUE_FALSE: {
+                        switch (previousElement.xmlEvent) {
+                            case XMLEvent.START_ELEMENT:
+                                previousElement.xmlEvent = XMLEvent.CHARACTERS;
+                                return XMLEvent.CHARACTERS;
+
+                            case XMLEvent.CHARACTERS:
+                                removeStackElement(previousElement.jsonToken);
+                                removeStackElement(JsonToken.FIELD_NAME);
+
+                                tokenStack.peek().xmlEvent = XMLEvent.END_ELEMENT;
+                                return XMLEvent.END_ELEMENT;
+
+                            default:
+                                throw new IllegalStateException(""illegal state"");
+                        }
+                    }
+                }
+            }
+
+            if (eof) {
+                return END_DOCUMENT;
+            }
+
+            JsonToken currentToken = jsonParser.nextToken();
+            if (currentToken == null) {
+                throw new IllegalStateException(""End of document"");
+            }
+
+            StackElement stackElement = new StackElement(currentToken, toXmlString(jsonParser.getCurrentName()));
+            tokenStack.push(stackElement);
+
+            if (currentToken == JsonToken.FIELD_NAME) {
+                currentToken = jsonParser.nextToken();
+
+                stackElement = new StackElement(currentToken, toXmlString(jsonParser.getCurrentName()));
+                tokenStack.push(stackElement);
+            }
+
+            switch (currentToken) {
+                case START_OBJECT:
+                case START_ARRAY:
+                    stackElement.xmlEvent = XMLEvent.START_ELEMENT;
+
+                    return XMLEvent.START_ELEMENT;
+                case END_OBJECT:
+                    removeStackElement(JsonToken.END_OBJECT);
+                    removeStackElement(JsonToken.START_OBJECT);
+                    removeStackElement(JsonToken.FIELD_NAME);
+                    eof = tokenStack.size() == 0;
+
+                    return XMLEvent.END_ELEMENT;
+                case END_ARRAY:
+                    removeStackElement(JsonToken.END_ARRAY);
+                    removeStackElement(JsonToken.START_ARRAY);
+                    removeStackElement(JsonToken.FIELD_NAME);
+                    eof = tokenStack.size() == 0;
+
+                    return XMLEvent.END_ELEMENT;
+                case VALUE_STRING:
+                case VALUE_NUMBER_INT:
+                case VALUE_NUMBER_FLOAT:
+                case VALUE_NULL:
+                case VALUE_TRUE:
+                case VALUE_FALSE:
+                    stackElement.xmlEvent = XMLEvent.START_ELEMENT;
+
+                    return XMLEvent.START_ELEMENT;
+                default:
+                    throw new IllegalStateException(""JsonToken: "" + currentToken);
+            }
+
+        } catch (IOException e) {
+            throw new XMLStreamException(e);
+        }
+    }
+
+    private void removeStackElement(JsonToken jsonToken) {
+        final StackElement stackElement = tokenStack.peek();
+        if (stackElement == null || (stackElement.jsonToken != jsonToken)) {
+            if (stackElement != null && jsonToken == JsonToken.FIELD_NAME && (stackElement.jsonToken == JsonToken.START_ARRAY)) {
+                // anonym array
+                return;
+            }
+
+            if (stackElement == null && jsonToken == JsonToken.FIELD_NAME) {
+                // root object / array
+                return;
+            }
+
+            final String stackElements = tokenStack.stream().map(StackElement::toString).collect(Collectors.joining(""\n""));
+            throw new IllegalStateException(""Stack element did not match expected ("" + jsonToken + "") one. Stack:\n"" + stackElements);
+        }
+
+        tokenStack.pop();
+    }
+
+    @Override
+    public void require(int type, String namespaceURI, String localName) throws XMLStreamException {
+        throw new UnsupportedOperationException(XJConstants.UNSUPPORTED_OPERATION_EXCEPTION_MESSAGE);
+    }
+
+    @Override
+    public String getElementText() throws XMLStreamException {
+        throw new UnsupportedOperationException(XJConstants.UNSUPPORTED_OPERATION_EXCEPTION_MESSAGE);
+    }
+
+    @Override
+    public int nextTag() throws XMLStreamException {
+        int evt;
+        do {
+            evt = next();
+        } while (evt != XMLEvent.START_ELEMENT && evt != XMLEvent.END_ELEMENT);
+
+        return evt;
+    }
+
+    @Override
+    public boolean hasNext() throws XMLStreamException {
+        return !eof;
+    }
+
+    @Override
+    public void close() throws XMLStreamException {
+        try {
+            jsonParser.close();
+        } catch (IOException e) {
+            throw new XMLStreamException(e);
+        }
+    }
+
+    @Override
+    public String getNamespaceURI(String prefix) {
+        return null;
+    }
+
+    @Override
+    public boolean isStartElement() {
+        final StackElement stackElement = tokenStack.peek();
+        if (stackElement == null) {
+            return false;
+        }
+
+        return stackElement.xmlEvent == XMLEvent.START_ELEMENT;
+    }
+
+    @Override
+    public boolean isEndElement() {
+        final StackElement stackElement = tokenStack.peek();
+        if (stackElement == null) {
+            return false;
+        }
+
+        return stackElement.xmlEvent == XMLEvent.END_ELEMENT;
+    }
+
+    @Override
+    public boolean isCharacters() {
+        final StackElement stackElement = tokenStack.peek();
+        if (stackElement == null) {
+            return false;
+        }
+
+        return stackElement.xmlEvent == XMLEvent.CHARACTERS;
+    }
+
+    @Override
+    public boolean isWhiteSpace() {
+        return false;
+    }
+
+    @Override
+    public String getAttributeValue(String namespaceURI, String localName) {
+        throw new UnsupportedOperationException(XJConstants.UNSUPPORTED_OPERATION_EXCEPTION_MESSAGE);
+    }
+
+    @Override
+    public int getAttributeCount() {
+        final StackElement stackElement = tokenStack.peek();
+        if (stackElement == null || (stackElement.xmlEvent != XMLEvent.START_ELEMENT)) {
+            throw new IllegalStateException();
+        }
+
+        return stackElement.getAttributeCount();
+    }
+
+    @Override
+    public QName getAttributeName(int index) {
+        final StackElement stackElement = tokenStack.peek();
+        if (stackElement == null || (stackElement.xmlEvent != XMLEvent.START_ELEMENT)) {
+            throw new IllegalStateException();
+        }
+
+        return stackElement.getAttribute(index);
+    }
+
+    @Override
+    public String getAttributeNamespace(int index) {
+        final StackElement stackElement = tokenStack.peek();
+        if (stackElement == null || (stackElement.xmlEvent != XMLEvent.START_ELEMENT)) {
+            throw new IllegalStateException();
+        }
+
+        return stackElement.getAttribute(index).getNamespaceURI();
+    }
+
+    @Override
+    public String getAttributeLocalName(int index) {
+        final StackElement stackElement = tokenStack.peek();
+        if (stackElement == null || (stackElement.xmlEvent != XMLEvent.START_ELEMENT)) {
+            throw new IllegalStateException();
+        }
+
+        return stackElement.getAttribute(index).getLocalPart();
+    }
+
+    @Override
+    public String getAttributePrefix(int index) {
+        final StackElement stackElement = tokenStack.peek();
+        if (stackElement == null || (stackElement.xmlEvent != XMLEvent.START_ELEMENT)) {
+            throw new IllegalStateException();
+        }
+
+        return stackElement.getAttribute(index).getPrefix();
+    }
+
+    @Override
+    public String getAttributeType(int index) {
+        final StackElement stackElement = tokenStack.peek();
+        if (stackElement == null || (stackElement.xmlEvent != XMLEvent.START_ELEMENT)) {
+            throw new IllegalStateException();
+        }
+
+        return ""CDATA"";
+    }
+
+    @Override
+    public String getAttributeValue(int index) {
+        final StackElement stackElement = tokenStack.peek();
+        if (stackElement == null || (stackElement.xmlEvent != XMLEvent.START_ELEMENT)) {
+            throw new IllegalStateException();
+        }
+
+        return tokenStack.peek().getAttributeValue(index);
+    }
+
+    @Override
+    public boolean isAttributeSpecified(int index) {
+        return false;
+    }
+
+    @Override
+    public int getNamespaceCount() {
+        // declare ns on root element
+        if (tokenStack.size() == 1) {
+            return 1;
+        }
+
+        return 0;
+    }
+
+    @Override
+    public String getNamespacePrefix(int index) {
+        final StackElement stackElement = tokenStack.peek();
+        if (stackElement == null || (stackElement.xmlEvent != XMLEvent.START_ELEMENT && stackElement.xmlEvent != XMLEvent.END_ELEMENT)) {
+            throw new IllegalStateException();
+        }
+
+        return XJConstants.NS_PREFIX_XJ;
+    }
+
+    @Override
+    public String getNamespaceURI(int index) {
+        final StackElement stackElement = tokenStack.peek();
+        if (stackElement == null || (stackElement.xmlEvent != XMLEvent.START_ELEMENT && stackElement.xmlEvent != XMLEvent.END_ELEMENT)) {
+            throw new IllegalStateException();
+        }
+
+        return XJConstants.NS_XJ;
+    }
+
+    @Override
+    public NamespaceContext getNamespaceContext() {
+        throw new UnsupportedOperationException(XJConstants.UNSUPPORTED_OPERATION_EXCEPTION_MESSAGE);
+    }
+
+    @Override
+    public int getEventType() {
+        if (eof) {
+            return XMLEvent.END_DOCUMENT;
+        }
+
+        if (tokenStack.size() == 0) {
+            return XMLEvent.START_DOCUMENT;
+        }
+
+        return tokenStack.peek().xmlEvent;
+    }
+
+    @Override
+    public String getText() {
+        return new String(getTextCharacters());
+    }
+
+    @Override
+    public char[] getTextCharacters() {
+        final StackElement stackElement = tokenStack.peek();
+        if (stackElement == null || stackElement.xmlEvent != XMLEvent.CHARACTERS) {
+            throw new IllegalStateException();
+        }
+
+        try {
+            setXmlText(stackElement, jsonParser);
+            return stackElement.value;
+        } catch (IOException e) {
+            throw new IllegalStateException(e);","[{'comment': 'It is better to rethrow this as UncheckedIOException.', 'commenter': 'bedlaj'}, {'comment': 'done.', 'commenter': 'kayuma'}]"
3093,components/camel-xj/src/main/java/org/apache/camel/component/xj/JsonXmlStreamReader.java,"@@ -0,0 +1,605 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.camel.component.xj;
+
+import com.fasterxml.jackson.core.JsonParser;
+import com.fasterxml.jackson.core.JsonToken;
+
+import javax.xml.namespace.NamespaceContext;
+import javax.xml.namespace.QName;
+import javax.xml.stream.Location;
+import javax.xml.stream.XMLStreamException;
+import javax.xml.stream.XMLStreamReader;
+import javax.xml.stream.events.XMLEvent;
+import java.io.IOException;
+import java.util.*;
+import java.util.stream.Collectors;
+
+/**
+ * XML Json bridge. Explicitly using XMLStreamReader and not XMLEventReader because saxon wants that.
+ */
+public class JsonXmlStreamReader implements XMLStreamReader {
+
+    private static final Location LOCATION = new Location() {
+        @Override
+        public int getLineNumber() {
+            return -1;
+        }
+
+        @Override
+        public int getColumnNumber() {
+            return -1;
+        }
+
+        @Override
+        public int getCharacterOffset() {
+            return -1;
+        }
+
+        @Override
+        public String getPublicId() {
+            return null;
+        }
+
+        @Override
+        public String getSystemId() {
+            return null;
+        }
+    };
+
+    private final JsonParser jsonParser;
+
+    private Deque<StackElement> tokenStack = new ArrayDeque<>();
+    private boolean eof = false;
+
+    public JsonXmlStreamReader(JsonParser jsonParser) {
+        this.jsonParser = jsonParser;
+    }
+
+    @Override
+    public Object getProperty(String name) throws IllegalArgumentException {
+        return null;
+    }
+
+    @Override
+    public int next() throws XMLStreamException {
+        try {
+            final StackElement previousElement = tokenStack.peek();
+            if (previousElement != null) {
+                switch (previousElement.jsonToken) {
+                    case VALUE_STRING:
+                    case VALUE_NUMBER_INT:
+                    case VALUE_NUMBER_FLOAT:
+                    case VALUE_NULL:
+                    case VALUE_TRUE:
+                    case VALUE_FALSE: {
+                        switch (previousElement.xmlEvent) {
+                            case XMLEvent.START_ELEMENT:
+                                previousElement.xmlEvent = XMLEvent.CHARACTERS;
+                                return XMLEvent.CHARACTERS;
+
+                            case XMLEvent.CHARACTERS:
+                                removeStackElement(previousElement.jsonToken);
+                                removeStackElement(JsonToken.FIELD_NAME);
+
+                                tokenStack.peek().xmlEvent = XMLEvent.END_ELEMENT;
+                                return XMLEvent.END_ELEMENT;
+
+                            default:
+                                throw new IllegalStateException(""illegal state"");
+                        }
+                    }
+                }
+            }
+
+            if (eof) {
+                return END_DOCUMENT;
+            }
+
+            JsonToken currentToken = jsonParser.nextToken();
+            if (currentToken == null) {
+                throw new IllegalStateException(""End of document"");
+            }
+
+            StackElement stackElement = new StackElement(currentToken, toXmlString(jsonParser.getCurrentName()));
+            tokenStack.push(stackElement);
+
+            if (currentToken == JsonToken.FIELD_NAME) {
+                currentToken = jsonParser.nextToken();
+
+                stackElement = new StackElement(currentToken, toXmlString(jsonParser.getCurrentName()));
+                tokenStack.push(stackElement);
+            }
+
+            switch (currentToken) {
+                case START_OBJECT:
+                case START_ARRAY:
+                    stackElement.xmlEvent = XMLEvent.START_ELEMENT;
+
+                    return XMLEvent.START_ELEMENT;
+                case END_OBJECT:
+                    removeStackElement(JsonToken.END_OBJECT);
+                    removeStackElement(JsonToken.START_OBJECT);
+                    removeStackElement(JsonToken.FIELD_NAME);
+                    eof = tokenStack.size() == 0;
+
+                    return XMLEvent.END_ELEMENT;
+                case END_ARRAY:
+                    removeStackElement(JsonToken.END_ARRAY);
+                    removeStackElement(JsonToken.START_ARRAY);
+                    removeStackElement(JsonToken.FIELD_NAME);
+                    eof = tokenStack.size() == 0;
+
+                    return XMLEvent.END_ELEMENT;
+                case VALUE_STRING:
+                case VALUE_NUMBER_INT:
+                case VALUE_NUMBER_FLOAT:
+                case VALUE_NULL:
+                case VALUE_TRUE:
+                case VALUE_FALSE:
+                    stackElement.xmlEvent = XMLEvent.START_ELEMENT;
+
+                    return XMLEvent.START_ELEMENT;
+                default:
+                    throw new IllegalStateException(""JsonToken: "" + currentToken);
+            }
+
+        } catch (IOException e) {
+            throw new XMLStreamException(e);
+        }
+    }
+
+    private void removeStackElement(JsonToken jsonToken) {
+        final StackElement stackElement = tokenStack.peek();
+        if (stackElement == null || (stackElement.jsonToken != jsonToken)) {
+            if (stackElement != null && jsonToken == JsonToken.FIELD_NAME && (stackElement.jsonToken == JsonToken.START_ARRAY)) {
+                // anonym array
+                return;
+            }
+
+            if (stackElement == null && jsonToken == JsonToken.FIELD_NAME) {
+                // root object / array
+                return;
+            }
+
+            final String stackElements = tokenStack.stream().map(StackElement::toString).collect(Collectors.joining(""\n""));
+            throw new IllegalStateException(""Stack element did not match expected ("" + jsonToken + "") one. Stack:\n"" + stackElements);
+        }
+
+        tokenStack.pop();
+    }
+
+    @Override
+    public void require(int type, String namespaceURI, String localName) throws XMLStreamException {
+        throw new UnsupportedOperationException(XJConstants.UNSUPPORTED_OPERATION_EXCEPTION_MESSAGE);
+    }
+
+    @Override
+    public String getElementText() throws XMLStreamException {
+        throw new UnsupportedOperationException(XJConstants.UNSUPPORTED_OPERATION_EXCEPTION_MESSAGE);
+    }
+
+    @Override
+    public int nextTag() throws XMLStreamException {
+        int evt;
+        do {
+            evt = next();
+        } while (evt != XMLEvent.START_ELEMENT && evt != XMLEvent.END_ELEMENT);
+
+        return evt;
+    }
+
+    @Override
+    public boolean hasNext() throws XMLStreamException {
+        return !eof;
+    }
+
+    @Override
+    public void close() throws XMLStreamException {
+        try {
+            jsonParser.close();
+        } catch (IOException e) {
+            throw new XMLStreamException(e);
+        }
+    }
+
+    @Override
+    public String getNamespaceURI(String prefix) {
+        return null;
+    }
+
+    @Override
+    public boolean isStartElement() {
+        final StackElement stackElement = tokenStack.peek();
+        if (stackElement == null) {
+            return false;
+        }
+
+        return stackElement.xmlEvent == XMLEvent.START_ELEMENT;
+    }
+
+    @Override
+    public boolean isEndElement() {
+        final StackElement stackElement = tokenStack.peek();
+        if (stackElement == null) {
+            return false;
+        }
+
+        return stackElement.xmlEvent == XMLEvent.END_ELEMENT;
+    }
+
+    @Override
+    public boolean isCharacters() {
+        final StackElement stackElement = tokenStack.peek();
+        if (stackElement == null) {
+            return false;
+        }
+
+        return stackElement.xmlEvent == XMLEvent.CHARACTERS;
+    }
+
+    @Override
+    public boolean isWhiteSpace() {
+        return false;
+    }
+
+    @Override
+    public String getAttributeValue(String namespaceURI, String localName) {
+        throw new UnsupportedOperationException(XJConstants.UNSUPPORTED_OPERATION_EXCEPTION_MESSAGE);
+    }
+
+    @Override
+    public int getAttributeCount() {
+        final StackElement stackElement = tokenStack.peek();
+        if (stackElement == null || (stackElement.xmlEvent != XMLEvent.START_ELEMENT)) {
+            throw new IllegalStateException();
+        }
+
+        return stackElement.getAttributeCount();
+    }
+
+    @Override
+    public QName getAttributeName(int index) {
+        final StackElement stackElement = tokenStack.peek();
+        if (stackElement == null || (stackElement.xmlEvent != XMLEvent.START_ELEMENT)) {
+            throw new IllegalStateException();
+        }
+
+        return stackElement.getAttribute(index);
+    }
+
+    @Override
+    public String getAttributeNamespace(int index) {
+        final StackElement stackElement = tokenStack.peek();
+        if (stackElement == null || (stackElement.xmlEvent != XMLEvent.START_ELEMENT)) {
+            throw new IllegalStateException();
+        }
+
+        return stackElement.getAttribute(index).getNamespaceURI();
+    }
+
+    @Override
+    public String getAttributeLocalName(int index) {
+        final StackElement stackElement = tokenStack.peek();
+        if (stackElement == null || (stackElement.xmlEvent != XMLEvent.START_ELEMENT)) {
+            throw new IllegalStateException();
+        }
+
+        return stackElement.getAttribute(index).getLocalPart();
+    }
+
+    @Override
+    public String getAttributePrefix(int index) {
+        final StackElement stackElement = tokenStack.peek();
+        if (stackElement == null || (stackElement.xmlEvent != XMLEvent.START_ELEMENT)) {
+            throw new IllegalStateException();
+        }
+
+        return stackElement.getAttribute(index).getPrefix();
+    }
+
+    @Override
+    public String getAttributeType(int index) {
+        final StackElement stackElement = tokenStack.peek();
+        if (stackElement == null || (stackElement.xmlEvent != XMLEvent.START_ELEMENT)) {
+            throw new IllegalStateException();
+        }
+
+        return ""CDATA"";
+    }
+
+    @Override
+    public String getAttributeValue(int index) {
+        final StackElement stackElement = tokenStack.peek();
+        if (stackElement == null || (stackElement.xmlEvent != XMLEvent.START_ELEMENT)) {
+            throw new IllegalStateException();
+        }
+
+        return tokenStack.peek().getAttributeValue(index);
+    }
+
+    @Override
+    public boolean isAttributeSpecified(int index) {
+        return false;
+    }
+
+    @Override
+    public int getNamespaceCount() {
+        // declare ns on root element
+        if (tokenStack.size() == 1) {
+            return 1;
+        }
+
+        return 0;
+    }
+
+    @Override
+    public String getNamespacePrefix(int index) {
+        final StackElement stackElement = tokenStack.peek();
+        if (stackElement == null || (stackElement.xmlEvent != XMLEvent.START_ELEMENT && stackElement.xmlEvent != XMLEvent.END_ELEMENT)) {
+            throw new IllegalStateException();
+        }
+
+        return XJConstants.NS_PREFIX_XJ;
+    }
+
+    @Override
+    public String getNamespaceURI(int index) {
+        final StackElement stackElement = tokenStack.peek();
+        if (stackElement == null || (stackElement.xmlEvent != XMLEvent.START_ELEMENT && stackElement.xmlEvent != XMLEvent.END_ELEMENT)) {
+            throw new IllegalStateException();
+        }
+
+        return XJConstants.NS_XJ;
+    }
+
+    @Override
+    public NamespaceContext getNamespaceContext() {
+        throw new UnsupportedOperationException(XJConstants.UNSUPPORTED_OPERATION_EXCEPTION_MESSAGE);
+    }
+
+    @Override
+    public int getEventType() {
+        if (eof) {
+            return XMLEvent.END_DOCUMENT;
+        }
+
+        if (tokenStack.size() == 0) {
+            return XMLEvent.START_DOCUMENT;
+        }
+
+        return tokenStack.peek().xmlEvent;
+    }
+
+    @Override
+    public String getText() {
+        return new String(getTextCharacters());
+    }
+
+    @Override
+    public char[] getTextCharacters() {
+        final StackElement stackElement = tokenStack.peek();
+        if (stackElement == null || stackElement.xmlEvent != XMLEvent.CHARACTERS) {
+            throw new IllegalStateException();
+        }
+
+        try {
+            setXmlText(stackElement, jsonParser);
+            return stackElement.value;
+        } catch (IOException e) {
+            throw new IllegalStateException(e);
+        }
+    }
+
+    @Override
+    public int getTextCharacters(int sourceStart, char[] target, int targetStart, int length) throws XMLStreamException {
+        final char[] text = getTextCharacters();
+        System.arraycopy(text, sourceStart, target, targetStart, length);
+
+        return sourceStart + length;
+    }
+
+    @Override
+    public int getTextStart() {
+        // always starts at 0 because we normalized the text in setXmlText();
+        return 0;
+    }
+
+    @Override
+    public int getTextLength() {
+        final StackElement stackElement = tokenStack.peek();
+
+        try {
+            setXmlText(stackElement, jsonParser);
+            return stackElement.value.length;
+        } catch (IOException e) {
+            throw new IllegalStateException(e);","[{'comment': 'It is better to rethrow this as UncheckedIOException.', 'commenter': 'bedlaj'}, {'comment': 'done.', 'commenter': 'kayuma'}]"
3093,components/camel-xj/src/main/java/org/apache/camel/component/xj/JsonXmlStreamReader.java,"@@ -0,0 +1,605 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.camel.component.xj;
+
+import com.fasterxml.jackson.core.JsonParser;
+import com.fasterxml.jackson.core.JsonToken;
+
+import javax.xml.namespace.NamespaceContext;
+import javax.xml.namespace.QName;
+import javax.xml.stream.Location;
+import javax.xml.stream.XMLStreamException;
+import javax.xml.stream.XMLStreamReader;
+import javax.xml.stream.events.XMLEvent;
+import java.io.IOException;
+import java.util.*;
+import java.util.stream.Collectors;
+
+/**
+ * XML Json bridge. Explicitly using XMLStreamReader and not XMLEventReader because saxon wants that.
+ */
+public class JsonXmlStreamReader implements XMLStreamReader {
+
+    private static final Location LOCATION = new Location() {
+        @Override
+        public int getLineNumber() {
+            return -1;
+        }
+
+        @Override
+        public int getColumnNumber() {
+            return -1;
+        }
+
+        @Override
+        public int getCharacterOffset() {
+            return -1;
+        }
+
+        @Override
+        public String getPublicId() {
+            return null;
+        }
+
+        @Override
+        public String getSystemId() {
+            return null;
+        }
+    };
+
+    private final JsonParser jsonParser;
+
+    private Deque<StackElement> tokenStack = new ArrayDeque<>();
+    private boolean eof = false;
+
+    public JsonXmlStreamReader(JsonParser jsonParser) {
+        this.jsonParser = jsonParser;
+    }
+
+    @Override
+    public Object getProperty(String name) throws IllegalArgumentException {
+        return null;
+    }
+
+    @Override
+    public int next() throws XMLStreamException {
+        try {
+            final StackElement previousElement = tokenStack.peek();
+            if (previousElement != null) {
+                switch (previousElement.jsonToken) {
+                    case VALUE_STRING:
+                    case VALUE_NUMBER_INT:
+                    case VALUE_NUMBER_FLOAT:
+                    case VALUE_NULL:
+                    case VALUE_TRUE:
+                    case VALUE_FALSE: {
+                        switch (previousElement.xmlEvent) {
+                            case XMLEvent.START_ELEMENT:
+                                previousElement.xmlEvent = XMLEvent.CHARACTERS;
+                                return XMLEvent.CHARACTERS;
+
+                            case XMLEvent.CHARACTERS:
+                                removeStackElement(previousElement.jsonToken);
+                                removeStackElement(JsonToken.FIELD_NAME);
+
+                                tokenStack.peek().xmlEvent = XMLEvent.END_ELEMENT;
+                                return XMLEvent.END_ELEMENT;
+
+                            default:
+                                throw new IllegalStateException(""illegal state"");
+                        }
+                    }
+                }
+            }
+
+            if (eof) {
+                return END_DOCUMENT;
+            }
+
+            JsonToken currentToken = jsonParser.nextToken();
+            if (currentToken == null) {
+                throw new IllegalStateException(""End of document"");
+            }
+
+            StackElement stackElement = new StackElement(currentToken, toXmlString(jsonParser.getCurrentName()));
+            tokenStack.push(stackElement);
+
+            if (currentToken == JsonToken.FIELD_NAME) {
+                currentToken = jsonParser.nextToken();
+
+                stackElement = new StackElement(currentToken, toXmlString(jsonParser.getCurrentName()));
+                tokenStack.push(stackElement);
+            }
+
+            switch (currentToken) {
+                case START_OBJECT:
+                case START_ARRAY:
+                    stackElement.xmlEvent = XMLEvent.START_ELEMENT;
+
+                    return XMLEvent.START_ELEMENT;
+                case END_OBJECT:
+                    removeStackElement(JsonToken.END_OBJECT);
+                    removeStackElement(JsonToken.START_OBJECT);
+                    removeStackElement(JsonToken.FIELD_NAME);
+                    eof = tokenStack.size() == 0;
+
+                    return XMLEvent.END_ELEMENT;
+                case END_ARRAY:
+                    removeStackElement(JsonToken.END_ARRAY);
+                    removeStackElement(JsonToken.START_ARRAY);
+                    removeStackElement(JsonToken.FIELD_NAME);
+                    eof = tokenStack.size() == 0;
+
+                    return XMLEvent.END_ELEMENT;
+                case VALUE_STRING:
+                case VALUE_NUMBER_INT:
+                case VALUE_NUMBER_FLOAT:
+                case VALUE_NULL:
+                case VALUE_TRUE:
+                case VALUE_FALSE:
+                    stackElement.xmlEvent = XMLEvent.START_ELEMENT;
+
+                    return XMLEvent.START_ELEMENT;
+                default:
+                    throw new IllegalStateException(""JsonToken: "" + currentToken);
+            }
+
+        } catch (IOException e) {
+            throw new XMLStreamException(e);
+        }
+    }
+
+    private void removeStackElement(JsonToken jsonToken) {
+        final StackElement stackElement = tokenStack.peek();
+        if (stackElement == null || (stackElement.jsonToken != jsonToken)) {
+            if (stackElement != null && jsonToken == JsonToken.FIELD_NAME && (stackElement.jsonToken == JsonToken.START_ARRAY)) {
+                // anonym array
+                return;
+            }
+
+            if (stackElement == null && jsonToken == JsonToken.FIELD_NAME) {
+                // root object / array
+                return;
+            }
+
+            final String stackElements = tokenStack.stream().map(StackElement::toString).collect(Collectors.joining(""\n""));
+            throw new IllegalStateException(""Stack element did not match expected ("" + jsonToken + "") one. Stack:\n"" + stackElements);
+        }
+
+        tokenStack.pop();
+    }
+
+    @Override
+    public void require(int type, String namespaceURI, String localName) throws XMLStreamException {
+        throw new UnsupportedOperationException(XJConstants.UNSUPPORTED_OPERATION_EXCEPTION_MESSAGE);
+    }
+
+    @Override
+    public String getElementText() throws XMLStreamException {
+        throw new UnsupportedOperationException(XJConstants.UNSUPPORTED_OPERATION_EXCEPTION_MESSAGE);
+    }
+
+    @Override
+    public int nextTag() throws XMLStreamException {
+        int evt;
+        do {
+            evt = next();
+        } while (evt != XMLEvent.START_ELEMENT && evt != XMLEvent.END_ELEMENT);
+
+        return evt;
+    }
+
+    @Override
+    public boolean hasNext() throws XMLStreamException {
+        return !eof;
+    }
+
+    @Override
+    public void close() throws XMLStreamException {
+        try {
+            jsonParser.close();
+        } catch (IOException e) {
+            throw new XMLStreamException(e);
+        }
+    }
+
+    @Override
+    public String getNamespaceURI(String prefix) {
+        return null;
+    }
+
+    @Override
+    public boolean isStartElement() {
+        final StackElement stackElement = tokenStack.peek();
+        if (stackElement == null) {
+            return false;
+        }
+
+        return stackElement.xmlEvent == XMLEvent.START_ELEMENT;
+    }
+
+    @Override
+    public boolean isEndElement() {
+        final StackElement stackElement = tokenStack.peek();
+        if (stackElement == null) {
+            return false;
+        }
+
+        return stackElement.xmlEvent == XMLEvent.END_ELEMENT;
+    }
+
+    @Override
+    public boolean isCharacters() {
+        final StackElement stackElement = tokenStack.peek();
+        if (stackElement == null) {
+            return false;
+        }
+
+        return stackElement.xmlEvent == XMLEvent.CHARACTERS;
+    }
+
+    @Override
+    public boolean isWhiteSpace() {
+        return false;
+    }
+
+    @Override
+    public String getAttributeValue(String namespaceURI, String localName) {
+        throw new UnsupportedOperationException(XJConstants.UNSUPPORTED_OPERATION_EXCEPTION_MESSAGE);
+    }
+
+    @Override
+    public int getAttributeCount() {
+        final StackElement stackElement = tokenStack.peek();
+        if (stackElement == null || (stackElement.xmlEvent != XMLEvent.START_ELEMENT)) {
+            throw new IllegalStateException();
+        }
+
+        return stackElement.getAttributeCount();
+    }
+
+    @Override
+    public QName getAttributeName(int index) {
+        final StackElement stackElement = tokenStack.peek();
+        if (stackElement == null || (stackElement.xmlEvent != XMLEvent.START_ELEMENT)) {
+            throw new IllegalStateException();
+        }
+
+        return stackElement.getAttribute(index);
+    }
+
+    @Override
+    public String getAttributeNamespace(int index) {
+        final StackElement stackElement = tokenStack.peek();
+        if (stackElement == null || (stackElement.xmlEvent != XMLEvent.START_ELEMENT)) {
+            throw new IllegalStateException();
+        }
+
+        return stackElement.getAttribute(index).getNamespaceURI();
+    }
+
+    @Override
+    public String getAttributeLocalName(int index) {
+        final StackElement stackElement = tokenStack.peek();
+        if (stackElement == null || (stackElement.xmlEvent != XMLEvent.START_ELEMENT)) {
+            throw new IllegalStateException();
+        }
+
+        return stackElement.getAttribute(index).getLocalPart();
+    }
+
+    @Override
+    public String getAttributePrefix(int index) {
+        final StackElement stackElement = tokenStack.peek();
+        if (stackElement == null || (stackElement.xmlEvent != XMLEvent.START_ELEMENT)) {
+            throw new IllegalStateException();
+        }
+
+        return stackElement.getAttribute(index).getPrefix();
+    }
+
+    @Override
+    public String getAttributeType(int index) {
+        final StackElement stackElement = tokenStack.peek();
+        if (stackElement == null || (stackElement.xmlEvent != XMLEvent.START_ELEMENT)) {
+            throw new IllegalStateException();
+        }
+
+        return ""CDATA"";
+    }
+
+    @Override
+    public String getAttributeValue(int index) {
+        final StackElement stackElement = tokenStack.peek();
+        if (stackElement == null || (stackElement.xmlEvent != XMLEvent.START_ELEMENT)) {
+            throw new IllegalStateException();
+        }
+
+        return tokenStack.peek().getAttributeValue(index);
+    }
+
+    @Override
+    public boolean isAttributeSpecified(int index) {
+        return false;
+    }
+
+    @Override
+    public int getNamespaceCount() {
+        // declare ns on root element
+        if (tokenStack.size() == 1) {
+            return 1;
+        }
+
+        return 0;
+    }
+
+    @Override
+    public String getNamespacePrefix(int index) {
+        final StackElement stackElement = tokenStack.peek();
+        if (stackElement == null || (stackElement.xmlEvent != XMLEvent.START_ELEMENT && stackElement.xmlEvent != XMLEvent.END_ELEMENT)) {
+            throw new IllegalStateException();
+        }
+
+        return XJConstants.NS_PREFIX_XJ;
+    }
+
+    @Override
+    public String getNamespaceURI(int index) {
+        final StackElement stackElement = tokenStack.peek();
+        if (stackElement == null || (stackElement.xmlEvent != XMLEvent.START_ELEMENT && stackElement.xmlEvent != XMLEvent.END_ELEMENT)) {
+            throw new IllegalStateException();
+        }
+
+        return XJConstants.NS_XJ;
+    }
+
+    @Override
+    public NamespaceContext getNamespaceContext() {
+        throw new UnsupportedOperationException(XJConstants.UNSUPPORTED_OPERATION_EXCEPTION_MESSAGE);
+    }
+
+    @Override
+    public int getEventType() {
+        if (eof) {
+            return XMLEvent.END_DOCUMENT;
+        }
+
+        if (tokenStack.size() == 0) {
+            return XMLEvent.START_DOCUMENT;
+        }
+
+        return tokenStack.peek().xmlEvent;
+    }
+
+    @Override
+    public String getText() {
+        return new String(getTextCharacters());
+    }
+
+    @Override
+    public char[] getTextCharacters() {
+        final StackElement stackElement = tokenStack.peek();
+        if (stackElement == null || stackElement.xmlEvent != XMLEvent.CHARACTERS) {
+            throw new IllegalStateException();
+        }
+
+        try {
+            setXmlText(stackElement, jsonParser);
+            return stackElement.value;
+        } catch (IOException e) {
+            throw new IllegalStateException(e);
+        }
+    }
+
+    @Override
+    public int getTextCharacters(int sourceStart, char[] target, int targetStart, int length) throws XMLStreamException {
+        final char[] text = getTextCharacters();
+        System.arraycopy(text, sourceStart, target, targetStart, length);
+
+        return sourceStart + length;
+    }
+
+    @Override
+    public int getTextStart() {
+        // always starts at 0 because we normalized the text in setXmlText();
+        return 0;
+    }
+
+    @Override
+    public int getTextLength() {
+        final StackElement stackElement = tokenStack.peek();
+
+        try {
+            setXmlText(stackElement, jsonParser);
+            return stackElement.value.length;
+        } catch (IOException e) {
+            throw new IllegalStateException(e);
+        }
+    }
+
+    private void setXmlText(StackElement stackElement, JsonParser jsonParser) throws IOException {
+        if (stackElement.value == null) {
+            stackElement.value = toXmlString(jsonParser.getTextCharacters(), jsonParser.getTextOffset(), jsonParser.getTextLength());
+        }
+    }
+
+    @Override
+    public String getEncoding() {
+        return null;
+    }
+
+    @Override
+    public boolean hasText() {
+        final StackElement stackElement = tokenStack.peek();
+        if (stackElement == null) {
+            return false;
+        }
+
+        return stackElement.xmlEvent == XMLEvent.CHARACTERS;
+    }
+
+    @Override
+    public Location getLocation() {
+        return LOCATION;
+    }
+
+    @Override
+    public QName getName() {
+        return new QName(""object"");
+    }
+
+    @Override
+    public String getLocalName() {
+        return ""object"";
+    }
+
+    @Override
+    public boolean hasName() {
+        final StackElement stackElement = tokenStack.peek();
+        if (stackElement == null) {
+            return false;
+        }
+
+        return stackElement.xmlEvent == XMLEvent.START_ELEMENT || stackElement.xmlEvent == XMLEvent.END_ELEMENT;
+    }
+
+    @Override
+    public String getNamespaceURI() {
+        return null;
+    }
+
+    @Override
+    public String getPrefix() {
+        return null;
+    }
+
+    @Override
+    public String getVersion() {
+        return null;
+    }
+
+    @Override
+    public boolean isStandalone() {
+        return false;
+    }
+
+    @Override
+    public boolean standaloneSet() {
+        return false;
+    }
+
+    @Override
+    public String getCharacterEncodingScheme() {
+        return null;
+    }
+
+    @Override
+    public String getPITarget() {
+        return null;
+    }
+
+    @Override
+    public String getPIData() {
+        return null;
+    }
+
+    private String toXmlString(String input) {
+        if (input == null || input.length() == 0) {
+            return null;
+        }
+
+        final char[] chars = input.toCharArray();
+        return new String(toXmlString(chars, 0, chars.length));
+    }
+
+    private char[] toXmlString(char[] input, int offset, int length) {
+        if (length == 0) {
+            return new char[0];
+        }
+
+        char[] res = new char[length];
+        int copied = 0;
+
+        for (int i = offset; i < (offset + length); i++) {
+            final char cur = input[i];
+            if ((cur < 9) || (cur > 10 && cur < 13) || (cur > 13 && cur < 32)) { // non valid xml characters
+                continue;
+            }
+
+            res[copied++] = cur;
+        }
+
+        return Arrays.copyOfRange(res, 0, copied);
+    }
+
+    private static class StackElement {
+
+        private JsonToken jsonToken;
+        private String name;
+        private int xmlEvent;
+        private char[] value;
+        private List<QName> attributes;
+
+        StackElement(JsonToken jsonToken, String name) {
+            this.jsonToken = jsonToken;
+            this.name = name;
+
+            this.attributes = new ArrayList<>(2);
+
+            if (name != null) {
+                final QName nameAttribute = new QName(XJConstants.NS_XJ, XJConstants.TYPE_HINT_NAME, XJConstants.NS_PREFIX_XJ);
+                attributes.add(nameAttribute);
+            }
+
+            // todo configurable if type hints should be emitted?
+            final QName typeAttribute = new QName(XJConstants.NS_XJ, XJConstants.TYPE_HINT_TYPE, XJConstants.NS_PREFIX_XJ);
+            attributes.add(typeAttribute);
+        }
+
+        int getAttributeCount() {
+            return attributes.size();
+        }
+
+        QName getAttribute(int idx) {
+            return attributes.get(idx);
+        }
+
+        String getAttributeValue(int idx) {
+            final QName attribute = getAttribute(idx);
+            switch (attribute.getLocalPart()) {
+                case XJConstants.TYPE_HINT_NAME:
+                    return this.name;
+                case XJConstants.TYPE_HINT_TYPE:
+                    return XJConstants.JSONTYPE_TYPE_MAP.get(this.jsonToken);
+                default:
+                    throw new IllegalArgumentException(""Unknown attribute"");","[{'comment': 'Please add localPart to exception message', 'commenter': 'bedlaj'}, {'comment': 'done.', 'commenter': 'kayuma'}]"
3093,components/camel-xj/src/main/java/org/apache/camel/component/xj/XJComponent.java,"@@ -0,0 +1,203 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.xj;
+
+import org.apache.camel.Endpoint;
+import org.apache.camel.component.xslt.DefaultXsltUriResolverFactory;
+import org.apache.camel.component.xslt.XsltUriResolverFactory;
+import org.apache.camel.spi.Metadata;
+import org.apache.camel.spi.annotations.Component;
+import org.apache.camel.support.DefaultComponent;
+import org.apache.camel.support.EndpointHelper;
+import org.apache.camel.support.ResourceHelper;
+
+import javax.xml.transform.URIResolver;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+// todo?: This class is just a copy of XsltComponent because of minor but important different requirements. Refactoring of XsltComponent so that we can extend it?","[{'comment': 'What refactoring of XsltComponent do you need? You should be able exclude/change options on annotation level and methods can be overriden.', 'commenter': 'bedlaj'}, {'comment': 'obsolete.', 'commenter': 'kayuma'}]"
3093,components/camel-xj/src/main/java/org/apache/camel/component/xj/XJComponent.java,"@@ -0,0 +1,203 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.xj;
+
+import org.apache.camel.Endpoint;
+import org.apache.camel.component.xslt.DefaultXsltUriResolverFactory;
+import org.apache.camel.component.xslt.XsltUriResolverFactory;
+import org.apache.camel.spi.Metadata;
+import org.apache.camel.spi.annotations.Component;
+import org.apache.camel.support.DefaultComponent;
+import org.apache.camel.support.EndpointHelper;
+import org.apache.camel.support.ResourceHelper;
+
+import javax.xml.transform.URIResolver;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+// todo?: This class is just a copy of XsltComponent because of minor but important different requirements. Refactoring of XsltComponent so that we can extend it?
+
+/**
+ * The <a href=""http://camel.apache.org/xj.html"">XJ Component</a> is for performing xml to json and back transformations of messages
+ */
+@Component(""xj"")
+public class XJComponent extends DefaultComponent {
+
+    @Metadata(label = ""advanced"")","[{'comment': 'It would be nice to have description in Metadata annotations', 'commenter': 'bedlaj'}, {'comment': 'done.', 'commenter': 'kayuma'}]"
3093,components/camel-xj/src/main/java/org/apache/camel/component/xj/XJEndpoint.java,"@@ -0,0 +1,527 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.xj;
+
+import com.fasterxml.jackson.core.JsonFactory;
+import org.apache.camel.CamelContext;
+import org.apache.camel.Component;
+import org.apache.camel.Exchange;
+import org.apache.camel.api.management.ManagedAttribute;
+import org.apache.camel.api.management.ManagedOperation;
+import org.apache.camel.api.management.ManagedResource;
+import org.apache.camel.component.xslt.ResultHandlerFactory;
+import org.apache.camel.component.xslt.XsltOutput;
+import org.apache.camel.spi.*;
+import org.apache.camel.support.EndpointHelper;
+import org.apache.camel.support.ProcessorEndpoint;
+import org.apache.camel.support.service.ServiceHelper;
+import org.apache.camel.util.ObjectHelper;
+import org.xml.sax.EntityResolver;
+
+import javax.xml.transform.*;","[{'comment': 'Please build with `sourcecheck` profile and fix issues', 'commenter': 'bedlaj'}, {'comment': 'done.', 'commenter': 'kayuma'}]"
3093,components/camel-xj/src/main/java/org/apache/camel/component/xj/XJEndpoint.java,"@@ -0,0 +1,527 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.xj;
+
+import com.fasterxml.jackson.core.JsonFactory;
+import org.apache.camel.CamelContext;
+import org.apache.camel.Component;
+import org.apache.camel.Exchange;
+import org.apache.camel.api.management.ManagedAttribute;
+import org.apache.camel.api.management.ManagedOperation;
+import org.apache.camel.api.management.ManagedResource;
+import org.apache.camel.component.xslt.ResultHandlerFactory;
+import org.apache.camel.component.xslt.XsltOutput;
+import org.apache.camel.spi.*;
+import org.apache.camel.support.EndpointHelper;
+import org.apache.camel.support.ProcessorEndpoint;
+import org.apache.camel.support.service.ServiceHelper;
+import org.apache.camel.util.ObjectHelper;
+import org.xml.sax.EntityResolver;
+
+import javax.xml.transform.*;
+import java.io.IOException;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+// todo?: This class is just a copy of XsltEndpoint because of minor but important different requirements. Refactoring of XsltComponent so that we can extend it?","[{'comment': 'What refactoring of XslEndpoint do you need? You should be able exclude/change options on annotation level and methods can be overriden.', 'commenter': 'bedlaj'}, {'comment': 'obsolete.', 'commenter': 'kayuma'}]"
3093,components/camel-xj/src/main/java/org/apache/camel/component/xj/XJEndpoint.java,"@@ -0,0 +1,527 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.xj;
+
+import com.fasterxml.jackson.core.JsonFactory;
+import org.apache.camel.CamelContext;
+import org.apache.camel.Component;
+import org.apache.camel.Exchange;
+import org.apache.camel.api.management.ManagedAttribute;
+import org.apache.camel.api.management.ManagedOperation;
+import org.apache.camel.api.management.ManagedResource;
+import org.apache.camel.component.xslt.ResultHandlerFactory;
+import org.apache.camel.component.xslt.XsltOutput;
+import org.apache.camel.spi.*;
+import org.apache.camel.support.EndpointHelper;
+import org.apache.camel.support.ProcessorEndpoint;
+import org.apache.camel.support.service.ServiceHelper;
+import org.apache.camel.util.ObjectHelper;
+import org.xml.sax.EntityResolver;
+
+import javax.xml.transform.*;
+import java.io.IOException;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+// todo?: This class is just a copy of XsltEndpoint because of minor but important different requirements. Refactoring of XsltComponent so that we can extend it?
+
+/**
+ * Transforms json/xml message back and forth using a XSLT.
+ */
+@ManagedResource(description = ""Managed XJEndpoint"")
+@UriEndpoint(firstVersion = ""2.25.0"", scheme = ""xj"", title = ""XJ"", syntax = ""xj:resourceUri"", producerOnly = true, label = ""transformation"")
+public class XJEndpoint extends ProcessorEndpoint {
+
+    public static final String SAXON_TRANSFORMER_FACTORY_CLASS_NAME = ""net.sf.saxon.TransformerFactoryImpl"";
+
+    private volatile boolean cacheCleared;
+    private volatile XsltBuilder xslt;
+    private Map<String, Object> parameters;
+
+    private JsonFactory jsonFactory = new JsonFactory();
+
+    @UriParam
+    @Metadata(required = true)
+    private TransformDirection transformDirection;
+    @UriPath
+    @Metadata(required = true)
+    private String resourceUri;
+    @UriParam(defaultValue = ""true"")
+    private boolean contentCache = true;
+    @UriParam(label = ""advanced"")
+    private String transformerFactoryClass;
+    @UriParam(label = ""advanced"")
+    private TransformerFactory transformerFactory;
+    @UriParam
+    private boolean saxon;
+    @UriParam(label = ""advanced"")
+    private Object saxonConfiguration;
+    @Metadata(label = ""advanced"")
+    private Map<String, Object> saxonConfigurationProperties = new HashMap<>();
+    @UriParam(label = ""advanced"", javaType = ""java.lang.String"")
+    private List<Object> saxonExtensionFunctions;
+    @UriParam(label = ""advanced"")
+    private ResultHandlerFactory resultHandlerFactory;
+    @UriParam(defaultValue = ""true"")
+    private boolean failOnNullBody = true;
+    @UriParam(defaultValue = ""string"")
+    private XsltOutput output = XsltOutput.string;
+    @UriParam(defaultValue = ""0"")
+    private int transformerCacheSize;
+    @UriParam(label = ""advanced"")
+    private ErrorListener errorListener;
+    @UriParam(label = ""advanced"")
+    private URIResolver uriResolver;
+    @UriParam
+    private boolean deleteOutputFile;
+    @UriParam(label = ""advanced"")
+    private EntityResolver entityResolver;
+
+    public XJEndpoint(String endpointUri, Component component) {
+        super(endpointUri, component);
+    }
+
+    @ManagedOperation(description = ""Clears the cached XSLT stylesheet, forcing to re-load the stylesheet on next request"")
+    public void clearCachedStylesheet() {
+        this.cacheCleared = true;
+    }
+
+    @ManagedAttribute(description = ""Whether the XSLT stylesheet is cached"")
+    public boolean isCacheStylesheet() {
+        return contentCache;
+    }
+
+    public XJEndpoint findOrCreateEndpoint(String uri, String newResourceUri) {
+        String newUri = uri.replace(resourceUri, newResourceUri);
+        log.trace(""Getting endpoint with URI: {}"", newUri);
+        return getCamelContext().getEndpoint(newUri, XJEndpoint.class);
+    }
+
+    @Override
+    protected void onExchange(Exchange exchange) throws Exception {
+        if (!contentCache || cacheCleared) {
+            loadResource(resourceUri);
+        }
+        super.onExchange(exchange);
+    }
+
+    @ManagedAttribute(description = ""Transform direction"")
+    public TransformDirection getTransformDirection() {
+        return transformDirection;
+    }
+
+    /**
+     * The transform direction. Either XML2JSON or JSON2XML
+     */
+    public void setTransformDirection(TransformDirection transformDirection) {
+        this.transformDirection = transformDirection;
+    }
+
+    public boolean isCacheCleared() {
+        return cacheCleared;
+    }
+
+    public void setCacheCleared(boolean cacheCleared) {
+        this.cacheCleared = cacheCleared;
+    }
+
+    public XsltBuilder getXslt() {
+        return xslt;
+    }
+
+    public void setXslt(XsltBuilder xslt) {
+        this.xslt = xslt;
+    }
+
+    @ManagedAttribute(description = ""Path to the template"")
+    public String getResourceUri() {
+        return resourceUri;
+    }
+
+    /**
+     * Path to the template.
+     * <p/>
+     * The following is supported by the default URIResolver.
+     * You can prefix with: classpath, file, http, ref, or bean.
+     * classpath, file and http loads the resource using these protocols (classpath is default).
+     * ref will lookup the resource in the registry.
+     * bean will call a method on a bean to be used as the resource.
+     * For bean you can specify the method name after dot, eg bean:myBean.myMethod
+     *
+     * @param resourceUri the resource path
+     */
+    public void setResourceUri(String resourceUri) {
+        this.resourceUri = resourceUri;
+    }
+
+    public String getTransformerFactoryClass() {
+        return transformerFactoryClass;
+    }
+
+    /**
+     * To use a custom XSLT transformer factory, specified as a FQN class name
+     */
+    public void setTransformerFactoryClass(String transformerFactoryClass) {
+        this.transformerFactoryClass = transformerFactoryClass;
+    }
+
+    public TransformerFactory getTransformerFactory() {
+        return transformerFactory;
+    }
+
+    /**
+     * To use a custom XSLT transformer factory
+     */
+    public void setTransformerFactory(TransformerFactory transformerFactory) {
+        this.transformerFactory = transformerFactory;
+    }
+
+    @ManagedAttribute(description = ""Whether to use Saxon as the transformerFactoryClass"")
+    public boolean isSaxon() {
+        return saxon;
+    }
+
+    /**
+     * Whether to use Saxon as the transformerFactoryClass.
+     * If enabled then the class net.sf.saxon.TransformerFactoryImpl. You would need to add Saxon to the classpath.
+     */
+    public void setSaxon(boolean saxon) {
+        this.saxon = saxon;
+    }
+
+    public List<Object> getSaxonExtensionFunctions() {
+        return saxonExtensionFunctions;
+    }
+
+    /**
+     * Allows you to use a custom net.sf.saxon.lib.ExtensionFunctionDefinition.
+     * You would need to add camel-saxon to the classpath.
+     * The function is looked up in the registry, where you can comma to separate multiple values to lookup.
+     */
+    public void setSaxonExtensionFunctions(List<Object> extensionFunctions) {
+        this.saxonExtensionFunctions = extensionFunctions;
+    }
+
+    /**
+     * Allows you to use a custom net.sf.saxon.lib.ExtensionFunctionDefinition.
+     * You would need to add camel-saxon to the classpath.
+     * The function is looked up in the registry, where you can comma to separate multiple values to lookup.
+     */
+    public void setSaxonExtensionFunctions(String extensionFunctions) {
+        this.saxonExtensionFunctions = EndpointHelper.resolveReferenceListParameter(
+                getCamelContext(),
+                extensionFunctions,
+                Object.class
+        );
+    }
+
+    public Object getSaxonConfiguration() {
+        return saxonConfiguration;
+    }
+
+    /**
+     * To use a custom Saxon configuration
+     */
+    public void setSaxonConfiguration(Object saxonConfiguration) {
+        this.saxonConfiguration = saxonConfiguration;
+    }
+
+    public Map<String, Object> getSaxonConfigurationProperties() {
+        return saxonConfigurationProperties;
+    }
+
+    /**
+     * To set custom Saxon configuration properties
+     */
+    public void setSaxonConfigurationProperties(Map<String, Object> configurationProperties) {
+        this.saxonConfigurationProperties = configurationProperties;
+    }
+
+    public ResultHandlerFactory getResultHandlerFactory() {
+        return resultHandlerFactory;
+    }
+
+    /**
+     * Allows you to use a custom org.apache.camel.builder.xml.ResultHandlerFactory which is capable of
+     * using custom org.apache.camel.builder.xml.ResultHandler types.
+     */
+    public void setResultHandlerFactory(ResultHandlerFactory resultHandlerFactory) {
+        this.resultHandlerFactory = resultHandlerFactory;
+    }
+
+    @ManagedAttribute(description = ""Whether or not to throw an exception if the input body is null"")
+    public boolean isFailOnNullBody() {
+        return failOnNullBody;
+    }
+
+    /**
+     * Whether or not to throw an exception if the input body is null.
+     */
+    public void setFailOnNullBody(boolean failOnNullBody) {
+        this.failOnNullBody = failOnNullBody;
+    }
+
+    @ManagedAttribute(description = ""What kind of option to use."")
+    public XsltOutput getOutput() {
+        return output;
+    }
+
+    /**
+     * Option to specify which output type to use.
+     * Possible values are: string, bytes, DOM, file. The first three options are all in memory based, where as file is streamed directly to a java.io.File.
+     * For file you must specify the filename in the IN header with the key Exchange.XSLT_FILE_NAME which is also CamelXsltFileName.
+     * Also any paths leading to the filename must be created beforehand, otherwise an exception is thrown at runtime.
+     */
+    public void setOutput(XsltOutput output) {
+        this.output = output;
+    }
+
+    public int getTransformerCacheSize() {
+        return transformerCacheSize;
+    }
+
+    /**
+     * The number of javax.xml.transform.Transformer object that are cached for reuse to avoid calls to Template.newTransformer().
+     */
+    public void setTransformerCacheSize(int transformerCacheSize) {
+        this.transformerCacheSize = transformerCacheSize;
+    }
+
+    public ErrorListener getErrorListener() {
+        return errorListener;
+    }
+
+    /**
+     * Allows to configure to use a custom javax.xml.transform.ErrorListener. Beware when doing this then the default error
+     * listener which captures any errors or fatal errors and store information on the Exchange as properties is not in use.
+     * So only use this option for special use-cases.
+     */
+    public void setErrorListener(ErrorListener errorListener) {
+        this.errorListener = errorListener;
+    }
+
+    @ManagedAttribute(description = ""Cache for the resource content (the stylesheet file) when it is loaded."")
+    public boolean isContentCache() {
+        return contentCache;
+    }
+
+    /**
+     * Cache for the resource content (the stylesheet file) when it is loaded.
+     * If set to false Camel will reload the stylesheet file on each message processing. This is good for development.
+     * A cached stylesheet can be forced to reload at runtime via JMX using the clearCachedStylesheet operation.
+     */
+    public void setContentCache(boolean contentCache) {
+        this.contentCache = contentCache;
+    }
+
+    public URIResolver getUriResolver() {
+        return uriResolver;
+    }
+
+    /**
+     * To use a custom javax.xml.transform.URIResolver
+     */
+    public void setUriResolver(URIResolver uriResolver) {
+        this.uriResolver = uriResolver;
+    }
+
+    public boolean isDeleteOutputFile() {
+        return deleteOutputFile;
+    }
+
+    /**
+     * If you have output=file then this option dictates whether or not the output file should be deleted when the Exchange
+     * is done processing. For example suppose the output file is a temporary file, then it can be a good idea to delete it after use.
+     */
+    public void setDeleteOutputFile(boolean deleteOutputFile) {
+        this.deleteOutputFile = deleteOutputFile;
+    }
+
+    public EntityResolver getEntityResolver() {
+        return entityResolver;
+    }
+
+    /**
+     * To use a custom org.xml.sax.EntityResolver with javax.xml.transform.sax.SAXSource.
+     */
+    public void setEntityResolver(EntityResolver entityResolver) {
+        this.entityResolver = entityResolver;
+    }
+
+    public Map<String, Object> getParameters() {
+        return parameters;
+    }
+
+    /**
+     * Additional parameters to configure on the javax.xml.transform.Transformer.
+     */
+    public void setParameters(Map<String, Object> parameters) {
+        this.parameters = parameters;
+    }
+
+    /**
+     * Loads the resource.
+     *
+     * @param resourceUri the resource to load
+     * @throws TransformerException is thrown if error loading resource
+     * @throws IOException          is thrown if error loading resource
+     */
+    protected void loadResource(String resourceUri) throws TransformerException, IOException {
+        log.trace(""{} loading schema resource: {}"", this, resourceUri);
+        Source source = xslt.getUriResolver().resolve(resourceUri, null);
+        if (source == null) {
+            throw new IOException(""Cannot load xsl resource "" + resourceUri);
+        } else {
+            xslt.setTransformerSource(source);
+        }
+        // now loaded so clear flag
+        cacheCleared = false;
+    }
+
+    @Override
+    protected void doStart() throws Exception {
+        super.doStart();
+
+        if (ObjectHelper.isEmpty(getResourceUri())) {
+            // todo using a stylesheet for ""identity"" transform is slow. But with transformerFactory we can't get an identity transformer...
+            setResourceUri(""org/apache/camel/component/xj/identity.xsl"");
+        }
+
+        final CamelContext ctx = getCamelContext();
+        final ClassResolver resolver = ctx.getClassResolver();
+        final Injector injector = ctx.getInjector();
+
+        log.debug(""{} using schema resource: {}"", this, resourceUri);
+
+        this.xslt = new XsltBuilder();
+
+        boolean useSaxon = false;
+        if (transformerFactoryClass == null && (saxon || saxonExtensionFunctions != null)) {
+            useSaxon = true;
+            transformerFactoryClass = SAXON_TRANSFORMER_FACTORY_CLASS_NAME;
+        }
+
+        TransformerFactory factory = transformerFactory;
+        if (factory == null && transformerFactoryClass != null) {
+            // provide the class loader of this component to work in OSGi environments
+            Class<TransformerFactory> factoryClass = resolver.resolveMandatoryClass(transformerFactoryClass, TransformerFactory.class, XJEndpoint.class.getClassLoader());
+            log.debug(""Using TransformerFactoryClass {}"", factoryClass);
+            factory = injector.newInstance(factoryClass);
+
+            if (useSaxon) {
+                XsltHelper.registerSaxonConfiguration(ctx, factoryClass, factory, saxonConfiguration);
+                XsltHelper.registerSaxonConfigurationProperties(ctx, factoryClass, factory, saxonConfigurationProperties);
+                XsltHelper.registerSaxonExtensionFunctions(ctx, factoryClass, factory, saxonExtensionFunctions);
+            }
+        }
+
+        if (factory != null) {
+            log.debug(""Using TransformerFactory {}"", factory);
+            xslt.setTransformerFactory(factory);
+        }
+        if (resultHandlerFactory != null) {
+            xslt.setResultHandlerFactory(resultHandlerFactory);
+        }
+        if (this.transformDirection == TransformDirection.XML2JSON) {
+            xslt.setSourceHandlerFactory(new XmlSourceHandlerFactoryImpl());
+        } else {
+            xslt.setSourceHandlerFactory(new JsonSourceHandlerFactoryImpl(jsonFactory));
+        }
+        if (errorListener != null) {
+            xslt.errorListener(errorListener);
+        }
+        xslt.setFailOnNullBody(failOnNullBody);
+        xslt.transformerCacheSize(transformerCacheSize);
+        xslt.setUriResolver(uriResolver);
+        xslt.setEntityResolver(entityResolver);
+        xslt.setAllowStAX(true); // we rely on stax so always to true. No issues so far with jdk 1.8 and saxon xslt.","[{'comment': 'We are targetting to JDK11 in Camel 3.0 and we will deprecate JDK 1.8 soon. Why this comment? Do you expect some issues in later JDKs?', 'commenter': 'bedlaj'}, {'comment': ""This was just a reaction of the existing code in the XSLT component (XsltBuilder):\r\n\r\nif (!isAllowStAX() && source instanceof StAXSource) {\r\n                // Always convert StAXSource to SAXSource.\r\n                // * Xalan and Saxon-B don't support StAXSource.\r\n                // * The JDK default implementation (XSLTC) doesn't handle CDATA events\r\n                //   (see com.sun.org.apache.xalan.internal.xsltc.trax.StAXStream2SAX).\r\n                // * Saxon-HE/PE/EE seem to support StAXSource, but don't advertise this\r\n                //   officially (via TransformerFactory.getFeature(StAXSource.FEATURE))\r\n                source = new StAX2SAXSource(((StAXSource) source).getXMLStreamReader());\r\n            }\r\n"", 'commenter': 'kayuma'}]"
3093,components/readme.adoc,"@@ -871,6 +871,9 @@ Number of Components: 296 in 234 JAR artifacts (0 deprecated)
 | link:camel-xchange/src/main/docs/xchange-component.adoc[XChange] (camel-xchange) +
 `xchange:name` | 2.21 | The camel-xchange component provide access to many bitcoin and altcoin exchanges for trading and accessing market data.
 
+| link:camel-xj/src/main/docs/xj-component.adoc[XJ] (camel-xj) +","[{'comment': 'This file is missing. Please create one (You can find example in any other component) and then rebuild the component - it will be regenerated', 'commenter': 'bedlaj'}, {'comment': 'done.', 'commenter': 'kayuma'}]"
3093,components/camel-xj/src/main/java/org/apache/camel/component/xj/XJEndpoint.java,"@@ -0,0 +1,527 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.xj;
+
+import com.fasterxml.jackson.core.JsonFactory;
+import org.apache.camel.CamelContext;
+import org.apache.camel.Component;
+import org.apache.camel.Exchange;
+import org.apache.camel.api.management.ManagedAttribute;
+import org.apache.camel.api.management.ManagedOperation;
+import org.apache.camel.api.management.ManagedResource;
+import org.apache.camel.component.xslt.ResultHandlerFactory;
+import org.apache.camel.component.xslt.XsltOutput;
+import org.apache.camel.spi.*;
+import org.apache.camel.support.EndpointHelper;
+import org.apache.camel.support.ProcessorEndpoint;
+import org.apache.camel.support.service.ServiceHelper;
+import org.apache.camel.util.ObjectHelper;
+import org.xml.sax.EntityResolver;
+
+import javax.xml.transform.*;
+import java.io.IOException;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+// todo?: This class is just a copy of XsltEndpoint because of minor but important different requirements. Refactoring of XsltComponent so that we can extend it?
+
+/**
+ * Transforms json/xml message back and forth using a XSLT.
+ */
+@ManagedResource(description = ""Managed XJEndpoint"")
+@UriEndpoint(firstVersion = ""2.25.0"", scheme = ""xj"", title = ""XJ"", syntax = ""xj:resourceUri"", producerOnly = true, label = ""transformation"")
+public class XJEndpoint extends ProcessorEndpoint {
+
+    public static final String SAXON_TRANSFORMER_FACTORY_CLASS_NAME = ""net.sf.saxon.TransformerFactoryImpl"";
+
+    private volatile boolean cacheCleared;
+    private volatile XsltBuilder xslt;
+    private Map<String, Object> parameters;
+
+    private JsonFactory jsonFactory = new JsonFactory();
+
+    @UriParam
+    @Metadata(required = true)","[{'comment': 'It would be nice to have description in Metadata annotations', 'commenter': 'bedlaj'}, {'comment': 'done.', 'commenter': 'kayuma'}]"
3093,components/camel-xj/src/main/java/org/apache/camel/component/xj/XmlJsonStreamWriter.java,"@@ -0,0 +1,640 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.camel.component.xj;
+
+import com.fasterxml.jackson.core.JsonGenerator;
+import com.fasterxml.jackson.core.JsonToken;
+
+import javax.xml.namespace.NamespaceContext;
+import javax.xml.stream.XMLStreamException;
+import javax.xml.stream.XMLStreamWriter;
+import javax.xml.stream.events.XMLEvent;
+import java.io.IOException;
+import java.util.*;
+import java.util.stream.Collectors;
+
+/**
+ * XML Json bridge. Explicitly using StreamWriter and not XMLEventWriter because saxon wants that.
+ */
+public class XmlJsonStreamWriter implements XMLStreamWriter {
+
+    private static final String JSON_MIXED_CONTENT_TEXT_KEY = ""#text"";
+
+    private final JsonGenerator jsonGenerator;
+
+    private TreeElement treeRoot;
+    private TreeElement currentTreeElement;
+
+    public XmlJsonStreamWriter(JsonGenerator jsonGenerator) {
+        this.jsonGenerator = jsonGenerator;
+    }
+
+    @Override
+    public void writeStartElement(String localName) throws XMLStreamException {
+        writeStartElement(null, localName, null);
+    }
+
+    @Override
+    public void writeStartElement(String namespaceURI, String localName) throws XMLStreamException {
+        writeStartElement(null, localName, namespaceURI);
+    }
+
+    @Override
+    public void writeStartElement(String prefix, String localName, String namespaceURI) throws XMLStreamException {
+        final TreeElement treeElement = new TreeElement(currentTreeElement, XMLEvent.START_ELEMENT, localName);
+
+        currentTreeElement.addChild(treeElement);
+        currentTreeElement = treeElement;
+    }
+
+    @Override
+    public void writeEmptyElement(String namespaceURI, String localName) throws XMLStreamException {
+        writeStartElement(null, namespaceURI, localName);
+        writeEndElement();
+    }
+
+    @Override
+    public void writeEmptyElement(String prefix, String localName, String namespaceURI) throws XMLStreamException {
+        writeStartElement(prefix, localName, namespaceURI);
+        writeEndElement();
+    }
+
+    @Override
+    public void writeEmptyElement(String localName) throws XMLStreamException {
+        writeStartElement(null, localName, null);
+        writeEndElement();
+    }
+
+    @Override
+    public void writeEndElement() throws XMLStreamException {
+        try {
+            currentTreeElement.writeEnd();
+        } catch (IOException e) {
+            throw new XMLStreamException(e);
+        }
+        currentTreeElement = currentTreeElement.parent;
+    }
+
+    @Override
+    public void writeEndDocument() throws XMLStreamException {
+        try {
+            treeRoot.write(jsonGenerator);
+        } catch (IOException e) {
+            throw new XMLStreamException(e);
+        }
+    }
+
+    @Override
+    public void close() throws XMLStreamException {
+        try {
+            jsonGenerator.close();
+        } catch (IOException e) {
+            throw new XMLStreamException(e);
+        }
+    }
+
+    @Override
+    public void flush() throws XMLStreamException {
+        try {
+            jsonGenerator.flush();
+        } catch (IOException e) {
+            throw new XMLStreamException(e);
+        }
+    }
+
+    @Override
+    public void writeAttribute(String localName, String value) throws XMLStreamException {
+        writeAttribute(null, null, localName, value);
+    }
+
+    @Override
+    public void writeAttribute(String prefix, String namespaceURI, String localName, String value) throws XMLStreamException {
+        if (XJConstants.NS_XJ.equals(namespaceURI)) {
+            switch (localName) {
+                case XJConstants.TYPE_HINT_NAME:
+                    currentTreeElement.setName(value);
+                    return;
+                case XJConstants.TYPE_HINT_TYPE:
+                    currentTreeElement.setJsonToken(XJConstants.TYPE_JSONTYPE_MAP.get(value));
+                    return;
+            }
+
+            return;
+        }
+
+        final TreeElement treeElement = new TreeElement(currentTreeElement, XMLEvent.ATTRIBUTE, JsonToken.VALUE_STRING, localName);
+        treeElement.setValue(value);
+
+        currentTreeElement.addChild(treeElement);
+    }
+
+    @Override
+    public void writeAttribute(String namespaceURI, String localName, String value) throws XMLStreamException {
+        writeAttribute(null, namespaceURI, localName, value);
+    }
+
+    @Override
+    public void writeNamespace(String prefix, String namespaceURI) throws XMLStreamException {
+    }
+
+    @Override
+    public void writeDefaultNamespace(String namespaceURI) throws XMLStreamException {
+    }
+
+    @Override
+    public void writeComment(String data) throws XMLStreamException {
+    }
+
+    @Override
+    public void writeProcessingInstruction(String target) throws XMLStreamException {
+    }
+
+    @Override
+    public void writeProcessingInstruction(String target, String data) throws XMLStreamException {
+    }
+
+    @Override
+    public void writeCData(String data) throws XMLStreamException {
+        writeCharacters(data);
+    }
+
+    @Override
+    public void writeDTD(String dtd) throws XMLStreamException {
+    }
+
+    @Override
+    public void writeEntityRef(String name) throws XMLStreamException {
+    }
+
+    @Override
+    public void writeStartDocument() throws XMLStreamException {
+        writeStartDocument(null);
+    }
+
+    @Override
+    public void writeStartDocument(String version) throws XMLStreamException {
+        writeStartDocument(null, version);
+    }
+
+    @Override
+    public void writeStartDocument(String encoding, String version) throws XMLStreamException {
+        final TreeElement treeElement = new TreeElement(null, XMLEvent.START_DOCUMENT, JsonToken.NOT_AVAILABLE);
+        this.treeRoot = treeElement;
+        this.currentTreeElement = treeElement;
+    }
+
+    @Override
+    public void writeCharacters(String text) throws XMLStreamException {
+        // check for non coalescing read
+        final List<TreeElement> childs = currentTreeElement.childs;
+        if (childs.size() > 0) {
+            final TreeElement child = childs.get(childs.size() - 1);
+            if (child.getXmlEvent() == XMLEvent.CHARACTERS) {
+                child.appendValue(text);
+
+                return;
+            }
+        }
+
+        final TreeElement treeElement = new TreeElement(currentTreeElement, XMLEvent.CHARACTERS, JsonToken.VALUE_STRING);
+        treeElement.setValue(text);
+
+        currentTreeElement.addChild(treeElement);
+    }
+
+    @Override
+    public void writeCharacters(char[] text, int start, int len) throws XMLStreamException {
+        writeCharacters(new String(text, start, len));
+    }
+
+    @Override
+    public String getPrefix(String uri) throws XMLStreamException {
+        return null;
+    }
+
+    @Override
+    public void setPrefix(String prefix, String uri) throws XMLStreamException {
+    }
+
+    @Override
+    public void setDefaultNamespace(String uri) throws XMLStreamException {
+    }
+
+    @Override
+    public void setNamespaceContext(NamespaceContext context) throws XMLStreamException {
+    }
+
+    @Override
+    public NamespaceContext getNamespaceContext() {
+        throw new UnsupportedOperationException(XJConstants.UNSUPPORTED_OPERATION_EXCEPTION_MESSAGE);
+    }
+
+    @Override
+    public Object getProperty(String name) throws IllegalArgumentException {
+        throw new IllegalArgumentException(name + "" unsupported"");
+    }
+
+
+    private static class TreeElement {
+
+        private TreeElement parent;
+        private List<TreeElement> childs = Collections.emptyList();
+
+        private String name;
+        private String value;
+        private int xmlEvent;
+        private JsonToken jsonToken;
+
+        TreeElement(TreeElement parent, int xmlEvent, String name) {
+            this.parent = parent;
+            this.xmlEvent = xmlEvent;
+            this.name = name;
+        }
+
+        TreeElement(TreeElement parent, int xmlEvent, JsonToken jsonToken) {
+            this.parent = parent;
+            this.xmlEvent = xmlEvent;
+            this.jsonToken = jsonToken;
+        }
+
+        TreeElement(TreeElement parent, int xmlEvent, JsonToken jsonToken, String name) {
+            this.parent = parent;
+            this.xmlEvent = xmlEvent;
+            this.jsonToken = jsonToken;
+            this.name = name;
+        }
+
+        int getXmlEvent() {
+            return this.xmlEvent;
+        }
+
+        void addChild(TreeElement treeElement) {
+            if (this.childs == Collections.EMPTY_LIST) {
+                this.childs = new ArrayList<>(1);
+            }
+
+            this.childs.add(treeElement);
+        }
+
+        void setJsonToken(JsonToken jsonToken) {
+            if (this.jsonToken == null) {
+                this.jsonToken = jsonToken;
+            }
+        }
+
+        void setName(String name) {
+            this.name = name;
+        }
+
+        void setValue(String value) {
+            this.value = value;
+        }
+
+        void appendValue(String value) {
+            this.value += value;
+        }
+
+        void writeEnd() throws IOException {
+            if (jsonToken == null) {
+                writeEndNoTypeHints();
+            } else { // type hints
+                // move type hints
+                writeEndHaveTypeHints();
+            }
+        }
+
+        private void writeEndNoTypeHints() {
+            switch (xmlEvent) {
+                case XMLEvent.START_ELEMENT:
+                    if (childs.isEmpty()) {
+                        // empty root element
+                        if (this.parent.jsonToken == JsonToken.NOT_AVAILABLE) {
+                            jsonToken = JsonToken.START_OBJECT;
+                        } else {
+                            jsonToken = JsonToken.FIELD_NAME;
+
+                            final TreeElement treeElement = new TreeElement(this, -1, JsonToken.VALUE_STRING);
+                            treeElement.setValue("""");
+                            this.addChild(treeElement);
+                        }
+                    } else if (childs.size() == 1 && childs.get(0).xmlEvent == XMLEvent.CHARACTERS) {
+                        // just character childs.
+
+                        // empty root element
+                        if (this.parent.jsonToken == JsonToken.NOT_AVAILABLE) {
+                            jsonToken = JsonToken.START_OBJECT;
+
+                            final TreeElement child = childs.get(0);
+                            if (isWhitespace(child.value)) {
+                                childs.remove(0);
+                            } else {
+                                // create new intermediary element
+                                final TreeElement treeElement = new TreeElement(this, -1, JsonToken.FIELD_NAME, JSON_MIXED_CONTENT_TEXT_KEY);
+                                treeElement.addChild(child);
+                                childs.set(childs.indexOf(child), treeElement);
+                                child.parent = treeElement;
+                            }
+                        } else {
+                            jsonToken = JsonToken.FIELD_NAME;
+                        }
+                    } else {
+                        // mixed content fixup.
+                        final Iterator<TreeElement> iterator = childs.iterator();
+                        while (iterator.hasNext()) {
+                            TreeElement element = iterator.next();
+                            if (element.jsonToken == JsonToken.VALUE_STRING) {
+                                if (isWhitespace(element.value)) {
+                                    // remove element if is (ignorable-) whitespace
+                                    iterator.remove();
+                                } else {
+                                    // create new intermediary element
+                                    final TreeElement treeElement = new TreeElement(this, -1, JsonToken.FIELD_NAME,
+                                            element.name != null ? element.name : JSON_MIXED_CONTENT_TEXT_KEY);
+                                    treeElement.addChild(element);
+                                    childs.set(childs.indexOf(element), treeElement);
+                                    element.parent = treeElement;
+                                    element.jsonToken = JsonToken.VALUE_STRING;
+                                }
+                            }
+                        }
+
+                        jsonToken = JsonToken.START_OBJECT;
+
+                        final Map<String, Set<TreeElement>> childElementsMap = childs.stream()
+                                .collect(Collectors.groupingBy(o -> o.name, HashMap::new, Collectors.toCollection(LinkedHashSet::new)));
+
+                        // create arrays if element with the same name occurs more than once.
+                        for (Map.Entry<String, Set<TreeElement>> mapEntry : childElementsMap.entrySet()) {","[{'comment': 'Lines 382-403 are exactly same as lines 457-479.  And the 511-524 are pretty much similar. Is it possible to refactor to single method?', 'commenter': 'bedlaj'}]"
3093,components/camel-xj/src/main/java/org/apache/camel/component/xj/XmlSourceHandlerFactoryImpl.java,"@@ -0,0 +1,150 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.xj;
+
+import org.apache.camel.Exchange;
+import org.apache.camel.ExpectedBodyTypeException;
+import org.apache.camel.RuntimeTransformException;
+import org.apache.camel.TypeConverter;
+import org.apache.camel.support.builder.xml.XMLConverterHelper;
+import org.w3c.dom.Node;
+
+import javax.xml.parsers.ParserConfigurationException;
+import javax.xml.transform.Source;
+import javax.xml.transform.TransformerException;
+import javax.xml.transform.dom.DOMSource;
+import javax.xml.transform.sax.SAXSource;
+import javax.xml.transform.stax.StAXSource;
+import javax.xml.transform.stream.StreamSource;
+import java.io.InputStream;
+
+public class XmlSourceHandlerFactoryImpl implements SourceHandlerFactory {
+
+    private XMLConverterHelper converter = new XMLConverterHelper();
+    private boolean isFailOnNullBody = true;
+
+    public void setFailOnNullBody(boolean failOnNullBody) {
+        isFailOnNullBody = failOnNullBody;
+    }
+
+    public boolean isFailOnNullBody() {
+        return isFailOnNullBody;
+    }
+
+    @Override
+    public Source getSource(Exchange exchange) throws Exception {
+        // only convert to input stream if really needed
+        if (isInputStreamNeeded(exchange)) {
+            InputStream is = exchange.getIn().getBody(InputStream.class);
+            return getSource(exchange, is);
+        } else {
+            Object body = exchange.getIn().getBody();
+            return getSource(exchange, body);
+        }
+    }
+
+    /**
+     * Checks whether we need an {@link InputStream} to access the message body.
+     * <p/>
+     * Depending on the content in the message body, we may not need to convert
+     * to {@link InputStream}.
+     *
+     * @param exchange the current exchange
+     * @return <tt>true</tt> to convert to {@link InputStream} beforehand converting to {@link Source} afterwards.
+     */
+    protected boolean isInputStreamNeeded(Exchange exchange) {
+        Object body = exchange.getIn().getBody();","[{'comment': 'Lines 70-90 and 450-470 are copy-pasted. Is it possible to refactor this to method?', 'commenter': 'bedlaj'}]"
3093,components/camel-xj/src/main/java/org/apache/camel/component/xj/XmlSourceHandlerFactoryImpl.java,"@@ -0,0 +1,150 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.xj;
+
+import org.apache.camel.Exchange;
+import org.apache.camel.ExpectedBodyTypeException;
+import org.apache.camel.RuntimeTransformException;
+import org.apache.camel.TypeConverter;
+import org.apache.camel.support.builder.xml.XMLConverterHelper;
+import org.w3c.dom.Node;
+
+import javax.xml.parsers.ParserConfigurationException;
+import javax.xml.transform.Source;
+import javax.xml.transform.TransformerException;
+import javax.xml.transform.dom.DOMSource;
+import javax.xml.transform.sax.SAXSource;
+import javax.xml.transform.stax.StAXSource;
+import javax.xml.transform.stream.StreamSource;
+import java.io.InputStream;
+
+public class XmlSourceHandlerFactoryImpl implements SourceHandlerFactory {
+
+    private XMLConverterHelper converter = new XMLConverterHelper();
+    private boolean isFailOnNullBody = true;
+
+    public void setFailOnNullBody(boolean failOnNullBody) {
+        isFailOnNullBody = failOnNullBody;
+    }
+
+    public boolean isFailOnNullBody() {
+        return isFailOnNullBody;
+    }
+
+    @Override
+    public Source getSource(Exchange exchange) throws Exception {
+        // only convert to input stream if really needed
+        if (isInputStreamNeeded(exchange)) {
+            InputStream is = exchange.getIn().getBody(InputStream.class);
+            return getSource(exchange, is);
+        } else {
+            Object body = exchange.getIn().getBody();
+            return getSource(exchange, body);
+        }
+    }
+
+    /**
+     * Checks whether we need an {@link InputStream} to access the message body.
+     * <p/>
+     * Depending on the content in the message body, we may not need to convert
+     * to {@link InputStream}.
+     *
+     * @param exchange the current exchange
+     * @return <tt>true</tt> to convert to {@link InputStream} beforehand converting to {@link Source} afterwards.
+     */
+    protected boolean isInputStreamNeeded(Exchange exchange) {
+        Object body = exchange.getIn().getBody();
+        if (body == null) {
+            return false;
+        }
+
+        if (body instanceof InputStream) {
+            return true;
+        } else if (body instanceof Source) {
+            return false;
+        } else if (body instanceof String) {
+            return false;
+        } else if (body instanceof byte[]) {
+            return false;
+        } else if (body instanceof Node) {
+            return false;
+        } else if (exchange.getContext().getTypeConverterRegistry().lookup(Source.class, body.getClass()) != null) {
+            //there is a direct and hopefully optimized converter to Source
+            return false;
+        }
+        // yes an input stream is needed
+        return true;
+    }
+
+    /**
+     * Converts the inbound body to a {@link Source}, if the body is <b>not</b> already a {@link Source}.
+     * <p/>
+     * This implementation will prefer to source in the following order:
+     * <ul>
+     *   <li>StAX - If StAX is allowed</li>
+     *   <li>SAX - SAX as 2nd choice</li>
+     *   <li>Stream - Stream as 3rd choice</li>
+     *   <li>DOM - DOM as 4th choice</li>
+     * </ul>
+     */
+    protected Source getSource(Exchange exchange, Object body) {
+        // body may already be a source
+        if (body instanceof Source) {
+            return (Source) body;
+        }
+        Source source = null;
+        if (body != null) {
+            // try StAX if enabled
+            source = exchange.getContext().getTypeConverter().tryConvertTo(StAXSource.class, exchange, body);
+
+            if (source == null) {","[{'comment': 'Lines 114-125 and 386-397 are copy-pasted. Is it possible to refactor this to method?', 'commenter': 'bedlaj'}]"
3093,components/camel-xj/src/main/java/org/apache/camel/component/xj/XsltBuilder.java,"@@ -0,0 +1,482 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.xj;
+
+import org.apache.camel.Exchange;
+import org.apache.camel.Message;
+import org.apache.camel.Processor;
+import org.apache.camel.component.xslt.*;
+import org.apache.camel.support.ExchangeHelper;
+import org.apache.camel.support.SynchronizationAdapter;
+import org.apache.camel.support.builder.xml.XMLConverterHelper;
+import org.apache.camel.util.FileUtil;
+import org.apache.camel.util.IOHelper;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import org.xml.sax.EntityResolver;
+
+import javax.xml.transform.*;
+import javax.xml.transform.sax.SAXSource;
+import javax.xml.transform.stream.StreamSource;
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.URL;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.ArrayBlockingQueue;
+import java.util.concurrent.BlockingQueue;
+
+import static org.apache.camel.util.ObjectHelper.notNull;
+
+// todo?: This class is just a copy from the XsltComponent because of minor but important different requirements. Refactoring of XsltComponent so that we can extend it?
+
+/**
+ * Creates a <a href=""http://camel.apache.org/processor.html"">Processor</a>
+ * which performs an XSLT transformation of the IN message body.
+ * <p/>
+ * Will by default output the result as a String. You can chose which kind of output
+ * you want using the <tt>outputXXX</tt> methods.
+ */
+public class XsltBuilder implements Processor {
+
+    private static final Logger LOG = LoggerFactory.getLogger(XsltBuilder.class);
+    private Map<String, Object> parameters = new HashMap<>();
+    private XMLConverterHelper converter = new XMLConverterHelper();
+    private Templates template;
+    private volatile BlockingQueue<Transformer> transformers;
+    private SourceHandlerFactory sourceHandlerFactory;
+    private ResultHandlerFactory resultHandlerFactory = new StringResultHandlerFactory();
+    private boolean failOnNullBody = true;
+    private URIResolver uriResolver;
+    private boolean deleteOutputFile;
+    private ErrorListener errorListener;
+    private boolean allowStAX = true;
+    private EntityResolver entityResolver;
+
+    public XsltBuilder() {
+    }
+
+    public XsltBuilder(Templates templates) {
+        this.template = templates;
+    }
+
+    @Override
+    public String toString() {
+        return ""XSLT["" + template + ""]"";
+    }
+
+    @Override
+    public void process(Exchange exchange) throws Exception {
+        notNull(getTemplate(), ""template"");
+
+        if (isDeleteOutputFile()) {
+            // add on completion so we can delete the file when the Exchange is done
+            String fileName = ExchangeHelper.getMandatoryHeader(exchange, Exchange.XSLT_FILE_NAME, String.class);
+            exchange.addOnCompletion(new XsltBuilderOnCompletion(fileName));
+        }
+
+        Transformer transformer = getTransformer();
+        configureTransformer(transformer, exchange);
+
+        ResultHandler resultHandler = resultHandlerFactory.createResult(exchange);
+        Result result = resultHandler.getResult();
+        // let's copy the headers before we invoke the transform in case they modify them
+        Message out = exchange.getOut();
+        out.copyFrom(exchange.getIn());
+
+        // the underlying input stream, which we need to close to avoid locking files or other resources
+        InputStream is = null;","[{'comment': 'This is just initialized to null and then is this null closed. This doesnt seem correct.', 'commenter': 'bedlaj'}]"
3093,components/camel-xj/src/main/java/org/apache/camel/component/xj/JsonXmlStreamReader.java,"@@ -0,0 +1,605 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.camel.component.xj;
+
+import com.fasterxml.jackson.core.JsonParser;
+import com.fasterxml.jackson.core.JsonToken;
+
+import javax.xml.namespace.NamespaceContext;
+import javax.xml.namespace.QName;
+import javax.xml.stream.Location;
+import javax.xml.stream.XMLStreamException;
+import javax.xml.stream.XMLStreamReader;
+import javax.xml.stream.events.XMLEvent;
+import java.io.IOException;
+import java.util.*;
+import java.util.stream.Collectors;
+
+/**
+ * XML Json bridge. Explicitly using XMLStreamReader and not XMLEventReader because saxon wants that.
+ */
+public class JsonXmlStreamReader implements XMLStreamReader {
+
+    private static final Location LOCATION = new Location() {
+        @Override
+        public int getLineNumber() {
+            return -1;
+        }
+
+        @Override
+        public int getColumnNumber() {
+            return -1;
+        }
+
+        @Override
+        public int getCharacterOffset() {
+            return -1;
+        }
+
+        @Override
+        public String getPublicId() {
+            return null;
+        }
+
+        @Override
+        public String getSystemId() {
+            return null;
+        }
+    };
+
+    private final JsonParser jsonParser;
+
+    private Deque<StackElement> tokenStack = new ArrayDeque<>();
+    private boolean eof = false;
+
+    public JsonXmlStreamReader(JsonParser jsonParser) {
+        this.jsonParser = jsonParser;
+    }
+
+    @Override
+    public Object getProperty(String name) throws IllegalArgumentException {
+        return null;
+    }
+
+    @Override
+    public int next() throws XMLStreamException {
+        try {
+            final StackElement previousElement = tokenStack.peek();
+            if (previousElement != null) {
+                switch (previousElement.jsonToken) {
+                    case VALUE_STRING:
+                    case VALUE_NUMBER_INT:
+                    case VALUE_NUMBER_FLOAT:
+                    case VALUE_NULL:
+                    case VALUE_TRUE:
+                    case VALUE_FALSE: {
+                        switch (previousElement.xmlEvent) {
+                            case XMLEvent.START_ELEMENT:
+                                previousElement.xmlEvent = XMLEvent.CHARACTERS;
+                                return XMLEvent.CHARACTERS;
+
+                            case XMLEvent.CHARACTERS:
+                                removeStackElement(previousElement.jsonToken);
+                                removeStackElement(JsonToken.FIELD_NAME);
+
+                                tokenStack.peek().xmlEvent = XMLEvent.END_ELEMENT;
+                                return XMLEvent.END_ELEMENT;
+
+                            default:
+                                throw new IllegalStateException(""illegal state"");
+                        }
+                    }
+                }
+            }
+
+            if (eof) {
+                return END_DOCUMENT;
+            }
+
+            JsonToken currentToken = jsonParser.nextToken();
+            if (currentToken == null) {
+                throw new IllegalStateException(""End of document"");
+            }
+
+            StackElement stackElement = new StackElement(currentToken, toXmlString(jsonParser.getCurrentName()));
+            tokenStack.push(stackElement);
+
+            if (currentToken == JsonToken.FIELD_NAME) {
+                currentToken = jsonParser.nextToken();
+
+                stackElement = new StackElement(currentToken, toXmlString(jsonParser.getCurrentName()));
+                tokenStack.push(stackElement);
+            }
+
+            switch (currentToken) {","[{'comment': 'this switch can be a bit simplified\r\n```suggestion\r\n            switch (currentToken) {\r\n                case START_OBJECT:\r\n                case START_ARRAY:\r\n                case VALUE_STRING:\r\n                case VALUE_NUMBER_INT:\r\n                case VALUE_NUMBER_FLOAT:\r\n                case VALUE_NULL:\r\n                case VALUE_TRUE:\r\n                case VALUE_FALSE:\r\n                    stackElement.xmlEvent = XMLEvent.START_ELEMENT;\r\n\r\n                    return XMLEvent.START_ELEMENT;\r\n                case END_OBJECT:\r\n                    removeStackElement(JsonToken.END_OBJECT);\r\n                    removeStackElement(JsonToken.START_OBJECT);\r\n                    removeStackElement(JsonToken.FIELD_NAME);\r\n                    eof = tokenStack.size() == 0;\r\n\r\n                    return XMLEvent.END_ELEMENT;\r\n                case END_ARRAY:\r\n                    removeStackElement(JsonToken.END_ARRAY);\r\n                    removeStackElement(JsonToken.START_ARRAY);\r\n                    removeStackElement(JsonToken.FIELD_NAME);\r\n                    eof = tokenStack.size() == 0;\r\n\r\n                    return XMLEvent.END_ELEMENT;\r\n\r\n                default:\r\n                    throw new IllegalStateException(""JsonToken: "" + currentToken);\r\n            }\r\n```', 'commenter': 'bedlaj'}]"
3093,components/camel-xj/src/main/java/org/apache/camel/component/xj/XmlJsonStreamWriter.java,"@@ -0,0 +1,640 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.camel.component.xj;
+
+import com.fasterxml.jackson.core.JsonGenerator;
+import com.fasterxml.jackson.core.JsonToken;
+
+import javax.xml.namespace.NamespaceContext;
+import javax.xml.stream.XMLStreamException;
+import javax.xml.stream.XMLStreamWriter;
+import javax.xml.stream.events.XMLEvent;
+import java.io.IOException;
+import java.util.*;
+import java.util.stream.Collectors;
+
+/**
+ * XML Json bridge. Explicitly using StreamWriter and not XMLEventWriter because saxon wants that.
+ */
+public class XmlJsonStreamWriter implements XMLStreamWriter {
+
+    private static final String JSON_MIXED_CONTENT_TEXT_KEY = ""#text"";
+
+    private final JsonGenerator jsonGenerator;
+
+    private TreeElement treeRoot;
+    private TreeElement currentTreeElement;
+
+    public XmlJsonStreamWriter(JsonGenerator jsonGenerator) {
+        this.jsonGenerator = jsonGenerator;
+    }
+
+    @Override
+    public void writeStartElement(String localName) throws XMLStreamException {
+        writeStartElement(null, localName, null);
+    }
+
+    @Override
+    public void writeStartElement(String namespaceURI, String localName) throws XMLStreamException {
+        writeStartElement(null, localName, namespaceURI);
+    }
+
+    @Override
+    public void writeStartElement(String prefix, String localName, String namespaceURI) throws XMLStreamException {
+        final TreeElement treeElement = new TreeElement(currentTreeElement, XMLEvent.START_ELEMENT, localName);
+
+        currentTreeElement.addChild(treeElement);
+        currentTreeElement = treeElement;
+    }
+
+    @Override
+    public void writeEmptyElement(String namespaceURI, String localName) throws XMLStreamException {
+        writeStartElement(null, namespaceURI, localName);
+        writeEndElement();
+    }
+
+    @Override
+    public void writeEmptyElement(String prefix, String localName, String namespaceURI) throws XMLStreamException {
+        writeStartElement(prefix, localName, namespaceURI);
+        writeEndElement();
+    }
+
+    @Override
+    public void writeEmptyElement(String localName) throws XMLStreamException {
+        writeStartElement(null, localName, null);
+        writeEndElement();
+    }
+
+    @Override
+    public void writeEndElement() throws XMLStreamException {
+        try {
+            currentTreeElement.writeEnd();
+        } catch (IOException e) {
+            throw new XMLStreamException(e);
+        }
+        currentTreeElement = currentTreeElement.parent;
+    }
+
+    @Override
+    public void writeEndDocument() throws XMLStreamException {
+        try {
+            treeRoot.write(jsonGenerator);
+        } catch (IOException e) {
+            throw new XMLStreamException(e);
+        }
+    }
+
+    @Override
+    public void close() throws XMLStreamException {
+        try {
+            jsonGenerator.close();
+        } catch (IOException e) {
+            throw new XMLStreamException(e);
+        }
+    }
+
+    @Override
+    public void flush() throws XMLStreamException {
+        try {
+            jsonGenerator.flush();
+        } catch (IOException e) {
+            throw new XMLStreamException(e);
+        }
+    }
+
+    @Override
+    public void writeAttribute(String localName, String value) throws XMLStreamException {
+        writeAttribute(null, null, localName, value);
+    }
+
+    @Override
+    public void writeAttribute(String prefix, String namespaceURI, String localName, String value) throws XMLStreamException {
+        if (XJConstants.NS_XJ.equals(namespaceURI)) {
+            switch (localName) {
+                case XJConstants.TYPE_HINT_NAME:
+                    currentTreeElement.setName(value);
+                    return;
+                case XJConstants.TYPE_HINT_TYPE:
+                    currentTreeElement.setJsonToken(XJConstants.TYPE_JSONTYPE_MAP.get(value));
+                    return;
+            }
+
+            return;
+        }
+
+        final TreeElement treeElement = new TreeElement(currentTreeElement, XMLEvent.ATTRIBUTE, JsonToken.VALUE_STRING, localName);
+        treeElement.setValue(value);
+
+        currentTreeElement.addChild(treeElement);
+    }
+
+    @Override
+    public void writeAttribute(String namespaceURI, String localName, String value) throws XMLStreamException {
+        writeAttribute(null, namespaceURI, localName, value);
+    }
+
+    @Override
+    public void writeNamespace(String prefix, String namespaceURI) throws XMLStreamException {
+    }
+
+    @Override
+    public void writeDefaultNamespace(String namespaceURI) throws XMLStreamException {
+    }
+
+    @Override
+    public void writeComment(String data) throws XMLStreamException {
+    }
+
+    @Override
+    public void writeProcessingInstruction(String target) throws XMLStreamException {
+    }
+
+    @Override
+    public void writeProcessingInstruction(String target, String data) throws XMLStreamException {
+    }
+
+    @Override
+    public void writeCData(String data) throws XMLStreamException {
+        writeCharacters(data);
+    }
+
+    @Override
+    public void writeDTD(String dtd) throws XMLStreamException {
+    }
+
+    @Override
+    public void writeEntityRef(String name) throws XMLStreamException {
+    }
+
+    @Override
+    public void writeStartDocument() throws XMLStreamException {
+        writeStartDocument(null);
+    }
+
+    @Override
+    public void writeStartDocument(String version) throws XMLStreamException {
+        writeStartDocument(null, version);
+    }
+
+    @Override
+    public void writeStartDocument(String encoding, String version) throws XMLStreamException {
+        final TreeElement treeElement = new TreeElement(null, XMLEvent.START_DOCUMENT, JsonToken.NOT_AVAILABLE);
+        this.treeRoot = treeElement;
+        this.currentTreeElement = treeElement;
+    }
+
+    @Override
+    public void writeCharacters(String text) throws XMLStreamException {
+        // check for non coalescing read
+        final List<TreeElement> childs = currentTreeElement.childs;
+        if (childs.size() > 0) {
+            final TreeElement child = childs.get(childs.size() - 1);
+            if (child.getXmlEvent() == XMLEvent.CHARACTERS) {
+                child.appendValue(text);
+
+                return;
+            }
+        }
+
+        final TreeElement treeElement = new TreeElement(currentTreeElement, XMLEvent.CHARACTERS, JsonToken.VALUE_STRING);
+        treeElement.setValue(text);
+
+        currentTreeElement.addChild(treeElement);
+    }
+
+    @Override
+    public void writeCharacters(char[] text, int start, int len) throws XMLStreamException {
+        writeCharacters(new String(text, start, len));
+    }
+
+    @Override
+    public String getPrefix(String uri) throws XMLStreamException {
+        return null;
+    }
+
+    @Override
+    public void setPrefix(String prefix, String uri) throws XMLStreamException {
+    }
+
+    @Override
+    public void setDefaultNamespace(String uri) throws XMLStreamException {
+    }
+
+    @Override
+    public void setNamespaceContext(NamespaceContext context) throws XMLStreamException {
+    }
+
+    @Override
+    public NamespaceContext getNamespaceContext() {
+        throw new UnsupportedOperationException(XJConstants.UNSUPPORTED_OPERATION_EXCEPTION_MESSAGE);
+    }
+
+    @Override
+    public Object getProperty(String name) throws IllegalArgumentException {
+        throw new IllegalArgumentException(name + "" unsupported"");
+    }
+
+
+    private static class TreeElement {
+
+        private TreeElement parent;
+        private List<TreeElement> childs = Collections.emptyList();
+
+        private String name;
+        private String value;
+        private int xmlEvent;
+        private JsonToken jsonToken;
+
+        TreeElement(TreeElement parent, int xmlEvent, String name) {
+            this.parent = parent;
+            this.xmlEvent = xmlEvent;
+            this.name = name;
+        }
+
+        TreeElement(TreeElement parent, int xmlEvent, JsonToken jsonToken) {
+            this.parent = parent;
+            this.xmlEvent = xmlEvent;
+            this.jsonToken = jsonToken;
+        }
+
+        TreeElement(TreeElement parent, int xmlEvent, JsonToken jsonToken, String name) {
+            this.parent = parent;
+            this.xmlEvent = xmlEvent;
+            this.jsonToken = jsonToken;
+            this.name = name;
+        }
+
+        int getXmlEvent() {
+            return this.xmlEvent;
+        }
+
+        void addChild(TreeElement treeElement) {
+            if (this.childs == Collections.EMPTY_LIST) {
+                this.childs = new ArrayList<>(1);
+            }
+
+            this.childs.add(treeElement);
+        }
+
+        void setJsonToken(JsonToken jsonToken) {
+            if (this.jsonToken == null) {
+                this.jsonToken = jsonToken;
+            }
+        }
+
+        void setName(String name) {
+            this.name = name;
+        }
+
+        void setValue(String value) {
+            this.value = value;
+        }
+
+        void appendValue(String value) {
+            this.value += value;
+        }
+
+        void writeEnd() throws IOException {
+            if (jsonToken == null) {
+                writeEndNoTypeHints();
+            } else { // type hints
+                // move type hints
+                writeEndHaveTypeHints();
+            }
+        }
+
+        private void writeEndNoTypeHints() {
+            switch (xmlEvent) {
+                case XMLEvent.START_ELEMENT:","[{'comment': 'This switch have just one label and default. It would be better change to if-else;', 'commenter': 'bedlaj'}]"
3100,components/camel-pulsar/src/main/java/org/apache/camel/component/pulsar/PulsarProducer.java,"@@ -20,11 +20,14 @@
 import org.apache.camel.Message;
 import org.apache.camel.NoTypeConversionAvailableException;
 import org.apache.camel.TypeConversionException;
+import org.apache.camel.component.pulsar.configuration.PulsarConfiguration;
 import org.apache.camel.component.pulsar.utils.message.PulsarMessageUtils;
 import org.apache.camel.support.DefaultProducer;
 import org.apache.pulsar.client.api.Producer;
 import org.apache.pulsar.client.api.ProducerBuilder;
 
+import java.util.concurrent.TimeUnit;","[{'comment': 'Please run the sourcecheck profile. It will return warnings', 'commenter': 'oscerd'}, {'comment': 'I ran the sourcecheck profile and it showed no errors.', 'commenter': 'rshermanTHG'}, {'comment': ""I reran and found the errors, but as they don't break the build and had scrolled off the screen I accepted the build completing successfully as a thumbs up. Will now fix."", 'commenter': 'rshermanTHG'}]"
3100,components/camel-pulsar/src/main/java/org/apache/camel/component/pulsar/configuration/PulsarConfiguration.java,"@@ -19,6 +19,9 @@
 import org.apache.camel.component.pulsar.utils.consumers.SubscriptionType;
 import org.apache.camel.spi.UriParam;
 import org.apache.camel.spi.UriParams;
+import org.apache.pulsar.client.api.CompressionType;
+
+import java.util.concurrent.TimeUnit;","[{'comment': 'Ditto', 'commenter': 'oscerd'}]"
3110,components/camel-aws-ddb/src/main/java/org/apache/camel/component/aws/ddb/DdbComponentVerifierExtension.java,"@@ -46,11 +46,18 @@ public DdbComponentVerifierExtension(String scheme) {
     // Parameters validation
     // *********************************
 
+
+    /**
+     * Basic check of the parameters (they are not empty)
+     *
+     * @param parameters
+     * @return
+     */
     @Override
     protected Result verifyParameters(Map<String, Object> parameters) {
 
         ResultBuilder builder = ResultBuilder.withStatusAndScope(Result.Status.OK, Scope.PARAMETERS).error(ResultErrorHelper.requiresOption(""accessKey"", parameters))
-            .error(ResultErrorHelper.requiresOption(""secretKey"", parameters)).error(ResultErrorHelper.requiresOption(""region"", parameters));
+                .error(ResultErrorHelper.requiresOption(""secretKey"", parameters)).error(ResultErrorHelper.requiresOption(""region"", parameters));","[{'comment': 'Please run the build with the Profile sourcecheck enabled. It will return some warnings about code style.', 'commenter': 'oscerd'}, {'comment': ""The whitespaces shouldn't be there, I know, but the checkstyle does not complaint (see next comment)"", 'commenter': 'Delawen'}]"
3110,components/camel-aws-ddb/src/main/java/org/apache/camel/component/aws/ddb/DdbComponentVerifierExtension.java,"@@ -75,11 +89,11 @@ protected Result verifyConnectivity(Map<String, Object> parameters) {
             client.listTables();
         } catch (SdkClientException e) {
             ResultErrorBuilder errorBuilder = ResultErrorBuilder.withCodeAndDescription(VerificationError.StandardCode.AUTHENTICATION, e.getMessage())
-                .detail(""aws_ddb_exception_message"", e.getMessage()).detail(VerificationError.ExceptionAttribute.EXCEPTION_CLASS, e.getClass().getName())
-                .detail(VerificationError.ExceptionAttribute.EXCEPTION_INSTANCE, e);
+                    .detail(""aws_ddb_exception_message"", e.getMessage()).detail(VerificationError.ExceptionAttribute.EXCEPTION_CLASS, e.getClass().getName())","[{'comment': 'Same.', 'commenter': 'oscerd'}, {'comment': 'My ""mvn clean package install -Psourcecheck"" does not complain about this:\r\n\r\n> [INFO] --- maven-checkstyle-plugin:3.0.0:checkstyle (default-cli) @ camel-aws-ddb ---\r\n> [INFO] Starting audit...\r\n> Audit done.\r\n> [INFO] \r\n\r\nMaybe some other checkstyle to check? (I could fix that manually, but I want to learn for future PR how to detect that)\r\n', 'commenter': 'Delawen'}, {'comment': ""This is my fault, since this is a builder, there shouldn't be any warning."", 'commenter': 'oscerd'}]"
3110,components/camel-aws-ddb/src/main/java/org/apache/camel/component/aws/ddb/DdbComponentVerifierExtension.java,"@@ -75,11 +89,11 @@ protected Result verifyConnectivity(Map<String, Object> parameters) {
             client.listTables();
         } catch (SdkClientException e) {
             ResultErrorBuilder errorBuilder = ResultErrorBuilder.withCodeAndDescription(VerificationError.StandardCode.AUTHENTICATION, e.getMessage())
-                .detail(""aws_ddb_exception_message"", e.getMessage()).detail(VerificationError.ExceptionAttribute.EXCEPTION_CLASS, e.getClass().getName())
-                .detail(VerificationError.ExceptionAttribute.EXCEPTION_INSTANCE, e);
+                    .detail(""aws_ddb_exception_message"", e.getMessage()).detail(VerificationError.ExceptionAttribute.EXCEPTION_CLASS, e.getClass().getName())
+                    .detail(VerificationError.ExceptionAttribute.EXCEPTION_INSTANCE, e);
 
             builder.error(errorBuilder.build());
-        } catch (Exception e) {
+        } catch (@SuppressWarnings(""PMD.AvoidCatchingGenericException"") Exception e) {","[{'comment': 'No need for suppressWarnings in Camel project', 'commenter': 'oscerd'}]"
3110,components/camel-aws-ddb/src/test/java/org/apache/camel/component/aws/ddb/integration/DdbComponentIntegrationTest.java,"@@ -16,44 +16,114 @@
  */
 package org.apache.camel.component.aws.ddb.integration;
 
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-
+import com.amazonaws.regions.Regions;
 import com.amazonaws.services.dynamodbv2.model.AttributeValue;
-
-import org.apache.camel.EndpointInject;
+import com.amazonaws.services.dynamodbv2.model.ExpectedAttributeValue;
 import org.apache.camel.Exchange;
 import org.apache.camel.Processor;
-import org.apache.camel.ProducerTemplate;
 import org.apache.camel.builder.RouteBuilder;
 import org.apache.camel.component.aws.ddb.DdbConstants;
 import org.apache.camel.component.aws.ddb.DdbOperations;
 import org.apache.camel.test.junit4.CamelTestSupport;
 import org.junit.Ignore;
 import org.junit.Test;
 
-@Ignore(""Must be manually tested. Provide your own accessKey and secretKey!"")
+import java.util.HashMap;","[{'comment': 'Codestyle issue.', 'commenter': 'oscerd'}]"
3110,components/camel-aws-ddb/src/test/java/org/apache/camel/component/aws/ddb/integration/DdbComponentIntegrationTest.java,"@@ -16,44 +16,114 @@
  */
 package org.apache.camel.component.aws.ddb.integration;
 
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-
+import com.amazonaws.regions.Regions;
 import com.amazonaws.services.dynamodbv2.model.AttributeValue;
-
-import org.apache.camel.EndpointInject;
+import com.amazonaws.services.dynamodbv2.model.ExpectedAttributeValue;
 import org.apache.camel.Exchange;
 import org.apache.camel.Processor;
-import org.apache.camel.ProducerTemplate;
 import org.apache.camel.builder.RouteBuilder;
 import org.apache.camel.component.aws.ddb.DdbConstants;
 import org.apache.camel.component.aws.ddb.DdbOperations;
 import org.apache.camel.test.junit4.CamelTestSupport;
 import org.junit.Ignore;
 import org.junit.Test;
 
-@Ignore(""Must be manually tested. Provide your own accessKey and secretKey!"")
+import java.util.HashMap;
+import java.util.Map;
+
+@Ignore(""Must be manually tested. Provide your own ACCESS_KEY and SECRET_KEY!"")
 public class DdbComponentIntegrationTest extends CamelTestSupport {
 
-    @EndpointInject(""direct:start"")
-    private ProducerTemplate template;","[{'comment': 'This needs to stay there. Please add it again.', 'commenter': 'oscerd'}]"
3112,core/camel-base/src/main/java/org/apache/camel/impl/health/RouteHealthCheck.java,"@@ -84,21 +84,23 @@ protected void doCall(HealthCheckResultBuilder builder, Map<String, Object> opti
                 builder.up();
             }
 
-            if (builder.state() != State.DOWN) {
-                // If JMX is enabled, use the Managed MBeans to determine route
-                // health based on performance counters.
-                ManagedRouteMBean managedRoute = context.getExtension(ManagedCamelContext.class).getManagedRoute(route.getId());
+			if (builder.state() != State.DOWN) {","[{'comment': 'I think the indentation is wrong. Please run this with the profile sourcecheck enabled. You should see warnings.', 'commenter': 'oscerd'}, {'comment': ""OK, I'll update it"", 'commenter': 'pheaber'}, {'comment': ""I've run this from camel/core/camel-base but it's not reporting any errors. Is there something else I should check?\r\n`mvn clean install -Psourcecheck`"", 'commenter': 'pheaber'}, {'comment': ""Oh, I wasn't looking for warnings. I'll fix them now. Sorry for my confusion."", 'commenter': 'pheaber'}]"
3121,examples/camel-example-any23/pom.xml,"@@ -0,0 +1,66 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"">
+    <modelVersion>4.0.0</modelVersion>
+    <parent>
+        <groupId>org.apache.camel.example</groupId>
+        <artifactId>examples</artifactId>
+        <version>3.0.0-SNAPSHOT</version>
+    </parent>
+
+    <artifactId>camel-example-any23</artifactId>
+    <name>Camel :: Example :: Any23</name>
+    <description>An example that uses the Any23 dataformat</description>
+    <packaging>jar</packaging>
+    
+    
+    <properties>
+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
+        <camel.version>3.0.0-SNAPSHOT</camel.version>
+    </properties>
+    
+    
+    
+    <dependencies>
+        <dependency>
+            <groupId>org.apache.camel</groupId>
+            <artifactId>camel-core</artifactId>
+        </dependency>
+         <dependency>
+            <groupId>org.apache.camel</groupId>
+            <artifactId>camel-http</artifactId>
+        </dependency>
+        <dependency>
+            <groupId>org.apache.camel</groupId>
+            <artifactId>camel-management-impl</artifactId>
+        </dependency>
+        <dependency>
+            <groupId>org.apache.camel</groupId>
+            <artifactId>camel-any23</artifactId>
+        </dependency>
+        
+        <dependency>
+        <groupId>org.apache.camel</groupId>
+        <artifactId>camel-jsonpath</artifactId>
+        </dependency>","[{'comment': 'I dont see jsonpath used, is this dependency needed?', 'commenter': 'bedlaj'}]"
3121,examples/camel-example-any23/pom.xml,"@@ -0,0 +1,66 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"">
+    <modelVersion>4.0.0</modelVersion>
+    <parent>
+        <groupId>org.apache.camel.example</groupId>
+        <artifactId>examples</artifactId>
+        <version>3.0.0-SNAPSHOT</version>
+    </parent>
+
+    <artifactId>camel-example-any23</artifactId>
+    <name>Camel :: Example :: Any23</name>
+    <description>An example that uses the Any23 dataformat</description>
+    <packaging>jar</packaging>
+    
+    
+    <properties>
+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
+        <camel.version>3.0.0-SNAPSHOT</camel.version>","[{'comment': 'This property is unused', 'commenter': 'bedlaj'}]"
3121,examples/camel-example-any23/src/main/java/org/apache/camel/example/any23/Any23StartupMessage.java,"@@ -0,0 +1,34 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.example.any23;
+
+import org.apache.camel.CamelContext;
+import org.apache.camel.ProducerTemplate;
+import org.apache.camel.StartupListener;
+
+public class Any23StartupMessage implements StartupListener {
+
+  public Any23StartupMessage() {","[{'comment': 'This constructor is empty and thus can be removed.', 'commenter': 'bedlaj'}]"
3121,examples/camel-example-any23/pom.xml,"@@ -0,0 +1,66 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"">","[{'comment': 'Please add license header', 'commenter': 'bedlaj'}]"
3121,examples/camel-example-any23/src/main/java/org/apache/camel/example/any23/Any23RouteBuilder.java,"@@ -0,0 +1,81 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.example.any23;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Set;
+import org.apache.camel.Exchange;
+import org.apache.camel.Processor;
+import org.apache.camel.builder.RouteBuilder;
+import org.apache.camel.model.dataformat.Any23Type;
+import org.eclipse.rdf4j.model.IRI;
+import org.eclipse.rdf4j.model.Model;
+import org.eclipse.rdf4j.model.Value;
+import org.eclipse.rdf4j.model.ValueFactory;
+import org.eclipse.rdf4j.model.impl.SimpleValueFactory;
+
+public class Any23RouteBuilder extends RouteBuilder {
+
+  private static final String BASEURI = ""http://mock.foo/bar"";
+
+  @Override
+  public void configure() {
+
+    from(""direct:start"")
+            .log(""Querying dbpedia:Ecuador "")
+            .to(""http://dbpedia.org/page/Ecuador"")
+            .unmarshal()
+            .any23(BASEURI)
+            .process(new Processor() {
+              public void process(Exchange exchange) throws Exception {
+                ValueFactory vf = SimpleValueFactory.getInstance();
+                Model model = (Model) exchange.getIn().getBody();
+
+                //Selecting the leaders of Ecuador
+                IRI propertyLeader = vf.createIRI(""http://dbpedia.org/ontology/leader"");
+                Set<Value> leadersResources = model.filter(null, propertyLeader, null).objects();
+                List<String> leadersList = new ArrayList<>();
+                for (Value leader : leadersResources) {
+                  // Transform the leader resource (URI) into  an broweable URL.
+                  // For instance: 
+                  // http://dbpedia.org/resource/Oswaldo_Guayasam%C3%ADn  --> http://dbpedia.org/page/Oswaldo_Guayasam%C3%ADn
+                  String aLeader = leader.stringValue().replace(""resource"", ""page"");
+                  leadersList.add(aLeader);
+                }
+                exchange.getIn().setBody(leadersList);
+
+              }
+            })
+            .log("" Content: ${body} "")
+            //Process each leader in a separate route.
+            //In order to extract more information.
+            .split(simple(""${body}""))
+            .to(""direct:extractMoreData"");
+
+    from(""direct:extractMoreData"")
+            .log(""Split ${body}"")
+            .convertBodyTo(String.class)
+            .toD(""${body}"")
+            .unmarshal()
+            //Extract RDF data of the leaders as JSONLD
+            .any23(BASEURI, Any23Type.JSONLD)
+            .log("" Result : ${body} "")
+            .to(""mock:result"");","[{'comment': 'mock endpoint is useless here. `log:result` may be better.', 'commenter': 'bedlaj'}]"
3121,examples/camel-example-any23/src/main/java/org/apache/camel/example/any23/Any23RouteBuilder.java,"@@ -0,0 +1,81 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.example.any23;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Set;
+import org.apache.camel.Exchange;
+import org.apache.camel.Processor;
+import org.apache.camel.builder.RouteBuilder;
+import org.apache.camel.model.dataformat.Any23Type;
+import org.eclipse.rdf4j.model.IRI;
+import org.eclipse.rdf4j.model.Model;
+import org.eclipse.rdf4j.model.Value;
+import org.eclipse.rdf4j.model.ValueFactory;
+import org.eclipse.rdf4j.model.impl.SimpleValueFactory;
+
+public class Any23RouteBuilder extends RouteBuilder {
+
+  private static final String BASEURI = ""http://mock.foo/bar"";
+
+  @Override
+  public void configure() {
+
+    from(""direct:start"")
+            .log(""Querying dbpedia:Ecuador "")
+            .to(""http://dbpedia.org/page/Ecuador"")
+            .unmarshal()
+            .any23(BASEURI)
+            .process(new Processor() {
+              public void process(Exchange exchange) throws Exception {
+                ValueFactory vf = SimpleValueFactory.getInstance();
+                Model model = (Model) exchange.getIn().getBody();","[{'comment': 'Better use getBody(Class) instead this cast\r\n```suggestion\r\n                Model model = exchange.getIn().getBody(Model.class);\r\n```', 'commenter': 'bedlaj'}]"
3121,examples/camel-example-any23/src/main/java/org/apache/camel/example/any23/Any23RouteBuilder.java,"@@ -0,0 +1,81 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.example.any23;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Set;
+import org.apache.camel.Exchange;
+import org.apache.camel.Processor;
+import org.apache.camel.builder.RouteBuilder;
+import org.apache.camel.model.dataformat.Any23Type;
+import org.eclipse.rdf4j.model.IRI;
+import org.eclipse.rdf4j.model.Model;
+import org.eclipse.rdf4j.model.Value;
+import org.eclipse.rdf4j.model.ValueFactory;
+import org.eclipse.rdf4j.model.impl.SimpleValueFactory;
+
+public class Any23RouteBuilder extends RouteBuilder {
+
+  private static final String BASEURI = ""http://mock.foo/bar"";
+
+  @Override
+  public void configure() {
+
+    from(""direct:start"")
+            .log(""Querying dbpedia:Ecuador "")
+            .to(""http://dbpedia.org/page/Ecuador"")
+            .unmarshal()
+            .any23(BASEURI)
+            .process(new Processor() {
+              public void process(Exchange exchange) throws Exception {
+                ValueFactory vf = SimpleValueFactory.getInstance();
+                Model model = (Model) exchange.getIn().getBody();
+
+                //Selecting the leaders of Ecuador
+                IRI propertyLeader = vf.createIRI(""http://dbpedia.org/ontology/leader"");
+                Set<Value> leadersResources = model.filter(null, propertyLeader, null).objects();
+                List<String> leadersList = new ArrayList<>();
+                for (Value leader : leadersResources) {
+                  // Transform the leader resource (URI) into  an broweable URL.
+                  // For instance: 
+                  // http://dbpedia.org/resource/Oswaldo_Guayasam%C3%ADn  --> http://dbpedia.org/page/Oswaldo_Guayasam%C3%ADn
+                  String aLeader = leader.stringValue().replace(""resource"", ""page"");
+                  leadersList.add(aLeader);
+                }
+                exchange.getIn().setBody(leadersList);
+
+              }
+            })
+            .log("" Content: ${body} "")
+            //Process each leader in a separate route.
+            //In order to extract more information.
+            .split(simple(""${body}""))
+            .to(""direct:extractMoreData"");
+
+    from(""direct:extractMoreData"")
+            .log(""Split ${body}"")
+            .convertBodyTo(String.class)","[{'comment': 'If I am looking correctly, the body is already String. Why this conversion?', 'commenter': 'bedlaj'}]"
3121,examples/camel-example-any23/src/main/java/org/apache/camel/example/any23/Application.java,"@@ -0,0 +1,35 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.example.any23;
+
+import org.apache.camel.CamelContext;
+import org.apache.camel.impl.DefaultCamelContext;
+
+public class Application {
+
+  public static void main(String[] args) throws Exception {
+    System.out.println(""Camel is started. Ready to run Any23 example!"");","[{'comment': 'It is a bit nitpicking, but Camel is not started yet at the time of this message :-)', 'commenter': 'bedlaj'}]"
3121,examples/camel-example-any23/src/main/java/org/apache/camel/example/any23/Application.java,"@@ -0,0 +1,35 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.example.any23;
+
+import org.apache.camel.CamelContext;
+import org.apache.camel.impl.DefaultCamelContext;
+
+public class Application {
+
+  public static void main(String[] args) throws Exception {
+    System.out.println(""Camel is started. Ready to run Any23 example!"");
+
+    CamelContext context = new DefaultCamelContext();
+    context.start();","[{'comment': 'You should add routes and startup listener before calling `context.start()`.', 'commenter': 'bedlaj'}]"
3124,docs/user-manual/modules/ROOT/pages/lifecycle.adoc,"@@ -102,3 +102,7 @@ stop/start.
 If a route consumer does not support suspension, it will fallback and
 stop the route instead.
 
+[[Lifecycle-RelatedInfo]]
+== Related Info
+
+xref:controlbus-component.adoc[Take a look at the Control Bus Component]","[{'comment': ""We're using Antora to generate the website from this content, syntax for xref links is explained [here](https://docs.antora.org/antora/2.0/asciidoc/page-to-page-xref/).\r\n\r\nSince this link is pointing between two components (from user manual to component reference) the syntax is: \r\n\r\n```suggestion\r\nxref:components::controlbus-component.adoc[Take a look at the Control Bus Component]\r\n```"", 'commenter': 'zregvart'}]"
3128,components/camel-debezium/pom.xml,"@@ -0,0 +1,107 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one or more
+    contributor license agreements.  See the NOTICE file distributed with
+    this work for additional information regarding copyright ownership.
+    The ASF licenses this file to You under the Apache License, Version 2.0
+    (the ""License""); you may not use this file except in compliance with
+    the License.  You may obtain a copy of the License at
+
+         http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an ""AS IS"" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+
+-->
+<project xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xmlns=""http://maven.apache.org/POM/4.0.0""
+         xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+    <modelVersion>4.0.0</modelVersion>
+
+    <parent>
+        <groupId>org.apache.camel</groupId>
+        <artifactId>components</artifactId>
+        <version>3.0.0-SNAPSHOT</version>
+    </parent>
+
+    <artifactId>camel-debezium</artifactId>
+    <packaging>jar</packaging>
+    <name>Camel :: Debezium</name>
+    <description>Camel Debezium support</description>
+
+    <properties>
+    </properties>
+
+    <dependencies>
+
+        <!-- camel -->
+        <dependency>
+            <groupId>org.apache.camel</groupId>
+            <artifactId>camel-support</artifactId>
+        </dependency>
+
+        <!-- debezium embedded engine -->
+        <dependency>
+            <groupId>io.debezium</groupId>
+            <artifactId>debezium-embedded</artifactId>
+            <version>${debezium-version}</version>
+        </dependency>
+
+        <!-- debezium connectors -->
+        <dependency>
+            <groupId>io.debezium</groupId>
+            <artifactId>debezium-connector-mysql</artifactId>
+            <version>${debezium-version}</version>
+        </dependency>
+
+        <!-- test -->
+        <dependency>
+            <groupId>org.apache.camel</groupId>
+            <artifactId>camel-test</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.mockito</groupId>
+            <artifactId>mockito-core</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.apache.logging.log4j</groupId>
+            <artifactId>log4j-api</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.apache.logging.log4j</groupId>
+            <artifactId>log4j-core</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.apache.logging.log4j</groupId>
+            <artifactId>log4j-slf4j-impl</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.apache.logging.log4j</groupId>
+            <artifactId>log4j-1.2-api</artifactId>
+            <scope>test</scope>
+        </dependency>
+
+        <dependency>
+            <groupId>commons-lang</groupId>
+            <artifactId>commons-lang</artifactId>
+            <version>${commons-lang-version}</version>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.jetbrains</groupId>","[{'comment': 'Please also put this version into the parent/pom.xml', 'commenter': 'dmvolod'}, {'comment': 'It was auto generated by the IDE, removed it', 'commenter': 'omarsmak'}]"
3128,components/camel-debezium/src/main/java/org/apache/camel/component/debezium/DebeziumEndpoint.java,"@@ -0,0 +1,133 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.debezium;
+
+import java.util.concurrent.ExecutorService;
+
+import io.debezium.data.Envelope;
+import org.apache.camel.Consumer;
+import org.apache.camel.Exchange;
+import org.apache.camel.Message;
+import org.apache.camel.Processor;
+import org.apache.camel.Producer;
+import org.apache.camel.component.debezium.configuration.EmbeddedDebeziumConfiguration;
+import org.apache.camel.component.debezium.configuration.MySqlConnectorEmbeddedDebeziumConfiguration;
+import org.apache.camel.spi.UriEndpoint;
+import org.apache.camel.spi.UriParam;
+import org.apache.camel.support.DefaultEndpoint;
+import org.apache.kafka.connect.data.Schema;
+import org.apache.kafka.connect.data.Struct;
+import org.apache.kafka.connect.errors.DataException;
+import org.apache.kafka.connect.source.SourceRecord;
+
+/**
+ * Represents a Debezium endpoint which is used for interacting with Debezium
+ * embedded engine.
+ */
+@UriEndpoint(firstVersion = ""3.0.0"", scheme = ""debezium"", title = ""Debezium"", syntax = ""debezium:connector-name"", label = ""cdc"", consumerOnly = true)","[{'comment': 'Syntax should match the field defined with `UriPath` annotation. We have test for this (`CamelCatalogJsonSchemaTest#testValidateJsonComponent`), which will probably fail.  \r\n\r\nThe label should be used for grouping components and should be more generic. `cdc` seems to be much component specific. I suggest to change label to something like `database,sql`. It seems debezium supports cassandra, so maybe label `nosql` is relevant too.\r\n```suggestion\r\n@UriEndpoint(firstVersion = ""3.0.0"", scheme = ""debezium"", title = ""Debezium"", syntax = ""debezium:connectorType"", label = ""database,sql,nosql"", consumerOnly = true)\r\n```', 'commenter': 'bedlaj'}, {'comment': ""Yeah I figured that out yesterday but haven't pushed the latest changes yet"", 'commenter': 'omarsmak'}]"
3128,components/camel-debezium/src/main/java/org/apache/camel/component/debezium/configuration/EmbeddedDebeziumConfiguration.java,"@@ -0,0 +1,328 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.debezium.configuration;
+
+import io.debezium.config.Configuration;
+import io.debezium.config.Field;
+import io.debezium.embedded.EmbeddedEngine;
+
+import org.apache.camel.component.debezium.DebeziumConstants;
+import org.apache.camel.spi.Metadata;
+import org.apache.camel.spi.UriParam;
+import org.apache.camel.spi.UriParams;
+import org.apache.camel.spi.UriPath;
+import org.apache.camel.util.ObjectHelper;
+
+@UriParams
+public abstract class EmbeddedDebeziumConfiguration {
+
+    private static final String LABEL_NAME = ""common"";","[{'comment': 'label `common` means, that param can be used for both consumer and producer. Because this component is consumer only, the label should be `consumer`', 'commenter': 'bedlaj'}]"
3128,components/camel-debezium/src/main/java/org/apache/camel/component/debezium/configuration/MySqlConnectorEmbeddedDebeziumConfiguration.java,"@@ -0,0 +1,606 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.debezium.configuration;
+
+import io.debezium.config.CommonConnectorConfig;
+import io.debezium.config.Configuration;
+import io.debezium.connector.mysql.MySqlConnector;
+import io.debezium.connector.mysql.MySqlConnectorConfig;
+import io.debezium.relational.history.FileDatabaseHistory;
+import io.debezium.relational.history.KafkaDatabaseHistory;
+
+import org.apache.camel.component.debezium.DebeziumConstants;
+import org.apache.camel.spi.Metadata;
+import org.apache.camel.spi.UriParam;
+import org.apache.camel.spi.UriParams;
+
+@UriParams
+public class MySqlConnectorEmbeddedDebeziumConfiguration extends EmbeddedDebeziumConfiguration {
+
+    private static final String LABEL_NAME = ""mysql"";","[{'comment': 'The label should contain keyword `consumer`\r\n```suggestion\r\n    private static final String LABEL_NAME = ""consumer,mysql"";\r\n```', 'commenter': 'bedlaj'}]"
3128,components/camel-debezium/src/main/java/org/apache/camel/component/debezium/DebeziumEndpoint.java,"@@ -0,0 +1,133 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.debezium;
+
+import java.util.concurrent.ExecutorService;
+
+import io.debezium.data.Envelope;
+import org.apache.camel.Consumer;
+import org.apache.camel.Exchange;
+import org.apache.camel.Message;
+import org.apache.camel.Processor;
+import org.apache.camel.Producer;
+import org.apache.camel.component.debezium.configuration.EmbeddedDebeziumConfiguration;
+import org.apache.camel.component.debezium.configuration.MySqlConnectorEmbeddedDebeziumConfiguration;
+import org.apache.camel.spi.UriEndpoint;
+import org.apache.camel.spi.UriParam;
+import org.apache.camel.support.DefaultEndpoint;
+import org.apache.kafka.connect.data.Schema;
+import org.apache.kafka.connect.data.Struct;
+import org.apache.kafka.connect.errors.DataException;
+import org.apache.kafka.connect.source.SourceRecord;
+
+/**
+ * Represents a Debezium endpoint which is used for interacting with Debezium
+ * embedded engine.
+ */
+@UriEndpoint(firstVersion = ""3.0.0"", scheme = ""debezium"", title = ""Debezium"", syntax = ""debezium:connector-name"", label = ""cdc"", consumerOnly = true)
+public class DebeziumEndpoint extends DefaultEndpoint {","[{'comment': 'You have designed the endpoint the way, that path is currently constant `mysql`. Because otf this, you should  IMHO implement interface `MultipleConsumersSupport`, to allow consuming change streams from multiple MySQL databases.', 'commenter': 'bedlaj'}, {'comment': 'Actually the comment above is not true. I thought this validation is against path, but currently this validation checks full uri including parameters. So the `MultipleConsumersSupport` is not required here. ', 'commenter': 'bedlaj'}]"
3128,components/camel-debezium/src/main/java/org/apache/camel/component/debezium/DebeziumEndpoint.java,"@@ -0,0 +1,133 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.debezium;
+
+import java.util.concurrent.ExecutorService;
+
+import io.debezium.data.Envelope;
+import org.apache.camel.Consumer;
+import org.apache.camel.Exchange;
+import org.apache.camel.Message;
+import org.apache.camel.Processor;
+import org.apache.camel.Producer;
+import org.apache.camel.component.debezium.configuration.EmbeddedDebeziumConfiguration;
+import org.apache.camel.component.debezium.configuration.MySqlConnectorEmbeddedDebeziumConfiguration;
+import org.apache.camel.spi.UriEndpoint;
+import org.apache.camel.spi.UriParam;
+import org.apache.camel.support.DefaultEndpoint;
+import org.apache.kafka.connect.data.Schema;
+import org.apache.kafka.connect.data.Struct;
+import org.apache.kafka.connect.errors.DataException;
+import org.apache.kafka.connect.source.SourceRecord;
+
+/**
+ * Represents a Debezium endpoint which is used for interacting with Debezium
+ * embedded engine.
+ */
+@UriEndpoint(firstVersion = ""3.0.0"", scheme = ""debezium"", title = ""Debezium"", syntax = ""debezium:connector-name"", label = ""cdc"", consumerOnly = true)
+public class DebeziumEndpoint extends DefaultEndpoint {
+
+    @UriParam
+    private EmbeddedDebeziumConfiguration configuration;
+
+    // is only meant to include different configurations for each connector that is generated by camel-maven plugin
+    @UriParam
+    private MySqlConnectorEmbeddedDebeziumConfiguration mySqlConnectorEmbeddedDebeziumConfiguration;
+
+    public DebeziumEndpoint(String uri, DebeziumComponent component, EmbeddedDebeziumConfiguration config) {
+        super(uri, component);
+        this.configuration = config;
+    }
+
+    public DebeziumEndpoint() {
+    }
+
+    @Override
+    public Producer createProducer() throws Exception {
+        throw new UnsupportedOperationException(""Cannot produce from a DebeziumEndpoint: ""
+                                                + getEndpointUri());
+    }
+
+    public Consumer createConsumer(Processor processor) throws Exception {
+        return new DebeziumConsumer(this, processor);
+    }
+
+    public boolean isSingleton() {
+        return true;","[{'comment': '`isSingleton` returns true by default. You dont need to override it.', 'commenter': 'bedlaj'}]"
3128,components/camel-debezium/src/main/java/org/apache/camel/component/debezium/DebeziumEndpoint.java,"@@ -0,0 +1,133 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.debezium;
+
+import java.util.concurrent.ExecutorService;
+
+import io.debezium.data.Envelope;
+import org.apache.camel.Consumer;
+import org.apache.camel.Exchange;
+import org.apache.camel.Message;
+import org.apache.camel.Processor;
+import org.apache.camel.Producer;
+import org.apache.camel.component.debezium.configuration.EmbeddedDebeziumConfiguration;
+import org.apache.camel.component.debezium.configuration.MySqlConnectorEmbeddedDebeziumConfiguration;
+import org.apache.camel.spi.UriEndpoint;
+import org.apache.camel.spi.UriParam;
+import org.apache.camel.support.DefaultEndpoint;
+import org.apache.kafka.connect.data.Schema;
+import org.apache.kafka.connect.data.Struct;
+import org.apache.kafka.connect.errors.DataException;
+import org.apache.kafka.connect.source.SourceRecord;
+
+/**
+ * Represents a Debezium endpoint which is used for interacting with Debezium
+ * embedded engine.
+ */
+@UriEndpoint(firstVersion = ""3.0.0"", scheme = ""debezium"", title = ""Debezium"", syntax = ""debezium:connector-name"", label = ""cdc"", consumerOnly = true)
+public class DebeziumEndpoint extends DefaultEndpoint {
+
+    @UriParam
+    private EmbeddedDebeziumConfiguration configuration;
+
+    // is only meant to include different configurations for each connector that is generated by camel-maven plugin
+    @UriParam
+    private MySqlConnectorEmbeddedDebeziumConfiguration mySqlConnectorEmbeddedDebeziumConfiguration;
+
+    public DebeziumEndpoint(String uri, DebeziumComponent component, EmbeddedDebeziumConfiguration config) {
+        super(uri, component);
+        this.configuration = config;
+    }
+
+    public DebeziumEndpoint() {
+    }
+
+    @Override
+    public Producer createProducer() throws Exception {
+        throw new UnsupportedOperationException(""Cannot produce from a DebeziumEndpoint: ""
+                                                + getEndpointUri());
+    }
+
+    public Consumer createConsumer(Processor processor) throws Exception {","[{'comment': 'Please add `Override` annotation to overriden methods', 'commenter': 'bedlaj'}]"
3128,components/camel-debezium/pom.xml,"@@ -0,0 +1,100 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one or more
+    contributor license agreements.  See the NOTICE file distributed with
+    this work for additional information regarding copyright ownership.
+    The ASF licenses this file to You under the Apache License, Version 2.0
+    (the ""License""); you may not use this file except in compliance with
+    the License.  You may obtain a copy of the License at
+
+         http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an ""AS IS"" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+
+-->
+<project xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xmlns=""http://maven.apache.org/POM/4.0.0""
+         xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+    <modelVersion>4.0.0</modelVersion>
+
+    <parent>
+        <groupId>org.apache.camel</groupId>
+        <artifactId>components</artifactId>
+        <version>3.0.0-SNAPSHOT</version>
+    </parent>
+
+    <artifactId>camel-debezium</artifactId>
+    <packaging>jar</packaging>
+    <name>Camel :: Debezium</name>
+    <description>Camel Debezium support</description>
+
+    <properties>
+    </properties>","[{'comment': 'This can be removed', 'commenter': 'bedlaj'}]"
3128,components/camel-debezium/src/test/resources/log4j.properties,"@@ -0,0 +1,32 @@
+## ---------------------------------------------------------------------------
+## Licensed to the Apache Software Foundation (ASF) under one or more
+## contributor license agreements.  See the NOTICE file distributed with
+## this work for additional information regarding copyright ownership.
+## The ASF licenses this file to You under the Apache License, Version 2.0
+## (the ""License""); you may not use this file except in compliance with
+## the License.  You may obtain a copy of the License at
+##
+##      http://www.apache.org/licenses/LICENSE-2.0
+##
+## Unless required by applicable law or agreed to in writing, software
+## distributed under the License is distributed on an ""AS IS"" BASIS,
+## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+## See the License for the specific language governing permissions and
+## limitations under the License.
+## ---------------------------------------------------------------------------
+
+# Direct log messages to stdout
+log4j.appender.stdout=org.apache.log4j.ConsoleAppender","[{'comment': 'Please use file appender as other components do. Jenkins will be much happier.', 'commenter': 'bedlaj'}]"
3128,components/camel-debezium/src/test/resources/log4j.properties,"@@ -0,0 +1,32 @@
+## ---------------------------------------------------------------------------
+## Licensed to the Apache Software Foundation (ASF) under one or more
+## contributor license agreements.  See the NOTICE file distributed with
+## this work for additional information regarding copyright ownership.
+## The ASF licenses this file to You under the Apache License, Version 2.0
+## (the ""License""); you may not use this file except in compliance with
+## the License.  You may obtain a copy of the License at
+##
+##      http://www.apache.org/licenses/LICENSE-2.0
+##
+## Unless required by applicable law or agreed to in writing, software
+## distributed under the License is distributed on an ""AS IS"" BASIS,
+## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+## See the License for the specific language governing permissions and
+## limitations under the License.
+## ---------------------------------------------------------------------------
+
+# Direct log messages to stdout
+log4j.appender.stdout=org.apache.log4j.ConsoleAppender
+log4j.appender.stdout.Target=System.out
+log4j.appender.stdout.layout=org.apache.log4j.PatternLayout
+log4j.appender.stdout.layout.ConversionPattern=%d{ISO8601} %-5p  %X{dbz.connectorType}|%X{dbz.connectorName}|%X{dbz.connectorContext}  %m   [%c]%n
+
+# Root logger option
+log4j.rootLogger=WARN, stdout","[{'comment': 'Why are you logging only WARNs? This will make debugging tests on jenkins really hard.', 'commenter': 'bedlaj'}]"
3128,components/camel-debezium/src/main/java/org/apache/camel/component/debezium/DebeziumComponent.java,"@@ -0,0 +1,89 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.debezium;
+
+import java.util.Map;
+
+import org.apache.camel.CamelContext;
+import org.apache.camel.component.debezium.configuration.ConfigurationValidation;
+import org.apache.camel.component.debezium.configuration.EmbeddedDebeziumConfiguration;
+import org.apache.camel.component.debezium.configuration.MySqlConnectorEmbeddedDebeziumConfiguration;
+import org.apache.camel.spi.Metadata;","[{'comment': 'unused import', 'commenter': 'bedlaj'}]"
3128,components/camel-debezium/src/main/java/org/apache/camel/component/debezium/DebeziumConnectorTypes.java,"@@ -0,0 +1,44 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.debezium;
+
+import io.debezium.connector.mysql.MySqlConnector;","[{'comment': 'unused import', 'commenter': 'bedlaj'}]"
3128,components/camel-debezium/src/main/java/org/apache/camel/component/debezium/DebeziumEndpoint.java,"@@ -0,0 +1,133 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.debezium;
+
+import java.util.concurrent.ExecutorService;
+
+import io.debezium.data.Envelope;
+import org.apache.camel.Consumer;
+import org.apache.camel.Exchange;
+import org.apache.camel.Message;
+import org.apache.camel.Processor;
+import org.apache.camel.Producer;
+import org.apache.camel.component.debezium.configuration.EmbeddedDebeziumConfiguration;
+import org.apache.camel.component.debezium.configuration.MySqlConnectorEmbeddedDebeziumConfiguration;
+import org.apache.camel.spi.UriEndpoint;
+import org.apache.camel.spi.UriParam;
+import org.apache.camel.support.DefaultEndpoint;
+import org.apache.kafka.connect.data.Schema;
+import org.apache.kafka.connect.data.Struct;
+import org.apache.kafka.connect.errors.DataException;
+import org.apache.kafka.connect.source.SourceRecord;
+
+/**
+ * Represents a Debezium endpoint which is used for interacting with Debezium
+ * embedded engine.
+ */
+@UriEndpoint(firstVersion = ""3.0.0"", scheme = ""debezium"", title = ""Debezium"", syntax = ""debezium:connector-name"", label = ""cdc"", consumerOnly = true)
+public class DebeziumEndpoint extends DefaultEndpoint {
+
+    @UriParam
+    private EmbeddedDebeziumConfiguration configuration;
+
+    // is only meant to include different configurations for each connector that is generated by camel-maven plugin
+    @UriParam
+    private MySqlConnectorEmbeddedDebeziumConfiguration mySqlConnectorEmbeddedDebeziumConfiguration;
+
+    public DebeziumEndpoint(String uri, DebeziumComponent component, EmbeddedDebeziumConfiguration config) {
+        super(uri, component);
+        this.configuration = config;
+    }
+
+    public DebeziumEndpoint() {
+    }
+
+    @Override
+    public Producer createProducer() throws Exception {
+        throw new UnsupportedOperationException(""Cannot produce from a DebeziumEndpoint: ""
+                                                + getEndpointUri());
+    }
+
+    public Consumer createConsumer(Processor processor) throws Exception {
+        return new DebeziumConsumer(this, processor);
+    }
+
+    public boolean isSingleton() {
+        return true;
+    }
+
+    public EmbeddedDebeziumConfiguration getConfiguration() {
+        return configuration;
+    }
+
+    public void setConfiguration(EmbeddedDebeziumConfiguration configuration) {
+        this.configuration = configuration;
+    }
+
+    public MySqlConnectorEmbeddedDebeziumConfiguration getMySqlConnectorEmbeddedDebeziumConfiguration() {
+        return mySqlConnectorEmbeddedDebeziumConfiguration;
+    }
+
+    public ExecutorService createExecutor() {
+        return getCamelContext().getExecutorServiceManager().newSingleThreadExecutor(this,
+                                                                                     ""DebeziumConsumer"");
+    }
+
+    public Exchange createDbzExchange(final SourceRecord record) {
+        final Exchange exchange = super.createExchange();
+
+        final Message message = exchange.getIn();
+
+        message.setHeader(DebeziumConstants.FIELD_IDENTIFIER, record.topic());
+        message.setHeader(DebeziumConstants.FIELD_KEY, record.key());
+        message.setHeader(DebeziumConstants.FIELD_SOURCE, record.sourceOffset());
+        setOperationFieldInHeader(message, record.valueSchema(), record.value());
+
+        message.setBody(record.value());
+
+        return exchange;
+    }
+
+    private void setOperationFieldInHeader(final Message message, final Schema schema, final Object value) {
+        if (isValueAndStructSchemaSet(schema, value)) {
+            message.setHeader(DebeziumConstants.FIELD_OPERATION, getOperationFromValueRecord((Struct)value));
+        } else if (!isValueAndSchemaSet(schema, value)) { // sometimes a delete will be emitted as null in the
+                                                      // value and the schema, hence we need to set the operation manually
+            message.setHeader(DebeziumConstants.FIELD_OPERATION, Envelope.Operation.DELETE.code());
+        }
+    }
+
+    private boolean isValueAndStructSchemaSet(final Schema schema, final Object value) {
+        return  isValueAndSchemaSet(schema, value) && isSchemaAStructSchema(schema);
+    }
+
+    private boolean isValueAndSchemaSet(final Schema schema, final Object value) {
+        return value != null && schema != null;
+    }
+
+    private boolean isSchemaAStructSchema(final Schema schema){","[{'comment': 'Please run build with `sourcecheck` profile', 'commenter': 'bedlaj'}]"
3128,components/camel-debezium/src/main/java/org/apache/camel/component/debezium/DebeziumConstants.java,"@@ -0,0 +1,59 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.debezium;
+
+public final class DebeziumConstants {
+    public static final int DEFAULT_PORT = 3306;
+    public static final int DEFAULT_TASKS_MAX = 1;","[{'comment': 'Some constants are unused. Are they needed?', 'commenter': 'bedlaj'}]"
3128,components/camel-debezium/src/main/java/org/apache/camel/component/debezium/DebeziumConstants.java,"@@ -0,0 +1,59 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.debezium;
+
+public final class DebeziumConstants {
+    public static final int DEFAULT_PORT = 3306;
+    public static final int DEFAULT_TASKS_MAX = 1;
+
+    public static final DebeziumConnectorTypes DEFAULT_CONNECTOR_TYPE = DebeziumConnectorTypes.MYSQL;
+
+    public static final String DEFAULT_TIME_PRECISION_MODE = ""adaptive_time_microseconds"";
+
+    public static final String DEFAULT_DECIMAL_HANDLING_MODE = ""precise"";
+    public static final String DEFAULT_BIGINT_UNSIGNED_HANDLING_MODE = ""long"";
+
+    public static final boolean DEFAULT_INCLUDE_SCHEMA_CHANGES = true;
+    public static final boolean DEFAULT_INCLUDE_QUERY = false;
+
+    public static final int DEFAULT_MAX_QUEUE_SIZE = 8192;
+    public static final int DEFAULT_MAX_BATCH_SIZE = 2048;
+
+    public static final long DEFAULT_POLL_INTERVAL_MS = 1000;
+
+    public static final long DEFAULT_CONNECT_TIMEOUT_MS = 30000;
+
+    public static final String DEFAULT_EVENT_DESERIALIZATION_FAILUER_HANDLING_MODE = ""fail"";","[{'comment': 'typo in constant name and also it is unused', 'commenter': 'bedlaj'}]"
3128,components/camel-debezium/src/main/java/org/apache/camel/component/debezium/configuration/EmbeddedDebeziumConfiguration.java,"@@ -0,0 +1,328 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.debezium.configuration;
+
+import io.debezium.config.Configuration;
+import io.debezium.config.Field;
+import io.debezium.embedded.EmbeddedEngine;
+
+import org.apache.camel.component.debezium.DebeziumConstants;
+import org.apache.camel.spi.Metadata;
+import org.apache.camel.spi.UriParam;
+import org.apache.camel.spi.UriParams;
+import org.apache.camel.spi.UriPath;
+import org.apache.camel.util.ObjectHelper;
+
+@UriParams
+public abstract class EmbeddedDebeziumConfiguration {
+
+    private static final String LABEL_NAME = ""common"";
+
+    @UriPath(label = LABEL_NAME)
+    @Metadata(required = true)
+    private String connectorType;
+
+    private Class<?> connectorClass;
+    // name
+    @UriParam(label = LABEL_NAME)
+    @Metadata(required = true)
+    private String name;
+    // offset.storage
+    @UriParam(label = LABEL_NAME)
+    @Metadata(defaultValue = DebeziumConstants.DEFAULT_OFFSET_STORAGE)
+    private String offsetStorage = DebeziumConstants.DEFAULT_OFFSET_STORAGE;
+    // offset.storage.file.filename
+    @UriParam(label = LABEL_NAME)
+    private String offsetStorageFileName;
+    // offset.storage.topic
+    @UriParam(label = LABEL_NAME)
+    private String offsetStorageTopic;
+    // offset.storage.partitions
+    @UriParam(label = LABEL_NAME)
+    private int offsetStoragePartitions;
+    // offset.storage.replication.factor
+    @UriParam(label = LABEL_NAME)
+    private int offsetStorageReplicationFactor;
+    // offset.commit.policy
+    @UriParam(label = LABEL_NAME)
+    private String offsetCommitPolicy;
+    // offset.flush.interval.ms
+    @UriParam(label = LABEL_NAME)
+    @Metadata(defaultValue = """" + DebeziumConstants.DEFAULT_OFFSET_FLUSH_INTERVAL_MS)
+    private long offsetFlushIntervalMs = DebeziumConstants.DEFAULT_OFFSET_FLUSH_INTERVAL_MS;
+    // offset.commit.timeout.ms
+    @UriParam(label = LABEL_NAME)
+    @Metadata(defaultValue = """" + DebeziumConstants.DEFAULT_OFFSET_FLUSH_TIMEOUT_MS)
+    private long offsetCommitTimeoutMs = DebeziumConstants.DEFAULT_OFFSET_FLUSH_TIMEOUT_MS;
+    // internal.key.converter
+    @UriParam(label = LABEL_NAME)
+    private String internalKeyConverter;
+    // internal.value.converter
+    @UriParam(label = LABEL_NAME)
+    private String internalValueConverter;
+
+    public EmbeddedDebeziumConfiguration() {
+        ObjectHelper.notNull(configureConnectorClass(), ""connectorClass"");
+        this.connectorClass = configureConnectorClass();
+    }
+
+    /**
+     * Configure the Debezium connector class that is supported by Debezium
+     *
+     * @return {@link Class}
+     */
+    protected abstract Class<?> configureConnectorClass();
+
+    /**
+     * Create a specific {@link Configuration} for a concrete configuration
+     * @return {@link Configuration}
+     */
+    protected abstract Configuration createConnectorConfiguration();
+
+    /**
+     * Validate a concrete configuration
+     * @return {@link ConfigurationValidation}
+     */
+    protected abstract ConfigurationValidation validateConnectorConfiguration();
+
+    /**
+     * Creates a Debezium configuration of type {@link Configuration} in order to be used in the engine.
+     * @return {@link Configuration}
+     */
+    public Configuration createDebeziumConfiguration() {
+        final Configuration connectorConfiguration = createConnectorConfiguration();
+
+        ObjectHelper.notNull(connectorConfiguration, ""createConnectorConfiguration"");
+
+        return Configuration.create()
+                .with(createDebeziumEmbeddedEngineConfiguration())
+                .with(createConnectorConfiguration())
+                .build();
+    }
+
+    private Configuration createDebeziumEmbeddedEngineConfiguration() {
+        final Configuration.Builder configBuilder = Configuration.create();
+
+        addPropertyIfNotNull(configBuilder, EmbeddedEngine.ENGINE_NAME, name);
+        addPropertyIfNotNull(configBuilder, EmbeddedEngine.CONNECTOR_CLASS, connectorClass.getName());
+        addPropertyIfNotNull(configBuilder, EmbeddedEngine.OFFSET_STORAGE, offsetStorage);
+        addPropertyIfNotNull(configBuilder, EmbeddedEngine.OFFSET_STORAGE_FILE_FILENAME,
+                offsetStorageFileName);
+        addPropertyIfNotNull(configBuilder, EmbeddedEngine.OFFSET_STORAGE_KAFKA_TOPIC, offsetStorageTopic);
+        addPropertyIfNotNull(configBuilder, EmbeddedEngine.OFFSET_STORAGE_KAFKA_PARTITIONS,
+                offsetStoragePartitions);
+        addPropertyIfNotNull(configBuilder, EmbeddedEngine.OFFSET_STORAGE_KAFKA_REPLICATION_FACTOR,
+                offsetStorageReplicationFactor);
+        addPropertyIfNotNull(configBuilder, EmbeddedEngine.OFFSET_COMMIT_POLICY, offsetCommitPolicy);
+        addPropertyIfNotNull(configBuilder, EmbeddedEngine.OFFSET_FLUSH_INTERVAL_MS, offsetFlushIntervalMs);
+        addPropertyIfNotNull(configBuilder, EmbeddedEngine.OFFSET_COMMIT_TIMEOUT_MS, offsetCommitTimeoutMs);
+
+        if (internalKeyConverter != null && internalValueConverter != null) {
+            configBuilder.with(""internal.key.converter"", internalKeyConverter);
+            configBuilder.with(""internal.value.converter"", internalValueConverter);
+        }
+
+        return configBuilder.build();
+    }
+
+    protected static <T> void addPropertyIfNotNull(final Configuration.Builder configBuilder,
+                                                   final Field field, final T value) {
+        if (value != null) {
+            configBuilder.with(field, value);
+        }
+    }
+
+    /**
+     * Validate all configurations defined and return {@link ConfigurationValidation} instance which contains the validation results
+     * @return {@link ConfigurationValidation}
+     */
+    public ConfigurationValidation validateConfiguration() {
+        final ConfigurationValidation embeddedEngineValidation = validateDebeziumEmbeddedEngineConfiguration();
+        // only if embeddedEngineValidation is true, we check the connector validation
+        if (embeddedEngineValidation.isValid()) {
+            final ConfigurationValidation connectorValidation = validateConnectorConfiguration();
+
+            ObjectHelper.notNull(connectorValidation, ""validateConnectorConfiguration"");
+
+            return connectorValidation;
+        }
+        return embeddedEngineValidation;
+    }
+
+    private ConfigurationValidation validateDebeziumEmbeddedEngineConfiguration() {
+        if (isFieldValueNotSet(name)) {
+            return ConfigurationValidation.notValid(""Required field 'name' must be set."");
+        }
+        // check for offsetStorageFileName
+        if (offsetStorage.equals(DebeziumConstants.DEFAULT_OFFSET_STORAGE)
+                && isFieldValueNotSet(offsetStorageFileName)) {
+            return ConfigurationValidation.notValid(String
+                    .format(""Required field 'offsetStorageFileName' must be set since 'offsetStorage' is set to '%s'"",
+                            DebeziumConstants.DEFAULT_OFFSET_STORAGE));
+        }
+        return ConfigurationValidation.valid();
+    }
+
+    protected static boolean isFieldValueNotSet(final Object field) {
+        return field == null || ObjectHelper.isEmpty(field);
+    }
+
+    /**
+     * The connector type that is supported by Debezium component
+     */
+    public String getConnectorType() {
+        return connectorType;
+    }
+
+    public void setConnectorType(String connectorType) {
+        this.connectorType = connectorType;
+    }
+
+    /**
+     * The name of the Java class for the connector
+     */
+    public Class<?> getConnectorClass() {
+        return connectorClass;
+    }
+
+    public void setConnectorClass(Class<?> connectorClass) {
+        this.connectorClass = connectorClass;
+    }
+
+    /**
+     * Unique name for the connector. Attempting to register again with the same
+     * name will fail.
+     */
+    public String getName() {
+        return name;
+    }
+
+    public void setName(String name) {
+        this.name = name;
+    }
+
+    /**
+     * The name of the Java class that is responsible for persistence of connector offsets.
+     */
+    public String getOffsetStorage() {
+        return offsetStorage;
+    }
+
+    public void setOffsetStorage(String offsetStorage) {
+        this.offsetStorage = offsetStorage;
+    }
+
+    /**
+     * Path to file where offsets are to be stored. Required when offset.storage is set to the FileOffsetBackingStore
+     */
+    public String getOffsetStorageFileName() {
+        return offsetStorageFileName;
+    }
+
+    public void setOffsetStorageFileName(String offsetStorageFileName) {
+        this.offsetStorageFileName = offsetStorageFileName;
+    }
+
+    /**
+     * The name of the Kafka topic where offsets are to be stored. Required when offset.storage is set to the KafkaOffsetBackingStore.
+     */
+    public String getOffsetStorageTopic() {
+        return offsetStorageTopic;
+    }
+
+    public void setOffsetStorageTopic(String offsetStorageTopic) {
+        this.offsetStorageTopic = offsetStorageTopic;
+    }
+
+    /**
+     * Replication factor used when creating the offset storage topic. Required when offset.storage is set to the KafkaOffsetBackingStore
+     */
+    public int getOffsetStorageReplicationFactor() {
+        return offsetStorageReplicationFactor;
+    }
+
+    public void setOffsetStorageReplicationFactor(int offsetStorageReplicationFactor) {
+        this.offsetStorageReplicationFactor = offsetStorageReplicationFactor;
+    }
+
+    /**
+     * The name of the Java class of the commit policy. It defines when offsets commit has to be triggered based on the number of events processed and the time elapsed since the last commit.
+     * This class must implement the interface <…​>.OffsetCommitPolicy. The default is a periodic commity policy based upon time intervals.","[{'comment': 'typo in `commit policy`', 'commenter': 'bedlaj'}]"
3128,components/camel-debezium/src/test/java/org/apache/camel/component/debezium/configuration/TestEmbeddedDebeziumConfiguration.java,"@@ -0,0 +1,50 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.debezium.configuration;
+
+import io.debezium.config.Configuration;
+
+public class TestEmbeddedDebeziumConfiguration extends EmbeddedDebeziumConfiguration {
+
+    private String testField;
+
+    public String getTestField() {
+        return testField;
+    }
+
+    public void setTestField(String testField) {
+        this.testField = testField;
+    }
+
+    @Override
+    protected Class<?> configureConnectorClass() {
+        return Class.class;
+    }
+
+    @Override
+    protected Configuration createConnectorConfiguration() {
+        return Configuration.create().with(""test.field"", testField).build();
+    }
+
+    @Override
+    protected ConfigurationValidation validateConnectorConfiguration() {
+        if (isFieldValueNotSet(testField)) {
+            return ConfigurationValidation.notValid(""testField canont be empty"");","[{'comment': 'Typo in `cannot`', 'commenter': 'bedlaj'}]"
3128,components/camel-debezium/src/main/java/org/apache/camel/component/debezium/configuration/EmbeddedDebeziumConfiguration.java,"@@ -0,0 +1,328 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.debezium.configuration;
+
+import io.debezium.config.Configuration;
+import io.debezium.config.Field;
+import io.debezium.embedded.EmbeddedEngine;
+
+import org.apache.camel.component.debezium.DebeziumConstants;
+import org.apache.camel.spi.Metadata;
+import org.apache.camel.spi.UriParam;
+import org.apache.camel.spi.UriParams;
+import org.apache.camel.spi.UriPath;
+import org.apache.camel.util.ObjectHelper;
+
+@UriParams
+public abstract class EmbeddedDebeziumConfiguration {
+
+    private static final String LABEL_NAME = ""common"";
+
+    @UriPath(label = LABEL_NAME)
+    @Metadata(required = true)
+    private String connectorType;
+
+    private Class<?> connectorClass;
+    // name
+    @UriParam(label = LABEL_NAME)
+    @Metadata(required = true)
+    private String name;
+    // offset.storage
+    @UriParam(label = LABEL_NAME)
+    @Metadata(defaultValue = DebeziumConstants.DEFAULT_OFFSET_STORAGE)
+    private String offsetStorage = DebeziumConstants.DEFAULT_OFFSET_STORAGE;
+    // offset.storage.file.filename
+    @UriParam(label = LABEL_NAME)
+    private String offsetStorageFileName;
+    // offset.storage.topic
+    @UriParam(label = LABEL_NAME)
+    private String offsetStorageTopic;
+    // offset.storage.partitions
+    @UriParam(label = LABEL_NAME)
+    private int offsetStoragePartitions;
+    // offset.storage.replication.factor
+    @UriParam(label = LABEL_NAME)
+    private int offsetStorageReplicationFactor;
+    // offset.commit.policy
+    @UriParam(label = LABEL_NAME)
+    private String offsetCommitPolicy;
+    // offset.flush.interval.ms
+    @UriParam(label = LABEL_NAME)
+    @Metadata(defaultValue = """" + DebeziumConstants.DEFAULT_OFFSET_FLUSH_INTERVAL_MS)
+    private long offsetFlushIntervalMs = DebeziumConstants.DEFAULT_OFFSET_FLUSH_INTERVAL_MS;
+    // offset.commit.timeout.ms
+    @UriParam(label = LABEL_NAME)
+    @Metadata(defaultValue = """" + DebeziumConstants.DEFAULT_OFFSET_FLUSH_TIMEOUT_MS)
+    private long offsetCommitTimeoutMs = DebeziumConstants.DEFAULT_OFFSET_FLUSH_TIMEOUT_MS;
+    // internal.key.converter
+    @UriParam(label = LABEL_NAME)
+    private String internalKeyConverter;
+    // internal.value.converter
+    @UriParam(label = LABEL_NAME)
+    private String internalValueConverter;
+
+    public EmbeddedDebeziumConfiguration() {
+        ObjectHelper.notNull(configureConnectorClass(), ""connectorClass"");
+        this.connectorClass = configureConnectorClass();
+    }
+
+    /**
+     * Configure the Debezium connector class that is supported by Debezium
+     *
+     * @return {@link Class}
+     */
+    protected abstract Class<?> configureConnectorClass();
+
+    /**
+     * Create a specific {@link Configuration} for a concrete configuration
+     * @return {@link Configuration}
+     */
+    protected abstract Configuration createConnectorConfiguration();
+
+    /**
+     * Validate a concrete configuration
+     * @return {@link ConfigurationValidation}
+     */
+    protected abstract ConfigurationValidation validateConnectorConfiguration();
+
+    /**
+     * Creates a Debezium configuration of type {@link Configuration} in order to be used in the engine.
+     * @return {@link Configuration}
+     */
+    public Configuration createDebeziumConfiguration() {
+        final Configuration connectorConfiguration = createConnectorConfiguration();
+
+        ObjectHelper.notNull(connectorConfiguration, ""createConnectorConfiguration"");
+
+        return Configuration.create()
+                .with(createDebeziumEmbeddedEngineConfiguration())
+                .with(createConnectorConfiguration())
+                .build();
+    }
+
+    private Configuration createDebeziumEmbeddedEngineConfiguration() {
+        final Configuration.Builder configBuilder = Configuration.create();
+
+        addPropertyIfNotNull(configBuilder, EmbeddedEngine.ENGINE_NAME, name);
+        addPropertyIfNotNull(configBuilder, EmbeddedEngine.CONNECTOR_CLASS, connectorClass.getName());
+        addPropertyIfNotNull(configBuilder, EmbeddedEngine.OFFSET_STORAGE, offsetStorage);
+        addPropertyIfNotNull(configBuilder, EmbeddedEngine.OFFSET_STORAGE_FILE_FILENAME,
+                offsetStorageFileName);
+        addPropertyIfNotNull(configBuilder, EmbeddedEngine.OFFSET_STORAGE_KAFKA_TOPIC, offsetStorageTopic);
+        addPropertyIfNotNull(configBuilder, EmbeddedEngine.OFFSET_STORAGE_KAFKA_PARTITIONS,
+                offsetStoragePartitions);
+        addPropertyIfNotNull(configBuilder, EmbeddedEngine.OFFSET_STORAGE_KAFKA_REPLICATION_FACTOR,
+                offsetStorageReplicationFactor);
+        addPropertyIfNotNull(configBuilder, EmbeddedEngine.OFFSET_COMMIT_POLICY, offsetCommitPolicy);
+        addPropertyIfNotNull(configBuilder, EmbeddedEngine.OFFSET_FLUSH_INTERVAL_MS, offsetFlushIntervalMs);
+        addPropertyIfNotNull(configBuilder, EmbeddedEngine.OFFSET_COMMIT_TIMEOUT_MS, offsetCommitTimeoutMs);
+
+        if (internalKeyConverter != null && internalValueConverter != null) {
+            configBuilder.with(""internal.key.converter"", internalKeyConverter);
+            configBuilder.with(""internal.value.converter"", internalValueConverter);
+        }
+
+        return configBuilder.build();
+    }
+
+    protected static <T> void addPropertyIfNotNull(final Configuration.Builder configBuilder,
+                                                   final Field field, final T value) {
+        if (value != null) {
+            configBuilder.with(field, value);
+        }
+    }
+
+    /**
+     * Validate all configurations defined and return {@link ConfigurationValidation} instance which contains the validation results
+     * @return {@link ConfigurationValidation}
+     */
+    public ConfigurationValidation validateConfiguration() {
+        final ConfigurationValidation embeddedEngineValidation = validateDebeziumEmbeddedEngineConfiguration();
+        // only if embeddedEngineValidation is true, we check the connector validation
+        if (embeddedEngineValidation.isValid()) {
+            final ConfigurationValidation connectorValidation = validateConnectorConfiguration();
+
+            ObjectHelper.notNull(connectorValidation, ""validateConnectorConfiguration"");
+
+            return connectorValidation;
+        }
+        return embeddedEngineValidation;
+    }
+
+    private ConfigurationValidation validateDebeziumEmbeddedEngineConfiguration() {
+        if (isFieldValueNotSet(name)) {
+            return ConfigurationValidation.notValid(""Required field 'name' must be set."");
+        }
+        // check for offsetStorageFileName
+        if (offsetStorage.equals(DebeziumConstants.DEFAULT_OFFSET_STORAGE)
+                && isFieldValueNotSet(offsetStorageFileName)) {
+            return ConfigurationValidation.notValid(String
+                    .format(""Required field 'offsetStorageFileName' must be set since 'offsetStorage' is set to '%s'"",
+                            DebeziumConstants.DEFAULT_OFFSET_STORAGE));
+        }
+        return ConfigurationValidation.valid();
+    }
+
+    protected static boolean isFieldValueNotSet(final Object field) {
+        return field == null || ObjectHelper.isEmpty(field);","[{'comment': '`ObjectHelper#isEmpty` already contains null check.\r\n```suggestion\r\n        return ObjectHelper.isEmpty(field);\r\n```', 'commenter': 'bedlaj'}]"
3128,components/camel-debezium/src/main/java/org/apache/camel/component/debezium/DebeziumConsumer.java,"@@ -0,0 +1,92 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.debezium;
+
+import java.util.concurrent.ExecutorService;
+
+import io.debezium.embedded.EmbeddedEngine;
+
+import org.apache.camel.Exchange;
+import org.apache.camel.Processor;
+import org.apache.camel.component.debezium.configuration.EmbeddedDebeziumConfiguration;
+import org.apache.camel.support.DefaultConsumer;
+import org.apache.kafka.connect.source.SourceRecord;
+
+public class DebeziumConsumer extends DefaultConsumer {
+
+    private final DebeziumEndpoint endpoint;
+    private final EmbeddedDebeziumConfiguration configuration;
+
+    private ExecutorService executorService;
+    private EmbeddedEngine dbzEngine;
+
+    public DebeziumConsumer(DebeziumEndpoint endpoint, Processor processor) {
+        super(endpoint, processor);
+        this.endpoint = endpoint;
+        this.configuration = endpoint.getConfiguration();
+    }
+
+    @Override
+    protected void doStart() throws Exception {
+        super.doStart();
+
+        // start a single threaded pool to monitor events
+        executorService = endpoint.createExecutor();
+
+        // create engine
+        dbzEngine = createDbzEngine();
+
+        // submit task to the thread pool
+        executorService.submit(dbzEngine);
+    }
+
+    @Override
+    protected void doStop() throws Exception {
+        super.doStop();
+
+        if (log.isTraceEnabled()) {
+            log.trace(""Shutting down consumer gracefully"");","[{'comment': 'Is this needed? `super.doStop()` is already logging debug message.', 'commenter': 'bedlaj'}]"
3128,components/camel-debezium/src/main/java/org/apache/camel/component/debezium/DebeziumConsumer.java,"@@ -0,0 +1,92 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.debezium;
+
+import java.util.concurrent.ExecutorService;
+
+import io.debezium.embedded.EmbeddedEngine;
+
+import org.apache.camel.Exchange;
+import org.apache.camel.Processor;
+import org.apache.camel.component.debezium.configuration.EmbeddedDebeziumConfiguration;
+import org.apache.camel.support.DefaultConsumer;
+import org.apache.kafka.connect.source.SourceRecord;
+
+public class DebeziumConsumer extends DefaultConsumer {
+
+    private final DebeziumEndpoint endpoint;
+    private final EmbeddedDebeziumConfiguration configuration;
+
+    private ExecutorService executorService;
+    private EmbeddedEngine dbzEngine;
+
+    public DebeziumConsumer(DebeziumEndpoint endpoint, Processor processor) {
+        super(endpoint, processor);
+        this.endpoint = endpoint;
+        this.configuration = endpoint.getConfiguration();
+    }
+
+    @Override
+    protected void doStart() throws Exception {
+        super.doStart();
+
+        // start a single threaded pool to monitor events
+        executorService = endpoint.createExecutor();
+
+        // create engine
+        dbzEngine = createDbzEngine();
+
+        // submit task to the thread pool
+        executorService.submit(dbzEngine);
+    }
+
+    @Override
+    protected void doStop() throws Exception {
+        super.doStop();","[{'comment': 'The `super.doStop()` should be IMHO called after stopping `executorService` and `dbzEngine`.', 'commenter': 'bedlaj'}]"
3128,components/camel-debezium/src/main/java/org/apache/camel/component/debezium/DebeziumEndpoint.java,"@@ -0,0 +1,133 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.debezium;
+
+import java.util.concurrent.ExecutorService;
+
+import io.debezium.data.Envelope;
+import org.apache.camel.Consumer;
+import org.apache.camel.Exchange;
+import org.apache.camel.Message;
+import org.apache.camel.Processor;
+import org.apache.camel.Producer;
+import org.apache.camel.component.debezium.configuration.EmbeddedDebeziumConfiguration;
+import org.apache.camel.component.debezium.configuration.MySqlConnectorEmbeddedDebeziumConfiguration;
+import org.apache.camel.spi.UriEndpoint;
+import org.apache.camel.spi.UriParam;
+import org.apache.camel.support.DefaultEndpoint;
+import org.apache.kafka.connect.data.Schema;
+import org.apache.kafka.connect.data.Struct;
+import org.apache.kafka.connect.errors.DataException;
+import org.apache.kafka.connect.source.SourceRecord;
+
+/**
+ * Represents a Debezium endpoint which is used for interacting with Debezium
+ * embedded engine.
+ */
+@UriEndpoint(firstVersion = ""3.0.0"", scheme = ""debezium"", title = ""Debezium"", syntax = ""debezium:connector-name"", label = ""cdc"", consumerOnly = true)
+public class DebeziumEndpoint extends DefaultEndpoint {
+
+    @UriParam
+    private EmbeddedDebeziumConfiguration configuration;
+
+    // is only meant to include different configurations for each connector that is generated by camel-maven plugin
+    @UriParam
+    private MySqlConnectorEmbeddedDebeziumConfiguration mySqlConnectorEmbeddedDebeziumConfiguration;
+
+    public DebeziumEndpoint(String uri, DebeziumComponent component, EmbeddedDebeziumConfiguration config) {
+        super(uri, component);
+        this.configuration = config;
+    }
+
+    public DebeziumEndpoint() {
+    }
+
+    @Override
+    public Producer createProducer() throws Exception {
+        throw new UnsupportedOperationException(""Cannot produce from a DebeziumEndpoint: ""
+                                                + getEndpointUri());
+    }
+
+    public Consumer createConsumer(Processor processor) throws Exception {
+        return new DebeziumConsumer(this, processor);
+    }
+
+    public boolean isSingleton() {
+        return true;
+    }
+
+    public EmbeddedDebeziumConfiguration getConfiguration() {
+        return configuration;
+    }
+
+    public void setConfiguration(EmbeddedDebeziumConfiguration configuration) {
+        this.configuration = configuration;
+    }
+
+    public MySqlConnectorEmbeddedDebeziumConfiguration getMySqlConnectorEmbeddedDebeziumConfiguration() {
+        return mySqlConnectorEmbeddedDebeziumConfiguration;
+    }
+
+    public ExecutorService createExecutor() {
+        return getCamelContext().getExecutorServiceManager().newSingleThreadExecutor(this,
+                                                                                     ""DebeziumConsumer"");
+    }
+
+    public Exchange createDbzExchange(final SourceRecord record) {
+        final Exchange exchange = super.createExchange();
+
+        final Message message = exchange.getIn();
+
+        message.setHeader(DebeziumConstants.FIELD_IDENTIFIER, record.topic());
+        message.setHeader(DebeziumConstants.FIELD_KEY, record.key());
+        message.setHeader(DebeziumConstants.FIELD_SOURCE, record.sourceOffset());
+        setOperationFieldInHeader(message, record.valueSchema(), record.value());
+
+        message.setBody(record.value());
+
+        return exchange;
+    }
+
+    private void setOperationFieldInHeader(final Message message, final Schema schema, final Object value) {
+        if (isValueAndStructSchemaSet(schema, value)) {
+            message.setHeader(DebeziumConstants.FIELD_OPERATION, getOperationFromValueRecord((Struct)value));
+        } else if (!isValueAndSchemaSet(schema, value)) { // sometimes a delete will be emitted as null in the","[{'comment': 'Hey @gunnarmorling, I am bit hesitant here, do I need as well to check for a `null` value for the delete? I noticed that DBZ emits two messages sequentially when a delete operation occurs, the first with `op=d` and the second with a `null` value, I guess would be enough to relay on the `op` message and ignore the second message? ', 'commenter': 'omarsmak'}, {'comment': 'It\'s a configuration of the Debezium connectors whether to omit that second message (""tombstone"") or not. It\'s used as the indicator to the Kafka broker that all the messages with the same key can be removed from the topic during compaction. It probably doesn\'t not make that much sense for the Camel use case, so you might default that option to not emitting the tombstone. I think though the Camel connector should still accept it gracefully if it is sent.', 'commenter': 'gunnarmorling'}]"
3128,components/camel-debezium/pom.xml,"@@ -0,0 +1,100 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one or more
+    contributor license agreements.  See the NOTICE file distributed with
+    this work for additional information regarding copyright ownership.
+    The ASF licenses this file to You under the Apache License, Version 2.0
+    (the ""License""); you may not use this file except in compliance with
+    the License.  You may obtain a copy of the License at
+
+         http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an ""AS IS"" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+
+-->
+<project xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xmlns=""http://maven.apache.org/POM/4.0.0""
+         xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+    <modelVersion>4.0.0</modelVersion>
+
+    <parent>
+        <groupId>org.apache.camel</groupId>
+        <artifactId>components</artifactId>
+        <version>3.0.0-SNAPSHOT</version>
+    </parent>
+
+    <artifactId>camel-debezium</artifactId>
+    <packaging>jar</packaging>
+    <name>Camel :: Debezium</name>
+    <description>Camel Debezium support</description>
+
+    <properties>
+    </properties>
+
+    <dependencies>
+
+        <!-- camel -->
+        <dependency>
+            <groupId>org.apache.camel</groupId>
+            <artifactId>camel-support</artifactId>
+        </dependency>
+
+        <!-- debezium embedded engine -->
+        <dependency>
+            <groupId>io.debezium</groupId>
+            <artifactId>debezium-embedded</artifactId>
+            <version>${debezium-version}</version>
+        </dependency>
+
+        <!-- debezium connectors -->
+        <dependency>","[{'comment': ""Instead of relying on a specific connector, I'd suggest to add their versions to your BOM (if there is such thing in Camel) and then have users depend on the specific connector they want."", 'commenter': 'gunnarmorling'}]"
3128,components/camel-debezium/src/main/java/org/apache/camel/component/debezium/DebeziumConnectorTypes.java,"@@ -0,0 +1,44 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.debezium;
+
+import io.debezium.connector.mysql.MySqlConnector;
+
+public enum DebeziumConnectorTypes {
+    // for the initial version of the component, we support MySQL
+    MYSQL(""mysql"");","[{'comment': 'Are you planning the others, too? Note I don\'t know that much about Camel, so out of curiosity: why is it that you need to ""know"" about specific Debezium connectors at the Camel end of things?', 'commenter': 'gunnarmorling'}]"
3128,platforms/spring-boot/components-starter/camel-debezium-starter/src/main/java/org/apache/camel/component/debezium/springboot/DebeziumComponentConfiguration.java,"@@ -0,0 +1,68 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.debezium.springboot;
+
+import javax.annotation.Generated;
+import org.apache.camel.spring.boot.ComponentConfigurationPropertiesCommon;
+import org.springframework.boot.context.properties.ConfigurationProperties;
+
+/**
+ * Represents a Debezium endpoint which is used for interacting with Debezium
+ * embedded engine.
+ * 
+ * Generated by camel-package-maven-plugin - do not edit this file!
+ */
+@Generated(""org.apache.camel.maven.packaging.SpringBootAutoConfigurationMojo"")
+@ConfigurationProperties(prefix = ""camel.component.debezium"")
+public class DebeziumComponentConfiguration
+        extends
+            ComponentConfigurationPropertiesCommon {
+
+    /**
+     * Whether to enable auto configuration of the debezium component. This is
+     * enabled by default.
+     */
+    private Boolean enabled;","[{'comment': 'Could be primitive `boolean`?', 'commenter': 'gunnarmorling'}]"
3128,components/camel-debezium/src/main/java/org/apache/camel/component/debezium/DebeziumEndpoint.java,"@@ -0,0 +1,133 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.debezium;
+
+import java.util.concurrent.ExecutorService;
+
+import io.debezium.data.Envelope;
+import org.apache.camel.Consumer;
+import org.apache.camel.Exchange;
+import org.apache.camel.Message;
+import org.apache.camel.Processor;
+import org.apache.camel.Producer;
+import org.apache.camel.component.debezium.configuration.EmbeddedDebeziumConfiguration;
+import org.apache.camel.component.debezium.configuration.MySqlConnectorEmbeddedDebeziumConfiguration;
+import org.apache.camel.spi.UriEndpoint;
+import org.apache.camel.spi.UriParam;
+import org.apache.camel.support.DefaultEndpoint;
+import org.apache.kafka.connect.data.Schema;
+import org.apache.kafka.connect.data.Struct;
+import org.apache.kafka.connect.errors.DataException;
+import org.apache.kafka.connect.source.SourceRecord;
+
+/**
+ * Represents a Debezium endpoint which is used for interacting with Debezium
+ * embedded engine.
+ */
+@UriEndpoint(firstVersion = ""3.0.0"", scheme = ""debezium"", title = ""Debezium"", syntax = ""debezium:connector-name"", label = ""cdc"", consumerOnly = true)
+public class DebeziumEndpoint extends DefaultEndpoint {
+
+    @UriParam
+    private EmbeddedDebeziumConfiguration configuration;
+
+    // is only meant to include different configurations for each connector that is generated by camel-maven plugin
+    @UriParam
+    private MySqlConnectorEmbeddedDebeziumConfiguration mySqlConnectorEmbeddedDebeziumConfiguration;
+
+    public DebeziumEndpoint(String uri, DebeziumComponent component, EmbeddedDebeziumConfiguration config) {
+        super(uri, component);
+        this.configuration = config;
+    }
+
+    public DebeziumEndpoint() {
+    }
+
+    @Override
+    public Producer createProducer() throws Exception {
+        throw new UnsupportedOperationException(""Cannot produce from a DebeziumEndpoint: ""
+                                                + getEndpointUri());
+    }
+
+    public Consumer createConsumer(Processor processor) throws Exception {
+        return new DebeziumConsumer(this, processor);
+    }
+
+    public boolean isSingleton() {
+        return true;
+    }
+
+    public EmbeddedDebeziumConfiguration getConfiguration() {
+        return configuration;
+    }
+
+    public void setConfiguration(EmbeddedDebeziumConfiguration configuration) {
+        this.configuration = configuration;
+    }
+
+    public MySqlConnectorEmbeddedDebeziumConfiguration getMySqlConnectorEmbeddedDebeziumConfiguration() {
+        return mySqlConnectorEmbeddedDebeziumConfiguration;
+    }
+
+    public ExecutorService createExecutor() {
+        return getCamelContext().getExecutorServiceManager().newSingleThreadExecutor(this,
+                                                                                     ""DebeziumConsumer"");
+    }
+
+    public Exchange createDbzExchange(final SourceRecord record) {
+        final Exchange exchange = super.createExchange();
+
+        final Message message = exchange.getIn();
+
+        message.setHeader(DebeziumConstants.FIELD_IDENTIFIER, record.topic());
+        message.setHeader(DebeziumConstants.FIELD_KEY, record.key());
+        message.setHeader(DebeziumConstants.FIELD_SOURCE, record.sourceOffset());
+        setOperationFieldInHeader(message, record.valueSchema(), record.value());
+
+        message.setBody(record.value());","[{'comment': 'So here\'s a general question: IIUC, you pass on the original type of the change event (i.e. the `Struct` obtained from the `SourceRecord`); I\'m wondering whether that\'s a good idea, as it exposes the Kafka Connect specific types to the Camel route, which might not be desirable. As said, I\'m no Camel expert, so I have no idea really by which types messages are typically represented. If it is hash maps basically, you might do the following:\r\n\r\n* create a `Map` with the fields of the ""after"" `Struct`from the ``SourceRecord``s value and use this as the message body\r\n* create a  `Map` with the fields from the ``SourceRecord``s key and propagate this as message header (assuming you can have maps there)\r\n* pass `op`, `ts` and all the values from the `source` struct as header properties\r\n* create a `Map` with the fields of the ""before"" `Struct`from the ``SourceRecord``s value and pass this on as a message header\r\n\r\nThat way, the message body would just a map with the new row column values (or null/empty map in case of a ""d"" event), which *may* help to make these messages easier to handle with existing Camel sinks. Alternatively, you also might create a nested structure just with ""before""/""after"" and propagate the other things above as headers (that kind of mapping is what we currently consider for CloudEvents).\r\n\r\nYet another solution might be to convert the entire Debezium event envelope into a JSON structure. Again, I\'m not sure what\'d work best in terms of Camel\'s conventions/expectations, but exposing the Kafka Connect types might be not ideal. Probably it\'d also be a good idea to do some integration testing / PoC of sorts with selected consumers (at least JDBC sink), so to get a better feeling of what would be most useful.', 'commenter': 'gunnarmorling'}]"
3128,components/camel-debezium/src/main/java/org/apache/camel/component/debezium/DebeziumEndpoint.java,"@@ -0,0 +1,133 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.debezium;
+
+import java.util.concurrent.ExecutorService;
+
+import io.debezium.data.Envelope;
+import org.apache.camel.Consumer;
+import org.apache.camel.Exchange;
+import org.apache.camel.Message;
+import org.apache.camel.Processor;
+import org.apache.camel.Producer;
+import org.apache.camel.component.debezium.configuration.EmbeddedDebeziumConfiguration;
+import org.apache.camel.component.debezium.configuration.MySqlConnectorEmbeddedDebeziumConfiguration;
+import org.apache.camel.spi.UriEndpoint;
+import org.apache.camel.spi.UriParam;
+import org.apache.camel.support.DefaultEndpoint;
+import org.apache.kafka.connect.data.Schema;
+import org.apache.kafka.connect.data.Struct;
+import org.apache.kafka.connect.errors.DataException;
+import org.apache.kafka.connect.source.SourceRecord;
+
+/**
+ * Represents a Debezium endpoint which is used for interacting with Debezium
+ * embedded engine.
+ */
+@UriEndpoint(firstVersion = ""3.0.0"", scheme = ""debezium"", title = ""Debezium"", syntax = ""debezium:connector-name"", label = ""cdc"", consumerOnly = true)
+public class DebeziumEndpoint extends DefaultEndpoint {
+
+    @UriParam
+    private EmbeddedDebeziumConfiguration configuration;
+
+    // is only meant to include different configurations for each connector that is generated by camel-maven plugin
+    @UriParam
+    private MySqlConnectorEmbeddedDebeziumConfiguration mySqlConnectorEmbeddedDebeziumConfiguration;
+
+    public DebeziumEndpoint(String uri, DebeziumComponent component, EmbeddedDebeziumConfiguration config) {
+        super(uri, component);
+        this.configuration = config;
+    }
+
+    public DebeziumEndpoint() {
+    }
+
+    @Override
+    public Producer createProducer() throws Exception {
+        throw new UnsupportedOperationException(""Cannot produce from a DebeziumEndpoint: ""
+                                                + getEndpointUri());
+    }
+
+    public Consumer createConsumer(Processor processor) throws Exception {
+        return new DebeziumConsumer(this, processor);
+    }
+
+    public boolean isSingleton() {
+        return true;
+    }
+
+    public EmbeddedDebeziumConfiguration getConfiguration() {
+        return configuration;
+    }
+
+    public void setConfiguration(EmbeddedDebeziumConfiguration configuration) {
+        this.configuration = configuration;
+    }
+
+    public MySqlConnectorEmbeddedDebeziumConfiguration getMySqlConnectorEmbeddedDebeziumConfiguration() {
+        return mySqlConnectorEmbeddedDebeziumConfiguration;
+    }
+
+    public ExecutorService createExecutor() {
+        return getCamelContext().getExecutorServiceManager().newSingleThreadExecutor(this,
+                                                                                     ""DebeziumConsumer"");
+    }
+
+    public Exchange createDbzExchange(final SourceRecord record) {
+        final Exchange exchange = super.createExchange();
+
+        final Message message = exchange.getIn();
+
+        message.setHeader(DebeziumConstants.FIELD_IDENTIFIER, record.topic());
+        message.setHeader(DebeziumConstants.FIELD_KEY, record.key());
+        message.setHeader(DebeziumConstants.FIELD_SOURCE, record.sourceOffset());","[{'comment': ""Why is it you expose the source offset here? Is it really needed? It's mostly specific to the actual Kafka transport."", 'commenter': 'gunnarmorling'}]"
3147,core/camel-core/src/main/docs/eips/marshal-eip.adoc,"@@ -1,7 +1,7 @@
 [[marshal-eip]]
 = Marshal EIP
 
-Marshalling is the opposite of unmarshalling, where a bean is marshalled into some binary or textual format for transmission over some transport via a Camel https://github.com/apache/camel/tree/master/components[Components]. Marshalling is used in the same way as unmarshalling above; in the https://github.com/apache/camel/blob/master/docs/user-manual/en/dsl.adoc[DSL] you can use a DataFormat instance, you can configure the DataFormat dynamically using the DSL or you can refer to a named instance of the format in the https://github.com/apache/camel/blob/master/docs/user-manual/en/registry.adoc[Registry].
+Marshalling is the opposite of unmarshalling, where a bean is marshalled into some binary or textual format for transmission over some transport via a Camel https://github.com/apache/camel/tree/master/components[Components]. Marshalling is used in the same way as unmarshalling above; in the https://github.com/apache/camel/blob/master/docs/user-manual/modules/ROOT/pages/dsl.adoc[DSL] you can use a DataFormat instance, you can configure the DataFormat dynamically using the DSL or you can refer to a named instance of the format in the https://github.com/apache/camel/blob/master/docs/user-manual/modules/ROOT/pages/registry.adoc[Registry].","[{'comment': ""Here it would be better if we were to link between pages using `xref`. There's some [documentation on the Antora site](https://docs.antora.org/antora/2.0/asciidoc/page-to-page-xref/) that explains this better. Those links won't work on GitHub but they will when rendered as a part of the website build.\r\n\r\nIf you want to test your changes you can run `./mvnw -f docs verify` from the root of the git repository, this will both copy files into right locations and run a check to see if all the `xref` links are pointing to an existing document.\r\n\r\n```suggestion\r\nMarshalling is the opposite of unmarshalling, where a bean is marshalled into some binary or textual format for transmission over some transport via a Camel xref:components::index.adoc[Components]. Marshalling is used in the same way as unmarshalling above; in the xref:dsl.adoc[DSL] you can use a DataFormat instance, you can configure the DataFormat dynamically using the DSL or you can refer to a named instance of the format in the xref:registry.adoc[Registry].\r\n```"", 'commenter': 'zregvart'}]"
3147,CONTRIBUTING.md,"@@ -49,7 +49,7 @@ To edit the documentation:
    - Create a commit and raise a Pull Request
 - If you want to add more documentation check for .adoc in codebase 
 
-For more information see [How does the website work](https://github.com/apache/camel/blob/master/docs/user-manual/en/faq/how-does-the-website-work.adoc) or [How do I edit the website for more details](https://github.com/apache/camel/blob/master/docs/user-manual/en/faq/how-do-i-edit-the-website.adoc).
+For more information see [How does the website work](https://github.com/apache/camel/blob/master/docs/user-manual/modules/ROOT/pages/faq/how-does-the-website-work.adoc) or [How do I edit the website for more details](https://github.com/apache/camel/blob/master/docs/user-manual/modules/ROOT/pages/faq/how-do-i-edit-the-website.adoc).","[{'comment': 'Perhaps we can point to the rendered documentation on the website.\r\n\r\n```suggestion\r\nFor more information see [How does the website work](https://camel.apache.org/manual/latest/faq/how-does-the-website-work.html) or [How do I edit the website for more details](https://camel.apache.org/manual/latest/faq/how-do-i-edit-the-website.html).\r\n```', 'commenter': 'zregvart'}]"
3147,core/camel-core/src/main/docs/eips/pipeline-eip.adoc,"@@ -1,12 +1,12 @@
 [[pipeline-eip]]
 = Pipeline EIP
 
-Camel supports the http://www.enterpriseintegrationpatterns.com/PipesAndFilters.html[Pipes and Filters] from the https://github.com/apache/camel/blob/master/docs/user-manual/en/enterprise-integration-patterns.adoc[EIP patterns] in various ways.
+Camel supports the http://www.enterpriseintegrationpatterns.com/PipesAndFilters.html[Pipes and Filters] from the https://github.com/apache/camel/blob/master/docs/user-manual/modules/ROOT/pages/enterprise-integration-patterns.adoc[EIP patterns] in various ways.","[{'comment': '```suggestion\r\nCamel supports the http://www.enterpriseintegrationpatterns.com/PipesAndFilters.html[Pipes and Filters] from the xref:enterprise-integration-patterns.adoc[EIP patterns] in various ways.\r\n```', 'commenter': 'zregvart'}]"
3147,core/camel-core/src/main/docs/eips/pipeline-eip.adoc,"@@ -1,12 +1,12 @@
 [[pipeline-eip]]
 = Pipeline EIP
 
-Camel supports the http://www.enterpriseintegrationpatterns.com/PipesAndFilters.html[Pipes and Filters] from the https://github.com/apache/camel/blob/master/docs/user-manual/en/enterprise-integration-patterns.adoc[EIP patterns] in various ways.
+Camel supports the http://www.enterpriseintegrationpatterns.com/PipesAndFilters.html[Pipes and Filters] from the https://github.com/apache/camel/blob/master/docs/user-manual/modules/ROOT/pages/enterprise-integration-patterns.adoc[EIP patterns] in various ways.
 
 image::eip/PipesAndFilters.gif[image]
 
 With Camel you can split your processing across multiple independent
-https://github.com/apache/camel/blob/master/docs/user-manual/en/endpoint.adoc[Endpoint] instances which can then be chained
+https://github.com/apache/camel/blob/master/docs/user-manual/modules/ROOT/pages/endpoint.adoc[Endpoint] instances which can then be chained","[{'comment': '```suggestion\r\nxref:endpoint.adoc[Endpoint] instances which can then be chained\r\n```', 'commenter': 'zregvart'}]"
3147,core/camel-core/src/main/docs/eips/pipeline-eip.adoc,"@@ -19,7 +19,7 @@ The Pipeline EIP has no options.
 == Examples
 
 You can create pipelines of logic using multiple
-https://github.com/apache/camel/blob/master/docs/user-manual/en/endpoint.adoc[Endpoint] or https://github.com/apache/camel/blob/master/camel-core/src/main/docs/eips/message-translator.adoc[Message
+https://github.com/apache/camel/blob/master/docs/user-manual/modules/ROOT/pages/endpoint.adoc[Endpoint] or https://github.com/apache/camel/blob/master/camel-core/src/main/docs/eips/message-translator.adoc[Message","[{'comment': '```suggestion\r\nxref:endpoint.adoc[Endpoint] or xref:message-translator.adoc[Message\r\n```', 'commenter': 'zregvart'}]"
3147,core/camel-core/src/main/docs/eips/process-eip.adoc,"@@ -32,7 +32,7 @@ public class MyProcessor implements Processor {
 
 You can then easily use this inside a route by declaring the bean in
 Spring, say via the XML (or registering it in JNDI if that is your
-https://github.com/apache/camel/blob/master/docs/user-manual/en/registry.adoc[Registry])
+https://github.com/apache/camel/blob/master/docs/user-manual/modules/ROOT/pages/registry.adoc[Registry])","[{'comment': '```suggestion\r\nxref:registry.adoc[Registry])\r\n```', 'commenter': 'zregvart'}]"
3147,core/camel-core/src/main/docs/eips/process-eip.adoc,"@@ -58,7 +58,7 @@ Processor myProcessor = new MyProcessor();
 from(""activemq:myQueue"").process(myProcessor);
 ----
 
-If you need to lookup the processor in the https://github.com/apache/camel/blob/master/docs/user-manual/en/registry.adoc[Registry]
+If you need to lookup the processor in the https://github.com/apache/camel/blob/master/docs/user-manual/modules/ROOT/pages/registry.adoc[Registry]","[{'comment': '```suggestion\r\nIf you need to lookup the processor in the xref:registry.adoc[Registry]\r\n```', 'commenter': 'zregvart'}]"
3147,core/camel-core/src/main/docs/eips/rollback-eip.adoc,"@@ -115,7 +115,7 @@ from(""activemq:queue:foo"").policy(notsupported).to(""activemq:queue:bar"");
 
 === OSGi Blueprint
 
-If you are using https://github.com/apache/camel/blob/master/docs/user-manual/en/using-osgi-blueprint-with-camel.adoc[OSGi
+If you are using https://github.com/apache/camel/blob/master/docs/user-manual/modules/ROOT/pages/using-osgi-blueprint-with-camel.adoc[OSGi","[{'comment': '```suggestion\r\nIf you are using xref:using-osgi-blueprint-with-camel.adoc[OSGi\r\n```', 'commenter': 'zregvart'}]"
3147,core/camel-core/src/main/docs/eips/rollback-eip.adoc,"@@ -188,7 +188,7 @@ Transaction error handler
 When a route is marked as transacted using *transacted* Camel will
 automatic use the
 xref:transactionerrorhandler.adoc[TransactionErrorHandler] as
-https://github.com/apache/camel/blob/master/docs/user-manual/en/error-handler.adoc[Error Handler]. It supports basically the same
+https://github.com/apache/camel/blob/master/docs/user-manual/modules/ROOT/pages/error-handler.adoc[Error Handler]. It supports basically the same","[{'comment': '```suggestion\r\nxref:error-handler.adoc[Error Handler]. It supports basically the same\r\n```', 'commenter': 'zregvart'}]"
3147,core/camel-core/src/main/docs/eips/step-eip.adoc,"@@ -1,7 +1,7 @@
 [[step-eip]]
 = Step EIP
 
-Camel supports the http://www.enterpriseintegrationpatterns.com/PipesAndFilters.html[Pipes and Filters] from the https://github.com/apache/camel/blob/master/docs/user-manual/en/enterprise-integration-patterns.adoc[EIP patterns] in various ways.
+Camel supports the http://www.enterpriseintegrationpatterns.com/PipesAndFilters.html[Pipes and Filters] from the https://github.com/apache/camel/blob/master/docs/user-manual/modules/ROOT/pages/enterprise-integration-patterns.adoc[EIP patterns] in various ways.","[{'comment': '```suggestion\r\nCamel supports the http://www.enterpriseintegrationpatterns.com/PipesAndFilters.html[Pipes and Filters] from the xref:enterprise-integration-patterns.adoc[EIP patterns] in various ways.\r\n```', 'commenter': 'zregvart'}]"
3147,core/camel-core/src/main/docs/eips/unmarshal-eip.adoc,"@@ -28,7 +28,7 @@ from(""activemq:My.Queue"").
   to(""mqseries:Another.Queue"");
 ----
 
-The above uses a named DataFormat of _jaxb_ which is configured with a number of Java package names. You can if you prefer use a named reference to a data format which can then be defined in your https://github.com/apache/camel/blob/master/docs/user-manual/en/registry.adoc[Registry] such as via your xref:components::spring.adoc[Spring] XML file.
+The above uses a named DataFormat of _jaxb_ which is configured with a number of Java package names. You can if you prefer use a named reference to a data format which can then be defined in your https://github.com/apache/camel/blob/master/docs/user-manual/modules/ROOT/pages/registry.adoc[Registry] such as via your xref:components::spring.adoc[Spring] XML file.","[{'comment': '```suggestion\r\nThe above uses a named DataFormat of _jaxb_ which is configured with a number of Java package names. You can if you prefer use a named reference to a data format which can then be defined in your xref:registry.adoc[Registry] such as via your xref:components::spring.adoc[Spring] XML file.\r\n```', 'commenter': 'zregvart'}]"
3147,docs/user-manual/modules/ROOT/pages/contributing.adoc,"@@ -51,7 +51,7 @@ To edit the documentation:
  ** Create a commit and raise a Pull Request
 * If you want to add more documentation check for .adoc in codebase
 
-For more information see https://github.com/apache/camel/blob/master/docs/user-manual/en/faq/how-does-the-website-work.adoc[How does the website work] or https://github.com/apache/camel/blob/master/docs/user-manual/en/faq/how-do-i-edit-the-website.adoc[How do I edit the website for more details].
+For more information see https://github.com/apache/camel/blob/master/docs/user-manual/modules/ROOT/pages/faq/how-does-the-website-work.adoc[How does the website work] or https://github.com/apache/camel/blob/master/docs/user-manual/modules/ROOT/pages/faq/how-do-i-edit-the-website.adoc[How do I edit the website for more details].","[{'comment': '```suggestion\r\nFor more information see xref:faq/how-does-the-website-work.adoc[How does the website work] or xref:faq/how-do-i-edit-the-website.adoc[How do I edit the website for more details].\r\n```', 'commenter': 'zregvart'}]"
3147,docs/user-manual/modules/ROOT/pages/faq/how-does-camel-compare-to-mule.adoc,"@@ -25,5 +25,5 @@ routing/mediation engines. The main differences are as follows:
 * Camel supports an implicit xref:type-converter.adoc[Type Converter] in
   the core API to make it simpler to connect components together requiring
   different types of payload & headers
-* Camel uses the https://github.com/apache/camel/blob/master/docs/user-manual/en/notice.md[Apache 2 License] rather than Mule's more restrictive
+* Camel uses the https://github.com/apache/camel/blob/master/docs/user-manual/modules/ROOT/pages/notice.md[Apache 2 License] rather than Mule's more restrictive","[{'comment': ""Let's point to the official one\r\n\r\n```suggestion\r\n* Camel uses the https://apache.org/licenses/LICENSE-2.0[Apache 2 License] rather than Mule's more restrictive\r\n```"", 'commenter': 'zregvart'}]"
3147,docs/user-manual/modules/ROOT/pages/marshal-eip.adoc,"@@ -2,7 +2,7 @@
 = Marshal EIP
 :page-source: core/camel-core/src/main/docs/eips/marshal-eip.adoc
 
-Marshalling is the opposite of unmarshalling, where a bean is marshalled into some binary or textual format for transmission over some transport via a Camel https://github.com/apache/camel/tree/master/components[Components]. Marshalling is used in the same way as unmarshalling above; in the https://github.com/apache/camel/blob/master/docs/user-manual/en/dsl.adoc[DSL] you can use a DataFormat instance, you can configure the DataFormat dynamically using the DSL or you can refer to a named instance of the format in the https://github.com/apache/camel/blob/master/docs/user-manual/en/registry.adoc[Registry].
+Marshalling is the opposite of unmarshalling, where a bean is marshalled into some binary or textual format for transmission over some transport via a Camel https://github.com/apache/camel/tree/master/components[Components]. Marshalling is used in the same way as unmarshalling above; in the https://github.com/apache/camel/blob/master/docs/user-manual/modules/ROOT/pages/dsl.adoc[DSL] you can use a DataFormat instance, you can configure the DataFormat dynamically using the DSL or you can refer to a named instance of the format in the https://github.com/apache/camel/blob/master/docs/user-manual/modules/ROOT/pages/registry.adoc[Registry].","[{'comment': '```suggestion\r\nMarshalling is the opposite of unmarshalling, where a bean is marshalled into some binary or textual format for transmission over some transport via a Camel xref:components::index.adoc[Components]. Marshalling is used in the same way as unmarshalling above; in the xref:dsl.adoc[DSL] you can use a DataFormat instance, you can configure the DataFormat dynamically using the DSL or you can refer to a named instance of the format in the xref:registry.adoc[Registry].\r\n```', 'commenter': 'zregvart'}]"
3147,docs/user-manual/modules/ROOT/pages/pipeline-eip.adoc,"@@ -2,12 +2,12 @@
 = Pipeline EIP
 :page-source: core/camel-core/src/main/docs/eips/pipeline-eip.adoc
 
-Camel supports the http://www.enterpriseintegrationpatterns.com/PipesAndFilters.html[Pipes and Filters] from the https://github.com/apache/camel/blob/master/docs/user-manual/en/enterprise-integration-patterns.adoc[EIP patterns] in various ways.
+Camel supports the http://www.enterpriseintegrationpatterns.com/PipesAndFilters.html[Pipes and Filters] from the https://github.com/apache/camel/blob/master/docs/user-manual/modules/ROOT/pages/enterprise-integration-patterns.adoc[EIP patterns] in various ways.","[{'comment': '```suggestion\r\nCamel supports the http://www.enterpriseintegrationpatterns.com/PipesAndFilters.html[Pipes and Filters] from the xref:enterprise-integration-patterns.adoc[EIP patterns] in various ways.\r\n```', 'commenter': 'zregvart'}]"
3147,docs/user-manual/modules/ROOT/pages/pipeline-eip.adoc,"@@ -2,12 +2,12 @@
 = Pipeline EIP
 :page-source: core/camel-core/src/main/docs/eips/pipeline-eip.adoc
 
-Camel supports the http://www.enterpriseintegrationpatterns.com/PipesAndFilters.html[Pipes and Filters] from the https://github.com/apache/camel/blob/master/docs/user-manual/en/enterprise-integration-patterns.adoc[EIP patterns] in various ways.
+Camel supports the http://www.enterpriseintegrationpatterns.com/PipesAndFilters.html[Pipes and Filters] from the https://github.com/apache/camel/blob/master/docs/user-manual/modules/ROOT/pages/enterprise-integration-patterns.adoc[EIP patterns] in various ways.
 
 image::eip/PipesAndFilters.gif[image]
 
 With Camel you can split your processing across multiple independent
-https://github.com/apache/camel/blob/master/docs/user-manual/en/endpoint.adoc[Endpoint] instances which can then be chained
+https://github.com/apache/camel/blob/master/docs/user-manual/modules/ROOT/pages/endpoint.adoc[Endpoint] instances which can then be chained","[{'comment': '```suggestion\r\nxref:endpoint.adoc[Endpoint] instances which can then be chained\r\n```', 'commenter': 'zregvart'}]"
3147,docs/user-manual/modules/ROOT/pages/pipeline-eip.adoc,"@@ -20,7 +20,7 @@ The Pipeline EIP has no options.
 == Examples
 
 You can create pipelines of logic using multiple
-https://github.com/apache/camel/blob/master/docs/user-manual/en/endpoint.adoc[Endpoint] or https://github.com/apache/camel/blob/master/camel-core/src/main/docs/eips/message-translator.adoc[Message
+https://github.com/apache/camel/blob/master/docs/user-manual/modules/ROOT/pages/endpoint.adoc[Endpoint] or https://github.com/apache/camel/blob/master/camel-core/src/main/docs/eips/message-translator.adoc[Message","[{'comment': '```suggestion\r\nxref:endpoint.adoc[Endpoint] or xref:message-translator.adoc[Message\r\n```', 'commenter': 'zregvart'}]"
3147,docs/user-manual/modules/ROOT/pages/process-eip.adoc,"@@ -33,7 +33,7 @@ public class MyProcessor implements Processor {
 
 You can then easily use this inside a route by declaring the bean in
 Spring, say via the XML (or registering it in JNDI if that is your
-https://github.com/apache/camel/blob/master/docs/user-manual/en/registry.adoc[Registry])
+https://github.com/apache/camel/blob/master/docs/user-manual/modules/ROOT/pages/registry.adoc[Registry])","[{'comment': '```suggestion\r\nxref:registry.adoc[Registry])\r\n```', 'commenter': 'zregvart'}]"
3147,docs/user-manual/modules/ROOT/pages/process-eip.adoc,"@@ -59,7 +59,7 @@ Processor myProcessor = new MyProcessor();
 from(""activemq:myQueue"").process(myProcessor);
 ----
 
-If you need to lookup the processor in the https://github.com/apache/camel/blob/master/docs/user-manual/en/registry.adoc[Registry]
+If you need to lookup the processor in the https://github.com/apache/camel/blob/master/docs/user-manual/modules/ROOT/pages/registry.adoc[Registry]","[{'comment': '```suggestion\r\nIf you need to lookup the processor in the xref:registry.adoc[Registry]\r\n```', 'commenter': 'zregvart'}]"
3147,docs/user-manual/modules/ROOT/pages/rollback-eip.adoc,"@@ -116,7 +116,7 @@ from(""activemq:queue:foo"").policy(notsupported).to(""activemq:queue:bar"");
 
 === OSGi Blueprint
 
-If you are using https://github.com/apache/camel/blob/master/docs/user-manual/en/using-osgi-blueprint-with-camel.adoc[OSGi
+If you are using https://github.com/apache/camel/blob/master/docs/user-manual/modules/ROOT/pages/using-osgi-blueprint-with-camel.adoc[OSGi","[{'comment': '```suggestion\r\nIf you are using xref:using-osgi-blueprint-with-camel.adoc[OSGi\r\n```', 'commenter': 'zregvart'}]"
3147,docs/user-manual/modules/ROOT/pages/rollback-eip.adoc,"@@ -189,7 +189,7 @@ Transaction error handler
 When a route is marked as transacted using *transacted* Camel will
 automatic use the
 xref:transactionerrorhandler.adoc[TransactionErrorHandler] as
-https://github.com/apache/camel/blob/master/docs/user-manual/en/error-handler.adoc[Error Handler]. It supports basically the same
+https://github.com/apache/camel/blob/master/docs/user-manual/modules/ROOT/pages/error-handler.adoc[Error Handler]. It supports basically the same","[{'comment': '```suggestion\r\nxref:error-handler.adoc[Error Handler]. It supports basically the same\r\n```', 'commenter': 'zregvart'}]"
3147,docs/user-manual/modules/ROOT/pages/step-eip.adoc,"@@ -2,7 +2,7 @@
 = Step EIP
 :page-source: core/camel-core/src/main/docs/eips/step-eip.adoc
 
-Camel supports the http://www.enterpriseintegrationpatterns.com/PipesAndFilters.html[Pipes and Filters] from the https://github.com/apache/camel/blob/master/docs/user-manual/en/enterprise-integration-patterns.adoc[EIP patterns] in various ways.
+Camel supports the http://www.enterpriseintegrationpatterns.com/PipesAndFilters.html[Pipes and Filters] from the https://github.com/apache/camel/blob/master/docs/user-manual/modules/ROOT/pages/enterprise-integration-patterns.adoc[EIP patterns] in various ways.","[{'comment': '```suggestion\r\nCamel supports the http://www.enterpriseintegrationpatterns.com/PipesAndFilters.html[Pipes and Filters] from the xref:enterprise-integration-patterns.adoc[EIP patterns] in various ways.\r\n```', 'commenter': 'zregvart'}]"
3147,docs/user-manual/modules/ROOT/pages/unmarshal-eip.adoc,"@@ -29,7 +29,7 @@ from(""activemq:My.Queue"").
   to(""mqseries:Another.Queue"");
 ----
 
-The above uses a named DataFormat of _jaxb_ which is configured with a number of Java package names. You can if you prefer use a named reference to a data format which can then be defined in your https://github.com/apache/camel/blob/master/docs/user-manual/en/registry.adoc[Registry] such as via your xref:components::spring.adoc[Spring] XML file.
+The above uses a named DataFormat of _jaxb_ which is configured with a number of Java package names. You can if you prefer use a named reference to a data format which can then be defined in your https://github.com/apache/camel/blob/master/docs/user-manual/modules/ROOT/pages/registry.adoc[Registry] such as via your xref:components::spring.adoc[Spring] XML file.","[{'comment': '```suggestion\r\nThe above uses a named DataFormat of _jaxb_ which is configured with a number of Java package names. You can if you prefer use a named reference to a data format which can then be defined in your xref:registry.adoc[Registry] such as via your xref:components::spring.adoc[Spring] XML file.\r\n```', 'commenter': 'zregvart'}]"
3165,core/camel-util/src/test/java/org/apache/camel/util/OgnlHelperTest.java,"@@ -0,0 +1,26 @@
+package org.apache.camel.util;","[{'comment': 'nit: the licence header needs to be added here', 'commenter': 'omarsmak'}]"
3165,core/camel-util/src/test/java/org/apache/camel/util/OgnlHelperTest.java,"@@ -0,0 +1,26 @@
+package org.apache.camel.util;
+
+import org.junit.Assert;
+import org.junit.Test;
+
+import java.util.List;","[{'comment': 'nit: the order needs to be rearranged', 'commenter': 'omarsmak'}]"
3165,core/camel-util/src/main/java/org/apache/camel/util/OgnlHelper.java,"@@ -279,7 +280,7 @@ public static String removeOperators(String ognlExpression) {
         }
 
         String last = methods.isEmpty() ? null : methods.get(methods.size() - 1);
-        if (parenthesisBracket && last != null) {
+        if (parenthesisBracketCnt>0 && last != null) {","[{'comment': 'nit: there should be whitespace between `>`', 'commenter': 'omarsmak'}]"
3171,examples/camel-example-debezium/.gitignore,"@@ -0,0 +1 @@
+*.data","[{'comment': 'I think this can be removed.', 'commenter': 'oscerd'}, {'comment': 'This intends to ignore the generated offset files by Debezium in order to avoid pushing them accidentally :p ', 'commenter': 'omarsmak'}]"
3171,examples/camel-example-debezium/pom.xml,"@@ -0,0 +1,113 @@
+<?xml version=""1.0""?>
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one or more
+    contributor license agreements.  See the NOTICE file distributed with
+    this work for additional information regarding copyright ownership.
+    The ASF licenses this file to You under the Apache License, Version 2.0
+    (the ""License""); you may not use this file except in compliance with
+    the License.  You may obtain a copy of the License at
+
+         http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an ""AS IS"" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+
+-->
+<project xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xmlns=""http://maven.apache.org/POM/4.0.0""
+         xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+
+    <modelVersion>4.0.0</modelVersion>
+
+    <parent>
+        <groupId>org.apache.camel.example</groupId>
+        <artifactId>examples</artifactId>
+        <version>3.0.0-SNAPSHOT</version>
+    </parent>
+
+    <artifactId>camel-example-debezium</artifactId>
+    <name>Camel :: Example :: Debezium</name>
+    <description>An example for Debezium Component</description>
+
+    <properties>
+        <category>Change Data Capture</category>","[{'comment': 'The category for Examples should be a bit more generic', 'commenter': 'oscerd'}]"
3171,examples/camel-example-debezium/src/main/java/org/apache/camel/example/debezium/DebeziumMySqlConsumerToKinesis.java,"@@ -0,0 +1,112 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.example.debezium;
+
+import java.util.HashMap;
+import java.util.Map;
+
+import org.apache.camel.CamelContext;
+import org.apache.camel.builder.RouteBuilder;
+import org.apache.camel.component.aws.kinesis.KinesisConstants;
+import org.apache.camel.component.debezium.DebeziumConstants;
+import org.apache.camel.component.properties.PropertiesComponent;
+import org.apache.camel.impl.DefaultCamelContext;
+import org.apache.camel.model.dataformat.JsonLibrary;
+import org.apache.kafka.connect.data.Struct;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * A simple example to consume data from Debezium and send it to Kinesis
+ */
+public final class DebeziumMySqlConsumerToKinesis {
+
+    private static final Logger LOG = LoggerFactory.getLogger(DebeziumMySqlConsumerToKinesis.class);
+
+    private DebeziumMySqlConsumerToKinesis() {
+    }
+
+    public static void main(String[] args) throws Exception {
+
+        LOG.info(""About to run Debezium integration..."");","[{'comment': 'Maybe this at debug. Too noisy.', 'commenter': 'oscerd'}]"
3171,examples/camel-example-debezium/src/main/java/org/apache/camel/example/debezium/KinesisProducerToCassandra.java,"@@ -0,0 +1,110 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.example.debezium;
+
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.Map;
+
+import org.apache.camel.CamelContext;
+import org.apache.camel.builder.RouteBuilder;
+import org.apache.camel.component.properties.PropertiesComponent;
+import org.apache.camel.impl.DefaultCamelContext;
+import org.apache.camel.model.dataformat.JsonLibrary;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * A simple example to sink data from Kinesis that produced by Debezium into Cassandra
+ */
+public final class KinesisProducerToCassandra {
+
+    private static final Logger LOG = LoggerFactory.getLogger(KinesisProducerToCassandra.class);
+
+    private KinesisProducerToCassandra() {
+    }
+
+    public static void main(String[] args) throws Exception {
+
+        LOG.info(""About to run Kinesis to Cassandra integration..."");","[{'comment': 'Debug here too, I guess', 'commenter': 'oscerd'}]"
3171,examples/camel-example-debezium/src/main/java/org/apache/camel/example/debezium/DebeziumMySqlConsumerToKinesis.java,"@@ -37,17 +36,18 @@
 
     private static final Logger LOG = LoggerFactory.getLogger(DebeziumMySqlConsumerToKinesis.class);
 
+    // use Camel Main to setup and run Camel
+    private static Main main = new Main();
+
     private DebeziumMySqlConsumerToKinesis() {
     }
 
     public static void main(String[] args) throws Exception {
 
         LOG.debug(""About to run Debezium integration..."");
 
-        final CamelContext camelContext = new DefaultCamelContext();
-
-
-        camelContext.addRoutes(new RouteBuilder() {
+        // add route
+        main.addRouteBuilder(new RouteBuilder() {
             public void configure() {
                 final PropertiesComponent pc = getContext().getComponent(""properties"", PropertiesComponent.class);","[{'comment': 'camel-main has this out of the box, you dont need to setup the properties component for this', 'commenter': 'davsclaus'}]"
3171,examples/camel-example-debezium/src/main/java/org/apache/camel/example/debezium/KinesisProducerToCassandra.java,"@@ -35,16 +34,18 @@
 
     private static final Logger LOG = LoggerFactory.getLogger(KinesisProducerToCassandra.class);
 
+    // use Camel Main to setup and run Camel
+    private static Main main = new Main();
+
     private KinesisProducerToCassandra() {
     }
 
     public static void main(String[] args) throws Exception {
 
         LOG.debug(""About to run Kinesis to Cassandra integration..."");
 
-        final CamelContext camelContext = new DefaultCamelContext();
-
-        camelContext.addRoutes(new RouteBuilder() {
+        // add route
+        main.addRouteBuilder(new RouteBuilder() {
             public void configure() {
                 final PropertiesComponent pc = getContext().getComponent(""properties"", PropertiesComponent.class);","[{'comment': 'Same as above', 'commenter': 'davsclaus'}]"
3172,apache-camel/pom.xml,"@@ -1226,6 +1226,11 @@
       <artifactId>camel-ribbon</artifactId>
       <version>${project.version}</version>
     </dependency>
+    <dependency>","[{'comment': 'Here you are missing the stater', 'commenter': 'oscerd'}]"
3172,components/camel-robotframework/src/main/docs/robotframework-component.adoc,"@@ -0,0 +1,160 @@
+[[Robotframework-component]]
+== Robotframework Component
+
+*Available as of Camel version 3.0.0*
+
+The *robotframework:* component allows for processing camel exchanges
+in acceptence test suites which are already implemented with its own DSL. 
+The depending keyword libraries that can be used inside test suites 
+implemented in Robot DSL, could have been implemented either via 
+Java or Pyhton.
+
+This component will let you execute business logic of acceptence test cases 
+in Robot language on which you can pass parameters to feed data via power 
+of Camel Routes, however there is no reverse binding of parameters back where
+you can pass values back into Camel exchange. Therefore, for that reason, it actually
+acts like a template language passing camel exchanges by binding data into the test 
+cases implemented. 
+
+[source,xml]
+-------------------------------------------------------------------------------------
+<dependency>
+    <groupId>org.apache.camel</groupId>
+    <artifactId>camel-robotframework</artifactId>
+    <version>x.x.x</version> <!-- use the same version as your Camel core version -->
+</dependency>
+-------------------------------------------------------------------------------------
+
+### URI format
+
+[source,java]
+-------------------------------
+robotframework:templateName[?options]
+-------------------------------
+
+Where *templateName* is the classpath-local URI of the template to
+invoke; or the complete URL of the remote template (eg:
+\file://folder/myfile.robot).
+
+You can append query options to the URI in the following format,
+`?option=value&option=value&...`
+
+### Options
+
+// component options: START
+","[{'comment': 'I think this must be populated anyway.', 'commenter': 'oscerd'}, {'comment': 'i ran full build but those were not populated. doing it again. let me see if they will get populated. will update soon.', 'commenter': 'onderson'}, {'comment': 'Is not going to work I guess, I think there is a bug in the maven plugin, when it checks for the for the Schema JSON file that is generated from the `schema` endpoint parameter, it checks with case sensitivity, since your schema is `scheme = ""RobotFramework""`, it failed to load the json file since it was expecting the name to be without uppercase `robotframework.json`. To workaround it, can you please change the schema name to `robotframework` and run the full build again? I will fix that small bug later', 'commenter': 'omarsmak'}, {'comment': 'Update: I was wrong here, in fact your schema name **should** be in small case ', 'commenter': 'omarsmak'}]"
3172,components/camel-robotframework/src/main/java/org/apache/camel/component/robotframework/RobotFrameworkCamelConfiguration.java,"@@ -0,0 +1,787 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.robotframework;
+
+import java.io.File;
+
+import org.apache.camel.RuntimeCamelException;
+import org.apache.camel.spi.UriParam;
+import org.apache.camel.spi.UriParams;
+
+@UriParams
+public class RobotFrameworkCamelConfiguration implements Cloneable {
+
+    /**","[{'comment': 'This can be moved to getter/setter section, same for all the javadoc', 'commenter': 'oscerd'}]"
3172,components/camel-robotframework/src/main/java/org/apache/camel/component/robotframework/RobotFrameworkCamelConstants.java,"@@ -0,0 +1,32 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.robotframework;
+
+public interface RobotFrameworkCamelConstants {
+
+    public final String ROBOT_CAMEL_EXCHANGE_NAME = ""exchange"";","[{'comment': ""It doesn't seem generic enough as name, same for the others ROBOT_VAR"", 'commenter': 'oscerd'}, {'comment': ""moved them into utils and left what's used to set headers and whatnot.."", 'commenter': 'onderson'}]"
3172,components/camel-robotframework/src/main/resources/META-INF/services/org/apache/camel/component/robotframework,"@@ -0,0 +1,18 @@
+#
+# Licensed to the Apache Software Foundation (ASF) under one or more
+# contributor license agreements.  See the NOTICE file distributed with
+# this work for additional information regarding copyright ownership.
+# The ASF licenses this file to You under the Apache License, Version 2.0
+# (the ""License""); you may not use this file except in compliance with
+# the License.  You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an ""AS IS"" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+class=org.apache.camel.component.robotframework.RobotFrameworkComponent","[{'comment': 'In camel 3 this is not needed anymore, it will be autogenerated during the build', 'commenter': 'oscerd'}, {'comment': 'removed that bit.', 'commenter': 'onderson'}]"
3172,components/camel-robotframework/src/main/java/org/apache/camel/component/robotframework/RobotFrameworkEndpoint.java,"@@ -0,0 +1,149 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.robotframework;
+
+import java.io.File;
+import java.util.Arrays;
+import java.util.List;
+
+import org.apache.camel.Exchange;
+import org.apache.camel.ExchangePattern;
+import org.apache.camel.component.ResourceEndpoint;
+import org.apache.camel.spi.UriEndpoint;
+import org.apache.camel.spi.UriParam;
+import org.apache.camel.util.ObjectHelper;
+import org.robotframework.RobotFramework;
+
+/**
+ * Represents a RobotFramework endpoint.
+ */
+@UriEndpoint(firstVersion = ""3.0.0-SNAPSHOT"", scheme = ""RobotFramework"", title = ""RobotFramework"", syntax = ""robotframework:resourceUri"", label = ""test execution"")
+public class RobotFrameworkEndpoint extends ResourceEndpoint {
+
+    @UriParam
+    private RobotFrameworkCamelConfiguration configuration;
+
+    public RobotFrameworkEndpoint(String uri, RobotFrameworkComponent component, String resourceUri, RobotFrameworkCamelConfiguration configuration) {
+        super(uri, component, resourceUri);
+        this.configuration = configuration;
+    }
+
+    public boolean isSingleton() {
+        return true;
+    }
+
+    @Override
+    public ExchangePattern getExchangePattern() {
+        return ExchangePattern.InOut;
+    }
+
+    @Override
+    protected String createEndpointUri() {
+        return ""robotframework:"" + getResourceUri();
+    }
+
+    public RobotFrameworkCamelConfiguration getConfiguration() {
+        return configuration;
+    }
+
+    @Override
+    protected void onExchange(Exchange exchange) throws Exception {
+        // create robot arguments to pass
+        RobotFrameworkArguments generatedArguments = new RobotFrameworkArguments();
+
+        generatedArguments.addFileToArguments(configuration.getOutputDirectory(), ""-d"");
+        generatedArguments.addFileToArguments(configuration.getOutput(), ""-o"");
+        generatedArguments.addFileToArguments(configuration.getLog(), ""-l"");
+        generatedArguments.addFileToArguments(configuration.getReport(), ""-r"");
+        generatedArguments.addFileToArguments(configuration.getDebugFile(), ""-b"");
+        generatedArguments.addFileToArguments(configuration.getArgumentFile(), ""-A"");
+        generatedArguments.addFileToArguments(configuration.getRunFailed(), ""-R"");
+
+        generatedArguments.addNonEmptyStringToArguments(configuration.getName(), ""-N"");
+        generatedArguments.addNonEmptyStringToArguments(configuration.getDocument(), ""-D"");
+        generatedArguments.addNonEmptyStringToArguments(configuration.getRunMode(), ""--runmode"");
+        generatedArguments.addFlagToArguments(configuration.isDryrun(), ""--dryrun"");
+        generatedArguments.addFlagToArguments(configuration.isExitOnFailure(), ""--exitonfailure"");
+        generatedArguments.addFlagToArguments(configuration.isSkipTeardownOnExit(), ""--skipteardownonexit"");
+        generatedArguments.addNonEmptyStringToArguments(configuration.getRandomize(), ""--randomize"");
+        generatedArguments.addNonEmptyStringToArguments(configuration.getSplitOutputs(), ""--splitoutputs"");
+        generatedArguments.addNonEmptyStringToArguments(configuration.getLogTitle(), ""--logtitle"");
+        generatedArguments.addNonEmptyStringToArguments(configuration.getReportTitle(), ""--reporttitle"");
+        generatedArguments.addNonEmptyStringToArguments(configuration.getReportBackground(), ""--reportbackground"");
+        generatedArguments.addNonEmptyStringToArguments(configuration.getSummaryTitle(), ""--summarytitle"");
+        generatedArguments.addNonEmptyStringToArguments(configuration.getLogLevel(), ""-L"");
+        generatedArguments.addNonEmptyStringToArguments(configuration.getSuiteStatLevel(), ""--suitestatlevel"");
+        generatedArguments.addNonEmptyStringToArguments(configuration.getMonitorWidth(), ""--monitorwidth"");
+        generatedArguments.addNonEmptyStringToArguments(configuration.getMonitorColors(), ""--monitorcolors"");
+        generatedArguments.addNonEmptyStringToArguments(configuration.getListener(), ""--listener"");
+
+        generatedArguments.addFlagToArguments(configuration.isRunEmptySuite(), ""--runemptysuite"");
+        generatedArguments.addFlagToArguments(configuration.isNoStatusReturnCode(), ""--nostatusrc"");
+        generatedArguments.addFlagToArguments(configuration.isTimestampOutputs(), ""-T"");
+        generatedArguments.addFlagToArguments(configuration.isWarnOnSkippedFiles(), ""--warnonskippedfiles"");
+
+        generatedArguments.addListToArguments(Arrays.asList((configuration.getMetadata() != null ? configuration.getMetadata() : """").split("","")), ""-M"");
+        generatedArguments.addListToArguments(Arrays.asList((configuration.getTags() != null ? configuration.getTags() : """").split("","")), ""-G"");
+        generatedArguments.addListToArguments(Arrays.asList((configuration.getTests() != null ? configuration.getTests() : """").split("","")), ""-t"");
+        generatedArguments.addListToArguments(Arrays.asList((configuration.getSuites() != null ? configuration.getSuites() : """").split("","")), ""-s"");
+        generatedArguments.addListToArguments(Arrays.asList((configuration.getIncludes() != null ? configuration.getIncludes() : """").split("","")), ""-i"");
+        generatedArguments.addListToArguments(Arrays.asList((configuration.getExcludes() != null ? configuration.getExcludes() : """").split("","")), ""-e"");
+        generatedArguments.addListToArguments(Arrays.asList((configuration.getCriticalTags() != null ? configuration.getCriticalTags() : """").split("","")), ""-c"");
+        generatedArguments.addListToArguments(Arrays.asList((configuration.getNonCriticalTags() != null ? configuration.getNonCriticalTags() : """").split("","")), ""-n"");
+
+        // create variables from camel exchange to pass into robot
+        List<String> variables = RobotFrameworkCamelUtils.createRobotVariablesFromCamelExchange(exchange);
+        exchange.getIn().setHeader(RobotFrameworkCamelConstants.CAMEL_ROBOT_VARIABLES, variables);
+        generatedArguments.addListToArguments(variables, ""-v"");
+
+        generatedArguments.addListToArguments(Arrays.asList((configuration.getVariableFiles() != null ? configuration.getVariableFiles() : """").split("","")), ""-V"");
+        generatedArguments.addListToArguments(Arrays.asList((configuration.getTagStatIncludes() != null ? configuration.getTagStatIncludes() : """").split("","")), ""--tagstatinclude"");
+        generatedArguments.addListToArguments(Arrays.asList((configuration.getTagStatExcludes() != null ? configuration.getTagStatExcludes() : """").split("","")), ""--tagstatexclude"");
+        generatedArguments.addListToArguments(Arrays.asList((configuration.getCombinedTagStats() != null ? configuration.getCombinedTagStats() : """").split("","")), ""--tagstatcombine"");
+        generatedArguments.addListToArguments(Arrays.asList((configuration.getTagDocs() != null ? configuration.getTagDocs() : """").split("","")), ""--tagdoc"");
+        generatedArguments.addListToArguments(Arrays.asList((configuration.getTagStatLinks() != null ? configuration.getTagStatLinks() : """").split("","")), ""--tagstatlink"");
+        generatedArguments.addListToArguments(Arrays.asList((configuration.getListeners() != null ? configuration.getListeners() : """").split("","")), ""--listener"");
+
+        // process path and set robot env by that to specify which test cases to
+        // run
+        // either from a directory or from a file
+        String path = getResourceUri();
+        ObjectHelper.notNull(path, ""resourceUri"");
+        log.info(""RobotFrameworkEndpoint resourceUri:{}"", path);
+        
+        String newResourceUri = exchange.getIn().getHeader(RobotFrameworkCamelConstants.CAMEL_ROBOT_RESOURCE_URI, String.class);
+        if (newResourceUri != null) {
+            exchange.getIn().removeHeader(RobotFrameworkCamelConstants.CAMEL_ROBOT_RESOURCE_URI);
+            log.debug(""{} set to {} setting resourceUri to pass robotframework"", RobotFrameworkCamelConstants.CAMEL_ROBOT_RESOURCE_URI, newResourceUri);
+            path = newResourceUri;
+        }
+
+        if (configuration.getXunitFile() == null) {
+            String testCasesFolderName = path;
+            configuration.setXunitFile(new File(""TEST-"" + testCasesFolderName.replace(' ', '_') + "".xml""));","[{'comment': ""I was wondering, wouldn't be better to have test files created under `target` folder?"", 'commenter': 'omarsmak'}, {'comment': 'Also I saw some other files being created when I ran the tests:\r\n```\r\nOutput:  /Users/oalsafi/Work/Apache/camel/components/camel-robotframework/output.xml\r\nXUnit:   /Users/oalsafi/Work/Apache/camel/components/camel-robotframework/TEST-src/test/resources/org/apache/camel/component/robotframework/set_variable_camel_exchange.robot.xml\r\nLog:     /Users/oalsafi/Work/Apache/camel/components/camel-robotframework/log.html\r\nReport:  /Users/oalsafi/Work/Apache/camel/components/camel-robotframework/report.html\r\n```\r\nSo I was wondering as well for these files if they should be created under `target`?', 'commenter': 'omarsmak'}, {'comment': 'Can we just do like this?:\r\n```suggestion\r\n            configuration.setXunitFile(new File(""TEST-"" + path.replace(\' \', \'_\') + "".xml""));\r\n```\r\nand remove `testCasesFolderName`?', 'commenter': 'omarsmak'}, {'comment': 'not neccessary. that option can be user-configured. for unit tests, i set that option to get them generated in target folder.', 'commenter': 'onderson'}]"
3172,components/camel-robotframework/src/main/java/org/apache/camel/component/robotframework/RobotFrameworkArguments.java,"@@ -0,0 +1,95 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.robotframework;
+
+import java.io.File;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+import org.apache.camel.util.ObjectHelper;
+
+public class RobotFrameworkArguments {
+
+    private final List<String> arguments = new ArrayList<String>();
+
+    public void addFileToArguments(File file, String flag) {
+        if (isFileValid(file)) {
+            String path = !file.getName().toUpperCase().equals(""NONE"") ? file.getPath() : file.getName();
+            add(flag, path);
+        }
+    }
+
+    protected boolean isFileValid(File file) {
+        return file != null && file.getPath() != null && !file.getPath().equals("""");
+    }
+
+    public void addNonEmptyStringToArguments(String variableToAdd, String flag) {
+        if (!ObjectHelper.isEmpty(variableToAdd)) {
+            addStringToArguments(variableToAdd, flag);
+        }
+    }
+
+    public void addFlagToArguments(boolean flag, String argument) {
+        if (flag) {
+            add(argument);
+        }
+    }
+
+    public void addStringToArguments(String variableToAdd, String flag) {
+        add(flag, variableToAdd);
+    }
+
+    public void addListToArguments(String variablesToAdd, String flag) {
+        if (variablesToAdd == null) {
+            return;
+        }
+        String[] splittedVariabledToAdd = variablesToAdd.split("","");","[{'comment': 'nit: I think you meant here `splitVariablesToAdd`? \r\n```suggestion\r\n        String[] splitVariablesToAdd = variablesToAdd.split("","");\r\n```', 'commenter': 'omarsmak'}]"
3172,components/camel-robotframework/src/main/java/org/apache/camel/component/robotframework/RobotFrameworkArguments.java,"@@ -0,0 +1,95 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.robotframework;
+
+import java.io.File;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+import org.apache.camel.util.ObjectHelper;
+
+public class RobotFrameworkArguments {
+
+    private final List<String> arguments = new ArrayList<String>();
+
+    public void addFileToArguments(File file, String flag) {
+        if (isFileValid(file)) {
+            String path = !file.getName().toUpperCase().equals(""NONE"") ? file.getPath() : file.getName();
+            add(flag, path);
+        }
+    }
+
+    protected boolean isFileValid(File file) {
+        return file != null && file.getPath() != null && !file.getPath().equals("""");
+    }
+
+    public void addNonEmptyStringToArguments(String variableToAdd, String flag) {
+        if (!ObjectHelper.isEmpty(variableToAdd)) {
+            addStringToArguments(variableToAdd, flag);
+        }
+    }
+
+    public void addFlagToArguments(boolean flag, String argument) {
+        if (flag) {
+            add(argument);
+        }
+    }
+
+    public void addStringToArguments(String variableToAdd, String flag) {
+        add(flag, variableToAdd);
+    }
+
+    public void addListToArguments(String variablesToAdd, String flag) {
+        if (variablesToAdd == null) {
+            return;
+        }
+        String[] splittedVariabledToAdd = variablesToAdd.split("","");
+        addListToArguments(new ArrayList<String>(Arrays.asList(splittedVariabledToAdd)), flag);
+    }
+
+    public void addListToArguments(List<String> variablesToAdd, String flag) {
+        if (variablesToAdd == null) {
+            return;
+        }
+        for (String variableToAdd : variablesToAdd) {
+            if (!ObjectHelper.isEmpty(variableToAdd)) {
+                add(flag, variableToAdd);
+            }
+        }
+    }
+
+    public void addFileListToArguments(List<File> variablesToAdd, String flag) {
+        if (variablesToAdd == null) {
+            return;
+        }
+        for (File variableToAdd : variablesToAdd) {
+            addFileToArguments(variableToAdd, flag);
+        }
+    }
+
+    public void add(String... values) {
+        for (String value : values) {","[{'comment': 'Do you think is better to replace it with `Collection.addAll`? \r\n```suggestion\r\n       arguments.addAll(Arrays.asList(values));\r\n```', 'commenter': 'omarsmak'}]"
3172,components/camel-robotframework/src/main/java/org/apache/camel/component/robotframework/RobotFrameworkEndpoint.java,"@@ -0,0 +1,149 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.robotframework;
+
+import java.io.File;
+import java.util.Arrays;
+import java.util.List;
+
+import org.apache.camel.Exchange;
+import org.apache.camel.ExchangePattern;
+import org.apache.camel.component.ResourceEndpoint;
+import org.apache.camel.spi.UriEndpoint;
+import org.apache.camel.spi.UriParam;
+import org.apache.camel.util.ObjectHelper;
+import org.robotframework.RobotFramework;
+
+/**
+ * Represents a RobotFramework endpoint.
+ */
+@UriEndpoint(firstVersion = ""3.0.0-SNAPSHOT"", scheme = ""RobotFramework"", title = ""RobotFramework"", syntax = ""robotframework:resourceUri"", label = ""test execution"")
+public class RobotFrameworkEndpoint extends ResourceEndpoint {
+
+    @UriParam
+    private RobotFrameworkCamelConfiguration configuration;
+
+    public RobotFrameworkEndpoint(String uri, RobotFrameworkComponent component, String resourceUri, RobotFrameworkCamelConfiguration configuration) {
+        super(uri, component, resourceUri);
+        this.configuration = configuration;
+    }
+
+    public boolean isSingleton() {
+        return true;","[{'comment': ""I think you don't need to override since is by default set to `true`"", 'commenter': 'omarsmak'}]"
3172,components/camel-robotframework/src/main/java/org/apache/camel/component/robotframework/RobotFrameworkEndpoint.java,"@@ -0,0 +1,149 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.robotframework;
+
+import java.io.File;
+import java.util.Arrays;
+import java.util.List;
+
+import org.apache.camel.Exchange;
+import org.apache.camel.ExchangePattern;
+import org.apache.camel.component.ResourceEndpoint;
+import org.apache.camel.spi.UriEndpoint;
+import org.apache.camel.spi.UriParam;
+import org.apache.camel.util.ObjectHelper;
+import org.robotframework.RobotFramework;
+
+/**
+ * Represents a RobotFramework endpoint.
+ */
+@UriEndpoint(firstVersion = ""3.0.0-SNAPSHOT"", scheme = ""RobotFramework"", title = ""RobotFramework"", syntax = ""robotframework:resourceUri"", label = ""test execution"")
+public class RobotFrameworkEndpoint extends ResourceEndpoint {
+
+    @UriParam
+    private RobotFrameworkCamelConfiguration configuration;
+
+    public RobotFrameworkEndpoint(String uri, RobotFrameworkComponent component, String resourceUri, RobotFrameworkCamelConfiguration configuration) {
+        super(uri, component, resourceUri);
+        this.configuration = configuration;
+    }
+
+    public boolean isSingleton() {
+        return true;
+    }
+
+    @Override
+    public ExchangePattern getExchangePattern() {
+        return ExchangePattern.InOut;
+    }
+
+    @Override
+    protected String createEndpointUri() {
+        return ""robotframework:"" + getResourceUri();
+    }
+
+    public RobotFrameworkCamelConfiguration getConfiguration() {
+        return configuration;
+    }
+
+    @Override
+    protected void onExchange(Exchange exchange) throws Exception {
+        // create robot arguments to pass
+        RobotFrameworkArguments generatedArguments = new RobotFrameworkArguments();
+
+        generatedArguments.addFileToArguments(configuration.getOutputDirectory(), ""-d"");
+        generatedArguments.addFileToArguments(configuration.getOutput(), ""-o"");
+        generatedArguments.addFileToArguments(configuration.getLog(), ""-l"");
+        generatedArguments.addFileToArguments(configuration.getReport(), ""-r"");
+        generatedArguments.addFileToArguments(configuration.getDebugFile(), ""-b"");
+        generatedArguments.addFileToArguments(configuration.getArgumentFile(), ""-A"");
+        generatedArguments.addFileToArguments(configuration.getRunFailed(), ""-R"");
+
+        generatedArguments.addNonEmptyStringToArguments(configuration.getName(), ""-N"");
+        generatedArguments.addNonEmptyStringToArguments(configuration.getDocument(), ""-D"");
+        generatedArguments.addNonEmptyStringToArguments(configuration.getRunMode(), ""--runmode"");
+        generatedArguments.addFlagToArguments(configuration.isDryrun(), ""--dryrun"");
+        generatedArguments.addFlagToArguments(configuration.isExitOnFailure(), ""--exitonfailure"");
+        generatedArguments.addFlagToArguments(configuration.isSkipTeardownOnExit(), ""--skipteardownonexit"");
+        generatedArguments.addNonEmptyStringToArguments(configuration.getRandomize(), ""--randomize"");
+        generatedArguments.addNonEmptyStringToArguments(configuration.getSplitOutputs(), ""--splitoutputs"");
+        generatedArguments.addNonEmptyStringToArguments(configuration.getLogTitle(), ""--logtitle"");
+        generatedArguments.addNonEmptyStringToArguments(configuration.getReportTitle(), ""--reporttitle"");
+        generatedArguments.addNonEmptyStringToArguments(configuration.getReportBackground(), ""--reportbackground"");
+        generatedArguments.addNonEmptyStringToArguments(configuration.getSummaryTitle(), ""--summarytitle"");
+        generatedArguments.addNonEmptyStringToArguments(configuration.getLogLevel(), ""-L"");
+        generatedArguments.addNonEmptyStringToArguments(configuration.getSuiteStatLevel(), ""--suitestatlevel"");
+        generatedArguments.addNonEmptyStringToArguments(configuration.getMonitorWidth(), ""--monitorwidth"");
+        generatedArguments.addNonEmptyStringToArguments(configuration.getMonitorColors(), ""--monitorcolors"");
+        generatedArguments.addNonEmptyStringToArguments(configuration.getListener(), ""--listener"");
+
+        generatedArguments.addFlagToArguments(configuration.isRunEmptySuite(), ""--runemptysuite"");
+        generatedArguments.addFlagToArguments(configuration.isNoStatusReturnCode(), ""--nostatusrc"");
+        generatedArguments.addFlagToArguments(configuration.isTimestampOutputs(), ""-T"");
+        generatedArguments.addFlagToArguments(configuration.isWarnOnSkippedFiles(), ""--warnonskippedfiles"");
+
+        generatedArguments.addListToArguments(Arrays.asList((configuration.getMetadata() != null ? configuration.getMetadata() : """").split("","")), ""-M"");
+        generatedArguments.addListToArguments(Arrays.asList((configuration.getTags() != null ? configuration.getTags() : """").split("","")), ""-G"");
+        generatedArguments.addListToArguments(Arrays.asList((configuration.getTests() != null ? configuration.getTests() : """").split("","")), ""-t"");
+        generatedArguments.addListToArguments(Arrays.asList((configuration.getSuites() != null ? configuration.getSuites() : """").split("","")), ""-s"");
+        generatedArguments.addListToArguments(Arrays.asList((configuration.getIncludes() != null ? configuration.getIncludes() : """").split("","")), ""-i"");
+        generatedArguments.addListToArguments(Arrays.asList((configuration.getExcludes() != null ? configuration.getExcludes() : """").split("","")), ""-e"");
+        generatedArguments.addListToArguments(Arrays.asList((configuration.getCriticalTags() != null ? configuration.getCriticalTags() : """").split("","")), ""-c"");
+        generatedArguments.addListToArguments(Arrays.asList((configuration.getNonCriticalTags() != null ? configuration.getNonCriticalTags() : """").split("","")), ""-n"");
+
+        // create variables from camel exchange to pass into robot
+        List<String> variables = RobotFrameworkCamelUtils.createRobotVariablesFromCamelExchange(exchange);
+        exchange.getIn().setHeader(RobotFrameworkCamelConstants.CAMEL_ROBOT_VARIABLES, variables);
+        generatedArguments.addListToArguments(variables, ""-v"");
+
+        generatedArguments.addListToArguments(Arrays.asList((configuration.getVariableFiles() != null ? configuration.getVariableFiles() : """").split("","")), ""-V"");
+        generatedArguments.addListToArguments(Arrays.asList((configuration.getTagStatIncludes() != null ? configuration.getTagStatIncludes() : """").split("","")), ""--tagstatinclude"");
+        generatedArguments.addListToArguments(Arrays.asList((configuration.getTagStatExcludes() != null ? configuration.getTagStatExcludes() : """").split("","")), ""--tagstatexclude"");
+        generatedArguments.addListToArguments(Arrays.asList((configuration.getCombinedTagStats() != null ? configuration.getCombinedTagStats() : """").split("","")), ""--tagstatcombine"");
+        generatedArguments.addListToArguments(Arrays.asList((configuration.getTagDocs() != null ? configuration.getTagDocs() : """").split("","")), ""--tagdoc"");
+        generatedArguments.addListToArguments(Arrays.asList((configuration.getTagStatLinks() != null ? configuration.getTagStatLinks() : """").split("","")), ""--tagstatlink"");
+        generatedArguments.addListToArguments(Arrays.asList((configuration.getListeners() != null ? configuration.getListeners() : """").split("","")), ""--listener"");
+
+        // process path and set robot env by that to specify which test cases to
+        // run
+        // either from a directory or from a file
+        String path = getResourceUri();
+        ObjectHelper.notNull(path, ""resourceUri"");
+        log.info(""RobotFrameworkEndpoint resourceUri:{}"", path);
+        
+        String newResourceUri = exchange.getIn().getHeader(RobotFrameworkCamelConstants.CAMEL_ROBOT_RESOURCE_URI, String.class);
+        if (newResourceUri != null) {
+            exchange.getIn().removeHeader(RobotFrameworkCamelConstants.CAMEL_ROBOT_RESOURCE_URI);
+            log.debug(""{} set to {} setting resourceUri to pass robotframework"", RobotFrameworkCamelConstants.CAMEL_ROBOT_RESOURCE_URI, newResourceUri);
+            path = newResourceUri;
+        }
+
+        if (configuration.getXunitFile() == null) {
+            String testCasesFolderName = path;
+            configuration.setXunitFile(new File(""TEST-"" + testCasesFolderName.replace(' ', '_') + "".xml""));
+        }
+        generatedArguments.addFileToArguments(configuration.getXunitFile(), ""-x"");
+        generatedArguments.addFlagToArguments(true, ""--xunitskipnoncritical"");
+
+        generatedArguments.add(path);","[{'comment': 'Do you think it would make sense to have the code responsible `path` creation separated into a different function:\r\n```suggestion\r\n        generatedArguments.add(createPath());\r\n```', 'commenter': 'omarsmak'}, {'comment': 'not really imho.', 'commenter': 'onderson'}, {'comment': ""The purpose is here to just decompose the function and give more readability and make the code more conscious. However, if you think it doesn't make sense, then is fine "", 'commenter': 'omarsmak'}]"
3172,components/camel-robotframework/src/main/java/org/apache/camel/component/robotframework/RobotFrameworkEndpoint.java,"@@ -0,0 +1,144 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.robotframework;
+
+import java.io.File;
+import java.util.Arrays;
+import java.util.List;
+
+import org.apache.camel.Exchange;
+import org.apache.camel.ExchangePattern;
+import org.apache.camel.component.ResourceEndpoint;
+import org.apache.camel.spi.UriEndpoint;
+import org.apache.camel.spi.UriParam;
+import org.apache.camel.util.ObjectHelper;
+import org.robotframework.RobotFramework;
+
+/**
+ * Represents a RobotFramework endpoint.
+ */
+@UriEndpoint(firstVersion = ""3.0.0-SNAPSHOT"", scheme = ""RobotFramework"", title = ""RobotFramework"", syntax = ""robotframework:resourceUri"", label = ""test execution"")","[{'comment': 'Remove -SNAPSHOT', 'commenter': 'davsclaus'}, {'comment': 'label = ""testing""', 'commenter': 'davsclaus'}]"
3172,components/camel-robotframework/src/main/java/org/apache/camel/component/robotframework/RobotFrameworkEndpoint.java,"@@ -0,0 +1,144 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.robotframework;
+
+import java.io.File;
+import java.util.Arrays;
+import java.util.List;
+
+import org.apache.camel.Exchange;
+import org.apache.camel.ExchangePattern;
+import org.apache.camel.component.ResourceEndpoint;
+import org.apache.camel.spi.UriEndpoint;
+import org.apache.camel.spi.UriParam;
+import org.apache.camel.util.ObjectHelper;
+import org.robotframework.RobotFramework;
+
+/**
+ * Represents a RobotFramework endpoint.
+ */
+@UriEndpoint(firstVersion = ""3.0.0-SNAPSHOT"", scheme = ""RobotFramework"", title = ""RobotFramework"", syntax = ""robotframework:resourceUri"", label = ""test execution"")
+public class RobotFrameworkEndpoint extends ResourceEndpoint {
+
+    @UriParam
+    private RobotFrameworkCamelConfiguration configuration;
+
+    public RobotFrameworkEndpoint(String uri, RobotFrameworkComponent component, String resourceUri, RobotFrameworkCamelConfiguration configuration) {
+        super(uri, component, resourceUri);
+        this.configuration = configuration;
+    }
+
+    @Override
+    public ExchangePattern getExchangePattern() {
+        return ExchangePattern.InOut;
+    }
+
+    @Override
+    protected String createEndpointUri() {
+        return ""robotframework:"" + getResourceUri();
+    }
+
+    public RobotFrameworkCamelConfiguration getConfiguration() {
+        return configuration;
+    }
+
+    @Override
+    protected void onExchange(Exchange exchange) throws Exception {
+        // create robot arguments to pass
+        RobotFrameworkArguments generatedArguments = new RobotFrameworkArguments();
+
+        generatedArguments.addFileToArguments(configuration.getOutputDirectory(), ""-d"");
+        generatedArguments.addFileToArguments(configuration.getOutput(), ""-o"");
+        generatedArguments.addFileToArguments(configuration.getLog(), ""-l"");
+        generatedArguments.addFileToArguments(configuration.getReport(), ""-r"");
+        generatedArguments.addFileToArguments(configuration.getDebugFile(), ""-b"");
+        generatedArguments.addFileToArguments(configuration.getArgumentFile(), ""-A"");
+        generatedArguments.addFileToArguments(configuration.getRunFailed(), ""-R"");
+
+        generatedArguments.addNonEmptyStringToArguments(configuration.getName(), ""-N"");
+        generatedArguments.addNonEmptyStringToArguments(configuration.getDocument(), ""-D"");
+        generatedArguments.addNonEmptyStringToArguments(configuration.getRunMode(), ""--runmode"");
+        generatedArguments.addFlagToArguments(configuration.isDryrun(), ""--dryrun"");
+        generatedArguments.addFlagToArguments(configuration.isExitOnFailure(), ""--exitonfailure"");
+        generatedArguments.addFlagToArguments(configuration.isSkipTeardownOnExit(), ""--skipteardownonexit"");
+        generatedArguments.addNonEmptyStringToArguments(configuration.getRandomize(), ""--randomize"");
+        generatedArguments.addNonEmptyStringToArguments(configuration.getSplitOutputs(), ""--splitoutputs"");
+        generatedArguments.addNonEmptyStringToArguments(configuration.getLogTitle(), ""--logtitle"");
+        generatedArguments.addNonEmptyStringToArguments(configuration.getReportTitle(), ""--reporttitle"");
+        generatedArguments.addNonEmptyStringToArguments(configuration.getReportBackground(), ""--reportbackground"");
+        generatedArguments.addNonEmptyStringToArguments(configuration.getSummaryTitle(), ""--summarytitle"");
+        generatedArguments.addNonEmptyStringToArguments(configuration.getLogLevel(), ""-L"");
+        generatedArguments.addNonEmptyStringToArguments(configuration.getSuiteStatLevel(), ""--suitestatlevel"");
+        generatedArguments.addNonEmptyStringToArguments(configuration.getMonitorWidth(), ""--monitorwidth"");
+        generatedArguments.addNonEmptyStringToArguments(configuration.getMonitorColors(), ""--monitorcolors"");
+        generatedArguments.addNonEmptyStringToArguments(configuration.getListener(), ""--listener"");
+
+        generatedArguments.addFlagToArguments(configuration.isRunEmptySuite(), ""--runemptysuite"");
+        generatedArguments.addFlagToArguments(configuration.isNoStatusReturnCode(), ""--nostatusrc"");
+        generatedArguments.addFlagToArguments(configuration.isTimestampOutputs(), ""-T"");
+        generatedArguments.addFlagToArguments(configuration.isWarnOnSkippedFiles(), ""--warnonskippedfiles"");
+
+        generatedArguments.addListToArguments(Arrays.asList((configuration.getMetadata() != null ? configuration.getMetadata() : """").split("","")), ""-M"");
+        generatedArguments.addListToArguments(Arrays.asList((configuration.getTags() != null ? configuration.getTags() : """").split("","")), ""-G"");
+        generatedArguments.addListToArguments(Arrays.asList((configuration.getTests() != null ? configuration.getTests() : """").split("","")), ""-t"");
+        generatedArguments.addListToArguments(Arrays.asList((configuration.getSuites() != null ? configuration.getSuites() : """").split("","")), ""-s"");
+        generatedArguments.addListToArguments(Arrays.asList((configuration.getIncludes() != null ? configuration.getIncludes() : """").split("","")), ""-i"");
+        generatedArguments.addListToArguments(Arrays.asList((configuration.getExcludes() != null ? configuration.getExcludes() : """").split("","")), ""-e"");
+        generatedArguments.addListToArguments(Arrays.asList((configuration.getCriticalTags() != null ? configuration.getCriticalTags() : """").split("","")), ""-c"");
+        generatedArguments.addListToArguments(Arrays.asList((configuration.getNonCriticalTags() != null ? configuration.getNonCriticalTags() : """").split("","")), ""-n"");
+
+        // create variables from camel exchange to pass into robot
+        List<String> variables = RobotFrameworkCamelUtils.createRobotVariablesFromCamelExchange(exchange);
+        exchange.getIn().setHeader(RobotFrameworkCamelConstants.CAMEL_ROBOT_VARIABLES, variables);
+        generatedArguments.addListToArguments(variables, ""-v"");
+
+        generatedArguments.addListToArguments(Arrays.asList((configuration.getVariableFiles() != null ? configuration.getVariableFiles() : """").split("","")), ""-V"");
+        generatedArguments.addListToArguments(Arrays.asList((configuration.getTagStatIncludes() != null ? configuration.getTagStatIncludes() : """").split("","")), ""--tagstatinclude"");
+        generatedArguments.addListToArguments(Arrays.asList((configuration.getTagStatExcludes() != null ? configuration.getTagStatExcludes() : """").split("","")), ""--tagstatexclude"");
+        generatedArguments.addListToArguments(Arrays.asList((configuration.getCombinedTagStats() != null ? configuration.getCombinedTagStats() : """").split("","")), ""--tagstatcombine"");
+        generatedArguments.addListToArguments(Arrays.asList((configuration.getTagDocs() != null ? configuration.getTagDocs() : """").split("","")), ""--tagdoc"");
+        generatedArguments.addListToArguments(Arrays.asList((configuration.getTagStatLinks() != null ? configuration.getTagStatLinks() : """").split("","")), ""--tagstatlink"");
+        generatedArguments.addListToArguments(Arrays.asList((configuration.getListeners() != null ? configuration.getListeners() : """").split("","")), ""--listener"");
+
+        // process path and set robot env by that to specify which test cases to
+        // run
+        // either from a directory or from a file
+        String path = getResourceUri();
+        ObjectHelper.notNull(path, ""resourceUri"");
+        log.info(""RobotFrameworkEndpoint resourceUri:{}"", path);","[{'comment': 'Reduce to DEBUG level', 'commenter': 'davsclaus'}]"
3183,components/camel-hdfs/src/main/java/org/apache/camel/component/hdfs/HdfsConfiguration.java,"@@ -171,33 +191,63 @@ private String getString(Map<String, Object> hdfsSettings, String param, String
 
     private List<HdfsProducer.SplitStrategy> getSplitStrategies(Map<String, Object> hdfsSettings) {
         List<HdfsProducer.SplitStrategy> strategies = new ArrayList<>();
-        for (Object obj : hdfsSettings.keySet()) {
-            String key = (String) obj;
-            if (""splitStrategy"".equals(key)) {
-                String eit = (String) hdfsSettings.get(key);
-                if (eit != null) {
-                    String[] strstrategies = eit.split("","");
-                    for (String strstrategy : strstrategies) {
-                        String tokens[] = strstrategy.split("":"");
-                        if (tokens.length != 2) {
-                            throw new IllegalArgumentException(""Wrong Split Strategy "" + key + ""="" + eit);
-                        }
-                        HdfsProducer.SplitStrategyType sst = HdfsProducer.SplitStrategyType.valueOf(tokens[0]);
-                        long ssv = Long.valueOf(tokens[1]);
-                        strategies.add(new HdfsProducer.SplitStrategy(sst, ssv));
-                    }
+
+        splitStrategy = getString(hdfsSettings, ""splitStrategy"", kerberosNamedNodes);
+
+        if (Objects.nonNull(splitStrategy)) {
+            String[] strstrategies = splitStrategy.split("","");
+            for (String strstrategy : strstrategies) {
+                String[] tokens = strstrategy.split("":"");
+                if (tokens.length != 2) {
+                    throw new IllegalArgumentException(""Wrong Split Strategy [splitStrategy"" + ""="" + splitStrategy + ""]"");
                 }
+                HdfsProducer.SplitStrategyType sst = HdfsProducer.SplitStrategyType.valueOf(tokens[0]);
+                long ssv = Long.parseLong(tokens[1]);
+                strategies.add(new HdfsProducer.SplitStrategy(sst, ssv));
             }
         }
         return strategies;
     }
 
+    private List<String> getKerberosNamedNodeList(Map<String, Object> hdfsSettings) {
+        kerberosNamedNodes = getString(hdfsSettings, ""kerberosNamedNodes"", kerberosNamedNodes);
+        return Arrays.stream(kerberosNamedNodes.split("","")).distinct().collect(Collectors.toList());
+    }
+
+
+    Configuration getJAASConfiguration() {","[{'comment': ""Is there a specific reason to move the jaasconfiguration here? It was a parameter at component level , now it's not even an endpoint option. It doesn't seem right."", 'commenter': 'oscerd'}, {'comment': 'Good point, will redesign. My aim was to remove the static method, and make the refactoring easy, but the result is indeed not optimal.', 'commenter': 'marius-cornescu'}, {'comment': 'Redesigned, please re-check.', 'commenter': 'marius-cornescu'}]"
3183,components/camel-hdfs/src/main/java/org/apache/camel/component/hdfs/HdfsFileType.java,"@@ -54,9 +41,21 @@
 import org.apache.hadoop.io.Text;
 import org.apache.hadoop.io.Writable;
 import org.apache.hadoop.io.WritableComparable;
-import org.apache.hadoop.util.Progressable;
 import org.apache.hadoop.util.ReflectionUtils;
 
+import java.io.ByteArrayOutputStream;","[{'comment': 'This breaks the code style. Please run the module build with sourcecheck profile enabled and check the warnings', 'commenter': 'oscerd'}, {'comment': ""Is there a codestype profile for intelij I could use? I've done the formatting with the default setting."", 'commenter': 'marius-cornescu'}, {'comment': 'The available stuff is here https://github.com/apache/camel/tree/master/buildingtools/src/main/resources', 'commenter': 'oscerd'}]"
3183,components/camel-hdfs/src/main/java/org/apache/camel/component/hdfs/HdfsInfo.java,"@@ -16,29 +16,29 @@
  */
 package org.apache.camel.component.hdfs;
 
-import java.io.IOException;
-import java.net.URI;
-
+import org.apache.camel.component.hdfs.kerberos.KerberosConfiguration;
 import org.apache.hadoop.conf.Configuration;
 import org.apache.hadoop.fs.FileSystem;
 import org.apache.hadoop.fs.Path;
 
+import java.io.IOException;","[{'comment': 'Codestyle', 'commenter': 'oscerd'}]"
3183,components/camel-hdfs/src/main/java/org/apache/camel/component/hdfs/HdfsComponent.java,"@@ -16,18 +16,16 @@
  */
 package org.apache.camel.component.hdfs;
 
-import java.net.URL;
-import java.util.Map;
-
-import javax.security.auth.login.Configuration;
-
 import org.apache.camel.Endpoint;
 import org.apache.camel.spi.annotations.Component;
 import org.apache.camel.support.DefaultComponent;
 import org.apache.hadoop.fs.FsUrlStreamHandlerFactory;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import java.net.URL;","[{'comment': 'Codestyle', 'commenter': 'oscerd'}]"
3183,components/camel-hdfs/src/main/java/org/apache/camel/component/hdfs/HdfsProducer.java,"@@ -116,8 +120,12 @@ protected void doStart() throws Exception {
                 log.debug(""Creating IdleCheck task scheduled to run every {} millis"", config.getCheckIdleInterval());
                 scheduler.scheduleAtFixedRate(new IdleCheck(idleStrategy), config.getCheckIdleInterval(), config.getCheckIdleInterval(), TimeUnit.MILLISECONDS);
             }
+        } catch (Exception e) {
+            LOG.warn(""Failed to start the HDFS producer. Caused by: [{}]"", e.getMessage());
+            LOG.trace("""", e);","[{'comment': 'Why logging at trace level?', 'commenter': 'oscerd'}]"
3183,components/camel-hdfs/src/main/java/org/apache/camel/component/hdfs/kerberos/HdfsKerberosConfigurationFactory.java,"@@ -0,0 +1,34 @@
+package org.apache.camel.component.hdfs.kerberos;","[{'comment': 'Add Apache license header please', 'commenter': 'oscerd'}]"
3183,components/camel-hdfs/src/main/java/org/apache/camel/component/hdfs/kerberos/KerberosConfiguration.java,"@@ -0,0 +1,95 @@
+package org.apache.camel.component.hdfs.kerberos;","[{'comment': 'Add Apache license header please', 'commenter': 'oscerd'}]"
3183,components/camel-hdfs/src/test/java/org/apache/camel/component/hdfs/kerberos/HdfsKerberosConfigurationFactoryTest.java,"@@ -0,0 +1,24 @@
+package org.apache.camel.component.hdfs.kerberos;
+","[{'comment': 'Add Apache license header please', 'commenter': 'oscerd'}]"
3183,components/camel-hdfs/src/test/java/org/apache/camel/component/hdfs/kerberos/KerberosConfigurationTest.java,"@@ -0,0 +1,78 @@
+package org.apache.camel.component.hdfs.kerberos;","[{'comment': 'Add Apache license header please', 'commenter': 'oscerd'}]"
3183,components/camel-hdfs/src/main/java/org/apache/camel/component/hdfs/HdfsConfiguration.java,"@@ -194,7 +189,7 @@ private String getString(Map<String, Object> hdfsSettings, String param, String
 
         splitStrategy = getString(hdfsSettings, ""splitStrategy"", kerberosNamedNodes);
 
-        if (Objects.nonNull(splitStrategy)) {
+        if (nonNull(splitStrategy)) {","[{'comment': 'Here you can use the ObjectHelper class from camel.', 'commenter': 'oscerd'}]"
3183,components/camel-hdfs/src/main/java/org/apache/camel/component/hdfs/HdfsConfiguration.java,"@@ -618,7 +585,14 @@ public void setKerberosKeytabLocation(String kerberosKeytabLocation) {
     }
 
     public boolean isKerberosAuthentication() {
-        return Objects.nonNull(kerberosNamedNodes) && Objects.nonNull(kerberosConfigFileLocation) && Objects.nonNull(kerberosUsername) && Objects.nonNull(kerberosKeytabLocation)
-                && !kerberosNamedNodes.isEmpty() && !kerberosConfigFileLocation.isEmpty() && !kerberosUsername.isEmpty() && !kerberosKeytabLocation.isEmpty();
+        return nonNullKerberosProperties() && nonEmptyKerberosProperties();
+    }
+
+    private boolean nonNullKerberosProperties() {
+        return nonNull(kerberosNamedNodes) && nonNull(kerberosConfigFileLocation) && nonNull(kerberosUsername) && nonNull(kerberosKeytabLocation);","[{'comment': 'same here', 'commenter': 'oscerd'}]"
3183,components/camel-hdfs/src/main/java/org/apache/camel/component/hdfs/HdfsConfiguration.java,"@@ -171,33 +186,35 @@ private String getString(Map<String, Object> hdfsSettings, String param, String
 
     private List<HdfsProducer.SplitStrategy> getSplitStrategies(Map<String, Object> hdfsSettings) {
         List<HdfsProducer.SplitStrategy> strategies = new ArrayList<>();
-        for (Object obj : hdfsSettings.keySet()) {
-            String key = (String) obj;
-            if (""splitStrategy"".equals(key)) {
-                String eit = (String) hdfsSettings.get(key);
-                if (eit != null) {
-                    String[] strstrategies = eit.split("","");
-                    for (String strstrategy : strstrategies) {
-                        String tokens[] = strstrategy.split("":"");
-                        if (tokens.length != 2) {
-                            throw new IllegalArgumentException(""Wrong Split Strategy "" + key + ""="" + eit);
-                        }
-                        HdfsProducer.SplitStrategyType sst = HdfsProducer.SplitStrategyType.valueOf(tokens[0]);
-                        long ssv = Long.valueOf(tokens[1]);
-                        strategies.add(new HdfsProducer.SplitStrategy(sst, ssv));
-                    }
+
+        splitStrategy = getString(hdfsSettings, ""splitStrategy"", kerberosNamedNodes);
+
+        if (isNotEmpty(splitStrategy)) {
+            String[] strstrategies = splitStrategy.split("","");","[{'comment': 'nit: do you think this makes sense?\r\n```suggestion\r\n            String[] strStrategies = splitStrategy.split("","");\r\n```', 'commenter': 'omarsmak'}, {'comment': ""Makes sense.\r\nI'll do another pull request for refactoring and other issues found by sonar."", 'commenter': 'marius-cornescu'}]"
3183,components/camel-hdfs/src/main/java/org/apache/camel/component/hdfs/HdfsConfiguration.java,"@@ -171,33 +186,35 @@ private String getString(Map<String, Object> hdfsSettings, String param, String
 
     private List<HdfsProducer.SplitStrategy> getSplitStrategies(Map<String, Object> hdfsSettings) {
         List<HdfsProducer.SplitStrategy> strategies = new ArrayList<>();
-        for (Object obj : hdfsSettings.keySet()) {
-            String key = (String) obj;
-            if (""splitStrategy"".equals(key)) {
-                String eit = (String) hdfsSettings.get(key);
-                if (eit != null) {
-                    String[] strstrategies = eit.split("","");
-                    for (String strstrategy : strstrategies) {
-                        String tokens[] = strstrategy.split("":"");
-                        if (tokens.length != 2) {
-                            throw new IllegalArgumentException(""Wrong Split Strategy "" + key + ""="" + eit);
-                        }
-                        HdfsProducer.SplitStrategyType sst = HdfsProducer.SplitStrategyType.valueOf(tokens[0]);
-                        long ssv = Long.valueOf(tokens[1]);
-                        strategies.add(new HdfsProducer.SplitStrategy(sst, ssv));
-                    }
+
+        splitStrategy = getString(hdfsSettings, ""splitStrategy"", kerberosNamedNodes);
+
+        if (isNotEmpty(splitStrategy)) {
+            String[] strstrategies = splitStrategy.split("","");
+            for (String strstrategy : strstrategies) {","[{'comment': 'same here \r\n```suggestion\r\n            for (String strStrategy : strStrategies) {\r\n```', 'commenter': 'omarsmak'}]"
3183,components/camel-hdfs/src/main/java/org/apache/camel/component/hdfs/HdfsConfiguration.java,"@@ -171,33 +186,35 @@ private String getString(Map<String, Object> hdfsSettings, String param, String
 
     private List<HdfsProducer.SplitStrategy> getSplitStrategies(Map<String, Object> hdfsSettings) {
         List<HdfsProducer.SplitStrategy> strategies = new ArrayList<>();
-        for (Object obj : hdfsSettings.keySet()) {
-            String key = (String) obj;
-            if (""splitStrategy"".equals(key)) {
-                String eit = (String) hdfsSettings.get(key);
-                if (eit != null) {
-                    String[] strstrategies = eit.split("","");
-                    for (String strstrategy : strstrategies) {
-                        String tokens[] = strstrategy.split("":"");
-                        if (tokens.length != 2) {
-                            throw new IllegalArgumentException(""Wrong Split Strategy "" + key + ""="" + eit);
-                        }
-                        HdfsProducer.SplitStrategyType sst = HdfsProducer.SplitStrategyType.valueOf(tokens[0]);
-                        long ssv = Long.valueOf(tokens[1]);
-                        strategies.add(new HdfsProducer.SplitStrategy(sst, ssv));
-                    }
+
+        splitStrategy = getString(hdfsSettings, ""splitStrategy"", kerberosNamedNodes);
+
+        if (isNotEmpty(splitStrategy)) {
+            String[] strstrategies = splitStrategy.split("","");
+            for (String strstrategy : strstrategies) {
+                String[] tokens = strstrategy.split("":"");
+                if (tokens.length != 2) {
+                    throw new IllegalArgumentException(""Wrong Split Strategy [splitStrategy"" + ""="" + splitStrategy + ""]"");
                 }
+                HdfsProducer.SplitStrategyType sst = HdfsProducer.SplitStrategyType.valueOf(tokens[0]);
+                long ssv = Long.parseLong(tokens[1]);
+                strategies.add(new HdfsProducer.SplitStrategy(sst, ssv));
             }
         }
         return strategies;
     }
 
+    private List<String> getKerberosNamedNodeList(Map<String, Object> hdfsSettings) {
+        kerberosNamedNodes = getString(hdfsSettings, ""kerberosNamedNodes"", kerberosNamedNodes);
+        return Arrays.stream(kerberosNamedNodes.split("","")).distinct().collect(Collectors.toList());","[{'comment': 'This return null in some tests.', 'commenter': 'oscerd'}, {'comment': 'Fixed it.', 'commenter': 'marius-cornescu'}]"
3184,components/camel-as2/camel-as2-api/src/main/java/org/apache/camel/component/as2/api/protocol/ResponseMDN.java,"@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the ""License""); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
+ * <p>
+ * http://www.apache.org/licenses/LICENSE-2.0","[{'comment': 'This breaks the codestyle.', 'commenter': 'oscerd'}]"
3185,components/camel-zipkin/src/main/java/org/apache/camel/zipkin/ZipkinClientRequestAdapter.java,"@@ -56,5 +56,15 @@ void onRequest(Exchange exchange, SpanCustomizer span) {
                 cache.reset();
             }
         }
+        
+        Object clientTagsObj = exchange.getProperty(""camel.custom.tags"");","[{'comment': 'Cant we use `camel.client.customtags` eg with `camel.client` as prefix.\r\n\r\nAnd then you can use `exchange.getProperty(""xxx"", Map.class);', 'commenter': 'davsclaus'}, {'comment': 'Have updated property name to camel.client.customtags and used getProperty() method with class type.', 'commenter': 'pranshuparmar'}]"
3185,components/camel-zipkin/src/main/java/org/apache/camel/zipkin/ZipkinClientRequestAdapter.java,"@@ -56,5 +56,15 @@ void onRequest(Exchange exchange, SpanCustomizer span) {
                 cache.reset();
             }
         }
+        
+        Object clientTagsObj = exchange.getProperty(""camel.custom.tags"");
+        if (clientTagsObj != null) {
+        	Map<String, String> clientTags = (Map)clientTagsObj;
+	        if (clientTags != null && !clientTags.isEmpty()) {
+	        	for (Map.Entry<String, String> tag: clientTags.entrySet()) {
+	        		span.tag(""custom."" + tag.getKey(), tag.getValue());","[{'comment': 'Fix checkstyle, eg run `mvn compile -P sourcecheck` and fix the errors it report', 'commenter': 'davsclaus'}, {'comment': 'Fixed checkstyle issues and added unit test.', 'commenter': 'pranshuparmar'}]"
3188,components/camel-as2/camel-as2-api/src/main/java/org/apache/camel/component/as2/api/AS2ClientConnection.java,"@@ -40,21 +50,46 @@
 import org.apache.http.protocol.RequestUserAgent;
 import org.apache.http.util.Args;
 
+import java.io.IOException;","[{'comment': 'Please run the build with sourcecheck profile enabled and check the warnings. The imports order is wrong.', 'commenter': 'oscerd'}, {'comment': ""Hi @oscerd, \r\n\r\nWhere can I find the sourcecheck profile? I'm using Intellij"", 'commenter': 'Braus'}, {'comment': ""Hello,\r\n\r\nYou just need to run the module build with -Psourcecheck. You'll see some warnings at the beginning."", 'commenter': 'oscerd'}]"
3188,components/camel-as2/camel-as2-api/src/main/java/org/apache/camel/component/as2/api/AS2ClientConnection.java,"@@ -89,15 +133,69 @@ public String getClientFqdn() {
 
     public HttpResponse send(HttpRequest request, HttpCoreContext httpContext) throws HttpException, IOException {
 
+        // Connection pooling
+        ConnectionRequest connectionRequest = connectionManager.requestConnection(httpRoute, null);
+        HttpClientConnection httpClientConnection = null;
+        try {
+            httpClientConnection = connectionRequest.get(10, TimeUnit.SECONDS);
+        } catch (InterruptedException e) {","[{'comment': 'This can be a single catch', 'commenter': 'oscerd'}]"
3188,components/camel-as2/camel-as2-api/src/main/java/org/apache/camel/component/as2/api/entity/EntityParser.java,"@@ -203,10 +205,15 @@ public static MimeEntity parseEntity(byte[] content) throws HttpException {
             ContentType entityContentType = null;
             String entityContentTransferEncoding = null;
             for (Header header : headers) {
-                if (header.getName().equalsIgnoreCase(AS2Header.CONTENT_TYPE)) {
+                switch (header.getName()) {","[{'comment': 'Sourcecheck profile enabled here too', 'commenter': 'oscerd'}]"
3192,components/camel-as2/camel-as2-api/src/main/java/org/apache/camel/component/as2/api/AS2ClientConnection.java,"@@ -19,42 +19,59 @@
 import java.io.IOException;
 import java.net.Socket;
 import java.net.UnknownHostException;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.TimeUnit;
 
 import org.apache.camel.component.as2.api.io.AS2BHttpClientConnection;
 import org.apache.camel.component.as2.api.protocol.RequestAS2;
 import org.apache.camel.component.as2.api.protocol.RequestMDN;
-import org.apache.http.HttpException;
-import org.apache.http.HttpHost;
-import org.apache.http.HttpRequest;
-import org.apache.http.HttpResponse;
+import org.apache.camel.component.as2.api.util.AS2HttpConnectionFactory;
+import org.apache.http.*;
+import org.apache.http.config.ConnectionConfig;
+import org.apache.http.config.SocketConfig;
+import org.apache.http.conn.*;
+import org.apache.http.conn.HttpConnectionFactory;
+import org.apache.http.conn.routing.HttpRoute;
 import org.apache.http.impl.DefaultBHttpClientConnection;
-import org.apache.http.protocol.HttpCoreContext;
-import org.apache.http.protocol.HttpProcessor;
-import org.apache.http.protocol.HttpProcessorBuilder;
-import org.apache.http.protocol.HttpRequestExecutor;
-import org.apache.http.protocol.RequestConnControl;
-import org.apache.http.protocol.RequestContent;
-import org.apache.http.protocol.RequestDate;
-import org.apache.http.protocol.RequestExpectContinue;
-import org.apache.http.protocol.RequestTargetHost;
-import org.apache.http.protocol.RequestUserAgent;
+import org.apache.http.impl.conn.PoolingHttpClientConnectionManager;
+import org.apache.http.message.BasicHeaderElementIterator;
+import org.apache.http.protocol.*;
 import org.apache.http.util.Args;
 
 public class AS2ClientConnection {
 
     private HttpHost targetHost;
+    private HttpRoute httpRoute;
     private HttpProcessor httpProcessor;
-    private DefaultBHttpClientConnection httpConnection;
     private String as2Version;
     private String userAgent;
     private String clientFqdn;
+    private PoolingHttpClientConnectionManager connectionManager;
+    private ConnectionKeepAliveStrategy connectionKeepAliveStrategy;
+    private IdleConnectionMonitorThread idleConnectionMonitorThread;
 
     public AS2ClientConnection(String as2Version, String userAgent, String clientFqdn, String targetHostName, Integer targetPortNumber) throws UnknownHostException, IOException {
 
         this.as2Version = Args.notNull(as2Version, ""as2Version"");
         this.userAgent = Args.notNull(userAgent, ""userAgent"");
         this.clientFqdn = Args.notNull(clientFqdn, ""clientFqdn"");
         this.targetHost = new HttpHost(Args.notNull(targetHostName, ""targetHostName""), Args.notNull(targetPortNumber, ""targetPortNumber""));
+        this.connectionManager = new PoolingHttpClientConnectionManager(AS2HttpConnectionFactory.INSTANCE);
+        this.connectionManager.setMaxTotal(3);
+        this.connectionManager.setSocketConfig(targetHost, SocketConfig.custom().setSoTimeout(5000).build());","[{'comment': 'It would be nice to add possibility to change parameters like soTimeout, maxTotal and so on, as these can be depends on the environment configuration. ', 'commenter': 'dmvolod'}]"
3192,components/camel-as2/camel-as2-api/src/main/java/org/apache/camel/component/as2/api/AS2ClientConnection.java,"@@ -89,15 +110,61 @@ public String getClientFqdn() {
 
     public HttpResponse send(HttpRequest request, HttpCoreContext httpContext) throws HttpException, IOException {
 
+        // Connection pooling
+        ConnectionRequest connectionRequest = connectionManager.requestConnection(httpRoute, null);
+        HttpClientConnection httpClientConnection = null;
+        try {
+            httpClientConnection = connectionRequest.get(10, TimeUnit.SECONDS);","[{'comment': 'Also wold be nice to be configuring.', 'commenter': 'dmvolod'}]"
3192,components/camel-as2/camel-as2-api/src/main/java/org/apache/camel/component/as2/api/AS2ClientConnection.java,"@@ -89,15 +110,61 @@ public String getClientFqdn() {
 
     public HttpResponse send(HttpRequest request, HttpCoreContext httpContext) throws HttpException, IOException {
 
+        // Connection pooling
+        ConnectionRequest connectionRequest = connectionManager.requestConnection(httpRoute, null);
+        HttpClientConnection httpClientConnection = null;
+        try {
+            httpClientConnection = connectionRequest.get(10, TimeUnit.SECONDS);
+        }  catch (InterruptedException | ExecutionException e) {
+            throw new HttpException(e.getMessage(), e.getCause());
+        }
+
+        connectionManager.connect(httpClientConnection, httpRoute, 5000, httpContext);
+        connectionManager.routeComplete(httpClientConnection, httpRoute, httpContext);
+
         httpContext.setTargetHost(targetHost);
 
         // Execute Request
         HttpRequestExecutor httpexecutor = new HttpRequestExecutor();
         httpexecutor.preProcess(request, httpProcessor, httpContext);
-        HttpResponse response = httpexecutor.execute(request, httpConnection, httpContext);
+        HttpResponse response = httpexecutor.execute(request, httpClientConnection, httpContext);
         httpexecutor.postProcess(response, httpProcessor, httpContext);
 
+        connectionManager.releaseConnection(httpClientConnection, null, 1, TimeUnit.SECONDS);
+
         return response;
     }
 
+    private class IdleConnectionMonitorThread extends Thread {
+
+        private final HttpClientConnectionManager connectionManager;
+        private volatile boolean shutdown;
+
+        public IdleConnectionMonitorThread(PoolingHttpClientConnectionManager connectionManager) {
+            super();
+            this.connectionManager = connectionManager;
+        }
+
+        @Override
+        public void run() {
+            try {
+                while (!shutdown) {
+                    synchronized (this) {
+                        wait(2500);
+                        connectionManager.closeExpiredConnections();
+                        connectionManager.closeIdleConnections(30, TimeUnit.SECONDS);","[{'comment': 'Also wold be nice to be configuring.', 'commenter': 'dmvolod'}]"
3192,components/camel-as2/camel-as2-api/src/main/java/org/apache/camel/component/as2/api/AS2ClientConnection.java,"@@ -19,42 +19,59 @@
 import java.io.IOException;
 import java.net.Socket;
 import java.net.UnknownHostException;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.TimeUnit;
 
 import org.apache.camel.component.as2.api.io.AS2BHttpClientConnection;
 import org.apache.camel.component.as2.api.protocol.RequestAS2;
 import org.apache.camel.component.as2.api.protocol.RequestMDN;
-import org.apache.http.HttpException;
-import org.apache.http.HttpHost;
-import org.apache.http.HttpRequest;
-import org.apache.http.HttpResponse;
+import org.apache.camel.component.as2.api.util.AS2HttpConnectionFactory;
+import org.apache.http.*;
+import org.apache.http.config.ConnectionConfig;
+import org.apache.http.config.SocketConfig;
+import org.apache.http.conn.*;
+import org.apache.http.conn.HttpConnectionFactory;
+import org.apache.http.conn.routing.HttpRoute;
 import org.apache.http.impl.DefaultBHttpClientConnection;
-import org.apache.http.protocol.HttpCoreContext;
-import org.apache.http.protocol.HttpProcessor;
-import org.apache.http.protocol.HttpProcessorBuilder;
-import org.apache.http.protocol.HttpRequestExecutor;
-import org.apache.http.protocol.RequestConnControl;
-import org.apache.http.protocol.RequestContent;
-import org.apache.http.protocol.RequestDate;
-import org.apache.http.protocol.RequestExpectContinue;
-import org.apache.http.protocol.RequestTargetHost;
-import org.apache.http.protocol.RequestUserAgent;
+import org.apache.http.impl.conn.PoolingHttpClientConnectionManager;
+import org.apache.http.message.BasicHeaderElementIterator;
+import org.apache.http.protocol.*;
 import org.apache.http.util.Args;
 
 public class AS2ClientConnection {
 
     private HttpHost targetHost;
+    private HttpRoute httpRoute;
     private HttpProcessor httpProcessor;
-    private DefaultBHttpClientConnection httpConnection;
     private String as2Version;
     private String userAgent;
     private String clientFqdn;
+    private PoolingHttpClientConnectionManager connectionManager;
+    private ConnectionKeepAliveStrategy connectionKeepAliveStrategy;
+    private IdleConnectionMonitorThread idleConnectionMonitorThread;
 
     public AS2ClientConnection(String as2Version, String userAgent, String clientFqdn, String targetHostName, Integer targetPortNumber) throws UnknownHostException, IOException {
 
         this.as2Version = Args.notNull(as2Version, ""as2Version"");
         this.userAgent = Args.notNull(userAgent, ""userAgent"");
         this.clientFqdn = Args.notNull(clientFqdn, ""clientFqdn"");
         this.targetHost = new HttpHost(Args.notNull(targetHostName, ""targetHostName""), Args.notNull(targetPortNumber, ""targetPortNumber""));
+        this.connectionManager = new PoolingHttpClientConnectionManager(AS2HttpConnectionFactory.INSTANCE);
+        this.connectionManager.setMaxTotal(3);
+        this.connectionManager.setSocketConfig(targetHost, SocketConfig.custom().setSoTimeout(5000).build());
+        this.connectionKeepAliveStrategy = (response, context) -> {
+            HeaderElementIterator iterator = new BasicHeaderElementIterator(response.headerIterator(HTTP.CONN_KEEP_ALIVE));
+            while (iterator.hasNext()) {
+                HeaderElement headerElement = iterator.nextElement();
+                String name = headerElement.getName();
+                String value = headerElement.getValue();
+                if (value != null && name.equalsIgnoreCase(""timeout"")) {
+                    return Long.parseLong(value) * 1000;
+                }
+            }
+            return 30000;","[{'comment': 'I think it will be more readable to move these numbers into constants in order to give more clarity on the context, same as the `1000`, what do you think?', 'commenter': 'omarsmak'}]"
3192,components/camel-as2/camel-as2-api/src/main/java/org/apache/camel/component/as2/api/AS2ClientConnection.java,"@@ -67,12 +84,16 @@ public AS2ClientConnection(String as2Version, String userAgent, String clientFqd
                 .add(new RequestConnControl())
                 .add(new RequestExpectContinue(true)).build();
 
-        // Create Socket
-        Socket socket = new Socket(targetHost.getHostName(), targetHost.getPort());
+        this.httpRoute = new HttpRoute(new HttpHost(targetHost.getHostName(), targetHost.getPort()));
 
-        // Create Connection
-        httpConnection = new AS2BHttpClientConnection(8 * 1024);
-        httpConnection.bind(socket);
+        org.apache.http.conn.HttpConnectionFactory<HttpRoute, ManagedHttpClientConnection> httpConnectionFactory = new HttpConnectionFactory<HttpRoute, ManagedHttpClientConnection>() {","[{'comment': 'I am bit confused here, is `httpConnectionFactory` supposed to be initialized but never used somewhere else? ', 'commenter': 'omarsmak'}]"
3192,components/camel-as2/camel-as2-api/src/main/java/org/apache/camel/component/as2/api/AS2ClientConnection.java,"@@ -89,15 +110,61 @@ public String getClientFqdn() {
 
     public HttpResponse send(HttpRequest request, HttpCoreContext httpContext) throws HttpException, IOException {
 
+        // Connection pooling
+        ConnectionRequest connectionRequest = connectionManager.requestConnection(httpRoute, null);
+        HttpClientConnection httpClientConnection = null;
+        try {
+            httpClientConnection = connectionRequest.get(10, TimeUnit.SECONDS);
+        }  catch (InterruptedException | ExecutionException e) {
+            throw new HttpException(e.getMessage(), e.getCause());
+        }
+
+        connectionManager.connect(httpClientConnection, httpRoute, 5000, httpContext);
+        connectionManager.routeComplete(httpClientConnection, httpRoute, httpContext);
+
         httpContext.setTargetHost(targetHost);
 
         // Execute Request
         HttpRequestExecutor httpexecutor = new HttpRequestExecutor();
         httpexecutor.preProcess(request, httpProcessor, httpContext);
-        HttpResponse response = httpexecutor.execute(request, httpConnection, httpContext);
+        HttpResponse response = httpexecutor.execute(request, httpClientConnection, httpContext);
         httpexecutor.postProcess(response, httpProcessor, httpContext);
 
+        connectionManager.releaseConnection(httpClientConnection, null, 1, TimeUnit.SECONDS);
+
         return response;
     }
 
+    private class IdleConnectionMonitorThread extends Thread {
+
+        private final HttpClientConnectionManager connectionManager;
+        private volatile boolean shutdown;
+
+        public IdleConnectionMonitorThread(PoolingHttpClientConnectionManager connectionManager) {
+            super();
+            this.connectionManager = connectionManager;
+        }
+
+        @Override
+        public void run() {
+            try {
+                while (!shutdown) {
+                    synchronized (this) {
+                        wait(2500);","[{'comment': 'Maybe we can move this into constant as well? ', 'commenter': 'omarsmak'}]"
3192,components/camel-as2/camel-as2-api/src/main/java/org/apache/camel/component/as2/api/AS2ClientConnection.java,"@@ -89,15 +110,61 @@ public String getClientFqdn() {
 
     public HttpResponse send(HttpRequest request, HttpCoreContext httpContext) throws HttpException, IOException {
 
+        // Connection pooling
+        ConnectionRequest connectionRequest = connectionManager.requestConnection(httpRoute, null);
+        HttpClientConnection httpClientConnection = null;
+        try {
+            httpClientConnection = connectionRequest.get(10, TimeUnit.SECONDS);
+        }  catch (InterruptedException | ExecutionException e) {
+            throw new HttpException(e.getMessage(), e.getCause());
+        }
+
+        connectionManager.connect(httpClientConnection, httpRoute, 5000, httpContext);","[{'comment': 'is the number here configurable? the same way as @dmvolod mentioned in earlier configurations', 'commenter': 'omarsmak'}]"
3201,components/camel-aws-sqs/src/main/java/org/apache/camel/component/aws/sqs/SqsEndpoint.java,"@@ -333,9 +352,13 @@ AmazonSQS createClient() {
                 clientBuilder = AmazonSQSClientBuilder.standard().withClientConfiguration(clientConfiguration);
             }
         }
-        if (ObjectHelper.isNotEmpty(configuration.getRegion())) {
-            clientBuilder = clientBuilder.withRegion(Regions.valueOf(configuration.getRegion()));
-        }
+
+        String host = configuration.getAmazonAWSHost();
+        String region = configuration.getRegion();
+
+        log.debug(""Creating endpoint for host {} on region {}"", host, region);
+        clientBuilder.withEndpointConfiguration(new AwsClientBuilder.EndpointConfiguration(host, region));","[{'comment': 'For the region you may need to use the Regions.valueOf(configuration.getRegion()) because all the components use the enum version so you would have EU_WEST_1, while the endpointConfiguration is expecting the signing region eu-west-1.\r\nI think it should be ok, otherwise. Did you test this with a real AWS SQS queue? Thanks.', 'commenter': 'oscerd'}, {'comment': ""Thanks for the review!\r\n\r\nI have adjusted the points you raised, but I haven't tested on a real SQS queue. Let me do that and get back to you as soon as I verify that."", 'commenter': 'orpiske'}, {'comment': '@oscerd I did find an issue with signing after running some AWS tests, but I updated the PR to resolve the problems I found. The PR now works for both the ""normal AWS"" use case as well as with the custom AWS Host I proposed to support. ', 'commenter': 'orpiske'}]"
3219,components/camel-netty-http/src/main/java/org/apache/camel/component/netty/http/handlers/HttpClientChannelHandler.java,"@@ -75,6 +77,29 @@ protected Message getResponseMessage(Exchange exchange, ChannelHandlerContext ct
             producer.getEndpoint().getCookieHandler().storeCookies(exchange, uri, m);
         }
 
+        //handleNoContent(exchange, answer, response);
         return answer;
     }
+    
+//    protected void handleNoContent(Exchange exchange, Message answer, HttpResponse response) {","[{'comment': ""I'll clean this up... just wanted to make sure had the right approach overall first"", 'commenter': 'CodeSmell'}]"
3219,components/camel-netty-http/src/main/java/org/apache/camel/component/netty/http/handlers/HttpServerChannelHandler.java,"@@ -316,11 +318,44 @@ public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws E
 
     @Override
     protected Object getResponseBody(Exchange exchange) throws Exception {
+        HttpResponse response;
+        Message answer;
         // use the binding
         if (exchange.hasOut()) {
-            return consumer.getEndpoint().getNettyHttpBinding().toNettyResponse(exchange.getOut(), consumer.getConfiguration());
+            response = consumer.getEndpoint().getNettyHttpBinding().toNettyResponse(exchange.getOut(), consumer.getConfiguration());
+            answer = exchange.getOut();
         } else {
-            return consumer.getEndpoint().getNettyHttpBinding().toNettyResponse(exchange.getIn(), consumer.getConfiguration());
+            response = consumer.getEndpoint().getNettyHttpBinding().toNettyResponse(exchange.getIn(), consumer.getConfiguration());
+            answer = exchange.getIn();
         }
+        
+        // TODO is this where we should tackle handling the 204 change?
+        handleNoContent(exchange, answer, response);
+        
+        return response;
+    }
+    
+    protected void handleNoContent(Exchange exchange, Message answer, HttpResponse response) {
+        HttpResponseStatus responseStatus = response.status();
+        if (responseStatus.code() == 200 && hasNoContentBody(exchange, answer)) {
+            answer.getHeaders().put(Exchange.HTTP_RESPONSE_CODE, 204);
+            answer.getHeaders().put(Exchange.HTTP_RESPONSE_TEXT, ""No Content"");
+            answer.setBody("""");
+            
+            response.setStatus(new HttpResponseStatus(204, ""No Content""));
+        }
+    }
+    
+    protected boolean hasNoContentBody(Exchange exchange, Message answer) {","[{'comment': 'The same as I mentioned in the other PR #3239', 'commenter': 'omarsmak'}]"
3219,components/camel-netty-http/src/main/java/org/apache/camel/component/netty/http/handlers/HttpServerChannelHandler.java,"@@ -316,11 +318,44 @@ public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws E
 
     @Override
     protected Object getResponseBody(Exchange exchange) throws Exception {
+        HttpResponse response;
+        Message answer;
         // use the binding
         if (exchange.hasOut()) {
-            return consumer.getEndpoint().getNettyHttpBinding().toNettyResponse(exchange.getOut(), consumer.getConfiguration());
+            response = consumer.getEndpoint().getNettyHttpBinding().toNettyResponse(exchange.getOut(), consumer.getConfiguration());
+            answer = exchange.getOut();
         } else {
-            return consumer.getEndpoint().getNettyHttpBinding().toNettyResponse(exchange.getIn(), consumer.getConfiguration());
+            response = consumer.getEndpoint().getNettyHttpBinding().toNettyResponse(exchange.getIn(), consumer.getConfiguration());
+            answer = exchange.getIn();
         }
+        
+        // TODO is this where we should tackle handling the 204 change?
+        handleNoContent(exchange, answer, response);","[{'comment': ""Do you think if better handle the status code here: https://github.com/apache/camel/blob/master/components/camel-netty-http/src/main/java/org/apache/camel/component/netty/http/DefaultNettyHttpBinding.java#L394, because that is the method sole responsibility to produce the correct HTTP response and thus you won't need any further logic elsewhere"", 'commenter': 'omarsmak'}, {'comment': 'working on that change now... ', 'commenter': 'CodeSmell'}, {'comment': 'should be good to go', 'commenter': 'CodeSmell'}]"
3232,components/camel-graphql/pom.xml,"@@ -0,0 +1,67 @@
+<?xml version=""1.0"" encoding=""UTF-8"" ?>
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one or more
+    contributor license agreements.  See the NOTICE file distributed with
+    this work for additional information regarding copyright ownership.
+    The ASF licenses this file to You under the Apache License, Version 2.0
+    (the ""License""); you may not use this file except in compliance with
+    the License.  You may obtain a copy of the License at
+
+         http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an ""AS IS"" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+
+-->
+<project xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xmlns=""http://maven.apache.org/POM/4.0.0"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+    <modelVersion>4.0.0</modelVersion>
+
+    <parent>
+        <groupId>org.apache.camel</groupId>
+        <artifactId>components</artifactId>
+        <version>3.0.0-SNAPSHOT</version>
+    </parent>
+
+    <artifactId>camel-graphql</artifactId>
+    <packaging>jar</packaging>
+
+    <name>Camel :: AWS GraphQL</name>","[{'comment': ""Maybe it's not AWS? :-)"", 'commenter': 'oscerd'}, {'comment': 'Classic copy & paste mistake', 'commenter': 'abkieling'}]"
3232,components/camel-graphql/pom.xml,"@@ -0,0 +1,67 @@
+<?xml version=""1.0"" encoding=""UTF-8"" ?>
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one or more
+    contributor license agreements.  See the NOTICE file distributed with
+    this work for additional information regarding copyright ownership.
+    The ASF licenses this file to You under the Apache License, Version 2.0
+    (the ""License""); you may not use this file except in compliance with
+    the License.  You may obtain a copy of the License at
+
+         http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an ""AS IS"" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+
+-->
+<project xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xmlns=""http://maven.apache.org/POM/4.0.0"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+    <modelVersion>4.0.0</modelVersion>
+
+    <parent>
+        <groupId>org.apache.camel</groupId>
+        <artifactId>components</artifactId>
+        <version>3.0.0-SNAPSHOT</version>
+    </parent>
+
+    <artifactId>camel-graphql</artifactId>
+    <packaging>jar</packaging>
+
+    <name>Camel :: AWS GraphQL</name>
+    <description>A Camel GraphQL Component</description>
+
+    <properties>
+        <graphql-java-version>13.0</graphql-java-version>","[{'comment': 'This one can go in parent/pom', 'commenter': 'oscerd'}, {'comment': ""Only the property, right? You've selected the description as well."", 'commenter': 'abkieling'}]"
3232,components/camel-graphql/src/main/java/org/apache/camel/component/graphql/Resources.java,"@@ -0,0 +1,33 @@
+package org.apache.camel.component.graphql;
+
+import java.io.IOException;
+import java.net.URISyntaxException;
+import java.net.URL;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.Paths;
+
+import org.apache.camel.RuntimeCamelException;
+
+public class Resources {","[{'comment': 'I think we already a class in camel-support for reading file and stuff like that.', 'commenter': 'oscerd'}, {'comment': 'OK, found a way to do it.', 'commenter': 'abkieling'}]"
3232,components/camel-graphql/src/main/java/org/apache/camel/component/graphql/GraphqlComponent.java,"@@ -0,0 +1,18 @@
+package org.apache.camel.component.graphql;
+
+import java.util.Map;
+
+import org.apache.camel.Endpoint;
+import org.apache.camel.spi.annotations.Component;
+import org.apache.camel.support.DefaultComponent;
+
+@Component(""graphql"")
+public class GraphqlComponent extends DefaultComponent {
+
+    @Override","[{'comment': 'Are you planning let the component configurable in the component level? Then will be nice to add the GraphqlConfiguration as private field in the class ', 'commenter': 'omarsmak'}, {'comment': ""Sorry. I didn't understand your comment. Can you give me an example?"", 'commenter': 'abkieling'}, {'comment': ""I've decided to remove GraphqlConfiguration and define the parameters in GraphqlEndpoint for now."", 'commenter': 'abkieling'}, {'comment': 'Please review the code again.', 'commenter': 'abkieling'}]"
3232,components/camel-graphql/src/main/java/org/apache/camel/component/graphql/GraphqlEndpoint.java,"@@ -0,0 +1,40 @@
+package org.apache.camel.component.graphql;
+
+import org.apache.camel.Component;
+import org.apache.camel.Consumer;
+import org.apache.camel.Processor;
+import org.apache.camel.Producer;
+import org.apache.camel.support.DefaultEndpoint;
+import org.apache.http.impl.client.CloseableHttpClient;
+import org.apache.http.impl.client.HttpClients;
+","[{'comment': 'Here we are missing `@UriEndpoint` annotation with the schema information, you can see other compenents for some examples', 'commenter': 'omarsmak'}, {'comment': 'Added the annotation', 'commenter': 'abkieling'}, {'comment': 'Done', 'commenter': 'abkieling'}]"
3232,components/camel-graphql/src/main/java/org/apache/camel/component/graphql/GraphqlEndpoint.java,"@@ -0,0 +1,40 @@
+package org.apache.camel.component.graphql;
+
+import org.apache.camel.Component;
+import org.apache.camel.Consumer;
+import org.apache.camel.Processor;
+import org.apache.camel.Producer;
+import org.apache.camel.support.DefaultEndpoint;
+import org.apache.http.impl.client.CloseableHttpClient;
+import org.apache.http.impl.client.HttpClients;
+
+public class GraphqlEndpoint extends DefaultEndpoint {
+
+    private final GraphqlConfiguration configuration;","[{'comment': ""Here we can add `@UriParam` in order tell Camel's maven plugin that is our configuration that we wish to generate the endpoint property configurer, generate endpoints docs .etc   "", 'commenter': 'omarsmak'}, {'comment': 'Done', 'commenter': 'abkieling'}]"
3232,components/camel-graphql/src/main/java/org/apache/camel/component/graphql/GraphqlConfiguration.java,"@@ -0,0 +1,82 @@
+package org.apache.camel.component.graphql;
+
+import java.net.URI;
+import java.net.URISyntaxException;
+import java.util.Map;
+
+import org.apache.camel.RuntimeCamelException;
+import org.apache.camel.util.PropertiesHelper;
+import org.apache.camel.util.json.JsonObject;
+
+public class GraphqlConfiguration {","[{'comment': 'As well here, we add `UriParams` annotation ', 'commenter': 'omarsmak'}]"
3232,components/camel-graphql/src/main/java/org/apache/camel/component/graphql/GraphqlComponent.java,"@@ -0,0 +1,18 @@
+package org.apache.camel.component.graphql;
+
+import java.util.Map;
+
+import org.apache.camel.Endpoint;
+import org.apache.camel.spi.annotations.Component;
+import org.apache.camel.support.DefaultComponent;
+
+@Component(""graphql"")
+public class GraphqlComponent extends DefaultComponent {
+
+    @Override
+    protected Endpoint createEndpoint(String uri, String remaining, Map<String, Object> parameters) throws Exception {
+        GraphqlConfiguration configuration = new GraphqlConfiguration(remaining, parameters);","[{'comment': 'I think would be better to follow other components on how to set configurations, meaning that to configuration properties mutable and let Camel do the job of binding the parameters via `setProperties(configuration, parameters);`.  ', 'commenter': 'omarsmak'}, {'comment': 'Done', 'commenter': 'abkieling'}]"
3232,components/camel-graphql/src/main/java/org/apache/camel/component/graphql/GraphqlConfiguration.java,"@@ -0,0 +1,82 @@
+package org.apache.camel.component.graphql;
+
+import java.net.URI;
+import java.net.URISyntaxException;
+import java.util.Map;
+
+import org.apache.camel.RuntimeCamelException;
+import org.apache.camel.util.PropertiesHelper;
+import org.apache.camel.util.json.JsonObject;
+
+public class GraphqlConfiguration {
+
+    private static final String QUERY_PARAM = ""query"";
+    private static final String QUERY_FILE_PARAM = ""queryFile"";
+    private static final String OPERATION_NAME_PARAM = ""operationName"";
+    private static final String VARIABLE_PREFIX = ""variable."";
+    private final URI httpUri;
+    private final String query;
+    private final String operationName;
+    private final String variables;
+
+    public GraphqlConfiguration(String remaining, Map<String, Object> parameters) {
+        this.httpUri = extractHttpUri(remaining);
+        this.query = extractQuery(parameters);
+        this.operationName = extractOperationName(parameters);
+        this.variables = extractVariables(parameters);
+    }
+
+    public URI getHttpUri() {
+        return httpUri;
+    }
+
+    public String getQuery() {
+        return query;
+    }
+
+    public String getOperationName() {
+        return operationName;
+    }
+
+    public String getVariables() {
+        return variables;
+    }
+
+    public String getRequestBody() {
+        JsonObject jsonObject = new JsonObject();
+        jsonObject.put(""query"", query);
+        jsonObject.put(""operationName"", operationName);
+        jsonObject.put(""variables"", variables);
+        return jsonObject.toJson();
+    }
+
+    private URI extractHttpUri(String remaining) {
+        try {
+            return new URI(remaining);
+        } catch (URISyntaxException e) {
+            throw new RuntimeCamelException(""Invalid HTTP URI: "" + remaining, e);
+        }
+    }
+
+    private String extractQuery(Map<String, Object> parameters) {","[{'comment': ""If you let Camel do this, I don't think you will need it"", 'commenter': 'omarsmak'}, {'comment': 'Done', 'commenter': 'abkieling'}]"
3232,components/camel-graphql/src/main/java/org/apache/camel/component/graphql/GraphqlEndpoint.java,"@@ -0,0 +1,119 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.graphql;
+
+import java.io.IOException;
+import java.net.URI;
+import java.util.Map;
+
+import org.apache.camel.Component;
+import org.apache.camel.Consumer;
+import org.apache.camel.Processor;
+import org.apache.camel.Producer;
+import org.apache.camel.RuntimeCamelException;
+import org.apache.camel.spi.Metadata;
+import org.apache.camel.spi.UriEndpoint;
+import org.apache.camel.spi.UriParam;
+import org.apache.camel.spi.UriPath;
+import org.apache.camel.support.DefaultEndpoint;
+import org.apache.camel.util.IOHelper;
+import org.apache.camel.util.ObjectHelper;
+import org.apache.http.impl.client.CloseableHttpClient;
+import org.apache.http.impl.client.HttpClients;
+
+@UriEndpoint(firstVersion = ""3.0.0"", scheme = ""graphql"", title = ""GraphQL"", syntax = ""graphql:httpUri"", label = ""graphql"")
+public class GraphqlEndpoint extends DefaultEndpoint {
+
+    private final CloseableHttpClient httpclient;
+    @UriPath
+    @Metadata(required = true)
+    private URI httpUri;
+    @UriParam
+    private String query;
+    @UriParam
+    private String queryFile;
+    @UriParam
+    private String operationName;
+    @UriParam(prefix = ""variable."", multiValue = true)
+    private Map<String, Object> variables;","[{'comment': ""@oscerd Camel is failing to map the variable.* URI options to this class field. What's wrong?"", 'commenter': 'abkieling'}, {'comment': ""I get the following error:\r\n```\r\nCaused by: org.apache.camel.ResolveEndpointFailedException: Failed to resolve endpoint: graphql://http://localhost:43663/graphql?operationName=BookById&queryFile=multipleQueries.graphql&variable.id=book-1 due to: There are 1 parameters that couldn't be set on the endpoint. Check the uri if the parameters are spelt correctly and that they are properties of the endpoint. Unknown parameters=[{variable.id=book-1}]\r\n```"", 'commenter': 'abkieling'}, {'comment': ""@alexkieling AFAIK the way the binding works in camel is by generating a property configurter java classes to set these properties and avoid reflections. However of course, it needs to cast the input into the suitable type using [type converters](https://camel.apache.org/manual/latest/type-converter.html), meaning when it tries to set variables, first Camel will try to convert it from Object to Map. However in this case, I don't think Camel will be able to convert it out of box for you since there is a type converter from object to Map that shipped in (as I know but not 100%). In order to solve this, either you handle setting this by yourself (see here for an [example](https://github.com/apache/camel/blob/master/components/camel-http/src/main/java/org/apache/camel/component/http/HttpComponent.java#L321) on how camel-http handles that). Or you can add a type converter to convert from `Object` to `Map` and let Camel does it for you (an [example](https://github.com/apache/camel/blob/master/components/camel-debezium/src/main/java/org/apache/camel/component/debezium/DebeziumTypeConverter.java))"", 'commenter': 'omarsmak'}, {'comment': '@omarsmak Thanks for your answer. An alternative way would be defining my `variables` field as String and accepting a comma-separated list of colon-separated key/value pairs, like `variables=var1:foo,var2:bar`. That strategy is used in the Kafka component. What do you think?\r\nhttps://github.com/apache/camel/blob/35184b640382923fc52b56d38dda6f329ec23f9a/components/camel-kafka/src/test/java/org/apache/camel/component/kafka/KafkaComponentTest.java#L42', 'commenter': 'abkieling'}, {'comment': 'Sure whatever you think is more convenient for the user and easy for you to work with, just bear in mind that you will still need to parse that by yourself in case you want to create the `Map` out of it. ', 'commenter': 'omarsmak'}]"
3232,components/camel-graphql/src/main/java/org/apache/camel/component/graphql/GraphqlEndpoint.java,"@@ -0,0 +1,119 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.graphql;
+
+import java.io.IOException;
+import java.net.URI;
+import java.util.Map;
+
+import org.apache.camel.Component;
+import org.apache.camel.Consumer;
+import org.apache.camel.Processor;
+import org.apache.camel.Producer;
+import org.apache.camel.RuntimeCamelException;
+import org.apache.camel.spi.Metadata;
+import org.apache.camel.spi.UriEndpoint;
+import org.apache.camel.spi.UriParam;
+import org.apache.camel.spi.UriPath;
+import org.apache.camel.support.DefaultEndpoint;
+import org.apache.camel.util.IOHelper;
+import org.apache.camel.util.ObjectHelper;
+import org.apache.http.impl.client.CloseableHttpClient;
+import org.apache.http.impl.client.HttpClients;
+
+@UriEndpoint(firstVersion = ""3.0.0"", scheme = ""graphql"", title = ""GraphQL"", syntax = ""graphql:httpUri"", label = ""graphql"")
+public class GraphqlEndpoint extends DefaultEndpoint {
+
+    private final CloseableHttpClient httpclient;
+    @UriPath
+    @Metadata(required = true)
+    private URI httpUri;
+    @UriParam
+    private String query;
+    @UriParam
+    private String queryFile;
+    @UriParam
+    private String operationName;
+    @UriParam(prefix = ""variable."", multiValue = true)
+    private Map<String, Object> variables;
+
+    public GraphqlEndpoint(String uri, Component component) {
+        super(uri, component);
+        this.httpclient = HttpClients.createDefault();
+    }
+
+    @Override
+    public Producer createProducer() throws Exception {
+        return new GraphqlProducer(this);
+    }
+
+    @Override
+    public Consumer createConsumer(Processor processor) throws Exception {
+        throw new UnsupportedOperationException(""You cannot receive messages at this endpoint: "" + getEndpointUri());
+    }
+
+    public CloseableHttpClient getHttpclient() {
+        return httpclient;
+    }
+
+    public URI getHttpUri() {
+        return httpUri;
+    }
+
+    public void setHttpUri(URI httpUri) {
+        this.httpUri = httpUri;
+    }
+
+    public String getQuery() {
+        if (query == null && queryFile != null) {
+            try {
+                query = IOHelper.loadText(ObjectHelper.loadResourceAsStream(queryFile));
+            } catch (IOException e) {
+                throw new RuntimeCamelException(""Failed to read query file: "" + queryFile, e);
+            }
+        }
+        return query;
+    }
+
+    public void setQuery(String query) {
+        this.query = query;
+    }
+
+    public String getQueryFile() {","[{'comment': '@akieling you need to add javadoc to this setter/getter methods, take a look at other components. The javadoc will be used as description in the component adoc documentation file.', 'commenter': 'oscerd'}]"
3232,components/camel-graphql/src/main/java/org/apache/camel/component/graphql/GraphqlEndpoint.java,"@@ -0,0 +1,225 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.graphql;
+
+import java.io.IOException;
+import java.net.URI;
+import java.util.Arrays;
+
+import org.apache.camel.Component;
+import org.apache.camel.Consumer;
+import org.apache.camel.Processor;
+import org.apache.camel.Producer;
+import org.apache.camel.RuntimeCamelException;
+import org.apache.camel.spi.Metadata;
+import org.apache.camel.spi.UriEndpoint;
+import org.apache.camel.spi.UriParam;
+import org.apache.camel.spi.UriPath;
+import org.apache.camel.support.DefaultEndpoint;
+import org.apache.camel.util.IOHelper;
+import org.apache.camel.util.ObjectHelper;
+import org.apache.camel.util.json.JsonObject;
+import org.apache.http.HttpHeaders;
+import org.apache.http.HttpHost;
+import org.apache.http.auth.AuthScope;
+import org.apache.http.auth.UsernamePasswordCredentials;
+import org.apache.http.client.CredentialsProvider;
+import org.apache.http.client.utils.HttpClientUtils;
+import org.apache.http.impl.client.BasicCredentialsProvider;
+import org.apache.http.impl.client.CloseableHttpClient;
+import org.apache.http.impl.client.HttpClientBuilder;
+import org.apache.http.impl.client.HttpClients;
+import org.apache.http.message.BasicHeader;
+
+@UriEndpoint(firstVersion = ""3.0.0"", scheme = ""graphql"", title = ""GraphQL"", syntax = ""graphql:httpUri?options"", label = ""graphql"", producerOnly = true)","[{'comment': 'The syntax should not include query parameters, eg ?options should be removed', 'commenter': 'davsclaus'}]"
3232,components/camel-graphql/src/main/java/org/apache/camel/component/graphql/GraphqlEndpoint.java,"@@ -0,0 +1,225 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.graphql;
+
+import java.io.IOException;
+import java.net.URI;
+import java.util.Arrays;
+
+import org.apache.camel.Component;
+import org.apache.camel.Consumer;
+import org.apache.camel.Processor;
+import org.apache.camel.Producer;
+import org.apache.camel.RuntimeCamelException;
+import org.apache.camel.spi.Metadata;
+import org.apache.camel.spi.UriEndpoint;
+import org.apache.camel.spi.UriParam;
+import org.apache.camel.spi.UriPath;
+import org.apache.camel.support.DefaultEndpoint;
+import org.apache.camel.util.IOHelper;
+import org.apache.camel.util.ObjectHelper;
+import org.apache.camel.util.json.JsonObject;
+import org.apache.http.HttpHeaders;
+import org.apache.http.HttpHost;
+import org.apache.http.auth.AuthScope;
+import org.apache.http.auth.UsernamePasswordCredentials;
+import org.apache.http.client.CredentialsProvider;
+import org.apache.http.client.utils.HttpClientUtils;
+import org.apache.http.impl.client.BasicCredentialsProvider;
+import org.apache.http.impl.client.CloseableHttpClient;
+import org.apache.http.impl.client.HttpClientBuilder;
+import org.apache.http.impl.client.HttpClients;
+import org.apache.http.message.BasicHeader;
+
+@UriEndpoint(firstVersion = ""3.0.0"", scheme = ""graphql"", title = ""GraphQL"", syntax = ""graphql:httpUri?options"", label = ""graphql"", producerOnly = true)
+public class GraphqlEndpoint extends DefaultEndpoint {
+
+    @UriPath
+    @Metadata(required = true)
+    private URI httpUri;
+    @UriParam
+    private String proxyHost;
+    @UriParam
+    private String accessToken;
+    @UriParam","[{'comment': 'Add label = ""security"" and there is a secret = true to set as well for sensitive options', 'commenter': 'davsclaus'}]"
3232,components/camel-graphql/src/main/java/org/apache/camel/component/graphql/GraphqlEndpoint.java,"@@ -0,0 +1,225 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.graphql;
+
+import java.io.IOException;
+import java.net.URI;
+import java.util.Arrays;
+
+import org.apache.camel.Component;
+import org.apache.camel.Consumer;
+import org.apache.camel.Processor;
+import org.apache.camel.Producer;
+import org.apache.camel.RuntimeCamelException;
+import org.apache.camel.spi.Metadata;
+import org.apache.camel.spi.UriEndpoint;
+import org.apache.camel.spi.UriParam;
+import org.apache.camel.spi.UriPath;
+import org.apache.camel.support.DefaultEndpoint;
+import org.apache.camel.util.IOHelper;
+import org.apache.camel.util.ObjectHelper;
+import org.apache.camel.util.json.JsonObject;
+import org.apache.http.HttpHeaders;
+import org.apache.http.HttpHost;
+import org.apache.http.auth.AuthScope;
+import org.apache.http.auth.UsernamePasswordCredentials;
+import org.apache.http.client.CredentialsProvider;
+import org.apache.http.client.utils.HttpClientUtils;
+import org.apache.http.impl.client.BasicCredentialsProvider;
+import org.apache.http.impl.client.CloseableHttpClient;
+import org.apache.http.impl.client.HttpClientBuilder;
+import org.apache.http.impl.client.HttpClients;
+import org.apache.http.message.BasicHeader;
+
+@UriEndpoint(firstVersion = ""3.0.0"", scheme = ""graphql"", title = ""GraphQL"", syntax = ""graphql:httpUri?options"", label = ""graphql"", producerOnly = true)
+public class GraphqlEndpoint extends DefaultEndpoint {
+
+    @UriPath
+    @Metadata(required = true)
+    private URI httpUri;
+    @UriParam
+    private String proxyHost;
+    @UriParam
+    private String accessToken;
+    @UriParam
+    private String username;
+    @UriParam
+    private String password;
+    @UriParam
+    private String query;
+    @UriParam
+    private String queryFile;
+    @UriParam
+    private String operationName;
+    @UriParam
+    private JsonObject variables;
+
+    private CloseableHttpClient httpClient;
+
+    public GraphqlEndpoint(String uri, Component component) {
+        super(uri, component);
+    }
+
+    @Override
+    protected void doStop() throws Exception {
+        HttpClientUtils.closeQuietly(this.httpClient);
+    }
+
+    @Override
+    public Producer createProducer() throws Exception {
+        return new GraphqlProducer(this);
+    }
+
+    @Override
+    public Consumer createConsumer(Processor processor) throws Exception {
+        throw new UnsupportedOperationException(""You cannot receive messages at this endpoint: "" + getEndpointUri());
+    }
+
+    public CloseableHttpClient getHttpclient() {","[{'comment': 'Its better to do all those initialization in doStart, eg also the one that loads the query file, then all initialization is done at the right moment', 'commenter': 'davsclaus'}]"
3232,components/camel-graphql/src/test/java/org/apache/camel/component/graphql/GraphqlProducerTest.java,"@@ -0,0 +1,42 @@
+package org.apache.camel.component.graphql;","[{'comment': 'Add license header', 'commenter': 'davsclaus'}]"
3236,components/camel-undertow/src/main/java/org/apache/camel/component/undertow/DefaultUndertowHttpBinding.java,"@@ -337,28 +349,30 @@ public Object toHttpResponse(HttpServerExchange httpExchange, Message message) t
         Exception exception = message.getExchange().getException();
 
         if (exception != null) {
-            if (isTransferException()) {
-                // we failed due an exception, and transfer it as java serialized object
-                ByteArrayOutputStream bos = new ByteArrayOutputStream();
-                ObjectOutputStream oos = new ObjectOutputStream(bos);
-                oos.writeObject(exception);
-                oos.flush();
-                IOHelper.close(oos, bos);
-
-                // the body should be the serialized java object of the exception
-                body = ByteBuffer.wrap(bos.toByteArray());
-                // force content type to be serialized java object
-                message.setHeader(Exchange.CONTENT_TYPE, ""application/x-java-serialized-object"");
-            } else {
-                // we failed due an exception so print it as plain text
-                StringWriter sw = new StringWriter();
-                PrintWriter pw = new PrintWriter(sw);
-                exception.printStackTrace(pw);
-
-                // the body should then be the stacktrace
-                body = ByteBuffer.wrap(sw.toString().getBytes());
-                // force content type to be text/plain as that is what the stacktrace is
-                message.setHeader(Exchange.CONTENT_TYPE, ""text/plain"");
+            if (!isMuteException()) {","[{'comment': 'Put this on a single line exception != null && !isMute ...', 'commenter': 'davsclaus'}, {'comment': 'I put this on a single line. However, with muteException enabled the exchange will not be marked as failure handled. I\'m wondering whether I should include a second condition ""exception != null && isMute..."" that does exactly this.', 'commenter': 'mschnitzler'}, {'comment': 'Ah sorry my bad then, yeah you are welcome to make it so its understandable and maintainable. Or maybe have a if (muteException) else { ... } block etc', 'commenter': 'davsclaus'}, {'comment': 'In commits 2b8ab50 and 95a7150 I put the nested conditions into single line statement and added a second condition to mark the failure as handled since the exception is actively muted.', 'commenter': 'mschnitzler'}]"
3236,components/camel-undertow/src/main/java/org/apache/camel/component/undertow/UndertowEndpoint.java,"@@ -87,6 +87,8 @@
     private Boolean throwExceptionOnFailure = Boolean.TRUE;
     @UriParam(label = ""producer"", defaultValue = ""false"")
     private Boolean transferException = Boolean.FALSE;
+    @UriParam(label = ""producer"", defaultValue = ""false"")","[{'comment': 'This should be consumer label', 'commenter': 'davsclaus'}, {'comment': 'fixed in commit d4f50d0', 'commenter': 'mschnitzler'}]"
3237,components/camel-pulsar/src/main/docs/pulsar-component.adoc,"@@ -98,7 +98,7 @@ with the following path and query parameters:
 | *maxPendingMessagesAcross Partitions* (producer) | Set the number of max pending messages across all the partitions. Default is 50000. | 50000 | int
 | *messageRouter* (producer) | Set a custom Message Router. |  | MessageRouter
 | *messageRoutingMode* (producer) | Set the message routing mode for the producer. | RoundRobinPartition | MessageRoutingMode
-| *producerName* (producer) | Name of the producer | default-producer | String
+| *producerName* (producer) | Name of the producer, if unset lets Pulsar select a unique identifier | | String","[{'comment': 'The doc changes in this table should happen in the source code, also it should be `an unique`', 'commenter': 'davsclaus'}, {'comment': ""Oh ok, I didn't think this was automated. Is it only the default value field that is done through the source code or is there some file I'm missing that contains the description? \r\n\r\nI disagree with `an unique` given the first syllable is pronounced like `you` which is not a vowel sound."", 'commenter': 'williamthompson-toast'}, {'comment': ""Figured out how to do the docs. It's not exactly clear the maven command to run to generate the new one, but I think I've figured it out."", 'commenter': 'williamthompson-toast'}]"
3237,components/camel-pulsar/src/main/java/org/apache/camel/component/pulsar/configuration/PulsarConfiguration.java,"@@ -41,8 +41,8 @@
     private int consumerQueueSize = 10;
     @UriParam(label = ""consumer"", defaultValue = ""sole-consumer"")
     private String consumerName = ""sole-consumer"";
-    @UriParam(label = ""producer"", defaultValue = ""default-producer"")
-    private String producerName = ""default-producer"";
+    @UriParam(label = ""producer"")
+    private String producerName = null;","[{'comment': 'remove `= null` as its default in java', 'commenter': 'davsclaus'}]"
3239,components/camel-undertow/src/main/java/org/apache/camel/component/undertow/UndertowConsumer.java,"@@ -181,6 +181,14 @@ public void handleRequest(HttpServerExchange httpExchange) throws Exception {
     private void sendResponse(HttpServerExchange httpExchange, Exchange camelExchange) throws IOException, NoTypeConversionAvailableException {
         Object body = getResponseBody(httpExchange, camelExchange);
 
+        Message answer;
+        if (camelExchange.hasOut()) {","[{'comment': 'I think `hasOut` is being deprecated here https://github.com/apache/camel/blob/master/core/camel-api/src/main/java/org/apache/camel/Exchange.java#L456, I think is better to use `getMessage` instead', 'commenter': 'omarsmak'}, {'comment': 'thanks, saw that it was deprecated but also is used in a lot of places. Was not sure what the preferred approach was. Guess I should have read that JavaDoc more closely. :)\r\n\r\nalso, was going to clean this all up a bit. mostly wanted to know if this was the right place to but the code since it was different than Netty-Http (see #3219 )\r\n\r\nfor some failed tests, that currently have no body but return 200, what would be the preferred approach to fixing. Add a body or change the expected status to 204?', 'commenter': 'CodeSmell'}, {'comment': 'IMHO having 204 is more clear natural that corresponds to the status code definition ', 'commenter': 'omarsmak'}]"
3239,components/camel-undertow/src/main/java/org/apache/camel/component/undertow/UndertowConsumer.java,"@@ -201,6 +209,29 @@ private void sendResponse(HttpServerExchange httpExchange, Exchange camelExchang
             httpExchange.getResponseSender().send(bodyAsByteBuffer);
         }
     }
+    
+    protected void handleNoContent(Exchange exchange, Message answer, HttpServerExchange httpExchange) {
+        if (httpExchange.getStatusCode() == 200 && hasNoContentBody(exchange, answer)) {
+            answer.getHeaders().put(Exchange.HTTP_RESPONSE_CODE, 204);
+            answer.getHeaders().put(Exchange.HTTP_RESPONSE_TEXT, ""No Content"");
+            answer.setBody("""");
+
+            httpExchange.setStatusCode(204);
+        }
+    }
+    
+    protected boolean hasNoContentBody(Exchange exchange, Message answer) {
+        boolean hasNoBody = false;
+        String bodyObj = answer.getBody(String.class);
+        if (bodyObj == null || bodyObj.trim().isEmpty()
+            || bodyObj.equalsIgnoreCase(""No Content"") 
+            || bodyObj.equalsIgnoreCase(""No Body"")){","[{'comment': 'nit:  I think you can just return the results of this predicate with no need to initialise `hasNoBody` \r\n```suggestion\r\n            return bodyObj == null || bodyObj.trim().isEmpty()  || bodyObj.equalsIgnoreCase(""No Content"")  || bodyObj.equalsIgnoreCase(""No Body"");\r\n```', 'commenter': 'omarsmak'}]"
3239,components/camel-undertow/src/main/java/org/apache/camel/component/undertow/UndertowConsumer.java,"@@ -196,11 +200,51 @@ private void sendResponse(HttpServerExchange httpExchange, Exchange camelExchang
                 IOHelper.copy(input, output, IOHelper.DEFAULT_BUFFER_SIZE, true);
             }
         } else {
-            TypeConverter tc = getEndpoint().getCamelContext().getTypeConverter();
-            ByteBuffer bodyAsByteBuffer = tc.mandatoryConvertTo(ByteBuffer.class, body);
+            ByteBuffer bodyAsByteBuffer = this.convertBodyToByteBuffer(camelExchange, httpExchange, body);
             httpExchange.getResponseSender().send(bodyAsByteBuffer);
         }
     }
+    
+    /*
+     * when an HTTP response has status code 200 
+     * but does not have content in the body change the status code to 204
+     */
+    private void changeStatusCodeToNoContent(Exchange camelExchange, HttpServerExchange httpExchange) {
+        Message answer = camelExchange.getMessage();
+        if (httpExchange.getStatusCode() == 200) {
+            answer.getHeaders().put(Exchange.HTTP_RESPONSE_CODE, 204);
+            answer.getHeaders().put(Exchange.HTTP_RESPONSE_TEXT, ""No Content"");
+
+            httpExchange.setStatusCode(204);
+        }
+    }
+ 
+    private ByteBuffer convertBodyToByteBuffer(Exchange camelExchange, HttpServerExchange httpExchange, Object bodyObj) throws NoTypeConversionAvailableException {
+        
+        TypeConverter tc = getEndpoint().getCamelContext().getTypeConverter();
+        ByteBuffer bodyAsByteBuffer = tc.mandatoryConvertTo(ByteBuffer.class, bodyObj);
+        
+        if (!bodyAsByteBuffer.hasRemaining()) {
+            this.changeStatusCodeToNoContent(camelExchange, httpExchange);
+        } else {
+            if (this.hasNoContent(StandardCharsets.UTF_8.decode(bodyAsByteBuffer.asReadOnlyBuffer()).toString())) {
+                this.changeStatusCodeToNoContent(camelExchange, httpExchange);
+            }
+        }
+        
+        return bodyAsByteBuffer;
+
+    }
+    
+    private boolean hasNoContent(String bodyAsString) {","[{'comment': '@CodeSmell You don\'t need to return true or false, you can just return the result of the predicate directly, e.g:\r\n```suggestion\r\n    private boolean hasNoContent(String bodyAsString) {\r\n        return (bodyAsString.trim().isEmpty()\r\n            || bodyAsString.equalsIgnoreCase(""No Content"")\r\n            || bodyAsString.equalsIgnoreCase(""No Body""));\r\n    }\r\n```', 'commenter': 'omarsmak'}]"
3239,components/camel-undertow/src/main/java/org/apache/camel/component/undertow/UndertowConsumer.java,"@@ -196,11 +200,51 @@ private void sendResponse(HttpServerExchange httpExchange, Exchange camelExchang
                 IOHelper.copy(input, output, IOHelper.DEFAULT_BUFFER_SIZE, true);
             }
         } else {
-            TypeConverter tc = getEndpoint().getCamelContext().getTypeConverter();
-            ByteBuffer bodyAsByteBuffer = tc.mandatoryConvertTo(ByteBuffer.class, body);
+            ByteBuffer bodyAsByteBuffer = this.convertBodyToByteBuffer(camelExchange, httpExchange, body);
             httpExchange.getResponseSender().send(bodyAsByteBuffer);
         }
     }
+    
+    /*
+     * when an HTTP response has status code 200 
+     * but does not have content in the body change the status code to 204
+     */
+    private void changeStatusCodeToNoContent(Exchange camelExchange, HttpServerExchange httpExchange) {
+        Message answer = camelExchange.getMessage();
+        if (httpExchange.getStatusCode() == 200) {
+            answer.getHeaders().put(Exchange.HTTP_RESPONSE_CODE, 204);
+            answer.getHeaders().put(Exchange.HTTP_RESPONSE_TEXT, ""No Content"");
+
+            httpExchange.setStatusCode(204);
+        }
+    }
+ 
+    private ByteBuffer convertBodyToByteBuffer(Exchange camelExchange, HttpServerExchange httpExchange, Object bodyObj) throws NoTypeConversionAvailableException {
+        
+        TypeConverter tc = getEndpoint().getCamelContext().getTypeConverter();
+        ByteBuffer bodyAsByteBuffer = tc.mandatoryConvertTo(ByteBuffer.class, bodyObj);
+        
+        if (!bodyAsByteBuffer.hasRemaining()) {
+            this.changeStatusCodeToNoContent(camelExchange, httpExchange);","[{'comment': 'Can you please clarify why this check was needed? ', 'commenter': 'omarsmak'}, {'comment': ""if there isn't anything in the `ByteBuffer` we would change the status code from 200 to 204"", 'commenter': 'CodeSmell'}, {'comment': ""Aha I see, but if you will just check for the emptiness of the body here https://github.com/apache/camel/blob/master/components/camel-undertow/src/main/java/org/apache/camel/component/undertow/DefaultUndertowHttpBinding.java#L325, I don't think you'd still need this logic here. However maybe is worth to give a try first?"", 'commenter': 'omarsmak'}, {'comment': ""should we check the body if there is an exception? I was moving it to the `else` and doing the check only if there wasn't one. "", 'commenter': 'CodeSmell'}, {'comment': '@CodeSmell I am not really sure if this is necessary. ', 'commenter': 'omarsmak'}, {'comment': ""which part? checking after making sure there isn't an exception?"", 'commenter': 'CodeSmell'}, {'comment': 'yeah, please see my other comment about the logic of the status code https://github.com/apache/camel/pull/3239#discussion_r334049060', 'commenter': 'omarsmak'}]"
3239,components/camel-undertow/src/main/java/org/apache/camel/component/undertow/UndertowConsumer.java,"@@ -183,6 +186,7 @@ private void sendResponse(HttpServerExchange httpExchange, Exchange camelExchang
 
         if (body == null) {
             log.trace(""No payload to send as reply for exchange: {}"", camelExchange);
+            this.changeStatusCodeToNoContent(camelExchange, httpExchange);","[{'comment': ""Do you think as well, if we handle the status code from here instead: https://github.com/apache/camel/blob/master/components/camel-undertow/src/main/java/org/apache/camel/component/undertow/DefaultUndertowHttpBinding.java#L314? From the top of my head, if you handle it from there (which is the main responsibility of that method), you won't need any more modifications elsewhere apart from the tests. Also, I'd recommend to use the enum `StatusCode.NO_CONTENT` instead of the raw int"", 'commenter': 'omarsmak'}, {'comment': ""After going through the debugger, wasn't sure of the best place to implement it. There were quite a few classes. Was hoping for that feedback. I'll try moving the code for this feature and test it. \r\n"", 'commenter': 'CodeSmell'}, {'comment': 'Sorry here: https://github.com/apache/camel/blob/master/components/camel-undertow/src/main/java/org/apache/camel/component/undertow/DefaultUndertowHttpBinding.java#L325', 'commenter': 'omarsmak'}, {'comment': 'Looks like moving it to `DefaultUndertowHttpBinding` is working! Thanks', 'commenter': 'CodeSmell'}, {'comment': 'You welcome! Also I advice to do the same in your other PR :)', 'commenter': 'omarsmak'}]"
3239,components/camel-undertow/src/main/java/org/apache/camel/component/undertow/DefaultUndertowHttpBinding.java,"@@ -319,7 +321,8 @@ public void populateCamelHeaders(ClientResponse response, Map<String, Object> he
 
     @Override
     public Object toHttpResponse(HttpServerExchange httpExchange, Message message) throws IOException {
-        boolean failed = message.getExchange().isFailed();
+        Exchange camelExchange = message.getExchange();
+        boolean failed = camelExchange.isFailed();
         int defaultCode = failed ? 500 : 200;
 
         int code = message.getHeader(Exchange.HTTP_RESPONSE_CODE, defaultCode, int.class);","[{'comment': 'I was on thinking something simpler for the logic, maybe something like this:  \r\n```suggestion\r\n            int code = message.getHeader(Exchange.HTTP_RESPONSE_CODE, defaultCode, int.class);\r\n            httpExchange.setStatusCode(code);\r\n            Object body = message.getBody();\r\n            code = checkIfNoContentAndReturnCorrectStatusCode(body, code);\r\n            httpExchange.setStatusCode(code);\r\n```\r\nwhereby `checkIfNoContentAndReturnCorrectStatusCode` will check if body is null as well if it has empty content, if true, then return `204` otherwise return code in the method param. What do you think of this approach ?', 'commenter': 'omarsmak'}, {'comment': 'oddly that was very close to what I originally had, though I would still prefer the method handles all of the changes inside of it since there are couple of headers and possibly the body itself that will be updated', 'commenter': 'CodeSmell'}, {'comment': 'also still have to handle 3 possible values for body differently\r\n- null\r\n- `InputStream`\r\n- non `InputStream` \r\n\r\nbecause we have to check for various values in the body that count as ""empty""', 'commenter': 'CodeSmell'}]"
3239,components/camel-undertow/src/main/java/org/apache/camel/component/undertow/DefaultUndertowHttpBinding.java,"@@ -373,12 +376,24 @@ public Object toHttpResponse(HttpServerExchange httpExchange, Message message) t
             }
 
             // and mark the exception as failure handled, as we handled it by returning it as the response
-            ExchangeHelper.setFailureHandled(message.getExchange());
+            ExchangeHelper.setFailureHandled(camelExchange);
         } else if (exception != null && isMuteException()) {
             // mark the exception as failure handled, as we handled it by actively muting it
-            ExchangeHelper.setFailureHandled(message.getExchange());
+            ExchangeHelper.setFailureHandled(camelExchange);
+        } else {
+            // there are no exceptions
+            // so check the body for content
+            // if there is none change the status code to 204
+            if (body == null) {
+                this.changeStatusCodeToNoContent(camelExchange, httpExchange);","[{'comment': 'nit: no need to use `this`', 'commenter': 'omarsmak'}]"
3239,components/camel-undertow/src/main/java/org/apache/camel/component/undertow/DefaultUndertowHttpBinding.java,"@@ -389,6 +393,63 @@ public Object toHttpResponse(HttpServerExchange httpExchange, Message message) t
         return body;
     }
 
+    /*
+     * when an HTTP response has status code 200 
+     * but does not have content in the body change the status code to 204
+     */
+    private void handleResponseWithNoContent(Exchange camelExchange, HttpServerExchange httpExchange, Object body) {
+        if (body == null) {
+            changeStatusCodeToNoContent(camelExchange, httpExchange);
+        } else {
+            checkBodyForContentAndUpdateStatusCode(camelExchange, httpExchange, body);
+        }
+    }
+    
+    /*
+     * change the status code to no content
+     */
+    private void changeStatusCodeToNoContent(Exchange camelExchange, HttpServerExchange httpExchange) {
+        Message message = camelExchange.getMessage();
+        if (httpExchange.getStatusCode() == 200) {
+            message.getHeaders().put(Exchange.HTTP_RESPONSE_CODE, 204);
+            message.getHeaders().put(Exchange.HTTP_RESPONSE_TEXT, StatusCodes.NO_CONTENT_STRING);
+            httpExchange.setStatusCode(204);
+        }
+    }
+    
+    /*
+     * check body content for being empty
+     */
+    private void checkBodyForContentAndUpdateStatusCode(Exchange camelExchange, HttpServerExchange httpExchange, Object body) {
+        if (body instanceof InputStream) {
+            // reading out the input stream to check it causes issues 
+            // do we want to check using PushbackStream?
+        } else {
+            //
+            TypeConverter tc = camelExchange.getContext().getTypeConverter();
+            ByteBuffer bodyAsByteBuffer = tc.convertTo(ByteBuffer.class, body);
+            if (!bodyAsByteBuffer.hasRemaining()) {
+                this.changeStatusCodeToNoContent(camelExchange, httpExchange);
+            } else {
+                if (hasNoContent(StandardCharsets.UTF_8.decode(bodyAsByteBuffer.asReadOnlyBuffer()).toString())) {
+                    changeStatusCodeToNoContent(camelExchange, httpExchange);
+                }
+            }
+        }
+    }
+    
+    /*
+     * an empty body along with 
+     * various values in the body 
+     * will be treated as no content
+     */
+    private boolean hasNoContent(String bodyAsString) {
+        return (bodyAsString.trim().isEmpty()
+            || bodyAsString.equalsIgnoreCase(""No Content"")","[{'comment': '@davsclaus I am bit confused, do we really need to check if body has these strings? As I understood from your JIRA https://issues.apache.org/jira/browse/CAMEL-14029, component shouldnt produces such strings at all and instead add the correct status code `204`.  ', 'commenter': 'omarsmak'}, {'comment': 'this was added based on comments from the other PR (HTTP-Netty)', 'commenter': 'CodeSmell'}, {'comment': 'Hey @CodeSmell, sorry for not spotting this earlier. However I guess what @davsclaus meant on the other PR is that, sometimes there might be a component that when camel body is null, they just return hard coded text. However in your case, all what you need to do is, just check if there is an empty/null camel return 204 otherwise 200. It should be very simple ', 'commenter': 'omarsmak'}]"
3245,core/camel-support/src/main/java/org/apache/camel/support/EndpointHelper.java,"@@ -42,6 +42,8 @@
 
 import static org.apache.camel.util.StringHelper.after;
 
+import java.util.function.Function;
+","[{'comment': 'This will fail the codestyle check. Try to run the build with the profile sourcecheck enabled and fix the warnings reported. Thanks.', 'commenter': 'oscerd'}, {'comment': 'Thanks, will do', 'commenter': 'srdo'}]"
3245,core/camel-support/src/main/java/org/apache/camel/support/EndpointHelper.java,"@@ -126,24 +127,40 @@ public static boolean matchEndpoint(CamelContext context, String uri, String pat
         }
 
         // we need to test with and without scheme separators (//)
-        if (uri.contains(""://"")) {
-            // try without :// also
-            String scheme = StringHelper.before(uri, ""://"");
-            String path = after(uri, ""://"");
-            if (PatternHelper.matchPattern(scheme + "":"" + path, pattern)) {
-                return true;
-            }
-        } else {
-            // try with :// also
-            String scheme = StringHelper.before(uri, "":"");
-            String path = after(uri, "":"");
-            if (PatternHelper.matchPattern(scheme + ""://"" + path, pattern)) {
-                return true;
+        boolean match = PatternHelper.matchPattern(toggleUriSchemeSeparators(uri), pattern);
+        match |= PatternHelper.matchPattern(uri, pattern);
+        if (!match && pattern != null && pattern.contains(""?"")) {
+            // try normalizing the pattern as a uri for exact matching, so parameters are ordered the same as in the endpoint uri
+            try {
+                pattern = URISupport.normalizeUri(pattern);
+                // try both with and without scheme separators (//)
+                match = toggleUriSchemeSeparators(uri).equalsIgnoreCase(pattern);
+                return match || uri.equalsIgnoreCase(pattern);
+            } catch (URISyntaxException e) {","[{'comment': 'I dont like swallowed exceptions as they impact performance. We need to consider that matchEndpoint if its used during routing then this can slow down unnecessary.\r\n\r\nNeed to investigate some more', 'commenter': 'davsclaus'}, {'comment': 'Okay looked at this, and we only use this for interceptors at runtime so there is no normal overhead. And we also normalize the uri, so this logic does attempt to normalize also.', 'commenter': 'davsclaus'}]"
3247,components/camel-salesforce/camel-salesforce-component/src/main/java/org/apache/camel/component/salesforce/internal/streaming/SubscriptionHelper.java,"@@ -397,13 +405,48 @@ public void onMessage(ClientSessionChannel channel, Message message) {
                         if (error == null) {
                             error = ""Missing error message"";
                         }
+
                         Exception failure = getFailure(message);
                         String msg = String.format(""Error subscribing to %s: %s"", topicName, failure != null ? failure.getMessage() : error);
-                        consumer.handleException(msg, new SalesforceException(msg, failure));
+                        boolean abort = true;
+
+                        if (isTemporaryError(message)) {
+                            LOG.warn(msg);
+
+                            // retry after delay
+                            final long backoff = restartBackoff.getAndAdd(backoffIncrement);
+                            if (backoff > maxBackoff) {
+                                LOG.error(""Subscribe aborted after exceeding {} msecs backoff"", maxBackoff);
+                            } else {
+                                abort = false;
+
+                                try {
+                                    LOG.debug(""Pausing for {} msecs before subscribe attempt"", backoff);
+                                    Thread.sleep(backoff);
+
+                                    final SalesforceHttpClient httpClient = component.getConfig().getHttpClient();
+                                    httpClient.getExecutor().execute(new Runnable() {
+                                        @Override
+                                        public void run() {
+                                            subscribe(topicName, consumer);
+                                        }
+                                    });
+                                } catch (InterruptedException e) {
+                                    LOG.error(""Aborting subscribe on interrupt!"", e);","[{'comment': 'WARN', 'commenter': 'davsclaus'}, {'comment': 'Fixed', 'commenter': 'tomwetjens'}]"
3250,components/camel-corda/pom.xml,"@@ -36,6 +36,20 @@
     <properties>
     </properties>
 
+    <repositories>","[{'comment': ""Please don't use third party repository. It's a nightmare. We already passed through this with restlet. If it's not available in central we'll wait for it. But please avoid third party repository."", 'commenter': 'oscerd'}, {'comment': 'I have already raised with R3 to release the corda-rpc:4.1 to maven central ... Hope this will be fixed soon ', 'commenter': 'pkrishnath'}, {'comment': '@oscerd , I have not tested karaf feature .. Would you be able to guid me how to test karaf feature?', 'commenter': 'pkrishnath'}, {'comment': 'Just build platform/karaf/features and the run camelcordatest under tests/camel-itest-karaf \r\n\r\nThanks', 'commenter': 'oscerd'}, {'comment': 'Thanks @oscerd .. testing karaf feature is  done .. All good', 'commenter': 'pkrishnath'}]"
3272,components/camel-kudu/pom.xml,"@@ -0,0 +1,183 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one or more
+    contributor license agreements.  See the NOTICE file distributed with
+    this work for additional information regarding copyright ownership.
+    The ASF licenses this file to You under the Apache License, Version 2.0
+    (the ""License""); you may not use this file except in compliance with
+    the License.  You may obtain a copy of the License at
+
+         http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an ""AS IS"" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+
+-->
+<project xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
+         xmlns=""http://maven.apache.org/POM/4.0.0""
+         xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+    <modelVersion>4.0.0</modelVersion>
+
+    <parent>
+        <groupId>org.apache.camel</groupId>
+        <artifactId>components</artifactId>
+        <version>2.25.0-SNAPSHOT</version>
+    </parent>
+
+    <artifactId>camel-kudu</artifactId>
+    <packaging>jar</packaging>
+    <name>Camel :: Kudu</name>
+
+
+    <properties>
+        <schemeName>kudu</schemeName>
+        <componentName>Apache Kudu</componentName>
+        <componentPackage>org.apache.camel.component.kudu</componentPackage>
+        <kuduVersion>1.10.0</kuduVersion>","[{'comment': 'please add this properties under parent/pom', 'commenter': 'oscerd'}]"
3272,components/camel-kudu/pom.xml,"@@ -0,0 +1,183 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one or more
+    contributor license agreements.  See the NOTICE file distributed with
+    this work for additional information regarding copyright ownership.
+    The ASF licenses this file to You under the Apache License, Version 2.0
+    (the ""License""); you may not use this file except in compliance with
+    the License.  You may obtain a copy of the License at
+
+         http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an ""AS IS"" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+
+-->
+<project xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
+         xmlns=""http://maven.apache.org/POM/4.0.0""
+         xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+    <modelVersion>4.0.0</modelVersion>
+
+    <parent>
+        <groupId>org.apache.camel</groupId>
+        <artifactId>components</artifactId>
+        <version>2.25.0-SNAPSHOT</version>
+    </parent>
+
+    <artifactId>camel-kudu</artifactId>
+    <packaging>jar</packaging>
+    <name>Camel :: Kudu</name>
+
+
+    <properties>
+        <schemeName>kudu</schemeName>
+        <componentName>Apache Kudu</componentName>
+        <componentPackage>org.apache.camel.component.kudu</componentPackage>
+        <kuduVersion>1.10.0</kuduVersion>
+        <slf4jVersion>1.7.25</slf4jVersion>","[{'comment': 'This can be removed I guess', 'commenter': 'oscerd'}]"
3272,components/camel-kudu/src/main/java/org/apache/camel/component/kudu/KuduEndpoint.java,"@@ -0,0 +1,182 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.kudu;
+
+import org.apache.camel.Consumer;
+import org.apache.camel.Processor;
+import org.apache.camel.Producer;
+import org.apache.camel.impl.DefaultEndpoint;
+import org.apache.camel.spi.Metadata;
+import org.apache.camel.spi.UriEndpoint;
+import org.apache.camel.spi.UriParam;
+import org.apache.camel.spi.UriPath;
+import org.apache.kudu.client.KuduClient;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * Represents a Kudu endpoint. A kudu endpoint allows you to interact with
+ * <a href=""https://kudu.apache.org/"">Apache Kudu</a>, a free and open source
+ * column-oriented data store of the Apache Hadoop ecosystem.
+ */
+@UriEndpoint(firstVersion = ""2.23.0"",","[{'comment': 'First version shoud be 2.25.0', 'commenter': 'oscerd'}]"
3272,components/camel-kudu/src/main/java/org/apache/camel/component/kudu/KuduEndpoint.java,"@@ -0,0 +1,182 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.kudu;
+
+import org.apache.camel.Consumer;
+import org.apache.camel.Processor;
+import org.apache.camel.Producer;
+import org.apache.camel.impl.DefaultEndpoint;
+import org.apache.camel.spi.Metadata;
+import org.apache.camel.spi.UriEndpoint;
+import org.apache.camel.spi.UriParam;
+import org.apache.camel.spi.UriPath;
+import org.apache.kudu.client.KuduClient;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * Represents a Kudu endpoint. A kudu endpoint allows you to interact with
+ * <a href=""https://kudu.apache.org/"">Apache Kudu</a>, a free and open source
+ * column-oriented data store of the Apache Hadoop ecosystem.
+ */
+@UriEndpoint(firstVersion = ""2.23.0"",
+    scheme = ""kudu"",
+    title = ""Apache Kudu"", syntax = ""kudu:type"",
+    consumerClass = KuduConsumer.class,
+    label = ""database,iot"")
+public class KuduEndpoint extends DefaultEndpoint {
+
+    private static final Logger LOG = LoggerFactory.getLogger(KuduEndpoint.class);
+    private KuduClient kuduClient;
+
+    @UriPath
+    @Metadata(required = ""true"")
+    private String type;
+
+    @UriParam
+    @Metadata(required = ""true"")
+    private String host;
+
+    @UriParam
+    @Metadata(required = ""true"")
+    private String port;
+
+    @UriParam
+    private KuduOperations operation = KuduOperations.INSERT;
+
+    @UriParam
+    private String tableName;
+
+    public KuduEndpoint(String uri, KuduComponent component) {
+        super(uri, component);
+    }
+
+    @Override
+    protected void doStart() throws Exception {
+        LOG.trace(""Connection: {}, {}"", getHost(), getPort());
+
+        //To facilitate tests, if the client is already created, do not recreate.
+        if (this.getKuduClient() == null) {
+            setKuduClient(new KuduClient.KuduClientBuilder(getHost() + "":"" + getPort()).build());
+        }
+        LOG.debug(""Resolved the host with the name {} as {}"", getHost(), getKuduClient());
+        super.doStart();
+    }
+
+    @Override
+    protected void doStop() throws Exception {
+        try {
+            LOG.info(""doStop()"");
+            getKuduClient().shutdown();
+        } catch (Exception e) {
+            LOG.error(""Unable to shutdown kudu client"", e);
+        }
+
+        super.doStop();
+    }
+
+    public String getHost() {
+        return host;
+    }
+
+    /**
+     * Kudu master to connect to
+     */
+    public void setHost(String host) {
+        this.host = host;
+    }
+
+    public String getPort() {
+        return port;
+    }
+
+    public KuduClient getKuduClient() {
+        return kuduClient;
+    }
+
+    /**
+     * Set the client to connect to a kudu resource
+     *
+     * @param kuduClient","[{'comment': 'all the @param annotations can be removed', 'commenter': 'oscerd'}]"
3272,components/camel-kudu/src/main/java/org/apache/camel/component/kudu/KuduProducer.java,"@@ -0,0 +1,136 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.kudu;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+import org.apache.camel.Exchange;
+import org.apache.camel.impl.DefaultProducer;
+import org.apache.camel.util.ObjectHelper;
+import org.apache.kudu.ColumnSchema;
+import org.apache.kudu.Schema;
+import org.apache.kudu.client.CreateTableOptions;
+import org.apache.kudu.client.Insert;
+import org.apache.kudu.client.KuduClient;
+import org.apache.kudu.client.KuduException;
+import org.apache.kudu.client.KuduScanner;
+import org.apache.kudu.client.KuduTable;
+import org.apache.kudu.client.PartialRow;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * The Kudu producer.
+ *
+ * @see org.apache.camel.component.kudu.KuduEndpoint
+ */
+public class KuduProducer extends DefaultProducer {
+
+    private static final Logger LOG = LoggerFactory.getLogger(KuduProducer.class);
+
+    private final KuduEndpoint endpoint;
+
+    public KuduProducer(KuduEndpoint endpoint) {
+        super(endpoint);
+
+        if (ObjectHelper.isEmpty(endpoint.getKuduClient())) {
+            throw new IllegalArgumentException(""Can't create a producer when the database connection is null"");
+        }
+        this.endpoint = endpoint;
+    }
+
+    @Override
+    public void process(Exchange exchange) throws Exception {
+        String table = endpoint.getTableName();
+        switch (endpoint.getOperation()) {
+        case INSERT:
+            doInsert(exchange, table);
+            break;
+        case CREATE_TABLE:
+            doCreateTable(exchange, table);
+            break;
+        case SCAN:
+            doScan(exchange, table);
+            break;
+        default:
+            throw new IllegalArgumentException(""The operation "" + endpoint.getOperation() + "" is not supported"");
+        }
+    }
+
+    private void doInsert(Exchange exchange, String tableName) throws KuduException {
+        KuduClient connection = endpoint.getKuduClient();
+        KuduTable table = connection.openTable(tableName);
+
+        Insert insert = table.newInsert();
+        PartialRow row = insert.getRow();
+
+        Map<?, ?> rows = exchange.getIn().getBody(Map.class);
+
+        for (Map.Entry<?, ?> entry : rows.entrySet()) {
+            String key = (String) entry.getKey();
+            Object value = entry.getValue();
+            switch (value.getClass().toString()) {
+            case ""class java.lang.String"":","[{'comment': ""Isn't a better way to express this, it's really ugly :-("", 'commenter': 'oscerd'}, {'comment': 'I thought the same when I saw it :) Will look for something better. It looks like a list of if-elses with instanceof is an antipattern.', 'commenter': 'Delawen'}]"
3272,components/camel-kudu/src/main/resources/org/apache/camel/catalog/components/kudu.json,"@@ -0,0 +1,104 @@
+{","[{'comment': 'This is not useful for camel and it can be removed. Please have a look at the other component structure.', 'commenter': 'oscerd'}]"
3272,components/camel-kudu/src/main/java/org/apache/camel/component/kudu/KuduEndpoint.java,"@@ -0,0 +1,174 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.kudu;
+
+import org.apache.camel.Consumer;
+import org.apache.camel.Processor;
+import org.apache.camel.Producer;
+import org.apache.camel.impl.DefaultEndpoint;
+import org.apache.camel.spi.Metadata;
+import org.apache.camel.spi.UriEndpoint;
+import org.apache.camel.spi.UriParam;
+import org.apache.camel.spi.UriPath;
+import org.apache.kudu.client.KuduClient;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * Represents a Kudu endpoint. A kudu endpoint allows you to interact with
+ * <a href=""https://kudu.apache.org/"">Apache Kudu</a>, a free and open source
+ * column-oriented data store of the Apache Hadoop ecosystem.
+ */
+@UriEndpoint(firstVersion = ""2.25.0"",
+    scheme = ""kudu"",
+    title = ""Apache Kudu"", syntax = ""kudu:type"",
+    consumerClass = KuduConsumer.class,
+    label = ""database,iot"")
+public class KuduEndpoint extends DefaultEndpoint {","[{'comment': '@Delawen may be rethink about enpoint syntax from separate URI parameters (host and port) to the syntax like in thrift or similar components, i.e. thrift:host:port/service.\r\nfor this component it would like kudu:host:port/type that much more cloud ready for services and routes.\r\nAlso KuduClientBuilder is using this syntax.', 'commenter': 'dmvolod'}, {'comment': 'Makes sense. Thanks!', 'commenter': 'Delawen'}]"
3272,components/camel-kudu/pom.xml,"@@ -0,0 +1,98 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one or more
+    contributor license agreements.  See the NOTICE file distributed with
+    this work for additional information regarding copyright ownership.
+    The ASF licenses this file to You under the Apache License, Version 2.0
+    (the ""License""); you may not use this file except in compliance with
+    the License.  You may obtain a copy of the License at
+
+         http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an ""AS IS"" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+
+-->
+<project xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
+         xmlns=""http://maven.apache.org/POM/4.0.0""
+         xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+    <modelVersion>4.0.0</modelVersion>
+
+    <parent>
+        <groupId>org.apache.camel</groupId>
+        <artifactId>components</artifactId>
+        <version>2.25.0-SNAPSHOT</version>
+    </parent>
+
+    <artifactId>camel-kudu</artifactId>
+    <packaging>jar</packaging>
+    <name>Camel :: Kudu</name>
+
+    <properties>
+        <camel.osgi.export.pkg>org.apache.camel.component.kudu.*</camel.osgi.export.pkg>
+        <camel.osgi.export.service>org.apache.camel.spi.ComponentResolver;
+            component=kudu</camel.osgi.export.service>
+    </properties>
+
+    <dependencies>
+        <dependency>
+            <groupId>org.apache.camel</groupId>
+            <artifactId>camel-core</artifactId>
+        </dependency>
+
+        <!-- KUDU dependencies -->
+        <dependency>
+            <groupId>org.apache.kudu</groupId>
+            <artifactId>kudu-client</artifactId>
+            <version>${kuduVersion}</version>","[{'comment': 'It would be nice to change to the common format for all components, i.e. kudu-version', 'commenter': 'dmvolod'}, {'comment': ""That's already done. I'm going to close this PR and focus on the 3.x branch :)"", 'commenter': 'Delawen'}]"
3272,components/camel-kudu/src/main/java/org/apache/camel/component/kudu/KuduProducer.java,"@@ -0,0 +1,114 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.kudu;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+import org.apache.camel.Exchange;
+import org.apache.camel.impl.DefaultProducer;
+import org.apache.kudu.ColumnSchema;
+import org.apache.kudu.Schema;
+import org.apache.kudu.client.CreateTableOptions;
+import org.apache.kudu.client.Insert;
+import org.apache.kudu.client.KuduClient;
+import org.apache.kudu.client.KuduException;
+import org.apache.kudu.client.KuduScanner;
+import org.apache.kudu.client.KuduTable;
+import org.apache.kudu.client.PartialRow;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * The Kudu producer.
+ *
+ * @see org.apache.camel.component.kudu.KuduEndpoint
+ */
+public class KuduProducer extends DefaultProducer {
+
+    private static final Logger LOG = LoggerFactory.getLogger(KuduProducer.class);
+
+    private final KuduEndpoint endpoint;
+
+    public KuduProducer(KuduEndpoint endpoint) {
+        super(endpoint);
+
+        if (endpoint == null || endpoint.getKuduClient() == null) {
+            throw new IllegalArgumentException(""Can't create a producer when the database connection is null"");
+        }
+        this.endpoint = endpoint;
+    }
+
+    @Override
+    public void process(Exchange exchange) throws Exception {
+        String table = endpoint.getTableName();
+        switch (endpoint.getOperation()) {
+        case INSERT:
+            doInsert(exchange, table);
+            break;
+        case CREATE_TABLE:
+            doCreateTable(exchange, table);
+            break;
+        case SCAN:
+            doScan(exchange, table);
+            break;
+        default:
+            throw new IllegalArgumentException(""The operation "" + endpoint.getOperation() + "" is not supported"");
+        }
+    }
+
+    private void doInsert(Exchange exchange, String tableName) throws KuduException {
+        KuduClient connection = endpoint.getKuduClient();
+        KuduTable table = connection.openTable(tableName);
+
+        Insert insert = table.newInsert();
+        PartialRow row = insert.getRow();
+
+        Map<?, ?> rows = exchange.getIn().getBody(Map.class);
+        for (Map.Entry<?, ?> entry : rows.entrySet()) {
+            row.addObject(entry.getKey().toString(), entry.getValue());
+        }
+
+        connection.newSession().apply(insert);
+    }
+
+    private void doCreateTable(Exchange exchange, String tableName) throws KuduException {
+        KuduClient connection = endpoint.getKuduClient();
+        LOG.debug(""Creating table {}"", tableName);
+
+        Schema schema = (Schema) exchange.getIn().getHeader(""Schema"");","[{'comment': 'It would be nice to have headers name in Camel style like CamelKuduSchema and store them names in separate constant class/interface. ', 'commenter': 'dmvolod'}, {'comment': 'Thanks!', 'commenter': 'Delawen'}]"
3281,components/camel-box/camel-box-api/src/main/java/org/apache/camel/component/box/api/BoxFilesManager.java,"@@ -162,7 +162,7 @@ public BoxFile uploadFile(String parentFolderId, InputStream content, String fil
             }
             BoxFile boxFile = null;
             boolean uploadNewFile = true;
-            if (check) {
+            if (check != null && check) {","[{'comment': 'ObjectHelper would be better? :-)', 'commenter': 'oscerd'}, {'comment': 'There is toBoolean method, but it return null when parameter is null, hence the validation is redundant', 'commenter': 'claudio4j'}]"
3285,components/camel-hdfs/src/main/java/org/apache/camel/component/hdfs/HdfsConfiguration.java,"@@ -86,6 +86,9 @@
     @UriParam
     private String owner;
 
+    @UriParam(label = ""consumer,experimental"", defaultValue = ""false"")","[{'comment': ""I don't think we use experimental label anywhere in the project, consumer should be enough"", 'commenter': 'oscerd'}, {'comment': ""Removed.\r\nI've used the _experimental_ label because I haven't tested this for all scenarios."", 'commenter': 'marius-cornescu'}]"
3290,components/camel-kudu/pom.xml,"@@ -0,0 +1,115 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one or more
+    contributor license agreements.  See the NOTICE file distributed with
+    this work for additional information regarding copyright ownership.
+    The ASF licenses this file to You under the Apache License, Version 2.0
+    (the ""License""); you may not use this file except in compliance with
+    the License.  You may obtain a copy of the License at
+
+         http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an ""AS IS"" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+
+-->
+<project xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
+         xmlns=""http://maven.apache.org/POM/4.0.0""
+         xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+    <modelVersion>4.0.0</modelVersion>
+
+    <parent>
+        <groupId>org.apache.camel</groupId>
+        <artifactId>components</artifactId>
+        <version>3.0.0-SNAPSHOT</version>
+    </parent>
+
+    <artifactId>camel-kudu</artifactId>
+    <packaging>jar</packaging>
+    <name>Camel :: Kudu</name>
+    <description>Camel Apache Kudu support</description>
+
+
+    <properties>
+        <camel.osgi.export.pkg>org.apache.camel.component.kudu.*</camel.osgi.export.pkg>
+        <camel.osgi.export.service>org.apache.camel.spi.ComponentResolver;
+            component=kudu</camel.osgi.export.service>
+    </properties>
+
+    <dependencies>
+        <dependency>
+            <groupId>org.apache.camel</groupId>
+            <artifactId>camel-support</artifactId>
+        </dependency>
+
+        <!-- KUDU dependencies -->
+        <dependency>
+            <groupId>org.apache.kudu</groupId>
+            <artifactId>kudu-client</artifactId>
+            <version>${kudu-version}</version>
+        </dependency>
+
+        <dependency>
+            <groupId>org.apache.yetus</groupId>
+            <artifactId>audience-annotations</artifactId>
+            <version>${yetus-audience-annotations-version}</version>
+        </dependency>
+
+        <!-- TESTING -->
+        <dependency>
+            <groupId>org.apache.camel</groupId>
+            <artifactId>camel-test</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.apache.logging.log4j</groupId>
+            <artifactId>log4j-api</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.apache.logging.log4j</groupId>
+            <artifactId>log4j-core</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.apache.logging.log4j</groupId>
+            <artifactId>log4j-slf4j-impl</artifactId>
+            <scope>test</scope>
+        </dependency>
+
+        <!-- Spin a kudu cluster to run integration tests -->
+        <!-- as described in
+        https://kudu.apache.org/docs/developing.html#_using_the_kudu_binary_test_jar -->
+        <dependency>
+            <groupId>org.apache.kudu</groupId>
+            <artifactId>kudu-test-utils</artifactId>
+            <version>${kudu-version}</version>
+            <scope>test</scope>
+        </dependency>
+
+        <dependency>
+            <groupId>org.apache.kudu</groupId>
+            <artifactId>kudu-binary</artifactId>
+            <version>${kudu-version}</version>
+            <!--suppress UnresolvedMavenProperty -->
+            <classifier>${os.detected.classifier}</classifier>
+            <scope>test</scope>
+        </dependency>
+    </dependencies>
+
+    <build>
+        <extensions>
+            <!-- Used to find the right kudu-binary artifact with the Maven
+                 property ${os.detected.classifier} -->
+            <extension>
+                <groupId>kr.motd.maven</groupId>
+                <artifactId>os-maven-plugin</artifactId>
+                <version>1.6.2</version>","[{'comment': 'Please use os-maven-plugin-version from parent/pom.xml', 'commenter': 'dmvolod'}]"
3290,components/camel-kudu/src/main/docs/kudu-component.adoc,"@@ -0,0 +1,91 @@
+[[kudu-component]]
+= Apache Kudu Component
+
+*Since Camel 2.25*","[{'comment': ""Looks like shoud be 3.0 as we didn't implement it for 2.25.0."", 'commenter': 'dmvolod'}, {'comment': '@oscerd do we decide to have this component for 2.25.0 or only 3.0.0?', 'commenter': 'dmvolod'}, {'comment': '3.0.0 for the moment', 'commenter': 'oscerd'}]"
3290,components/camel-kudu/src/main/java/org/apache/camel/component/kudu/KuduProducer.java,"@@ -0,0 +1,114 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.kudu;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+import org.apache.camel.Exchange;
+import org.apache.camel.support.DefaultProducer;
+import org.apache.kudu.ColumnSchema;
+import org.apache.kudu.Schema;
+import org.apache.kudu.client.CreateTableOptions;
+import org.apache.kudu.client.Insert;
+import org.apache.kudu.client.KuduClient;
+import org.apache.kudu.client.KuduException;
+import org.apache.kudu.client.KuduScanner;
+import org.apache.kudu.client.KuduTable;
+import org.apache.kudu.client.PartialRow;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * The Kudu producer.
+ *
+ * @see org.apache.camel.component.kudu.KuduEndpoint
+ */
+public class KuduProducer extends DefaultProducer {
+
+    private static final Logger LOG = LoggerFactory.getLogger(KuduProducer.class);
+
+    private final KuduEndpoint endpoint;
+
+    public KuduProducer(KuduEndpoint endpoint) {
+        super(endpoint);
+
+        if (endpoint == null || endpoint.getKuduClient() == null) {
+            throw new IllegalArgumentException(""Can't create a producer when the database connection is null"");
+        }
+        this.endpoint = endpoint;
+    }
+
+    @Override
+    public void process(Exchange exchange) throws Exception {
+        String table = endpoint.getTableName();
+        switch (endpoint.getOperation()) {
+        case INSERT:
+            doInsert(exchange, table);
+            break;
+        case CREATE_TABLE:
+            doCreateTable(exchange, table);
+            break;
+        case SCAN:
+            doScan(exchange, table);
+            break;
+        default:
+            throw new IllegalArgumentException(""The operation "" + endpoint.getOperation() + "" is not supported"");
+        }
+    }
+
+    private void doInsert(Exchange exchange, String tableName) throws KuduException {
+        KuduClient connection = endpoint.getKuduClient();
+        KuduTable table = connection.openTable(tableName);
+
+        Insert insert = table.newInsert();
+        PartialRow row = insert.getRow();
+
+        Map<?, ?> rows = exchange.getIn().getBody(Map.class);
+        for (Map.Entry<?, ?> entry : rows.entrySet()) {
+            row.addObject(entry.getKey().toString(), entry.getValue());
+        }
+
+        connection.newSession().apply(insert);
+    }
+
+    private void doCreateTable(Exchange exchange, String tableName) throws KuduException {
+        KuduClient connection = endpoint.getKuduClient();
+        LOG.debug(""Creating table {}"", tableName);
+
+        Schema schema = (Schema) exchange.getIn().getHeader(""Schema"");
+        CreateTableOptions builder = (CreateTableOptions) exchange.getIn().getHeader(""TableOptions"");
+        connection.createTable(tableName, schema, builder);
+    }
+
+    private void doScan(Exchange exchange, String tableName) throws KuduException {","[{'comment': 'Is it required to have doScan(...) both for producer and consumer? ', 'commenter': 'dmvolod'}, {'comment': 'Good question... probably not.', 'commenter': 'Delawen'}]"
3290,components/camel-kudu/src/main/java/org/apache/camel/component/kudu/KuduProducer.java,"@@ -0,0 +1,114 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.kudu;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+import org.apache.camel.Exchange;
+import org.apache.camel.support.DefaultProducer;
+import org.apache.kudu.ColumnSchema;
+import org.apache.kudu.Schema;
+import org.apache.kudu.client.CreateTableOptions;
+import org.apache.kudu.client.Insert;
+import org.apache.kudu.client.KuduClient;
+import org.apache.kudu.client.KuduException;
+import org.apache.kudu.client.KuduScanner;
+import org.apache.kudu.client.KuduTable;
+import org.apache.kudu.client.PartialRow;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * The Kudu producer.
+ *
+ * @see org.apache.camel.component.kudu.KuduEndpoint
+ */
+public class KuduProducer extends DefaultProducer {
+
+    private static final Logger LOG = LoggerFactory.getLogger(KuduProducer.class);
+
+    private final KuduEndpoint endpoint;
+
+    public KuduProducer(KuduEndpoint endpoint) {
+        super(endpoint);
+
+        if (endpoint == null || endpoint.getKuduClient() == null) {
+            throw new IllegalArgumentException(""Can't create a producer when the database connection is null"");
+        }
+        this.endpoint = endpoint;
+    }
+
+    @Override
+    public void process(Exchange exchange) throws Exception {
+        String table = endpoint.getTableName();
+        switch (endpoint.getOperation()) {
+        case INSERT:
+            doInsert(exchange, table);
+            break;
+        case CREATE_TABLE:
+            doCreateTable(exchange, table);
+            break;
+        case SCAN:
+            doScan(exchange, table);
+            break;
+        default:
+            throw new IllegalArgumentException(""The operation "" + endpoint.getOperation() + "" is not supported"");
+        }
+    }
+
+    private void doInsert(Exchange exchange, String tableName) throws KuduException {
+        KuduClient connection = endpoint.getKuduClient();
+        KuduTable table = connection.openTable(tableName);
+
+        Insert insert = table.newInsert();
+        PartialRow row = insert.getRow();
+
+        Map<?, ?> rows = exchange.getIn().getBody(Map.class);","[{'comment': 'I guess is a must we have the body as a `Map`? Maybe we can put this as a comment in the docs?', 'commenter': 'omarsmak'}]"
3290,components/camel-kudu/src/main/java/org/apache/camel/component/kudu/KuduConsumer.java,"@@ -0,0 +1,81 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.kudu;
+
+import java.util.ArrayList;
+import java.util.List;
+import org.apache.camel.Exchange;
+import org.apache.camel.Processor;
+import org.apache.camel.support.ScheduledPollConsumer;
+import org.apache.kudu.ColumnSchema;
+import org.apache.kudu.client.KuduClient;
+import org.apache.kudu.client.KuduException;
+import org.apache.kudu.client.KuduScanner;
+import org.apache.kudu.client.KuduTable;
+
+/**
+ * The Kudu consumer.
+ *
+ * @see org.apache.camel.support.ScheduledPollConsumer
+ * @see org.apache.camel.component.kudu.KuduEndpoint
+ */
+public class KuduConsumer extends ScheduledPollConsumer {
+    private final KuduEndpoint endpoint;
+
+    public KuduConsumer(KuduEndpoint endpoint, Processor processor) {
+        super(endpoint, processor);
+        this.endpoint = endpoint;
+    }
+
+    @Override
+    protected int poll() throws Exception {
+        Exchange exchange = endpoint.createExchange();
+
+        // create a message body
+        KuduScanner scanner = doScan(endpoint.getTableName());
+
+        exchange.getIn().setBody(scanner);","[{'comment': 'IMHO is a bit weird to put the scanner directly in the message body (unless you have a different intention), hence do you think would it make sense to put `Iterator<RowResult>` as message body instead? Also, IMHO, I think it would be nice to include a type converter to `Map` as well (if possible of course). ', 'commenter': 'omarsmak'}, {'comment': 'My first component and taking code from others, I am doing some things a bit blindly here :)\r\n\r\nYou are right, a good converter and conversion never hurts.', 'commenter': 'Delawen'}, {'comment': ""No problems, I understand, it could a bit confusing at the beginning :). But, please don't hesitate to let us know if you need help or explaining anything, mailing list and gitter the best places ;) "", 'commenter': 'omarsmak'}]"
3290,components/camel-kudu/src/main/java/org/apache/camel/component/kudu/KuduProducer.java,"@@ -0,0 +1,114 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.kudu;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+import org.apache.camel.Exchange;
+import org.apache.camel.support.DefaultProducer;
+import org.apache.kudu.ColumnSchema;
+import org.apache.kudu.Schema;
+import org.apache.kudu.client.CreateTableOptions;
+import org.apache.kudu.client.Insert;
+import org.apache.kudu.client.KuduClient;
+import org.apache.kudu.client.KuduException;
+import org.apache.kudu.client.KuduScanner;
+import org.apache.kudu.client.KuduTable;
+import org.apache.kudu.client.PartialRow;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * The Kudu producer.
+ *
+ * @see org.apache.camel.component.kudu.KuduEndpoint
+ */
+public class KuduProducer extends DefaultProducer {
+
+    private static final Logger LOG = LoggerFactory.getLogger(KuduProducer.class);
+
+    private final KuduEndpoint endpoint;
+
+    public KuduProducer(KuduEndpoint endpoint) {
+        super(endpoint);
+
+        if (endpoint == null || endpoint.getKuduClient() == null) {
+            throw new IllegalArgumentException(""Can't create a producer when the database connection is null"");
+        }
+        this.endpoint = endpoint;
+    }
+
+    @Override
+    public void process(Exchange exchange) throws Exception {
+        String table = endpoint.getTableName();
+        switch (endpoint.getOperation()) {
+        case INSERT:
+            doInsert(exchange, table);
+            break;
+        case CREATE_TABLE:
+            doCreateTable(exchange, table);
+            break;
+        case SCAN:
+            doScan(exchange, table);
+            break;
+        default:
+            throw new IllegalArgumentException(""The operation "" + endpoint.getOperation() + "" is not supported"");
+        }
+    }
+
+    private void doInsert(Exchange exchange, String tableName) throws KuduException {
+        KuduClient connection = endpoint.getKuduClient();
+        KuduTable table = connection.openTable(tableName);
+
+        Insert insert = table.newInsert();
+        PartialRow row = insert.getRow();
+
+        Map<?, ?> rows = exchange.getIn().getBody(Map.class);
+        for (Map.Entry<?, ?> entry : rows.entrySet()) {
+            row.addObject(entry.getKey().toString(), entry.getValue());
+        }
+
+        connection.newSession().apply(insert);
+    }
+
+    private void doCreateTable(Exchange exchange, String tableName) throws KuduException {
+        KuduClient connection = endpoint.getKuduClient();
+        LOG.debug(""Creating table {}"", tableName);
+
+        Schema schema = (Schema) exchange.getIn().getHeader(""Schema"");","[{'comment': ""Here we are expecting a header `Schema`, however I couldn't find some information how do we set it up, do we expect the user to add it? "", 'commenter': 'omarsmak'}, {'comment': 'Would it be better to ask for simple text headers that build the schema?', 'commenter': 'Delawen'}, {'comment': ""What I meant just to indicate in the docs that in order to use Kudu producer to create a table, a schema should be set in the headers, for example [camel-kafka](https://github.com/apache/camel/blob/master/components/camel-kafka/src/main/docs/kafka-component.adoc#producer-headers) and [camel-kniesis](https://github.com/apache/camel/blob/master/components/camel-aws-kinesis/src/main/docs/aws-kinesis-component.adoc#message-headers-used-by-the-kinesis-producer-to-write-to-kinesis--the-producer-expects-that-the-message-body-is-a-byte) docs, so the user can be aware of it. Which format would be better, I honestly have no much of details into kudu, hence I can't tell which is better. What I can recommend is, you can try to create a simple example for a camel route with kudu and see how the user can use it, at least you will get a feeling what can be more convenient for the user."", 'commenter': 'omarsmak'}, {'comment': 'I agree with @omarsmak , you can choose any header name style which is not intersect with another components to avoid conflicts and will be clear to understand for you and other component users. CamelKuduSchema is also suitable or you can define this name yourself.', 'commenter': 'dmvolod'}]"
3290,components/camel-kudu/src/main/java/org/apache/camel/component/kudu/KuduEndpoint.java,"@@ -0,0 +1,174 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.kudu;
+
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+import org.apache.camel.Consumer;
+import org.apache.camel.Processor;
+import org.apache.camel.Producer;
+import org.apache.camel.spi.Metadata;
+import org.apache.camel.spi.UriEndpoint;
+import org.apache.camel.spi.UriParam;
+import org.apache.camel.spi.UriPath;
+import org.apache.camel.support.DefaultEndpoint;
+import org.apache.kudu.client.KuduClient;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * Represents a Kudu endpoint. A kudu endpoint allows you to interact with
+ * <a href=""https://kudu.apache.org/"">Apache Kudu</a>, a free and open source
+ * column-oriented data store of the Apache Hadoop ecosystem.
+ */
+@UriEndpoint(firstVersion = ""2.25.0"",
+    scheme = ""kudu"",
+    title = ""Apache Kudu"", syntax = ""kudu:host:port/tableName"",
+    label = ""cloud,database,iot"")
+public class KuduEndpoint extends DefaultEndpoint {
+
+    private static final Logger LOG = LoggerFactory.getLogger(KuduEndpoint.class);
+    private KuduClient kuduClient;
+
+    @Metadata(required = true, description = ""Host of the server to connect to"")
+    private String host;
+
+    @UriPath(description = ""Connection string to Kudu"")
+    private String uri;
+
+    @Metadata(required = true)
+    private String port;
+
+    @UriParam(description = ""Operation to perform"")
+    private KuduOperations operation;
+
+    @Metadata(description = ""Table to connect to"")
+    private String tableName;
+
+    public KuduEndpoint(String uri, KuduComponent component) {
+        super(uri, component);
+        this.setUri(uri);
+        this.setEndpointUri(uri);
+        Pattern p = Pattern.compile(""^(\\S+)\\:(\\d+)\\/(\\S+)$"");","[{'comment': ""I can see you are parsing the URI manually, I think is better to delegate that to Camel in order to do it for you. In `KuduComponent`, under `createEndpoint` method , you will notice `Map<String, Object> parameters`, that already parsed by Camel and when you do `setProperties` in `KuduComponent`, actually Camel will set all the properties for you, plus it will generate the correct docs for you for these properties. However you might need to adjust your endpoint structure e.g: `kudo:operation?port=&host=&tableName=` or whatever struture you like as long you have one UriPath, as well as adding the correct annotations e.g: `UriParam` and `UriPath`, I'd advise you to take a look at [SolrEndpoint](https://github.com/apache/camel/blob/master/components/camel-solr/src/main/java/org/apache/camel/component/solr/SolrEndpoint.java#L43) and [FileWatch](https://github.com/apache/camel/blob/master/components/camel-file-watch/src/main/java/org/apache/camel/component/file/watch/FileWatchEndpoint.java#L41) as they have very similar structure to your component  "", 'commenter': 'omarsmak'}, {'comment': 'Isn\'t it more ""human understandable"" to use the uri part for the host, port and table? I was checking componentes like:\r\nhttps://camel.apache.org/components/latest/couchdb-component.html#_uri_format\r\nhttps://camel.apache.org/components/latest/pg-replication-slot-component.html\r\n\r\nThat are databases that uses the `host:port/schema?option` form. As someone who just landed on camel, to me it makes sense to have a classic url form. But if you tell me the ""standard"" in camel is on parameters, I change it.', 'commenter': 'Delawen'}, {'comment': 'Aha I see, then you can have what you think what it makes sense, as long you can delgate the params parsing to Camel and just parse the path type manually like here: https://github.com/apache/camel/blob/master/components/camel-couchdb/src/main/java/org/apache/camel/component/couchdb/CouchDbEndpoint.java#L45', 'commenter': 'omarsmak'}, {'comment': '@Delawen Sorry I missed that, actually what you have now is perfectly fine from view. Just add `@UriPath` annotations on `host`, `port` and `tableName` so Camel can generate the correct metadata for the docs', 'commenter': 'omarsmak'}]"
3290,components/camel-kudu/src/main/java/org/apache/camel/component/kudu/KuduEndpoint.java,"@@ -0,0 +1,174 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.kudu;
+
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+import org.apache.camel.Consumer;
+import org.apache.camel.Processor;
+import org.apache.camel.Producer;
+import org.apache.camel.spi.Metadata;
+import org.apache.camel.spi.UriEndpoint;
+import org.apache.camel.spi.UriParam;
+import org.apache.camel.spi.UriPath;
+import org.apache.camel.support.DefaultEndpoint;
+import org.apache.kudu.client.KuduClient;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * Represents a Kudu endpoint. A kudu endpoint allows you to interact with
+ * <a href=""https://kudu.apache.org/"">Apache Kudu</a>, a free and open source
+ * column-oriented data store of the Apache Hadoop ecosystem.
+ */
+@UriEndpoint(firstVersion = ""2.25.0"",
+    scheme = ""kudu"",
+    title = ""Apache Kudu"", syntax = ""kudu:host:port/tableName"",
+    label = ""cloud,database,iot"")","[{'comment': 'Since your component is only a producer, then you can add this to the annotation UriEndpoint in order to generate the correct metadata \r\n```suggestion\r\n    label = ""cloud,database,iot"", producerOnly = true)\r\n```', 'commenter': 'omarsmak'}]"
3290,components/camel-kudu/src/main/java/org/apache/camel/component/kudu/KuduProducer.java,"@@ -0,0 +1,112 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.kudu;
+
+import java.util.Map;
+import org.apache.camel.Exchange;
+import org.apache.camel.support.DefaultProducer;
+import org.apache.kudu.Schema;
+import org.apache.kudu.client.CreateTableOptions;
+import org.apache.kudu.client.Insert;
+import org.apache.kudu.client.KuduClient;
+import org.apache.kudu.client.KuduException;
+import org.apache.kudu.client.KuduTable;
+import org.apache.kudu.client.PartialRow;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * The Kudu producer.
+ *
+ * @see org.apache.camel.component.kudu.KuduEndpoint
+ */
+public class KuduProducer extends DefaultProducer {
+
+    private static final Logger LOG = LoggerFactory.getLogger(KuduProducer.class);
+
+    private final KuduEndpoint endpoint;
+
+    public KuduProducer(KuduEndpoint endpoint) {
+        super(endpoint);
+
+        if (endpoint == null || endpoint.getKuduClient() == null) {
+            throw new IllegalArgumentException(""Can't create a producer when the database connection is null"");
+        }
+        this.endpoint = endpoint;
+    }
+
+    @Override
+    public void process(Exchange exchange) throws Exception {
+        String table = endpoint.getTableName();
+        switch (endpoint.getOperation()) {
+        case INSERT:
+            doInsert(exchange, table);
+            break;
+        case CREATE_TABLE:
+            doCreateTable(exchange, table);
+            break;
+        case SCAN:
+            doScan(exchange, table);
+            break;
+        default:
+            throw new IllegalArgumentException(""The operation "" + endpoint.getOperation() + "" is not supported"");
+        }
+    }
+
+    private void doInsert(Exchange exchange, String tableName) throws KuduException {
+        LOG.trace(""Insert on table {}"", tableName);
+        KuduClient connection = endpoint.getKuduClient();
+        KuduTable table = connection.openTable(tableName);
+
+
+        Insert insert = table.newInsert();
+        PartialRow row = insert.getRow();
+
+        Map<?, ?> rows = exchange.getIn().getBody(Map.class);
+        for (Map.Entry<?, ?> entry : rows.entrySet()) {
+            final String colName = entry.getKey().toString();
+            final Object value = entry.getValue();
+            //Add only if column exist
+            //If not, this will throw an IllegalArgumentException
+            if (table.getSchema().getColumn(colName) != null) {
+                row.addObject(colName, value);
+            }
+        }
+
+        connection.newSession().apply(insert);
+    }
+
+    private void doCreateTable(Exchange exchange, String tableName) throws KuduException {
+        LOG.trace(""Creating table {}"", tableName);
+        KuduClient connection = endpoint.getKuduClient();
+
+        try {
+            Schema schema = (Schema) exchange.getIn().getHeader(KuduConstants.CAMEL_KUDU_SCHEMA);
+            CreateTableOptions builder = (CreateTableOptions)
+                                             exchange.getIn()
+                                                 .getHeader(KuduConstants.CAMEL_KUDU_TABLE_OPTIONS);
+            connection.createTable(tableName, schema, builder);
+        } catch (Throwable t) {","[{'comment': ""Since you are added checked exception `KuduException` to the method signature, you don't need to catch and re-throw it again "", 'commenter': 'omarsmak'}, {'comment': ""This was for debugging, shouldn't be here :("", 'commenter': 'Delawen'}]"
3290,components/camel-kudu/src/main/java/org/apache/camel/component/kudu/KuduEndpoint.java,"@@ -0,0 +1,174 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.kudu;
+
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+import org.apache.camel.Consumer;
+import org.apache.camel.Processor;
+import org.apache.camel.Producer;
+import org.apache.camel.spi.Metadata;
+import org.apache.camel.spi.UriEndpoint;
+import org.apache.camel.spi.UriParam;
+import org.apache.camel.spi.UriPath;
+import org.apache.camel.support.DefaultEndpoint;
+import org.apache.kudu.client.KuduClient;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * Represents a Kudu endpoint. A kudu endpoint allows you to interact with
+ * <a href=""https://kudu.apache.org/"">Apache Kudu</a>, a free and open source
+ * column-oriented data store of the Apache Hadoop ecosystem.
+ */
+@UriEndpoint(firstVersion = ""2.25.0"",
+    scheme = ""kudu"",
+    title = ""Apache Kudu"", syntax = ""kudu:host:port/tableName"",
+    label = ""cloud,database,iot"", producerOnly = true)
+public class KuduEndpoint extends DefaultEndpoint {
+
+    private static final Logger LOG = LoggerFactory.getLogger(KuduEndpoint.class);
+    private KuduClient kuduClient;
+
+    @Metadata(required = true, description = ""Host of the server to connect to"")
+    private String host;
+
+    @UriPath(description = ""Connection string to Kudu"")
+    private String uri;
+
+    @Metadata(required = true)
+    private String port;
+
+    @UriParam(description = ""Operation to perform"")
+    private KuduOperations operation;
+
+    @Metadata(description = ""Table to connect to"")
+    private String tableName;
+
+    public KuduEndpoint(String uri, KuduComponent component) {
+        super(uri, component);
+        this.setUri(uri);
+        this.setEndpointUri(uri);","[{'comment': ""You don't need to set `this.setEndpointUri(uri);`, when you call the parent constructor of `DefaultEndpoint`, `EndpointUri` is being set there"", 'commenter': 'omarsmak'}]"
3290,components/camel-kudu/src/main/java/org/apache/camel/component/kudu/KuduEndpoint.java,"@@ -0,0 +1,174 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.kudu;
+
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+import org.apache.camel.Consumer;
+import org.apache.camel.Processor;
+import org.apache.camel.Producer;
+import org.apache.camel.spi.Metadata;
+import org.apache.camel.spi.UriEndpoint;
+import org.apache.camel.spi.UriParam;
+import org.apache.camel.spi.UriPath;
+import org.apache.camel.support.DefaultEndpoint;
+import org.apache.kudu.client.KuduClient;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * Represents a Kudu endpoint. A kudu endpoint allows you to interact with
+ * <a href=""https://kudu.apache.org/"">Apache Kudu</a>, a free and open source
+ * column-oriented data store of the Apache Hadoop ecosystem.
+ */
+@UriEndpoint(firstVersion = ""2.25.0"",
+    scheme = ""kudu"",
+    title = ""Apache Kudu"", syntax = ""kudu:host:port/tableName"",
+    label = ""cloud,database,iot"", producerOnly = true)
+public class KuduEndpoint extends DefaultEndpoint {
+
+    private static final Logger LOG = LoggerFactory.getLogger(KuduEndpoint.class);
+    private KuduClient kuduClient;
+
+    @Metadata(required = true, description = ""Host of the server to connect to"")
+    private String host;
+
+    @UriPath(description = ""Connection string to Kudu"")
+    private String uri;
+
+    @Metadata(required = true)
+    private String port;
+
+    @UriParam(description = ""Operation to perform"")
+    private KuduOperations operation;
+
+    @Metadata(description = ""Table to connect to"")
+    private String tableName;
+
+    public KuduEndpoint(String uri, KuduComponent component) {
+        super(uri, component);
+        this.setUri(uri);","[{'comment': 'Also do we need `setUri(uri);` here? You have endpointUri that being set in the parent constructor which is available for you via `getEndpointUri()`', 'commenter': 'omarsmak'}, {'comment': 'I was just making sure. Going to check and remove.', 'commenter': 'Delawen'}]"
3302,core/camel-main/src/main/java/org/apache/camel/main/MainConfigurationProperties.java,"@@ -27,6 +27,7 @@
     private boolean autoConfigurationLogSummary = true;
     private boolean autowireComponentProperties = true;
     private boolean autowireComponentPropertiesDeep;
+    private boolean autowireNonNullOnlyComponentProperties;","[{'comment': 'Can this be named like the others `autowireComponentPropertiesNonNullOnly`', 'commenter': 'davsclaus'}]"
3302,core/camel-main/src/test/resources/log4j2.properties,"@@ -29,7 +29,7 @@ appender.file.layout.pattern = %d [%-15.15t] %-5p %-30.30c{1} - %m%n
 rootLogger.level = INFO
 
 rootLogger.appenderRef.file.ref = file
-#rootLogger.appenderRef.console.ref = console
+rootLogger.appenderRef.console.ref = console","[{'comment': 'Remove', 'commenter': 'davsclaus'}]"
3302,core/camel-main/pom.xml,"@@ -102,6 +102,11 @@
             <artifactId>junit</artifactId>
             <scope>test</scope>
         </dependency>
+        <dependency>","[{'comment': 'Are you using this at all?', 'commenter': 'davsclaus'}, {'comment': ""yep I'm using it but I can replace it "", 'commenter': 'lburgazzoli'}, {'comment': 'Okay since its not already widespread in use, lets try to keep the number of different JARs and ways to test to the same level', 'commenter': 'davsclaus'}, {'comment': 'done', 'commenter': 'lburgazzoli'}]"
3315,components/camel-jetty-common/src/main/java/org/apache/camel/component/jetty/JettyHttpComponent.java,"@@ -1319,6 +1329,8 @@ protected Server createServer() {
                 qtp.setMaxThreads(maxThreads.intValue());
             }
             tp = qtp;
+            _queuedThreadPool=qtp;","[{'comment': ""it is a little bit confusing, shouldn't we use `_queuedThreadPool` instead of `qtp` directly from the beginning of `protected Server createServer()` method?"", 'commenter': 'valdar'}, {'comment': 'done', 'commenter': 'luigidemasi'}]"
3315,components/camel-jetty-common/src/main/java/org/apache/camel/component/jetty/JettyHttpComponent.java,"@@ -134,6 +134,7 @@
     protected boolean useXForwardedForHeader;
     private Integer proxyPort;
     private boolean sendServerVersion = true;
+    private QueuedThreadPool _queuedThreadPool;","[{'comment': 'Can we use the same approach for variable name? just queuedThreadPool instead of _queuedThreadpool? Thanks.', 'commenter': 'oscerd'}, {'comment': 'done', 'commenter': 'luigidemasi'}]"
3317,components/camel-debezium-sqlserver/src/test/java/org/apache/camel/component/debezium/configuration/SqlserverConnectorEmbeddedDebeziumConfigurationTest.java,"@@ -0,0 +1,88 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.debezium.configuration;
+
+import io.debezium.config.CommonConnectorConfig;
+import io.debezium.config.Configuration;
+import io.debezium.connector.sqlserver.SqlServerConnector;
+import io.debezium.embedded.EmbeddedEngine;
+import org.apache.camel.component.debezium.DebeziumConstants;
+import org.junit.Test;
+
+import static org.junit.Assert.*;","[{'comment': 'Please avoid * imports', 'commenter': 'oscerd'}, {'comment': 'Thanks for spotting this, willl change it now ', 'commenter': 'omarsmak'}]"
3325,components/camel-exec/src/main/java/org/apache/camel/component/exec/ExecCommandLogLevelType.java,"@@ -0,0 +1,24 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.exec;
+
+/**
+ * Enumeration of log levels for logging execution of commands.
+ */
+public enum ExecCommandLogLevelType {","[{'comment': 'There is already `LoggingLevel` from camel-api, use that', 'commenter': 'davsclaus'}]"
3325,components/camel-exec/src/main/java/org/apache/camel/component/exec/ExecProducer.java,"@@ -50,11 +51,30 @@ public void process(Exchange exchange) throws Exception {
             executor = new DefaultExecCommandExecutor();
         }
 
-        log.info(""Executing {}"", execCommand);
+        Consumer<String> logMethod;","[{'comment': 'Use `CamelLogger` from camel-api', 'commenter': 'davsclaus'}]"
3325,components/camel-exec/src/main/java/org/apache/camel/component/exec/ExecEndpoint.java,"@@ -55,6 +56,8 @@
     private ExecBinding binding;
     @UriParam
     private boolean useStderrOnEmptyStdout;
+    @UriParam","[{'comment': 'Add (default = ""xxx"") so we have that in the metadata', 'commenter': 'davsclaus'}, {'comment': ""Thanks for showing it to me, I'll fix both cases"", 'commenter': 'JiriOndrusek'}]"
3325,components/camel-exec/src/main/java/org/apache/camel/component/exec/ExecProducer.java,"@@ -50,11 +52,14 @@ public void process(Exchange exchange) throws Exception {
             executor = new DefaultExecCommandExecutor();
         }
 
-        log.info(""Executing {}"", execCommand);
+        CamelLogger logger = new CamelLogger(log, execCommand.getCommandLogLevel());","[{'comment': 'You can likely create this instance once, in the doStart and reuse it', 'commenter': 'davsclaus'}]"
3354,components/camel-hdfs/src/main/java/org/apache/camel/component/hdfs/HdfsConsumer.java,"@@ -220,4 +233,19 @@ private HdfsInputStream createInputStream(FileStatus fileStatus) {
         }
     }
 
+    protected void updateNewExchange(Exchange exchange, int index, HdfsInputStream hdfsFile) {
+        // do not share unit of work
+        exchange.setUnitOfWork(null);","[{'comment': 'This is dangerous, lets revisit why you do this. Maybe what you want to do is to create a correlated copy of the exchange where you can avoid sharing the unit of work, as it has its own uow. See ExchangeHelper and try to git grep the source code and find other components that does this', 'commenter': 'davsclaus'}, {'comment': ""I ported this over from the **Splitter** class, **updateNewExchange(...)** , not saying that it's right.\r\nWill look into other options."", 'commenter': 'marius-cornescu'}, {'comment': 'Ah the splitter should have created a correlated copy with that helper class, so its a copy of the original exchange, then setting it as null is okay.', 'commenter': 'davsclaus'}]"
3354,components/camel-hdfs/src/test/java/org/apache/camel/component/hdfs/HdfsInputStreamTest.java,"@@ -114,4 +123,138 @@ public void createInputStreamForMissingNormalFile() throws IOException {
         verify(fileSystem, times(1)).rename(any(Path.class), any(Path.class));
     }
 
+    @Test
+    @Ignore","[{'comment': 'Is this (i.e. adding ignored tests) intended?', 'commenter': 'valdar'}]"
3354,components/camel-hdfs/src/main/java/org/apache/camel/component/hdfs/DefaultHdfsFile.java,"@@ -63,11 +64,8 @@ protected final long copyBytes(InputStream in, OutputStream out, int buffSize, b
     }
 
     protected final Writable getWritable(Object obj, Exchange exchange, Holder<Integer> size) {
-        Class<?> objCls = obj == null ? null : obj.getClass();
-        HdfsWritableFactories.HdfsWritableFactory objWritableFactory = WritableCache.writables.get(objCls);
-        if (objWritableFactory == null) {
-            objWritableFactory = new HdfsWritableFactories.HdfsObjectWritableFactory();
-        }
+        Class<?> objCls = Optional.ofNullable(obj).orElse(new UnknownType()).getClass();","[{'comment': 'As far as I understood, you want to use some sort of empty class instead of null, do you think is better to use [`Void`](https://docs.oracle.com/javase/8/docs/api/java/lang/Void.html) class instead of defining your own? ', 'commenter': 'omarsmak'}, {'comment': 'I created a new class because:\r\n\r\n1. I thought that using Void would re-purpose another class.\r\n2. UnknownType is the ""_correct_""/label for that type.\r\n3. Creating a new class is almost costless.\r\n\r\nWould change it if there precedent of using Void for unknown map item in other components, to preserve consistency.', 'commenter': 'marius-cornescu'}, {'comment': 'Sure, I think it should be fine', 'commenter': 'omarsmak'}]"
3354,components/camel-hdfs/src/main/java/org/apache/camel/component/hdfs/HdfsArrayFileTypeHandler.java,"@@ -36,8 +36,14 @@
             HdfsInfo hdfsInfo = hdfsInfoFactory.newHdfsInfo(hdfsPath);
             HdfsConfiguration endpointConfig = hdfsInfoFactory.getEndpointConfig();
             Class<? extends WritableComparable> valueWritableClass = endpointConfig.getValueType().getWritableClass();
-            rout = new ArrayFile.Writer(hdfsInfo.getConfiguration(), hdfsInfo.getFileSystem(), hdfsPath, valueWritableClass,
-                    endpointConfig.getCompressionType(), () -> { });
+            rout = new ArrayFile.Writer(
+                    hdfsInfo.getConfiguration(),
+                    hdfsInfo.getFileSystem(),
+                    hdfsPath,
+                    valueWritableClass,
+                    endpointConfig.getCompressionType(),
+            () -> { }","[{'comment': 'nit: formatting ident here', 'commenter': 'omarsmak'}, {'comment': 'I get a check-style violation when I move the lambda inline with the others.', 'commenter': 'marius-cornescu'}, {'comment': 'That is weird, we can take a look at the checkstyle later', 'commenter': 'omarsmak'}]"
3354,components/camel-hdfs/src/main/java/org/apache/camel/component/hdfs/HdfsConsumer.java,"@@ -127,53 +129,67 @@ public boolean accept(Path path) {
     }
 
     private int processFileStatuses(HdfsInfo info, FileStatus[] fileStatuses) {
-        final AtomicInteger messageCount = new AtomicInteger(0);
+        final AtomicInteger totalMessageCount = new AtomicInteger(0);
 
-        Arrays.stream(fileStatuses)
+        List<HdfsInputStream> hdfsFiles = Arrays.stream(fileStatuses)
                 .filter(status -> normalFileIsDirectoryHasSuccessFile(status, info))
                 .filter(this::hasMatchingOwner)
-                .map(this::createInputStream)
+                .map(this::asHdfsFile)
                 .filter(Objects::nonNull)
-                .forEach(hdfsInputStream -> {
-                    try {
-                        processHdfsInputStream(hdfsInputStream, messageCount, fileStatuses.length);
-                    } finally {
-                        IOHelper.close(hdfsInputStream, ""input stream"", log);
-                    }
-                });
+                .collect(Collectors.toList());
 
-        return messageCount.get();
+        log.info(""Processing [{}] valid files out of [{}] available."", hdfsFiles.size(), fileStatuses.length);
+
+        for (int i = 0; i < hdfsFiles.size(); i++) {","[{'comment': ""IMHO I'd tend to replace this with `forEach` as it can be readable and concise, unless there was another reason perhaps?  "", 'commenter': 'omarsmak'}, {'comment': ""it's not for each, so I can print the index ... I can also add an int index and increment it, but in the end it's just syntactic sugar. An index will still be created by the compiler."", 'commenter': 'marius-cornescu'}, {'comment': 'Well for me that is a personal flavour that I tend to prefer forEach over the classical for loop, however if you really need index to print, then is fine for me', 'commenter': 'omarsmak'}]"
3374,components/camel-rest-swagger/src/main/java/org/apache/camel/component/rest/swagger/RestSwaggerEndpoint.java,"@@ -165,7 +177,18 @@ public Consumer createConsumer(final Processor processor) throws Exception {
     @Override
     public Producer createProducer() throws Exception {
         final CamelContext camelContext = getCamelContext();
-        final Swagger swagger = loadSpecificationFrom(camelContext, specificationUri);
+        SSLContextParameters sslContextParameters = getSslContextParameters();
+        if (sslContextParameters == null) {","[{'comment': ""IMHO, I'd move `sslContextParameters` checks to a separate function and I'd prefer to use `if else` only in this context in order to avoid the `null` checks in case is already assigned"", 'commenter': 'omarsmak'}, {'comment': ""I don't have a problem with suggested approach, I'll change it."", 'commenter': 'JiriOndrusek'}]"
3374,components/camel-rest-swagger/src/main/java/org/apache/camel/component/rest/swagger/RestSwaggerEndpoint.java,"@@ -165,7 +177,18 @@ public Consumer createConsumer(final Processor processor) throws Exception {
     @Override
     public Producer createProducer() throws Exception {
         final CamelContext camelContext = getCamelContext();
-        final Swagger swagger = loadSpecificationFrom(camelContext, specificationUri);
+        SSLContextParameters sslContextParameters = getSslContextParameters();
+        if (sslContextParameters == null) {
+            sslContextParameters = component().getSslContextParameters();
+        }
+        if (sslContextParameters == null) {
+            sslContextParameters = camelContext.getSSLContextParameters();
+        }
+        if (sslContextParameters == null) {
+            sslContextParameters = component().retrieveGlobalSslContextParameters();","[{'comment': ""Do we check if `retrieveGlobalSslContextParameters` doesn't return `null` somewhere?"", 'commenter': 'omarsmak'}, {'comment': ""sslContextParameters could be null. (and it will be in majority of calls). Null means that the security is not defined http-component won't be used - https://github.com/apache/camel/pull/3374/files#diff-198a2a776971f53def53c61f07af2721R633"", 'commenter': 'JiriOndrusek'}]"
3374,components/camel-rest-swagger/src/main/java/org/apache/camel/component/rest/swagger/RestSwaggerEndpoint.java,"@@ -651,4 +705,18 @@ static String queryParameterExpression(final Parameter parameter) {
         return expression.toString();
     }
 
+    protected static HttpRequestBase createMethod(String url) {
+
+        // create http holder objects for the request
+        HttpMethods methodToUse = HttpMethods.GET;","[{'comment': 'Is this used somewhere?', 'commenter': 'omarsmak'}, {'comment': 'This code will be removed in favor of 1-line expression', 'commenter': 'JiriOndrusek'}]"
3374,components/camel-rest-swagger/src/main/java/org/apache/camel/component/rest/swagger/RestSwaggerEndpoint.java,"@@ -651,4 +705,18 @@ static String queryParameterExpression(final Parameter parameter) {
         return expression.toString();
     }
 
+    protected static HttpRequestBase createMethod(String url) {
+
+        // create http holder objects for the request
+        HttpMethods methodToUse = HttpMethods.GET;
+
+        HttpEntity requestEntity = new StringEntity((String) """", """");","[{'comment': ""We don't need to cast to string here "", 'commenter': 'omarsmak'}, {'comment': 'This code will be removed in favor of 1-line expression', 'commenter': 'JiriOndrusek'}]"
3374,components/camel-rest-swagger/src/main/java/org/apache/camel/component/rest/swagger/RestSwaggerEndpoint.java,"@@ -651,4 +705,18 @@ static String queryParameterExpression(final Parameter parameter) {
         return expression.toString();
     }
 
+    protected static HttpRequestBase createMethod(String url) {","[{'comment': 'I\'d rather save up on this function and write it as one line\r\n```suggestion\r\n    protected static HttpRequestBase createMethod(String url) {\r\n        return new HttpGetWithBodyMethod(url, new StringEntity("""", """"));\r\n    }\r\n```', 'commenter': 'omarsmak'}, {'comment': ""I agree,  I haven't refactored this part of code (I was removing unnecessary code and at this moment method is completely useless)"", 'commenter': 'JiriOndrusek'}]"
3374,components/camel-rest-swagger/src/main/java/org/apache/camel/component/rest/swagger/RestSwaggerEndpoint.java,"@@ -592,31 +623,54 @@ static String hostFrom(final RestConfiguration restConfiguration) {
      * @return the specification
      * @throws IOException
      */
-    static Swagger loadSpecificationFrom(final CamelContext camelContext, final URI uri) throws IOException {
+    static Swagger loadSpecificationFrom(final CamelContext camelContext, final URI uri, SSLContextParameters sslContextParameters) throws IOException {
         final ObjectMapper mapper = Json.mapper();
 
         final SwaggerParser swaggerParser = new SwaggerParser();
 
         final String uriAsString = uri.toString();
 
-        try (InputStream stream = ResourceHelper.resolveMandatoryResourceAsInputStream(camelContext, uriAsString)) {
-            final JsonNode node = mapper.readTree(stream);
+        if (sslContextParameters == null) {
+            try (InputStream stream = ResourceHelper.resolveMandatoryResourceAsInputStream(camelContext, uriAsString)) {
+                return parseInputStream(swaggerParser, mapper, stream);
+            } catch (final Exception e) {
+                return loadSpecificationFalback(swaggerParser, uriAsString, e);","[{'comment': 'I think you meant \r\n```suggestion\r\n                return loadSpecificationFallback(swaggerParser, uriAsString, e);\r\n```', 'commenter': 'omarsmak'}, {'comment': ""I've fixed this typo in last force push, but evidently there was one missing case, I'll fix it."", 'commenter': 'JiriOndrusek'}]"
3374,components/camel-rest-swagger/src/main/java/org/apache/camel/component/rest/swagger/RestSwaggerEndpoint.java,"@@ -592,31 +619,53 @@ static String hostFrom(final RestConfiguration restConfiguration) {
      * @return the specification
      * @throws IOException
      */
-    static Swagger loadSpecificationFrom(final CamelContext camelContext, final URI uri) throws IOException {
+    static Swagger loadSpecificationFrom(final CamelContext camelContext, final URI uri, SSLContextParameters sslContextParameters) throws IOException {
         final ObjectMapper mapper = Json.mapper();
 
         final SwaggerParser swaggerParser = new SwaggerParser();
 
         final String uriAsString = uri.toString();
 
-        try (InputStream stream = ResourceHelper.resolveMandatoryResourceAsInputStream(camelContext, uriAsString)) {
-            final JsonNode node = mapper.readTree(stream);
+        if (sslContextParameters == null) {
+            try (InputStream stream = ResourceHelper.resolveMandatoryResourceAsInputStream(camelContext, uriAsString)) {
+                return parseInputStream(swaggerParser, mapper, stream);
+            } catch (final Exception e) {
+                return loadSpecificationFallback(swaggerParser, uriAsString, e);
+            }
+        }
 
-            return swaggerParser.read(node);
+        HttpComponent httpComponent = new HttpComponent();
+        httpComponent.setSslContextParameters(sslContextParameters);
+        httpComponent.setCamelContext(camelContext);
+        try (HttpEndpoint e = (HttpEndpoint)httpComponent.createEndpoint(uriAsString);
+             HttpProducer p = (HttpProducer)e.createProducer();
+             InputStream stream = p.getHttpClient().execute(new HttpGet(uri)).getEntity().getContent())  {","[{'comment': 'You likely need to close this input stream after use.', 'commenter': 'davsclaus'}, {'comment': '@davsclaus I thought that try-with-resource will take care of closing. (https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html). Am I missing something?', 'commenter': 'JiriOndrusek'}, {'comment': 'It only takes care the stuff inside the try ( xxxx ) line, which in your case is creating an http endpoint', 'commenter': 'davsclaus'}, {'comment': ""oh, ma bad, I'll fix it"", 'commenter': 'JiriOndrusek'}, {'comment': '@davsclaus Just to be sure, whole \r\nHttpEndpoint e = (HttpEndpoint)httpComponent.createEndpoint(uriAsString);\r\n             HttpProducer p = (HttpProducer)e.createProducer();\r\n             InputStream stream = p.getHttpClient().execute(new HttpGet(uri)).getEntity().getContent()\r\n\r\nis inside try ( xxx ), so it should be all closed automatically. All 3 instances (e, p, stream) should be closed.', 'commenter': 'JiriOndrusek'}, {'comment': 'Ah gotcha yeah its multi lined and in one giant ( ). Okay usually its 99% just one resource. Yeah it will be auto-closed.', 'commenter': 'davsclaus'}]"
3385,components/camel-rabbitmq/src/main/java/org/apache/camel/component/rabbitmq/RabbitMQComponent.java,"@@ -185,6 +185,8 @@ protected RabbitMQEndpoint createEndpoint(String uri,
             }
         }
 
+        @SuppressWarnings(""unchecked"")
+        Map<String, Object> args = resolveAndRemoveReferenceParameter(params, ""args"", Map.class, getArgs());","[{'comment': 'I think this is not needed, under by `setProperties` is doing the job to resolve the args param ', 'commenter': 'omarsmak'}, {'comment': 'Same as my next comment', 'commenter': 'mikadev'}]"
3385,components/camel-rabbitmq/src/main/java/org/apache/camel/component/rabbitmq/RabbitMQComponent.java,"@@ -202,6 +204,7 @@ protected RabbitMQEndpoint createEndpoint(String uri,
         endpoint.setAddresses(getAddresses());
         endpoint.setThreadPoolSize(getThreadPoolSize());
         endpoint.setExchangeName(exchangeName);
+        endpoint.setArgs(args);","[{'comment': 'Same here, I think this is not needed, as this being handled by `setProperties(endpoint, params);`\r\n', 'commenter': 'omarsmak'}, {'comment': ""This is all the point params parameter is always an empty map where args is setting using query parameters is my PR there is something wrong i don't know where i think we have to cleanup this component"", 'commenter': 'mikadev'}, {'comment': 'What do you mean? What are you trying to fix exactly here? Because I feel we are mixing things up here. \r\n', 'commenter': 'omarsmak'}, {'comment': 'I trying to first getting args argument when it passed as query parameters lets just fix this for beginning ', 'commenter': 'mikadev'}, {'comment': 'But I thought if you pass it like this `rabbitmq:foo?queue=foo&arg.queue.x-max-priority=10` it will work?  ', 'commenter': 'omarsmak'}, {'comment': 'Yes is work but as i explain in my ticket how i suppose to do with the camelenpointdsl to achieve the same this is not a regular way to pass query parameter and now we see the limitation', 'commenter': 'mikadev'}, {'comment': 'So maybe is better to rollback all this stuff and restore the oldest and good way using some param that take a map and then use this eg:params=#paramsMap', 'commenter': 'mikadev'}, {'comment': 'Okay, how do you call your rabbitmq then via endpoint dsl?', 'commenter': 'omarsmak'}, {'comment': 'Like your example could be a good way i take your example from the ticket:\r\n\r\n```\r\nrabbitmq(""foo"")\r\n        .queue(""foo"")\r\n        .advanced()\r\n        .args(Collections.singletonMap(""queue.x-max-priority"", ""10""));```', 'commenter': 'mikadev'}, {'comment': 'Okay, based on this one, how about if you just remove the lines that I suggested and try it out.  ', 'commenter': 'omarsmak'}, {'comment': ""What do you mean ? i really didn't understand "", 'commenter': 'mikadev'}, {'comment': 'The case is simple how i suppose to translate this weird way `&arg.queue.x-max-priority=10` of passing parameter with the new DSL ', 'commenter': 'mikadev'}, {'comment': 'In this PR, I suggested to remove some lines from the code. This line where we are commenting now and [here](https://github.com/apache/camel/pull/3385#discussion_r354166344)', 'commenter': 'omarsmak'}, {'comment': ""But this is the main point if your remove this line i'll get an empty map"", 'commenter': 'mikadev'}, {'comment': ""Maybe if you can try this and i think you'll see what i'm trying to solve "", 'commenter': 'mikadev'}]"
3401,components/camel-elytron/pom.xml,"@@ -0,0 +1,74 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one or more
+    contributor license agreements.  See the NOTICE file distributed with
+    this work for additional information regarding copyright ownership.
+    The ASF licenses this file to You under the Apache License, Version 2.0
+    (the ""License""); you may not use this file except in compliance with
+    the License.  You may obtain a copy of the License at
+
+         http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an ""AS IS"" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+
+-->
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"">
+    <modelVersion>4.0.0</modelVersion>
+
+    <parent>
+        <groupId>org.apache.camel</groupId>
+        <artifactId>components</artifactId>
+        <version>3.1.0-SNAPSHOT</version>
+    </parent>
+
+    <artifactId>camel-elytron</artifactId>
+    <packaging>jar</packaging>
+
+    <name>Camel :: Elytron</name>
+
+    <properties>
+        <version.org.wildfly.security.wildfly-elytron>1.1.0.Final</version.org.wildfly.security.wildfly-elytron>","[{'comment': 'This should be under parent POM', 'commenter': 'oscerd'}, {'comment': 'done', 'commenter': 'JiriOndrusek'}]"
3401,components/camel-elytron/pom.xml,"@@ -0,0 +1,74 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one or more
+    contributor license agreements.  See the NOTICE file distributed with
+    this work for additional information regarding copyright ownership.
+    The ASF licenses this file to You under the Apache License, Version 2.0
+    (the ""License""); you may not use this file except in compliance with
+    the License.  You may obtain a copy of the License at
+
+         http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an ""AS IS"" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+
+-->
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"">
+    <modelVersion>4.0.0</modelVersion>
+
+    <parent>
+        <groupId>org.apache.camel</groupId>
+        <artifactId>components</artifactId>
+        <version>3.1.0-SNAPSHOT</version>
+    </parent>
+
+    <artifactId>camel-elytron</artifactId>
+    <packaging>jar</packaging>
+
+    <name>Camel :: Elytron</name>
+
+    <properties>
+        <version.org.wildfly.security.wildfly-elytron>1.1.0.Final</version.org.wildfly.security.wildfly-elytron>
+        <version.org.wildfly.security.elytron-web.undertow-server>1.0.0.Final</version.org.wildfly.security.elytron-web.undertow-server>
+        <camel.osgi.import.before.defaults>
+            javax.activation.*;version=""${javax-activation-version-range}""
+        </camel.osgi.import.before.defaults>
+    </properties>
+
+    <dependencies>
+        <dependency>
+            <groupId>org.apache.camel</groupId>
+            <artifactId>camel-cloud</artifactId>
+        </dependency>
+        <dependency>
+            <groupId>org.apache.camel</groupId>
+            <artifactId>camel-undertow</artifactId>
+        </dependency>
+        <dependency>
+            <groupId>org.wildfly.security</groupId>
+            <artifactId>wildfly-elytron</artifactId>
+            <version>${version.org.wildfly.security.wildfly-elytron}</version>
+        </dependency>
+        <dependency>
+            <groupId>org.wildfly.security.elytron-web</groupId>
+            <artifactId>undertow-server</artifactId>
+            <version>${version.org.wildfly.security.elytron-web.undertow-server}</version>
+        </dependency>
+        <dependency>
+            <groupId>io.undertow</groupId>
+            <artifactId>undertow-servlet</artifactId>
+            <version>2.0.13.Final</version>","[{'comment': 'I think should use the same version as camel-undertow is using, I believe is 2.0.28.Final', 'commenter': 'oscerd'}, {'comment': 'done', 'commenter': 'JiriOndrusek'}]"
3401,components/camel-elytron/src/main/docs/elytron-component.adoc,"@@ -0,0 +1,157 @@
+[[elytron-component]]
+= Elytron Component
+
+*Since Camel 2.16*","[{'comment': '3.1.0', 'commenter': 'oscerd'}, {'comment': 'done', 'commenter': 'JiriOndrusek'}]"
3401,components/camel-elytron/src/main/java/org/apache/camel/component/elytron/ElytronComponent.java,"@@ -0,0 +1,148 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.elytron;
+
+import io.undertow.security.handlers.AuthenticationCallHandler;
+import io.undertow.security.handlers.AuthenticationConstraintHandler;
+import io.undertow.server.HttpHandler;
+import org.apache.camel.CamelContext;
+import org.apache.camel.component.undertow.HttpHandlerRegistrationInfo;
+import org.apache.camel.component.undertow.UndertowComponent;
+import org.apache.camel.component.undertow.UndertowEndpoint;
+import org.apache.camel.spi.Metadata;
+import org.apache.camel.spi.annotations.Component;
+import org.wildfly.elytron.web.undertow.server.ElytronContextAssociationHandler;
+import org.wildfly.elytron.web.undertow.server.ElytronRunAsHandler;
+import org.wildfly.security.WildFlyElytronProvider;
+import org.wildfly.security.auth.server.HttpAuthenticationFactory;
+import org.wildfly.security.auth.server.MechanismConfiguration;
+import org.wildfly.security.auth.server.MechanismConfigurationSelector;
+import org.wildfly.security.auth.server.MechanismRealmConfiguration;
+import org.wildfly.security.auth.server.SecurityDomain;
+import org.wildfly.security.http.HttpAuthenticationException;
+import org.wildfly.security.http.HttpServerAuthenticationMechanismFactory;
+import org.wildfly.security.http.util.FilterServerMechanismFactory;
+import org.wildfly.security.http.util.SecurityProviderServerMechanismFactory;
+
+import javax.net.ssl.SSLContext;
+import java.net.URI;
+import java.net.URISyntaxException;
+import java.security.Provider;
+import java.util.Collections;
+
+/**
+ *
+ * @author JiriOndrusek
+ */
+//TODO
+@Metadata(label = ""verifiers"", enums = ""parameters,connectivity"")
+@Component(""elytron"")
+public class ElytronComponent extends UndertowComponent {
+
+    private static final WildFlyElytronProvider elytronProvider = new WildFlyElytronProvider();
+
+    @Metadata(label = ""elytron"")
+    private SecurityDomain.Builder securityDomainBuilder;
+
+    private SecurityDomain securityDomain;
+
+    public ElytronComponent() {
+    }
+
+    public ElytronComponent(CamelContext context) {
+        super(context);
+    }
+
+    @Override
+    protected String getComponentName() {
+        return ""elytron"";
+    }
+
+
+    @Override
+    protected UndertowEndpoint createEndpointInstance(URI endpointUri, UndertowComponent component) throws URISyntaxException {
+        return new ElytronEndpoint(endpointUri.toString(), component);
+    }
+
+    @Override
+    public HttpHandler registerEndpoint(HttpHandlerRegistrationInfo registrationInfo, SSLContext sslContext, HttpHandler handler) {
+        //injecting elytron
+        return super.registerEndpoint(registrationInfo, sslContext, wrap(handler, getSecurityDomain()));
+    }
+
+    /**
+     * TODO","[{'comment': 'I think the TODO can be removed.', 'commenter': 'oscerd'}, {'comment': 'done', 'commenter': 'JiriOndrusek'}]"
3401,components/camel-elytron/src/main/java/org/apache/camel/component/elytron/ElytronConsumer.java,"@@ -0,0 +1,70 @@
+package org.apache.camel.component.elytron;","[{'comment': 'Missing license header', 'commenter': 'oscerd'}, {'comment': 'done', 'commenter': 'JiriOndrusek'}]"
3401,components/camel-elytron/src/main/java/org/apache/camel/component/elytron/ElytronEndpoint.java,"@@ -0,0 +1,85 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.elytron;
+
+
+import io.undertow.server.HttpServerExchange;
+import org.apache.camel.Consumer;
+import org.apache.camel.Exchange;
+import org.apache.camel.Processor;
+import org.apache.camel.component.undertow.UndertowComponent;
+import org.apache.camel.component.undertow.UndertowEndpoint;
+import org.apache.camel.spi.UriEndpoint;
+import org.apache.camel.spi.UriParam;
+import org.wildfly.security.auth.server.SecurityIdentity;
+
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+
+/**
+ *
+ * @author JiriOndrusek
+ */
+//TODO","[{'comment': 'TODO can be removed.', 'commenter': 'oscerd'}, {'comment': 'done', 'commenter': 'JiriOndrusek'}]"
3401,components/camel-elytron/src/main/java/org/apache/camel/component/elytron/ElytronEndpoint.java,"@@ -0,0 +1,85 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.elytron;
+
+
+import io.undertow.server.HttpServerExchange;
+import org.apache.camel.Consumer;
+import org.apache.camel.Exchange;
+import org.apache.camel.Processor;
+import org.apache.camel.component.undertow.UndertowComponent;
+import org.apache.camel.component.undertow.UndertowEndpoint;
+import org.apache.camel.spi.UriEndpoint;
+import org.apache.camel.spi.UriParam;
+import org.wildfly.security.auth.server.SecurityIdentity;
+
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+
+/**
+ *
+ * @author JiriOndrusek
+ */
+//TODO
+@UriEndpoint(firstVersion = ""2.16.0"", scheme = ""elytron"", title = ""Elytron"", syntax = ""elytron:httpURI"",","[{'comment': '3.1.0', 'commenter': 'oscerd'}, {'comment': 'done', 'commenter': 'JiriOndrusek'}]"
3401,components/camel-elytron/src/main/java/org/apache/camel/component/elytron/ElytronComponent.java,"@@ -0,0 +1,163 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.elytron;
+
+import io.undertow.security.handlers.AuthenticationCallHandler;
+import io.undertow.security.handlers.AuthenticationConstraintHandler;
+import io.undertow.server.HttpHandler;
+import org.apache.camel.CamelContext;
+import org.apache.camel.component.undertow.HttpHandlerRegistrationInfo;
+import org.apache.camel.component.undertow.UndertowComponent;
+import org.apache.camel.component.undertow.UndertowEndpoint;
+import org.apache.camel.spi.Metadata;
+import org.apache.camel.spi.annotations.Component;
+import org.wildfly.elytron.web.undertow.server.ElytronContextAssociationHandler;
+import org.wildfly.elytron.web.undertow.server.ElytronRunAsHandler;
+import org.wildfly.security.WildFlyElytronProvider;
+import org.wildfly.security.auth.server.MechanismConfiguration;
+import org.wildfly.security.auth.server.MechanismConfigurationSelector;
+import org.wildfly.security.auth.server.MechanismRealmConfiguration;
+import org.wildfly.security.auth.server.SecurityDomain;
+import org.wildfly.security.auth.server.http.HttpAuthenticationFactory;
+import org.wildfly.security.http.HttpAuthenticationException;
+import org.wildfly.security.http.HttpConstants;
+import org.wildfly.security.http.HttpServerAuthenticationMechanismFactory;
+import org.wildfly.security.http.util.FilterServerMechanismFactory;
+import org.wildfly.security.http.util.SecurityProviderServerMechanismFactory;
+
+import javax.net.ssl.SSLContext;
+import java.net.URI;
+import java.net.URISyntaxException;
+import java.security.Provider;
+import java.util.Collections;
+
+/**
+ * Elytron component brings elytron security over came-undertow component.
+ *
+ * Component work either as producer and as consumer.
+ *
+ * User has to define its SecurityDomain.Builder which will be used for creation of security domain.
+ * MechanismName then allows to define mechanism, which will take care of authentication from security context.
+ * MechanusmName should be selected with regard to default securityRealm.
+ *
+ * Example: to use bearer_token, mechanism name has to be ""BEARER_TOKEN"" and realm has to be TokenSecurityRealm.
+ *
+ * @author JiriOndrusek
+ */
+@Metadata(label = ""verifiers"", enums = ""parameters,connectivity"")
+@Component(""elytron"")
+public class ElytronComponent extends UndertowComponent {
+
+    private static final WildFlyElytronProvider elytronProvider = new WildFlyElytronProvider();","[{'comment': 'Hey @JiriOndrusek, it got to my attention that `WildFlyElytronProvider` is deprecated as I can see [here](https://github.com/wildfly-security/wildfly-elytron/blob/1.11.0.CR3/base/src/main/java/org/wildfly/security/WildFlyElytronProvider.java#L43), since I am not detailed about WildFlyElectron project, do you have an idea what is the alternative way to do it? ', 'commenter': 'omarsmak'}, {'comment': ""Hi, I've noticed this a few hours ago as I was writing a test. I agree that we should use correct object, I'll look into it"", 'commenter': 'JiriOndrusek'}]"
3401,components/camel-elytron/src/main/java/org/apache/camel/component/elytron/ElytronComponent.java,"@@ -0,0 +1,163 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.elytron;
+
+import io.undertow.security.handlers.AuthenticationCallHandler;
+import io.undertow.security.handlers.AuthenticationConstraintHandler;
+import io.undertow.server.HttpHandler;
+import org.apache.camel.CamelContext;
+import org.apache.camel.component.undertow.HttpHandlerRegistrationInfo;
+import org.apache.camel.component.undertow.UndertowComponent;
+import org.apache.camel.component.undertow.UndertowEndpoint;
+import org.apache.camel.spi.Metadata;
+import org.apache.camel.spi.annotations.Component;
+import org.wildfly.elytron.web.undertow.server.ElytronContextAssociationHandler;
+import org.wildfly.elytron.web.undertow.server.ElytronRunAsHandler;
+import org.wildfly.security.WildFlyElytronProvider;
+import org.wildfly.security.auth.server.MechanismConfiguration;
+import org.wildfly.security.auth.server.MechanismConfigurationSelector;
+import org.wildfly.security.auth.server.MechanismRealmConfiguration;
+import org.wildfly.security.auth.server.SecurityDomain;
+import org.wildfly.security.auth.server.http.HttpAuthenticationFactory;
+import org.wildfly.security.http.HttpAuthenticationException;
+import org.wildfly.security.http.HttpConstants;
+import org.wildfly.security.http.HttpServerAuthenticationMechanismFactory;
+import org.wildfly.security.http.util.FilterServerMechanismFactory;
+import org.wildfly.security.http.util.SecurityProviderServerMechanismFactory;
+
+import javax.net.ssl.SSLContext;
+import java.net.URI;
+import java.net.URISyntaxException;
+import java.security.Provider;
+import java.util.Collections;
+
+/**
+ * Elytron component brings elytron security over came-undertow component.
+ *
+ * Component work either as producer and as consumer.
+ *
+ * User has to define its SecurityDomain.Builder which will be used for creation of security domain.
+ * MechanismName then allows to define mechanism, which will take care of authentication from security context.
+ * MechanusmName should be selected with regard to default securityRealm.
+ *
+ * Example: to use bearer_token, mechanism name has to be ""BEARER_TOKEN"" and realm has to be TokenSecurityRealm.
+ *
+ * @author JiriOndrusek
+ */
+@Metadata(label = ""verifiers"", enums = ""parameters,connectivity"")
+@Component(""elytron"")
+public class ElytronComponent extends UndertowComponent {
+
+    private static final WildFlyElytronProvider elytronProvider = new WildFlyElytronProvider();
+
+    @Metadata(label = ""elytron"")
+    private SecurityDomain.Builder securityDomainBuilder;
+    @Metadata(label = ""elytron"", defaultValue = HttpConstants.BEARER_TOKEN)
+    private String mechanismName;
+
+    private SecurityDomain securityDomain;
+
+    public ElytronComponent() {
+    }
+
+    public ElytronComponent(CamelContext context) {
+        super(context);
+    }
+
+    @Override
+    protected String getComponentName() {
+        return ""elytron"";
+    }
+
+
+    @Override
+    protected UndertowEndpoint createEndpointInstance(URI endpointUri, UndertowComponent component) throws URISyntaxException {
+        return new ElytronEndpoint(endpointUri.toString(), component);
+    }
+
+    @Override
+    public HttpHandler registerEndpoint(HttpHandlerRegistrationInfo registrationInfo, SSLContext sslContext, HttpHandler handler) {
+        //injecting elytron
+        return super.registerEndpoint(registrationInfo, sslContext, wrap(handler, getSecurityDomain()));
+    }
+
+    /**
+     * Definition of Builder, which will be used for creation of security domain.
+     */
+    public SecurityDomain.Builder getSecurityDomainBuilder() {
+        return securityDomainBuilder;
+    }
+
+    public void setSecurityDomainBuilder(SecurityDomain.Builder securityDomainBuilder) {
+        this.securityDomainBuilder = securityDomainBuilder;
+    }
+
+
+    /**
+     * Name of the mechanism, which will be used for selection of authentication mechanism.
+     */
+    public String getMechanismName() {
+        return mechanismName;
+    }
+
+    public void setMechanismName(String mechanismName) {
+        this.mechanismName = mechanismName;
+    }
+
+    SecurityDomain getSecurityDomain() {","[{'comment': 'Can we add the access modifier here? ', 'commenter': 'omarsmak'}, {'comment': 'Would ""protected"" suffice? I\'m accessing this getter from endpoint', 'commenter': 'JiriOndrusek'}, {'comment': ""sorry didn't notice, should be fine I guess."", 'commenter': 'omarsmak'}]"
3401,components/camel-elytron/src/main/java/org/apache/camel/component/elytron/ElytronConsumer.java,"@@ -0,0 +1,87 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.elytron;
+
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+
+import io.undertow.server.HttpServerExchange;
+import io.undertow.util.StatusCodes;
+import org.apache.camel.Processor;
+import org.apache.camel.component.undertow.UndertowConsumer;
+import org.apache.camel.component.undertow.UndertowEndpoint;
+import org.wildfly.security.auth.server.SecurityIdentity;
+import org.wildfly.security.authz.Roles;
+
+
+
+/**
+ * Consumer contains decides if request contains required roles (which are defined for endpoint)
+ *
+ * @author JiriOndrusek
+ */
+public class ElytronConsumer extends UndertowConsumer {
+
+    private Set<String> roles;
+    private List<String> allowedRoles;
+
+    public ElytronConsumer(UndertowEndpoint endpoint, Processor processor) {
+        super(endpoint, processor);
+    }
+
+    public ElytronEndpoint getElytronEndpoint() {
+        return (ElytronEndpoint) super.getEndpoint();
+    }
+
+    @Override
+    public void handleRequest(HttpServerExchange httpExchange) throws Exception {
+        SecurityIdentity identity = getElytronEndpoint().getElytronComponent().getSecurityDomain().getCurrentSecurityIdentity();
+
+        if (identity != null) {
+            //already authenticated
+            Set<String> roles = new HashSet<>();
+            Roles identityRoles = identity.getRoles();
+
+            if (identityRoles != null) {
+                for (String roleName : identityRoles) {
+                    roles.add(roleName);
+                }
+            }
+
+            if (isAllowed(roles, getElytronEndpoint().getAllowedRolesList())) {
+                super.handleRequest(httpExchange);
+            } else {
+                httpExchange.setStatusCode(StatusCodes.FORBIDDEN);
+            }
+
+            return;","[{'comment': 'Please mind if I ask, but what would happen if the request reaches this line? ', 'commenter': 'omarsmak'}, {'comment': 'It will return status code 403 and fails the exchange, You can see it in the junit test with bad role', 'commenter': 'JiriOndrusek'}, {'comment': ""Ah right, didn't notice the that was setting `403` on the exchange. Thanks for the clarification!"", 'commenter': 'omarsmak'}]"
3401,components/camel-elytron/src/main/java/org/apache/camel/component/elytron/ElytronEndpoint.java,"@@ -0,0 +1,90 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.camel.component.elytron;
+
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+
+import io.undertow.server.HttpServerExchange;
+import org.apache.camel.Consumer;
+import org.apache.camel.Exchange;
+import org.apache.camel.Processor;
+import org.apache.camel.component.undertow.UndertowComponent;
+import org.apache.camel.component.undertow.UndertowEndpoint;
+import org.apache.camel.spi.UriEndpoint;
+import org.apache.camel.spi.UriParam;
+import org.wildfly.security.auth.server.SecurityIdentity;
+
+/**
+ * Endpoint
+ *
+ * @author JiriOndrusek
+ */
+@UriEndpoint(firstVersion = ""3.1.0"", scheme = ""elytron"", title = ""Elytron"", syntax = ""elytron:httpURI"",
+        label = ""http"", lenientProperties = true)
+public class ElytronEndpoint extends UndertowEndpoint {
+
+    /**
+     * Name of the header which contains associated security identity if request is authenticated.
+     */
+    public static final String SECURITY_IDENTITY_HEADER = ""securityIdentity"";
+
+    @UriParam(label = ""allowedRoles"")","[{'comment': 'Please change `label`, it is used for categorization in documentation (should be one of consumer, producer, common, advanced).', 'commenter': 'bedlaj'}]"
3401,components/camel-elytron/src/main/java/org/apache/camel/component/elytron/ElytronEndpoint.java,"@@ -0,0 +1,90 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.camel.component.elytron;
+
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+
+import io.undertow.server.HttpServerExchange;
+import org.apache.camel.Consumer;
+import org.apache.camel.Exchange;
+import org.apache.camel.Processor;
+import org.apache.camel.component.undertow.UndertowComponent;
+import org.apache.camel.component.undertow.UndertowEndpoint;
+import org.apache.camel.spi.UriEndpoint;
+import org.apache.camel.spi.UriParam;
+import org.wildfly.security.auth.server.SecurityIdentity;
+
+/**
+ * Endpoint
+ *
+ * @author JiriOndrusek
+ */
+@UriEndpoint(firstVersion = ""3.1.0"", scheme = ""elytron"", title = ""Elytron"", syntax = ""elytron:httpURI"",","[{'comment': 'Please add `extendsScheme = ""undertow""` attribute', 'commenter': 'bedlaj'}]"
3401,components/camel-elytron/src/main/java/org/apache/camel/component/elytron/ElytronConsumer.java,"@@ -0,0 +1,87 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.elytron;
+
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+
+import io.undertow.server.HttpServerExchange;
+import io.undertow.util.StatusCodes;
+import org.apache.camel.Processor;
+import org.apache.camel.component.undertow.UndertowConsumer;
+import org.apache.camel.component.undertow.UndertowEndpoint;
+import org.wildfly.security.auth.server.SecurityIdentity;
+import org.wildfly.security.authz.Roles;
+
+
+
+/**
+ * Consumer contains decides if request contains required roles (which are defined for endpoint)
+ *
+ * @author JiriOndrusek
+ */
+public class ElytronConsumer extends UndertowConsumer {
+
+    private Set<String> roles;
+    private List<String> allowedRoles;
+
+    public ElytronConsumer(UndertowEndpoint endpoint, Processor processor) {
+        super(endpoint, processor);
+    }
+
+    public ElytronEndpoint getElytronEndpoint() {
+        return (ElytronEndpoint) super.getEndpoint();
+    }
+
+    @Override
+    public void handleRequest(HttpServerExchange httpExchange) throws Exception {
+        SecurityIdentity identity = getElytronEndpoint().getElytronComponent().getSecurityDomain().getCurrentSecurityIdentity();
+
+        if (identity != null) {
+            //already authenticated
+            Set<String> roles = new HashSet<>();
+            Roles identityRoles = identity.getRoles();
+
+            if (identityRoles != null) {
+                for (String roleName : identityRoles) {
+                    roles.add(roleName);
+                }
+            }
+
+            if (isAllowed(roles, getElytronEndpoint().getAllowedRolesList())) {
+                super.handleRequest(httpExchange);
+            } else {
+                httpExchange.setStatusCode(StatusCodes.FORBIDDEN);","[{'comment': 'Shouldnt be exchange closed here to prevent resource leaks? `httpExchange.endExchange()`, or is this handled somewhere?', 'commenter': 'bedlaj'}]"
3401,components/camel-elytron/src/main/java/org/apache/camel/component/elytron/ElytronComponent.java,"@@ -0,0 +1,175 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.elytron;
+
+import java.net.URI;
+import java.net.URISyntaxException;
+import java.security.Provider;
+import java.util.Collections;
+
+import javax.net.ssl.SSLContext;
+
+import io.undertow.security.handlers.AuthenticationCallHandler;
+import io.undertow.security.handlers.AuthenticationConstraintHandler;
+import io.undertow.server.HttpHandler;
+import org.apache.camel.CamelContext;
+import org.apache.camel.component.undertow.HttpHandlerRegistrationInfo;
+import org.apache.camel.component.undertow.UndertowComponent;
+import org.apache.camel.component.undertow.UndertowEndpoint;
+import org.apache.camel.spi.Metadata;
+import org.apache.camel.spi.annotations.Component;
+import org.wildfly.elytron.web.undertow.server.ElytronContextAssociationHandler;
+import org.wildfly.elytron.web.undertow.server.ElytronRunAsHandler;
+import org.wildfly.security.WildFlyElytronBaseProvider;
+import org.wildfly.security.auth.server.MechanismConfiguration;
+import org.wildfly.security.auth.server.MechanismConfigurationSelector;
+import org.wildfly.security.auth.server.MechanismRealmConfiguration;
+import org.wildfly.security.auth.server.SecurityDomain;
+import org.wildfly.security.auth.server.http.HttpAuthenticationFactory;
+import org.wildfly.security.http.HttpAuthenticationException;
+import org.wildfly.security.http.HttpConstants;
+import org.wildfly.security.http.HttpServerAuthenticationMechanismFactory;
+import org.wildfly.security.http.bearer.WildFlyElytronHttpBearerProvider;
+import org.wildfly.security.http.util.FilterServerMechanismFactory;
+import org.wildfly.security.http.util.SecurityProviderServerMechanismFactory;
+
+/**
+ * Elytron component brings elytron security over came-undertow component.
+ *
+ * Component work either as producer and as consumer.
+ *
+ * User has to define its SecurityDomain.Builder which will be used for creation of security domain.
+ * MechanismName then allows to define mechanism, which will take care of authentication from security context.
+ * MechanusmName should be selected with regard to default securityRealm.","[{'comment': 'nit: typo', 'commenter': 'bedlaj'}]"
3401,components/camel-elytron/src/main/java/org/apache/camel/component/elytron/ElytronConsumer.java,"@@ -0,0 +1,87 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.elytron;
+
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+
+import io.undertow.server.HttpServerExchange;
+import io.undertow.util.StatusCodes;
+import org.apache.camel.Processor;
+import org.apache.camel.component.undertow.UndertowConsumer;
+import org.apache.camel.component.undertow.UndertowEndpoint;
+import org.wildfly.security.auth.server.SecurityIdentity;
+import org.wildfly.security.authz.Roles;
+
+
+
+/**
+ * Consumer contains decides if request contains required roles (which are defined for endpoint)
+ *
+ * @author JiriOndrusek
+ */
+public class ElytronConsumer extends UndertowConsumer {
+
+    private Set<String> roles;
+    private List<String> allowedRoles;
+
+    public ElytronConsumer(UndertowEndpoint endpoint, Processor processor) {
+        super(endpoint, processor);
+    }
+
+    public ElytronEndpoint getElytronEndpoint() {
+        return (ElytronEndpoint) super.getEndpoint();
+    }
+
+    @Override
+    public void handleRequest(HttpServerExchange httpExchange) throws Exception {
+        SecurityIdentity identity = getElytronEndpoint().getElytronComponent().getSecurityDomain().getCurrentSecurityIdentity();
+
+        if (identity != null) {
+            //already authenticated
+            Set<String> roles = new HashSet<>();
+            Roles identityRoles = identity.getRoles();
+
+            if (identityRoles != null) {
+                for (String roleName : identityRoles) {
+                    roles.add(roleName);
+                }
+            }
+
+            if (isAllowed(roles, getElytronEndpoint().getAllowedRolesList())) {
+                super.handleRequest(httpExchange);
+            } else {
+                httpExchange.setStatusCode(StatusCodes.FORBIDDEN);
+            }
+
+            return;
+        }
+
+        super.handleRequest(httpExchange);
+    }
+
+    public boolean isAllowed(Set<String> roles, List<String> allowedRoles) throws Exception {","[{'comment': 'Is there reason for `throws Exception` in signature?', 'commenter': 'bedlaj'}]"
3401,core/camel-endpointdsl/src/main/java/org/apache/camel/builder/endpoint/EndpointBuilderFactory.java,"@@ -101,6 +101,7 @@
         EhcacheEndpointBuilderFactory,
         ElasticsearchEndpointBuilderFactory,
         ElsqlEndpointBuilderFactory,
+        ElytronEndpointBuilderFactory,","[{'comment': 'Please commit this class', 'commenter': 'bedlaj'}]"
3401,components/camel-elytron/src/main/java/org/apache/camel/component/elytron/ElytronConsumer.java,"@@ -0,0 +1,87 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.elytron;
+
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+
+import io.undertow.server.HttpServerExchange;
+import io.undertow.util.StatusCodes;
+import org.apache.camel.Processor;
+import org.apache.camel.component.undertow.UndertowConsumer;
+import org.apache.camel.component.undertow.UndertowEndpoint;
+import org.wildfly.security.auth.server.SecurityIdentity;
+import org.wildfly.security.authz.Roles;
+
+
+
+/**
+ * Consumer contains decides if request contains required roles (which are defined for endpoint)
+ *
+ * @author JiriOndrusek
+ */
+public class ElytronConsumer extends UndertowConsumer {
+
+    private Set<String> roles;
+    private List<String> allowedRoles;","[{'comment': 'Both fields seems to be unused. `roles` is masked by another initialization', 'commenter': 'bedlaj'}]"
3401,components/camel-elytron/pom.xml,"@@ -0,0 +1,167 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one or more
+    contributor license agreements.  See the NOTICE file distributed with
+    this work for additional information regarding copyright ownership.
+    The ASF licenses this file to You under the Apache License, Version 2.0
+    (the ""License""); you may not use this file except in compliance with
+    the License.  You may obtain a copy of the License at
+
+         http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an ""AS IS"" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+
+-->
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"">
+    <modelVersion>4.0.0</modelVersion>
+
+    <parent>
+        <groupId>org.apache.camel</groupId>
+        <artifactId>components</artifactId>
+        <version>3.1.0-SNAPSHOT</version>
+    </parent>
+
+    <artifactId>camel-elytron</artifactId>
+    <packaging>jar</packaging>
+
+    <name>Camel :: Elytron</name>
+
+    <properties>
+        <camel.osgi.import.before.defaults>","[{'comment': 'Are these properties needed, though this component does not support OSGI?', 'commenter': 'bedlaj'}]"
3403,components/camel-http/src/main/java/org/apache/camel/component/http/HttpProducer.java,"@@ -45,12 +26,7 @@
 import org.apache.camel.http.common.HttpOperationFailedException;
 import org.apache.camel.http.common.HttpProtocolHeaderFilterStrategy;
 import org.apache.camel.spi.HeaderFilterStrategy;
-import org.apache.camel.support.DefaultProducer;
-import org.apache.camel.support.ExchangeHelper;
-import org.apache.camel.support.GZIPHelper;
-import org.apache.camel.support.MessageHelper;
-import org.apache.camel.support.ObjectHelper;
-import org.apache.camel.support.SynchronizationAdapter;
+import org.apache.camel.support.*;","[{'comment': 'To import all packages is not preferable, did you run camel build with source check in order to pick up these issues?', 'commenter': 'omarsmak'}, {'comment': ""Yup, it didn't complain. This is how my IDE is set, i can revert it if it's a problem."", 'commenter': 'djoleB'}, {'comment': 'Pretty weird, it should complain. Can you please revert it?', 'commenter': 'omarsmak'}]"
3403,components/camel-http/src/test/java/org/apache/camel/component/http/HttpProducerCustomHeaderTest.java,"@@ -0,0 +1,105 @@
+package org.apache.camel.component.http;
+
+import org.apache.camel.Exchange;
+import org.apache.camel.component.http.handler.HeaderValidationHandler;
+import org.apache.http.impl.bootstrap.HttpServer;
+import org.apache.http.impl.bootstrap.ServerBootstrap;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+
+import java.util.HashMap;
+import java.util.Map;
+
+import static org.apache.http.HttpHeaders.HOST;
+
+public class HttpProducerCustomHeaderTest extends BaseHttpTest {
+
+    private static final String CUSTOM_HOST = ""test"";
+
+    private HttpServer localServer;
+
+    @Before
+    @Override
+    public void setUp() throws Exception {
+        Map<String, String> expectedHeaders = new HashMap<>();
+        expectedHeaders.put(HOST,
+                            CUSTOM_HOST);
+
+        localServer = ServerBootstrap.bootstrap().
+                setHttpProcessor(getBasicHttpProcessor()).
+                setConnectionReuseStrategy(getConnectionReuseStrategy()).
+                setResponseFactory(getHttpResponseFactory()).
+                setExpectationVerifier(getHttpExpectationVerifier()).
+                setSslContext(getSSLContext()).
+                registerHandler(""*"",
+                                new HeaderValidationHandler(""GET"",
+                                                            ""customHostHeader=test"",
+                                                            null,
+                                                            getExpectedContent(),
+                                                            expectedHeaders))
+                .registerHandler(""*"",
+                                 new HeaderValidationHandler(""GET"",
+                                                             null,
+                                                             null,
+                                                             getExpectedContent(),
+                                                             null))
+                .create();
+
+        localServer.start();
+
+        super.setUp();
+    }
+
+    @After
+    @Override
+    public void tearDown() throws Exception {
+        super.tearDown();
+
+        if (localServer != null) {
+            localServer.stop();
+        }
+    }
+
+    @Test
+    public void testHttpProducer_GivenCustomHostHeaderQuery_SetCustomHost() throws Exception {","[{'comment': 'Does the names of the test have to contain `_` ? ', 'commenter': 'omarsmak'}, {'comment': ""Of course it doesn't, i find it more readable this way.\r\n "", 'commenter': 'djoleB'}, {'comment': ""I would prefer if we don't use the underscore. Just to keep it consistent with what we have in the codebase"", 'commenter': 'omarsmak'}]"
3403,components/camel-http/src/main/java/org/apache/camel/component/http/HttpProducer.java,"@@ -61,17 +37,23 @@
 import org.apache.http.client.methods.HttpEntityEnclosingRequestBase;
 import org.apache.http.client.methods.HttpRequestBase;
 import org.apache.http.client.methods.HttpUriRequest;
-import org.apache.http.entity.ByteArrayEntity;
-import org.apache.http.entity.ContentType;
-import org.apache.http.entity.FileEntity;
-import org.apache.http.entity.InputStreamEntity;
-import org.apache.http.entity.StringEntity;
+import org.apache.http.entity.*;","[{'comment': 'Same goes here and other places as well', 'commenter': 'omarsmak'}]"
3403,components/camel-http/src/test/java/org/apache/camel/component/http/HttpProducerCustomHeaderTest.java,"@@ -0,0 +1,105 @@
+package org.apache.camel.component.http;
+
+import org.apache.camel.Exchange;
+import org.apache.camel.component.http.handler.HeaderValidationHandler;
+import org.apache.http.impl.bootstrap.HttpServer;
+import org.apache.http.impl.bootstrap.ServerBootstrap;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+
+import java.util.HashMap;
+import java.util.Map;
+
+import static org.apache.http.HttpHeaders.HOST;
+
+public class HttpProducerCustomHeaderTest extends BaseHttpTest {
+
+    private static final String CUSTOM_HOST = ""test"";
+
+    private HttpServer localServer;
+
+    @Before
+    @Override
+    public void setUp() throws Exception {
+        Map<String, String> expectedHeaders = new HashMap<>();
+        expectedHeaders.put(HOST,
+                            CUSTOM_HOST);
+
+        localServer = ServerBootstrap.bootstrap().
+                setHttpProcessor(getBasicHttpProcessor()).
+                setConnectionReuseStrategy(getConnectionReuseStrategy()).
+                setResponseFactory(getHttpResponseFactory()).
+                setExpectationVerifier(getHttpExpectationVerifier()).
+                setSslContext(getSSLContext()).
+                registerHandler(""*"",
+                                new HeaderValidationHandler(""GET"",
+                                                            ""customHostHeader=test"",
+                                                            null,
+                                                            getExpectedContent(),
+                                                            expectedHeaders))
+                .registerHandler(""*"",
+                                 new HeaderValidationHandler(""GET"",
+                                                             null,
+                                                             null,
+                                                             getExpectedContent(),
+                                                             null))
+                .create();
+
+        localServer.start();
+
+        super.setUp();
+    }
+
+    @After
+    @Override
+    public void tearDown() throws Exception {
+        super.tearDown();
+
+        if (localServer != null) {
+            localServer.stop();
+        }
+    }
+
+    @Test
+    public void testHttpProducer_GivenCustomHostHeaderQuery_SetCustomHost() throws Exception {
+
+        HttpComponent component = context.getComponent(""http"",
+                                                       HttpComponent.class);
+        component.setConnectionTimeToLive(1000L);
+
+        HttpEndpoint endpoint = (HttpEndpoint) component.createEndpoint(""http://"" + localServer.getInetAddress().getHostName() + "":""
+                                                                                + localServer.getLocalPort() + ""/myget?customHostHeader=test"");
+        HttpProducer producer = new HttpProducer(endpoint);
+
+        Exchange exchange = producer.createExchange();
+        exchange.getIn().setBody(null);
+
+        producer.start();
+        producer.process(exchange);
+        producer.stop();
+
+        assertExchange(exchange);","[{'comment': 'If not mistaken, this is will not assert the custom headers, is that correct? (mind you I have no details info about this component) ', 'commenter': 'omarsmak'}, {'comment': 'Check HeaderValidationHandler I set a Map with expected Headers and when component creates a request it will send request to local server defined in test and validate Host header there. Please correct me if I am wrong. :) Thanks for taking the time to check this PR.', 'commenter': 'djoleB'}, {'comment': ""Ah now it makes sense. I wondered before where the header assert is happening and I didn't pay attention to this part. Thanks for clarification :)"", 'commenter': 'omarsmak'}]"
3412,components/camel-infinispan/src/main/java/org/apache/camel/component/infinispan/InfinispanComponent.java,"@@ -69,7 +74,20 @@ protected Endpoint createEndpoint(String uri, String remaining, Map<String, Obje
         } else {
             conf = new InfinispanConfiguration();
         }
-        conf.setCacheContainer(cacheContainer);
+
+        String[] confParameters = new String[] {""hosts"", ""cacheContainerConfiguration"", ""configurationUri"", ""cacheContainer""};
+        //     init default embedded cache if config parameters aren't specified or cacheContainer is set using setMethod
+        if (!Arrays.stream(confParameters).anyMatch(parameters::containsKey) || setCacheFromComponent) {","[{'comment': 'you probably need to check also the values set on the `InfinispanConfiguration`', 'commenter': 'lburgazzoli'}, {'comment': 'Missed this one.', 'commenter': 'oscerd'}, {'comment': 'Thanks @lburgazzoli ', 'commenter': 'oscerd'}, {'comment': 'Is the `||` OR correct as the `setCacheFromComponent` is always true. So I think its is wrong, and it should be `&&` AND instead', 'commenter': 'davsclaus'}, {'comment': ""thanks. I didn't know about other possibilities of initialization. I added help method do determine whether configuration is provided or not. "", 'commenter': 'mmelko'}, {'comment': '@davsclaus actually `setCacheFromComponent` is almost never true, at least in tests which I provided. Usually cacheContainer is initialized in `InfinispanManager` class.', 'commenter': 'mmelko'}]"
3412,components/camel-infinispan/src/main/java/org/apache/camel/component/infinispan/InfinispanComponent.java,"@@ -59,6 +63,8 @@ public BasicCacheContainer getCacheContainer() {
      */
     public void setCacheContainer(BasicCacheContainer cacheContainer) {
         this.cacheContainer = cacheContainer;
+        this.setCacheFromComponent = true;
+        System.out.println(""===========<created"");","[{'comment': 'Remove', 'commenter': 'davsclaus'}]"
3413,components/camel-openapi-java/pom.xml,"@@ -0,0 +1,156 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one or more
+    contributor license agreements.  See the NOTICE file distributed with
+    this work for additional information regarding copyright ownership.
+    The ASF licenses this file to You under the Apache License, Version 2.0
+    (the ""License""); you may not use this file except in compliance with
+    the License.  You may obtain a copy of the License at
+
+         http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an ""AS IS"" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+
+-->
+<project xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xmlns=""http://maven.apache.org/POM/4.0.0""
+         xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"">
+    <modelVersion>4.0.0</modelVersion>
+
+    <parent>
+        <groupId>org.apache.camel</groupId>
+        <artifactId>components</artifactId>
+        <version>3.1.0-SNAPSHOT</version>
+    </parent>
+
+    <artifactId>camel-openapi-java</artifactId>
+    <packaging>jar</packaging>
+
+    <name>Camel :: OpenApi Java</name>
+    <description>Rest-dsl support for using openapi doc</description>
+
+    <properties>
+        <firstVersion>3.1.0</firstVersion>
+        <label>rest,api</label>
+
+        <camel.osgi.import.before.defaults>
+            com.fasterxml.jackson.*;version=""[2.9,3)""
+        </camel.osgi.import.before.defaults>
+    </properties>
+
+    <dependencies>
+
+        <!-- requires camel-core to have access to the camel model -->
+        <dependency>
+            <groupId>org.apache.camel</groupId>
+            <artifactId>camel-core-engine</artifactId>
+        </dependency>
+
+        <!-- json -->
+        <dependency>
+            <groupId>com.fasterxml.jackson.core</groupId>
+            <artifactId>jackson-annotations</artifactId>
+        </dependency>
+        <dependency>
+            <groupId>com.fasterxml.jackson.core</groupId>
+            <artifactId>jackson-databind</artifactId>
+        </dependency>
+        <dependency>
+            <groupId>com.fasterxml.jackson.datatype</groupId>
+            <artifactId>jackson-datatype-joda</artifactId>
+        </dependency>
+        <dependency>
+            <groupId>com.fasterxml.jackson.dataformat</groupId>
+            <artifactId>jackson-dataformat-yaml</artifactId>
+        </dependency>
+        <dependency>
+            <groupId>com.fasterxml.jackson.dataformat</groupId>
+            <artifactId>jackson-dataformat-xml</artifactId>
+        </dependency>
+        <dependency>
+            <groupId>com.fasterxml.jackson.jaxrs</groupId>
+            <artifactId>jackson-jaxrs-json-provider</artifactId>
+        </dependency>
+        <dependency>
+            <groupId>org.apache.commons</groupId>
+            <artifactId>commons-lang3</artifactId>
+            <version>${commons-lang3-version}</version>
+        </dependency>
+
+        <dependency>
+            <groupId>io.apicurio</groupId>
+            <artifactId>apicurio-data-models</artifactId>
+            <version>1.0.16.Final</version>","[{'comment': 'This could be in parent pom', 'commenter': 'oscerd'}]"
3413,components/camel-openapi-java/pom.xml,"@@ -0,0 +1,156 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one or more
+    contributor license agreements.  See the NOTICE file distributed with
+    this work for additional information regarding copyright ownership.
+    The ASF licenses this file to You under the Apache License, Version 2.0
+    (the ""License""); you may not use this file except in compliance with
+    the License.  You may obtain a copy of the License at
+
+         http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an ""AS IS"" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+
+-->
+<project xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xmlns=""http://maven.apache.org/POM/4.0.0""
+         xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"">
+    <modelVersion>4.0.0</modelVersion>
+
+    <parent>
+        <groupId>org.apache.camel</groupId>
+        <artifactId>components</artifactId>
+        <version>3.1.0-SNAPSHOT</version>
+    </parent>
+
+    <artifactId>camel-openapi-java</artifactId>
+    <packaging>jar</packaging>
+
+    <name>Camel :: OpenApi Java</name>
+    <description>Rest-dsl support for using openapi doc</description>
+
+    <properties>
+        <firstVersion>3.1.0</firstVersion>
+        <label>rest,api</label>
+
+        <camel.osgi.import.before.defaults>
+            com.fasterxml.jackson.*;version=""[2.9,3)""
+        </camel.osgi.import.before.defaults>
+    </properties>
+
+    <dependencies>
+
+        <!-- requires camel-core to have access to the camel model -->
+        <dependency>
+            <groupId>org.apache.camel</groupId>
+            <artifactId>camel-core-engine</artifactId>
+        </dependency>
+
+        <!-- json -->
+        <dependency>
+            <groupId>com.fasterxml.jackson.core</groupId>
+            <artifactId>jackson-annotations</artifactId>
+        </dependency>
+        <dependency>
+            <groupId>com.fasterxml.jackson.core</groupId>
+            <artifactId>jackson-databind</artifactId>
+        </dependency>
+        <dependency>
+            <groupId>com.fasterxml.jackson.datatype</groupId>
+            <artifactId>jackson-datatype-joda</artifactId>
+        </dependency>
+        <dependency>
+            <groupId>com.fasterxml.jackson.dataformat</groupId>
+            <artifactId>jackson-dataformat-yaml</artifactId>
+        </dependency>
+        <dependency>
+            <groupId>com.fasterxml.jackson.dataformat</groupId>
+            <artifactId>jackson-dataformat-xml</artifactId>
+        </dependency>
+        <dependency>
+            <groupId>com.fasterxml.jackson.jaxrs</groupId>
+            <artifactId>jackson-jaxrs-json-provider</artifactId>
+        </dependency>
+        <dependency>
+            <groupId>org.apache.commons</groupId>
+            <artifactId>commons-lang3</artifactId>
+            <version>${commons-lang3-version}</version>
+        </dependency>
+
+        <dependency>
+            <groupId>io.apicurio</groupId>
+            <artifactId>apicurio-data-models</artifactId>
+            <version>1.0.16.Final</version>
+        </dependency>
+
+
+        <!-- servlet api -->
+        <dependency>
+            <groupId>javax.servlet</groupId>
+            <artifactId>servlet-api</artifactId>
+            <version>2.5</version>","[{'comment': 'I think we could use a newest version?', 'commenter': 'oscerd'}]"
3414,components/camel-telegram/src/main/java/org/apache/camel/component/telegram/TelegramEndpoint.java,"@@ -46,17 +52,63 @@
 
     @UriParam
     private TelegramConfiguration configuration;
+    @UriParam(label = ""advanced"")
+    private AsyncHttpClientConfig clientConfig;
+    @UriParam(label = ""advanced"", defaultValue = """" + 4 * 1024)
+    private int bufferSize = 4 * 1024;
 
     private WebhookConfiguration webhookConfiguration;
 
-    public TelegramEndpoint(String endpointUri, Component component, TelegramConfiguration configuration) {
+    private AsyncHttpClient client;
+    private TelegramService telegramService;
+
+    public TelegramEndpoint(
+            String endpointUri,
+            Component component,
+            TelegramConfiguration configuration,
+            AsyncHttpClient client,
+            AsyncHttpClientConfig clientConfig) {
         super(endpointUri, component);
         this.configuration = configuration;
-        // setup the proxy setting here
-        if (ObjectHelper.isNotEmpty(configuration.getProxyHost()) && ObjectHelper.isNotEmpty(configuration.getProxyPort())) {
-            LOG.debug(""Setup http proxy host:{} port:{} for TelegramService"", configuration.getProxyHost(), configuration.getProxyPort());
-            TelegramServiceProvider.get().getService().setHttpProxy(configuration.getProxyHost(), configuration.getProxyPort());
+        this.client = client;
+        this.clientConfig = clientConfig;
+    }
+
+    @Override
+    protected void doStart() throws Exception {
+        super.doStart();
+        if (client == null) {
+            DefaultAsyncHttpClientConfig.Builder builder = clientConfig != null
+                    ? new DefaultAsyncHttpClientConfig.Builder(clientConfig)
+                    : new DefaultAsyncHttpClientConfig.Builder();
+
+            if (configuration != null && ObjectHelper.isNotEmpty(configuration.getProxyHost())
+                    && ObjectHelper.isNotEmpty(configuration.getProxyPort())) {
+                LOG.debug(""Setup http proxy host:{} port:{} for TelegramService"", configuration.getProxyHost(),
+                        configuration.getProxyPort());
+                builder.setProxyServer(
+                        new ProxyServer.Builder(configuration.getProxyHost(), configuration.getProxyPort()).build());
+            }
+            final AsyncHttpClientConfig config = builder.build();
+            client = new DefaultAsyncHttpClient(config);
+        }
+        if (telegramService == null) {
+            telegramService = new TelegramServiceRestBotAPIAdapter(
+                    client,
+                    4 * 1024,","[{'comment': 'This should probably be `bufferSize`', 'commenter': 'lburgazzoli'}, {'comment': 'Good catch, thanks!', 'commenter': 'ppalaga'}]"
3414,components/camel-telegram/src/main/java/org/apache/camel/component/telegram/model/InstantSerializer.java,"@@ -0,0 +1,36 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.telegram.model;
+
+import java.io.IOException;
+import java.time.Instant;
+
+import com.fasterxml.jackson.core.JsonGenerator;
+import com.fasterxml.jackson.databind.JsonSerializer;
+import com.fasterxml.jackson.databind.SerializerProvider;
+
+/**
+ * A serializer for {@link Instant} compatible with {@link UnixTimestampDeserializer}.
+ */
+public class InstantSerializer extends JsonSerializer<Instant> {","[{'comment': ""For my information, isn't this case covered by any of the jackson modules ?"", 'commenter': 'lburgazzoli'}, {'comment': 'Not sure which other Jackson modules you mean? \r\n\r\nSome test code now serializes IncomingMessages (which was not the case before this PR) and InstantSerializer is just a serializer symmetric to UnixTimestampDeserializer so that for an IncomingMessage m the following pseudo-expression is always true: serialize(deserialize(m)).equals(m)\r\n\r\nUnixTimestampDeserializer lives here so I thought InstantSerializer can also live in the same package.', 'commenter': 'ppalaga'}, {'comment': 'Jackson provides a module for java8 bits (https://github.com/FasterXML/jackson-modules-java8) that includes support for Instant & co. Not sure if it formats the Instant as expected here but worth investigating', 'commenter': 'lburgazzoli'}, {'comment': 'Searched in jackson-datatype-jsr310 and haven not found anything useful. The Telegram API is using epoch seconds without a point and fraction digits which seems to be non-standard.', 'commenter': 'ppalaga'}, {'comment': 'ok so fine to have our own impl, maybe we should just name the classes consistently ', 'commenter': 'lburgazzoli'}, {'comment': 'Done in 733c862', 'commenter': 'ppalaga'}]"
3414,components/camel-telegram/src/main/java/org/apache/camel/component/telegram/TelegramComponent.java,"@@ -20,15 +20,27 @@
 
 import org.apache.camel.Endpoint;
 import org.apache.camel.spi.Metadata;
+import org.apache.camel.spi.UriParam;
 import org.apache.camel.spi.annotations.Component;
 import org.apache.camel.support.DefaultComponent;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
 
 @Component(""telegram"")
 public class TelegramComponent extends DefaultComponent {
+    public static final String BOT_API_DEFAULT_URL = ""https://api.telegram.org"";
 
     @Metadata(label = ""security"", secret = true)
     private String authorizationToken;
 
+    @Metadata(label = ""advanced"")
+    private AsyncHttpClient client;
+    @Metadata(label = ""advanced"")
+    private AsyncHttpClientConfig clientConfig;
+
+    @UriParam(label = ""advanced"", defaultValue = BOT_API_DEFAULT_URL, description = ""Can be used to set an alternative base URI, e.g. when you want to test the component against a mock Telegram API"")","[{'comment': 'This should be @Metadata', 'commenter': 'davsclaus'}]"
3423,components/camel-rabbitmq/src/test/java/org/apache/camel/component/rabbitmq/RabbitMQDeadLetterRoutingKeyIntTest.java,"@@ -0,0 +1,129 @@
+package org.apache.camel.component.rabbitmq;","[{'comment': 'Please add the ASF license header here', 'commenter': 'oscerd'}]"
3433,components/camel-direct/src/main/java/org/apache/camel/component/direct/DirectProducer.java,"@@ -33,14 +33,14 @@ public DirectProducer(DirectEndpoint endpoint) {
     }
 
     @Override
+    @Deprecated","[{'comment': 'start and stop methods should not be deprecated, since they dont do anything then just remove them so they just use from parent', 'commenter': 'davsclaus'}]"
3433,components/camel-direct/src/main/java/org/apache/camel/component/direct/DirectEndpoint.java,"@@ -97,17 +94,11 @@ public void removeConsumer(DirectConsumer consumer) {
         }
     }
 
-    public void addProducer(DirectProducer producer) {
-        synchronized (consumers) {
-            producers.add(producer);
-        }
-    }
+    @Deprecated","[{'comment': 'Its very likely fine to remove in he near future as nobody is extending direct component', 'commenter': 'davsclaus'}, {'comment': 'I have updated the pull request to remove the methods (not sure if I understood you correctly).', 'commenter': 'PascalSchumacher'}]"
3439,components/camel-cmis/src/main/java/org/apache/camel/component/cmis/CMISProducer.java,"@@ -160,9 +261,11 @@ public void deleteDocument(Exchange exchange) throws Exception {
         Message message = exchange.getIn();
 
         String objectId = message.getHeader(CamelCMISConstants.CMIS_OBJECT_ID, String.class);
+        Boolean allVersions = Boolean.valueOf(message.getHeader(CamelCMISConstants.ALL_VERSIONS, String.class));","[{'comment': 'You can just say\r\n\r\nmessage.getHeader(xxx, Boolean.class)', 'commenter': 'davsclaus'}]"
3439,components/camel-cmis/src/main/java/org/apache/camel/component/cmis/CamelCMISConstants.java,"@@ -29,5 +29,7 @@
     String CAMEL_CMIS_RETRIEVE_CONTENT = ""CamelCMISRetrieveContent"";
     String CAMEL_CMIS_READ_SIZE = ""CamelCMISReadSize"";
     String CAMEL_CMIS_CONTENT_STREAM = ""CamelCMISContent"";
+    String ALL_VERSIONS = ""allVersions"";","[{'comment': 'CamelCMISAllVersions', 'commenter': 'davsclaus'}]"
3439,components/camel-cmis/src/main/java/org/apache/camel/component/cmis/CMISProducer.java,"@@ -16,8 +16,11 @@
  */
 package org.apache.camel.component.cmis;
 
+import java.awt.Stroke;","[{'comment': 'What is this used for smells like it should be removed', 'commenter': 'davsclaus'}]"
3459,components/camel-kafka/src/main/java/org/apache/camel/component/kafka/KafkaProducer.java,"@@ -181,34 +171,67 @@ protected void doStop() throws Exception {
         if (iterator != null) {
             final Iterator<Object> msgList = iterator;
             final String msgTopic = topic;
-            return new Iterator<ProducerRecord>() {
+            return new Iterator<Pair<Object, ProducerRecord>>() {
                 @Override
                 public boolean hasNext() {
                     return msgList.hasNext();
                 }
 
                 @Override
-                public ProducerRecord next() {
+                public Pair<Object, ProducerRecord> next() {","[{'comment': 'Sorry, I am bit confused here, was there a logical reason to use `pair` with the message body?', 'commenter': 'omarsmak'}, {'comment': 'If the left of pair is instance of Message or Exchange it will then be used to set metadata on this Exchange/Message instance. If this is instance of something else, no metadata will be set at all.\r\n\r\nIf we return only the ProducerRecord, we loose information to what Message/Exchange it refers to and we cannot set metadata returned by Kafka producer.', 'commenter': 'rgala'}]"
3459,components/camel-kafka/src/main/java/org/apache/camel/component/kafka/KafkaProducer.java,"@@ -365,7 +468,9 @@ boolean allSent() {
         @Override
         public void onCompletion(RecordMetadata recordMetadata, Exception e) {
             if (e != null) {
-                exchange.setException(e);
+                if(body instanceof Exchange) {","[{'comment': 'I wonder if you should also check for instanceof Message here, and if its a message, you can use message -> getExchange to get that to set the exception.', 'commenter': 'davsclaus'}, {'comment': 'Added as requested. I also wonder if checking of null result of getExchange would not be a good idea.', 'commenter': 'rgala'}, {'comment': 'Yeah you can do that', 'commenter': 'davsclaus'}]"
3473,components/camel-salesforce/camel-salesforce-component/src/main/java/org/apache/camel/component/salesforce/internal/streaming/SubscriptionHelper.java,"@@ -16,6 +16,16 @@
  */
 package org.apache.camel.component.salesforce.internal.streaming;
 
+import static java.util.concurrent.TimeUnit.MILLISECONDS;","[{'comment': 'Please run the build with the sourcecheck profile enabled, the static part must be at the end of the imports listing.', 'commenter': 'oscerd'}]"
3473,components/camel-salesforce/camel-salesforce-component/src/main/java/org/apache/camel/component/salesforce/internal/streaming/SubscriptionHelper.java,"@@ -99,50 +99,51 @@ public SubscriptionHelper(final SalesforceComponent component) throws Salesforce
 
         this.listenerMap = new ConcurrentHashMap<>();
 
-        restartBackoff = new AtomicLong(0);
-        backoffIncrement = component.getConfig().getBackoffIncrement();
-        maxBackoff = component.getConfig().getMaxBackoff();
+        this.restartBackoff = new AtomicLong(0);
+        this.backoffIncrement = component.getConfig().getBackoffIncrement();
+        this.maxBackoff = component.getConfig().getMaxBackoff();
     }
 
     @Override
     protected void doStart() throws Exception {
 
         // create CometD client
-        this.client = createClient(component);
+        this.client = createClient(this.component);
 
         // reset all error conditions
-        handshakeError = null;
-        handshakeException = null;
-        connectError = null;
-        connectException = null;
+        this.handshakeError = null;
+        this.handshakeException = null;
+        this.connectError = null;
+        this.connectException = null;
 
         // listener for handshake error or exception
-        if (handshakeListener == null) {
+        if (this.handshakeListener == null) {
             // first start
-            handshakeListener = new ClientSessionChannel.MessageListener() {
-                public void onMessage(ClientSessionChannel channel, Message message) {
+            this.handshakeListener = new ClientSessionChannel.MessageListener() {
+                @Override
+                public void onMessage(final ClientSessionChannel channel, final Message message) {
                     LOG.debug(""[CHANNEL:META_HANDSHAKE]: {}"", message);
 
                     if (!message.isSuccessful()) {
                         LOG.warn(""Handshake failure: {}"", message);
-                        handshakeError = (String)message.get(ERROR_FIELD);
-                        handshakeException = getFailure(message);
+                        SubscriptionHelper.this.handshakeError = (String)message.get(ERROR_FIELD);","[{'comment': 'What is the reason to add `SubscriptionHelper.this` for these properties? IMHO it makes the code a bit chaotic, same goes for `this`.', 'commenter': 'omarsmak'}, {'comment': 'Sorry is my mistake... (default configuration of my IDE). I fix this.', 'commenter': 'jbdefard'}, {'comment': 'I commited a more correct patch', 'commenter': 'jbdefard'}]"
3476,core/camel-management/src/main/java/org/apache/camel/management/DefaultManagementObjectNameStrategy.java,"@@ -497,7 +497,7 @@ protected String getContextId(CamelContext context) {
     }
 
     protected String getContextId(String name) {
-        Boolean includeHostName = camelContext != null && camelContext.getManagementStrategy().getManagementAgent().getIncludeHostName();
+        boolean includeHostName = camelContext != null && camelContext.getManagementStrategy().getManagementAgent().getIncludeHostName();
         if (includeHostName != null && includeHostName) {","[{'comment': 'primitive boolean cannot be compared with null.', 'commenter': 'bedlaj'}]"
3476,core/camel-management/src/main/java/org/apache/camel/management/DefaultManagementObjectNameStrategy.java,"@@ -507,7 +507,7 @@ protected String getContextId(String name) {
 
     protected String getEndpointId(Endpoint ep) {
         String answer = doGetEndpointId(ep);
-        Boolean sanitize = camelContext != null && camelContext.getManagementStrategy().getManagementAgent().getMask();
+        boolean sanitize = camelContext != null && camelContext.getManagementStrategy().getManagementAgent().getMask();
         if (sanitize != null && sanitize) {","[{'comment': 'primitive boolean cannot be compared with null.', 'commenter': 'bedlaj'}]"
3478,core/camel-support/src/main/java/org/apache/camel/support/DefaultComponent.java,"@@ -406,17 +407,25 @@ protected void doInit() throws Exception {
                 name = StringHelper.before(name, "","");
             }
             try {
+                final Registry registry = getCamelContext().getRegistry();
                 log.trace(""Discovering optional component property configurer class for component: {}"", name);
-                Optional<Class<?>> clazz = getCamelContext().adapt(ExtendedCamelContext.class).getFactoryFinder(RESOURCE_PATH)
-                        .findOptionalClass(name + ""-component"", null);
-                clazz.ifPresent(c -> componentPropertyConfigurer = org.apache.camel.support.ObjectHelper.newInstance(c, GeneratedPropertyConfigurer.class));
+                componentPropertyConfigurer = registry.lookupByNameAndType(name + ""-component"", GeneratedPropertyConfigurer.class);","[{'comment': 'The name should have -configurer, eg -component-configurer', 'commenter': 'davsclaus'}, {'comment': ""That would introduce a discrepancy between the name of the property file and the name used for the registration of the service in the Camel registry. That would in turn require special code for registering the configurers in Camel Quarkus, which I think we'd like to avoid ( cc @lburgazzoli ?) So if you really want the registry name to have the `-configurer` suffix, could we please also rename the property files?"", 'commenter': 'ppalaga'}, {'comment': 'I have added 14c5188 that renames both the property files and the keys used to register the configurers to the registry.', 'commenter': 'ppalaga'}, {'comment': 'The name of the property file is based on its FQN folder name, where its parent folder name is configurer. Not sure what you do on the quarkus side, but you should not change the APT code ', 'commenter': 'davsclaus'}, {'comment': 'OK, let me remove the second commit.\r\n\r\nBack to your original proposal\r\n\r\n> The name should have -configurer, eg -component-configurer\r\n\r\nCould you please explain why? I just want to understand your motivation.', 'commenter': 'ppalaga'}, {'comment': 'The registry is end user facing and they can register things too, and some register components with foo-component, etc so you end up with naming clashes too.\r\n', 'commenter': 'davsclaus'}]"
3478,core/camel-support/src/main/java/org/apache/camel/support/DefaultComponent.java,"@@ -406,17 +407,25 @@ protected void doInit() throws Exception {
                 name = StringHelper.before(name, "","");
             }
             try {
+                final Registry registry = getCamelContext().getRegistry();
                 log.trace(""Discovering optional component property configurer class for component: {}"", name);
-                Optional<Class<?>> clazz = getCamelContext().adapt(ExtendedCamelContext.class).getFactoryFinder(RESOURCE_PATH)
-                        .findOptionalClass(name + ""-component"", null);
-                clazz.ifPresent(c -> componentPropertyConfigurer = org.apache.camel.support.ObjectHelper.newInstance(c, GeneratedPropertyConfigurer.class));
+                componentPropertyConfigurer = registry.lookupByNameAndType(name + ""-component"", GeneratedPropertyConfigurer.class);
+                if (componentPropertyConfigurer == null) {
+                    final Optional<Class<?>> clazz = getCamelContext().adapt(ExtendedCamelContext.class).getFactoryFinder(RESOURCE_PATH)
+                            .findOptionalClass(name + ""-component"", null);
+                    clazz.ifPresent(c -> componentPropertyConfigurer = org.apache.camel.support.ObjectHelper.newInstance(c, GeneratedPropertyConfigurer.class));
+                }
                 if (log.isDebugEnabled() && componentPropertyConfigurer != null) {
                     log.debug(""Discovered component property configurer: {} -> {}"", name, componentPropertyConfigurer);
                 }
+
                 log.trace(""Discovering optional endpoint property configurer class for component: {}"", name);
-                clazz = getCamelContext().adapt(ExtendedCamelContext.class).getFactoryFinder(RESOURCE_PATH)
-                        .findOptionalClass(name + ""-endpoint"", null);
-                clazz.ifPresent(c -> endpointPropertyConfigurer = org.apache.camel.support.ObjectHelper.newInstance(c, GeneratedPropertyConfigurer.class));
+                endpointPropertyConfigurer = registry.lookupByNameAndType(name + ""-endpoint"", GeneratedPropertyConfigurer.class);","[{'comment': 'The name should have -configurer, eg -endpoint-configurer', 'commenter': 'davsclaus'}]"
3491,core/camel-endpointdsl/src/main/java/org/apache/camel/builder/endpoint/dsl/ServiceNowEndpointBuilderFactory.java,"@@ -1034,7 +1034,7 @@ default AdvancedServiceNowEndpointBuilder timeFormat(String timeFormat) {
 
     public interface ServiceNowBuilders {
         /**
-         * ServiceNow (camel-servicenow)
+         * ServiceNow (@@@ARTIFACTID@@@)","[{'comment': 'This is really weird.', 'commenter': 'oscerd'}, {'comment': 'I think is something else, not from the endpointdsl MOJO, looks like the generated `json` for this component has this `@@@ARTIFACTID@@@`', 'commenter': 'omarsmak'}, {'comment': 'Did you rebuild everything without fastinstall and -DskipTests?', 'commenter': 'oscerd'}, {'comment': 'Nope I built it with fastinstall, could be that? ', 'commenter': 'omarsmak'}, {'comment': 'There were a lot of changes yesterday so I would go with a full rebuild in this case.', 'commenter': 'oscerd'}]"
3508,components/camel-mail/src/main/java/org/apache/camel/component/mail/MailConsumer.java,"@@ -95,6 +95,30 @@ protected void doStop() throws Exception {
         super.doStop();
     }
 
+    /**
+     * Returns the max number of messages to be processed. Will return -1 if no maximum is set
+     *
+     * @return","[{'comment': 'please remove this', 'commenter': 'oscerd'}, {'comment': ""Comment removed. I'm not familiar with the adoc. Can you elaborate what to do here?"", 'commenter': 'mash-sap'}]"
3508,components/camel-mail/src/main/java/org/apache/camel/component/mail/MailConsumer.java,"@@ -95,6 +95,25 @@ protected void doStop() throws Exception {
         super.doStop();
     }
 ","[{'comment': ""I meant only the '@return' part :-)"", 'commenter': 'oscerd'}, {'comment': 'Ok. I understood to put the comment in the adoc instead. I updated the commit. Please check :)', 'commenter': 'mash-sap'}, {'comment': 'My fault. It looks good. When you can please a note about the change in the adoc, not this comment :-)', 'commenter': 'oscerd'}, {'comment': ""Sorry, I'm not familiar with the adoc. Do I need a editor for it? Where should I document my change? I could not see a suitable place in the mail-component.adoc."", 'commenter': 'mash-sap'}, {'comment': 'You just need to add a section here https://github.com/apache/camel/blob/master/components/camel-mail/src/main/docs/mail-component.adoc\r\n\r\nBy the way, no problem, we can do this later.', 'commenter': 'oscerd'}, {'comment': ""Sorry I still don't get it :) What exactly you like me to document? The commit is just code optimization, right? :)"", 'commenter': 'mash-sap'}, {'comment': ""Usually people notice performance optmizations, but sometime for special cases people may also note problems, so we need to add a note about what you've done between 3.0 and 3.1"", 'commenter': 'oscerd'}, {'comment': 'I updated the mail.component.adoc. Please have a look.', 'commenter': 'mash-sap'}]"
3512,components/camel-workday/pom.xml,"@@ -0,0 +1,83 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>org.apache.camel</groupId>
+    <artifactId>components</artifactId>
+    <version>3.1.0-SNAPSHOT</version>
+  </parent>
+
+  <artifactId>camel-workday</artifactId>
+  <packaging>jar</packaging>
+
+  <name>Camel :: Workday</name>
+  <description>Camel Workday support</description>
+
+  <properties>
+    <camel.osgi.export.pkg>org.apache.camel.component.workday.*</camel.osgi.export.pkg>","[{'comment': 'Not needed anymore, in Camel 3.', 'commenter': 'oscerd'}, {'comment': 'I removed those properties.', 'commenter': 'favalos'}]"
3512,components/camel-workday/pom.xml,"@@ -0,0 +1,83 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>org.apache.camel</groupId>
+    <artifactId>components</artifactId>
+    <version>3.1.0-SNAPSHOT</version>
+  </parent>
+
+  <artifactId>camel-workday</artifactId>
+  <packaging>jar</packaging>
+
+  <name>Camel :: Workday</name>
+  <description>Camel Workday support</description>
+
+  <properties>
+    <camel.osgi.export.pkg>org.apache.camel.component.workday.*</camel.osgi.export.pkg>
+    <camel.osgi.export.service>org.apache.camel.spi.ComponentResolver;component=workday</camel.osgi.export.service>","[{'comment': 'Not needed anymore in Camel 3', 'commenter': 'oscerd'}, {'comment': 'Removed the properties.', 'commenter': 'favalos'}]"
3512,components/camel-workday/pom.xml,"@@ -0,0 +1,83 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>org.apache.camel</groupId>
+    <artifactId>components</artifactId>
+    <version>3.1.0-SNAPSHOT</version>
+  </parent>
+
+  <artifactId>camel-workday</artifactId>
+  <packaging>jar</packaging>
+
+  <name>Camel :: Workday</name>
+  <description>Camel Workday support</description>
+
+  <properties>
+    <camel.osgi.export.pkg>org.apache.camel.component.workday.*</camel.osgi.export.pkg>
+    <camel.osgi.export.service>org.apache.camel.spi.ComponentResolver;component=workday</camel.osgi.export.service>
+  </properties>
+
+  <dependencies>
+    <dependency>
+      <groupId>commons-httpclient</groupId>","[{'comment': 'Please use a newer HTTP client like httpcomponents, the last release of commons-httpclient is from 2007', 'commenter': 'oscerd'}, {'comment': 'Changed to HttpComponents-client,', 'commenter': 'favalos'}]"
3512,components/camel-workday/pom.xml,"@@ -0,0 +1,83 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>org.apache.camel</groupId>
+    <artifactId>components</artifactId>
+    <version>3.1.0-SNAPSHOT</version>
+  </parent>
+
+  <artifactId>camel-workday</artifactId>
+  <packaging>jar</packaging>
+
+  <name>Camel :: Workday</name>
+  <description>Camel Workday support</description>
+
+  <properties>
+    <camel.osgi.export.pkg>org.apache.camel.component.workday.*</camel.osgi.export.pkg>
+    <camel.osgi.export.service>org.apache.camel.spi.ComponentResolver;component=workday</camel.osgi.export.service>
+  </properties>
+
+  <dependencies>
+    <dependency>
+      <groupId>commons-httpclient</groupId>
+      <artifactId>commons-httpclient</artifactId>
+    </dependency>
+    <dependency>
+      <groupId>org.apache.camel</groupId>
+      <artifactId>camel-support</artifactId>
+    </dependency>
+
+    <dependency>
+      <groupId>org.apache.camel</groupId>
+      <artifactId>camel-core</artifactId>
+    </dependency>
+    
+    <!-- support camel documentation -->
+    <dependency>
+      <groupId>org.apache.camel</groupId>
+      <artifactId>apt</artifactId>
+    </dependency>
+    
+    <!-- logging -->
+    <dependency>
+      <groupId>org.apache.logging.log4j</groupId>
+      <artifactId>log4j-api</artifactId>
+      <version>2.12.1</version>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.apache.logging.log4j</groupId>
+      <artifactId>log4j-core</artifactId>
+      <version>2.12.1</version>","[{'comment': 'Please use the property placeholder coming from the parent pom.', 'commenter': 'oscerd'}, {'comment': 'Removed the version using from parent dependency management.', 'commenter': 'favalos'}]"
3512,components/camel-workday/src/main/java/org/apache/camel/component/workday/WorkdayComponent.java,"@@ -0,0 +1,120 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.workday;
+
+import java.util.Map;
+import java.util.stream.Collectors;
+
+import org.apache.camel.Endpoint;
+import org.apache.camel.ResolveEndpointFailedException;
+import org.apache.camel.support.DefaultComponent;
+import org.apache.camel.spi.Metadata;
+import org.apache.camel.spi.annotations.Component;
+import org.apache.commons.httpclient.HttpClient;
+import org.apache.commons.httpclient.HttpConnectionManager;
+import org.apache.commons.httpclient.MultiThreadedHttpConnectionManager;
+
+/**
+ * Represents the component that manages {@link WorkdayEndpoint}.
+ */
+@Component(""workday"")
+public class WorkdayComponent extends DefaultComponent {
+
+    public static final String RAAS_ENDPOINT_URL = ""https://%s/ccx/service/customreport2/%s%s"";
+
+    private HttpClient httpClient;
+
+    @Metadata(label=""advanced"")
+    private WorkdayConfiguration workdayConfiguration;
+
+    protected Endpoint createEndpoint(String uri, String remaining, Map<String, Object> parameters) throws Exception {
+        WorkdayConfiguration workdayConfiguration = new WorkdayConfiguration();
+
+        setProperties(workdayConfiguration, parameters);","[{'comment': ""This shouldn't be done, we just need to setProperties on the endpoint, so the second one should be sufficient, take a look at the other components."", 'commenter': 'oscerd'}, {'comment': 'Removed the first call, the endpoint was updated to handle the properties.', 'commenter': 'favalos'}]"
3512,components/camel-workday/src/main/java/org/apache/camel/component/workday/WorkdayEndpoint.java,"@@ -0,0 +1,68 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.workday;
+
+import org.apache.camel.Consumer;
+import org.apache.camel.NoSuchEndpointException;
+import org.apache.camel.Processor;
+import org.apache.camel.Producer;
+import org.apache.camel.support.DefaultEndpoint;
+import org.apache.camel.spi.Metadata;
+import org.apache.camel.spi.UriEndpoint;
+import org.apache.camel.spi.UriPath;
+
+/**
+ * Represents a camel-workday endpoint.
+ */
+
+@UriEndpoint(firstVersion = ""3.0.0-SNAPSHOT"", scheme = ""workday-raas"", title = ""Workday"", syntax=""workday-raas:uri"", label=""hcm"")","[{'comment': 'First version is 3.1.0-SNAPSHOT', 'commenter': 'oscerd'}, {'comment': 'Updated the version.', 'commenter': 'favalos'}]"
3512,components/camel-workday/src/test/java/org/apache/camel/WorkdayComponentConfigurationTest.java,"@@ -0,0 +1,75 @@
+package org.apache.camel;
+
+import org.apache.camel.component.workday.WorkdayComponent;
+import org.apache.camel.component.workday.WorkdayConfiguration;
+import org.apache.camel.component.workday.WorkdayEndpoint;
+import org.apache.camel.test.junit4.CamelTestSupport;
+import org.junit.Test;
+
+public class WorkdayComponentConfigurationTest extends CamelTestSupport {
+
+    @Test
+    public void createProducerMinimalConfiguration() throws Exception {
+
+        WorkdayComponent workdayComponent = context.getComponent(""workday"", WorkdayComponent.class);
+
+        WorkdayEndpoint workdayEndpoint = (WorkdayEndpoint)workdayComponent.createEndpoint(""workday-raas:/<Owner>/<ReportName>?"" +
+        ""host=impl.workday.com"" +
+                ""&tenant=camel"" +
+                ""&clientId=f7014d38-99d2-4969-b740-b5b62db6b46a"" +","[{'comment': 'Could this stuff be public and published in this way?', 'commenter': 'oscerd'}, {'comment': 'No real data, Used only to validate the configuration in the test.', 'commenter': 'favalos'}]"
3512,components/camel-workday/src/main/java/org/apache/camel/component/workday/WorkdayConfiguration.java,"@@ -0,0 +1,111 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.camel.component.workday;
+
+import org.apache.camel.spi.Metadata;
+import org.apache.commons.httpclient.HttpConnectionManager;
+
+import org.apache.camel.spi.UriParams;
+import org.apache.camel.spi.UriParam;
+
+@UriParams
+public class WorkdayConfiguration {
+
+    @UriParam(label = ""security"", secret = true)
+    @Metadata(required = true)
+    private String clientId;
+
+    @UriParam(label = ""security"", secret = true)
+    @Metadata(required = true)
+    private String clientSecret;
+
+    @UriParam(label = ""security"", secret = true)
+    @Metadata(required = true)
+    private String tokenRefresh;
+
+    @UriParam(label = ""host"")
+    @Metadata(required = true)
+    private String host;
+
+    @UriParam(label = ""tenant"")
+    @Metadata(required = true)
+    private String tenant;
+
+    @UriParam(label = ""format"")
+    private String format = ""json"";
+
+    @UriParam(label = ""advanced"")
+    private HttpConnectionManager httpConnectionManager;
+
+    public String getClientId() {","[{'comment': 'Documentations are missing for the configurations here', 'commenter': 'omarsmak'}]"
3512,components/camel-workday/src/main/java/org/apache/camel/component/workday/WorkdayEndpoint.java,"@@ -0,0 +1,68 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.workday;
+
+import org.apache.camel.Consumer;
+import org.apache.camel.NoSuchEndpointException;
+import org.apache.camel.Processor;
+import org.apache.camel.Producer;
+import org.apache.camel.support.DefaultEndpoint;
+import org.apache.camel.spi.Metadata;
+import org.apache.camel.spi.UriEndpoint;
+import org.apache.camel.spi.UriPath;
+
+/**
+ * Represents a camel-workday endpoint.
+ */
+
+@UriEndpoint(firstVersion = ""3.0.0-SNAPSHOT"", scheme = ""workday-raas"", title = ""Workday"", syntax=""workday-raas:uri"", label=""hcm"")
+public class WorkdayEndpoint extends DefaultEndpoint {
+
+    @UriPath(description = ""The partial URL for RAAS report."")
+    @Metadata(required = true)
+    private String uri;
+
+    public WorkdayEndpoint() {
+    }
+
+    public WorkdayEndpoint(String uri, WorkdayComponent component) {
+        super(uri, component);
+    }
+
+    public Producer createProducer() throws Exception {
+
+        return new WorkdayProducer(this, uri);
+    }
+
+    public Consumer createConsumer(Processor processor) throws Exception {
+
+        throw new NoSuchEndpointException(""Workday producer is not implemented."");","[{'comment': 'You meant a consumer here I guess?', 'commenter': 'omarsmak'}]"
3512,components/camel-workday/src/main/java/org/apache/camel/component/workday/WorkdayProducer.java,"@@ -0,0 +1,89 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.workday;
+
+import org.apache.camel.Exchange;
+import org.apache.camel.component.workday.auth.AuthClientForIntegration;
+import org.apache.camel.component.workday.auth.AutheticationClient;
+import org.apache.camel.support.DefaultProducer;
+import org.apache.commons.httpclient.HttpClient;
+import org.apache.commons.httpclient.HttpStatus;
+import org.apache.commons.httpclient.methods.GetMethod;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * The camel-workday producer.
+ */
+public class WorkdayProducer extends DefaultProducer {
+
+    public static final String WORKDAY_RAAS_HEADER = ""CamelWorkdayRAAS"";
+
+    private static final Logger LOG = LoggerFactory.getLogger(WorkdayProducer.class);
+
+    private String workdayUri;
+
+    private WorkdayEndpoint endpoint;
+
+    private WorkdayComponent component;
+
+    private AutheticationClient autheticationClient;
+
+    public WorkdayProducer(WorkdayEndpoint endpoint, String workdayUri) {
+        super(endpoint);
+        this.endpoint = endpoint;
+        this.workdayUri = workdayUri;
+        this.component = (WorkdayComponent)this.endpoint.getComponent();
+        this.autheticationClient = new AuthClientForIntegration(
+                this.component.getWorkdayConfiguration()
+            );
+    }
+
+    @Override
+    public WorkdayEndpoint getEndpoint() {
+        return (WorkdayEndpoint) super.getEndpoint();
+    }
+
+    public void process(Exchange exchange) throws Exception {
+
+        HttpClient httpClient = this.component.getHttpClient();
+
+        GetMethod getMethod  = new GetMethod(workdayUri);
+        this.autheticationClient.configure(httpClient, getMethod);
+
+        try {
+            int statusCode = httpClient.executeMethod(getMethod);
+
+            if (statusCode != HttpStatus.SC_OK) {
+                throw new IllegalStateException(""Got the invalid http status value '"" + getMethod.getStatusLine() + ""' as the result of the RAAS '"" + workdayUri + ""'"");
+            }
+
+            String report = getEndpoint().getCamelContext().getTypeConverter().mandatoryConvertTo(String.class, getMethod.getResponseBodyAsStream());
+
+            if ("""".equals(report)) {","[{'comment': 'I think would be more efficient to use `report.isEmpty()`', 'commenter': 'omarsmak'}]"
3512,components/camel-workday/src/main/java/org/apache/camel/component/workday/auth/AuthClientForIntegration.java,"@@ -0,0 +1,111 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.camel.component.workday.auth;
+
+import org.apache.camel.component.workday.WorkdayConfiguration;
+import org.apache.commons.httpclient.HttpClient;
+import org.apache.commons.httpclient.HttpMethodBase;
+import org.apache.commons.httpclient.HttpStatus;
+import org.apache.commons.httpclient.methods.PostMethod;
+
+import java.io.IOException;
+import java.util.Base64;
+
+public class AuthClientForIntegration implements AutheticationClient {
+
+    private static final String GRANT_TYPE = ""grant_type"";
+
+    private static final String REFRESH_TOKEN = ""refresh_token"";
+
+    private static final String CONTENT_TYPE_HEADER = ""Content-Type"";
+
+    private static final String AUTHORIZATION_HEADER = ""Authorization"";
+
+    private static final String ACCESS_TOKEN = ""access_token"";
+
+    private static final String CONTENT_TYPE = ""application/x-www-form-urlencoded"";
+
+    public static final String BASE_TOKEN_ENDPOINT = ""https://%s/ccx/oauth2/%s/token"";
+
+    private WorkdayConfiguration workdayConfiguration;
+
+    public AuthClientForIntegration(WorkdayConfiguration workdayConfiguration) {
+        this.workdayConfiguration = workdayConfiguration;
+    }
+
+    @Override
+    public void configure(HttpClient httpClient, HttpMethodBase method) {
+
+        String bearerToken = getBearerToken(httpClient);
+        method.addRequestHeader(AUTHORIZATION_HEADER, ""Bearer "" + bearerToken);
+
+    }
+
+    protected String getBearerToken(HttpClient httpClient) {
+
+        String tokenUrl = String.format(BASE_TOKEN_ENDPOINT,
+                workdayConfiguration.getHost(),
+                workdayConfiguration.getTenant());
+
+        PostMethod postMethod = createPostMethod(tokenUrl);
+
+        try {
+            int statusCode = httpClient.executeMethod(postMethod);
+
+            if (statusCode != HttpStatus.SC_OK) {
+                throw new IllegalStateException(""Got the invalid http status value '"" + postMethod.getStatusLine() + ""' as the result of the Token Request '"" + tokenUrl + ""'"");
+            }
+
+            String response = postMethod.getResponseBodyAsString();
+            return parseResponse(response);
+
+        } catch (IOException e) {
+            e.printStackTrace();","[{'comment': ""I'd throw an `RuntimeException` instead of printing the stack trace"", 'commenter': 'omarsmak'}]"
3512,components/camel-workday/src/test/java/org/apache/camel/WorkdayComponentConfigurationTest.java,"@@ -0,0 +1,75 @@
+package org.apache.camel;
+
+import org.apache.camel.component.workday.WorkdayComponent;
+import org.apache.camel.component.workday.WorkdayConfiguration;
+import org.apache.camel.component.workday.WorkdayEndpoint;
+import org.apache.camel.test.junit4.CamelTestSupport;
+import org.junit.Test;
+
+public class WorkdayComponentConfigurationTest extends CamelTestSupport {","[{'comment': ""I am actually bit confused about naming. I'd go for something like WorkdayComponentTest` since you are testing the component itself"", 'commenter': 'omarsmak'}]"
3512,components/camel-graphql/src/main/docs/graphql-component.adoc,"@@ -37,7 +37,7 @@ with the following path and query parameters:
 
 
 [width=""100%"",cols=""2,5,^1,2"",options=""header""]
-|===
+|===http","[{'comment': 'Please remove this one, Graphql is a different component.', 'commenter': 'oscerd'}]"
3517,components/camel-rabbitmq/src/test/java/org/apache/camel/component/rabbitmq/RabbitMQConsumerIntTest.java,"@@ -121,15 +123,18 @@ public void sentMessageWithTimestampIsReceived() throws InterruptedException, IO
      */
     @Test
     public void sentMessageIsReceivedWithHeadersRouting() throws InterruptedException, IOException, TimeoutException {
-        //should only be one message that makes it through because only
-        //one has the correct header set
+        // Should only be one message that makes it through,
+        // because only one has the correct header set
         to.expectedMessageCount(1);
 
         Channel channel = connection().createChannel();
         channel.basicPublish(HEADERS_EXCHANGE, """", propertiesWithHeader(""foo"", ""bar""), MSG.getBytes());
         channel.basicPublish(HEADERS_EXCHANGE, """", null, MSG.getBytes());
         channel.basicPublish(HEADERS_EXCHANGE, """", propertiesWithHeader(""foo"", ""bra""), MSG.getBytes());
 
+        // Only one message should be received, waiting for some other messages
+        Thread.sleep(500);","[{'comment': 'Maybe you could use Awaitility for this purpose.', 'commenter': 'oscerd'}, {'comment': 'Thanks, fixed', 'commenter': 'DenisIstomin'}]"
3518,components/camel-jira/src/main/java/org/apache/camel/component/jira/producer/AddWorkLogProducer.java,"@@ -0,0 +1,62 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * <p>
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * <p>
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.jira.producer;
+
+import static org.apache.camel.component.jira.JiraConstants.ISSUE_KEY;
+import static org.apache.camel.component.jira.JiraConstants.MINUTES_SPENT;
+
+import com.atlassian.jira.rest.client.api.IssueRestClient;
+import com.atlassian.jira.rest.client.api.JiraRestClient;
+import com.atlassian.jira.rest.client.api.domain.Issue;
+import com.atlassian.jira.rest.client.api.domain.input.WorklogInput;
+import org.apache.camel.Exchange;
+import org.apache.camel.component.jira.JiraEndpoint;
+import org.apache.camel.support.DefaultProducer;
+import org.joda.time.DateTime;
+
+public class AddWorkLogProducer extends DefaultProducer {
+
+    public AddWorkLogProducer(JiraEndpoint endpoint) {
+        super(endpoint);
+    }
+
+    @Override
+    public void process(Exchange exchange) {
+        String issueKey = exchange.getIn().getHeader(ISSUE_KEY, String.class);
+        if (issueKey == null) {
+            throw new IllegalArgumentException(""Missing exchange input header named "" + ISSUE_KEY);
+        }
+        String comment = exchange.getIn().getBody(String.class);
+        if (comment == null) {
+            throw new IllegalArgumentException(""Missing exchange body, it should specify the string comment."");
+        }
+        Integer minutesSpent = exchange.getIn().getHeader(MINUTES_SPENT, Integer.class);","[{'comment': 'Can we use here primitive` instead of the boxed `Integer`?', 'commenter': 'omarsmak'}, {'comment': 'Ok, I see where you\'re coming from, I initially did this to avoid the `NullPointerException` and have the more meaningful `IllegalArgumentException` with message instead.\r\n\r\nI\'m updating this to default to a negative value, to keep the best of both worlds.\r\n\r\n```java\r\nprivate static final int DEFAULT_MINUTES_SPENT = -1;\r\n\r\n[...]\r\n\r\nint minutesSpent = exchange.getIn().getHeader(MINUTES_SPENT, DEFAULT_MINUTES_SPENT, int.class);\r\nif (DEFAULT_MINUTES_SPENT == minutesSpent) {\r\n     throw new IllegalArgumentException(""Missing exchange input header named "" + MINUTES_SPENT);\r\n}\r\n```', 'commenter': 'clementmouchet'}]"
3518,components/camel-jira/src/main/java/org/apache/camel/component/jira/producer/AddIssueLinkProducer.java,"@@ -0,0 +1,69 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * <p>
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * <p>
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.jira.producer;
+
+import static org.apache.camel.component.jira.JiraConstants.CHILD_ISSUE_KEY;","[{'comment': 'I think the static imports should be at the bottom of the imports. Did you run the build with sourcecheck enabled? ', 'commenter': 'omarsmak'}, {'comment': ""My bad, I use IDEA and had my imports organised in a different order. I'll format this to be consistent with the rest of the project."", 'commenter': 'clementmouchet'}]"
3518,components/camel-jira/src/main/java/org/apache/camel/component/jira/producer/FetchIssueProducer.java,"@@ -0,0 +1,52 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ * <p>
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * <p>
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.jira.producer;
+
+import static org.apache.camel.component.jira.JiraConstants.ISSUE_KEY;
+
+import com.atlassian.jira.rest.client.api.IssueRestClient;
+import com.atlassian.jira.rest.client.api.JiraRestClient;
+import com.atlassian.jira.rest.client.api.domain.Issue;
+import org.apache.camel.Exchange;
+import org.apache.camel.component.jira.JiraEndpoint;
+import org.apache.camel.support.DefaultProducer;
+
+public class FetchIssueProducer extends DefaultProducer {
+    public FetchIssueProducer(JiraEndpoint endpoint) {
+        super(endpoint);
+    }
+
+    @Override
+    public void process(Exchange exchange) {
+        String issueKey = exchange.getIn().getHeader(ISSUE_KEY, String.class);
+        if (issueKey == null) {
+            throw new IllegalArgumentException(""Missing exchange input header named "" + ISSUE_KEY);
+        }
+        JiraRestClient client = ((JiraEndpoint) getEndpoint()).getClient();
+        IssueRestClient issueClient = client.getIssueClient();
+        Issue issue = issueClient.getIssue(issueKey).claim();
+
+        // support InOut
+        if (exchange.getPattern().isOutCapable()) {
+            // copy the header of in message to the out message
+            exchange.getOut().copyFrom(exchange.getIn());","[{'comment': 'If not mistaken, `exchange().getOut()` has been [deprecated](https://github.com/apache/camel/blob/master/core/camel-api/src/main/java/org/apache/camel/Exchange.java#L442) in favour of `exchange().getMessage()` ', 'commenter': 'omarsmak'}, {'comment': ""Of course, I'll drop the `.isOutCapable()` block and use `exchange().getMessage()` instead."", 'commenter': 'clementmouchet'}]"
3518,components/camel-jira/src/test/java/org/apache/camel/component/jira/Utils.java,"@@ -102,13 +105,43 @@ public static Issue createIssueWithComments(long id, Collection<Comment> comment
                 null, null, null, null, null, null, null, null);
     }
 
+    public static Issue createIssueWithLinks(long id, Collection<IssueLink> issueLinks) {
+        URI selfUri = URI.create(TEST_JIRA_URL + ""/rest/api/latest/issue/"" + id);
+        return new Issue(""jira summary test "" + id, selfUri, KEY + ""-"" + id, id, null, issueType, null, ""Description "" + id,
+            null, null, null, null, userAssignee, null, null, null, null, null, null, null, null, null, null, issueLinks,
+            null, null, null, null, null, null, null, null);
+    }
+
+    public static Issue createIssueWithWorkLogs(long id, Collection<Worklog> worklogs) {
+        URI selfUri = URI.create(TEST_JIRA_URL + ""/rest/api/latest/issue/"" + id);
+        return new Issue(""jira summary test "" + id, selfUri, KEY + ""-"" + id, id, null, issueType, null, ""Description "" + id,
+            null, null, null, null, userAssignee, null, null, null, null, null, null, null, null, null, null, null,
+            null, worklogs, null, null, null, null, null, null);
+    }
+
     public static Comment newComment(long issueId, int newCommentId, String comment) {
         DateTime now = DateTime.now();
         Long id = Long.parseLong(issueId + ""0"" + newCommentId);","[{'comment': 'Since you are at it, can you please change this to `long` primitive type? :) ', 'commenter': 'omarsmak'}]"
3523,core/camel-core-engine/src/main/java/org/apache/camel/builder/RouteBuilderLifecycleStrategy.java,"@@ -0,0 +1,31 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.builder;
+
+public interface RouteBuilderLifecycleStrategy {","[{'comment': 'Move to camel-api and add javdoc to class level', 'commenter': 'davsclaus'}, {'comment': 'even if it is RouteBuilder specific ?', 'commenter': 'lburgazzoli'}, {'comment': 'Ah sorry yeah thats not doable, so it should be here. Its just that its an api that is now a bit hidden inside core-engine.', 'commenter': 'davsclaus'}]"
3523,core/camel-core-engine/src/main/java/org/apache/camel/builder/RouteBuilder.java,"@@ -478,12 +493,21 @@ protected void checkInitialized() throws Exception {
             if (camelContext.adapt(ExtendedCamelContext.class).getErrorHandlerFactory() instanceof ErrorHandlerBuilder) {
                 setErrorHandlerBuilder((ErrorHandlerBuilder)camelContext.adapt(ExtendedCamelContext.class).getErrorHandlerFactory());
             }
+
+            for (RouteBuilderLifecycleStrategy interceptor: lifecycleInterceptors) {","[{'comment': 'Fix CS', 'commenter': 'davsclaus'}, {'comment': 'done', 'commenter': 'lburgazzoli'}]"
3523,core/camel-core-engine/src/main/java/org/apache/camel/builder/RouteBuilder.java,"@@ -478,12 +493,21 @@ protected void checkInitialized() throws Exception {
             if (camelContext.adapt(ExtendedCamelContext.class).getErrorHandlerFactory() instanceof ErrorHandlerBuilder) {
                 setErrorHandlerBuilder((ErrorHandlerBuilder)camelContext.adapt(ExtendedCamelContext.class).getErrorHandlerFactory());
             }
+
+            for (RouteBuilderLifecycleStrategy interceptor: lifecycleInterceptors) {
+                interceptor.beforeConfigure(this);
+            }
+
             configure();
             // mark all route definitions as custom prepared because
             // a route builder prepares the route definitions correctly already
             for (RouteDefinition route : getRouteCollection().getRoutes()) {
                 route.markPrepared();
             }
+
+            for (RouteBuilderLifecycleStrategy interceptor: lifecycleInterceptors) {","[{'comment': 'Fix CS', 'commenter': 'davsclaus'}, {'comment': 'done', 'commenter': 'lburgazzoli'}]"
3523,core/camel-core-engine/src/main/java/org/apache/camel/builder/RouteBuilder.java,"@@ -71,6 +71,7 @@
     private List<TransformerBuilder> transformerBuilders = new ArrayList<>();
     private List<ValidatorBuilder> validatorBuilders = new ArrayList<>();
     private RoutesDefinition routeCollection = new RoutesDefinition();
+    private List<RouteBuilderLifecycleStrategy> lifecycleInterceptors = new ArrayList<>();","[{'comment': 'Make final', 'commenter': 'davsclaus'}, {'comment': 'done', 'commenter': 'lburgazzoli'}]"
3523,core/camel-core-engine/src/main/java/org/apache/camel/builder/RouteBuilderLifecycleStrategy.java,"@@ -0,0 +1,31 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.builder;
+
+public interface RouteBuilderLifecycleStrategy {
+    /**
+     * This method is invoked before the {@link RouteBuilder#configure()}method is invoked.","[{'comment': 'Fix spacing in javadoc, also for the other method', 'commenter': 'davsclaus'}, {'comment': 'done', 'commenter': 'lburgazzoli'}, {'comment': 'done', 'commenter': 'lburgazzoli'}]"
3536,components/camel-weka/src/main/java/org/apache/camel/component/weka/WekaEndpoint.java,"@@ -16,22 +16,46 @@
  */
 package org.apache.camel.component.weka;
 
+import java.io.BufferedReader;
+import java.io.BufferedWriter;
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.OutputStreamWriter;
+import java.net.URL;
+import java.nio.file.Paths;
+
 import org.apache.camel.Consumer;
+import org.apache.camel.Exchange;
+import org.apache.camel.Message;
 import org.apache.camel.Processor;
 import org.apache.camel.Producer;
+import org.apache.camel.component.file.GenericFile;
 import org.apache.camel.spi.UriEndpoint;
 import org.apache.camel.spi.UriParam;
 import org.apache.camel.support.DefaultEndpoint;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import io.nessus.weka.AssertState;
+import io.nessus.weka.Dataset;
+import io.nessus.weka.ModelLoader;
+import io.nessus.weka.ModelPersister;
+import io.nessus.weka.UncheckedException;
+import weka.classifiers.Classifier;
+import weka.classifiers.Evaluation;
+import weka.core.Instances;
 import weka.core.Version;
+import weka.core.converters.ArffLoader;
+import weka.core.converters.CSVLoader;
+import weka.core.converters.Loader;
 
 /**
  * The camel-weka component provides Data Mining functionality through Weka.
  */
-@UriEndpoint(firstVersion = ""3.1.0"", scheme = ""weka"", title = ""Weka"",
-        syntax = ""weka:cmd?options"", producerOnly = true, label = ""data mining"")
+@UriEndpoint(firstVersion = ""3.1.0"", scheme = ""weka"", title = ""Weka"", syntax = ""weka:cmd?options"", label = ""data mining"")","[{'comment': 'No ?option in syntax. And label should be a single word, datamining or something as a category label.', 'commenter': 'davsclaus'}, {'comment': 'Done', 'commenter': 'tdiesler'}]"
3536,components/camel-weka/src/main/java/org/apache/camel/component/weka/WekaConsumer.java,"@@ -0,0 +1,75 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.weka;
+
+import org.apache.camel.Exchange;
+import org.apache.camel.Processor;
+import org.apache.camel.component.weka.WekaConfiguration.Command;
+import org.apache.camel.support.DefaultConsumer;
+
+import io.nessus.weka.Dataset;
+
+public class WekaConsumer extends DefaultConsumer {
+
+    public WekaConsumer(WekaEndpoint endpoint, Processor processor) {
+        super(endpoint, processor);
+    }
+
+    @Override
+    public WekaEndpoint getEndpoint() {
+        return (WekaEndpoint)super.getEndpoint();
+    }
+
+    public WekaConfiguration getConfiguration() {
+        return getEndpoint().getConfiguration();
+    }
+    
+    @Override
+    protected void doStart() throws Exception {
+        super.doStart();
+        
+        Thread thread = new Thread(new Runnable() {","[{'comment': 'Its preferred to create thread via Camel. See CamelContext ExecutorServiceStrategy which has APIs for creating threads. Also you should stop the thread in doStop.', 'commenter': 'davsclaus'}]"
3536,components/camel-weka/src/main/java/org/apache/camel/component/weka/WekaConsumer.java,"@@ -0,0 +1,75 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.weka;
+
+import org.apache.camel.Exchange;
+import org.apache.camel.Processor;
+import org.apache.camel.component.weka.WekaConfiguration.Command;
+import org.apache.camel.support.DefaultConsumer;
+
+import io.nessus.weka.Dataset;
+
+public class WekaConsumer extends DefaultConsumer {
+
+    public WekaConsumer(WekaEndpoint endpoint, Processor processor) {
+        super(endpoint, processor);
+    }
+
+    @Override
+    public WekaEndpoint getEndpoint() {
+        return (WekaEndpoint)super.getEndpoint();
+    }
+
+    public WekaConfiguration getConfiguration() {
+        return getEndpoint().getConfiguration();
+    }
+    
+    @Override
+    protected void doStart() throws Exception {
+        super.doStart();
+        
+        Thread thread = new Thread(new Runnable() {
+            
+            @Override
+            public void run() {
+                
+                WekaEndpoint endpoint = getEndpoint();
+                Exchange exchange = endpoint.createExchange();
+                
+                Command cmd = getConfiguration().getCommand();
+                if (Command.read != cmd) {","[{'comment': 'Check for invalid command in the component or the createConsumer method. Doing this here is too late.', 'commenter': 'davsclaus'}, {'comment': 'Done', 'commenter': 'tdiesler'}]"
3536,components/camel-weka/src/main/java/org/apache/camel/component/weka/WekaEndpoint.java,"@@ -44,14 +68,18 @@ public WekaEndpoint(String uri, WekaComponent component, WekaConfiguration confi
         this.configuration = config;
     }
 
+    public WekaConfiguration getConfiguration() {
+        return configuration;
+    }
+
     @Override
     public WekaComponent getComponent() {
-        return (WekaComponent)super.getComponent();
+        return (WekaComponent) super.getComponent();
     }
 
     @Override
-    public Consumer createConsumer(Processor processor) throws Exception {
-        throw new UnsupportedOperationException();
+    public Consumer createConsumer(Processor processor) {
+        return new WekaConsumer(this, processor);","[{'comment': 'You need to call configureConsumer too, see the other components ', 'commenter': 'davsclaus'}, {'comment': 'Done', 'commenter': 'tdiesler'}]"
3536,components/camel-weka/src/main/java/org/apache/camel/component/weka/WekaEndpoint.java,"@@ -64,11 +92,245 @@ public boolean isSingleton() {
         return false;
     }
 
-    public WekaConfiguration getConfiguration() {
-        return configuration;
-    }
-
     String wekaVersion() {
         return Version.VERSION;
     }
+
+    Dataset handlePushCmd(Exchange exchange) throws Exception {
+        
+        String dsname = configuration.getDsname();
+
+        Dataset dataset = assertDatasetBody(exchange);
+        if (dsname != null) {
+            dataset.push(dsname);
+        } else {
+            dataset.push();
+        }
+        
+        return dataset;
+    }
+
+    Dataset handlePopCmd(Exchange exchange) throws Exception {
+        
+        String dsname = configuration.getDsname();
+
+        Dataset dataset = assertDatasetBody(exchange);
+        if (dsname != null) {
+            dataset.pop(dsname);
+        } else {
+            dataset.pop();
+        }
+        
+        return dataset;
+    }
+
+    Dataset handleReadCmd(Exchange exchange) throws Exception {
+        
+        String fpath = configuration.getPath();
+        
+        if (fpath != null) {
+            Dataset dataset = Dataset.create(fpath);
+            return dataset;
+        }
+        
+        Dataset dataset = assertDatasetBody(exchange);
+        return dataset;
+    }
+
+    Object handleWriteCmd(Exchange exchange) throws Exception {
+        
+        Dataset dataset = assertDatasetBody(exchange);
+        String fpath = configuration.getPath();
+        
+        if (fpath != null) {
+            
+            dataset.write(Paths.get(fpath));
+            return dataset;
+            
+        } else {
+            
+            // The internal implementation of DataSink does this.. 
+            // Instances.toString().getBytes()
+            //
+            // Therefore, we avoid creating yet another copy of the
+            // instance data and call Instances.toString() as well
+            
+            Instances instances = dataset.getInstances();
+            byte[] bytes = instances.toString().getBytes();
+            return new ByteArrayInputStream(bytes);
+        }
+    }
+
+    Dataset handleFilterCmd(Exchange exchange) throws Exception {
+        
+        String applyValue = configuration.getApply();
+
+        Dataset dataset = assertDatasetBody(exchange);
+        dataset = dataset.apply(applyValue);
+        
+        return dataset;
+    }
+
+    Dataset handleModelCmd(Exchange exchange) throws Exception {
+        
+        Dataset dataset = assertDatasetBody(exchange);
+        
+        String dsname = configuration.getDsname();
+        boolean crossValidate = configuration.isXval();
+        String buildSpec = configuration.getBuild();
+        String loadFrom = configuration.getLoadFrom();
+        String saveTo = configuration.getSaveTo();
+        
+        // Load the Model
+        
+        if (loadFrom != null) {
+            
+            Classifier cl = dataset
+                    .loadClassifier(new ModelLoader(loadFrom))
+                    .getClassifier();
+            
+            AssertState.notNull(cl, ""Cannot load the classifier from: "" + loadFrom);
+            LOG.info(""{}"", cl);","[{'comment': 'LOG.debug', 'commenter': 'davsclaus'}, {'comment': 'Done', 'commenter': 'tdiesler'}]"
3536,components/camel-weka/src/main/java/org/apache/camel/component/weka/WekaEndpoint.java,"@@ -64,11 +92,245 @@ public boolean isSingleton() {
         return false;
     }
 
-    public WekaConfiguration getConfiguration() {
-        return configuration;
-    }
-
     String wekaVersion() {
         return Version.VERSION;
     }
+
+    Dataset handlePushCmd(Exchange exchange) throws Exception {
+        
+        String dsname = configuration.getDsname();
+
+        Dataset dataset = assertDatasetBody(exchange);
+        if (dsname != null) {
+            dataset.push(dsname);
+        } else {
+            dataset.push();
+        }
+        
+        return dataset;
+    }
+
+    Dataset handlePopCmd(Exchange exchange) throws Exception {
+        
+        String dsname = configuration.getDsname();
+
+        Dataset dataset = assertDatasetBody(exchange);
+        if (dsname != null) {
+            dataset.pop(dsname);
+        } else {
+            dataset.pop();
+        }
+        
+        return dataset;
+    }
+
+    Dataset handleReadCmd(Exchange exchange) throws Exception {
+        
+        String fpath = configuration.getPath();
+        
+        if (fpath != null) {
+            Dataset dataset = Dataset.create(fpath);
+            return dataset;
+        }
+        
+        Dataset dataset = assertDatasetBody(exchange);
+        return dataset;
+    }
+
+    Object handleWriteCmd(Exchange exchange) throws Exception {
+        
+        Dataset dataset = assertDatasetBody(exchange);
+        String fpath = configuration.getPath();
+        
+        if (fpath != null) {
+            
+            dataset.write(Paths.get(fpath));
+            return dataset;
+            
+        } else {
+            
+            // The internal implementation of DataSink does this.. 
+            // Instances.toString().getBytes()
+            //
+            // Therefore, we avoid creating yet another copy of the
+            // instance data and call Instances.toString() as well
+            
+            Instances instances = dataset.getInstances();
+            byte[] bytes = instances.toString().getBytes();
+            return new ByteArrayInputStream(bytes);
+        }
+    }
+
+    Dataset handleFilterCmd(Exchange exchange) throws Exception {
+        
+        String applyValue = configuration.getApply();
+
+        Dataset dataset = assertDatasetBody(exchange);
+        dataset = dataset.apply(applyValue);
+        
+        return dataset;
+    }
+
+    Dataset handleModelCmd(Exchange exchange) throws Exception {
+        
+        Dataset dataset = assertDatasetBody(exchange);
+        
+        String dsname = configuration.getDsname();
+        boolean crossValidate = configuration.isXval();
+        String buildSpec = configuration.getBuild();
+        String loadFrom = configuration.getLoadFrom();
+        String saveTo = configuration.getSaveTo();
+        
+        // Load the Model
+        
+        if (loadFrom != null) {
+            
+            Classifier cl = dataset
+                    .loadClassifier(new ModelLoader(loadFrom))
+                    .getClassifier();
+            
+            AssertState.notNull(cl, ""Cannot load the classifier from: "" + loadFrom);
+            LOG.info(""{}"", cl);
+        } 
+        
+        // Build a classifier
+        
+        else if (buildSpec != null) {
+            
+            dataset.buildClassifier(buildSpec);
+            
+            // Cross Validate the Model
+            
+            if (crossValidate) {
+                int seed = configuration.getSeed();
+                int folds = configuration.getFolds();
+                dataset.crossValidateModel(folds, seed);
+            } 
+            
+            // Validate the Model using explicit/current instances
+            
+            else {
+                
+                // Use the named data set training
+                if (dsname != null) {
+                    dataset.pop(dsname);
+                }
+                
+                // Train with current instances
+                dataset.evaluateModel();
+            }
+            
+            Classifier cl = dataset.getClassifier();
+            AssertState.notNull(cl, ""Model command requires 'load' or 'apply'"");
+            LOG.info(""{}"", cl);","[{'comment': 'debug logging', 'commenter': 'davsclaus'}, {'comment': 'Done', 'commenter': 'tdiesler'}]"
3536,components/camel-weka/src/main/java/org/apache/camel/component/weka/WekaEndpoint.java,"@@ -64,11 +92,245 @@ public boolean isSingleton() {
         return false;
     }
 
-    public WekaConfiguration getConfiguration() {
-        return configuration;
-    }
-
     String wekaVersion() {
         return Version.VERSION;
     }
+
+    Dataset handlePushCmd(Exchange exchange) throws Exception {
+        
+        String dsname = configuration.getDsname();
+
+        Dataset dataset = assertDatasetBody(exchange);
+        if (dsname != null) {
+            dataset.push(dsname);
+        } else {
+            dataset.push();
+        }
+        
+        return dataset;
+    }
+
+    Dataset handlePopCmd(Exchange exchange) throws Exception {
+        
+        String dsname = configuration.getDsname();
+
+        Dataset dataset = assertDatasetBody(exchange);
+        if (dsname != null) {
+            dataset.pop(dsname);
+        } else {
+            dataset.pop();
+        }
+        
+        return dataset;
+    }
+
+    Dataset handleReadCmd(Exchange exchange) throws Exception {
+        
+        String fpath = configuration.getPath();
+        
+        if (fpath != null) {
+            Dataset dataset = Dataset.create(fpath);
+            return dataset;
+        }
+        
+        Dataset dataset = assertDatasetBody(exchange);
+        return dataset;
+    }
+
+    Object handleWriteCmd(Exchange exchange) throws Exception {
+        
+        Dataset dataset = assertDatasetBody(exchange);
+        String fpath = configuration.getPath();
+        
+        if (fpath != null) {
+            
+            dataset.write(Paths.get(fpath));
+            return dataset;
+            
+        } else {
+            
+            // The internal implementation of DataSink does this.. 
+            // Instances.toString().getBytes()
+            //
+            // Therefore, we avoid creating yet another copy of the
+            // instance data and call Instances.toString() as well
+            
+            Instances instances = dataset.getInstances();
+            byte[] bytes = instances.toString().getBytes();
+            return new ByteArrayInputStream(bytes);
+        }
+    }
+
+    Dataset handleFilterCmd(Exchange exchange) throws Exception {
+        
+        String applyValue = configuration.getApply();
+
+        Dataset dataset = assertDatasetBody(exchange);
+        dataset = dataset.apply(applyValue);
+        
+        return dataset;
+    }
+
+    Dataset handleModelCmd(Exchange exchange) throws Exception {
+        
+        Dataset dataset = assertDatasetBody(exchange);
+        
+        String dsname = configuration.getDsname();
+        boolean crossValidate = configuration.isXval();
+        String buildSpec = configuration.getBuild();
+        String loadFrom = configuration.getLoadFrom();
+        String saveTo = configuration.getSaveTo();
+        
+        // Load the Model
+        
+        if (loadFrom != null) {
+            
+            Classifier cl = dataset
+                    .loadClassifier(new ModelLoader(loadFrom))
+                    .getClassifier();
+            
+            AssertState.notNull(cl, ""Cannot load the classifier from: "" + loadFrom);
+            LOG.info(""{}"", cl);
+        } 
+        
+        // Build a classifier
+        
+        else if (buildSpec != null) {
+            
+            dataset.buildClassifier(buildSpec);
+            
+            // Cross Validate the Model
+            
+            if (crossValidate) {
+                int seed = configuration.getSeed();
+                int folds = configuration.getFolds();
+                dataset.crossValidateModel(folds, seed);
+            } 
+            
+            // Validate the Model using explicit/current instances
+            
+            else {
+                
+                // Use the named data set training
+                if (dsname != null) {
+                    dataset.pop(dsname);
+                }
+                
+                // Train with current instances
+                dataset.evaluateModel();
+            }
+            
+            Classifier cl = dataset.getClassifier();
+            AssertState.notNull(cl, ""Model command requires 'load' or 'apply'"");
+            LOG.info(""{}"", cl);
+            
+            Evaluation ev = dataset.getEvaluation();
+            LOG.info(""{}"", ev.toSummaryString());","[{'comment': 'Is this needed to be logged at info level? And is this per exchange which then can get noisy', 'commenter': 'davsclaus'}, {'comment': 'Done', 'commenter': 'tdiesler'}]"
3536,components/camel-weka/src/main/java/org/apache/camel/component/weka/WekaEndpoint.java,"@@ -64,11 +92,245 @@ public boolean isSingleton() {
         return false;
     }
 
-    public WekaConfiguration getConfiguration() {
-        return configuration;
-    }
-
     String wekaVersion() {
         return Version.VERSION;
     }
+
+    Dataset handlePushCmd(Exchange exchange) throws Exception {
+        
+        String dsname = configuration.getDsname();
+
+        Dataset dataset = assertDatasetBody(exchange);
+        if (dsname != null) {
+            dataset.push(dsname);
+        } else {
+            dataset.push();
+        }
+        
+        return dataset;
+    }
+
+    Dataset handlePopCmd(Exchange exchange) throws Exception {
+        
+        String dsname = configuration.getDsname();
+
+        Dataset dataset = assertDatasetBody(exchange);
+        if (dsname != null) {
+            dataset.pop(dsname);
+        } else {
+            dataset.pop();
+        }
+        
+        return dataset;
+    }
+
+    Dataset handleReadCmd(Exchange exchange) throws Exception {
+        
+        String fpath = configuration.getPath();
+        
+        if (fpath != null) {
+            Dataset dataset = Dataset.create(fpath);
+            return dataset;
+        }
+        
+        Dataset dataset = assertDatasetBody(exchange);
+        return dataset;
+    }
+
+    Object handleWriteCmd(Exchange exchange) throws Exception {
+        
+        Dataset dataset = assertDatasetBody(exchange);
+        String fpath = configuration.getPath();
+        
+        if (fpath != null) {
+            
+            dataset.write(Paths.get(fpath));
+            return dataset;
+            
+        } else {
+            
+            // The internal implementation of DataSink does this.. 
+            // Instances.toString().getBytes()
+            //
+            // Therefore, we avoid creating yet another copy of the
+            // instance data and call Instances.toString() as well
+            
+            Instances instances = dataset.getInstances();
+            byte[] bytes = instances.toString().getBytes();
+            return new ByteArrayInputStream(bytes);
+        }
+    }
+
+    Dataset handleFilterCmd(Exchange exchange) throws Exception {
+        
+        String applyValue = configuration.getApply();
+
+        Dataset dataset = assertDatasetBody(exchange);
+        dataset = dataset.apply(applyValue);
+        
+        return dataset;
+    }
+
+    Dataset handleModelCmd(Exchange exchange) throws Exception {
+        
+        Dataset dataset = assertDatasetBody(exchange);
+        
+        String dsname = configuration.getDsname();
+        boolean crossValidate = configuration.isXval();
+        String buildSpec = configuration.getBuild();
+        String loadFrom = configuration.getLoadFrom();
+        String saveTo = configuration.getSaveTo();
+        
+        // Load the Model
+        
+        if (loadFrom != null) {
+            
+            Classifier cl = dataset
+                    .loadClassifier(new ModelLoader(loadFrom))
+                    .getClassifier();
+            
+            AssertState.notNull(cl, ""Cannot load the classifier from: "" + loadFrom);
+            LOG.info(""{}"", cl);
+        } 
+        
+        // Build a classifier
+        
+        else if (buildSpec != null) {
+            
+            dataset.buildClassifier(buildSpec);
+            
+            // Cross Validate the Model
+            
+            if (crossValidate) {
+                int seed = configuration.getSeed();
+                int folds = configuration.getFolds();
+                dataset.crossValidateModel(folds, seed);
+            } 
+            
+            // Validate the Model using explicit/current instances
+            
+            else {
+                
+                // Use the named data set training
+                if (dsname != null) {
+                    dataset.pop(dsname);
+                }
+                
+                // Train with current instances
+                dataset.evaluateModel();
+            }
+            
+            Classifier cl = dataset.getClassifier();
+            AssertState.notNull(cl, ""Model command requires 'load' or 'apply'"");
+            LOG.info(""{}"", cl);
+            
+            Evaluation ev = dataset.getEvaluation();
+            LOG.info(""{}"", ev.toSummaryString());
+        }
+        
+        // Save the Model
+        
+        if (saveTo != null) {
+            dataset.consumeClassifier(new ModelPersister(saveTo));
+        }
+        
+        return dataset;
+    }
+
+    private Dataset assertDatasetBody(Exchange exchange) throws Exception {
+        
+        Message msg = exchange.getMessage();
+        Object body = msg.getBody();
+        
+        Dataset dataset = msg.getBody(Dataset.class);
+        
+        if (dataset == null) {
+            
+            if (body instanceof Instances) {
+
+                dataset = Dataset.create((Instances) body);
+                
+            } else if (body instanceof GenericFile) {
+                
+                GenericFile<?> file = (GenericFile<?>) body;
+                AssertState.isFalse(file.isDirectory(), ""Directory not supported: "" + file);
+                String absolutePath = file.getAbsoluteFilePath();
+                dataset = Dataset.create(absolutePath);
+                
+            } else if (body instanceof URL) {
+                
+                URL url = (URL) body;
+                Instances instances = readInternal(url.openStream());","[{'comment': 'Can the stream not leak? eg need to close it after use', 'commenter': 'davsclaus'}, {'comment': 'Well spotted, thanks.', 'commenter': 'tdiesler'}]"
3536,components/camel-weka/src/main/java/org/apache/camel/component/weka/WekaEndpoint.java,"@@ -64,11 +92,245 @@ public boolean isSingleton() {
         return false;
     }
 
-    public WekaConfiguration getConfiguration() {
-        return configuration;
-    }
-
     String wekaVersion() {
         return Version.VERSION;
     }
+
+    Dataset handlePushCmd(Exchange exchange) throws Exception {
+        
+        String dsname = configuration.getDsname();
+
+        Dataset dataset = assertDatasetBody(exchange);
+        if (dsname != null) {
+            dataset.push(dsname);
+        } else {
+            dataset.push();
+        }
+        
+        return dataset;
+    }
+
+    Dataset handlePopCmd(Exchange exchange) throws Exception {
+        
+        String dsname = configuration.getDsname();
+
+        Dataset dataset = assertDatasetBody(exchange);
+        if (dsname != null) {
+            dataset.pop(dsname);
+        } else {
+            dataset.pop();
+        }
+        
+        return dataset;
+    }
+
+    Dataset handleReadCmd(Exchange exchange) throws Exception {
+        
+        String fpath = configuration.getPath();
+        
+        if (fpath != null) {
+            Dataset dataset = Dataset.create(fpath);
+            return dataset;
+        }
+        
+        Dataset dataset = assertDatasetBody(exchange);
+        return dataset;
+    }
+
+    Object handleWriteCmd(Exchange exchange) throws Exception {
+        
+        Dataset dataset = assertDatasetBody(exchange);
+        String fpath = configuration.getPath();
+        
+        if (fpath != null) {
+            
+            dataset.write(Paths.get(fpath));
+            return dataset;
+            
+        } else {
+            
+            // The internal implementation of DataSink does this.. 
+            // Instances.toString().getBytes()
+            //
+            // Therefore, we avoid creating yet another copy of the
+            // instance data and call Instances.toString() as well
+            
+            Instances instances = dataset.getInstances();
+            byte[] bytes = instances.toString().getBytes();
+            return new ByteArrayInputStream(bytes);
+        }
+    }
+
+    Dataset handleFilterCmd(Exchange exchange) throws Exception {
+        
+        String applyValue = configuration.getApply();
+
+        Dataset dataset = assertDatasetBody(exchange);
+        dataset = dataset.apply(applyValue);
+        
+        return dataset;
+    }
+
+    Dataset handleModelCmd(Exchange exchange) throws Exception {
+        
+        Dataset dataset = assertDatasetBody(exchange);
+        
+        String dsname = configuration.getDsname();
+        boolean crossValidate = configuration.isXval();
+        String buildSpec = configuration.getBuild();
+        String loadFrom = configuration.getLoadFrom();
+        String saveTo = configuration.getSaveTo();
+        
+        // Load the Model
+        
+        if (loadFrom != null) {
+            
+            Classifier cl = dataset
+                    .loadClassifier(new ModelLoader(loadFrom))
+                    .getClassifier();
+            
+            AssertState.notNull(cl, ""Cannot load the classifier from: "" + loadFrom);
+            LOG.info(""{}"", cl);
+        } 
+        
+        // Build a classifier
+        
+        else if (buildSpec != null) {
+            
+            dataset.buildClassifier(buildSpec);
+            
+            // Cross Validate the Model
+            
+            if (crossValidate) {
+                int seed = configuration.getSeed();
+                int folds = configuration.getFolds();
+                dataset.crossValidateModel(folds, seed);
+            } 
+            
+            // Validate the Model using explicit/current instances
+            
+            else {
+                
+                // Use the named data set training
+                if (dsname != null) {
+                    dataset.pop(dsname);
+                }
+                
+                // Train with current instances
+                dataset.evaluateModel();
+            }
+            
+            Classifier cl = dataset.getClassifier();
+            AssertState.notNull(cl, ""Model command requires 'load' or 'apply'"");
+            LOG.info(""{}"", cl);
+            
+            Evaluation ev = dataset.getEvaluation();
+            LOG.info(""{}"", ev.toSummaryString());
+        }
+        
+        // Save the Model
+        
+        if (saveTo != null) {
+            dataset.consumeClassifier(new ModelPersister(saveTo));
+        }
+        
+        return dataset;
+    }
+
+    private Dataset assertDatasetBody(Exchange exchange) throws Exception {
+        
+        Message msg = exchange.getMessage();
+        Object body = msg.getBody();
+        
+        Dataset dataset = msg.getBody(Dataset.class);
+        
+        if (dataset == null) {
+            
+            if (body instanceof Instances) {
+
+                dataset = Dataset.create((Instances) body);
+                
+            } else if (body instanceof GenericFile) {
+                
+                GenericFile<?> file = (GenericFile<?>) body;
+                AssertState.isFalse(file.isDirectory(), ""Directory not supported: "" + file);
+                String absolutePath = file.getAbsoluteFilePath();
+                dataset = Dataset.create(absolutePath);
+                
+            } else if (body instanceof URL) {
+                
+                URL url = (URL) body;
+                Instances instances = readInternal(url.openStream());
+                dataset = Dataset.create(instances);
+                
+            } else if (body instanceof InputStream) {
+                
+                InputStream input = (InputStream) body;
+                Instances instances = readInternal(input);
+                dataset = Dataset.create(instances);
+            }
+        }
+        
+        AssertState.notNull(dataset, ""Cannot obtain dataset from body: "" + body);
+        return dataset;
+    }
+
+    // https://github.com/tdiesler/nessus-weka/issues/11
+    private static Instances readInternal(InputStream input) {","[{'comment': 'Can the stream not leak? eg need to close it after use', 'commenter': 'davsclaus'}, {'comment': 'Caller resposibility', 'commenter': 'tdiesler'}]"
3536,components/camel-weka/src/test/java/org/apache/camel/component/weka/DecisionTreeTest.java,"@@ -0,0 +1,124 @@
+package org.apache.camel.component.weka;","[{'comment': 'Add license headers for missing files.', 'commenter': 'davsclaus'}]"
3543,components/camel-jdbc/src/main/docs/jdbc-component.adoc,"@@ -219,6 +219,80 @@ bound in the previous step:
 
 Or you can create a `DataSource` in Spring like this:
 
+With srping xml:","[{'comment': 'A little typo', 'commenter': 'oscerd'}, {'comment': 'Thanks, @oscerd !\r\n\r\nI solved the typo. ', 'commenter': 'laertida'}]"
3544,components/camel-beanstalk/src/main/java/org/apache/camel/component/beanstalk/BeanstalkEndpoint.java,"@@ -42,7 +42,7 @@
     final ConnectionSettings conn;
 
     @UriPath(description = ""Connection settings host:port/tube"")
-    private String connectionSettings;
+    private final String connectionSettings;","[{'comment': 'Is there a specific reason?', 'commenter': 'oscerd'}, {'comment': ""This needs to be reverted. It's my mistake when i was going through tests."", 'commenter': 'djoleB'}]"
3551,components/camel-google-pubsub/src/main/java/org/apache/camel/component/google/pubsub/GooglePubsubEndpoint.java,"@@ -16,14 +16,11 @@
  */
 package org.apache.camel.component.google.pubsub;
 
-import java.util.concurrent.ExecutorService;
-
-import com.google.api.services.pubsub.Pubsub;
-import org.apache.camel.Component;
-import org.apache.camel.Consumer;
-import org.apache.camel.ExchangePattern;
-import org.apache.camel.Processor;
-import org.apache.camel.Producer;
+import com.google.cloud.pubsub.v1.Publisher;
+import com.google.common.cache.Cache;
+import com.google.common.cache.CacheBuilder;
+import com.google.common.cache.RemovalListener;
+import org.apache.camel.*;","[{'comment': 'Please use explicit imports', 'commenter': 'oscerd'}]"
3551,components/camel-google-pubsub/src/main/java/org/apache/camel/component/google/pubsub/consumer/CamelMessageReceiver.java,"@@ -0,0 +1,62 @@
+package org.apache.camel.component.google.pubsub.consumer;","[{'comment': 'Can you please run your build using the source check `mvn -Psourcecheck clean install` to fix the checkstyle issues, for example the missing license header in this class', 'commenter': 'omarsmak'}]"
3551,components/camel-google-pubsub/src/main/java/org/apache/camel/component/google/pubsub/GooglePubsubConstants.java,"@@ -19,16 +19,12 @@
 public final class GooglePubsubConstants {
 
     public static final String MESSAGE_ID = ""CamelGooglePubsub.MessageId"";
-    public static final String ACK_ID = ""CamelGooglePubsub.MsgAckId"";
     public static final String PUBLISH_TIME = ""CamelGooglePubsub.PublishTime"";
     public static final String ATTRIBUTES = ""CamelGooglePubsub.Attributes"";
-    public static final String ACK_DEADLINE = ""CamelGooglePubsub.AckDeadline"";
 
     public enum AckMode {
         AUTO, NONE
     }
 
-    private GooglePubsubConstants() {","[{'comment': 'Any reason to remove the private constructor since it was meant to be a singleton class? ', 'commenter': 'omarsmak'}, {'comment': ""Right, I've introduced it again"", 'commenter': 'alvinkwekel'}, {'comment': 'Failing tests were due to missing @BindToRegistry(""prop"")', 'commenter': 'alvinkwekel'}]"
3551,components/camel-google-pubsub/src/main/java/org/apache/camel/component/google/pubsub/GooglePubsubEndpoint.java,"@@ -57,16 +58,24 @@
     @UriParam(name = ""concurrentConsumers"", description = ""The number of parallel streams consuming from the subscription"", defaultValue = ""1"")
     private Integer concurrentConsumers = 1;
 
-    @UriParam(name = ""maxMessagesPerPoll"", description = ""The max number of messages to receive from the server in a single API call"", defaultValue = ""1"")
-    private Integer maxMessagesPerPoll = 1;
-
-    @UriParam(name = ""connectionFactory"", description = ""ConnectionFactory to obtain connection to PubSub Service. If non provided the default one will be used"")
-    private GooglePubsubConnectionFactory connectionFactory;
-
     @UriParam(defaultValue = ""AUTO"", enums = ""AUTO,NONE"", description = ""AUTO = exchange gets ack'ed/nack'ed on completion. NONE = downstream process has to ack/nack explicitly"")
     private GooglePubsubConstants.AckMode ackMode = GooglePubsubConstants.AckMode.AUTO;
 
-    private Pubsub pubsub;
+    private RemovalListener<String, Publisher> removalListener = removal -> {
+        Publisher publisher = removal.getValue();
+        publisher.shutdown();","[{'comment': 'My IDE reports that `publisher` reports this could be `null`, does it make sense to check for nullity here?', 'commenter': 'omarsmak'}]"
3551,components/camel-google-pubsub/src/main/java/org/apache/camel/component/google/pubsub/GooglePubsubEndpoint.java,"@@ -57,16 +62,27 @@
     @UriParam(name = ""concurrentConsumers"", description = ""The number of parallel streams consuming from the subscription"", defaultValue = ""1"")
     private Integer concurrentConsumers = 1;
 
-    @UriParam(name = ""maxMessagesPerPoll"", description = ""The max number of messages to receive from the server in a single API call"", defaultValue = ""1"")
-    private Integer maxMessagesPerPoll = 1;
-
-    @UriParam(name = ""connectionFactory"", description = ""ConnectionFactory to obtain connection to PubSub Service. If non provided the default one will be used"")
-    private GooglePubsubConnectionFactory connectionFactory;
-
     @UriParam(defaultValue = ""AUTO"", enums = ""AUTO,NONE"", description = ""AUTO = exchange gets ack'ed/nack'ed on completion. NONE = downstream process has to ack/nack explicitly"")
     private GooglePubsubConstants.AckMode ackMode = GooglePubsubConstants.AckMode.AUTO;
 
-    private Pubsub pubsub;
+    private RemovalListener<String, Publisher> removalListener = removal -> {
+        Publisher publisher = removal.getValue();
+        if (publisher == null) {
+            return;
+        }
+        publisher.shutdown();","[{'comment': 'There is some API on CamelContext via ExecutorServiceStrategy that can shutdown thread pools graceful and is recommened to use', 'commenter': 'davsclaus'}, {'comment': ""This is cleanup of the cached publisher with no associated thread pool.\r\n\r\nIf you are referring to the consumer thread pool. I've changed that to use the graceful shutdown: https://github.com/apache/camel/pull/3551/files#diff-8becc735c075d032757f24805f234520R70"", 'commenter': 'alvinkwekel'}]"
3551,components/camel-google-pubsub/src/main/java/org/apache/camel/component/google/pubsub/GooglePubsubEndpoint.java,"@@ -57,16 +62,27 @@
     @UriParam(name = ""concurrentConsumers"", description = ""The number of parallel streams consuming from the subscription"", defaultValue = ""1"")
     private Integer concurrentConsumers = 1;
 
-    @UriParam(name = ""maxMessagesPerPoll"", description = ""The max number of messages to receive from the server in a single API call"", defaultValue = ""1"")
-    private Integer maxMessagesPerPoll = 1;
-
-    @UriParam(name = ""connectionFactory"", description = ""ConnectionFactory to obtain connection to PubSub Service. If non provided the default one will be used"")
-    private GooglePubsubConnectionFactory connectionFactory;
-
     @UriParam(defaultValue = ""AUTO"", enums = ""AUTO,NONE"", description = ""AUTO = exchange gets ack'ed/nack'ed on completion. NONE = downstream process has to ack/nack explicitly"")
     private GooglePubsubConstants.AckMode ackMode = GooglePubsubConstants.AckMode.AUTO;
 
-    private Pubsub pubsub;
+    private RemovalListener<String, Publisher> removalListener = removal -> {
+        Publisher publisher = removal.getValue();
+        if (publisher == null) {
+            return;
+        }
+        publisher.shutdown();
+        try {
+            publisher.awaitTermination(1, TimeUnit.MINUTES);
+        } catch (Exception e) {
+            throw new RuntimeException(e);
+        }
+    };
+
+    private Cache<String, Publisher> cachedPublishers = CacheBuilder.newBuilder()","[{'comment': 'These are hardcoded values, why these values? And would it make sense for users to be able to cofigure them', 'commenter': 'davsclaus'}, {'comment': 'Its possible better to have such cache on the component so there is a single cache for all endpoints. And also shutdown the cache whe the componet stop', 'commenter': 'davsclaus'}, {'comment': ""I've moved the cache to the component and made the values configurable."", 'commenter': 'alvinkwekel'}]"
3551,components/camel-google-pubsub/src/main/java/org/apache/camel/component/google/pubsub/GooglePubsubEndpoint.java,"@@ -108,9 +122,7 @@ public Producer createProducer() throws Exception {
     public Consumer createConsumer(Processor processor) throws Exception {
         afterPropertiesSet();
         setExchangePattern(ExchangePattern.InOnly);
-        GooglePubsubConsumer consumer = new GooglePubsubConsumer(this, processor);
-        configureConsumer(consumer);
-        return consumer;
+        return new GooglePubsubConsumer(this, processor);","[{'comment': 'You need to call configureConsumer', 'commenter': 'davsclaus'}, {'comment': 'Whoops, corrected', 'commenter': 'alvinkwekel'}]"
3551,platforms/karaf/features/src/main/resources/features.xml,"@@ -1128,18 +1128,49 @@
   </feature>
   <feature name='camel-google-pubsub' version='${project.version}' start-level='50'>
     <feature version='${project.version}'>camel-core</feature>
-    <bundle dependency='true'>wrap:mvn:com.google.apis/google-api-services-pubsub/${google-api-services-pubsub-version}</bundle>
-    <bundle dependency='true'>wrap:mvn:com.google.api-client/google-api-client/${google-api-client-version}</bundle>
-    <bundle dependency='true'>mvn:commons-codec/commons-codec/${commons-codec-version}</bundle>
-    <bundle dependency='true'>wrap:mvn:com.google.http-client/google-http-client/${google-api-client-version}</bundle>
-    <bundle dependency='true'>wrap:mvn:com.google.http-client/google-http-client-jackson2/${google-api-client-version}</bundle>
-    <bundle dependency='true'>wrap:mvn:com.google.oauth-client/google-oauth-client/${google-api-client-version}</bundle>
-    <bundle dependency='true'>wrap:mvn:com.google.oauth-client/google-oauth-client-java6/${google-api-client-version}</bundle>
-    <bundle dependency='true'>wrap:mvn:com.google.oauth-client/google-oauth-client-jetty/${google-api-client-version}</bundle>
+    <bundle dependency='true'>wrap:mvn:com.google.cloud/google-cloud-pubsub/${google-cloud-pubsub-version}</bundle>
+    <bundle dependency='true'>wrap:mvn:io.grpc/grpc-api/${grpc-version}</bundle>
+    <bundle dependency='true'>wrap:mvn:io.grpc/grpc-context/${grpc-version}</bundle>
+    <bundle dependency='true'>wrap:mvn:org.codehaus.mojo/animal-sniffer-annotations/${animal-sniffer-version}</bundle>
+    <bundle dependency='true'>wrap:mvn:io.grpc/grpc-stub/${grpc-version}</bundle>
+    <bundle dependency='true'>wrap:mvn:io.grpc/grpc-protobuf/${grpc-version}</bundle>
+    <bundle dependency='true'>wrap:mvn:io.grpc/grpc-protobuf-lite/${grpc-version}</bundle>
+    <bundle dependency='true'>wrap:mvn:com.google.api/api-common/${google-api-common-version}</bundle>
+    <bundle dependency='true'>mvn:com.google.protobuf/protobuf-java/${protobuf-version}</bundle>
+    <bundle dependency='true'>wrap:mvn:com.google.api.grpc/proto-google-common-protos/${google-proto-common-version}</bundle>
+    <bundle dependency='true'>wrap:mvn:com.google.api.grpc/proto-google-cloud-pubsub-v1/${google-proto-pubsub-version}</bundle>
+    <bundle dependency='true'>wrap:mvn:com.google.api.grpc/proto-google-iam-v1/${google-proto-iam-version}</bundle>
+    <bundle dependency='true'>mvn:com.google.guava/guava/${google-guava-version}</bundle>
+    <bundle dependency='true'>wrap:mvn:com.google.api/gax/${google-gax-version}</bundle>
+    <bundle dependency='true'>wrap:mvn:com.google.auth/google-auth-library-oauth2-http/${grpc-google-auth-library-version}</bundle>
+    <bundle dependency='true'>wrap:mvn:com.google.http-client/google-http-client-jackson2/${google-http-jackson2-version}</bundle>
     <bundle dependency='true'>mvn:com.fasterxml.jackson.core/jackson-core/${jackson2-version}</bundle>
-    <bundle dependency='true'>mvn:org.apache.httpcomponents/httpcore-osgi/${httpcore4-version}</bundle>
+    <bundle dependency='true'>wrap:mvn:com.google.api/gax-grpc/${google-gax-version}</bundle>
+    <bundle dependency='true'>wrap:mvn:io.grpc/grpc-auth/${grpc-version}</bundle>
+    <bundle dependency='true'>wrap:mvn:com.google.auth/google-auth-library-credentials/${grpc-google-auth-library-version}</bundle>
+    <bundle dependency='true'>wrap:mvn:io.grpc/grpc-netty-shaded/${grpc-version}</bundle>
+    <bundle dependency='true'>wrap:mvn:io.grpc/grpc-alts/${grpc-version}</bundle>
+    <bundle dependency='true'>wrap:mvn:io.grpc/grpc-grpclb/${grpc-version}</bundle>
+    <bundle dependency='true'>mvn:com.google.protobuf/protobuf-java-util/${protobuf-version}</bundle>
+    <bundle dependency='true'>wrap:mvn:org.apache.commons/commons-lang3/${commons-lang3-version}</bundle>
+    <bundle dependency='true'>wrap:mvn:org.conscrypt/conscrypt-openjdk-uber/${conscrypt-uber-version}</bundle>
+    <bundle dependency='true'>wrap:mvn:org.threeten/threetenbp/${threetenbp-version}</bundle>
+    <bundle dependency='true'>wrap:mvn:com.google.code.findbugs/jsr305/${google-findbugs-jsr305-version}</bundle>
+    <bundle dependency='true'>wrap:mvn:io.opencensus/opencensus-api/${opencensus-api-version}</bundle>
+    <bundle dependency='true'>wrap:mvn:io.grpc/grpc-core/${grpc-version}</bundle>
+    <bundle dependency='true'>wrap:mvn:com.google.code.gson/gson/${gson-version}</bundle>
+    <bundle dependency='true'>wrap:mvn:com.google.android/annotations/${android-annotations-version}</bundle>
+    <bundle dependency='true'>wrap:mvn:io.perfmark/perfmark-api/${perfmark-version}</bundle>
+    <bundle dependency='true'>wrap:mvn:io.opencensus/opencensus-contrib-grpc-metrics/${opencensus-api-version}</bundle>
+    <bundle dependency='true'>wrap:mvn:com.google.errorprone/error_prone_annotations/${google-errorprone-version}</bundle>
+    <bundle dependency='true'>wrap:mvn:com.google.auto.value/auto-value-annotations/${google-auto-value-version}</bundle>
+    <bundle dependency='true'>wrap:mvn:com.google.http-client/google-http-client/${google-http-client-version}</bundle>
     <bundle dependency='true'>mvn:org.apache.httpcomponents/httpclient-osgi/${httpclient4-version}</bundle>
-    <bundle dependency='true'>mvn:javax.servlet/javax.servlet-api/${javax-servlet-api-version}</bundle>
+    <bundle dependency='true'>wrap:mvn:commons-logging/commons-logging/${commons-logging-version}</bundle>
+    <bundle dependency='true'>wrap:mvn:commons-codec/commons-codec/${commons-codec-version}</bundle>","[{'comment': 'Do not wrap everything. Some of these are already osgi bundles like commons-logging and so on', 'commenter': 'davsclaus'}, {'comment': ""I've identified the commons-logging and commons-lang3 as bundles. Not sure if I've got all of them now..."", 'commenter': 'alvinkwekel'}]"
3551,components/camel-google-pubsub/src/main/java/org/apache/camel/component/google/pubsub/GooglePubsubEndpoint.java,"@@ -60,14 +65,12 @@
     @UriParam(name = ""maxMessagesPerPoll"", description = ""The max number of messages to receive from the server in a single API call"", defaultValue = ""1"")
     private Integer maxMessagesPerPoll = 1;
 
-    @UriParam(name = ""connectionFactory"", description = ""ConnectionFactory to obtain connection to PubSub Service. If non provided the default one will be used"")
-    private GooglePubsubConnectionFactory connectionFactory;
+    @UriParam(name = ""synchronousPull"", description = ""Synchronously pull batches of messages"", defaultValue = ""false"")
+    private Boolean synchronousPull = false;","[{'comment': 'boolean', 'commenter': 'davsclaus'}]"
3551,parent/pom.xml,"@@ -230,16 +233,27 @@
         <geronimo-jta-spec-version>1.1.1</geronimo-jta-spec-version>
         <geronimo-ws-metadata-spec-version>1.1.3</geronimo-ws-metadata-spec-version>
         <gmetric4j-version>1.0.10</gmetric4j-version>
-        <google-guava-version>19.0</google-guava-version>
+        <google-guava-version>28.1-jre</google-guava-version>","[{'comment': 'Do NOT change this as other components are dependent on this old version. Instead create a new for pubnub (guava hell)', 'commenter': 'davsclaus'}, {'comment': 'Right. Added a new property for pubsub.', 'commenter': 'alvinkwekel'}]"
3551,components/camel-google-pubsub/src/main/java/org/apache/camel/component/google/pubsub/GooglePubsubComponent.java,"@@ -16,19 +16,80 @@
  */
 package org.apache.camel.component.google.pubsub;
 
+import java.io.IOException;
 import java.util.Map;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.TimeUnit;
 
+import com.google.api.gax.core.CredentialsProvider;
+import com.google.api.gax.core.NoCredentialsProvider;
+import com.google.api.gax.grpc.GrpcTransportChannel;
+import com.google.api.gax.rpc.FixedTransportChannelProvider;
+import com.google.api.gax.rpc.TransportChannelProvider;
+import com.google.cloud.pubsub.v1.MessageReceiver;
+import com.google.cloud.pubsub.v1.Publisher;
+import com.google.cloud.pubsub.v1.Subscriber;
+import com.google.cloud.pubsub.v1.stub.SubscriberStub;
+import com.google.cloud.pubsub.v1.stub.SubscriberStubSettings;
+import com.google.common.cache.Cache;
+import com.google.common.cache.CacheBuilder;
+import com.google.common.cache.RemovalListener;
+import io.grpc.ManagedChannel;
+import io.grpc.ManagedChannelBuilder;
 import org.apache.camel.Endpoint;
+import org.apache.camel.spi.Metadata;
 import org.apache.camel.spi.annotations.Component;
 import org.apache.camel.support.DefaultComponent;
+import org.apache.commons.lang3.StringUtils;","[{'comment': 'Avoid using commons lang - Camel has API also for checking if string is empty - StringHelper / ObjectHelper etc.', 'commenter': 'davsclaus'}]"
3552,components/camel-bindy/src/main/java/org/apache/camel/dataformat/bindy/UnicodeHelper.java,"@@ -0,0 +1,209 @@
+package org.apache.camel.dataformat.bindy;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.stream.Collectors;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import com.ibm.icu.text.BreakIterator;
+
+/**
+ * <p>Unterstützung für String-Verarbeitung für Unicode-Strings</p>","[{'comment': 'Please comments must be in English, if not, please remove the German one.', 'commenter': 'oscerd'}, {'comment': 'https://github.com/search?q=org%3Aapache+%27com.ibm.icu.icu4j%27&type=Code', 'commenter': 'oscerd'}]"
3552,components/camel-bindy/pom.xml,"@@ -40,6 +41,11 @@
             <groupId>org.apache.camel</groupId>
             <artifactId>camel-support</artifactId>
         </dependency>
+ 		<dependency>
+			<groupId>com.ibm.icu</groupId>
+			<artifactId>icu4j</artifactId>","[{'comment': 'Using this will require adding a license for this.\r\n\r\nhttps://github.com/search?q=org%3Aapache+%27com.ibm.icu.icu4j%27&type=Code\r\n\r\nOther projects are already using it, not sure this is a good idea, by the way.', 'commenter': 'oscerd'}]"
3552,components/camel-bindy/pom.xml,"@@ -32,6 +32,7 @@
     <description>Camel Bindy data format support</description>
 
     <properties>
+    	<icu4j.version>65.1</icu4j.version>","[{'comment': 'Please put the version property [here](https://github.com/apache/camel/blob/master/parent/pom.xml) as it is easier to manage ', 'commenter': 'omarsmak'}, {'comment': 'Done', 'commenter': 'mgr-lhm'}]"
3594,components/camel-pulsar/src/main/java/org/apache/camel/component/pulsar/configuration/PulsarConfiguration.java,"@@ -51,6 +51,8 @@
     private boolean allowManualAcknowledgement;
     @UriParam(label = ""consumer"", defaultValue = ""10000"")
     private long ackTimeoutMillis = 10000;
+    @UriParam(label = ""consumer"", defaultValue = ""60000000"")
+    private long negativeAckRedeliveryDelayMicros = 60000000;","[{'comment': 'Lets use millis for this option as we do that for all others. micros is soo little that the number is hard to understand, so change it to millis thanks', 'commenter': 'davsclaus'}]"
3595,components/camel-pulsar/src/main/java/org/apache/camel/component/pulsar/configuration/PulsarConfiguration.java,"@@ -55,6 +55,10 @@
     private long ackGroupTimeMillis = 100;
     @UriParam(label = ""consumer"", defaultValue = ""LATEST"")
     private SubscriptionInitialPosition subscriptionInitialPosition = LATEST;
+    @UriParam(label = ""consumer"", description = ""Maximum number of times that a message will be redelivered before being sent to the dead letter queue. If this value is not set, no Dead Letter Policy will be created"")
+    private Integer maxRedeliverCount;
+    @UriParam(label = ""consumer"", description = ""Name of the topic where the messages which fail {maxRedeliverCount} times will be sent. Note: if not set, default topic name will be <topicname>-<subscriptionname>-DLQ"")","[{'comment': 'Lets avoid using {xxx} in the description but just the name of the option is fine', 'commenter': 'davsclaus'}, {'comment': 'Also avoid the < > in the DLQ name as the generated docs in the json will strip out invalid characters.', 'commenter': 'davsclaus'}]"
3595,components/camel-pulsar/src/main/java/org/apache/camel/component/pulsar/configuration/PulsarConfiguration.java,"@@ -354,4 +358,28 @@ public void setMessageRouter(MessageRouter messageRouter) {
         this.messageRouter = messageRouter;
     }
 
+    public Integer getMaxRedeliverCount() {
+        return maxRedeliverCount;
+    }
+
+    /**","[{'comment': 'This javadoc and the option description are not the same, eg if the other options dont have javadoc then remove it also here, eg they are documented in the json/adoc file which is the important place', 'commenter': 'davsclaus'}]"
3603,camel-core/src/main/java/org/apache/camel/impl/DefaultExchange.java,"@@ -109,9 +109,9 @@ public Exchange copy(boolean safeCopy) {
             exchange.getIn().setFault(getIn().isFault());
             if (getIn().hasHeaders()) {
                 exchange.getIn().setHeaders(safeCopyHeaders(getIn().getHeaders()));
-                // just copy the attachments here
-                exchange.getIn().copyAttachments(getIn());
             }
+            // just copy the attachments here","[{'comment': 'As attachments are very very seldom in use, then this has negative performance impact. You should check via `hasAttachments` if any copying is needed.', 'commenter': 'davsclaus'}, {'comment': 'Okay, should I apply this change to the out message as well?', 'commenter': 'oklimberg'}, {'comment': 'Yeah that would be good', 'commenter': 'davsclaus'}]"
3605,core/camel-componentdsl/src/generated/resources/metadata.json,"@@ -5263,6 +5263,26 @@
     ""artifactId"": ""camel-quickfix"",
     ""version"": ""3.2.0-SNAPSHOT""
   },
+  ""QuteComponentBuilderFactory"": {
+    ""kind"": ""component"",
+    ""scheme"": ""qute"",
+    ""extendsScheme"": """",
+    ""syntax"": ""qute:resourceUri"",
+    ""title"": ""Qute"",
+    ""description"": ""Transforms the message using a Quarkus Qute template."",
+    ""label"": ""transformation"",
+    ""deprecated"": false,
+    ""deprecationNote"": ""transformation"",
+    ""async"": false,
+    ""consumerOnly"": false,
+    ""producerOnly"": true,
+    ""lenientProperties"": false,
+    ""javaType"": ""org.apache.camel.component.qute.QuteComponent"",
+    ""firstVersion"": ""3.1.0"",","[{'comment': 'Should be 3.2.0', 'commenter': 'davsclaus'}]"
3605,components/camel-qute/src/generated/resources/qute.json,"@@ -0,0 +1,12 @@
+{
+  ""other"": {
+    ""kind"": ""other"",
+    ""name"": ""qute"",
+    ""title"": ""Qute"",
+    ""description"": ""Camel Qute support"",
+    ""deprecated"": false,
+    ""groupId"": ""org.apache.camel"",
+    ""artifactId"": ""camel-qute"",
+    ""version"": ""3.1.0-SNAPSHOT""","[{'comment': 'Here too, it should be 3.2.0-SNAPSHOT', 'commenter': 'oscerd'}]"
3605,components/camel-qute/src/main/java/org/apache/camel/component/qute/QuteEndpoint.java,"@@ -0,0 +1,185 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.qute;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.Reader;
+import java.net.URL;
+import java.util.Map;
+import java.util.Optional;
+
+import io.quarkus.qute.Engine;
+import io.quarkus.qute.EngineBuilder;
+import io.quarkus.qute.ReflectionValueResolver;
+import io.quarkus.qute.Template;
+import io.quarkus.qute.TemplateInstance;
+import io.quarkus.qute.TemplateLocator.TemplateLocation;
+import io.quarkus.qute.Variant;
+import org.apache.camel.Exchange;
+import org.apache.camel.ExchangePattern;
+import org.apache.camel.component.ResourceEndpoint;
+import org.apache.camel.spi.UriEndpoint;
+import org.apache.camel.spi.UriParam;
+import org.apache.camel.support.ExchangeHelper;
+import org.apache.camel.util.ObjectHelper;
+
+/**
+ * Transforms the message using a Quarkus Qute template.
+ */
+@UriEndpoint(firstVersion = ""3.2.0"", scheme = ""qute"", title = ""Qute"", syntax = ""qute:resourceUri"", producerOnly = true, label = ""transformation"")
+public class QuteEndpoint extends ResourceEndpoint {
+    private Engine quarkusEngine;
+
+    @UriParam
+    private String encoding;
+
+    public QuteEndpoint() {
+    }
+
+    public QuteEndpoint(String uri, QuteComponent component, String resourceUri) {
+        super(uri, component, resourceUri);
+    }
+
+    @Override
+    public ExchangePattern getExchangePattern() {
+        return ExchangePattern.InOut;","[{'comment': 'Is there any reason for this? You can already override the exchangePattern as option if you want.', 'commenter': 'oscerd'}, {'comment': 'No, it should be removed and I just borrow this from the camel-velocity.', 'commenter': 'zhfeng'}]"
3605,components/camel-qute/src/test/java/org/apache/camel/component/qute/QuteTest.java,"@@ -0,0 +1,54 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.qute;
+
+import org.apache.camel.Exchange;
+import org.apache.camel.Processor;
+import org.apache.camel.RoutesBuilder;
+import org.apache.camel.builder.RouteBuilder;
+import org.apache.camel.test.junit4.CamelTestSupport;
+import org.junit.Test;
+
+public class QuteTest extends CamelTestSupport {
+
+    @Test
+    public void testQuteExample() {
+        Exchange exchange = template.request(""direct:a"", new Processor() {
+            @Override
+            public void process(Exchange exchange) throws Exception {
+                exchange.getIn().setBody(""Monday"");
+                exchange.getIn().setHeader(""name"", ""Christian"");
+                exchange.setProperty(""item"", ""7"");
+            }
+        });
+
+        assertEquals(""Dear Christian. You ordered item 7 on Monday."", exchange.getMessage().getBody());
+        assertEquals(""Christian"", exchange.getMessage().getHeader(""name""));
+    }
+
+    @Override
+    protected RoutesBuilder createRouteBuilder() throws Exception {
+        return new RouteBuilder() {
+            public void configure() {
+                // START SNIPPET: example","[{'comment': 'I think the snippet comments could be removed.', 'commenter': 'oscerd'}]"
3605,components/camel-qute/src/generated/java/org/apache/camel/component/qute/QuteComponentConfigurer.java,"@@ -0,0 +1,29 @@
+/* Generated by camel build tools - do NOT edit this file! */","[{'comment': 'Look like auto-generated files should include ASF header.', 'commenter': 'dmvolod'}, {'comment': 'We excluded them from the checkstyle.', 'commenter': 'oscerd'}]"
3605,components/camel-qute/src/main/java/org/apache/camel/component/qute/QuteComponent.java,"@@ -0,0 +1,64 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.qute;
+
+import java.util.Map;
+
+import io.quarkus.qute.Engine;
+import org.apache.camel.Endpoint;
+import org.apache.camel.spi.Metadata;
+import org.apache.camel.spi.annotations.Component;
+import org.apache.camel.support.DefaultComponent;
+import org.apache.camel.support.ResourceHelper;
+
+@Component(""qute"")
+public class QuteComponent extends DefaultComponent {
+
+    @Metadata(label = ""advanced"")
+    private Engine quarkusEngine;","[{'comment': 'This should be named quteEngine', 'commenter': 'davsclaus'}]"
3605,components/camel-qute/src/main/java/org/apache/camel/component/qute/QuteEndpoint.java,"@@ -0,0 +1,179 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.qute;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.Reader;
+import java.net.URL;
+import java.util.Map;
+import java.util.Optional;
+
+import io.quarkus.qute.Engine;
+import io.quarkus.qute.EngineBuilder;
+import io.quarkus.qute.ReflectionValueResolver;
+import io.quarkus.qute.Template;
+import io.quarkus.qute.TemplateInstance;
+import io.quarkus.qute.TemplateLocator.TemplateLocation;
+import io.quarkus.qute.Variant;
+import org.apache.camel.Exchange;
+import org.apache.camel.component.ResourceEndpoint;
+import org.apache.camel.spi.UriEndpoint;
+import org.apache.camel.spi.UriParam;
+import org.apache.camel.support.ExchangeHelper;
+import org.apache.camel.util.ObjectHelper;
+
+/**
+ * Transforms the message using a Quarkus Qute template.
+ */
+@UriEndpoint(firstVersion = ""3.2.0"", scheme = ""qute"", title = ""Qute"", syntax = ""qute:resourceUri"", producerOnly = true, label = ""transformation"")
+public class QuteEndpoint extends ResourceEndpoint {
+    private Engine quarkusEngine;
+
+    @UriParam
+    private String encoding;
+
+    public QuteEndpoint() {
+    }
+
+    public QuteEndpoint(String uri, QuteComponent component, String resourceUri) {
+        super(uri, component, resourceUri);
+    }
+
+    @Override
+    protected String createEndpointUri() {
+        return ""qute:"" + getResourceUri();
+    }
+
+    public void setQuarkusEngine(Engine engine) {
+        this.quarkusEngine = engine;
+    }
+
+    private synchronized Engine getQuarkusEngine() {
+        if (quarkusEngine == null) {
+            EngineBuilder builder = Engine.builder().addDefaults();
+            builder.addValueResolver(ReflectionValueResolver::new);
+            builder.addLocator(this::locate);
+
+            quarkusEngine = builder.build();
+        }
+        return quarkusEngine;
+    }
+
+    private Optional<TemplateLocation> locate(String path) {
+        return Optional.of(new TemplateLocation() {
+            private URL locatePath(String path) {
+                ClassLoader cl = Thread.currentThread().getContextClassLoader();
+                if (cl == null) {
+                    cl = QuteEndpoint.class.getClassLoader();
+                }
+
+                return cl.getResource(path);
+            }
+
+            @Override
+            public Reader read() {
+                try {
+                    InputStream in;
+                    if (path.equals(getResourceUri())) {
+                        in = getResourceAsInputStream();
+                    } else {
+                        in = locatePath(path).openStream();
+                    }
+
+                    Reader reader = getEncoding() != null ? new InputStreamReader(in, getEncoding()) : new InputStreamReader(in);
+                    return reader;
+                } catch (Exception e) {
+                    log.warn(""can not load template "" + path + "" due to "" + e);","[{'comment': 'Cannot', 'commenter': 'davsclaus'}]"
3605,components/camel-qute/src/main/docs/qute-component.adoc,"@@ -0,0 +1,61 @@
+[[qute-component]]
+= Qute Component
+
+*Since Camel 3.2*
+
+// HEADER START
+*Only producer is supported*
+// HEADER END
+
+The Qute component allows you to process a message using an
+https://quarkus.io/guides/qute[Quarkus Qute] template. This can be ideal
+when using Templating to generate responses for
+requests.
+
+== Options
+// component options: START
+The Qute component supports 3 options, which are listed below.
+
+
+
+[width=""100%"",cols=""2,5,^1,2"",options=""header""]
+|===
+| Name | Description | Default | Type
+| *lazyStartProducer* (producer) | Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing. | false | boolean
+| *basicPropertyBinding* (advanced) | Whether the component should use basic property binding (Camel 2.x) or the newer property binding with additional capabilities | false | boolean
+| *quarkusEngine* (advanced) | To use the Engine otherwise a new engine is created |  | Engine
+|===
+// component options: END
+
+// endpoint options: START
+The Qute endpoint is configured using URI syntax:
+
+----
+qute:resourceUri
+----
+
+with the following path and query parameters:
+
+=== Path Parameters (1 parameters):
+
+
+[width=""100%"",cols=""2,5,^1,2"",options=""header""]
+|===
+| Name | Description | Default | Type
+| *resourceUri* | *Required* Path to the resource. You can prefix with: classpath, file, http, ref, or bean. classpath, file and http loads the resource using these protocols (classpath is default). ref will lookup the resource in the registry. bean will call a method on a bean to be used as the resource. For bean you can specify the method name after dot, eg bean:myBean.myMethod. |  | String
+|===
+
+
+=== Query Parameters (5 parameters):
+
+
+[width=""100%"",cols=""2,5,^1,2"",options=""header""]
+|===
+| Name | Description | Default | Type
+| *contentCache* (producer) | Sets whether to use resource content cache or not | false | boolean
+| *encoding* (producer) | Character encoding of the resource content. |  | String
+| *lazyStartProducer* (producer) | Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing. | false | boolean
+| *basicPropertyBinding* (advanced) | Whether the endpoint should use basic property binding (Camel 2.x) or the newer property binding with additional capabilities | false | boolean
+| *synchronous* (advanced) | Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported). | false | boolean
+|===
+// endpoint options: END","[{'comment': 'It would be good to add a new section with one or two examples to the docs', 'commenter': 'davsclaus'}, {'comment': 'yeah, I will add the examples. ', 'commenter': 'zhfeng'}]"
3615,components/camel-file/src/main/docs/file-component.adoc,"@@ -146,10 +146,10 @@ with the following path and query parameters:
 | *eagerMaxMessagesPerPoll* (filter) | Allows for controlling whether the limit from maxMessagesPerPoll is eager or not. If eager then the limit is during the scanning of files. Where as false would scan all files, and then perform sorting. Setting this option to false allows for sorting all files first, and then limit the poll. Mind that this requires a higher memory usage as all file details are in memory to perform the sorting. | true | boolean
 | *exclude* (filter) | Is used to exclude files, if filename matches the regex pattern (matching is case in-senstive). Notice if you use symbols such as plus sign and others you would need to configure this using the RAW() syntax if configuring this as an endpoint uri. See more details at configuring endpoint uris |  | String
 | *filter* (filter) | Pluggable filter as a org.apache.camel.component.file.GenericFileFilter class. Will skip files if filter returns false in its accept() method. |  | GenericFileFilter
-| *filterDirectory* (filter) | Filters the directory based on Simple language. For example to filter on current date, you can use a simple date pattern such as \${date:now:yyyMMdd} |  | String
-| *filterFile* (filter) | Filters the file based on Simple language. For example to filter on file size, you can use \${file:size} 5000 |  | String
+| *filterDirectory* (filter) | Filters the directory based on Simple language. For example to filter on current date, you can use a simple date pattern such as ${date:now:yyyMMdd} |  | String
+| *filterFile* (filter) | Filters the file based on Simple language. For example to filter on file size, you can use ${file:size} 5000 |  | String","[{'comment': 'Those are generated from javadoc. You need to do this in the related javadoc and rebuild the module.', 'commenter': 'oscerd'}]"
3620,components/camel-pulsar/src/main/java/org/apache/camel/component/pulsar/PulsarEndpoint.java,"@@ -45,11 +45,17 @@
     @UriPath
     @Metadata(required = true)
     private String topic;
+
+    @UriParam(defaultValue = ""true"", label = ""advanced"",
+            description = ""Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported)."")","[{'comment': ""I think the description can be removed, since it's already in the javadoc"", 'commenter': 'oscerd'}, {'comment': 'I have removed the description.', 'commenter': 'masahoriyama-toast'}]"
3631,components/camel-sql/src/main/docs/sql-component.adoc,"@@ -180,7 +180,7 @@ with the following path and query parameters:
 | *batch* (producer) | Enables or disables batch mode | false | boolean
 | *lazyStartProducer* (producer) | Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing. | false | boolean
 | *noop* (producer) | If set, will ignore the results of the SQL query and use the existing IN message as the OUT message for the continuation of processing | false | boolean
-| *useMessageBodyForSql* (producer) | Whether to use the message body as the SQL and then headers for parameters. If this option is enabled then the SQL in the uri is not used. | false | boolean
+| *useMessageBodyForSql* (producer) | Whether to use the message body as the SQL and then headers for parameters. If this option is enabled then the SQL in the uri is not used. Note that query parameters in the message body _are_ represented by a `?` instead of a `pass:[#]` symbol. | false | boolean","[{'comment': 'This is autogenerated from the javadoc.. you need to modify the javadoc and rebuild the module, otherwise it will be lost. ', 'commenter': 'oscerd'}, {'comment': ""oops, I'll do that..."", 'commenter': 'vboerchers'}]"
3636,docs/components/modules/ROOT/pages/properties-component.adoc,"@@ -1,6 +1,5 @@
 [[properties-component]]
 = Properties Component
-:page-source: core/camel-base/src/main/docs/properties-component.adoc","[{'comment': ""This needs to be there, don't remove it, there is a reason for having it there"", 'commenter': 'oscerd'}, {'comment': ""This needs to be there, don't remove it, there is a reason for having it there"", 'commenter': 'oscerd'}]"
3637,docs/user-manual/modules/ROOT/pages/index.adoc,"@@ -533,6 +534,53 @@ camel routes without them knowing
 * xref:team.adoc[Team]
 * https://github.com/camel-extra/camel-extra[Camel Extra]
 
+== Requirements
+
+=== Platform Requirements
+
+* Any platform that supports JDK 6 is required.
+
+=== JDK Requirements
+
+* Camel 2.6 or older requires JDK 1.5 or better.
+
+* Camel 2.7 onwards requires JDK 1.6 or JDK 1.7.
+
+* Camel 2.14 onwards requires JDK 1.7 or better.
+
+* Camel 2.18 onwards requires JDK 1.8
+
+=== Camel Jar Requirements","[{'comment': 'I think this section could be completely removed. The other related to JDK could be useful.', 'commenter': 'oscerd'}, {'comment': ""oh okay ,I'll do that"", 'commenter': 'rimshach'}]"
3641,docs/user-manual/modules/ROOT/pages/index.adoc,"@@ -14,6 +14,8 @@ routing rules in your IDE, whether in a Java or XML editor.
 
 For a deeper and better understanding of Apache Camel, an xref:faq/what-is-camel.adoc[Introduction] is provided.
 
+Furthermore, camel has added a new API i.e. Endpoint-dsl. More information can be founded under documentation section.","[{'comment': '""Can be found"" should be better I guess ', 'commenter': 'oscerd'}, {'comment': 'Yes, this should be ""can be found"".I\'ll fix it ', 'commenter': 'rimshach'}, {'comment': 'I have made the change in the file', 'commenter': 'rimshach'}]"
3641,docs/user-manual/modules/ROOT/pages/index.adoc,"@@ -14,6 +14,8 @@ routing rules in your IDE, whether in a Java or XML editor.
 
 For a deeper and better understanding of Apache Camel, an xref:faq/what-is-camel.adoc[Introduction] is provided.
 
+Furthermore, camel has added a new API i.e. Endpoint-dsl. More information can be found under documentation section.","[{'comment': ""Looking at this better, I don't think this is the right place for this. But we could move it later"", 'commenter': 'oscerd'}]"
3645,components/camel-hbase/pom.xml,"@@ -208,36 +75,18 @@
                     <groupId>log4j</groupId>
                     <artifactId>log4j</artifactId>
                 </exclusion>
-                <exclusion>
-                    <groupId>junit</groupId>
-                    <artifactId>junit</artifactId>
-                </exclusion>
             </exclusions>
         </dependency>
-        <!-- because hbase-server 1.1.1 use hadoop2.5.1 by default, check is it still required by the next version update -->
         <dependency>
-            <groupId>org.apache.hadoop</groupId>
-            <artifactId>hadoop-client</artifactId>
-            <version>${hadoop2-version}</version>
-            <classifier>tests</classifier>
+            <groupId>com.google.guava</groupId>
+            <artifactId>guava</artifactId>
+            <version>12.0.1</version>","[{'comment': 'This is really an old version of guava. Anyway, please use a property placeholder from parent', 'commenter': 'oscerd'}, {'comment': ""I used this version, cause it's used in hbase-test util, and it is not working with the version automatically taken (i suppose it its overriden by  some other dep)"", 'commenter': 'manonthegithub'}, {'comment': 'Yeah unfortunately we need to use old version for testing this old hbase version. IMHO as its a test scoped dependency then its okay to stay here as version number, and we should look at upgrading to newer hbase also.', 'commenter': 'davsclaus'}]"
3645,components/camel-hbase/pom.xml,"@@ -208,36 +75,18 @@
                     <groupId>log4j</groupId>
                     <artifactId>log4j</artifactId>
                 </exclusion>
-                <exclusion>
-                    <groupId>junit</groupId>
-                    <artifactId>junit</artifactId>
-                </exclusion>
             </exclusions>
         </dependency>
-        <!-- because hbase-server 1.1.1 use hadoop2.5.1 by default, check is it still required by the next version update -->
         <dependency>
-            <groupId>org.apache.hadoop</groupId>
-            <artifactId>hadoop-client</artifactId>
-            <version>${hadoop2-version}</version>
-            <classifier>tests</classifier>
+            <groupId>com.google.guava</groupId>
+            <artifactId>guava</artifactId>
+            <version>12.0.1</version>
             <scope>test</scope>
-            <exclusions>
-                <exclusion>
-                    <groupId>org.slf4j</groupId>
-                    <artifactId>slf4j-log4j12</artifactId>
-                </exclusion>
-                <exclusion>
-                    <groupId>log4j</groupId>
-                    <artifactId>log4j</artifactId>
-                </exclusion>
-            </exclusions>
         </dependency>
-        <!-- because hbase-server 1.1.1 use hadoop2.5.1 by default, check is it still required by the next version update -->
         <dependency>
-            <groupId>org.apache.hadoop</groupId>
-            <artifactId>hadoop-hdfs</artifactId>
-            <version>${hadoop2-version}</version>
-            <classifier>tests</classifier>
+            <groupId>org.apache.zookeeper</groupId>
+            <artifactId>zookeeper</artifactId>
+            <version>3.4.6</version>","[{'comment': 'Use the zookeeper version property placeholder from parent, or create a new placeholder in parent', 'commenter': 'oscerd'}, {'comment': ""I used this version, cause it's used in hbase-test util, and it is not working with the version automatically taken (i suppose it its overriden by  some other dep)"", 'commenter': 'manonthegithub'}, {'comment': 'Yeah unfortunately we need to use old version for testing this old hbase version. IMHO as its a test scoped dependency then its okay to stay here as version number, and we should look at upgrading to newer hbase also.', 'commenter': 'davsclaus'}]"
3645,components/camel-hbase/pom.xml,"@@ -208,36 +75,18 @@
                     <groupId>log4j</groupId>
                     <artifactId>log4j</artifactId>
                 </exclusion>
-                <exclusion>
-                    <groupId>junit</groupId>
-                    <artifactId>junit</artifactId>
-                </exclusion>
             </exclusions>
         </dependency>
-        <!-- because hbase-server 1.1.1 use hadoop2.5.1 by default, check is it still required by the next version update -->
         <dependency>
-            <groupId>org.apache.hadoop</groupId>
-            <artifactId>hadoop-client</artifactId>
-            <version>${hadoop2-version}</version>","[{'comment': 'I have a question, why you needed to replace the hadoop deps of the hbase client?', 'commenter': 'manonthegithub'}]"
3646,core/camel-core-engine/src/main/docs/modules/eips/pages/hystrixConfiguration-eip.adoc,"@@ -10,34 +10,34 @@ The Hystrix Configuration EIP supports 31 options which are listed below:
 | Name | Description | Default | Type
 | *groupKey* | Sets the group key to use. The default value is CamelHystrix. | CamelHystrix | String
 | *threadPoolKey* | Sets the thread pool key to use. Will by default use the same value as groupKey has been configured to use. | CamelHystrix | String
-| *circuitBreakerEnabled* | Whether to use a HystrixCircuitBreaker or not. If false no circuit-breaker logic will be used and all requests permitted. This is similar in effect to circuitBreakerForceClosed() except that continues tracking metrics and knowing whether it should be open/closed, this property results in not even instantiating a circuit-breaker. | true | Boolean
-| *circuitBreakerError ThresholdPercentage* | Error percentage threshold (as whole number such as 50) at which point the circuit breaker will trip open and reject requests. It will stay tripped for the duration defined in circuitBreakerSleepWindowInMilliseconds; The error percentage this is compared against comes from HystrixCommandMetrics.getHealthCounts(). | 50 | Integer
-| *circuitBreakerForceClosed* | If true the HystrixCircuitBreaker#allowRequest() will always return true to allow requests regardless of the error percentage from HystrixCommandMetrics.getHealthCounts(). The circuitBreakerForceOpen() property takes precedence so if it set to true this property does nothing. | false | Boolean
-| *circuitBreakerForceOpen* | If true the HystrixCircuitBreaker.allowRequest() will always return false, causing the circuit to be open (tripped) and reject all requests. This property takes precedence over circuitBreakerForceClosed(); | false | Boolean
-| *circuitBreakerRequestVolume Threshold* | Minimum number of requests in the metricsRollingStatisticalWindowInMilliseconds() that must exist before the HystrixCircuitBreaker will trip. If below this number the circuit will not trip regardless of error percentage. | 20 | Integer
-| *circuitBreakerSleepWindow InMilliseconds* | The time in milliseconds after a HystrixCircuitBreaker trips open that it should wait before trying requests again. | 5000 | Integer
-| *executionIsolationSemaphore MaxConcurrentRequests* | Number of concurrent requests permitted to HystrixCommand.run(). Requests beyond the concurrent limit will be rejected. Applicable only when executionIsolationStrategy == SEMAPHORE. | 20 | Integer
+| *circuitBreakerEnabled* | Whether to use a HystrixCircuitBreaker or not. If false no circuit-breaker logic will be used and all requests permitted. This is similar in effect to circuitBreakerForceClosed() except that continues tracking metrics and knowing whether it should be open/closed, this property results in not even instantiating a circuit-breaker. | true | String
+| *circuitBreakerErrorThreshold Percentage* | Error percentage threshold (as whole number such as 50) at which point the circuit breaker will trip open and reject requests. It will stay tripped for the duration defined in circuitBreakerSleepWindowInMilliseconds; The error percentage this is compared against comes from HystrixCommandMetrics.getHealthCounts(). | 50 | String
+| *circuitBreakerForceClosed* | If true the HystrixCircuitBreaker#allowRequest() will always return true to allow requests regardless of the error percentage from HystrixCommandMetrics.getHealthCounts(). The circuitBreakerForceOpen() property takes precedence so if it set to true this property does nothing. | false | String
+| *circuitBreakerForceOpen* | If true the HystrixCircuitBreaker.allowRequest() will always return false, causing the circuit to be open (tripped) and reject all requests. This property takes precedence over circuitBreakerForceClosed(); | false | String
+| *circuitBreakerRequestVolume Threshold* | Minimum number of requests in the metricsRollingStatisticalWindowInMilliseconds() that must exist before the HystrixCircuitBreaker will trip. If below this number the circuit will not trip regardless of error percentage. | 20 | String
+| *circuitBreakerSleepWindowIn Milliseconds* | The time in milliseconds after a HystrixCircuitBreaker trips open that it should wait before trying requests again. | 5000 | String","[{'comment': 'There is something in your change that is causing all the types of these EIPs to be wrong, eg the Integer -> String. And so on.', 'commenter': 'davsclaus'}, {'comment': 'Perhaps you could suggest what might be causing this: checking the (generated) json source for one of these the type is being copied from json to adoc accurately:\r\n```\r\n    ""circuitBreakerEnabled"": { ""kind"": ""attribute"", ""displayName"": ""Circuit Breaker Enabled"", ""required"": false, ""type"": ""string"", ""javaType"": ""java.lang.String"", ""deprecated"": false, ""secret"": false, ""defaultValue"": ""true"", ""description"": ""Whether to use a HystrixCircuitBreaker or not. If false no circuit-breaker logic will be used and all requests permitted. This is similar in effect to circuitBreakerForceClosed() except that continues tracking metrics and knowing whether it should be open\\/closed, this property results in not even instantiating a circuit-breaker."" },\r\n```\r\n\r\nAFAICT I didn\'t touch any part of the code or build that could possibly affect the json generation.', 'commenter': 'djencks'}]"
3665,PR-template.html,"@@ -0,0 +1,6 @@
+- [ ] Make sure there is a [JIRA issue](https://issues.apache.org/jira/browse/CAMEL) filed for the change (usually before you start working on it).  Trivial changes like typos do not require a JIRA issue.  Your pull request should address just this issue, without pulling in other changes.
+- [ ] Each commit in the pull request should have a meaningful subject line and body.
+- [ ] Format the pull request title like `[CAMEL-XXX] Fixes bug in camel-file component`, where you replace `CAMEL-XXX` with the appropriate JIRA issue.
+- [ ] Write a pull request description that is detailed enough to understand what the pull request does, how, and why.
+- [ ] Run `mvn clean install` in your module to make sure basic checks pass. A more thorough check will be performed on your pull request automatically.
+- [ ] If this contribution is large, please file an Apache [Individual Contributor License Agreement](https://www.apache.org/licenses/icla.pdf).","[{'comment': '- the ICLA is not needed, usually it is something for contributors becoming committers or part of the PMCs.\r\n- the point about JIRA issue is true only if the PR is large and introduce somenthing new, for little things is not needed.\r\n- so sometimes the point 3 is not needed', 'commenter': 'oscerd'}]"
3665,PR-template.html,"@@ -0,0 +1,5 @@
+[ ] Make sure there is a [JIRA issue](https://issues.apache.org/jira/browse/CAMEL) filed for the change (usually before you start working on it).  Trivial changes like typos do not require a JIRA issue.  Your pull request should address just this issue, without pulling in other changes.
+[ ] Each commit in the pull request should have a meaningful subject line and body.
+[ ] If you're unsure, you can format the pull request title like `[CAMEL-XXX] Fixes bug in camel-file component`, where you replace `CAMEL-XXX` with the appropriate JIRA issue.
+[ ] Write a pull request description that is detailed enough to understand what the pull request does, how, and why.
+[ ] Run `mvn clean install` in your module to make sure basic checks pass. A more thorough check will be performed on your pull request automatically.","[{'comment': ""I'd amend this to include the sourcecheck as pretty often gets forgotten in the process:\r\n```suggestion\r\n[ ] Run `mvn clean install -Psourcecheck` in your module with source check enabled to make sure basic checks pass and there are no checkstyle violations. A more thorough check will be performed on your pull request automatically.\r\n```"", 'commenter': 'omarsmak'}, {'comment': '@Xxyumi-hub perhaps you can take a look at this comment :) ', 'commenter': 'omarsmak'}, {'comment': 'Yes, please @Xxyumi-hub have a look at this comment and fix it.', 'commenter': 'oscerd'}]"
3665,PR-Template.txt,"@@ -0,0 +1,7 @@
+[ ] Make sure there is a [JIRA issue](https://issues.apache.org/jira/browse/CAMEL) filed for the change (usually before you start working on it).  Trivial changes like typos do not require a JIRA issue.  Your pull request should address just this issue, without pulling in other changes.
+[ ] Each commit in the pull request should have a meaningful subject line and body.
+[ ] If you're unsure, you can format the pull request title like `[CAMEL-XXX] Fixes bug in camel-file component`, where you replace `CAMEL-XXX` with the appropriate JIRA issue.","[{'comment': '[CAMEL-XXX]: Fixes bug in camel-file component', 'commenter': 'dmvolod'}, {'comment': 'Ah so reword my PR request like [CAMEL-13704] Added PR template file?\r\n', 'commenter': 'Xxyumi-hub'}]"
3665,PR-Template.txt,"@@ -0,0 +1,7 @@
+[ ] Make sure there is a [JIRA issue](https://issues.apache.org/jira/browse/CAMEL) filed for the change (usually before you start working on it).  Trivial changes like typos do not require a JIRA issue.  Your pull request should address just this issue, without pulling in other changes.","[{'comment': 'Looks like start point is https://issues.apache.org/jira/projects/CAMEL/issues', 'commenter': 'dmvolod'}, {'comment': 'CAMEL-13704 is the one I thought I could work on, do I have to do something to claim the issue?', 'commenter': 'Xxyumi-hub'}]"
3677,components/camel-undertow/src/main/java/org/apache/camel/component/undertow/UndertowComponent.java,"@@ -78,6 +87,7 @@
     @Metadata(label = ""security"")
     private String allowedRoles;
 
+    private UndertowSecurityProvider securityProvider;","[{'comment': 'Add @Metadata with security label.', 'commenter': 'davsclaus'}, {'comment': '@davsclaus this is not parameter which comes from configuration, it is just private variable that is used by component when SPI implementation is searched for. From my POV there should be annotation like @nometadata in tis case.', 'commenter': 'JiriOndrusek'}]"
3677,components/camel-undertow/src/main/java/org/apache/camel/component/undertow/UndertowComponent.java,"@@ -435,4 +476,8 @@ public String getAllowedRoles() {
     public void setAllowedRoles(String allowedRoles) {
         this.allowedRoles = allowedRoles;
     }
+
+    public UndertowSecurityProvider getSecurityProvider() {","[{'comment': 'Add setter so you can set this explicit', 'commenter': 'davsclaus'}, {'comment': 'I can do it also this way, in that case please ignore my previous comment', 'commenter': 'JiriOndrusek'}]"
3677,components/camel-undertow/src/main/java/org/apache/camel/component/undertow/UndertowComponent.java,"@@ -306,6 +339,8 @@ public Producer createProducer(CamelContext camelContext, String host,
     protected void doStart() throws Exception {
         super.doStart();
 
+        initSecurityProvider();","[{'comment': 'Only init if the security provider is null', 'commenter': 'davsclaus'}, {'comment': ""I'll change it"", 'commenter': 'JiriOndrusek'}]"
3677,components/camel-undertow/src/main/java/org/apache/camel/component/undertow/UndertowEndpoint.java,"@@ -147,7 +147,11 @@ public UndertowComponent getComponent() {
     }
 
     public UndertowSecurityProvider getSecurityProvider() {
-        return securityProvider;
+        if (this.securityProvider == null) {","[{'comment': 'getter/setters should be plain, not these tricks. Instead when creating the endpoint in the component, then set the security provider on the endpoint correctly', 'commenter': 'davsclaus'}, {'comment': ""ok, I'll do it, thanks for explanation"", 'commenter': 'JiriOndrusek'}]"
3677,components/camel-undertow/src/main/java/org/apache/camel/component/undertow/UndertowEndpoint.java,"@@ -454,14 +458,13 @@ public boolean isPreserveHostHeader() {
     }
 
     public Object getSecurityConfiguration() {
-        return this.securityConfiguration == null ? getComponent().getSecurityConfiguration() : this.securityConfiguration;
+        return this.securityConfiguration;
     }
 
     public void setSecurityConfiguration(Object securityConfiguration) {
         this.securityConfiguration = securityConfiguration;
     }
 
-
     public String getAllowedRoles() {
         return allowedRoles == null ? getComponent().getAllowedRoles() : allowedRoles;","[{'comment': 'See prev comment, getter/setter should be plain', 'commenter': 'davsclaus'}, {'comment': ""I'll change it"", 'commenter': 'JiriOndrusek'}]"
3682,components/camel-azure/src/main/java/org/apache/camel/component/azure/blob/BlobHeadersConstants.java,"@@ -0,0 +1,23 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.azure.blob;
+
+public interface BlobHeadersConstants {
+
+    String OVERRIDE_BLOB_NAME = ""overrideBlobName"";","[{'comment': 'The header should start with Camel; `CamelOverrideBlobName`', 'commenter': 'davsclaus'}]"
3682,components/camel-azure/src/main/java/org/apache/camel/component/azure/blob/BlobServiceComponent.java,"@@ -27,11 +27,14 @@
 import org.apache.camel.spi.Metadata;
 import org.apache.camel.spi.annotations.Component;
 import org.apache.camel.support.DefaultComponent;
+import org.apache.commons.lang3.StringUtils;","[{'comment': 'Remove import not used', 'commenter': 'davsclaus'}]"
3682,components/camel-azure/src/main/java/org/apache/camel/component/azure/blob/BlobServiceProducer.java,"@@ -46,9 +46,12 @@
 import org.apache.camel.support.DefaultProducer;
 import org.apache.camel.util.ObjectHelper;
 import org.apache.camel.util.URISupport;
+import org.apache.commons.lang3.StringUtils;","[{'comment': 'Remove import not used', 'commenter': 'davsclaus'}]"
3682,components/camel-azure/src/main/java/org/apache/camel/component/azure/blob/BlobServiceProducer.java,"@@ -495,4 +501,13 @@ private void closeInputStreamIfNeeded(InputStream inputStream) throws IOExceptio
         }
     }
 
+
+    private void overrideBlobName(Exchange exchange) {
+        String blobName = exchange.getIn().getHeader(OVERRIDE_BLOB_NAME, String.class);
+
+        if (StringUtils.isNotEmpty(blobName)) {","[{'comment': ""Use Camel's ObjectHelper - org.apache.camel.util.ObjectHelper#isNotEmpty"", 'commenter': 'davsclaus'}]"
3682,components/camel-azure/src/main/java/org/apache/camel/component/azure/blob/BlobServiceProducer.java,"@@ -495,4 +500,12 @@ private void closeInputStreamIfNeeded(InputStream inputStream) throws IOExceptio
         }
     }
 
+
+    private void overrideBlobName(Exchange exchange) {
+        String blobName = exchange.getIn().getHeader(OVERRIDE_BLOB_NAME, String.class);","[{'comment': 'Ah this is wrong, you should not change the endpoint value. Instead you should return the blob name to use, eg pick from header if exists, if not then fallback and use configured value from endpoint configuratoon', 'commenter': 'davsclaus'}, {'comment': '@davsclaus Can you please give me a little more guidance regarding what you want. Do you want me to provide the overridden blobName through the getBlobName() method which is in BlobServiceEndpoint class?', 'commenter': 'djoleB'}, {'comment': 'if exchange header has blob name then \r\n  to use blob name = exchange header \r\notherwise \r\n  to use blob name = endpoint blob name\r\n\r\nAnd then use the ""to use blob name"" in the producer', 'commenter': 'davsclaus'}]"
3703,components/camel-djl/pom.xml,"@@ -0,0 +1,174 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
+         xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+
+    <modelVersion>4.0.0</modelVersion>
+
+    <parent>
+        <artifactId>components</artifactId>
+        <groupId>org.apache.camel</groupId>
+        <version>3.2.0-SNAPSHOT</version>
+    </parent>
+
+    <artifactId>camel-djl</artifactId>
+    <packaging>jar</packaging>
+    <name>Camel :: Deep Java Library</name>
+    <description>Camel Deep Java Library support</description>
+
+    <properties>
+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
+        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
+        <djl.version>0.4.0</djl.version>","[{'comment': '@mgubaidullin we usually keep all versions inside parent/pom.xml for better updating support ', 'commenter': 'dmvolod'}, {'comment': 'Done', 'commenter': 'mgubaidullin'}]"
3703,components/camel-djl/pom.xml,"@@ -0,0 +1,174 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
+         xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+
+    <modelVersion>4.0.0</modelVersion>
+
+    <parent>
+        <artifactId>components</artifactId>
+        <groupId>org.apache.camel</groupId>
+        <version>3.2.0-SNAPSHOT</version>
+    </parent>
+
+    <artifactId>camel-djl</artifactId>
+    <packaging>jar</packaging>
+    <name>Camel :: Deep Java Library</name>
+    <description>Camel Deep Java Library support</description>
+
+    <properties>
+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
+        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
+        <djl.version>0.4.0</djl.version>
+    </properties>
+
+    <dependencyManagement>","[{'comment': ""We don't need this on component level and just using when someone Camel in your code "", 'commenter': 'dmvolod'}, {'comment': 'Done', 'commenter': 'mgubaidullin'}]"
3703,components/camel-djl/src/main/java/org/apache/camel/component/djl/DJLEndpoint.java,"@@ -0,0 +1,98 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.camel.component.djl;
+
+import org.apache.camel.Consumer;
+import org.apache.camel.Processor;
+import org.apache.camel.Producer;
+import org.apache.camel.spi.Metadata;
+import org.apache.camel.spi.UriEndpoint;
+import org.apache.camel.spi.UriParam;
+import org.apache.camel.spi.UriPath;
+import org.apache.camel.support.DefaultEndpoint;
+
+/**
+ * Represents a DJL endpoint.
+ */
+@UriEndpoint(firstVersion = ""3.2.0"", scheme = ""djl"", title = ""DJL"", syntax = ""djl:application"", label = ""djl"", producerOnly = true)","[{'comment': ""I'd use different label here, perhaps something like `deeplearning`?"", 'commenter': 'omarsmak'}, {'comment': 'Done', 'commenter': 'mgubaidullin'}]"
3703,components/camel-djl/pom.xml,"@@ -0,0 +1,174 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
+         xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+
+    <modelVersion>4.0.0</modelVersion>
+
+    <parent>
+        <artifactId>components</artifactId>
+        <groupId>org.apache.camel</groupId>
+        <version>3.2.0-SNAPSHOT</version>
+    </parent>
+
+    <artifactId>camel-djl</artifactId>
+    <packaging>jar</packaging>
+    <name>Camel :: Deep Java Library</name>
+    <description>Camel Deep Java Library support</description>
+
+    <properties>
+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
+        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
+        <djl.version>0.4.0</djl.version>
+    </properties>
+
+    <dependencyManagement>
+        <dependencies>
+            <!-- Camel BOM -->
+            <dependency>
+                <groupId>org.apache.camel</groupId>","[{'comment': 'The bom is not needed in the main repo, have a look at how the other components are structured @mgubaidullin ', 'commenter': 'oscerd'}, {'comment': 'Done', 'commenter': 'mgubaidullin'}]"
3703,components/camel-djl/pom.xml,"@@ -0,0 +1,174 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
+         xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+
+    <modelVersion>4.0.0</modelVersion>
+
+    <parent>
+        <artifactId>components</artifactId>
+        <groupId>org.apache.camel</groupId>
+        <version>3.2.0-SNAPSHOT</version>
+    </parent>
+
+    <artifactId>camel-djl</artifactId>
+    <packaging>jar</packaging>
+    <name>Camel :: Deep Java Library</name>
+    <description>Camel Deep Java Library support</description>
+
+    <properties>
+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
+        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
+        <djl.version>0.4.0</djl.version>
+    </properties>
+
+    <dependencyManagement>
+        <dependencies>
+            <!-- Camel BOM -->
+            <dependency>
+                <groupId>org.apache.camel</groupId>
+                <artifactId>camel-bom</artifactId>
+                <version>3.1.0</version>
+                <scope>import</scope>
+                <type>pom</type>
+            </dependency>
+        </dependencies>
+    </dependencyManagement>
+
+    <dependencies>
+
+        <!-- camel -->
+        <dependency>
+            <groupId>org.apache.camel</groupId>
+            <artifactId>camel-support</artifactId>
+        </dependency>
+
+        <!-- DJL -->
+        <dependency>
+            <groupId>ai.djl</groupId>
+            <artifactId>api</artifactId>
+            <version>${djl.version}</version>
+        </dependency>
+        <dependency>
+            <groupId>ai.djl</groupId>
+            <artifactId>model-zoo</artifactId>
+            <version>${djl.version}</version>
+        </dependency>
+
+        <!-- MxNet Engine -->
+        <dependency>
+            <groupId>ai.djl.mxnet</groupId>
+            <artifactId>mxnet-model-zoo</artifactId>
+            <version>${djl.version}</version>
+        </dependency>
+        <dependency>
+            <groupId>ai.djl.mxnet</groupId>
+            <artifactId>mxnet-engine</artifactId>
+            <version>${djl.version}</version>
+        </dependency>
+        <dependency>
+            <groupId>ai.djl.mxnet</groupId>
+            <artifactId>mxnet-native-auto</artifactId>
+            <version>1.6.0</version>
+            <scope>runtime</scope>
+        </dependency>
+
+        <!-- logging -->
+        <dependency>
+            <groupId>org.apache.logging.log4j</groupId>
+            <artifactId>log4j-api</artifactId>
+            <version>2.13.0</version>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.apache.logging.log4j</groupId>
+            <artifactId>log4j-core</artifactId>
+            <version>2.13.0</version>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.apache.logging.log4j</groupId>
+            <artifactId>log4j-slf4j-impl</artifactId>
+            <version>2.13.0</version>","[{'comment': 'Please use the version from parent/pom', 'commenter': 'oscerd'}, {'comment': 'Done', 'commenter': 'mgubaidullin'}]"
3703,components/camel-djl/src/main/java/org/apache/camel/component/djl/DJLEndpoint.java,"@@ -0,0 +1,98 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.camel.component.djl;
+
+import org.apache.camel.Consumer;
+import org.apache.camel.Processor;
+import org.apache.camel.Producer;
+import org.apache.camel.spi.Metadata;
+import org.apache.camel.spi.UriEndpoint;
+import org.apache.camel.spi.UriParam;
+import org.apache.camel.spi.UriPath;
+import org.apache.camel.support.DefaultEndpoint;
+
+/**
+ * Represents a DJL endpoint.
+ */
+@UriEndpoint(firstVersion = ""3.2.0"", scheme = ""djl"", title = ""DJL"", syntax = ""djl:application"", label = ""djl"", producerOnly = true)
+public class DJLEndpoint extends DefaultEndpoint {
+
+    @UriPath @Metadata(required = true, description = ""Application name"")
+    private String application;
+
+    @Metadata(required = false)
+    @UriParam(label = ""producer"", description = ""Model Artifact"")
+    private String artifactId;
+
+    @Metadata(required = false)
+    @UriParam(label = ""producer"", description = ""Model"")
+    private String model;
+
+    @Metadata(required = false)
+    @UriParam(label = ""producer"", description = ""Translator"")
+    private String translator;
+
+    public DJLEndpoint(String uri, DJLComponent component, String application) {
+        super(uri, component);
+        this.application = application;
+    }
+
+    public Producer createProducer() throws Exception {
+        return new DJLProducer(this);
+    }
+
+    public Consumer createConsumer(Processor processor) throws Exception {
+        throw new UnsupportedOperationException(""Consumer not supported"");
+    }
+
+    public boolean isSingleton() {","[{'comment': 'no need to override this, is a singleton by default', 'commenter': 'omarsmak'}, {'comment': 'Fixed', 'commenter': 'mgubaidullin'}]"
3703,components/camel-djl/pom.xml,"@@ -0,0 +1,174 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
+         xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+
+    <modelVersion>4.0.0</modelVersion>
+
+    <parent>
+        <artifactId>components</artifactId>
+        <groupId>org.apache.camel</groupId>
+        <version>3.2.0-SNAPSHOT</version>
+    </parent>
+
+    <artifactId>camel-djl</artifactId>
+    <packaging>jar</packaging>
+    <name>Camel :: Deep Java Library</name>
+    <description>Camel Deep Java Library support</description>
+
+    <properties>
+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
+        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
+        <djl.version>0.4.0</djl.version>
+    </properties>
+
+    <dependencyManagement>
+        <dependencies>
+            <!-- Camel BOM -->
+            <dependency>
+                <groupId>org.apache.camel</groupId>
+                <artifactId>camel-bom</artifactId>
+                <version>3.1.0</version>
+                <scope>import</scope>
+                <type>pom</type>
+            </dependency>
+        </dependencies>
+    </dependencyManagement>
+
+    <dependencies>
+
+        <!-- camel -->
+        <dependency>
+            <groupId>org.apache.camel</groupId>
+            <artifactId>camel-support</artifactId>
+        </dependency>
+
+        <!-- DJL -->
+        <dependency>
+            <groupId>ai.djl</groupId>
+            <artifactId>api</artifactId>
+            <version>${djl.version}</version>
+        </dependency>
+        <dependency>
+            <groupId>ai.djl</groupId>
+            <artifactId>model-zoo</artifactId>
+            <version>${djl.version}</version>
+        </dependency>
+
+        <!-- MxNet Engine -->
+        <dependency>
+            <groupId>ai.djl.mxnet</groupId>
+            <artifactId>mxnet-model-zoo</artifactId>
+            <version>${djl.version}</version>
+        </dependency>
+        <dependency>
+            <groupId>ai.djl.mxnet</groupId>
+            <artifactId>mxnet-engine</artifactId>
+            <version>${djl.version}</version>
+        </dependency>
+        <dependency>
+            <groupId>ai.djl.mxnet</groupId>
+            <artifactId>mxnet-native-auto</artifactId>
+            <version>1.6.0</version>
+            <scope>runtime</scope>
+        </dependency>
+
+        <!-- logging -->
+        <dependency>
+            <groupId>org.apache.logging.log4j</groupId>
+            <artifactId>log4j-api</artifactId>
+            <version>2.13.0</version>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.apache.logging.log4j</groupId>
+            <artifactId>log4j-core</artifactId>
+            <version>2.13.0</version>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.apache.logging.log4j</groupId>
+            <artifactId>log4j-slf4j-impl</artifactId>
+            <version>2.13.0</version>
+            <scope>test</scope>
+        </dependency>
+
+        <!-- testing -->
+        <dependency>
+            <groupId>org.apache.camel</groupId>
+            <artifactId>camel-test</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>ai.djl</groupId>
+            <artifactId>basicdataset</artifactId>
+            <version>${djl.version}</version>
+            <scope>test</scope>
+        </dependency>
+    </dependencies>
+
+    <build>
+        <defaultGoal>install</defaultGoal>
+
+        <plugins>
+
+            <plugin>
+                <groupId>org.apache.maven.plugins</groupId>
+                <artifactId>maven-compiler-plugin</artifactId>
+                <version>3.8.1</version>
+                <configuration>
+                    <source>1.8</source>
+                    <target>1.8</target>
+                </configuration>
+            </plugin>
+
+            <plugin>
+                <groupId>org.apache.maven.plugins</groupId>
+                <artifactId>maven-resources-plugin</artifactId>
+                <version>3.1.0</version>
+                <configuration>
+                    <encoding>UTF-8</encoding>
+                </configuration>
+            </plugin>
+
+            <!-- generate components meta-data -->
+            <plugin>
+                <groupId>org.apache.camel</groupId>
+                <artifactId>camel-package-maven-plugin</artifactId>
+                <version>3.1.0</version>","[{'comment': 'here it should be project.version', 'commenter': 'oscerd'}]"
3703,components/camel-djl/src/main/docs/djl-component.adoc,"@@ -0,0 +1,203 @@
+[[djl-component]]
+= Deep Java Library Component
+
+*Since Camel 3.2*
+
+// HEADER START
+*Only producer is supported*
+// HEADER END
+
+The *Deep Java Library* component is used to infer Deep Learning models from message exchanges data.
+This component uses https://djl.ai/[Deep Java Library] as underlying library.
+
+In order to use the DJL component, Maven users will need to add the
+following dependency to their `pom.xml`:
+
+*pom.xml*
+
+[source,xml]
+----
+<dependency>
+    <groupId>org.apache.camel</groupId>
+    <artifactId>camel-djl</artifactId>
+    <version>x.x.x</version>
+    <!-- use the same version as your Camel core version -->
+</dependency>
+----
+
+The DJL component only supports producer endpoints.
+
+// endpoint options: START
+The DJL endpoint is configured using URI syntax:
+
+----
+djl:application
+----
+
+with the following path and query parameters:
+
+=== Path Parameters (1 parameters):
+
+[width=""100%"",cols=""2,5,^1,2"",options=""header""]
+|===
+| Name | Description | Default | Type
+| *application* | *Required* Common deep learning application type. The value can be one of:
+`cv/image_classification`,","[{'comment': ""I don't know if this will be rendered correctly on the website, lets see"", 'commenter': 'oscerd'}]"
3703,components/camel-djl/src/main/java/org/apache/camel/component/djl/DJLProducer.java,"@@ -0,0 +1,48 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.camel.component.djl;
+
+import org.apache.camel.Exchange;
+import org.apache.camel.component.djl.model.AbstractPredictor;
+import org.apache.camel.component.djl.model.ModelPredictorProducer;
+import org.apache.camel.support.DefaultProducer;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * The DJL producer.
+ */
+public class DJLProducer extends DefaultProducer {
+    private static final Logger LOG = LoggerFactory.getLogger(DJLProducer.class);
+    private DJLEndpoint endpoint;","[{'comment': ""You don't need to have this `endpoint` property here. By default is available to you when you initiate the superclass constructors through `super(endpoint)` and then you can access it through `getEndpoint()` method"", 'commenter': 'omarsmak'}]"
3703,components/pom.xml,"@@ -374,7 +373,8 @@
         <module>camel-zipkin</module>
         <module>camel-zookeeper-master</module>
         <module>camel-zookeeper</module>
-    </modules>
+    <module>camel-djl</module>","[{'comment': 'Maybe correct the order here', 'commenter': 'oscerd'}, {'comment': 'Done', 'commenter': 'mgubaidullin'}]"
3703,components/camel-djl/src/main/java/org/apache/camel/component/djl/model/CustomImageClassificationPredictor.java,"@@ -0,0 +1,96 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.camel.component.djl.model;
+
+import java.awt.image.BufferedImage;
+import java.io.ByteArrayInputStream;
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.List;
+import java.util.Map;
+import java.util.stream.Collectors;
+
+import javax.imageio.ImageIO;
+
+import ai.djl.Model;
+import ai.djl.inference.Predictor;
+import ai.djl.modality.Classifications;
+import ai.djl.translate.TranslateException;
+import ai.djl.translate.Translator;
+import org.apache.camel.Exchange;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class CustomImageClassificationPredictor extends AbstractPredictor {
+    private static final Logger LOG = LoggerFactory.getLogger(CustomImageClassificationPredictor.class);
+
+    private String modelName;
+    private String translatorName;
+
+    public CustomImageClassificationPredictor(String modelName, String translatorName) {
+        this.modelName = modelName;
+        this.translatorName = translatorName;
+    }
+
+    @Override
+    public void process(Exchange exchange) throws Exception {
+        Model model = exchange.getContext().getRegistry().lookupByNameAndType(modelName, Model.class);
+        Translator translator = exchange.getContext().getRegistry().lookupByNameAndType(translatorName, Translator.class);
+
+        if (exchange.getIn().getBody() instanceof byte[]) {
+            byte[] bytes = exchange.getIn().getBody(byte[].class);
+            Map<String, Float> result = classify(model, translator, new ByteArrayInputStream(bytes));
+            exchange.getIn().setBody(result);
+        } else if (exchange.getIn().getBody() instanceof File) {
+            Map<String, Float> result = classify(model, translator, exchange.getIn().getBody(File.class));
+            exchange.getIn().setBody(result);
+        } else if (exchange.getIn().getBody() instanceof InputStream) {
+            Map<String, Float> result = classify(model, translator, exchange.getIn().getBody(InputStream.class));
+            exchange.getIn().setBody(result);
+        }","[{'comment': 'Does it suppose to throw an error in case non of these conditions being satisfied? ', 'commenter': 'omarsmak'}]"
3703,components/camel-djl/src/main/java/org/apache/camel/component/djl/model/CustomImageClassificationPredictor.java,"@@ -0,0 +1,96 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.camel.component.djl.model;
+
+import java.awt.image.BufferedImage;
+import java.io.ByteArrayInputStream;
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.List;
+import java.util.Map;
+import java.util.stream.Collectors;
+
+import javax.imageio.ImageIO;
+
+import ai.djl.Model;
+import ai.djl.inference.Predictor;
+import ai.djl.modality.Classifications;
+import ai.djl.translate.TranslateException;
+import ai.djl.translate.Translator;
+import org.apache.camel.Exchange;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class CustomImageClassificationPredictor extends AbstractPredictor {
+    private static final Logger LOG = LoggerFactory.getLogger(CustomImageClassificationPredictor.class);
+
+    private String modelName;
+    private String translatorName;
+
+    public CustomImageClassificationPredictor(String modelName, String translatorName) {
+        this.modelName = modelName;
+        this.translatorName = translatorName;
+    }
+
+    @Override
+    public void process(Exchange exchange) throws Exception {
+        Model model = exchange.getContext().getRegistry().lookupByNameAndType(modelName, Model.class);
+        Translator translator = exchange.getContext().getRegistry().lookupByNameAndType(translatorName, Translator.class);
+
+        if (exchange.getIn().getBody() instanceof byte[]) {
+            byte[] bytes = exchange.getIn().getBody(byte[].class);
+            Map<String, Float> result = classify(model, translator, new ByteArrayInputStream(bytes));
+            exchange.getIn().setBody(result);
+        } else if (exchange.getIn().getBody() instanceof File) {
+            Map<String, Float> result = classify(model, translator, exchange.getIn().getBody(File.class));
+            exchange.getIn().setBody(result);
+        } else if (exchange.getIn().getBody() instanceof InputStream) {
+            Map<String, Float> result = classify(model, translator, exchange.getIn().getBody(InputStream.class));
+            exchange.getIn().setBody(result);
+        }
+    }
+
+    private Map<String, Float> classify(Model model, Translator translator, File input) throws Exception {
+        try {
+            return classify(model, translator, ImageIO.read(input));
+        } catch (IOException e) {
+            LOG.error(""Couldn't transform input into a BufferedImage"");
+            throw new Exception(""Couldn't transform input into a BufferedImage"", e);","[{'comment': ""I'd favour to narrow down the exception being thrown here, `Exception` is too generic. Perhaps anything that inherits or it is  `RuntimeExceptioon`."", 'commenter': 'omarsmak'}, {'comment': 'Fixed', 'commenter': 'mgubaidullin'}]"
3703,components/camel-djl/src/main/java/org/apache/camel/component/djl/model/CustomImageClassificationPredictor.java,"@@ -0,0 +1,96 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.camel.component.djl.model;
+
+import java.awt.image.BufferedImage;
+import java.io.ByteArrayInputStream;
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.List;
+import java.util.Map;
+import java.util.stream.Collectors;
+
+import javax.imageio.ImageIO;
+
+import ai.djl.Model;
+import ai.djl.inference.Predictor;
+import ai.djl.modality.Classifications;
+import ai.djl.translate.TranslateException;
+import ai.djl.translate.Translator;
+import org.apache.camel.Exchange;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class CustomImageClassificationPredictor extends AbstractPredictor {
+    private static final Logger LOG = LoggerFactory.getLogger(CustomImageClassificationPredictor.class);
+
+    private String modelName;
+    private String translatorName;
+
+    public CustomImageClassificationPredictor(String modelName, String translatorName) {
+        this.modelName = modelName;
+        this.translatorName = translatorName;
+    }
+
+    @Override
+    public void process(Exchange exchange) throws Exception {
+        Model model = exchange.getContext().getRegistry().lookupByNameAndType(modelName, Model.class);
+        Translator translator = exchange.getContext().getRegistry().lookupByNameAndType(translatorName, Translator.class);
+
+        if (exchange.getIn().getBody() instanceof byte[]) {
+            byte[] bytes = exchange.getIn().getBody(byte[].class);
+            Map<String, Float> result = classify(model, translator, new ByteArrayInputStream(bytes));
+            exchange.getIn().setBody(result);
+        } else if (exchange.getIn().getBody() instanceof File) {
+            Map<String, Float> result = classify(model, translator, exchange.getIn().getBody(File.class));
+            exchange.getIn().setBody(result);
+        } else if (exchange.getIn().getBody() instanceof InputStream) {
+            Map<String, Float> result = classify(model, translator, exchange.getIn().getBody(InputStream.class));
+            exchange.getIn().setBody(result);
+        }
+    }
+
+    private Map<String, Float> classify(Model model, Translator translator, File input) throws Exception {
+        try {
+            return classify(model, translator, ImageIO.read(input));
+        } catch (IOException e) {
+            LOG.error(""Couldn't transform input into a BufferedImage"");
+            throw new Exception(""Couldn't transform input into a BufferedImage"", e);
+        }
+    }
+
+    private Map<String, Float> classify(Model model, Translator translator, InputStream input) throws Exception {
+        try {
+            return classify(model, translator, ImageIO.read(input));
+        } catch (IOException e) {
+            LOG.error(""Couldn't transform input into a BufferedImage"");
+            throw new Exception(""Couldn't transform input into a BufferedImage"", e);","[{'comment': 'same as my previous comment', 'commenter': 'omarsmak'}]"
3703,components/camel-djl/src/main/java/org/apache/camel/component/djl/model/CustomImageClassificationPredictor.java,"@@ -0,0 +1,96 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.camel.component.djl.model;
+
+import java.awt.image.BufferedImage;
+import java.io.ByteArrayInputStream;
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.List;
+import java.util.Map;
+import java.util.stream.Collectors;
+
+import javax.imageio.ImageIO;
+
+import ai.djl.Model;
+import ai.djl.inference.Predictor;
+import ai.djl.modality.Classifications;
+import ai.djl.translate.TranslateException;
+import ai.djl.translate.Translator;
+import org.apache.camel.Exchange;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class CustomImageClassificationPredictor extends AbstractPredictor {
+    private static final Logger LOG = LoggerFactory.getLogger(CustomImageClassificationPredictor.class);
+
+    private String modelName;
+    private String translatorName;
+
+    public CustomImageClassificationPredictor(String modelName, String translatorName) {
+        this.modelName = modelName;
+        this.translatorName = translatorName;
+    }
+
+    @Override
+    public void process(Exchange exchange) throws Exception {
+        Model model = exchange.getContext().getRegistry().lookupByNameAndType(modelName, Model.class);
+        Translator translator = exchange.getContext().getRegistry().lookupByNameAndType(translatorName, Translator.class);
+
+        if (exchange.getIn().getBody() instanceof byte[]) {
+            byte[] bytes = exchange.getIn().getBody(byte[].class);
+            Map<String, Float> result = classify(model, translator, new ByteArrayInputStream(bytes));
+            exchange.getIn().setBody(result);
+        } else if (exchange.getIn().getBody() instanceof File) {
+            Map<String, Float> result = classify(model, translator, exchange.getIn().getBody(File.class));
+            exchange.getIn().setBody(result);
+        } else if (exchange.getIn().getBody() instanceof InputStream) {
+            Map<String, Float> result = classify(model, translator, exchange.getIn().getBody(InputStream.class));
+            exchange.getIn().setBody(result);
+        }
+    }
+
+    private Map<String, Float> classify(Model model, Translator translator, File input) throws Exception {
+        try {
+            return classify(model, translator, ImageIO.read(input));
+        } catch (IOException e) {
+            LOG.error(""Couldn't transform input into a BufferedImage"");
+            throw new Exception(""Couldn't transform input into a BufferedImage"", e);
+        }
+    }
+
+    private Map<String, Float> classify(Model model, Translator translator, InputStream input) throws Exception {
+        try {
+            return classify(model, translator, ImageIO.read(input));
+        } catch (IOException e) {
+            LOG.error(""Couldn't transform input into a BufferedImage"");
+            throw new Exception(""Couldn't transform input into a BufferedImage"", e);
+        }
+    }
+
+    private Map<String, Float> classify(Model model, Translator translator, BufferedImage input) throws Exception {
+        try (Predictor<BufferedImage, Classifications> predictor = model.newPredictor(translator)) {
+            Classifications classifications = predictor.predict(input);
+            List<Classifications.Classification> list = classifications.items();
+            return list.stream().collect(Collectors.toMap(Classifications.Classification::getClassName, x -> (float) x.getProbability()));
+        } catch (TranslateException e) {
+            throw new Exception(""Failed to process output"", e);","[{'comment': 'same here', 'commenter': 'omarsmak'}, {'comment': 'Fixed', 'commenter': 'mgubaidullin'}]"
3703,components/camel-djl/src/main/java/org/apache/camel/component/djl/model/CustomImageClassificationPredictor.java,"@@ -0,0 +1,96 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.camel.component.djl.model;
+
+import java.awt.image.BufferedImage;
+import java.io.ByteArrayInputStream;
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.List;
+import java.util.Map;
+import java.util.stream.Collectors;
+
+import javax.imageio.ImageIO;
+
+import ai.djl.Model;
+import ai.djl.inference.Predictor;
+import ai.djl.modality.Classifications;
+import ai.djl.translate.TranslateException;
+import ai.djl.translate.Translator;
+import org.apache.camel.Exchange;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class CustomImageClassificationPredictor extends AbstractPredictor {
+    private static final Logger LOG = LoggerFactory.getLogger(CustomImageClassificationPredictor.class);
+
+    private String modelName;","[{'comment': ""those two properties should be immutable isn't? If yes, then we better mark them with `final`"", 'commenter': 'omarsmak'}, {'comment': 'Done', 'commenter': 'mgubaidullin'}]"
3703,components/camel-djl/src/main/java/org/apache/camel/component/djl/model/CustomObjectDetectionPredictor.java,"@@ -0,0 +1,93 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.camel.component.djl.model;
+
+import java.awt.image.BufferedImage;
+import java.io.ByteArrayInputStream;
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+
+import javax.imageio.ImageIO;
+
+import ai.djl.Model;
+import ai.djl.inference.Predictor;
+import ai.djl.modality.cv.output.DetectedObjects;
+import ai.djl.translate.TranslateException;
+import ai.djl.translate.Translator;
+import org.apache.camel.Exchange;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class CustomObjectDetectionPredictor extends AbstractPredictor {
+
+    private static final Logger LOG = LoggerFactory.getLogger(CustomObjectDetectionPredictor.class);
+
+    private String modelName;","[{'comment': 'same comment about the mutability. ', 'commenter': 'omarsmak'}, {'comment': 'Done', 'commenter': 'mgubaidullin'}]"
3703,components/camel-djl/src/test/resources/log4j2.properties,"@@ -0,0 +1,23 @@
+## ---------------------------------------------------------------------------
+## Licensed to the Apache Software Foundation (ASF) under one or more
+## contributor license agreements.  See the NOTICE file distributed with
+## this work for additional information regarding copyright ownership.
+## The ASF licenses this file to You under the Apache License, Version 2.0
+## (the ""License""); you may not use this file except in compliance with
+## the License.  You may obtain a copy of the License at
+##
+##      http://www.apache.org/licenses/LICENSE-2.0
+##
+## Unless required by applicable law or agreed to in writing, software
+## distributed under the License is distributed on an ""AS IS"" BASIS,
+## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+## See the License for the specific language governing permissions and
+## limitations under the License.
+## ---------------------------------------------------------------------------
+
+appender.out.type = Console","[{'comment': 'Please write the tests log in camel-parquet-avro-test.log in target', 'commenter': 'oscerd'}, {'comment': 'done', 'commenter': 'onderson'}]"
3703,components/camel-djl/pom.xml,"@@ -0,0 +1,174 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
+         xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+
+    <modelVersion>4.0.0</modelVersion>
+
+    <parent>
+        <artifactId>components</artifactId>
+        <groupId>org.apache.camel</groupId>
+        <version>3.2.0-SNAPSHOT</version>","[{'comment': 'Also since we have released 3.2 (in voting now), this need to change to the new snapshot', 'commenter': 'omarsmak'}]"
3726,components/camel-salesforce/camel-salesforce-component/src/test/java/org/apache/camel/component/salesforce/internal/client/AbstractClientBaseTest.java,"@@ -44,14 +45,12 @@
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.api.Assertions.entry;
 import static org.junit.Assert.assertTrue;
-import static org.mockito.Mockito.doNothing;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.when;
+import static org.mockito.Mockito.*;","[{'comment': ""The wildcard import shouldn't happen, can you please re-import individual packages"", 'commenter': 'omarsmak'}]"
3760,core/camel-componentdsl/src/generated/resources/metadata.json,"@@ -6612,6 +6612,28 @@
     ""producerOnly"": false,
     ""lenientProperties"": false
   },
+  ""SplunkHecComponentBuilderFactory"": {
+    ""kind"": ""component"",
+    ""name"": ""splunk-hec"",
+    ""title"": ""Splunk HEC"",
+    ""description"": ""The splunk component allows to publish events in Splunk using the HTTP Event Collector."",
+    ""deprecated"": false,
+    ""deprecationNote"": ""log,monitoring"",
+    ""firstVersion"": ""3.2.0"",","[{'comment': 'Firstversion is 3.3.0', 'commenter': 'oscerd'}, {'comment': 'Fixed.', 'commenter': 'atoulme'}]"
3760,components/camel-splunk-hec/src/main/java/org/apache/camel/component/splunkhec/SplunkHECProducer.java,"@@ -0,0 +1,122 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.splunkhec;
+
+
+import java.io.ByteArrayOutputStream;
+import java.nio.charset.StandardCharsets;
+import java.util.HashMap;
+import java.util.Map;
+
+import com.fasterxml.jackson.databind.ObjectMapper;
+import org.apache.camel.Exchange;
+import org.apache.camel.Message;
+import org.apache.camel.support.DefaultProducer;
+import org.apache.http.client.methods.CloseableHttpResponse;
+import org.apache.http.client.methods.HttpPost;
+import org.apache.http.conn.ssl.NoopHostnameVerifier;
+import org.apache.http.conn.ssl.SSLConnectionSocketFactory;
+import org.apache.http.entity.ContentType;
+import org.apache.http.entity.EntityTemplate;
+import org.apache.http.impl.client.CloseableHttpClient;
+import org.apache.http.impl.client.HttpClientBuilder;
+import org.apache.http.impl.client.HttpClients;
+import org.apache.http.ssl.SSLContextBuilder;
+
+/**
+ * The Splunk HEC producer.
+ */
+public class SplunkHECProducer extends DefaultProducer {
+    private static final ObjectMapper MAPPER = new ObjectMapper();
+    private SplunkHECEndpoint endpoint;
+    private CloseableHttpClient httpClient;
+
+
+    public SplunkHECProducer(SplunkHECEndpoint endpoint) {
+        super(endpoint);
+        this.endpoint = endpoint;
+    }
+
+    @Override
+    protected void doStart() throws Exception {
+        super.doStart();
+        HttpClientBuilder builder = HttpClients.custom().
+                setUserAgent(""Camel Splunk HEC/"" + getEndpoint().getCamelContext().getVersion()).
+                setMaxConnTotal(10);
+        if (endpoint.getConfiguration().isSkiptlsverify()) {
+            SSLContextBuilder sslbuilder = new SSLContextBuilder();
+            sslbuilder.loadTrustMaterial(null, (chain, authType) -> true);
+            SSLConnectionSocketFactory sslsf = new
+                    SSLConnectionSocketFactory(sslbuilder.build(), NoopHostnameVerifier.INSTANCE);
+            builder.setSSLSocketFactory(sslsf);
+        }
+        httpClient = builder.build();
+    }
+
+    @Override
+    public void process(Exchange exchange) throws Exception {
+        Map<String, Object> payload = createPayload(exchange.getIn());
+
+        HttpPost httppost = new HttpPost((endpoint.getConfiguration().isHttps() ? ""https"" : ""http"") + ""://"" + endpoint.getSplunkURL() + ""/services/collector/event"");
+        httppost.addHeader(""Authorization"", "" Splunk "" + endpoint.getToken());
+
+        EntityTemplate entityTemplate = new EntityTemplate(outputStream -> MAPPER.writer().writeValue(outputStream, payload));
+        entityTemplate.setContentType(ContentType.APPLICATION_JSON.getMimeType());
+
+        httppost.setEntity(entityTemplate);
+        try (CloseableHttpResponse response = httpClient.execute(httppost)) {
+            if (response.getStatusLine().getStatusCode() != 200) {
+                ByteArrayOutputStream output = new ByteArrayOutputStream();
+                response.getEntity().writeTo(output);
+
+                throw new RuntimeException(response.getStatusLine().toString() + ""\n"" + new String(output.toByteArray(), StandardCharsets.UTF_8));
+            }
+        }
+    }
+
+    @Override
+    protected void doStop() throws Exception {
+        super.doStop();
+        httpClient.close();","[{'comment': ""Isn't better to have `httpClient.close` before `super.doStop()`?"", 'commenter': 'omarsmak'}, {'comment': ""I'm seeing file and seda behave differently there. I think `super.doStop()` should be first so it logs the stop operation. If the client throws an exception, at least you get the log before."", 'commenter': 'atoulme'}]"
3760,components/camel-splunk-hec/src/main/java/org/apache/camel/component/splunkhec/SplunkHECConfiguration.java,"@@ -0,0 +1,117 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.splunkhec;
+
+import java.net.UnknownHostException;
+
+import org.apache.camel.spi.UriParam;
+import org.apache.camel.spi.UriParams;
+import org.apache.camel.util.HostUtils;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+@UriParams
+public class SplunkHECConfiguration {
+    private static final transient Logger LOG = LoggerFactory.getLogger(SplunkHECConfiguration.class);
+
+    @UriParam(label = ""producer"")
+    private String index = ""camel"";
+    @UriParam(label = ""producer"")
+    private String sourceType = ""camel"";
+    @UriParam(label = ""producer"")
+    private String source = ""camel"";
+    @UriParam(label = ""host"")
+    private String host;
+    @UriParam(label = ""skiptlsverify"")
+    private boolean skiptlsverify;","[{'comment': ""@atoulme it would be nice to use camel case, however it's a little bit tautology for Camel project :) "", 'commenter': 'dmvolod'}, {'comment': 'Sure thing. Fixed!', 'commenter': 'atoulme'}]"
3760,components/camel-splunk-hec/src/main/java/org/apache/camel/component/splunkhec/SplunkHECConfiguration.java,"@@ -0,0 +1,117 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.splunkhec;
+
+import java.net.UnknownHostException;
+
+import org.apache.camel.spi.UriParam;
+import org.apache.camel.spi.UriParams;
+import org.apache.camel.util.HostUtils;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+@UriParams
+public class SplunkHECConfiguration {
+    private static final transient Logger LOG = LoggerFactory.getLogger(SplunkHECConfiguration.class);
+
+    @UriParam(label = ""producer"")
+    private String index = ""camel"";
+    @UriParam(label = ""producer"")
+    private String sourceType = ""camel"";
+    @UriParam(label = ""producer"")
+    private String source = ""camel"";
+    @UriParam(label = ""producer"")
+    private String host;
+    @UriParam(label = ""producer"")
+    private boolean skipTlsVerify;
+    @UriParam(label = ""producer"")","[{'comment': 'You need to specify default value in @UriParam when it has a value, also for the ones that has camel above.', 'commenter': 'davsclaus'}]"
3760,components/camel-splunk-hec/src/main/java/org/apache/camel/component/splunkhec/SplunkHECEndpoint.java,"@@ -0,0 +1,103 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.splunkhec;
+
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+import org.apache.camel.Consumer;
+import org.apache.camel.Processor;
+import org.apache.camel.Producer;
+import org.apache.camel.spi.UriEndpoint;
+import org.apache.camel.spi.UriParam;
+import org.apache.camel.spi.UriPath;
+import org.apache.camel.support.DefaultEndpoint;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * The splunk component allows to publish events in Splunk using the HTTP Event Collector.
+ */
+@UriEndpoint(firstVersion = ""3.3.0"", scheme = ""splunk-hec"", title = ""Splunk HEC"", syntax = ""splunk-hec:endpoint/token"", label = ""log,monitoring"")
+public class SplunkHECEndpoint extends DefaultEndpoint {
+
+    private static final Logger LOG = LoggerFactory.getLogger(SplunkHECEndpoint.class);
+    private static final Pattern URI_PARSER = Pattern.compile(""splunk-hec\\:\\/?\\/?(\\w+):(\\d+)/(\\w{8}-\\w{4}-\\w{4}-\\w{4}-\\w{12})\\??.*"");
+
+    @UriPath","[{'comment': '@UriPath must match the syntax `splunk-hec:endpoint/token`, eg having 2 UriPath named `endpoint` and `token`. Otherwise change the syntax to `splunk-hec:endpointUri` to match the current @UriPath name.', 'commenter': 'davsclaus'}]"
3777,components/camel-resteasy/src/test/java/org/apache/camel/component/resteasy/test/ResteasyConsumerTest.java,"@@ -0,0 +1,222 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.resteasy.test;
+
+import java.io.File;
+import java.net.URI;
+import java.nio.file.Files;
+
+import javax.ws.rs.client.Client;
+import javax.ws.rs.client.ClientBuilder;
+import javax.ws.rs.client.Entity;
+import javax.ws.rs.client.WebTarget;
+import javax.ws.rs.core.MediaType;
+import javax.ws.rs.core.Response;
+
+import org.apache.camel.component.resteasy.test.beans.Customer;
+import org.apache.camel.component.resteasy.test.beans.CustomerList;
+import org.apache.camel.component.resteasy.test.beans.CustomerService;
+import org.jboss.arquillian.container.test.api.Deployment;
+import org.jboss.arquillian.container.test.api.RunAsClient;
+import org.jboss.arquillian.junit.Arquillian;
+import org.jboss.arquillian.junit.InSequence;
+import org.jboss.arquillian.test.api.ArquillianResource;
+import org.jboss.shrinkwrap.api.Archive;
+import org.jboss.shrinkwrap.api.ShrinkWrap;
+import org.jboss.shrinkwrap.api.spec.WebArchive;
+import org.jboss.shrinkwrap.resolver.api.maven.Maven;
+import org.junit.Assert;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+@RunWith(Arquillian.class)
+@RunAsClient
+public class ResteasyConsumerTest {
+
+    @ArquillianResource
+    URI baseUri;
+
+    @Deployment
+    public static Archive<?> createTestArchive() {
+        
+        return ShrinkWrap.create(WebArchive.class, ""test.war"")
+                .addClasses(Customer.class, CustomerService.class, CustomerList.class)
+                .addPackage(""org.apache.camel.component.resteasy"")
+                .addPackage(""org.apache.camel.component.resteasy.servlet"")
+                .addAsLibraries(Maven.resolver().loadPomFromFile(""pom.xml"")
+                        .importRuntimeAndTestDependencies().resolve().withTransitivity().asFile())
+                .addAsWebInfResource(new File(""src/test/resources/contexts/basicConsumer.xml""), ""applicationContext.xml"")
+                .addAsWebInfResource(""web.xml"");
+
+    }
+
+    private Response createCustomer(Customer customer) {
+        Client client = ClientBuilder.newBuilder().build();
+        WebTarget target = client.target(baseUri.toString() + ""customer/createCustomer"");
+        Response response = target.request(MediaType.APPLICATION_JSON)
+                .post(Entity.entity(customer, MediaType.APPLICATION_JSON_TYPE));
+
+        Assert.assertEquals(200, response.getStatus());
+        return response;
+    }
+
+    private Response deleteCustomer(int id) {
+        Client client = ClientBuilder.newBuilder().build();
+        WebTarget target = client.target(baseUri.toString() + ""customer/deleteCustomer?id="" + id);
+        Response response = target.request().delete();
+
+        Assert.assertEquals(200, response.getStatus());
+
+        return response;
+    }
+
+    private Customer getCustomer(int id) {
+        Client client = ClientBuilder.newBuilder().build();
+        WebTarget target = client.target(baseUri.toString() + ""customer/getCustomer?id="" + id);
+        Response response = target.request().get();
+
+        Assert.assertEquals(200, response.getStatus());
+
+        return response.readEntity(Customer.class);
+    }
+
+    @Test
+    @InSequence(1)
+    public void testGetAll() throws Exception {
+        String expectedUser1 = ""{\""name\"":\""Roman\"",\""surname\"":\""Jakubco\"",\""id\"":1}"";
+        String expectedUser2 = ""{\""name\"":\""Camel\"",\""surname\"":\""Rider\"",\""id\"":2}"";
+
+        Client client = ClientBuilder.newBuilder().build();
+        WebTarget target = client.target(baseUri.toString() + ""customer/getAll"");
+        Response response = target.request().get();
+
+        Assert.assertEquals(200, response.getStatus());
+
+        String users = response.readEntity(String.class);
+        Assert.assertTrue(users.contains(expectedUser1));
+        Assert.assertTrue(users.contains(expectedUser2));
+
+        File file = new File(""target/test/consumerTest/all.txt"");
+        byte[] encoded = Files.readAllBytes(file.toPath());
+        String responseBody = new String(encoded);
+
+        Assert.assertTrue(responseBody.contains(expectedUser1));
+        Assert.assertTrue(responseBody.contains(expectedUser2));
+    }
+
+    @Test
+    public void testGet() throws Exception {
+        Customer customer = getCustomer(2);
+
+        Assert.assertEquals(new Customer(""Camel"", ""Rider"", 2), customer);
+
+        File file = new File(""target/test/consumerTest/get.txt"");
+        byte[] encoded = Files.readAllBytes(file.toPath());
+        String responseBody = new String(encoded);
+
+        Assert.assertEquals(""{\""name\"":\""Camel\"",\""surname\"":\""Rider\"",\""id\"":2}"", responseBody);
+    }
+
+    @Test
+    public void testPost() throws Exception {
+
+        String expectedResponse = ""Customer added : Customer{name='TestCreate', surname='TestCreate', id=3}"";
+        int customerId = 3;
+
+        Customer customer = new Customer(""TestCreate"", ""TestCreate"", customerId);
+        Response response = createCustomer(customer);
+        System.out.println(response.readEntity(String.class));","[{'comment': 'Looks like this is from test period debug :)', 'commenter': 'dmvolod'}, {'comment': 'nice catch :)', 'commenter': 'onderson'}]"
3777,components/camel-resteasy/pom.xml,"@@ -0,0 +1,313 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one or more
+    contributor license agreements.  See the NOTICE file distributed with
+    this work for additional information regarding copyright ownership.
+    The ASF licenses this file to You under the Apache License, Version 2.0
+    (the ""License""); you may not use this file except in compliance with
+    the License.  You may obtain a copy of the License at
+
+         http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an ""AS IS"" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+
+-->
+<project xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
+    xmlns=""http://maven.apache.org/POM/4.0.0""
+    xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+
+    <modelVersion>4.0.0</modelVersion>
+
+    <parent>
+        <groupId>org.apache.camel</groupId>
+        <artifactId>components</artifactId>
+        <version>3.3.0-SNAPSHOT</version>
+    </parent>
+
+    <artifactId>camel-resteasy</artifactId>
+    <packaging>jar</packaging>
+    <name>Camel :: Resteasy</name>
+    <description>Camel Resteasy support</description>
+
+    <!--
+    <properties>","[{'comment': 'There are some commented out dependencies and properties, would it make sense to clean them out?', 'commenter': 'omarsmak'}, {'comment': '+1', 'commenter': 'oscerd'}]"
3777,docs/components/modules/ROOT/pages/resteasy-component.adoc,"@@ -0,0 +1,152 @@
+[[resteasy-component]]
+= Resteasy Component
+//THIS FILE IS COPIED: EDIT THE SOURCE FILE:
+:page-source: components/camel-resteasy/src/main/docs/resteasy-component.adoc
+:docTitle: Resteasy
+:artifactId: camel-resteasy
+:description: Defines the Resteasy Endpoint.
+:since: 3.3
+:supportLevel: Stable
+:component-header: Only consumer is supported
+
+*Since Camel {since}*
+
+*{component-header}*
+","[{'comment': 'Somewhat the documentation description looks missing though  ', 'commenter': 'omarsmak'}, {'comment': 'This should be ok, it has been introduced from a @djencks PR', 'commenter': 'oscerd'}]"
3777,docs/components/modules/ROOT/pages/resteasy-component.adoc,"@@ -0,0 +1,152 @@
+[[resteasy-component]]
+= Resteasy Component
+//THIS FILE IS COPIED: EDIT THE SOURCE FILE:
+:page-source: components/camel-resteasy/src/main/docs/resteasy-component.adoc
+:docTitle: Resteasy
+:artifactId: camel-resteasy
+:description: Defines the Resteasy Endpoint.
+:since: 3.3
+:supportLevel: Stable
+:component-header: Only consumer is supported
+
+*Since Camel {since}*
+
+*{component-header}*
+
+=== Options
+
+// component options: START
+The Resteasy component supports 22 options, which are listed below.
+
+
+
+[width=""100%"",cols=""2,5,^1,2"",options=""header""]
+|===
+| Name | Description | Default | Type
+| *bridgeErrorHandler* (consumer) | Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored. | false | boolean
+| *httpRegistry* (consumer) | Sets httpRegistry which can be externalized to be used by camel |  | HttpRegistry
+| *proxyConsumersClasses* (consumer) | Sets the proxy class for consumer enpoints |  | String
+| *allowJavaSerializedObject* (advanced) | Whether to allow java serialization when a request uses context-type=application/x-java-serialized-object. This is by default turned off. If you enable this then be aware that Java will deserialize the incoming data from the request to Java and that can be a potential security risk. | false | boolean
+| *basicPropertyBinding* (advanced) | Whether the component should use basic property binding (Camel 2.x) or the newer property binding with additional capabilities | false | boolean
+| *clientConnectionManager* (advanced) | To use a custom and shared HttpClientConnectionManager to manage connections. If this has been configured then this is always used for all endpoints created by this component. |  | HttpClientConnectionManager
+| *connectionsPerRoute* (advanced) | The maximum number of connections per route. | 20 | int
+| *connectionTimeToLive* (advanced) | The time for connection to live, the time unit is millisecond, the default value is always keep alive. |  | long
+| *httpBinding* (advanced) | To use a custom HttpBinding to control the mapping between Camel message and HttpClient. |  | HttpBinding
+| *httpClientConfigurer* (advanced) | To use the custom HttpClientConfigurer to perform configuration of the HttpClient that will be used. |  | HttpClientConfigurer
+| *httpConfiguration* (advanced) | To use the shared HttpConfiguration as base configuration. |  | HttpConfiguration
+| *httpContext* (advanced) | To use a custom org.apache.http.protocol.HttpContext when executing requests. |  | HttpContext
+| *maxTotalConnections* (advanced) | The maximum number of connections. | 200 | int
+| *headerFilterStrategy* (filter) | To use a custom org.apache.camel.spi.HeaderFilterStrategy to filter header to and from Camel message. |  | HeaderFilterStrategy
+| *sslContextParameters* (security) | To configure security using SSLContextParameters. Important: Only one instance of org.apache.camel.support.jsse.SSLContextParameters is supported per HttpComponent. If you need to use 2 or more different instances, you need to define a new HttpComponent per instance you need. |  | SSLContextParameters
+| *useGlobalSslContextParameters* (security) | Enable usage of global SSL context parameters. | false | boolean
+| *x509HostnameVerifier* (security) | To use a custom X509HostnameVerifier such as DefaultHostnameVerifier or NoopHostnameVerifier. |  | HostnameVerifier
+| *connectionRequestTimeout* (timeout) | The timeout in milliseconds used when requesting a connection from the connection manager. A timeout value of zero is interpreted as an infinite timeout. A timeout value of zero is interpreted as an infinite timeout. A negative value is interpreted as undefined (system default). | -1 | int
+| *connectTimeout* (timeout) | Determines the timeout in milliseconds until a connection is established. A timeout value of zero is interpreted as an infinite timeout. A timeout value of zero is interpreted as an infinite timeout. A negative value is interpreted as undefined (system default). | -1 | int
+| *socketTimeout* (timeout) | Defines the socket timeout in milliseconds, which is the timeout for waiting for data or, put differently, a maximum period inactivity between two consecutive data packets). A timeout value of zero is interpreted as an infinite timeout. A negative value is interpreted as undefined (system default). | -1 | int
+| *cookieStore* (producer) | To use a custom org.apache.http.client.CookieStore. By default the org.apache.http.impl.client.BasicCookieStore is used which is an in-memory only cookie store. Notice if bridgeEndpoint=true then the cookie store is forced to be a noop cookie store as cookie shouldn't be stored as we are just bridging (eg acting as a proxy). |  | CookieStore
+| *lazyStartProducer* (producer) | Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing. | false | boolean
+|===
+// component options: END
+
+
+// endpoint options: START
+The Resteasy endpoint is configured using URI syntax:
+
+----
+resteasy:contextPath
+----
+
+with the following path and query parameters:
+
+=== Path Parameters (1 parameters):
+
+
+[width=""100%"",cols=""2,5,^1,2"",options=""header""]
+|===
+| Name | Description | Default | Type
+| *httpUri* | *Required* The url of the HTTP endpoint to call. |  | URI
+|===
+
+
+=== Query Parameters (72 parameters):
+
+
+[width=""100%"",cols=""2,5,^1,2"",options=""header""]
+|===
+| Name | Description | Default | Type
+| *httpBinding* (common) | To use a custom HttpBinding to control the mapping between Camel message and HttpClient. |  | HttpBinding
+| *chunked* (consumer) | If this option is false the Servlet will disable the HTTP streaming and set the content-length header on the response | true | boolean
+| *disableStreamCache* (common) | Determines whether or not the raw input stream from Servlet is cached or not (Camel will read the stream into a in memory/overflow to file, Stream caching) cache. By default Camel will cache the Servlet input stream to support reading it multiple times to ensure it Camel can retrieve all data from the stream. However you can set this option to true when you for example need to access the raw stream, such as streaming it directly to a file or other persistent store. DefaultHttpBinding will copy the request input stream into a stream cache and put it into message body if this option is false to support reading the stream multiple times. If you use Servlet to bridge/proxy an endpoint then consider enabling this option to improve performance, in case you do not need to read the message payload multiple times. The http producer will by default cache the response body stream. If setting this option to true, then the producers will not cache the response body stream but use the response stream as-is as the message body. | false | boolean
+| *async* (consumer) | Configure the consumer to work in async mode | false | boolean
+| *bridgeErrorHandler* (consumer) | Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored. | false | boolean
+| *camelProxy* (consumer) | Sets the flag to use camel for proxying without resteasy interfaces |  | Boolean
+| *headerFilterStrategy* (consumer) | To use a custom HeaderFilterStrategy to filter header to and from Camel message. |  | HeaderFilterStrategy
+| *httpMethodRestrict* (consumer) | Used to only allow consuming if the HttpMethod matches, such as GET/POST/PUT etc. Multiple methods can be specified separated by comma. |  | String
+| *matchOnUriPrefix* (consumer) | Whether or not the consumer should try to find a target consumer by matching the URI prefix if no exact match is found. | false | boolean
+| *muteException* (consumer) | If enabled and an Exchange failed processing on the consumer side the response's body won't contain the exception's stack trace. | false | boolean
+| *password* (consumer) | Sets the password |  | String
+| *proxy* (consumer) | Sets the flag to use the endpoint as proxy |  | Boolean
+| *proxyClientClass* (consumer) | Sets the resteasy proxyClientClass |  | String
+| *proxyMethod* (consumer) | Sets the proxy method defined in an interface |  | String
+| *responseBufferSize* (consumer) | To use a custom buffer size on the javax.servlet.ServletResponse. |  | Integer
+| *restEasyHttpBindingRef* (consumer) | Sets the restEasyHttpBinding if you have a customised one registered in the context |  | ResteasyHttpBinding
+| *resteasyMethod* (consumer) | Sets the resteasy method to process the request |  | String
+| *servletName* (consumer) | Sets the servlet name |  | String
+| *throwExceptionOnFailure* (consumer) | ets the flag to propogate the exception | false | boolean
+| *transferException* (consumer) | If enabled and an Exchange failed processing on the consumer side, and if the caused Exception was send back serialized in the response as a application/x-java-serialized-object content type. On the producer side the exception will be deserialized and thrown as is, instead of the HttpOperationFailedException. The caused exception is required to be serialized. This is by default turned off. If you enable this then be aware that Java will deserialize the incoming data from the request to Java and that can be a potential security risk. | false | boolean
+| *username* (consumer) | Sets the username |  | String
+| *eagerCheckContentAvailable* (consumer) | Whether to eager check whether the HTTP requests has content if the content-length header is 0 or not present. This can be turned on in case HTTP clients do not send streamed data. | false | boolean
+| *exceptionHandler* (consumer) | To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored. |  | ExceptionHandler
+| *exchangePattern* (consumer) | Sets the exchange pattern when the consumer creates an exchange. The value can be one of: InOnly, InOut, InOptionalOut |  | ExchangePattern
+| *optionsEnabled* (consumer) | Specifies whether to enable HTTP OPTIONS for this Servlet consumer. By default OPTIONS is turned off. | false | boolean
+| *traceEnabled* (consumer) | Specifies whether to enable HTTP TRACE for this Servlet consumer. By default TRACE is turned off. | false | boolean
+| *basicPropertyBinding* (advanced) | Whether the endpoint should use basic property binding (Camel 2.x) or the newer property binding with additional capabilities | false | boolean
+| *clientBuilder* (advanced) | Provide access to the http client request parameters used on new RequestConfig instances used by producers or consumers of this endpoint. |  | HttpClientBuilder
+| *clientConnectionManager* (advanced) | To use a custom HttpClientConnectionManager to manage connections |  | HttpClientConnectionManager
+| *connectionsPerRoute* (advanced) | The maximum number of connections per route. | 20 | int
+| *httpClient* (advanced) | Sets a custom HttpClient to be used by the producer |  | HttpClient
+| *httpClientConfigurer* (advanced) | Register a custom configuration strategy for new HttpClient instances created by producers or consumers such as to configure authentication mechanisms etc. |  | HttpClientConfigurer
+| *httpClientOptions* (advanced) | To configure the HttpClient using the key/values from the Map. |  | Map
+| *httpContext* (advanced) | To use a custom HttpContext instance |  | HttpContext
+| *mapHttpMessageBody* (advanced) | If this option is true then IN exchange Body of the exchange will be mapped to HTTP body. Setting this to false will avoid the HTTP mapping. | true | boolean
+| *mapHttpMessageFormUrlEncoded Body* (advanced) | If this option is true then IN exchange Form Encoded body of the exchange will be mapped to HTTP. Setting this to false will avoid the HTTP Form Encoded body mapping. | true | boolean
+| *mapHttpMessageHeaders* (advanced) | If this option is true then IN exchange Headers of the exchange will be mapped to HTTP headers. Setting this to false will avoid the HTTP Headers mapping. | true | boolean
+| *maxTotalConnections* (advanced) | The maximum number of connections. | 200 | int
+| *synchronous* (advanced) | Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported). | false | boolean
+| *useSystemProperties* (advanced) | To use System Properties as fallback for configuration | false | boolean
+| *sslContextParameters* (security) | To configure security using SSLContextParameters. Important: Only one instance of org.apache.camel.util.jsse.SSLContextParameters is supported per HttpComponent. If you need to use 2 or more different instances, you need to define a new HttpComponent per instance you need. |  | SSLContextParameters
+| *x509HostnameVerifier* (security) | To use a custom X509HostnameVerifier such as DefaultHostnameVerifier or NoopHostnameVerifier |  | HostnameVerifier
+| *bridgeEndpoint* (producer) | If the option is true, HttpProducer will ignore the Exchange.HTTP_URI header, and use the endpoint's URI for request. You may also set the option throwExceptionOnFailure to be false to let the HttpProducer send all the fault response back. | false | boolean
+| *clearExpiredCookies* (producer) | Whether to clear expired cookies before sending the HTTP request. This ensures the cookies store does not keep growing by adding new cookies which is newer removed when they are expired. | true | boolean
+| *connectionClose* (producer) | Specifies whether a Connection Close header must be added to HTTP Request. By default connectionClose is false. | false | boolean
+| *copyHeaders* (producer) | If this option is true then IN exchange headers will be copied to OUT exchange headers according to copy strategy. Setting this to false, allows to only include the headers from the HTTP response (not propagating IN headers). | true | boolean
+| *customHostHeader* (producer) | To use custom host header for producer. When not set in query will be ignored. When set will override host header derived from url. |  | String
+| *httpMethod* (producer) | Configure the HTTP method to use. The HttpMethod header cannot override this option if set. The value can be one of: GET, POST, PUT, DELETE, HEAD, OPTIONS, TRACE, PATCH |  | HttpMethods
+| *ignoreResponseBody* (producer) | If this option is true, The http producer won't read response body and cache the input stream | false | boolean
+| *lazyStartProducer* (producer) | Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing. | false | boolean
+| *preserveHostHeader* (producer) | If the option is true, HttpProducer will set the Host header to the value contained in the current exchange Host header, useful in reverse proxy applications where you want the Host header received by the downstream server to reflect the URL called by the upstream client, this allows applications which use the Host header to generate accurate URL's for a proxied service | false | boolean
+| *cookieHandler* (producer) | Configure a cookie handler to maintain a HTTP session |  | CookieHandler
+| *cookieStore* (producer) | To use a custom CookieStore. By default the BasicCookieStore is used which is an in-memory only cookie store. Notice if bridgeEndpoint=true then the cookie store is forced to be a noop cookie store as cookie shouldn't be stored as we are just bridging (eg acting as a proxy). If a cookieHandler is set then the cookie store is also forced to be a noop cookie store as cookie handling is then performed by the cookieHandler. |  | CookieStore
+| *deleteWithBody* (producer) | Whether the HTTP DELETE should include the message body or not. By default HTTP DELETE do not include any HTTP body. However in some rare cases users may need to be able to include the message body. | false | boolean
+| *getWithBody* (producer) | Whether the HTTP GET should include the message body or not. By default HTTP GET do not include any HTTP body. However in some rare cases users may need to be able to include the message body. | false | boolean
+| *okStatusCodeRange* (producer) | The status codes which are considered a success response. The values are inclusive. Multiple ranges can be defined, separated by comma, e.g. 200-204,209,301-304. Each range must be a single number or from-to with the dash included. | 200-299 | String
+| *proxyAuthDomain* (proxy) | Proxy authentication domain to use with NTML |  | String
+| *proxyAuthHost* (proxy) | Proxy authentication host |  | String
+| *proxyAuthMethod* (proxy) | Proxy authentication method to use. The value can be one of: Basic, Digest, NTLM |  | String
+| *proxyAuthPassword* (proxy) | Proxy authentication password |  | String
+| *proxyAuthPort* (proxy) | Proxy authentication port |  | int
+| *proxyAuthScheme* (proxy) | Proxy authentication scheme to use. The value can be one of: http, https |  | String
+| *proxyAuthUsername* (proxy) | Proxy authentication username |  | String
+| *proxyHost* (proxy) | Proxy hostname to use |  | String
+| *proxyPort* (proxy) | Proxy port to use |  | int
+| *authDomain* (security) | Authentication domain to use with NTML |  | String
+| *authenticationPreemptive* (security) | If this option is true, camel-http sends preemptive basic authentication to the server. | false | boolean
+| *authHost* (security) | Authentication host to use with NTML |  | String
+| *authMethod* (security) | Authentication methods allowed to use as a comma separated list of values Basic, Digest or NTLM. |  | String
+| *authMethodPriority* (security) | Which authentication method to prioritize to use, either as Basic, Digest or NTLM. The value can be one of: Basic, Digest, NTLM |  | String
+| *authPassword* (security) | Authentication password |  | String
+| *authUsername* (security) | Authentication username |  | String
+|===
+// endpoint options: END
+
+=== Samples","[{'comment': 'Samples as well', 'commenter': 'omarsmak'}]"
3777,components/camel-resteasy/pom.xml,"@@ -0,0 +1,313 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one or more
+    contributor license agreements.  See the NOTICE file distributed with
+    this work for additional information regarding copyright ownership.
+    The ASF licenses this file to You under the Apache License, Version 2.0
+    (the ""License""); you may not use this file except in compliance with
+    the License.  You may obtain a copy of the License at
+
+         http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an ""AS IS"" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+
+-->
+<project xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
+    xmlns=""http://maven.apache.org/POM/4.0.0""
+    xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+
+    <modelVersion>4.0.0</modelVersion>
+
+    <parent>
+        <groupId>org.apache.camel</groupId>
+        <artifactId>components</artifactId>
+        <version>3.3.0-SNAPSHOT</version>
+    </parent>
+
+    <artifactId>camel-resteasy</artifactId>
+    <packaging>jar</packaging>
+    <name>Camel :: Resteasy</name>
+    <description>Camel Resteasy support</description>
+
+    <!--
+    <properties>
+        <resteasy-version>4.4.1.Final</resteasy-version>    
+        <version.org.eclipse.jetty>9.4.17.v20190418</version.org.eclipse.jetty>
+        <arquillian-version>1.4.1.Final</arquillian-version>
+        <shrinkwrap-resolver-version>2.2.6</shrinkwrap-resolver-version>
+        <shrinkwrap-version>1.2.6</shrinkwrap-version>    
+    </properties>
+    -->
+
+    <dependencyManagement>
+        <dependencies>
+            <dependency>
+                <groupId>org.jboss.arquillian</groupId>
+                <artifactId>arquillian-bom</artifactId>
+                <version>${arquillian-version}</version>
+                <scope>import</scope>
+                <type>pom</type>
+            </dependency>
+            <dependency>
+                <groupId>org.jboss.resteasy</groupId>
+                <artifactId>resteasy-bom</artifactId>
+                <version>${resteasy-version}</version>
+                <type>pom</type>
+                <scope>import</scope>
+            </dependency>
+            <dependency>
+                <groupId>org.jboss.resteasy</groupId>
+                <artifactId>resteasy-core</artifactId>
+                <version>${resteasy-version}</version>
+            </dependency>
+            <dependency>
+                <groupId>javax.servlet</groupId>
+                <artifactId>javax.servlet-api</artifactId>
+                <version>${javax-servlet-api-version}</version>
+            </dependency>
+        </dependencies>
+    </dependencyManagement>
+
+    <dependencies>
+        <!-- resteasy dependencies -->
+        <dependency>
+            <groupId>org.jboss.resteasy</groupId>
+            <artifactId>resteasy-core-spi</artifactId>
+        </dependency>
+        <dependency>
+            <groupId>org.jboss.resteasy</groupId>
+            <artifactId>resteasy-spring</artifactId>
+        </dependency>
+        <dependency>
+            <groupId>org.jboss.resteasy</groupId>
+            <artifactId>resteasy-servlet-initializer</artifactId>
+        </dependency>
+        <dependency>
+            <groupId>org.jboss.resteasy</groupId>
+            <artifactId>resteasy-client</artifactId>
+        </dependency>
+        <dependency>
+            <groupId>org.jboss.resteasy</groupId>
+            <artifactId>resteasy-validator-provider</artifactId>
+        </dependency>
+        
+        <!-- smx dependencies -->
+        <!--dependency>
+            <groupId>org.apache.servicemix.bundles</groupId>
+            <artifactId>org.apache.servicemix.bundles.reflections</artifactId>
+            <version>${reflections-bundle-version}</version>
+        </dependency-->
+
+        <!-- camel dependencies -->
+        <dependency>
+            <groupId>org.apache.camel</groupId>
+            <artifactId>camel-support</artifactId>
+        </dependency>
+        <dependency>
+            <groupId>org.apache.camel</groupId>
+            <artifactId>camel-http-common</artifactId>
+        </dependency>
+        <dependency>
+            <groupId>org.apache.camel</groupId>
+            <artifactId>camel-http</artifactId>
+        </dependency>
+
+        <!-- common dependencies -->
+        <dependency>
+            <groupId>org.apache.commons</groupId>
+            <artifactId>commons-lang3</artifactId>
+        </dependency>
+
+        <dependency>
+            <groupId>commons-io</groupId>
+            <artifactId>commons-io</artifactId>
+        </dependency>
+
+        <!-- jboss jaxb/jaxrs dependencies needed by resteasy -->
+        <dependency>
+            <groupId>org.jboss.spec.javax.ws.rs</groupId>
+            <artifactId>jboss-jaxrs-api_2.1_spec</artifactId>
+            <version>${jboss-jaxrs-api_2.1_spec-version}</version>
+        </dependency>
+        <dependency>
+            <groupId>org.jboss.spec.javax.xml.bind</groupId>
+            <artifactId>jboss-jaxb-api_2.3_spec</artifactId>
+            <version>${jboss-jaxb-api_2.3_spec-version}</version>
+        </dependency>
+        <dependency>
+            <groupId>org.glassfish</groupId>
+            <artifactId>jakarta.el</artifactId>
+            <version>${jakarta.el-version}</version>
+        </dependency>
+        <dependency>","[{'comment': 'Can we avoid JAXB? Or at least get rid of this old clunky glassfish thingy. There are some newer JAXB JARs, see in core/camel-xml-jaxb.', 'commenter': 'davsclaus'}]"
3777,components/camel-resteasy/pom.xml,"@@ -0,0 +1,313 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one or more
+    contributor license agreements.  See the NOTICE file distributed with
+    this work for additional information regarding copyright ownership.
+    The ASF licenses this file to You under the Apache License, Version 2.0
+    (the ""License""); you may not use this file except in compliance with
+    the License.  You may obtain a copy of the License at
+
+         http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an ""AS IS"" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+
+-->
+<project xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
+    xmlns=""http://maven.apache.org/POM/4.0.0""
+    xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+
+    <modelVersion>4.0.0</modelVersion>
+
+    <parent>
+        <groupId>org.apache.camel</groupId>
+        <artifactId>components</artifactId>
+        <version>3.3.0-SNAPSHOT</version>
+    </parent>
+
+    <artifactId>camel-resteasy</artifactId>
+    <packaging>jar</packaging>
+    <name>Camel :: Resteasy</name>
+    <description>Camel Resteasy support</description>
+
+    <!--
+    <properties>
+        <resteasy-version>4.4.1.Final</resteasy-version>    
+        <version.org.eclipse.jetty>9.4.17.v20190418</version.org.eclipse.jetty>
+        <arquillian-version>1.4.1.Final</arquillian-version>
+        <shrinkwrap-resolver-version>2.2.6</shrinkwrap-resolver-version>
+        <shrinkwrap-version>1.2.6</shrinkwrap-version>    
+    </properties>
+    -->
+
+    <dependencyManagement>
+        <dependencies>
+            <dependency>
+                <groupId>org.jboss.arquillian</groupId>
+                <artifactId>arquillian-bom</artifactId>
+                <version>${arquillian-version}</version>
+                <scope>import</scope>
+                <type>pom</type>
+            </dependency>
+            <dependency>
+                <groupId>org.jboss.resteasy</groupId>
+                <artifactId>resteasy-bom</artifactId>
+                <version>${resteasy-version}</version>
+                <type>pom</type>
+                <scope>import</scope>
+            </dependency>
+            <dependency>
+                <groupId>org.jboss.resteasy</groupId>
+                <artifactId>resteasy-core</artifactId>
+                <version>${resteasy-version}</version>
+            </dependency>
+            <dependency>
+                <groupId>javax.servlet</groupId>
+                <artifactId>javax.servlet-api</artifactId>
+                <version>${javax-servlet-api-version}</version>
+            </dependency>
+        </dependencies>
+    </dependencyManagement>
+
+    <dependencies>
+        <!-- resteasy dependencies -->
+        <dependency>
+            <groupId>org.jboss.resteasy</groupId>
+            <artifactId>resteasy-core-spi</artifactId>
+        </dependency>
+        <dependency>
+            <groupId>org.jboss.resteasy</groupId>
+            <artifactId>resteasy-spring</artifactId>
+        </dependency>
+        <dependency>
+            <groupId>org.jboss.resteasy</groupId>
+            <artifactId>resteasy-servlet-initializer</artifactId>
+        </dependency>
+        <dependency>
+            <groupId>org.jboss.resteasy</groupId>
+            <artifactId>resteasy-client</artifactId>
+        </dependency>
+        <dependency>
+            <groupId>org.jboss.resteasy</groupId>
+            <artifactId>resteasy-validator-provider</artifactId>
+        </dependency>
+        
+        <!-- smx dependencies -->
+        <!--dependency>
+            <groupId>org.apache.servicemix.bundles</groupId>
+            <artifactId>org.apache.servicemix.bundles.reflections</artifactId>
+            <version>${reflections-bundle-version}</version>
+        </dependency-->
+
+        <!-- camel dependencies -->
+        <dependency>
+            <groupId>org.apache.camel</groupId>
+            <artifactId>camel-support</artifactId>
+        </dependency>
+        <dependency>
+            <groupId>org.apache.camel</groupId>
+            <artifactId>camel-http-common</artifactId>
+        </dependency>
+        <dependency>
+            <groupId>org.apache.camel</groupId>
+            <artifactId>camel-http</artifactId>
+        </dependency>
+
+        <!-- common dependencies -->
+        <dependency>
+            <groupId>org.apache.commons</groupId>
+            <artifactId>commons-lang3</artifactId>
+        </dependency>
+
+        <dependency>
+            <groupId>commons-io</groupId>
+            <artifactId>commons-io</artifactId>
+        </dependency>
+
+        <!-- jboss jaxb/jaxrs dependencies needed by resteasy -->
+        <dependency>
+            <groupId>org.jboss.spec.javax.ws.rs</groupId>
+            <artifactId>jboss-jaxrs-api_2.1_spec</artifactId>
+            <version>${jboss-jaxrs-api_2.1_spec-version}</version>
+        </dependency>
+        <dependency>
+            <groupId>org.jboss.spec.javax.xml.bind</groupId>
+            <artifactId>jboss-jaxb-api_2.3_spec</artifactId>
+            <version>${jboss-jaxb-api_2.3_spec-version}</version>
+        </dependency>
+        <dependency>
+            <groupId>org.glassfish</groupId>","[{'comment': 'Can we avoid this old EL that nobody ever uses - some old clunk from J2EE days', 'commenter': 'davsclaus'}]"
3777,components/camel-resteasy/src/main/java/org/apache/camel/component/resteasy/DefaultResteasyHttpBinding.java,"@@ -0,0 +1,219 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.resteasy;
+
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.Map;
+
+import javax.ws.rs.client.Client;
+import javax.ws.rs.client.ClientBuilder;
+import javax.ws.rs.client.Entity;
+import javax.ws.rs.client.Invocation;
+import javax.ws.rs.client.WebTarget;
+import javax.ws.rs.core.Response;
+
+import org.apache.camel.Exchange;
+import org.apache.camel.spi.HeaderFilterStrategy;
+import org.apache.camel.support.MessageHelper;
+import org.apache.camel.util.ObjectHelper;
+import org.apache.commons.lang3.exception.ExceptionUtils;
+import org.jboss.resteasy.client.jaxrs.ResteasyWebTarget;
+import org.jboss.resteasy.client.jaxrs.internal.BasicAuthentication;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * The default Resteasy binding implementation
+ */
+public class DefaultResteasyHttpBinding implements ResteasyHttpBinding {
+
+    private static final Logger LOG = LoggerFactory.getLogger(DefaultResteasyHttpBinding.class);
+
+    private HeaderFilterStrategy headerFilterStrategy;
+
+    public HeaderFilterStrategy getHeaderFilterStrategy() {
+        return headerFilterStrategy;
+    }
+
+    @Override
+    public void setHeaderFilterStrategy(HeaderFilterStrategy headerFilterStrategy) {
+        this.headerFilterStrategy = headerFilterStrategy;
+    }
+
+    @Override
+    public Response populateResteasyRequestFromExchangeAndExecute(String uri, Exchange exchange, Map<String, String> parameters) {
+        Client client = ClientBuilder.newBuilder().build();
+        String body = exchange.getIn().getBody(String.class);
+
+        LOG.debug(""Body in producer: "" + body);","[{'comment': 'Use {} placeholders in logger and not + concat', 'commenter': 'davsclaus'}]"
3777,components/camel-resteasy/src/main/java/org/apache/camel/component/resteasy/DefaultResteasyHttpBinding.java,"@@ -0,0 +1,219 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.resteasy;
+
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.Map;
+
+import javax.ws.rs.client.Client;
+import javax.ws.rs.client.ClientBuilder;
+import javax.ws.rs.client.Entity;
+import javax.ws.rs.client.Invocation;
+import javax.ws.rs.client.WebTarget;
+import javax.ws.rs.core.Response;
+
+import org.apache.camel.Exchange;
+import org.apache.camel.spi.HeaderFilterStrategy;
+import org.apache.camel.support.MessageHelper;
+import org.apache.camel.util.ObjectHelper;
+import org.apache.commons.lang3.exception.ExceptionUtils;
+import org.jboss.resteasy.client.jaxrs.ResteasyWebTarget;
+import org.jboss.resteasy.client.jaxrs.internal.BasicAuthentication;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * The default Resteasy binding implementation
+ */
+public class DefaultResteasyHttpBinding implements ResteasyHttpBinding {
+
+    private static final Logger LOG = LoggerFactory.getLogger(DefaultResteasyHttpBinding.class);
+
+    private HeaderFilterStrategy headerFilterStrategy;
+
+    public HeaderFilterStrategy getHeaderFilterStrategy() {
+        return headerFilterStrategy;
+    }
+
+    @Override
+    public void setHeaderFilterStrategy(HeaderFilterStrategy headerFilterStrategy) {
+        this.headerFilterStrategy = headerFilterStrategy;
+    }
+
+    @Override
+    public Response populateResteasyRequestFromExchangeAndExecute(String uri, Exchange exchange, Map<String, String> parameters) {
+        Client client = ClientBuilder.newBuilder().build();
+        String body = exchange.getIn().getBody(String.class);","[{'comment': 'This forces the body to be string based. Wonder if we should in the future support inputstream and byte[] too', 'commenter': 'davsclaus'}, {'comment': 'might be improved later maybe??', 'commenter': 'onderson'}]"
3777,components/camel-resteasy/src/main/java/org/apache/camel/component/resteasy/DefaultResteasyHttpBinding.java,"@@ -0,0 +1,219 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.resteasy;
+
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.Map;
+
+import javax.ws.rs.client.Client;
+import javax.ws.rs.client.ClientBuilder;
+import javax.ws.rs.client.Entity;
+import javax.ws.rs.client.Invocation;
+import javax.ws.rs.client.WebTarget;
+import javax.ws.rs.core.Response;
+
+import org.apache.camel.Exchange;
+import org.apache.camel.spi.HeaderFilterStrategy;
+import org.apache.camel.support.MessageHelper;
+import org.apache.camel.util.ObjectHelper;
+import org.apache.commons.lang3.exception.ExceptionUtils;
+import org.jboss.resteasy.client.jaxrs.ResteasyWebTarget;
+import org.jboss.resteasy.client.jaxrs.internal.BasicAuthentication;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * The default Resteasy binding implementation
+ */
+public class DefaultResteasyHttpBinding implements ResteasyHttpBinding {
+
+    private static final Logger LOG = LoggerFactory.getLogger(DefaultResteasyHttpBinding.class);
+
+    private HeaderFilterStrategy headerFilterStrategy;
+
+    public HeaderFilterStrategy getHeaderFilterStrategy() {
+        return headerFilterStrategy;
+    }
+
+    @Override
+    public void setHeaderFilterStrategy(HeaderFilterStrategy headerFilterStrategy) {
+        this.headerFilterStrategy = headerFilterStrategy;
+    }
+
+    @Override
+    public Response populateResteasyRequestFromExchangeAndExecute(String uri, Exchange exchange, Map<String, String> parameters) {
+        Client client = ClientBuilder.newBuilder().build();
+        String body = exchange.getIn().getBody(String.class);
+
+        LOG.debug(""Body in producer: "" + body);
+
+        String mediaType = exchange.getIn().getHeader(Exchange.CONTENT_TYPE, String.class);
+
+        WebTarget target = client.target(uri);
+
+        LOG.debug(""Populate Resteasy request from exchange body: {} using media type {}"", body, mediaType);
+
+        Invocation.Builder builder;
+        if (mediaType != null) {
+            builder = target.request(mediaType);
+        } else {
+            builder = target.request();
+        }
+
+
+        for (Map.Entry<String, Object> entry : exchange.getIn().getHeaders().entrySet()) {
+            String key = entry.getKey();
+            Object value = entry.getValue();
+            if (headerFilterStrategy != null
+                    && !headerFilterStrategy.applyFilterToCamelHeaders(key, value, exchange)) {
+                builder.header(key, value);
+                LOG.debug(""Populate Resteasy request from exchange header: {} value: {}"", key, value);
+            }
+        }
+
+        if (parameters.get(""username"") != null && parameters.get(""password"") != null) {
+            target.register(new BasicAuthentication(parameters.get(""username""), parameters.get(""password"")));
+        }
+        LOG.debug(""Basic authentication was applied"");
+        String method = parameters.get(""method"");
+
+        if (method.equals(""GET"")) {
+            return builder.get();
+        }
+        if (method.equals(""POST"")) {
+            return  builder.post(Entity.entity(body, mediaType));
+        }
+        if (method.equals(""PUT"")) {
+            return  builder.put(Entity.entity(body, mediaType));
+        }
+        if (method.equals(""DELETE"")) {
+            return  builder.delete();
+        }
+        if (method.equals(""OPTIONS"")) {
+            return  builder.options();
+        }
+        if (method.equals(""TRACE"")) {
+            return  builder.trace();
+        }
+        if (method.equals(""HEAD"")) {
+            return  builder.head();
+        }
+
+        // maybe throw exception because not method was correct
+        throw new IllegalArgumentException(""Method '"" + method + ""' is not supported method"");
+    }
+
+
+    @SuppressWarnings({ ""rawtypes"", ""unchecked"" })
+    @Override
+    public void populateProxyResteasyRequestAndExecute(String uri, Exchange exchange, Map<String, String> parameters) {
+        Client client = ClientBuilder.newBuilder().build();
+
+        WebTarget target = client.target(uri);
+
+        if (parameters.get(""username"") != null && parameters.get(""password"") != null) {
+            target.register(new BasicAuthentication(parameters.get(""username""), parameters.get(""password"")));","[{'comment': 'Hmm I would rather have no surprise, and that we have a autoMethod=Basic you configure on the endpoint or component. ', 'commenter': 'davsclaus'}, {'comment': 'not sure if i got this one right? this might be something i am missing. can you please give a little bit more details?\r\n', 'commenter': 'onderson'}, {'comment': 'You just assume username/password requires basic auth. But they may just be query parameters for something else. Instead we should have an option to turn on authentication first. And so only do this if that option is turned on.', 'commenter': 'davsclaus'}]"
3777,components/camel-resteasy/src/main/java/org/apache/camel/component/resteasy/DefaultResteasyHttpBinding.java,"@@ -0,0 +1,219 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.resteasy;
+
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.Map;
+
+import javax.ws.rs.client.Client;
+import javax.ws.rs.client.ClientBuilder;
+import javax.ws.rs.client.Entity;
+import javax.ws.rs.client.Invocation;
+import javax.ws.rs.client.WebTarget;
+import javax.ws.rs.core.Response;
+
+import org.apache.camel.Exchange;
+import org.apache.camel.spi.HeaderFilterStrategy;
+import org.apache.camel.support.MessageHelper;
+import org.apache.camel.util.ObjectHelper;
+import org.apache.commons.lang3.exception.ExceptionUtils;
+import org.jboss.resteasy.client.jaxrs.ResteasyWebTarget;
+import org.jboss.resteasy.client.jaxrs.internal.BasicAuthentication;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * The default Resteasy binding implementation
+ */
+public class DefaultResteasyHttpBinding implements ResteasyHttpBinding {
+
+    private static final Logger LOG = LoggerFactory.getLogger(DefaultResteasyHttpBinding.class);
+
+    private HeaderFilterStrategy headerFilterStrategy;
+
+    public HeaderFilterStrategy getHeaderFilterStrategy() {
+        return headerFilterStrategy;
+    }
+
+    @Override
+    public void setHeaderFilterStrategy(HeaderFilterStrategy headerFilterStrategy) {
+        this.headerFilterStrategy = headerFilterStrategy;
+    }
+
+    @Override
+    public Response populateResteasyRequestFromExchangeAndExecute(String uri, Exchange exchange, Map<String, String> parameters) {
+        Client client = ClientBuilder.newBuilder().build();
+        String body = exchange.getIn().getBody(String.class);
+
+        LOG.debug(""Body in producer: "" + body);
+
+        String mediaType = exchange.getIn().getHeader(Exchange.CONTENT_TYPE, String.class);
+
+        WebTarget target = client.target(uri);
+
+        LOG.debug(""Populate Resteasy request from exchange body: {} using media type {}"", body, mediaType);
+
+        Invocation.Builder builder;
+        if (mediaType != null) {
+            builder = target.request(mediaType);
+        } else {
+            builder = target.request();
+        }
+
+
+        for (Map.Entry<String, Object> entry : exchange.getIn().getHeaders().entrySet()) {
+            String key = entry.getKey();
+            Object value = entry.getValue();
+            if (headerFilterStrategy != null
+                    && !headerFilterStrategy.applyFilterToCamelHeaders(key, value, exchange)) {
+                builder.header(key, value);
+                LOG.debug(""Populate Resteasy request from exchange header: {} value: {}"", key, value);
+            }
+        }
+
+        if (parameters.get(""username"") != null && parameters.get(""password"") != null) {
+            target.register(new BasicAuthentication(parameters.get(""username""), parameters.get(""password"")));
+        }
+        LOG.debug(""Basic authentication was applied"");
+        String method = parameters.get(""method"");
+
+        if (method.equals(""GET"")) {
+            return builder.get();
+        }
+        if (method.equals(""POST"")) {
+            return  builder.post(Entity.entity(body, mediaType));
+        }
+        if (method.equals(""PUT"")) {
+            return  builder.put(Entity.entity(body, mediaType));
+        }
+        if (method.equals(""DELETE"")) {
+            return  builder.delete();
+        }
+        if (method.equals(""OPTIONS"")) {
+            return  builder.options();
+        }
+        if (method.equals(""TRACE"")) {
+            return  builder.trace();
+        }
+        if (method.equals(""HEAD"")) {
+            return  builder.head();
+        }
+
+        // maybe throw exception because not method was correct
+        throw new IllegalArgumentException(""Method '"" + method + ""' is not supported method"");
+    }
+
+
+    @SuppressWarnings({ ""rawtypes"", ""unchecked"" })
+    @Override
+    public void populateProxyResteasyRequestAndExecute(String uri, Exchange exchange, Map<String, String> parameters) {
+        Client client = ClientBuilder.newBuilder().build();
+
+        WebTarget target = client.target(uri);
+
+        if (parameters.get(""username"") != null && parameters.get(""password"") != null) {
+            target.register(new BasicAuthentication(parameters.get(""username""), parameters.get(""password"")));
+        }
+
+        if (LOG.isTraceEnabled()) {
+            LOG.trace(""Basic authentication was applied"");
+        }
+
+        Class realClazz;
+        Object object = null;
+        try {
+            realClazz = Class.forName(parameters.get(""proxyClassName""));","[{'comment': 'Dont load classes via Class.forName. What is this proxyClassName use-case?', 'commenter': 'davsclaus'}, {'comment': 'i think it is to support proxy framework which is part of resteasy \r\nhttps://docs.jboss.org/resteasy/docs/4.5.3.Final/userguide/html/RESTEasy_Client_Framework.html#proxies', 'commenter': 'onderson'}, {'comment': 'yes i am aware of the efforts of removing reflections and not sure this feature what to do about this feature, either removing or dropping might be fine as this is a feature in resteasy.\r\n', 'commenter': 'onderson'}, {'comment': 'So is this mandatory? Do I really need to write a class with annotations to call a remote HTTP REST service? \r\n\r\n', 'commenter': 'davsclaus'}, {'comment': ""in earlier versions the client framework was a bit limited in resteasy. there are other ways but looks like this is one of the prior methods considering API support coming from resteasy's history. to consider adding / removing such features, engagement with resteasy community might be good but can be said of being not strong ATM"", 'commenter': 'onderson'}]"
3777,components/camel-resteasy/src/main/java/org/apache/camel/component/resteasy/servlet/ResteasyCamelServlet.java,"@@ -0,0 +1,359 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.resteasy.servlet;
+
+import java.io.IOException;
+import java.lang.reflect.InvocationHandler;
+import java.lang.reflect.Proxy;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
+
+import javax.servlet.ServletConfig;
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
+import org.apache.camel.Exchange;
+import org.apache.camel.ExchangePattern;
+import org.apache.camel.component.resteasy.DefaultHttpRegistry;
+import org.apache.camel.component.resteasy.HttpRegistry;
+import org.apache.camel.component.resteasy.ResteasyComponent;
+import org.apache.camel.component.resteasy.ResteasyConstants;
+import org.apache.camel.component.resteasy.ResteasyEndpoint;
+import org.apache.camel.http.common.HttpConsumer;
+import org.apache.camel.http.common.HttpHelper;
+import org.apache.camel.http.common.HttpMessage;
+import org.apache.camel.support.DefaultExchange;
+import org.jboss.resteasy.plugins.server.servlet.HttpServletDispatcher;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * Class extending HttpServletDispatcher from Resteasy and representing servlet used as Camel Consumer. This servlet
+ * needs to be used in application if you want to use Camel Resteasy consumer in your camel routes.
+ */
+public class ResteasyCamelServlet extends HttpServletDispatcher {
+
+    private static final long serialVersionUID = 1L;
+    
+    private static final Logger LOG = LoggerFactory.getLogger(ResteasyCamelServlet.class);
+
+    private HttpRegistry httpRegistry;
+
+    private String servletName;
+
+    private final ConcurrentMap<String, HttpConsumer> consumers = new ConcurrentHashMap<String, HttpConsumer>();
+
+
+    /**
+     * Init method for ResteasyCamelServlet, which registering servlets to HttpRegistry and it is also registering
+     * proxy classes to Resteasy dispatcher
+     *
+     * @param servletConfig configuration of the servlet
+     * @throws ServletException exception thrown from the super method
+     */
+    @SuppressWarnings(""rawtypes"")
+    @Override
+    public void init(ServletConfig servletConfig) throws ServletException {
+        super.init(servletConfig);
+
+        String name = servletConfig.getServletName();
+        if (httpRegistry == null) {
+            httpRegistry = DefaultHttpRegistry.getHttpRegistry(name);
+            ResteasyCamelServlet existing = httpRegistry.getCamelServlet(name);
+            if (existing != null) {
+                String msg = ""Duplicate ServletName detected: "" + name + "". Existing: "" + existing + "" This: "" + this.toString()
+                        + "". Its advised to use unique ServletName per Camel application."";
+                // always log so people can see it easier
+                LOG.info(msg);
+            }
+            httpRegistry.register(this);
+        }
+
+
+        for (Map.Entry<String, HttpConsumer> entry : consumers.entrySet()) {
+            String proxyClasses = ((ResteasyComponent)getServletEndpoint(entry.getValue()).getComponent()).getProxyConsumersClasses();
+            if (proxyClasses != null) {
+                String[] classes = proxyClasses.split("","");
+                LOG.debug(""Proxy classes defined in the component {}"", Arrays.asList(classes));
+
+                for (String clazz : classes) {
+                    try {
+                        Class realClazz = Class.forName(clazz);
+                        // Create dynamic proxy class implementing interface
+                        InvocationHandler handler = new ResteasyInvocationHandler();
+                        Object  proxy = Proxy.newProxyInstance(realClazz.getClassLoader(), new Class[]{realClazz}, handler);
+
+                        // register new created proxy to the resteasy registry
+                        getDispatcher().getRegistry().addSingletonResource(proxy);
+                    } catch (ClassNotFoundException e) {
+                        e.printStackTrace();","[{'comment': 'Dont ignore exception, but log via logger or fail fast or something', 'commenter': 'davsclaus'}]"
3777,components/camel-resteasy/src/main/java/org/apache/camel/component/resteasy/ResteasyEndpoint.java,"@@ -0,0 +1,274 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.resteasy;
+
+import java.net.URI;
+import java.net.URISyntaxException;
+
+import org.apache.camel.Consumer;
+import org.apache.camel.Processor;
+import org.apache.camel.Producer;
+import org.apache.camel.component.http.HttpClientConfigurer;
+import org.apache.camel.component.http.HttpEndpoint;
+import org.apache.camel.spi.HeaderFilterStrategy;
+import org.apache.camel.spi.HeaderFilterStrategyAware;
+import org.apache.camel.spi.UriEndpoint;
+import org.apache.camel.spi.UriParam;
+import org.apache.http.conn.HttpClientConnectionManager;
+import org.apache.http.impl.client.HttpClientBuilder;
+
+/**
+ * Defines the Resteasy Endpoint.
+ * It contains a list of properties for Resteasy endpoint including {@link org.apache.camel.component.resteasy.ResteasyHttpBinding},
+ * and {@link HeaderFilterStrategy}.
+ *
+ */
+@UriEndpoint(firstVersion = ""3.3.0"", scheme = ""resteasy"",  extendsScheme = ""http"", 
+        title = ""Resteasy"", syntax = ""resteasy:contextPath"", consumerOnly = true, label = ""rest"")","[{'comment': 'is it consumer only or was there also a producer?', 'commenter': 'davsclaus'}, {'comment': 'there is a producer. to be amended.', 'commenter': 'onderson'}]"
3777,components/camel-resteasy/src/main/java/org/apache/camel/component/resteasy/servlet/ResteasyServletInputStreamCopier.java,"@@ -0,0 +1,70 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.resteasy.servlet;
+
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+
+import javax.servlet.ReadListener;
+import javax.servlet.ServletInputStream;
+
+/**
+ * Class for copying input stream from HttpRequest
+ */
+public class ResteasyServletInputStreamCopier extends ServletInputStream {
+    
+    private InputStream input;
+    private ByteArrayOutputStream copy;
+
+    public ResteasyServletInputStreamCopier(InputStream inputStream) {
+        /* create a new input stream from the cached request body */
+        this.input = inputStream;
+        this.copy = new ByteArrayOutputStream();","[{'comment': 'This will read the entire stream into memory.\r\n\r\nCamel has a stream caching feature. Maybe we should revisit this later.', 'commenter': 'davsclaus'}]"
3777,components/camel-resteasy/pom.xml,"@@ -0,0 +1,287 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one or more
+    contributor license agreements.  See the NOTICE file distributed with
+    this work for additional information regarding copyright ownership.
+    The ASF licenses this file to You under the Apache License, Version 2.0
+    (the ""License""); you may not use this file except in compliance with
+    the License.  You may obtain a copy of the License at
+
+         http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an ""AS IS"" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+
+-->
+<project xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
+    xmlns=""http://maven.apache.org/POM/4.0.0""
+    xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+
+    <modelVersion>4.0.0</modelVersion>
+
+    <parent>
+        <groupId>org.apache.camel</groupId>
+        <artifactId>components</artifactId>
+        <version>3.3.0-SNAPSHOT</version>
+    </parent>
+
+    <artifactId>camel-resteasy</artifactId>
+    <packaging>jar</packaging>
+    <name>Camel :: Resteasy</name>
+    <description>Camel Resteasy support</description>
+
+    <dependencyManagement>
+        <dependencies>
+            <dependency>
+                <groupId>org.jboss.arquillian</groupId>
+                <artifactId>arquillian-bom</artifactId>
+                <version>${arquillian-version}</version>
+                <scope>import</scope>
+                <type>pom</type>
+            </dependency>
+            <dependency>
+                <groupId>org.jboss.resteasy</groupId>
+                <artifactId>resteasy-bom</artifactId>
+                <version>${resteasy-version}</version>
+                <type>pom</type>
+                <scope>import</scope>
+            </dependency>
+            <dependency>
+                <groupId>org.jboss.resteasy</groupId>
+                <artifactId>resteasy-core</artifactId>
+                <version>${resteasy-version}</version>
+            </dependency>
+            <dependency>
+                <groupId>javax.servlet</groupId>
+                <artifactId>javax.servlet-api</artifactId>
+                <version>${javax-servlet-api-version}</version>
+            </dependency>
+        </dependencies>
+    </dependencyManagement>
+
+    <dependencies>
+        <!-- resteasy dependencies -->
+        <dependency>
+            <groupId>org.jboss.resteasy</groupId>
+            <artifactId>resteasy-core-spi</artifactId>
+        </dependency>
+        <dependency>
+            <groupId>org.jboss.resteasy</groupId>
+            <artifactId>resteasy-spring</artifactId>","[{'comment': 'What do you use spring for?', 'commenter': 'davsclaus'}, {'comment': 'to be scoped as test', 'commenter': 'onderson'}]"
3777,components/camel-resteasy/pom.xml,"@@ -0,0 +1,287 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one or more
+    contributor license agreements.  See the NOTICE file distributed with
+    this work for additional information regarding copyright ownership.
+    The ASF licenses this file to You under the Apache License, Version 2.0
+    (the ""License""); you may not use this file except in compliance with
+    the License.  You may obtain a copy of the License at
+
+         http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an ""AS IS"" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+
+-->
+<project xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
+    xmlns=""http://maven.apache.org/POM/4.0.0""
+    xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+
+    <modelVersion>4.0.0</modelVersion>
+
+    <parent>
+        <groupId>org.apache.camel</groupId>
+        <artifactId>components</artifactId>
+        <version>3.3.0-SNAPSHOT</version>
+    </parent>
+
+    <artifactId>camel-resteasy</artifactId>
+    <packaging>jar</packaging>
+    <name>Camel :: Resteasy</name>
+    <description>Camel Resteasy support</description>
+
+    <dependencyManagement>
+        <dependencies>
+            <dependency>
+                <groupId>org.jboss.arquillian</groupId>
+                <artifactId>arquillian-bom</artifactId>","[{'comment': 'Its a bit shame to use arquillian for testing but its good for those WAR archives. But the project is dead just mind that.', 'commenter': 'davsclaus'}, {'comment': 'the reason of using arquillian was that the support on test-runtime was better explained and was easier to use. before in the tests, it was wildfly. maybe, it could have been used in testing but thought that style would be wildfly specific. maybe we can park it and track it to enhance with another JIRA. ', 'commenter': 'onderson'}, {'comment': 'https://issues.apache.org/jira/browse/CAMEL-15038', 'commenter': 'onderson'}]"
3777,components/camel-resteasy/src/main/java/org/apache/camel/component/resteasy/DefaultResteasyHttpBinding.java,"@@ -0,0 +1,218 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.resteasy;
+
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.Map;
+
+import javax.ws.rs.client.Client;
+import javax.ws.rs.client.ClientBuilder;
+import javax.ws.rs.client.Entity;
+import javax.ws.rs.client.Invocation;
+import javax.ws.rs.client.WebTarget;
+import javax.ws.rs.core.Response;
+
+import org.apache.camel.Exchange;
+import org.apache.camel.spi.HeaderFilterStrategy;
+import org.apache.camel.support.MessageHelper;
+import org.apache.camel.util.ObjectHelper;
+import org.apache.commons.lang3.exception.ExceptionUtils;","[{'comment': 'Can you avoid using this - Camel has api for working with exceptions. We should avoid adding a 3rd party JAR just to use a single api which we have ourselves or easily can write a few lines of code.', 'commenter': 'davsclaus'}]"
3810,components/camel-bindy/src/test/java/org/apache/camel/dataformat/bindy/model/date/BindyDatePatternCsvUnmarshallTest.java,"@@ -167,7 +171,15 @@ public void setReceivedTime(LocalTime receivedTime) {
             this.receivedTime = receivedTime;
         }
 
-        public ReturnReason getReturnReason() {
+		public ZonedDateTime getDeletedDateTime() {","[{'comment': ""Please run the build with the profile sourcecheck enable and fix the warnings you'll see"", 'commenter': 'oscerd'}]"
3810,components/camel-bindy/src/main/java/org/apache/camel/dataformat/bindy/format/factories/ZonedDateTimeFormatFactory.java,"@@ -0,0 +1,92 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.dataformat.bindy.format.factories;
+
+import java.time.ZonedDateTime;
+import java.time.format.DateTimeFormatter;
+import java.util.Locale;
+
+import org.apache.camel.dataformat.bindy.Format;
+import org.apache.camel.dataformat.bindy.FormattingOptions;
+import org.apache.camel.dataformat.bindy.PatternFormat;
+import org.apache.camel.util.ObjectHelper;
+
+public class ZonedDateTimeFormatFactory extends AbstractFormatFactory {
+
+    {
+        supportedClasses.add(ZonedDateTime.class);
+    }
+
+    @Override
+    public Format<?> build(FormattingOptions formattingOptions) {
+        return new ZonedDateTimePatternFormat(formattingOptions.getPattern(),
+                formattingOptions.getLocale());
+    }
+
+    private static class ZonedDateTimePatternFormat implements PatternFormat<ZonedDateTime> {
+
+        private String pattern;
+        private Locale locale;
+
+        ZonedDateTimePatternFormat(String pattern/*, String timezone*/, Locale locale) {","[{'comment': 'Is it intentional to comment out the string param here?', 'commenter': 'omarsmak'}]"
3810,components/camel-bindy/src/main/java/org/apache/camel/dataformat/bindy/format/factories/ZonedDateTimeFormatFactory.java,"@@ -0,0 +1,92 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.dataformat.bindy.format.factories;
+
+import java.time.ZonedDateTime;
+import java.time.format.DateTimeFormatter;
+import java.util.Locale;
+
+import org.apache.camel.dataformat.bindy.Format;
+import org.apache.camel.dataformat.bindy.FormattingOptions;
+import org.apache.camel.dataformat.bindy.PatternFormat;
+import org.apache.camel.util.ObjectHelper;
+
+public class ZonedDateTimeFormatFactory extends AbstractFormatFactory {
+
+    {
+        supportedClasses.add(ZonedDateTime.class);
+    }
+
+    @Override
+    public Format<?> build(FormattingOptions formattingOptions) {
+        return new ZonedDateTimePatternFormat(formattingOptions.getPattern(),
+                formattingOptions.getLocale());
+    }
+
+    private static class ZonedDateTimePatternFormat implements PatternFormat<ZonedDateTime> {
+
+        private String pattern;
+        private Locale locale;
+
+        ZonedDateTimePatternFormat(String pattern/*, String timezone*/, Locale locale) {
+            this.pattern = pattern;
+            this.locale = locale;
+        }
+
+        @Override
+        public String format(ZonedDateTime object) throws Exception {
+            ObjectHelper.notNull(this.pattern, ""pattern"");
+            return this.getDateFormat().format(object);
+        }
+
+        @Override
+        public ZonedDateTime parse(String string) throws Exception {
+
+            ZonedDateTime date;
+            DateTimeFormatter df = this.getDateFormat();
+
+            ObjectHelper.notNull(this.pattern, ""pattern"");
+            date = ZonedDateTime.parse(string, df);","[{'comment': ""I'd change this to initialize `date` directly unless there was another reason perhaps?:\r\n```suggestion\r\n            ZonedDateTime date = ZonedDateTime.parse(string, df);\r\n```"", 'commenter': 'omarsmak'}]"
3824,components/camel-webhook/src/main/java/org/apache/camel/component/webhook/WebhookEndpoint.java,"@@ -78,10 +79,16 @@ public void afterPropertiesConfigured(CamelContext camelContext) {
         delegateEndpoint.setWebhookConfiguration(configuration);
     }
 
+    @Override
+    protected void doInit() throws Exception {
+        super.doInit();
+        ServiceHelper.initService(delegateEndpoint);","[{'comment': 'This might be not necessary here. And it should be in https://github.com/apache/camel/blob/master/core/camel-base/src/main/java/org/apache/camel/impl/engine/AbstractCamelContext.java#L1457 ', 'commenter': 'zhfeng'}]"
3824,components/camel-webhook/src/main/java/org/apache/camel/component/webhook/WebhookEndpoint.java,"@@ -78,10 +79,16 @@ public void afterPropertiesConfigured(CamelContext camelContext) {
         delegateEndpoint.setWebhookConfiguration(configuration);
     }
 
+    @Override
+    protected void doInit() throws Exception {
+        super.doInit();
+        ServiceHelper.initService(delegateEndpoint);
+    }
+
     @Override
     protected void doStart() throws Exception {
         super.doStart();
-
+        ServiceHelper.startService(delegateEndpoint);","[{'comment': 'if the delegateEndpoint has been stared as this router is added after the camel context started, what would happen ? The endpoint can be started twice ?', 'commenter': 'zhfeng'}, {'comment': 'Thats taken care of internally by Camel to check its state and only start if not already started etc. ', 'commenter': 'davsclaus'}]"
3824,components/camel-webhook/src/main/java/org/apache/camel/component/webhook/WebhookEndpoint.java,"@@ -91,11 +98,17 @@ protected void doStart() throws Exception {
     @Override
     protected void doStop() throws Exception {
         super.doStop();
-
         if (configuration.isWebhookAutoRegister() && delegateEndpoint != null) {
             LOG.info(""Unregistering webhook for endpoint: {}"", delegateEndpoint);
             delegateEndpoint.unregisterWebhook();
         }
+        ServiceHelper.stopService(delegateEndpoint);","[{'comment': 'Not sure it is safe to stop the endpoint here.', 'commenter': 'zhfeng'}, {'comment': 'The webhook is creating the delegate endpoint and should handle its lifecycle. That is how its done in other componens that does something like this', 'commenter': 'davsclaus'}]"
3859,components/camel-xslt/src/main/java/org/apache/camel/component/xslt/XsltEndpoint.java,"@@ -327,8 +327,8 @@ protected void loadResource(String resourceUri, XsltBuilder xslt) throws Transfo
     }
 
     @Override
-    protected void doStart() throws Exception {
-        super.doStart();
+    protected void doInit() throws Exception {
+        super.doInit();","[{'comment': 'We cannot do init here as createXsltBuilder is potentially loading resources from file system and that should be done in doStart. Loading exclusively from classpath is okay in doInit. But file system should be in doStart.', 'commenter': 'davsclaus'}]"
3859,components/camel-stream/src/main/java/org/apache/camel/component/stream/StreamEndpoint.java,"@@ -303,7 +303,8 @@ public void setReadTimeout(int readTimeout) {
     //-------------------------------------------------------------------------
 
     @Override
-    protected void doStart() throws Exception {
+    protected void doInit() throws Exception {
+        super.doInit();","[{'comment': 'charsets are potentially not available if native compiling, so we may consider to make this doStart. However there are ways to make native compilation include all charsets.', 'commenter': 'davsclaus'}]"
3859,components/camel-sql/src/main/java/org/apache/camel/component/sql/stored/SqlStoredProducer.java,"@@ -123,8 +123,8 @@ private StatementWrapper createStatement(Exchange exchange) throws SQLException
     }
 
     @Override
-    protected void doStart() throws Exception {
-        super.doStart();
+    protected void doInit() throws Exception {
+        super.doInit();","[{'comment': 'This should be doStart as SqlHelper.resolveQuery can potentially load the SQL template from file system. See the SQL docs', 'commenter': 'davsclaus'}]"
3859,components/camel-sql/src/main/java/org/apache/camel/component/sql/SqlProducer.java,"@@ -69,8 +69,8 @@ public SqlEndpoint getEndpoint() {
     }
 
     @Override
-    protected void doStart() throws Exception {
-        super.doStart();
+    protected void doInit() throws Exception {
+        super.doInit();","[{'comment': 'This should be doStart as SqlHelper.resolveQuery can potentially load the SQL template from file system. See the SQL docs', 'commenter': 'davsclaus'}]"
3859,components/camel-sql/src/main/java/org/apache/camel/component/sql/SqlConsumer.java,"@@ -101,8 +101,8 @@ public DefaultSqlEndpoint getEndpoint() {
     }
 
     @Override
-    protected void doStart() throws Exception {
-        super.doStart();
+    protected void doInit() throws Exception {
+        super.doInit();","[{'comment': 'This should be doStart as SqlHelper.resolveQuery can potentially load the SQL template from file system. See the SQL docs', 'commenter': 'davsclaus'}]"
3866,components/camel-elsql/src/main/java/org/apache/camel/component/elsql/ElsqlEndpoint.java,"@@ -121,16 +123,39 @@ protected void doStart() throws Exception {
             elSqlConfig = ElSqlDatabaseVendor.Default.asElSqlConfig();
         }
 
+        // load and parse the sources which are from classpath
+        parseResources(resourceUri, uri-> ResourceHelper.isClasspathUri(uri));
+    }
+
+    @Override
+    protected void doStart() throws Exception {
+        super.doStart();
+
+        // load and parse the sources which are not from classpath
+        parseResources(resourceUri, uri-> !ResourceHelper.isClasspathUri(uri));
+    }
+
+    private void parseResources(String resourceUri, Predicate<String> predicate) throws Exception {
         // there can be multiple resources
         // so we have all this lovely code to turn that into an URL[]
         final List<URL> list = new ArrayList<>();
         final Iterable it = ObjectHelper.createIterable(resourceUri);
-        for (final Object path : it) {
-            final URL url = ResourceHelper.resolveMandatoryResourceAsUrl(getCamelContext().getClassResolver(), path.toString());
-            list.add(url);
+
+        StreamSupport.stream(it.spliterator(), false)
+                .filter(predicate)
+                .forEach(path -> {
+                    try {
+                        final URL url = ResourceHelper.resolveMandatoryResourceAsUrl(getCamelContext().getClassResolver(), path.toString());
+                        list.add(url);
+                    } catch (Exception e) {
+","[{'comment': 'This is wrong as you ignore thrown exception - I suggest to NOT use streaming API as its also TERRIBLE sometimes as in this example being overly complex and causing you to do try .. catch and ignore exceptions.', 'commenter': 'davsclaus'}, {'comment': 'OK, I see and will update to use the iterable as usual.', 'commenter': 'zhfeng'}, {'comment': 'Thanks', 'commenter': 'davsclaus'}]"
3866,components/camel-elsql/src/main/java/org/apache/camel/component/elsql/ElsqlEndpoint.java,"@@ -139,18 +139,14 @@ private void parseResources(String resourceUri, Predicate<String> predicate) thr
         // there can be multiple resources
         // so we have all this lovely code to turn that into an URL[]
         final List<URL> list = new ArrayList<>();
-        final Iterable it = ObjectHelper.createIterable(resourceUri);
-
-        StreamSupport.stream(it.spliterator(), false)
-                .filter(predicate)
-                .forEach(path -> {
-                    try {
-                        final URL url = ResourceHelper.resolveMandatoryResourceAsUrl(getCamelContext().getClassResolver(), path.toString());
-                        list.add(url);
-                    } catch (Exception e) {
-
-                    }
-                });
+        final Iterable<String> it = ObjectHelper.createIterable(resourceUri);
+
+        for(final String path : it) {","[{'comment': 'Can you fix CS, eg run mvn compile -P sourcecheck', 'commenter': 'davsclaus'}]"
3877,components/camel-kafka/src/main/java/org/apache/camel/component/kafka/KafkaConsumer.java,"@@ -460,7 +460,14 @@ public void onPartitionsRevoked(Collection<TopicPartition> partitions) {
                     offset = -1L;
                 }
                 LOG.debug(""Saving offset repository state {} from offsetKey {} with offset: {}"", threadId, offsetKey, offset);
-                commitOffset(offsetRepository, partition, offset, true);
+                try {
+                    commitOffset(offsetRepository, partition, offset, true);
+                } catch (java.lang.Exception e) {
+                    LOG.error(""Error saving offset repository state {} from offsetKey {} with offset: {}"", threadId, offsetKey, offset);
+                    throw e;
+                } finally {
+                    lastProcessedOffset.clear();","[{'comment': 'This finally block code is always exectued also for success. Is this really intended?', 'commenter': 'davsclaus'}, {'comment': 'Thank you for pointing that out. I was going by the comments in the JIRA.\r\nSince the partition is being revoked, I think it is fine to clear it out always, not just on the exception. \r\nhttps://issues.apache.org/jira/browse/CAMEL-14935\r\n\r\nBut, I will double-check with the reporter of the JIRA too. ', 'commenter': 'DariusX'}, {'comment': 'Yes removal is required on success as previously.  Having the removal in the finally block fixes an issue where an exception on commit prevents the map entry being removed - leading to a risk of old offsets being committed in a future rebalance scenario.  ', 'commenter': 'ceejay66'}, {'comment': 'Thank you. \r\n@davsclaus Yes, doing it in the finally is correct.', 'commenter': 'DariusX'}]"
3877,components/camel-kafka/src/main/java/org/apache/camel/component/kafka/KafkaConsumer.java,"@@ -460,7 +460,14 @@ public void onPartitionsRevoked(Collection<TopicPartition> partitions) {
                     offset = -1L;
                 }
                 LOG.debug(""Saving offset repository state {} from offsetKey {} with offset: {}"", threadId, offsetKey, offset);
-                commitOffset(offsetRepository, partition, offset, true);
+                try {
+                    commitOffset(offsetRepository, partition, offset, true);
+                } catch (java.lang.Exception e) {
+                    LOG.error(""Error saving offset repository state {} from offsetKey {} with offset: {}"", threadId, offsetKey, offset);","[{'comment': 'What if you move the clear up here, and remove it from finally. Then its only cleared when there is an exception. And on success then the code below will only remove the current offset key, which seems correct to me.', 'commenter': 'davsclaus'}, {'comment': ""We don't want to clear the map as it is used by multiple consumers and we will lose their state of last processed offset that may not be committed yet.  We just want to remove the entry from the map as it did originally but ensure we do this in the exception case as well as the non exception case. Moving the remove to the finally block gives us that behavior"", 'commenter': 'ceejay66'}]"
3897,components/camel-minio/ReadMe.txt,"@@ -0,0 +1,33 @@
+
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one or more
+    contributor license agreements.  See the NOTICE file distributed with
+    this work for additional information regarding copyright ownership.
+    The ASF licenses this file to You under the Apache License, Version 2.0
+    (the ""License""); you may not use this file except in compliance with
+    the License.  You may obtain a copy of the License at
+
+         http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an ""AS IS"" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+
+-->
+
+Camel Component Project
+=======================
+
+This project is a template of a Camel component.
+
+To build this project use
+
+    mvn install
+
+For more help see the Apache Camel documentation:
+
+    http://camel.apache.org/writing-components.html
+    ","[{'comment': 'This is not needed. You could remove this file.', 'commenter': 'oscerd'}]"
3897,components/camel-minio/pom.xml,"@@ -0,0 +1,140 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one or more
+    contributor license agreements.  See the NOTICE file distributed with
+    this work for additional information regarding copyright ownership.
+    The ASF licenses this file to You under the Apache License, Version 2.0
+    (the ""License""); you may not use this file except in compliance with
+    the License.  You may obtain a copy of the License at
+
+         http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an ""AS IS"" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+
+-->
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <artifactId>components</artifactId>
+    <groupId>org.apache.camel</groupId>
+    <version>3.4.0-SNAPSHOT</version>
+  </parent>
+
+  <artifactId>camel-minio</artifactId>
+  <packaging>jar</packaging>
+
+  <name>Camel :: MinIO</name>
+  <description>A Camel MinIO cloud storage server Component </description>
+
+  <properties>
+    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
+    <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
+  </properties>
+
+  <dependencyManagement>
+    <dependencies>
+      <!-- Camel BOM -->
+      <dependency>
+        <groupId>org.apache.camel</groupId>","[{'comment': 'No need for the camel-bom here. Take as example the other components in the components folder.', 'commenter': 'oscerd'}]"
3897,components/camel-minio/src/main/java/org/apache/camel/EventBusHelper.java,"@@ -0,0 +1,61 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.camel;
+
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.function.Consumer;
+
+/**
+ * Used for demonstrations purpose to simulate some external system event bus/broker, where messages are sent to, and
+ * this component can consume from.
+ */
+public class EventBusHelper {","[{'comment': 'This class can be removed.', 'commenter': 'oscerd'}, {'comment': ""Hi thank you for the suggestion, and I'll remove this for sure. But I'll keep it for a while for some random hello world kind tests while on the go. :)"", 'commenter': 'Nayananga'}]"
3897,components/camel-minio/src/main/java/org/apache/camel/MinIOComponent.java,"@@ -0,0 +1,35 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.camel;
+
+import java.util.Map;
+
+import org.apache.camel.CamelContext;
+import org.apache.camel.Endpoint;
+
+import org.apache.camel.support.DefaultComponent;
+
+@org.apache.camel.spi.annotations.Component(""MinIO"")","[{'comment': 'You can use directly Component annotation without the whole package.', 'commenter': 'oscerd'}]"
3897,components/camel-minio/src/main/java/org/apache/camel/MinIOConsumer.java,"@@ -0,0 +1,77 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.camel;
+
+import org.apache.camel.Exchange;
+import org.apache.camel.Processor;
+import org.apache.camel.RuntimeCamelException;
+import org.apache.camel.support.DefaultConsumer;
+
+import java.util.concurrent.ExecutorService;
+
+public class MinIOConsumer extends DefaultConsumer {
+    private final MinIOEndpoint endpoint;
+    private final EventBusHelper eventBusHelper;
+
+    private ExecutorService executorService;
+
+    public MinIOConsumer(MinIOEndpoint endpoint, Processor processor) {
+        super(endpoint, processor);
+        this.endpoint = endpoint;
+        eventBusHelper = EventBusHelper.getInstance();","[{'comment': ""Remove the eventBusHelper, except it is something really useful to the basic feature of component, but I don't think so."", 'commenter': 'oscerd'}, {'comment': ""Hi thank you for the suggestion, and I'll remove this for sure. But I'll keep it for a while for some random hello world kind tests while on the go. :)"", 'commenter': 'Nayananga'}]"
3897,components/pom.xml,"@@ -382,6 +382,7 @@
         <module>camel-zipkin</module>
         <module>camel-zookeeper-master</module>
         <module>camel-zookeeper</module>
+    <module>camel-minio</module>","[{'comment': 'Please add the component in the correct order.', 'commenter': 'oscerd'}]"
3897,components/camel-minio/src/main/java/org/apache/camel/MinIOEndpoint.java,"@@ -0,0 +1,87 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.camel;
+
+import org.apache.camel.Consumer;
+import org.apache.camel.Processor;
+import org.apache.camel.Producer;
+import org.apache.camel.support.DefaultEndpoint;
+import org.apache.camel.spi.Metadata;
+import org.apache.camel.spi.UriEndpoint;
+import org.apache.camel.spi.UriParam;
+import org.apache.camel.spi.UriPath;
+
+import java.util.concurrent.ExecutorService;
+
+/**
+ * MinIO component which does bla bla.
+ *
+ * TODO: Update one line description above what the component does.
+ */
+@UriEndpoint(firstVersion = ""1.0-SNAPSHOT"", scheme = ""MinIO"", title = ""MinIO"", syntax=""MinIO:name"",","[{'comment': 'Maybe `firstVersion` could be set to `3.5.0` or something like that.', 'commenter': 'DenisIstomin'}, {'comment': 'And maybe scheme could be lowercase, like ""minio""', 'commenter': 'DenisIstomin'}]"
3897,components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java,"@@ -0,0 +1,286 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.minio;
+
+import java.io.InputStream;
+import java.util.*;
+
+import io.minio.MinioClient;
+import io.minio.Result;
+import io.minio.errors.MinioException;
+import io.minio.messages.Item;
+import org.apache.camel.*;
+import org.apache.camel.spi.Synchronization;
+import org.apache.camel.support.ScheduledBatchPollingConsumer;
+import org.apache.camel.util.CastUtils;
+import org.apache.camel.util.IOHelper;
+import org.apache.camel.util.ObjectHelper;
+import org.apache.camel.util.URISupport;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * A Consumer of messages from the Minio Storage Service.
+ */
+public class MinioConsumer extends ScheduledBatchPollingConsumer {
+
+    private static final Logger LOG = LoggerFactory.getLogger(MinioConsumer.class);
+
+    private Iterator<Result<Item>> marker;
+    private transient String minioConsumerToString;
+
+    public MinioConsumer(MinioEndpoint endpoint, Processor processor) throws NoFactoryAvailableException {
+        super(endpoint, processor);
+    }
+
+    @Override
+    protected int poll() throws Exception {
+        // must reset for each poll
+        shutdownRunningTask = null;
+        pendingExchanges = 0;
+
+        MinioClient minioClient = getConfiguration().getMinioClient();
+        String objectName = getConfiguration().getObjectName();
+        String bucketName = getConfiguration().getBucketName();
+        Queue<Exchange> exchanges = null;
+
+        if (objectName != null) {
+            LOG.trace(""Getting object in bucket [{}] with object name [{}]..."", bucketName, objectName);
+
+            try {
+                InputStream stream = minioClient.getObject(bucketName,
+                        objectName,
+                        getConfiguration().getOffset(),
+                        getConfiguration().getLength(),
+                        getConfiguration().getServerSideEncryption());
+
+                exchanges = createExchanges(stream, objectName);
+            } catch (Exception e) {
+                LOG.trace(""Failed to get object in bucket [{}] with object name [{}], Error message [{}]"", bucketName, objectName, e);
+            }
+
+        } else {","[{'comment': '@oscerd @DenisIstomin What kind of approach suitable here? AWS2 S3 component have use something like this\r\n```\r\nListObjectsRequest.Builder listObjectsRequest = ListObjectsRequest.builder();\r\n            listObjectsRequest.bucket(bucketName);\r\n            listObjectsRequest.prefix(getConfiguration().getPrefix());\r\n            listObjectsRequest.delimiter(getConfiguration().getDelimiter());\r\n``` ', 'commenter': 'Nayananga'}, {'comment': 'you could use https://docs.min.io/docs/java-client-api-reference.html#listObjects @Nayananga ', 'commenter': 'oscerd'}]"
3897,components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java,"@@ -0,0 +1,286 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.minio;
+
+import java.io.InputStream;
+import java.util.*;
+
+import io.minio.MinioClient;
+import io.minio.Result;
+import io.minio.errors.MinioException;
+import io.minio.messages.Item;
+import org.apache.camel.*;
+import org.apache.camel.spi.Synchronization;
+import org.apache.camel.support.ScheduledBatchPollingConsumer;
+import org.apache.camel.util.CastUtils;
+import org.apache.camel.util.IOHelper;
+import org.apache.camel.util.ObjectHelper;
+import org.apache.camel.util.URISupport;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * A Consumer of messages from the Minio Storage Service.
+ */
+public class MinioConsumer extends ScheduledBatchPollingConsumer {
+
+    private static final Logger LOG = LoggerFactory.getLogger(MinioConsumer.class);
+
+    private Iterator<Result<Item>> marker;
+    private transient String minioConsumerToString;
+
+    public MinioConsumer(MinioEndpoint endpoint, Processor processor) throws NoFactoryAvailableException {
+        super(endpoint, processor);
+    }
+
+    @Override
+    protected int poll() throws Exception {
+        // must reset for each poll
+        shutdownRunningTask = null;
+        pendingExchanges = 0;
+
+        MinioClient minioClient = getConfiguration().getMinioClient();
+        String objectName = getConfiguration().getObjectName();
+        String bucketName = getConfiguration().getBucketName();
+        Queue<Exchange> exchanges = null;
+
+        if (objectName != null) {
+            LOG.trace(""Getting object in bucket [{}] with object name [{}]..."", bucketName, objectName);
+
+            try {
+                InputStream stream = minioClient.getObject(bucketName,
+                        objectName,
+                        getConfiguration().getOffset(),
+                        getConfiguration().getLength(),
+                        getConfiguration().getServerSideEncryption());
+
+                exchanges = createExchanges(stream, objectName);
+            } catch (Exception e) {
+                LOG.trace(""Failed to get object in bucket [{}] with object name [{}], Error message [{}]"", bucketName, objectName, e);
+            }
+
+        } else {
+
+            LOG.trace(""Queueing objects in bucket [{}]..."", bucketName);
+
+            Iterable<Result<Item>> results = minioClient.listObjects(bucketName,","[{'comment': ""Hi @oscerd, here if users haven't provided any objectName then my intention is to pull all the objects in the bucket using Iterator named marker, first I would like to know is that ok to do?"", 'commenter': 'Nayananga'}, {'comment': 'Hello @Nayananga , yes it is ok. You can do that and then process the result as a batch, like the S3 AWS2 component does.', 'commenter': 'oscerd'}, {'comment': 'Thank you, is it okay to queue all the bucket objects (may take lot memory I guess) then send to  ```processBatch(CastUtils.cast(exchanges))```? because in minio I had to queue each object in a ```Queue<Object>``` until ```iterator.hasNext()``` return false', 'commenter': 'Nayananga'}, {'comment': 'Not all the objects in one call, you need to define a limit for the batch, like setMaxKeys in AWS2 S3 component https://github.com/apache/camel/blob/master/components/camel-aws2-s3/src/main/java/org/apache/camel/component/aws2/s3/AWS2S3Consumer.java#L88\r\n\r\n', 'commenter': 'oscerd'}]"
3897,components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java,"@@ -0,0 +1,393 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.minio;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.security.InvalidKeyException;
+import java.security.NoSuchAlgorithmException;
+import java.util.*;
+
+import io.minio.DownloadObjectArgs;
+import io.minio.MinioClient;
+import io.minio.Result;
+import io.minio.errors.InvalidBucketNameException;
+import io.minio.errors.MinioException;
+import io.minio.messages.Bucket;
+import io.minio.messages.Item;
+import org.apache.camel.AsyncCallback;
+import org.apache.camel.Exchange;
+import org.apache.camel.ExtendedExchange;
+import org.apache.camel.NoFactoryAvailableException;
+import org.apache.camel.Processor;
+import org.apache.camel.spi.Synchronization;
+import org.apache.camel.support.ScheduledBatchPollingConsumer;
+import org.apache.camel.util.CastUtils;
+import org.apache.camel.util.ObjectHelper;
+import org.apache.camel.util.URISupport;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * A Consumer of messages from the Minio Storage Service.
+ */
+public class MinioConsumer extends ScheduledBatchPollingConsumer {
+
+    private static final Logger LOG = LoggerFactory.getLogger(MinioConsumer.class);
+
+    private Iterator<Result<Item>> marker;
+    private transient String minioConsumerToString;
+
+    public MinioConsumer(MinioEndpoint endpoint, Processor processor) throws NoFactoryAvailableException {
+        super(endpoint, processor);
+    }
+
+    @Override
+    protected int poll() throws Exception {
+        // must reset for each poll
+        shutdownRunningTask = null;
+        pendingExchanges = 0;
+
+        assert getConfiguration().getBucketName() != null;","[{'comment': 'Maybe you should avoid using `assert`. It is not enabled by default. It would be better to handle that with `if` condition.', 'commenter': 'DenisIstomin'}]"
3897,components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java,"@@ -0,0 +1,393 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.minio;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.security.InvalidKeyException;
+import java.security.NoSuchAlgorithmException;
+import java.util.*;
+
+import io.minio.DownloadObjectArgs;
+import io.minio.MinioClient;
+import io.minio.Result;
+import io.minio.errors.InvalidBucketNameException;
+import io.minio.errors.MinioException;
+import io.minio.messages.Bucket;
+import io.minio.messages.Item;
+import org.apache.camel.AsyncCallback;
+import org.apache.camel.Exchange;
+import org.apache.camel.ExtendedExchange;
+import org.apache.camel.NoFactoryAvailableException;
+import org.apache.camel.Processor;
+import org.apache.camel.spi.Synchronization;
+import org.apache.camel.support.ScheduledBatchPollingConsumer;
+import org.apache.camel.util.CastUtils;
+import org.apache.camel.util.ObjectHelper;
+import org.apache.camel.util.URISupport;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * A Consumer of messages from the Minio Storage Service.
+ */
+public class MinioConsumer extends ScheduledBatchPollingConsumer {
+
+    private static final Logger LOG = LoggerFactory.getLogger(MinioConsumer.class);
+
+    private Iterator<Result<Item>> marker;
+    private transient String minioConsumerToString;
+
+    public MinioConsumer(MinioEndpoint endpoint, Processor processor) throws NoFactoryAvailableException {
+        super(endpoint, processor);
+    }
+
+    @Override
+    protected int poll() throws Exception {
+        // must reset for each poll
+        shutdownRunningTask = null;
+        pendingExchanges = 0;
+
+        assert getConfiguration().getBucketName() != null;
+        String bucketName = getConfiguration().getBucketName();
+        MinioClient minioClient = getMinioClient();
+        String objectName = getConfiguration().getObjectName();
+        InputStream minioObject = null;
+        Queue<Exchange> exchanges = null;
+
+        if (bucketExists(minioClient, bucketName)) {
+            LOG.trace(""Bucket {} exists"", bucketName);
+        } else {
+            throw new InvalidBucketNameException(""Bucket {} does not exists"", bucketName);
+        }
+
+        if (objectName != null) {
+            LOG.trace(""Getting object in bucket {} with object name {}..."", bucketName, objectName);
+
+            try {
+                minioObject = getObject(bucketName, minioClient, objectName);
+                if (minioObject != null) {
+                    exchanges = createExchanges(minioObject, objectName);
+                }
+
+            } catch (Throwable e) {
+                LOG.warn(""Failed to get object in bucket {} with object name {}, Error message {}"", bucketName, objectName, e.getMessage());
+                throw e;
+
+            } finally {
+                //must be closed after use to release network resources.
+                try {
+                    assert minioObject != null;
+                    minioObject.close();","[{'comment': 'Maybe [try-with-resources](https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html) could be used here. It would be nice to reduce nesting.', 'commenter': 'DenisIstomin'}]"
3897,components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java,"@@ -0,0 +1,290 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.minio;
+
+import java.io.*;
+import java.nio.charset.Charset;
+import java.nio.charset.StandardCharsets;
+import java.util.Map;
+
+import io.minio.GetObjectTagsArgs;
+import io.minio.MakeBucketArgs;
+import io.minio.MinioClient;
+import io.minio.errors.InvalidBucketNameException;
+import io.minio.messages.Tags;
+import jdk.internal.org.jline.utils.Log;
+import org.apache.camel.Category;
+import org.apache.camel.Component;
+import org.apache.camel.Consumer;
+import org.apache.camel.Exchange;
+import org.apache.camel.ExchangePattern;
+import org.apache.camel.ExtendedExchange;
+import org.apache.camel.Message;
+import org.apache.camel.Processor;
+import org.apache.camel.Producer;
+import org.apache.camel.component.minio.client.MinioClientFactory;
+import org.apache.camel.spi.Metadata;
+import org.apache.camel.spi.UriEndpoint;
+import org.apache.camel.spi.UriParam;
+import org.apache.camel.spi.UriPath;
+import org.apache.camel.support.ScheduledPollEndpoint;
+import org.apache.camel.support.SynchronizationAdapter;
+import org.apache.camel.util.ObjectHelper;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * Store and retrie objects from Minio Storage Service using Minio SDK.","[{'comment': 'Typo: retrieve', 'commenter': 'DenisIstomin'}]"
3897,components/camel-minio/src/test/java/org/apache/camel/component/minio/MinioComponentTest.java,"@@ -0,0 +1,44 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.minio;
+
+import org.apache.camel.builder.RouteBuilder;
+import org.apache.camel.component.mock.MockEndpoint;
+import org.apache.camel.test.junit4.CamelTestSupport;
+import org.junit.Test;
+
+public class MinioComponentTest extends CamelTestSupport {
+
+    @Test
+    public void testMinio() throws Exception {
+        MockEndpoint mock = getMockEndpoint(""mock:result"");
+        mock.expectedMinimumMessageCount(1);
+
+        assertMockEndpointsSatisfied();","[{'comment': 'Looks like that test should fail, because there are no messages being sent.', 'commenter': 'DenisIstomin'}, {'comment': ""ack, I haven't look into tests yet, I'll work on these asap :)"", 'commenter': 'Nayananga'}]"
3897,components/camel-minio/pom.xml,"@@ -0,0 +1,149 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one or more
+    contributor license agreements.  See the NOTICE file distributed with
+    this work for additional information regarding copyright ownership.
+    The ASF licenses this file to You under the Apache License, Version 2.0
+    (the ""License""); you may not use this file except in compliance with
+    the License.  You may obtain a copy of the License at
+
+         http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an ""AS IS"" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+
+-->
+<project xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xmlns=""http://maven.apache.org/POM/4.0.0""
+         xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+    <modelVersion>4.0.0</modelVersion>
+
+    <parent>
+        <groupId>org.apache.camel</groupId>
+        <artifactId>components</artifactId>
+        <version>3.5.0-SNAPSHOT</version>
+    </parent>
+
+    <artifactId>camel-minio</artifactId>
+    <packaging>jar</packaging>
+
+    <name>Camel :: MinIO</name>
+    <description>A Camel MinIO cloud storage server Component</description>
+
+    <properties>
+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
+        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
+        <camel.osgi.export.pkg>org.apache.camel.component.minio.*</camel.osgi.export.pkg>
+        <camel.osgi.export.service>
+            org.apache.camel.spi.ComponentResolver;component=minio
+        </camel.osgi.export.service>
+    </properties>
+
+    <dependencies>
+        <!-- camel -->
+        <dependency>
+            <groupId>org.apache.camel</groupId>
+            <artifactId>camel-support</artifactId>
+        </dependency>
+        <dependency>
+            <groupId>io.minio</groupId>
+            <artifactId>minio</artifactId>
+            <version>7.1.0</version>","[{'comment': 'This should go as property in parent pom', 'commenter': 'oscerd'}, {'comment': '@oscerd Thank you for the suggestion. Would you mind telling me where exactly this property should go? is it pom.xml in component root directory?', 'commenter': 'Nayananga'}, {'comment': 'It should go in parent/pom.xml', 'commenter': 'oscerd'}]"
3897,components/camel-minio/pom.xml,"@@ -0,0 +1,149 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one or more
+    contributor license agreements.  See the NOTICE file distributed with
+    this work for additional information regarding copyright ownership.
+    The ASF licenses this file to You under the Apache License, Version 2.0
+    (the ""License""); you may not use this file except in compliance with
+    the License.  You may obtain a copy of the License at
+
+         http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an ""AS IS"" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+
+-->
+<project xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xmlns=""http://maven.apache.org/POM/4.0.0""
+         xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+    <modelVersion>4.0.0</modelVersion>
+
+    <parent>
+        <groupId>org.apache.camel</groupId>
+        <artifactId>components</artifactId>
+        <version>3.5.0-SNAPSHOT</version>
+    </parent>
+
+    <artifactId>camel-minio</artifactId>
+    <packaging>jar</packaging>
+
+    <name>Camel :: MinIO</name>
+    <description>A Camel MinIO cloud storage server Component</description>
+
+    <properties>
+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
+        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
+        <camel.osgi.export.pkg>org.apache.camel.component.minio.*</camel.osgi.export.pkg>
+        <camel.osgi.export.service>
+            org.apache.camel.spi.ComponentResolver;component=minio
+        </camel.osgi.export.service>
+    </properties>
+
+    <dependencies>
+        <!-- camel -->
+        <dependency>
+            <groupId>org.apache.camel</groupId>
+            <artifactId>camel-support</artifactId>
+        </dependency>
+        <dependency>
+            <groupId>io.minio</groupId>
+            <artifactId>minio</artifactId>
+            <version>7.1.0</version>
+        </dependency>
+
+        <!-- logging -->
+        <dependency>
+            <groupId>org.apache.logging.log4j</groupId>
+            <artifactId>log4j-api</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.apache.logging.log4j</groupId>
+            <artifactId>log4j-core</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.apache.logging.log4j</groupId>
+            <artifactId>log4j-slf4j-impl</artifactId>
+            <scope>test</scope>
+        </dependency>
+
+        <!-- testing -->
+        <dependency>
+            <groupId>org.apache.camel</groupId>
+            <artifactId>camel-test</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.apache.camel</groupId>","[{'comment': ""I don't think aws2-s3 is needed"", 'commenter': 'oscerd'}]"
3897,components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java,"@@ -0,0 +1,641 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.minio;
+
+import java.time.ZonedDateTime;
+
+import io.minio.MinioClient;
+import io.minio.ServerSideEncryption;
+import io.minio.ServerSideEncryptionCustomerKey;
+import okhttp3.OkHttpClient;
+import org.apache.camel.RuntimeCamelException;
+import org.apache.camel.spi.UriParam;
+import org.apache.camel.spi.UriParams;
+
+@UriParams
+public class MinioConfiguration implements Cloneable {
+
+    @UriParam
+    private String endpoint;
+    @UriParam
+    private Integer proxyPort;
+
+    @UriParam(label = ""security"", secret = true)
+    private String accessKey;
+    @UriParam(label = ""security"", secret = true)
+    private String secretKey;
+    @UriParam(defaultValue = ""false"")
+    private boolean secure;
+
+    @UriParam","[{'comment': 'labels are missing here, for example `producer`, `consumer`, `common` ..etc', 'commenter': 'omarsmak'}]"
3897,components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java,"@@ -0,0 +1,381 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.minio;
+
+import java.io.InputStream;
+import java.util.*;","[{'comment': 'Please avoid wildcard import', 'commenter': 'omarsmak'}]"
3897,components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java,"@@ -0,0 +1,381 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.minio;
+
+import java.io.InputStream;
+import java.util.*;
+
+import io.minio.CopyObjectArgs;
+import io.minio.CopySource;
+import io.minio.GetObjectArgs;
+import io.minio.ListObjectsArgs;
+import io.minio.MinioClient;
+import io.minio.RemoveObjectArgs;
+import io.minio.errors.MinioException;
+import io.minio.messages.Contents;
+import io.minio.messages.ListBucketResultV2;
+import org.apache.camel.Exchange;
+import org.apache.camel.ExtendedExchange;
+import org.apache.camel.Processor;
+import org.apache.camel.spi.Synchronization;
+import org.apache.camel.support.ScheduledBatchPollingConsumer;
+import org.apache.camel.util.CastUtils;
+import org.apache.camel.util.IOHelper;
+import org.apache.camel.util.ObjectHelper;
+import org.apache.camel.util.URISupport;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * A Consumer of messages from the Minio Storage Service.
+ */
+public class MinioConsumer extends ScheduledBatchPollingConsumer {
+
+    private static final Logger LOG = LoggerFactory.getLogger(MinioConsumer.class);
+
+    private String continuationToken;
+    private transient String minioConsumerToString;
+
+    public MinioConsumer(MinioEndpoint endpoint, Processor processor) {
+        super(endpoint, processor);
+    }
+
+    @Override
+    protected int poll() throws Exception {
+        // must reset for each poll
+        shutdownRunningTask = null;
+        pendingExchanges = 0;
+
+        String bucketName = getConfiguration().getBucketName();
+        String objectName = getConfiguration().getObjectName();
+        MinioClient minioClient = getMinioClient();
+        Queue<Exchange> exchanges;
+
+        if (objectName != null) {
+            LOG.trace(""Getting object in bucket {} with object name {}..."", bucketName, objectName);
+
+            InputStream minioObject = getObject(bucketName, minioClient, objectName);
+            exchanges = createExchanges(minioObject, objectName);
+
+        } else {
+
+            LOG.trace(""Queueing objects in bucket [{}]..."", bucketName);
+
+            ListObjectsArgs.Builder listObjectRequest = ListObjectsArgs.builder()
+                    .bucket(bucketName)
+                    .includeUserMetadata(getConfiguration().isIncludeUserMetadata())
+                    .includeVersions(getConfiguration().isIncludeVersions())
+                    .recursive(getConfiguration().isRecursive())
+                    .useApiVersion1(getConfiguration().isUseVersion1());
+
+            if (getConfiguration().getDelimiter() != null) {
+                listObjectRequest.delimiter(getConfiguration().getDelimiter());
+            }
+
+            if (maxMessagesPerPoll > 0) {
+                listObjectRequest.maxKeys(maxMessagesPerPoll);
+            }
+
+            if (getConfiguration().getPrefix() != null) {
+                listObjectRequest.prefix(getConfiguration().getPrefix());
+            }
+
+            if (getConfiguration().getStartAfter() != null) {
+                listObjectRequest.startAfter(getConfiguration().getStartAfter());
+            }
+
+            // if there was a marker from previous poll then use that to
+            // continue from where we left last time
+            if (continuationToken != null) {
+                LOG.trace(""Resuming from marker: {}"", continuationToken);
+                listObjectRequest.continuationToken(continuationToken);
+            }
+
+            // TODO: Check for validity of the statement
+            ListBucketResultV2 listObjects = (ListBucketResultV2) getMinioClient().listObjects(listObjectRequest.build());
+
+            if (listObjects.isTruncated()) {
+                LOG.trace(""Returned list is truncated, so setting next marker: {}"", continuationToken);
+                continuationToken = listObjects.nextContinuationToken();
+
+            } else {
+                // no more data so clear marker
+                continuationToken = null;
+            }
+            if (LOG.isTraceEnabled()) {
+                LOG.trace(""Found {} objects in bucket [{}]..."", listObjects.contents().size(), bucketName);
+            }
+
+            exchanges = createExchanges(listObjects.contents());
+        }
+        return processBatch(CastUtils.cast(exchanges));
+    }
+
+    protected Queue<Exchange> createExchanges(InputStream objectStream, String objectName) throws Exception {
+        Queue<Exchange> answer = new LinkedList<>();
+        Exchange exchange = getEndpoint().createExchange(objectStream, objectName);
+        answer.add(exchange);
+        IOHelper.close(objectStream);
+        return answer;
+    }
+
+    protected Queue<Exchange> createExchanges(List<Contents> minioObjectSummaries) throws Exception {
+        if (LOG.isTraceEnabled()) {
+            LOG.trace(""Received {} messages in this poll"", minioObjectSummaries.size());
+        }
+        String bucketName = getConfiguration().getBucketName();
+        Collection<InputStream> minioObjects = new ArrayList<>();
+        Queue<Exchange> answer = new LinkedList<>();
+        try {
+            if (getConfiguration().isIncludeFolders()) {
+                for (Contents minioObjectSummary : minioObjectSummaries) {
+                    InputStream minioObject = getObject(bucketName, getMinioClient(), minioObjectSummary.objectName());
+                    minioObjects.add(minioObject);
+                    Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.objectName());
+                    answer.add(exchange);
+                }
+            } else {
+                for (Contents minioObjectSummary : minioObjectSummaries) {
+                    // ignore if directory
+                    if (!minioObjectSummary.isDir()) {
+                        InputStream minioObject = getObject(bucketName, getMinioClient(), minioObjectSummary.objectName());
+                        minioObjects.add(minioObject);
+                        Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.objectName());
+                        answer.add(exchange);
+                    }
+                }
+            }
+
+        } catch (Throwable e) {
+            LOG.warn(""Error getting MinioObject due: {}"", e.getMessage());
+            throw e;
+
+        } finally {
+            // ensure all previous gathered minio objects are closed
+            // if there was an exception creating the exchanges in this batch
+            minioObjects.forEach(IOHelper::close);
+        }
+
+        return answer;
+    }
+
+    private InputStream getObject(String bucketName, MinioClient minioClient, String objectName) throws Exception {
+        GetObjectArgs.Builder getObjectRequest = GetObjectArgs.builder().bucket(bucketName).object(objectName);
+
+        if (getConfiguration().getServerSideEncryptionCustomerKey() != null) {
+            getObjectRequest.ssec(getConfiguration().getServerSideEncryptionCustomerKey());
+        }
+        if (getConfiguration().getOffset() != 0) {
+            getObjectRequest.offset(getConfiguration().getOffset());
+        }
+        if (getConfiguration().getLength() != 0) {
+            getObjectRequest.length(getConfiguration().getLength());
+        }
+        if (getConfiguration().getVersionId() != null) {
+            getObjectRequest.versionId(getConfiguration().getVersionId());
+        }
+        if (getConfiguration().getMatchETag() != null) {
+            getObjectRequest.matchETag(getConfiguration().getMatchETag());
+        }
+        if (getConfiguration().getNotMatchETag() != null) {
+            getObjectRequest.notMatchETag(getConfiguration().getNotMatchETag());
+        }
+        if (getConfiguration().getModifiedSince() != null) {
+            getObjectRequest.modifiedSince(getConfiguration().getModifiedSince());
+        }
+        if (getConfiguration().getUnModifiedSince() != null) {
+            getObjectRequest.unmodifiedSince(getConfiguration().getUnModifiedSince());
+        }
+
+        return minioClient.getObject(getObjectRequest.build());
+    }
+
+    @Override
+    public int processBatch(Queue<Object> exchanges) {
+        int total = exchanges.size();
+
+        for (int index = 0; index < total && isBatchAllowed(); index++) {
+            // only loop if we are started (allowed to run)
+            final Exchange exchange = ObjectHelper.cast(Exchange.class, exchanges.poll());
+            // add current index and total as properties
+            exchange.setProperty(Exchange.BATCH_INDEX, index);
+            exchange.setProperty(Exchange.BATCH_SIZE, total);
+            exchange.setProperty(Exchange.BATCH_COMPLETE, index == total - 1);
+
+            // update pending number of exchanges
+            pendingExchanges = total - index - 1;
+
+            // add on completion to handle after work when the exchange is done
+            exchange.adapt(ExtendedExchange.class).addOnCompletion(new Synchronization() {
+                public void onComplete(Exchange exchange) {
+                    processCommit(exchange);
+                }
+
+                public void onFailure(Exchange exchange) {
+                    processRollback(exchange);
+                }
+
+                @Override
+                public String toString() {
+                    return ""MinioConsumerOnCompletion"";
+                }
+            });
+
+            LOG.trace(""Processing exchange ..."");
+            getAsyncProcessor().process(exchange, doneSync -> LOG.trace(""Processing exchange done.""));
+        }
+
+        return total;
+    }
+
+    /**
+     * Strategy to delete the message after being processed.
+     *
+     * @param exchange the exchange
+     */
+    protected void processCommit(Exchange exchange) {
+        try {
+            String srcBucketName = exchange.getIn().getHeader(MinioConstants.BUCKET_NAME, String.class);
+            String srcObjectName = exchange.getIn().getHeader(MinioConstants.OBJECT_NAME, String.class);
+
+            if (getConfiguration().isDeleteAfterRead() || getConfiguration().isMoveAfterRead()) {
+                if (getConfiguration().isMoveAfterRead()) {
+                    copyObject(srcBucketName, srcObjectName);
+                    LOG.trace(""Copied object from bucket {} with objectName {} to bucket {}..."",
+                            srcBucketName, srcObjectName, getConfiguration().getDestinationBucketName());
+                }
+
+                LOG.trace(""Deleting object from bucket {} with objectName {}..."", srcBucketName, srcObjectName);
+
+                RemoveObjectArgs.Builder removeObjectRequest = RemoveObjectArgs.builder()
+                        .bucket(srcBucketName)
+                        .object(srcObjectName)
+                        .bypassGovernanceMode(getConfiguration().isBypassGovernanceMode());
+
+                if (getConfiguration().getVersionId() != null) {
+                    removeObjectRequest.versionId(getConfiguration().getVersionId());
+                }
+                if (getConfiguration().isBypassGovernanceMode()) {
+                    removeObjectRequest.versionId(getConfiguration().getVersionId());
+                }
+                getMinioClient().removeObject(removeObjectRequest.build());
+
+                LOG.trace(""Deleted object from bucket {} with objectName {}..."", srcBucketName, srcObjectName);
+            }
+        } catch (MinioException e) {
+            getExceptionHandler().handleException(""Error occurred during moving or deleting object. This exception is ignored."",
+                    exchange, e);
+        } catch (Exception e) {
+            LOG.trace(""Error process commit..."");","[{'comment': 'Should we handle this exception as well?', 'commenter': 'omarsmak'}]"
3897,components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java,"@@ -0,0 +1,381 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.minio;
+
+import java.io.InputStream;
+import java.util.*;
+
+import io.minio.CopyObjectArgs;
+import io.minio.CopySource;
+import io.minio.GetObjectArgs;
+import io.minio.ListObjectsArgs;
+import io.minio.MinioClient;
+import io.minio.RemoveObjectArgs;
+import io.minio.errors.MinioException;
+import io.minio.messages.Contents;
+import io.minio.messages.ListBucketResultV2;
+import org.apache.camel.Exchange;
+import org.apache.camel.ExtendedExchange;
+import org.apache.camel.Processor;
+import org.apache.camel.spi.Synchronization;
+import org.apache.camel.support.ScheduledBatchPollingConsumer;
+import org.apache.camel.util.CastUtils;
+import org.apache.camel.util.IOHelper;
+import org.apache.camel.util.ObjectHelper;
+import org.apache.camel.util.URISupport;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * A Consumer of messages from the Minio Storage Service.
+ */
+public class MinioConsumer extends ScheduledBatchPollingConsumer {
+
+    private static final Logger LOG = LoggerFactory.getLogger(MinioConsumer.class);
+
+    private String continuationToken;
+    private transient String minioConsumerToString;
+
+    public MinioConsumer(MinioEndpoint endpoint, Processor processor) {
+        super(endpoint, processor);
+    }
+
+    @Override
+    protected int poll() throws Exception {
+        // must reset for each poll
+        shutdownRunningTask = null;
+        pendingExchanges = 0;
+
+        String bucketName = getConfiguration().getBucketName();
+        String objectName = getConfiguration().getObjectName();
+        MinioClient minioClient = getMinioClient();
+        Queue<Exchange> exchanges;
+
+        if (objectName != null) {
+            LOG.trace(""Getting object in bucket {} with object name {}..."", bucketName, objectName);
+
+            InputStream minioObject = getObject(bucketName, minioClient, objectName);
+            exchanges = createExchanges(minioObject, objectName);
+
+        } else {
+
+            LOG.trace(""Queueing objects in bucket [{}]..."", bucketName);
+
+            ListObjectsArgs.Builder listObjectRequest = ListObjectsArgs.builder()
+                    .bucket(bucketName)
+                    .includeUserMetadata(getConfiguration().isIncludeUserMetadata())
+                    .includeVersions(getConfiguration().isIncludeVersions())
+                    .recursive(getConfiguration().isRecursive())
+                    .useApiVersion1(getConfiguration().isUseVersion1());
+
+            if (getConfiguration().getDelimiter() != null) {
+                listObjectRequest.delimiter(getConfiguration().getDelimiter());
+            }
+
+            if (maxMessagesPerPoll > 0) {
+                listObjectRequest.maxKeys(maxMessagesPerPoll);
+            }
+
+            if (getConfiguration().getPrefix() != null) {
+                listObjectRequest.prefix(getConfiguration().getPrefix());
+            }
+
+            if (getConfiguration().getStartAfter() != null) {
+                listObjectRequest.startAfter(getConfiguration().getStartAfter());
+            }
+
+            // if there was a marker from previous poll then use that to
+            // continue from where we left last time
+            if (continuationToken != null) {
+                LOG.trace(""Resuming from marker: {}"", continuationToken);
+                listObjectRequest.continuationToken(continuationToken);
+            }
+
+            // TODO: Check for validity of the statement
+            ListBucketResultV2 listObjects = (ListBucketResultV2) getMinioClient().listObjects(listObjectRequest.build());
+
+            if (listObjects.isTruncated()) {
+                LOG.trace(""Returned list is truncated, so setting next marker: {}"", continuationToken);
+                continuationToken = listObjects.nextContinuationToken();
+
+            } else {
+                // no more data so clear marker
+                continuationToken = null;
+            }
+            if (LOG.isTraceEnabled()) {
+                LOG.trace(""Found {} objects in bucket [{}]..."", listObjects.contents().size(), bucketName);
+            }
+
+            exchanges = createExchanges(listObjects.contents());
+        }
+        return processBatch(CastUtils.cast(exchanges));
+    }
+
+    protected Queue<Exchange> createExchanges(InputStream objectStream, String objectName) throws Exception {
+        Queue<Exchange> answer = new LinkedList<>();
+        Exchange exchange = getEndpoint().createExchange(objectStream, objectName);
+        answer.add(exchange);
+        IOHelper.close(objectStream);
+        return answer;
+    }
+
+    protected Queue<Exchange> createExchanges(List<Contents> minioObjectSummaries) throws Exception {
+        if (LOG.isTraceEnabled()) {
+            LOG.trace(""Received {} messages in this poll"", minioObjectSummaries.size());
+        }
+        String bucketName = getConfiguration().getBucketName();
+        Collection<InputStream> minioObjects = new ArrayList<>();
+        Queue<Exchange> answer = new LinkedList<>();
+        try {
+            if (getConfiguration().isIncludeFolders()) {
+                for (Contents minioObjectSummary : minioObjectSummaries) {
+                    InputStream minioObject = getObject(bucketName, getMinioClient(), minioObjectSummary.objectName());
+                    minioObjects.add(minioObject);
+                    Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.objectName());
+                    answer.add(exchange);
+                }
+            } else {
+                for (Contents minioObjectSummary : minioObjectSummaries) {
+                    // ignore if directory
+                    if (!minioObjectSummary.isDir()) {
+                        InputStream minioObject = getObject(bucketName, getMinioClient(), minioObjectSummary.objectName());
+                        minioObjects.add(minioObject);
+                        Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.objectName());
+                        answer.add(exchange);
+                    }
+                }
+            }
+
+        } catch (Throwable e) {
+            LOG.warn(""Error getting MinioObject due: {}"", e.getMessage());
+            throw e;
+
+        } finally {
+            // ensure all previous gathered minio objects are closed
+            // if there was an exception creating the exchanges in this batch
+            minioObjects.forEach(IOHelper::close);
+        }
+
+        return answer;
+    }
+
+    private InputStream getObject(String bucketName, MinioClient minioClient, String objectName) throws Exception {
+        GetObjectArgs.Builder getObjectRequest = GetObjectArgs.builder().bucket(bucketName).object(objectName);
+
+        if (getConfiguration().getServerSideEncryptionCustomerKey() != null) {
+            getObjectRequest.ssec(getConfiguration().getServerSideEncryptionCustomerKey());
+        }
+        if (getConfiguration().getOffset() != 0) {
+            getObjectRequest.offset(getConfiguration().getOffset());
+        }
+        if (getConfiguration().getLength() != 0) {
+            getObjectRequest.length(getConfiguration().getLength());
+        }
+        if (getConfiguration().getVersionId() != null) {
+            getObjectRequest.versionId(getConfiguration().getVersionId());
+        }
+        if (getConfiguration().getMatchETag() != null) {
+            getObjectRequest.matchETag(getConfiguration().getMatchETag());
+        }
+        if (getConfiguration().getNotMatchETag() != null) {
+            getObjectRequest.notMatchETag(getConfiguration().getNotMatchETag());
+        }
+        if (getConfiguration().getModifiedSince() != null) {
+            getObjectRequest.modifiedSince(getConfiguration().getModifiedSince());
+        }
+        if (getConfiguration().getUnModifiedSince() != null) {
+            getObjectRequest.unmodifiedSince(getConfiguration().getUnModifiedSince());
+        }
+
+        return minioClient.getObject(getObjectRequest.build());
+    }
+
+    @Override
+    public int processBatch(Queue<Object> exchanges) {
+        int total = exchanges.size();
+
+        for (int index = 0; index < total && isBatchAllowed(); index++) {
+            // only loop if we are started (allowed to run)
+            final Exchange exchange = ObjectHelper.cast(Exchange.class, exchanges.poll());
+            // add current index and total as properties
+            exchange.setProperty(Exchange.BATCH_INDEX, index);
+            exchange.setProperty(Exchange.BATCH_SIZE, total);
+            exchange.setProperty(Exchange.BATCH_COMPLETE, index == total - 1);
+
+            // update pending number of exchanges
+            pendingExchanges = total - index - 1;
+
+            // add on completion to handle after work when the exchange is done
+            exchange.adapt(ExtendedExchange.class).addOnCompletion(new Synchronization() {
+                public void onComplete(Exchange exchange) {
+                    processCommit(exchange);
+                }
+
+                public void onFailure(Exchange exchange) {
+                    processRollback(exchange);
+                }
+
+                @Override
+                public String toString() {
+                    return ""MinioConsumerOnCompletion"";
+                }
+            });
+
+            LOG.trace(""Processing exchange ..."");
+            getAsyncProcessor().process(exchange, doneSync -> LOG.trace(""Processing exchange done.""));
+        }
+
+        return total;
+    }
+
+    /**
+     * Strategy to delete the message after being processed.
+     *
+     * @param exchange the exchange
+     */
+    protected void processCommit(Exchange exchange) {
+        try {
+            String srcBucketName = exchange.getIn().getHeader(MinioConstants.BUCKET_NAME, String.class);
+            String srcObjectName = exchange.getIn().getHeader(MinioConstants.OBJECT_NAME, String.class);
+
+            if (getConfiguration().isDeleteAfterRead() || getConfiguration().isMoveAfterRead()) {
+                if (getConfiguration().isMoveAfterRead()) {
+                    copyObject(srcBucketName, srcObjectName);
+                    LOG.trace(""Copied object from bucket {} with objectName {} to bucket {}..."",
+                            srcBucketName, srcObjectName, getConfiguration().getDestinationBucketName());
+                }
+
+                LOG.trace(""Deleting object from bucket {} with objectName {}..."", srcBucketName, srcObjectName);
+
+                RemoveObjectArgs.Builder removeObjectRequest = RemoveObjectArgs.builder()
+                        .bucket(srcBucketName)
+                        .object(srcObjectName)
+                        .bypassGovernanceMode(getConfiguration().isBypassGovernanceMode());
+
+                if (getConfiguration().getVersionId() != null) {
+                    removeObjectRequest.versionId(getConfiguration().getVersionId());
+                }
+                if (getConfiguration().isBypassGovernanceMode()) {
+                    removeObjectRequest.versionId(getConfiguration().getVersionId());
+                }
+                getMinioClient().removeObject(removeObjectRequest.build());
+
+                LOG.trace(""Deleted object from bucket {} with objectName {}..."", srcBucketName, srcObjectName);
+            }
+        } catch (MinioException e) {
+            getExceptionHandler().handleException(""Error occurred during moving or deleting object. This exception is ignored."",
+                    exchange, e);
+        } catch (Exception e) {
+            LOG.trace(""Error process commit..."");
+        }
+    }
+
+    private void copyObject(String srcBucketName, String srcObjectName) {
+        String destinationBucketName = getConfiguration().getDestinationBucketName();
+        if (destinationBucketName == null) {
+            throw new IllegalArgumentException(""Destination Bucket name must be specified to copy operation"");
+        }
+
+        try {
+            // set destination object name as source object name, if not specified
+            String destinationObjectName = (getConfiguration().getDestinationObjectName() != null)
+                    ? getConfiguration().getDestinationObjectName()
+                    : srcObjectName;
+
+
+            LOG.trace(""Copying object from bucket {} with objectName {} to bucket {}..."",
+                    srcBucketName, srcObjectName, destinationBucketName);
+
+            CopySource.Builder copySourceBuilder = CopySource.builder().bucket(srcBucketName).object(srcObjectName);
+            if (getConfiguration().getServerSideEncryptionCustomerKey() != null) {
+                copySourceBuilder.ssec(getConfiguration().getServerSideEncryptionCustomerKey());
+            }
+            if (getConfiguration().getOffset() != 0) {
+                copySourceBuilder.offset(getConfiguration().getOffset());
+            }
+            if (getConfiguration().getLength() != 0) {
+                copySourceBuilder.length(getConfiguration().getLength());
+            }
+            if (getConfiguration().getVersionId() != null) {
+                copySourceBuilder.versionId(getConfiguration().getVersionId());
+            }
+            if (getConfiguration().getMatchETag() != null) {
+                copySourceBuilder.matchETag(getConfiguration().getMatchETag());
+            }
+            if (getConfiguration().getNotMatchETag() != null) {
+                copySourceBuilder.notMatchETag(getConfiguration().getNotMatchETag());
+            }
+            if (getConfiguration().getModifiedSince() != null) {
+                copySourceBuilder.modifiedSince(getConfiguration().getModifiedSince());
+            }
+            if (getConfiguration().getUnModifiedSince() != null) {
+                copySourceBuilder.unmodifiedSince(getConfiguration().getUnModifiedSince());
+            }
+
+            CopyObjectArgs.Builder copyObjectRequest = CopyObjectArgs.builder()
+                    .source(copySourceBuilder.build())
+                    .bucket(getConfiguration().getDestinationBucketName())
+                    .object(destinationObjectName);
+
+            if (getConfiguration().getServerSideEncryption() != null) {
+                copyObjectRequest.sse(getConfiguration().getServerSideEncryption());
+            }
+
+            getMinioClient().copyObject(copyObjectRequest.build());
+
+        } catch (Exception e) {
+            LOG.warn(""Error copy object from bucket {} with objectName {} to bucket {}..."",","[{'comment': 'Same here, should handle this exception as well?', 'commenter': 'omarsmak'}]"
3897,components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java,"@@ -0,0 +1,381 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.minio;
+
+import java.io.InputStream;
+import java.util.*;
+
+import io.minio.CopyObjectArgs;
+import io.minio.CopySource;
+import io.minio.GetObjectArgs;
+import io.minio.ListObjectsArgs;
+import io.minio.MinioClient;
+import io.minio.RemoveObjectArgs;
+import io.minio.errors.MinioException;
+import io.minio.messages.Contents;
+import io.minio.messages.ListBucketResultV2;
+import org.apache.camel.Exchange;
+import org.apache.camel.ExtendedExchange;
+import org.apache.camel.Processor;
+import org.apache.camel.spi.Synchronization;
+import org.apache.camel.support.ScheduledBatchPollingConsumer;
+import org.apache.camel.util.CastUtils;
+import org.apache.camel.util.IOHelper;
+import org.apache.camel.util.ObjectHelper;
+import org.apache.camel.util.URISupport;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * A Consumer of messages from the Minio Storage Service.
+ */
+public class MinioConsumer extends ScheduledBatchPollingConsumer {
+
+    private static final Logger LOG = LoggerFactory.getLogger(MinioConsumer.class);
+
+    private String continuationToken;
+    private transient String minioConsumerToString;
+
+    public MinioConsumer(MinioEndpoint endpoint, Processor processor) {
+        super(endpoint, processor);
+    }
+
+    @Override
+    protected int poll() throws Exception {
+        // must reset for each poll
+        shutdownRunningTask = null;
+        pendingExchanges = 0;
+
+        String bucketName = getConfiguration().getBucketName();
+        String objectName = getConfiguration().getObjectName();
+        MinioClient minioClient = getMinioClient();
+        Queue<Exchange> exchanges;
+
+        if (objectName != null) {
+            LOG.trace(""Getting object in bucket {} with object name {}..."", bucketName, objectName);
+
+            InputStream minioObject = getObject(bucketName, minioClient, objectName);
+            exchanges = createExchanges(minioObject, objectName);
+
+        } else {
+
+            LOG.trace(""Queueing objects in bucket [{}]..."", bucketName);
+
+            ListObjectsArgs.Builder listObjectRequest = ListObjectsArgs.builder()
+                    .bucket(bucketName)
+                    .includeUserMetadata(getConfiguration().isIncludeUserMetadata())
+                    .includeVersions(getConfiguration().isIncludeVersions())
+                    .recursive(getConfiguration().isRecursive())
+                    .useApiVersion1(getConfiguration().isUseVersion1());
+
+            if (getConfiguration().getDelimiter() != null) {
+                listObjectRequest.delimiter(getConfiguration().getDelimiter());
+            }
+
+            if (maxMessagesPerPoll > 0) {
+                listObjectRequest.maxKeys(maxMessagesPerPoll);
+            }
+
+            if (getConfiguration().getPrefix() != null) {
+                listObjectRequest.prefix(getConfiguration().getPrefix());
+            }
+
+            if (getConfiguration().getStartAfter() != null) {
+                listObjectRequest.startAfter(getConfiguration().getStartAfter());
+            }
+
+            // if there was a marker from previous poll then use that to
+            // continue from where we left last time
+            if (continuationToken != null) {
+                LOG.trace(""Resuming from marker: {}"", continuationToken);
+                listObjectRequest.continuationToken(continuationToken);
+            }
+
+            // TODO: Check for validity of the statement
+            ListBucketResultV2 listObjects = (ListBucketResultV2) getMinioClient().listObjects(listObjectRequest.build());
+
+            if (listObjects.isTruncated()) {
+                LOG.trace(""Returned list is truncated, so setting next marker: {}"", continuationToken);
+                continuationToken = listObjects.nextContinuationToken();
+
+            } else {
+                // no more data so clear marker
+                continuationToken = null;
+            }
+            if (LOG.isTraceEnabled()) {
+                LOG.trace(""Found {} objects in bucket [{}]..."", listObjects.contents().size(), bucketName);
+            }
+
+            exchanges = createExchanges(listObjects.contents());
+        }
+        return processBatch(CastUtils.cast(exchanges));
+    }
+
+    protected Queue<Exchange> createExchanges(InputStream objectStream, String objectName) throws Exception {
+        Queue<Exchange> answer = new LinkedList<>();
+        Exchange exchange = getEndpoint().createExchange(objectStream, objectName);
+        answer.add(exchange);
+        IOHelper.close(objectStream);
+        return answer;
+    }
+
+    protected Queue<Exchange> createExchanges(List<Contents> minioObjectSummaries) throws Exception {
+        if (LOG.isTraceEnabled()) {
+            LOG.trace(""Received {} messages in this poll"", minioObjectSummaries.size());
+        }
+        String bucketName = getConfiguration().getBucketName();
+        Collection<InputStream> minioObjects = new ArrayList<>();
+        Queue<Exchange> answer = new LinkedList<>();
+        try {
+            if (getConfiguration().isIncludeFolders()) {
+                for (Contents minioObjectSummary : minioObjectSummaries) {
+                    InputStream minioObject = getObject(bucketName, getMinioClient(), minioObjectSummary.objectName());
+                    minioObjects.add(minioObject);
+                    Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.objectName());
+                    answer.add(exchange);
+                }
+            } else {
+                for (Contents minioObjectSummary : minioObjectSummaries) {
+                    // ignore if directory
+                    if (!minioObjectSummary.isDir()) {
+                        InputStream minioObject = getObject(bucketName, getMinioClient(), minioObjectSummary.objectName());
+                        minioObjects.add(minioObject);
+                        Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.objectName());
+                        answer.add(exchange);
+                    }
+                }
+            }
+
+        } catch (Throwable e) {
+            LOG.warn(""Error getting MinioObject due: {}"", e.getMessage());
+            throw e;
+
+        } finally {
+            // ensure all previous gathered minio objects are closed
+            // if there was an exception creating the exchanges in this batch
+            minioObjects.forEach(IOHelper::close);
+        }
+
+        return answer;
+    }
+
+    private InputStream getObject(String bucketName, MinioClient minioClient, String objectName) throws Exception {
+        GetObjectArgs.Builder getObjectRequest = GetObjectArgs.builder().bucket(bucketName).object(objectName);
+
+        if (getConfiguration().getServerSideEncryptionCustomerKey() != null) {
+            getObjectRequest.ssec(getConfiguration().getServerSideEncryptionCustomerKey());
+        }
+        if (getConfiguration().getOffset() != 0) {","[{'comment': ""I am bit not comfortable of having check with not equal 0, odd cases like minus could slip. I'd recommend changing this to `> 0` instead. Same for the other checks"", 'commenter': 'omarsmak'}]"
3903,components/camel-rabbitmq/src/main/docs/rabbitmq-component.adoc,"@@ -134,7 +135,7 @@ with the following path and query parameters:
 [width=""100%"",cols=""2,5,^1,2"",options=""header""]
 |===
 | Name | Description | Default | Type
-| *exchangeName* | *Required* The exchange name determines which exchange produced messages will sent to. In the case of consumers, the exchange name determines which exchange the queue will bind to. |  | String
+| *exchangeName* | *Required* The exchange name determines the exchange to which the produced messages will be sent to. In the case of consumers, the exchange name determines the exchange the queue will be bound to. |  | String","[{'comment': 'This needs to be changed at Javadoc level, otherwise it will be override during the next build and re-generated.', 'commenter': 'oscerd'}]"
3912,docs/package.json,"@@ -14,5 +18,14 @@
     ""gulp-sort"": ""^2.0.0"",
     ""map-stream"": ""^0.0.7"",
     ""through2"": ""^3.0.1""
+  },
+  ""dependencies"": {
+    ""eslint"": ""^7.2.0"",
+    ""eslint-config-standard"": ""^14.1.1"",
+    ""eslint-plugin-import"": ""^2.21.2"",
+    ""eslint-plugin-node"": ""^11.1.0"",
+    ""eslint-plugin-promise"": ""^4.2.1"",
+    ""eslint-plugin-standard"": ""^4.0.1"",
+    ""prettier-eslint-cli"": ""^5.0.0""","[{'comment': 'Nitpick: this should go to devDependencies', 'commenter': 'zregvart'}]"
3912,docs/gulpfile.js,"@@ -14,343 +14,427 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-const { dest, series, parallel, src, symlink } = require('gulp');
-const del = require('del');
-const filter = require('gulp-filter');
-const inject = require('gulp-inject');
+/* eslint-disable-next-line no-unused-vars */
+const { dest, series, parallel, src, symlink } = require('gulp')
+const del = require('del')
+const filter = require('gulp-filter')
+const inject = require('gulp-inject')
 const map = require('map-stream')
-const path = require('path');
-const rename = require('gulp-rename');
-const replace = require('gulp-replace');
-const sort = require('gulp-sort');
-const through2 = require('through2');
+const path = require('path')
+const rename = require('gulp-rename')
+const replace = require('gulp-replace')
+const sort = require('gulp-sort')
+const through2 = require('through2')
 const File = require('vinyl')
-const fs = require('fs');
+const fs = require('fs')
 
-function deleteComponentSymlinks() {
-    return del(['components/modules/ROOT/pages/*', '!components/modules/ROOT/pages/index.adoc']);
+function deleteComponentSymlinks () {
+  return del(['components/modules/ROOT/pages/*', '!components/modules/ROOT/pages/index.adoc'])
 }
 
-function deleteComponentImageSymlinks() {
-    return del(['components/modules/ROOT/assets/images/*']);
+function deleteComponentImageSymlinks () {
+  return del(['components/modules/ROOT/assets/images/*'])
 }
 
-function createComponentSymlinks() {
-    return src(['../core/camel-base/src/main/docs/*-component.adoc', '../components/{*,*/*}/src/main/docs/*-component.adoc', '../components/{*,*/*}/src/main/docs/*-summary.adoc'])
-        .pipe(map((file, done) => {
-            // this flattens the output to just .../pages/....adoc
-            // instead of .../pages/camel-.../src/main/docs/....adoc
-            file.base = path.dirname(file.path);
-            done(null, file);
-        }))
-        // Antora disabled symlinks, there is an issue open
-        // https://gitlab.com/antora/antora/issues/188
-        // to reinstate symlink support, until that's resolved
-        // we'll simply copy over instead of creating symlinks
-        // .pipe(symlink('components/modules/ROOT/pages/', {
-        //     relativeSymlinks: true
-        // }));
-        // uncomment above .pipe() and remove the .pipe() below
-        // when antora#188 is resolved
-        .pipe(insertSourceAttribute())
-        .pipe(dest('components/modules/ROOT/pages/'));
+function createComponentSymlinks () {
+  return (
+    src([
+      '../core/camel-base/src/main/docs/*-component.adoc',
+      '../components/{*,*/*}/src/main/docs/*-component.adoc',
+      '../components/{*,*/*}/src/main/docs/*-summary.adoc',
+    ])
+      .pipe(
+        map((file, done) => {
+          // this flattens the output to just .../pages/....adoc
+          // instead of .../pages/camel-.../src/main/docs/....adoc
+          file.base = path.dirname(file.path)
+          done(null, file)
+        })
+      )
+      // Antora disabled symlinks, there is an issue open
+      // https://gitlab.com/antora/antora/issues/188
+      // to reinstate symlink support, until that's resolved
+      // we'll simply copy over instead of creating symlinks
+      // .pipe(symlink('components/modules/ROOT/pages/', {
+      //     relativeSymlinks: true
+      // }));
+      // uncomment above .pipe() and remove the .pipe() below
+      // when antora#188 is resolved
+      .pipe(insertSourceAttribute())
+      .pipe(dest('components/modules/ROOT/pages/'))
+  )
 }
 
-function createComponentOthersSymlinks() {
-    const f = filter(['**','!**/*-language.adoc', '!**/*-dataformat.adoc', '!**/*-component.adoc', '!**/*-summary.adoc'])
-    return src(['../core/camel-base/src/main/docs/*.adoc','../core/camel-main/src/main/docs/*.adoc','../components/{*,*/*}/src/main/docs/*.adoc'])
-        .pipe(f)
-        .pipe(map((file, done) => {
-            // this flattens the output to just .../pages/....adoc
-            // instead of .../pages/camel-.../src/main/docs/....adoc
-            file.base = path.dirname(file.path);
-            done(null, file);
-        }))
-        // Antora disabled symlinks, there is an issue open
-        // https://gitlab.com/antora/antora/issues/188
-        // to reinstate symlink support, until that's resolved
-        // we'll simply copy over instead of creating symlinks
-        // .pipe(symlink('components/modules/ROOT/pages/', {
-        //     relativeSymlinks: true
-        // }));
-        // uncomment above .pipe() and remove the .pipe() below
-        // when antora#188 is resolved
-        .pipe(insertSourceAttribute())
-        .pipe(dest('components/modules/others/pages/'));
+function createComponentOthersSymlinks () {
+  const f = filter([
+    '**',
+    '!**/*-language.adoc',
+    '!**/*-dataformat.adoc',
+    '!**/*-component.adoc',
+    '!**/*-summary.adoc',
+  ])
+  return (
+    src(['../core/camel-base/src/main/docs/*.adoc', '../components/{*,*/*}/src/main/docs/*.adoc'])","[{'comment': ""Seems that `'../core/camel-main/src/main/docs/*.adoc'` is missing here."", 'commenter': 'zregvart'}, {'comment': ""Yes, that's the merge conflict."", 'commenter': 'djencks'}, {'comment': ""I have rebased my branch with the master and it's up to date with the master branch. I am not sure about how this difference has come. "", 'commenter': 'AemieJ'}, {'comment': ""Claus added a commit to gulpfile.js after your initial run of lint[-fix].  His change isn't in your latest commit.  I think you should discard your second commit, make your your branch is up to date with master (in case someone else changed something :-), run lint-fix, and make any manual changes needed, commit the result, and force-push.  I hope we'll be able to commit then :-)"", 'commenter': 'djencks'}, {'comment': 'Latest commit includes the camel-main clause.', 'commenter': 'djencks'}]"
3915,components/camel-telegram/src/main/java/org/apache/camel/component/telegram/TelegramProxyType.java,"@@ -0,0 +1,8 @@
+package org.apache.camel.component.telegram;","[{'comment': 'Add license header', 'commenter': 'davsclaus'}]"
3915,components/camel-telegram/src/main/java/org/apache/camel/component/telegram/TelegramProxyType.java,"@@ -0,0 +1,8 @@
+package org.apache.camel.component.telegram;
+
+/**
+ * Date: 15.06.2020 08:33
+ */
+public enum TelegramProxyType {","[{'comment': 'Remove this javadoc', 'commenter': 'davsclaus'}]"
3919,components/camel-opentracing/src/main/java/org/apache/camel/opentracing/TagProcessor.java,"@@ -0,0 +1,102 @@
+package org.apache.camel.opentracing;","[{'comment': 'Please add the ASF license on top.', 'commenter': 'oscerd'}]"
3919,components/camel-opentracing/src/main/java/org/apache/camel/opentracing/TagProcessor.java,"@@ -0,0 +1,102 @@
+package org.apache.camel.opentracing;
+
+import io.opentracing.Span;
+import org.apache.camel.AsyncCallback;
+import org.apache.camel.Exchange;
+import org.apache.camel.Expression;
+import org.apache.camel.Traceable;
+import org.apache.camel.spi.IdAware;
+import org.apache.camel.spi.RouteIdAware;
+import org.apache.camel.support.AsyncProcessorSupport;
+import org.apache.camel.util.ObjectHelper;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * A processor which adds a tag on the active {@link io.opentracing.Span} with an {@link org.apache.camel.Expression}
+ */
+public class TagProcessor extends AsyncProcessorSupport implements Traceable, IdAware, RouteIdAware {
+
+    private static final Logger LOG = LoggerFactory.getLogger(TagProcessor.class);
+
+    private String id;
+    private String routeId;
+    private final Expression tagName;
+    private final Expression expression;
+
+    public TagProcessor(Expression tagName, Expression expression) {
+        this.tagName = tagName;
+        this.expression = expression;
+        ObjectHelper.notNull(tagName, ""headerName"");
+        ObjectHelper.notNull(expression, ""expression"");
+    }
+
+    @Override
+    public boolean process(Exchange exchange, AsyncCallback callback) {
+        try {
+            Span span = ActiveSpanManager.getSpan(exchange);
+            if (span != null) {
+                String key = tagName.evaluate(exchange, String.class);
+                String tag = expression.evaluate(exchange, String.class);","[{'comment': 'Maybe those expressions could be return null / empty key so the span tag is not set. This allows to only return keys when you want to set the tag.', 'commenter': 'davsclaus'}]"
3934,components/camel-oaipmh/pom.xml,"@@ -0,0 +1,140 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+
+    <modelVersion>4.0.0</modelVersion>
+
+    <parent>
+        <artifactId>components</artifactId>
+        <groupId>org.apache.camel</groupId>
+        <version>3.5.0-SNAPSHOT</version>
+    </parent>
+
+    <artifactId>camel-oaipmh</artifactId>
+    <packaging>jar</packaging>
+    <name>Camel :: OAIPMH</name>
+    <description>Camel OAI-PMH support</description>
+
+    <properties>
+    </properties>
+
+    <dependencyManagement>
+        <dependencies>
+            <!-- Camel BOM -->
+            <dependency>
+                <groupId>org.apache.camel</groupId>
+                <artifactId>camel-bom</artifactId>
+                <version>3.5.0-SNAPSHOT</version>
+                <scope>import</scope>
+                <type>pom</type>
+            </dependency>
+        </dependencies>
+    </dependencyManagement>
+
+    <dependencies>
+
+        <!-- camel -->
+        <dependency>
+            <groupId>org.apache.camel</groupId>
+            <artifactId>camel-support</artifactId>
+        </dependency>
+        <dependency>
+            <groupId>joda-time</groupId>
+            <artifactId>joda-time</artifactId>
+            <version>${jodatime2-bundle-version}</version>
+        </dependency>
+        <dependency>
+            <groupId>org.apache.httpcomponents</groupId>
+            <artifactId>httpclient</artifactId>
+        </dependency>
+        <dependency>
+            <groupId>org.jsoup</groupId>
+            <artifactId>jsoup</artifactId>
+            <version>${jsoup-version}</version>
+        </dependency>
+
+        <!-- testing -->
+        <dependency>
+            <groupId>org.apache.camel</groupId>
+            <artifactId>camel-test</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.eclipse.jetty</groupId>
+            <artifactId>jetty-servlet</artifactId>
+            <version>${jetty-version}</version>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>commons-io</groupId>
+            <artifactId>commons-io</artifactId>
+            <scope>test</scope>
+        </dependency>
+    </dependencies>
+
+    <build>
+        <defaultGoal>install</defaultGoal>
+
+        <plugins>
+            <plugin>
+                <groupId>org.apache.maven.plugins</groupId>
+                <artifactId>maven-compiler-plugin</artifactId>
+                <version>3.8.1</version>
+                <configuration>
+                    <source>1.8</source>
+                    <target>1.8</target>
+                </configuration>
+            </plugin>
+      
+            <plugin>
+                <groupId>org.apache.maven.plugins</groupId>
+                <artifactId>maven-resources-plugin</artifactId>
+                <version>3.1.0</version>
+                <configuration>
+                    <encoding>UTF-8</encoding>
+                </configuration>
+            </plugin>
+
+            <!-- generate camel meta-data -->
+            <plugin>","[{'comment': ""You don't need this plugin, is already included in the parent pom of the components."", 'commenter': 'omarsmak'}]"
3934,components/camel-oaipmh/pom.xml,"@@ -0,0 +1,140 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+
+    <modelVersion>4.0.0</modelVersion>
+
+    <parent>
+        <artifactId>components</artifactId>
+        <groupId>org.apache.camel</groupId>
+        <version>3.5.0-SNAPSHOT</version>
+    </parent>
+
+    <artifactId>camel-oaipmh</artifactId>
+    <packaging>jar</packaging>
+    <name>Camel :: OAIPMH</name>
+    <description>Camel OAI-PMH support</description>
+
+    <properties>
+    </properties>
+
+    <dependencyManagement>
+        <dependencies>
+            <!-- Camel BOM -->
+            <dependency>
+                <groupId>org.apache.camel</groupId>
+                <artifactId>camel-bom</artifactId>
+                <version>3.5.0-SNAPSHOT</version>
+                <scope>import</scope>
+                <type>pom</type>
+            </dependency>
+        </dependencies>
+    </dependencyManagement>
+
+    <dependencies>
+
+        <!-- camel -->
+        <dependency>
+            <groupId>org.apache.camel</groupId>
+            <artifactId>camel-support</artifactId>
+        </dependency>
+        <dependency>
+            <groupId>joda-time</groupId>
+            <artifactId>joda-time</artifactId>
+            <version>${jodatime2-bundle-version}</version>
+        </dependency>
+        <dependency>
+            <groupId>org.apache.httpcomponents</groupId>
+            <artifactId>httpclient</artifactId>
+        </dependency>
+        <dependency>
+            <groupId>org.jsoup</groupId>
+            <artifactId>jsoup</artifactId>
+            <version>${jsoup-version}</version>
+        </dependency>
+
+        <!-- testing -->
+        <dependency>
+            <groupId>org.apache.camel</groupId>
+            <artifactId>camel-test</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.eclipse.jetty</groupId>
+            <artifactId>jetty-servlet</artifactId>
+            <version>${jetty-version}</version>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>commons-io</groupId>
+            <artifactId>commons-io</artifactId>
+            <scope>test</scope>
+        </dependency>
+    </dependencies>
+
+    <build>
+        <defaultGoal>install</defaultGoal>
+
+        <plugins>
+            <plugin>
+                <groupId>org.apache.maven.plugins</groupId>
+                <artifactId>maven-compiler-plugin</artifactId>
+                <version>3.8.1</version>
+                <configuration>
+                    <source>1.8</source>
+                    <target>1.8</target>
+                </configuration>
+            </plugin>
+      
+            <plugin>
+                <groupId>org.apache.maven.plugins</groupId>
+                <artifactId>maven-resources-plugin</artifactId>
+                <version>3.1.0</version>
+                <configuration>
+                    <encoding>UTF-8</encoding>
+                </configuration>
+            </plugin>
+
+            <!-- generate camel meta-data -->
+            <plugin>
+                <groupId>org.apache.camel</groupId>
+                <artifactId>camel-component-maven-plugin</artifactId>
+                <version>3.5.0-SNAPSHOT</version>
+                <executions>
+                    <execution>
+                        <id>generate</id>
+                        <goals>
+                            <goal>generate</goal>
+                        </goals>
+                        <phase>process-classes</phase>
+                    </execution>
+                </executions>
+            </plugin>
+            <plugin>
+                <groupId>org.codehaus.mojo</groupId>
+                <artifactId>build-helper-maven-plugin</artifactId>","[{'comment': 'As well here', 'commenter': 'omarsmak'}]"
3934,components/camel-oaipmh/pom.xml,"@@ -0,0 +1,140 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+
+    <modelVersion>4.0.0</modelVersion>
+
+    <parent>
+        <artifactId>components</artifactId>
+        <groupId>org.apache.camel</groupId>
+        <version>3.5.0-SNAPSHOT</version>
+    </parent>
+
+    <artifactId>camel-oaipmh</artifactId>
+    <packaging>jar</packaging>
+    <name>Camel :: OAIPMH</name>
+    <description>Camel OAI-PMH support</description>
+
+    <properties>
+    </properties>
+
+    <dependencyManagement>","[{'comment': ""You already having the parent dependency, I don't think you need to add the Camel BOM here"", 'commenter': 'omarsmak'}]"
3934,components/camel-oaipmh/pom.xml,"@@ -0,0 +1,140 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+
+    <modelVersion>4.0.0</modelVersion>
+
+    <parent>
+        <artifactId>components</artifactId>
+        <groupId>org.apache.camel</groupId>
+        <version>3.5.0-SNAPSHOT</version>
+    </parent>
+
+    <artifactId>camel-oaipmh</artifactId>
+    <packaging>jar</packaging>
+    <name>Camel :: OAIPMH</name>
+    <description>Camel OAI-PMH support</description>
+
+    <properties>
+    </properties>
+
+    <dependencyManagement>
+        <dependencies>
+            <!-- Camel BOM -->
+            <dependency>
+                <groupId>org.apache.camel</groupId>
+                <artifactId>camel-bom</artifactId>
+                <version>3.5.0-SNAPSHOT</version>
+                <scope>import</scope>
+                <type>pom</type>
+            </dependency>
+        </dependencies>
+    </dependencyManagement>
+
+    <dependencies>
+
+        <!-- camel -->
+        <dependency>
+            <groupId>org.apache.camel</groupId>
+            <artifactId>camel-support</artifactId>
+        </dependency>
+        <dependency>
+            <groupId>joda-time</groupId>
+            <artifactId>joda-time</artifactId>
+            <version>${jodatime2-bundle-version}</version>
+        </dependency>
+        <dependency>
+            <groupId>org.apache.httpcomponents</groupId>
+            <artifactId>httpclient</artifactId>
+        </dependency>
+        <dependency>
+            <groupId>org.jsoup</groupId>
+            <artifactId>jsoup</artifactId>
+            <version>${jsoup-version}</version>
+        </dependency>
+
+        <!-- testing -->
+        <dependency>
+            <groupId>org.apache.camel</groupId>
+            <artifactId>camel-test</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.eclipse.jetty</groupId>
+            <artifactId>jetty-servlet</artifactId>
+            <version>${jetty-version}</version>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>commons-io</groupId>
+            <artifactId>commons-io</artifactId>
+            <scope>test</scope>
+        </dependency>
+    </dependencies>
+
+    <build>
+        <defaultGoal>install</defaultGoal>
+
+        <plugins>","[{'comment': 'and here', 'commenter': 'omarsmak'}]"
3934,components/camel-oaipmh/src/main/java/org/apache/camel/oaipmh/handler/Harvester.java,"@@ -0,0 +1,185 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.oaipmh.handler;
+
+import java.io.IOException;
+import java.net.URI;
+import java.net.URISyntaxException;
+import java.security.KeyManagementException;","[{'comment': 'I see these imports are not used here', 'commenter': 'omarsmak'}]"
3934,components/camel-oaipmh/src/main/java/org/apache/camel/oaipmh/handler/Harvester.java,"@@ -0,0 +1,185 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.oaipmh.handler;
+
+import java.io.IOException;
+import java.net.URI;
+import java.net.URISyntaxException;
+import java.security.KeyManagementException;
+import java.security.KeyStoreException;
+import java.security.NoSuchAlgorithmException;
+import java.util.List;
+import java.util.Optional;
+
+import javax.xml.parsers.ParserConfigurationException;
+
+import org.xml.sax.SAXException;
+
+import org.apache.camel.oaipmh.component.model.OAIPMHVerb;
+import org.apache.camel.oaipmh.model.OAIPMHResponse;
+import org.apache.camel.oaipmh.utils.OAIPMHHttpClient;
+
+public class Harvester {
+
+    private static final String NO_TOKEN = null;
+    private String resumptionToken = NO_TOKEN;
+    private URI baseURI;
+    private String verb;
+    private String metadata;
+    private String until;
+    private String from;
+    private String set;
+    private String identifier;
+    private OAIPMHHttpClient httpClient;
+    private ResponseHandler oaipmhResponseHandler;
+
+    private boolean empty;
+
+    public Harvester(ResponseHandler oaipmhResponseHandler, URI baseURI, String verb, String metadata, String until, String from, String set, String identifier) {
+        this.baseURI = baseURI;
+        this.verb = verb;
+        this.metadata = metadata;
+        this.until = until;
+        this.from = from;
+        this.set = set;
+        this.identifier = identifier;
+        this.httpClient = new OAIPMHHttpClient();
+        this.oaipmhResponseHandler = oaipmhResponseHandler;
+
+        if (OAIPMHVerb.valueOf(verb) == OAIPMHVerb.Identify) {
+            this.metadata = null;
+            this.until = null;
+            this.from = null;
+            this.set = null;
+            this.identifier = null;
+        }
+
+    }
+
+    private boolean harvest() throws IOException, URISyntaxException, ParserConfigurationException, SAXException, Exception {","[{'comment': ""I don't think you need to throw all these exception since you are throwing `Exception`."", 'commenter': 'omarsmak'}]"
3934,components/camel-oaipmh/src/main/java/org/apache/camel/oaipmh/component/OAIPMHProducer.java,"@@ -0,0 +1,116 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.oaipmh.component;
+
+import java.net.URI;
+import java.util.List;
+
+import org.apache.camel.Exchange;
+import org.apache.camel.Message;
+import org.apache.camel.oaipmh.handler.Harvester;
+import org.apache.camel.oaipmh.handler.ProducerResponseHandler;
+import org.apache.camel.support.DefaultProducer;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * The OAIPMH producer.
+ */
+public class OAIPMHProducer extends DefaultProducer {
+
+    private static final Logger LOG = LoggerFactory.getLogger(OAIPMHProducer.class);
+    private OAIPMHEndpoint endpoint;
+
+    public OAIPMHProducer(OAIPMHEndpoint endpoint) {
+        super(endpoint);
+        this.endpoint = endpoint;
+    }
+
+    @Override
+    public void process(Exchange exchange) throws Exception {
+        Harvester harvester = new Harvester(
+                new ProducerResponseHandler(),
+                endpoint.getUrl(),
+                endpoint.getVerb(),
+                endpoint.getMetadataPrefix(),
+                endpoint.getUntil(),
+                endpoint.getFrom(),
+                endpoint.getSet(),
+                endpoint.getIdentitier());
+        overrideHarvesterConfigs(exchange.getIn(), harvester);
+        if (endpoint.isIgnoreSSLWarnings()) {
+            harvester.getHttpClient().setIgnoreSSLWarnings(true);
+        }
+        List<String> synHarvest = harvester.synHarvest(endpoint.isOnlyFirst());
+        exchange.getMessage().setBody(synHarvest);
+        if (endpoint.isOnlyFirst() && harvester.getResumptionToken() != null) {
+            exchange.getMessage().setHeader(""CamelOaimphResumptionToken"", harvester.getResumptionToken());
+        } else {
+            exchange.getMessage().removeHeader(""CamelOaimphResumptionToken"");
+        }
+    }
+
+    private void overrideHarvesterConfigs(Message msg, Harvester harvester) {
+        String header = msg.getHeader(""CamelOaimphUrl"", String.class);","[{'comment': ""I'd prefer to put all headers key string constants in a different class, [example](https://github.com/apache/camel/blob/master/components/camel-arangodb/src/main/java/org/apache/camel/component/arangodb/ArangoDbConstants.java#L19)"", 'commenter': 'omarsmak'}]"
3934,components/camel-oaipmh/src/main/java/org/apache/camel/oaipmh/component/OAIPMHProducer.java,"@@ -0,0 +1,116 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.oaipmh.component;
+
+import java.net.URI;
+import java.util.List;
+
+import org.apache.camel.Exchange;
+import org.apache.camel.Message;
+import org.apache.camel.oaipmh.handler.Harvester;
+import org.apache.camel.oaipmh.handler.ProducerResponseHandler;
+import org.apache.camel.support.DefaultProducer;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * The OAIPMH producer.
+ */
+public class OAIPMHProducer extends DefaultProducer {
+
+    private static final Logger LOG = LoggerFactory.getLogger(OAIPMHProducer.class);
+    private OAIPMHEndpoint endpoint;
+
+    public OAIPMHProducer(OAIPMHEndpoint endpoint) {
+        super(endpoint);
+        this.endpoint = endpoint;
+    }
+
+    @Override
+    public void process(Exchange exchange) throws Exception {
+        Harvester harvester = new Harvester(
+                new ProducerResponseHandler(),
+                endpoint.getUrl(),
+                endpoint.getVerb(),
+                endpoint.getMetadataPrefix(),
+                endpoint.getUntil(),
+                endpoint.getFrom(),
+                endpoint.getSet(),
+                endpoint.getIdentitier());
+        overrideHarvesterConfigs(exchange.getIn(), harvester);
+        if (endpoint.isIgnoreSSLWarnings()) {
+            harvester.getHttpClient().setIgnoreSSLWarnings(true);
+        }
+        List<String> synHarvest = harvester.synHarvest(endpoint.isOnlyFirst());
+        exchange.getMessage().setBody(synHarvest);
+        if (endpoint.isOnlyFirst() && harvester.getResumptionToken() != null) {
+            exchange.getMessage().setHeader(""CamelOaimphResumptionToken"", harvester.getResumptionToken());
+        } else {
+            exchange.getMessage().removeHeader(""CamelOaimphResumptionToken"");
+        }
+    }
+
+    private void overrideHarvesterConfigs(Message msg, Harvester harvester) {
+        String header = msg.getHeader(""CamelOaimphUrl"", String.class);
+        if (header != null) {
+            harvester.setBaseURI(URI.create(header));
+        }
+
+        header = msg.getHeader(""CamelOaimphEndpointUrl"", String.class);
+        if (header != null) {","[{'comment': 'I think these kind of validations, could be simplified into a function that takes lambda as argument, example:\r\n```\r\nprivate <T> void checkAndSetConfigs(final Message message, final String key, final Consumer<T> fn, final Class<T> type) {\r\n        final T header = message.getHeader(key, type);\r\n        if (!ObjectHelper.isEmpty(header)) {\r\n            fn.accept(header);\r\n        }\r\n    }\r\n``` \r\nto call it:\r\n```\r\ncheckAndSetConfigs(msg, ""CamelOaimphVerb"", harvester::setVerb, String.class);\r\n```\r\nFor the URI, you may need to add the a wrapper from URI to String somewhere that creates `URI.create(header)`', 'commenter': 'omarsmak'}]"
3934,components/camel-oaipmh/src/main/java/org/apache/camel/oaipmh/utils/OAIPMHHttpClient.java,"@@ -0,0 +1,150 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.oaipmh.utils;
+
+import java.io.IOException;
+import java.net.URI;
+import java.net.URISyntaxException;
+import java.nio.charset.Charset;
+
+import org.apache.http.HttpEntity;
+import org.apache.http.HttpResponse;
+import org.apache.http.RequestLine;
+import org.apache.http.client.ClientProtocolException;
+import org.apache.http.client.ResponseHandler;
+import org.apache.http.client.methods.HttpGet;
+import org.apache.http.client.utils.URIBuilder;
+import org.apache.http.conn.ssl.SSLConnectionSocketFactory;
+import org.apache.http.conn.ssl.SSLContextBuilder;
+import org.apache.http.conn.ssl.TrustSelfSignedStrategy;
+import org.apache.http.impl.client.CloseableHttpClient;
+import org.apache.http.impl.client.HttpClients;
+import org.apache.http.util.EntityUtils;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class OAIPMHHttpClient {
+
+    private static final Logger LOG = LoggerFactory.getLogger(OAIPMHHttpClient.class);
+
+    private boolean ignoreSSLWarnings;
+
+    public String doRequest(URI baseURI, String verb, String set, String from, String until, String metadataPrefix, String token, String identifier) throws IOException, URISyntaxException, Exception {
+        CloseableHttpClient httpclient = getCloseableHttpClient();
+        try {","[{'comment': 'You can replace it with:\r\n```suggestion\r\n       try (CloseableHttpClient httpclient = getCloseableHttpClient()) {\r\n```', 'commenter': 'omarsmak'}]"
3934,components/camel-oaipmh/src/main/java/org/apache/camel/oaipmh/utils/OAIPMHHttpClient.java,"@@ -0,0 +1,150 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.oaipmh.utils;
+
+import java.io.IOException;
+import java.net.URI;
+import java.net.URISyntaxException;
+import java.nio.charset.Charset;
+
+import org.apache.http.HttpEntity;
+import org.apache.http.HttpResponse;
+import org.apache.http.RequestLine;
+import org.apache.http.client.ClientProtocolException;
+import org.apache.http.client.ResponseHandler;
+import org.apache.http.client.methods.HttpGet;
+import org.apache.http.client.utils.URIBuilder;
+import org.apache.http.conn.ssl.SSLConnectionSocketFactory;
+import org.apache.http.conn.ssl.SSLContextBuilder;
+import org.apache.http.conn.ssl.TrustSelfSignedStrategy;
+import org.apache.http.impl.client.CloseableHttpClient;
+import org.apache.http.impl.client.HttpClients;
+import org.apache.http.util.EntityUtils;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class OAIPMHHttpClient {
+
+    private static final Logger LOG = LoggerFactory.getLogger(OAIPMHHttpClient.class);
+
+    private boolean ignoreSSLWarnings;
+
+    public String doRequest(URI baseURI, String verb, String set, String from, String until, String metadataPrefix, String token, String identifier) throws IOException, URISyntaxException, Exception {
+        CloseableHttpClient httpclient = getCloseableHttpClient();
+        try {
+
+            URIBuilder builder = new URIBuilder();
+            builder.setScheme(baseURI.getScheme())
+                    .setHost(baseURI.getHost())
+                    .setPort(baseURI.getPort())
+                    .setPath(baseURI.getPath())
+                    .addParameter(""verb"", verb);
+
+            if (baseURI.getQuery() != null && !baseURI.getQuery().isEmpty()) {
+                for (String param : baseURI.getQuery().split(""&"")) {
+                    builder.addParameter(param.split(""="")[0], param.split(""="")[1]);","[{'comment': 'I am just wondering, do we need to check that we really have two params split with `=`? ', 'commenter': 'omarsmak'}]"
3934,components/camel-oaipmh/src/main/java/org/apache/camel/oaipmh/utils/OAIPMHHttpClient.java,"@@ -0,0 +1,150 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.oaipmh.utils;
+
+import java.io.IOException;
+import java.net.URI;
+import java.net.URISyntaxException;
+import java.nio.charset.Charset;
+
+import org.apache.http.HttpEntity;
+import org.apache.http.HttpResponse;
+import org.apache.http.RequestLine;
+import org.apache.http.client.ClientProtocolException;
+import org.apache.http.client.ResponseHandler;
+import org.apache.http.client.methods.HttpGet;
+import org.apache.http.client.utils.URIBuilder;
+import org.apache.http.conn.ssl.SSLConnectionSocketFactory;
+import org.apache.http.conn.ssl.SSLContextBuilder;
+import org.apache.http.conn.ssl.TrustSelfSignedStrategy;
+import org.apache.http.impl.client.CloseableHttpClient;
+import org.apache.http.impl.client.HttpClients;
+import org.apache.http.util.EntityUtils;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class OAIPMHHttpClient {
+
+    private static final Logger LOG = LoggerFactory.getLogger(OAIPMHHttpClient.class);
+
+    private boolean ignoreSSLWarnings;
+
+    public String doRequest(URI baseURI, String verb, String set, String from, String until, String metadataPrefix, String token, String identifier) throws IOException, URISyntaxException, Exception {
+        CloseableHttpClient httpclient = getCloseableHttpClient();
+        try {
+
+            URIBuilder builder = new URIBuilder();
+            builder.setScheme(baseURI.getScheme())
+                    .setHost(baseURI.getHost())
+                    .setPort(baseURI.getPort())
+                    .setPath(baseURI.getPath())
+                    .addParameter(""verb"", verb);
+
+            if (baseURI.getQuery() != null && !baseURI.getQuery().isEmpty()) {
+                for (String param : baseURI.getQuery().split(""&"")) {
+                    builder.addParameter(param.split(""="")[0], param.split(""="")[1]);
+                }
+            }
+
+            if (identifier != null) {
+                builder.addParameter(""identifier"", identifier);
+            }
+
+            if (token != null) {
+                builder.addParameter(""resumptionToken"", token);
+            } else {
+                if (metadataPrefix != null) {
+                    builder.addParameter(""metadataPrefix"", metadataPrefix);
+                }
+                if (set != null) {
+                    builder.addParameter(""set"", set);
+                }
+                if (from != null) {
+                    builder.addParameter(""from"", from);
+                }
+                if (until != null) {
+                    builder.addParameter(""until"", until);
+                }
+            }
+
+            HttpGet httpget = new HttpGet(builder.build());
+
+            RequestLine requestLine = httpget.getRequestLine();
+
+            LOG.info(""Executing request: {} "", requestLine);
+
+            // Create a custom response handler
+            ResponseHandler<String> responseHandler = new ResponseHandler<String>() {
+
+                @Override
+                public String handleResponse(final HttpResponse response) throws IOException {
+                    int status = response.getStatusLine().getStatusCode();
+                    if (status >= 200 && status < 300) {
+                        HttpEntity entity = response.getEntity();
+                        if (entity == null) {
+                            throw new IOException(""No response received"");
+                        }
+                        return EntityUtils.toString(entity, Charset.forName(""UTF-8""));
+                    } else {
+                        throw new ClientProtocolException(""Unexpected response status: "" + status);
+                    }
+                }
+
+            };
+            String responseBody = httpclient.execute(httpget, responseHandler);
+
+//            String uri = requestLine.getUri();","[{'comment': 'unnecessary comments here', 'commenter': 'omarsmak'}]"
3934,components/camel-oaipmh/src/main/java/org/apache/camel/oaipmh/utils/OAIPMHHttpClient.java,"@@ -0,0 +1,150 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.oaipmh.utils;
+
+import java.io.IOException;
+import java.net.URI;
+import java.net.URISyntaxException;
+import java.nio.charset.Charset;
+
+import org.apache.http.HttpEntity;
+import org.apache.http.HttpResponse;
+import org.apache.http.RequestLine;
+import org.apache.http.client.ClientProtocolException;
+import org.apache.http.client.ResponseHandler;
+import org.apache.http.client.methods.HttpGet;
+import org.apache.http.client.utils.URIBuilder;
+import org.apache.http.conn.ssl.SSLConnectionSocketFactory;
+import org.apache.http.conn.ssl.SSLContextBuilder;
+import org.apache.http.conn.ssl.TrustSelfSignedStrategy;
+import org.apache.http.impl.client.CloseableHttpClient;
+import org.apache.http.impl.client.HttpClients;
+import org.apache.http.util.EntityUtils;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class OAIPMHHttpClient {
+
+    private static final Logger LOG = LoggerFactory.getLogger(OAIPMHHttpClient.class);
+
+    private boolean ignoreSSLWarnings;
+
+    public String doRequest(URI baseURI, String verb, String set, String from, String until, String metadataPrefix, String token, String identifier) throws IOException, URISyntaxException, Exception {
+        CloseableHttpClient httpclient = getCloseableHttpClient();
+        try {
+
+            URIBuilder builder = new URIBuilder();
+            builder.setScheme(baseURI.getScheme())
+                    .setHost(baseURI.getHost())
+                    .setPort(baseURI.getPort())
+                    .setPath(baseURI.getPath())
+                    .addParameter(""verb"", verb);
+
+            if (baseURI.getQuery() != null && !baseURI.getQuery().isEmpty()) {
+                for (String param : baseURI.getQuery().split(""&"")) {
+                    builder.addParameter(param.split(""="")[0], param.split(""="")[1]);
+                }
+            }
+
+            if (identifier != null) {
+                builder.addParameter(""identifier"", identifier);
+            }
+
+            if (token != null) {
+                builder.addParameter(""resumptionToken"", token);
+            } else {
+                if (metadataPrefix != null) {
+                    builder.addParameter(""metadataPrefix"", metadataPrefix);
+                }
+                if (set != null) {
+                    builder.addParameter(""set"", set);
+                }
+                if (from != null) {
+                    builder.addParameter(""from"", from);
+                }
+                if (until != null) {
+                    builder.addParameter(""until"", until);
+                }
+            }
+
+            HttpGet httpget = new HttpGet(builder.build());
+
+            RequestLine requestLine = httpget.getRequestLine();
+
+            LOG.info(""Executing request: {} "", requestLine);
+
+            // Create a custom response handler
+            ResponseHandler<String> responseHandler = new ResponseHandler<String>() {
+
+                @Override
+                public String handleResponse(final HttpResponse response) throws IOException {
+                    int status = response.getStatusLine().getStatusCode();
+                    if (status >= 200 && status < 300) {
+                        HttpEntity entity = response.getEntity();
+                        if (entity == null) {
+                            throw new IOException(""No response received"");
+                        }
+                        return EntityUtils.toString(entity, Charset.forName(""UTF-8""));
+                    } else {
+                        throw new ClientProtocolException(""Unexpected response status: "" + status);
+                    }
+                }
+
+            };
+            String responseBody = httpclient.execute(httpget, responseHandler);
+
+//            String uri = requestLine.getUri();
+//            System.out.println(uri);
+//            String sha256Hex = DigestUtils.sha256Hex(uri.split("".org"")[1]);
+//            System.out.println (""File:""+sha256Hex);
+//            BufferedWriter writer = new BufferedWriter(new FileWriter(""/tmp/tests/test4/"" + sha256Hex + "".xml""));
+//            writer.write(responseBody);
+//            writer.close();
+            LOG.debug(""Response received: {}"", responseBody);
+
+            return responseBody;
+        } finally {
+            httpclient.close();
+        }
+    }
+
+    protected CloseableHttpClient getCloseableHttpClient() throws Exception {
+        if (isIgnoreSSLWarnings()) {
+            try {
+                SSLContextBuilder builder = new SSLContextBuilder();
+                builder.loadTrustMaterial(null, new TrustSelfSignedStrategy());
+                SSLConnectionSocketFactory sslsf = new SSLConnectionSocketFactory(
+                        builder.build());
+                return HttpClients.custom().setSSLSocketFactory(
+                        sslsf).build();
+            } catch (Exception ex) {","[{'comment': ""If you are catching the exception and then throw it again, makes no sense. However, I don't feel comfortable of throwing generic `Exception` here, please be specific on which exception you want to throw here"", 'commenter': 'omarsmak'}]"
3934,components/camel-oaipmh/src/main/java/org/apache/camel/oaipmh/utils/OAIPMHHttpClient.java,"@@ -0,0 +1,150 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.oaipmh.utils;
+
+import java.io.IOException;
+import java.net.URI;
+import java.net.URISyntaxException;
+import java.nio.charset.Charset;
+
+import org.apache.http.HttpEntity;
+import org.apache.http.HttpResponse;
+import org.apache.http.RequestLine;
+import org.apache.http.client.ClientProtocolException;
+import org.apache.http.client.ResponseHandler;
+import org.apache.http.client.methods.HttpGet;
+import org.apache.http.client.utils.URIBuilder;
+import org.apache.http.conn.ssl.SSLConnectionSocketFactory;
+import org.apache.http.conn.ssl.SSLContextBuilder;
+import org.apache.http.conn.ssl.TrustSelfSignedStrategy;
+import org.apache.http.impl.client.CloseableHttpClient;
+import org.apache.http.impl.client.HttpClients;
+import org.apache.http.util.EntityUtils;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class OAIPMHHttpClient {
+
+    private static final Logger LOG = LoggerFactory.getLogger(OAIPMHHttpClient.class);
+
+    private boolean ignoreSSLWarnings;
+
+    public String doRequest(URI baseURI, String verb, String set, String from, String until, String metadataPrefix, String token, String identifier) throws IOException, URISyntaxException, Exception {
+        CloseableHttpClient httpclient = getCloseableHttpClient();
+        try {
+
+            URIBuilder builder = new URIBuilder();
+            builder.setScheme(baseURI.getScheme())
+                    .setHost(baseURI.getHost())
+                    .setPort(baseURI.getPort())
+                    .setPath(baseURI.getPath())
+                    .addParameter(""verb"", verb);
+
+            if (baseURI.getQuery() != null && !baseURI.getQuery().isEmpty()) {
+                for (String param : baseURI.getQuery().split(""&"")) {
+                    builder.addParameter(param.split(""="")[0], param.split(""="")[1]);
+                }
+            }
+
+            if (identifier != null) {
+                builder.addParameter(""identifier"", identifier);
+            }
+
+            if (token != null) {
+                builder.addParameter(""resumptionToken"", token);
+            } else {
+                if (metadataPrefix != null) {
+                    builder.addParameter(""metadataPrefix"", metadataPrefix);
+                }
+                if (set != null) {
+                    builder.addParameter(""set"", set);
+                }
+                if (from != null) {
+                    builder.addParameter(""from"", from);
+                }
+                if (until != null) {
+                    builder.addParameter(""until"", until);
+                }
+            }
+
+            HttpGet httpget = new HttpGet(builder.build());
+
+            RequestLine requestLine = httpget.getRequestLine();
+
+            LOG.info(""Executing request: {} "", requestLine);
+
+            // Create a custom response handler
+            ResponseHandler<String> responseHandler = new ResponseHandler<String>() {
+
+                @Override
+                public String handleResponse(final HttpResponse response) throws IOException {
+                    int status = response.getStatusLine().getStatusCode();
+                    if (status >= 200 && status < 300) {
+                        HttpEntity entity = response.getEntity();
+                        if (entity == null) {
+                            throw new IOException(""No response received"");
+                        }
+                        return EntityUtils.toString(entity, Charset.forName(""UTF-8""));
+                    } else {
+                        throw new ClientProtocolException(""Unexpected response status: "" + status);
+                    }
+                }
+
+            };
+            String responseBody = httpclient.execute(httpget, responseHandler);
+
+//            String uri = requestLine.getUri();
+//            System.out.println(uri);
+//            String sha256Hex = DigestUtils.sha256Hex(uri.split("".org"")[1]);
+//            System.out.println (""File:""+sha256Hex);
+//            BufferedWriter writer = new BufferedWriter(new FileWriter(""/tmp/tests/test4/"" + sha256Hex + "".xml""));
+//            writer.write(responseBody);
+//            writer.close();
+            LOG.debug(""Response received: {}"", responseBody);
+
+            return responseBody;
+        } finally {
+            httpclient.close();
+        }
+    }
+
+    protected CloseableHttpClient getCloseableHttpClient() throws Exception {
+        if (isIgnoreSSLWarnings()) {
+            try {
+                SSLContextBuilder builder = new SSLContextBuilder();","[{'comment': 'This looks deprecated. ', 'commenter': 'omarsmak'}]"
3944,components/camel-couchbase/pom.xml,"@@ -23,7 +23,7 @@
     <parent>
         <groupId>org.apache.camel</groupId>
         <artifactId>components</artifactId>
-        <version>3.5.0-SNAPSHOT</version>
+        <version>3.4.0-SNAPSHOT</version>","[{'comment': 'master is on `3.5.0-SNAPSHOT`, this should change', 'commenter': 'omarsmak'}]"
3944,components/camel-couchbase/pom.xml,"@@ -60,13 +60,13 @@
 
         <dependency>
             <groupId>org.apache.camel</groupId>
-            <artifactId>camel-test-junit5</artifactId>","[{'comment': 'Any reason why not using junit5? We have done a lot of effort on junit5 migration', 'commenter': 'omarsmak'}]"
3944,components/camel-couchbase/src/main/java/org/apache/camel/component/couchbase/CouchbaseComponent.java,"@@ -1,44 +1,44 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.camel.component.couchbase;
-
-import java.util.Map;
-
-import org.apache.camel.CamelContext;
-import org.apache.camel.spi.annotations.Component;
-import org.apache.camel.support.DefaultComponent;
-
-/**
- * Couchbase component.
- */
-@Component(""couchbase"")
-public class CouchbaseComponent extends DefaultComponent {
-
-    public CouchbaseComponent() {
-    }
-
-    public CouchbaseComponent(CamelContext context) {
-        super(context);
-    }
-
-    @Override
-    protected CouchbaseEndpoint createEndpoint(String uri, String remaining, Map<String, Object> parameters) throws Exception {
-        CouchbaseEndpoint endpoint = new CouchbaseEndpoint(uri, remaining, this);
-        setProperties(endpoint, parameters);
-        return endpoint;
-    }
-}
+/*","[{'comment': 'Formatting here is bit troublesome as it shows it big change meanwhile it is formatting', 'commenter': 'omarsmak'}]"
3944,components/camel-couchbase/src/main/java/org/apache/camel/component/couchbase/CouchbaseEndpoint.java,"@@ -37,21 +41,7 @@
 import org.apache.camel.spi.UriPath;
 import org.apache.camel.support.ScheduledPollEndpoint;
 
-import static org.apache.camel.component.couchbase.CouchbaseConstants.COUCHBASE_PUT;
-import static org.apache.camel.component.couchbase.CouchbaseConstants.COUCHBASE_URI_ERROR;
-import static org.apache.camel.component.couchbase.CouchbaseConstants.DEFAULT_CONSUME_PROCESSED_STRATEGY;
-import static org.apache.camel.component.couchbase.CouchbaseConstants.DEFAULT_COUCHBASE_PORT;
-import static org.apache.camel.component.couchbase.CouchbaseConstants.DEFAULT_DESIGN_DOCUMENT_NAME;
-import static org.apache.camel.component.couchbase.CouchbaseConstants.DEFAULT_MAX_RECONNECT_DELAY;
-import static org.apache.camel.component.couchbase.CouchbaseConstants.DEFAULT_OBS_POLL_INTERVAL;
-import static org.apache.camel.component.couchbase.CouchbaseConstants.DEFAULT_OBS_TIMEOUT;
-import static org.apache.camel.component.couchbase.CouchbaseConstants.DEFAULT_OP_QUEUE_MAX_BLOCK_TIME;
-import static org.apache.camel.component.couchbase.CouchbaseConstants.DEFAULT_OP_TIMEOUT;
-import static org.apache.camel.component.couchbase.CouchbaseConstants.DEFAULT_PAUSE_BETWEEN_RETRIES;
-import static org.apache.camel.component.couchbase.CouchbaseConstants.DEFAULT_PRODUCER_RETRIES;
-import static org.apache.camel.component.couchbase.CouchbaseConstants.DEFAULT_READ_BUFFER_SIZE;
-import static org.apache.camel.component.couchbase.CouchbaseConstants.DEFAULT_TIMEOUT_EXCEPTION_THRESHOLD;
-import static org.apache.camel.component.couchbase.CouchbaseConstants.DEFAULT_VIEWNAME;
+import static org.apache.camel.component.couchbase.CouchbaseConstants.*;","[{'comment': 'Please retain from loading all statics through the wildcard', 'commenter': 'omarsmak'}]"
3944,components/camel-couchbase/src/main/java/org/apache/camel/component/couchbase/CouchbaseConsumer.java,"@@ -16,65 +16,76 @@
  */
 package org.apache.camel.component.couchbase;
 
-import com.couchbase.client.CouchbaseClient;
-import com.couchbase.client.protocol.views.Query;
-import com.couchbase.client.protocol.views.View;
-import com.couchbase.client.protocol.views.ViewResponse;
-import com.couchbase.client.protocol.views.ViewRow;
+import java.util.List;
+
+import com.couchbase.client.java.Bucket;
+import com.couchbase.client.java.Collection;
+import com.couchbase.client.java.Scope;
+import com.couchbase.client.java.view.ViewOptions;
+import com.couchbase.client.java.view.ViewOrdering;
+import com.couchbase.client.java.view.ViewResult;
+import com.couchbase.client.java.view.ViewRow;
 import org.apache.camel.Exchange;
 import org.apache.camel.Processor;
 import org.apache.camel.support.DefaultScheduledPollConsumer;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import static org.apache.camel.component.couchbase.CouchbaseConstants.HEADER_DESIGN_DOCUMENT_NAME;
-import static org.apache.camel.component.couchbase.CouchbaseConstants.HEADER_ID;
-import static org.apache.camel.component.couchbase.CouchbaseConstants.HEADER_KEY;
-import static org.apache.camel.component.couchbase.CouchbaseConstants.HEADER_VIEWNAME;
+import static org.apache.camel.component.couchbase.CouchbaseConstants.*;
 
 public class CouchbaseConsumer extends DefaultScheduledPollConsumer {
 
     private static final Logger LOG = LoggerFactory.getLogger(CouchbaseConsumer.class);
 
     private final CouchbaseEndpoint endpoint;
-    private final CouchbaseClient client;
-    private final View view;
-    private final Query query;
-
-    public CouchbaseConsumer(CouchbaseEndpoint endpoint, CouchbaseClient client, Processor processor) {
+    private final Bucket bucket;
+    private ViewOptions viewOptions;
+    private Collection collection;
 
+    public CouchbaseConsumer(CouchbaseEndpoint endpoint, Bucket client, Processor processor) {
         super(endpoint, processor);
-        this.client = client;
+        this.bucket = client;
         this.endpoint = endpoint;
-        this.view = client.getView(endpoint.getDesignDocumentName(), endpoint.getViewName());
-        this.query = new Query();
+        Scope scope;
+        if (!endpoint.getScope().equals(DEFAULT_SCOPE)) {","[{'comment': 'Instead of a default value that is _default. Then why not leave it as null/empty and then use that to know if a custom scope was set or not', 'commenter': 'davsclaus'}, {'comment': ""yeah, that's a valid point. Will do. "", 'commenter': 'mmelko'}]"
3944,components/camel-couchbase/src/main/java/org/apache/camel/component/couchbase/CouchbaseConsumer.java,"@@ -16,65 +16,76 @@
  */
 package org.apache.camel.component.couchbase;
 
-import com.couchbase.client.CouchbaseClient;
-import com.couchbase.client.protocol.views.Query;
-import com.couchbase.client.protocol.views.View;
-import com.couchbase.client.protocol.views.ViewResponse;
-import com.couchbase.client.protocol.views.ViewRow;
+import java.util.List;
+
+import com.couchbase.client.java.Bucket;
+import com.couchbase.client.java.Collection;
+import com.couchbase.client.java.Scope;
+import com.couchbase.client.java.view.ViewOptions;
+import com.couchbase.client.java.view.ViewOrdering;
+import com.couchbase.client.java.view.ViewResult;
+import com.couchbase.client.java.view.ViewRow;
 import org.apache.camel.Exchange;
 import org.apache.camel.Processor;
 import org.apache.camel.support.DefaultScheduledPollConsumer;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import static org.apache.camel.component.couchbase.CouchbaseConstants.HEADER_DESIGN_DOCUMENT_NAME;
-import static org.apache.camel.component.couchbase.CouchbaseConstants.HEADER_ID;
-import static org.apache.camel.component.couchbase.CouchbaseConstants.HEADER_KEY;
-import static org.apache.camel.component.couchbase.CouchbaseConstants.HEADER_VIEWNAME;
+import static org.apache.camel.component.couchbase.CouchbaseConstants.*;
 
 public class CouchbaseConsumer extends DefaultScheduledPollConsumer {
 
     private static final Logger LOG = LoggerFactory.getLogger(CouchbaseConsumer.class);
 
     private final CouchbaseEndpoint endpoint;
-    private final CouchbaseClient client;
-    private final View view;
-    private final Query query;
-
-    public CouchbaseConsumer(CouchbaseEndpoint endpoint, CouchbaseClient client, Processor processor) {
+    private final Bucket bucket;
+    private ViewOptions viewOptions;
+    private Collection collection;
 
+    public CouchbaseConsumer(CouchbaseEndpoint endpoint, Bucket client, Processor processor) {
         super(endpoint, processor);
-        this.client = client;
+        this.bucket = client;
         this.endpoint = endpoint;
-        this.view = client.getView(endpoint.getDesignDocumentName(), endpoint.getViewName());
-        this.query = new Query();
+        Scope scope;
+        if (!endpoint.getScope().equals(DEFAULT_SCOPE)) {
+            scope = client.scope(endpoint.getScope());
+        } else {
+            scope = client.defaultScope();
+        }
+
+        if (!endpoint.getCollection().equals(DEFAULT_COLLECTION)) {","[{'comment': 'The same as for default scope', 'commenter': 'davsclaus'}]"
3944,components/camel-couchbase/src/main/java/org/apache/camel/component/couchbase/CouchbaseEndpoint.java,"@@ -70,6 +71,12 @@
 
     @UriParam
     private String bucket;
+    //
+    @UriParam(defaultValue = ""_default"")
+    private String collection = DEFAULT_COLLECTION;","[{'comment': 'See my prev comments about default', 'commenter': 'davsclaus'}]"
3944,components/camel-couchbase/src/main/java/org/apache/camel/component/couchbase/CouchbaseEndpoint.java,"@@ -70,6 +71,12 @@
 
     @UriParam
     private String bucket;
+    //","[{'comment': 'Remove this', 'commenter': 'davsclaus'}]"
3944,components/camel-couchbase/src/main/java/org/apache/camel/component/couchbase/CouchbaseEndpoint.java,"@@ -225,6 +219,28 @@ public void setPort(int port) {
         this.port = port;
     }
 
+    /**
+     * The collection to use
+     */
+    public String getCollection() {
+        return this.collection;
+    }
+
+    public void setCollection(String collection) {
+        this.collection = collection;
+    }
+
+    public String getScope() {
+        return this.scope;
+    }
+
+    /**
+     * The scope to use","[{'comment': 'Do we know from couchbase what scopes is possible? If its like an enum then we can specify that via @UriParam so we have that information', 'commenter': 'davsclaus'}, {'comment': ""I believe you can create custom scopes with custom name .. so it's definitely not a enum."", 'commenter': 'mmelko'}]"
3944,components/camel-couchbase/src/main/java/org/apache/camel/component/couchbase/CouchbaseEndpoint.java,"@@ -434,98 +450,21 @@ public void setConsumerProcessedStrategy(String consumerProcessedStrategy) {
         this.consumerProcessedStrategy = consumerProcessedStrategy;
     }
 
-    public long getOpTimeOut() {
-        return opTimeOut;
+    public long getQueryTimeout() {
+        return queryTimeout;
     }
 
     /**
      * Define the operation timeout","[{'comment': 'in milli seconds', 'commenter': 'davsclaus'}]"
3944,components/camel-couchbase/src/main/java/org/apache/camel/component/couchbase/CouchbaseProducer.java,"@@ -149,21 +151,20 @@ private Boolean setDocument(String id, int expiry, Object obj, PersistTo persist
 
     private Boolean setDocument(String id, int expiry, Object obj, int retryAttempts, PersistTo persistTo, ReplicateTo replicateTo) throws Exception {
 
-        OperationFuture<Boolean> result = client.set(id, expiry, obj, persistTo, replicateTo);
+        UpsertOptions options = UpsertOptions.upsertOptions()
+                .expiry(Duration.ofSeconds(expiry))
+                .durability(persistTo, replicateTo)
+                .timeout(Duration.ofMillis(retryAttempts * producerRetryPause))
+                .retryStrategy(BestEffortRetryStrategy.withExponentialBackoff(Duration.ofMillis(producerRetryPause), Duration.ofMillis(producerRetryPause), 1));
+
         try {
-            if (!result.get()) {
-                throw new Exception(""Unable to save Document. "" + id);
-            }
-            return true;
+            MutationResult result = collection.upsert(id, obj, options);
+            LOG.debug(result.toString());","[{'comment': 'if isDebugEnabled', 'commenter': 'davsclaus'}]"
3944,components/camel-couchbase/src/main/java/org/apache/camel/component/couchbase/CouchbaseProducer.java,"@@ -149,21 +151,20 @@ private Boolean setDocument(String id, int expiry, Object obj, PersistTo persist
 
     private Boolean setDocument(String id, int expiry, Object obj, int retryAttempts, PersistTo persistTo, ReplicateTo replicateTo) throws Exception {
 
-        OperationFuture<Boolean> result = client.set(id, expiry, obj, persistTo, replicateTo);
+        UpsertOptions options = UpsertOptions.upsertOptions()
+                .expiry(Duration.ofSeconds(expiry))
+                .durability(persistTo, replicateTo)
+                .timeout(Duration.ofMillis(retryAttempts * producerRetryPause))
+                .retryStrategy(BestEffortRetryStrategy.withExponentialBackoff(Duration.ofMillis(producerRetryPause), Duration.ofMillis(producerRetryPause), 1));
+
         try {
-            if (!result.get()) {
-                throw new Exception(""Unable to save Document. "" + id);
-            }
-            return true;
+            MutationResult result = collection.upsert(id, obj, options);
+            LOG.debug(result.toString());
         } catch (Exception e) {
-            if (retryAttempts <= 0) {
-                throw e;
-            } else {
-                LOG.info(""Unable to save Document, retrying in "" + producerRetryPause + ""ms ("" + retryAttempts + "")"");
-                Thread.sleep(producerRetryPause);
-                return setDocument(id, expiry, obj, retryAttempts - 1, persistTo, replicateTo);
-            }
+            LOG.error(""Unable to save Document"");","[{'comment': 'Dont log and throw, just throw', 'commenter': 'davsclaus'}]"
3944,components/camel-couchbase/src/main/java/org/apache/camel/component/couchbase/CouchbaseComponent.java,"@@ -1,44 +1,44 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.camel.component.couchbase;
-
-import java.util.Map;
-
-import org.apache.camel.CamelContext;
-import org.apache.camel.spi.annotations.Component;
-import org.apache.camel.support.DefaultComponent;
-
-/**
- * Couchbase component.
- */
-@Component(""couchbase"")
-public class CouchbaseComponent extends DefaultComponent {
-
-    public CouchbaseComponent() {
-    }
-
-    public CouchbaseComponent(CamelContext context) {
-        super(context);
-    }
-
-    @Override
-    protected CouchbaseEndpoint createEndpoint(String uri, String remaining, Map<String, Object> parameters) throws Exception {
-        CouchbaseEndpoint endpoint = new CouchbaseEndpoint(uri, remaining, this);
-        setProperties(endpoint, parameters);
-        return endpoint;
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.couchbase;
+
+import java.util.Map;
+
+import org.apache.camel.CamelContext;
+import org.apache.camel.spi.annotations.Component;
+import org.apache.camel.support.DefaultComponent;
+
+/**
+ * Couchbase component.
+ */
+@Component(""couchbase"")
+public class  CouchbaseComponent extends DefaultComponent {","[{'comment': 'Formatting issues. Can you please take a look at your IDE settings perhaps?', 'commenter': 'omarsmak'}, {'comment': ""Thanks for comments. I'm running it with `sourcecheck` profile. I will recheck my IDE settings. "", 'commenter': 'mmelko'}]"
3944,components/camel-couchbase/src/main/java/org/apache/camel/component/couchbase/CouchbaseConstants.java,"@@ -28,6 +28,8 @@
     String COUCHBASE_DELETE = ""CCB_DEL"";
     String DEFAULT_DESIGN_DOCUMENT_NAME = ""beer"";
     String DEFAULT_VIEWNAME = ""brewery_beers"";
+    String  DEFAULT_COLLECTION = ""_default"";","[{'comment': 'here as well', 'commenter': 'omarsmak'}]"
3944,components/camel-couchbase/src/main/java/org/apache/camel/component/couchbase/CouchbaseConsumer.java,"@@ -16,65 +16,76 @@
  */
 package org.apache.camel.component.couchbase;
 
-import com.couchbase.client.CouchbaseClient;
-import com.couchbase.client.protocol.views.Query;
-import com.couchbase.client.protocol.views.View;
-import com.couchbase.client.protocol.views.ViewResponse;
-import com.couchbase.client.protocol.views.ViewRow;
+import java.util.List;
+
+import com.couchbase.client.java.Bucket;
+import com.couchbase.client.java.Collection;
+import com.couchbase.client.java.Scope;
+import com.couchbase.client.java.view.ViewOptions;
+import com.couchbase.client.java.view.ViewOrdering;
+import com.couchbase.client.java.view.ViewResult;
+import com.couchbase.client.java.view.ViewRow;
 import org.apache.camel.Exchange;
 import org.apache.camel.Processor;
 import org.apache.camel.support.DefaultScheduledPollConsumer;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import static org.apache.camel.component.couchbase.CouchbaseConstants.HEADER_DESIGN_DOCUMENT_NAME;
-import static org.apache.camel.component.couchbase.CouchbaseConstants.HEADER_ID;
-import static org.apache.camel.component.couchbase.CouchbaseConstants.HEADER_KEY;
-import static org.apache.camel.component.couchbase.CouchbaseConstants.HEADER_VIEWNAME;
+import static org.apache.camel.component.couchbase.CouchbaseConstants.*;","[{'comment': 'wildcard import. Please avoid it', 'commenter': 'omarsmak'}]"
3944,components/camel-couchbase/src/main/java/org/apache/camel/component/couchbase/CouchbaseEndpoint.java,"@@ -554,37 +493,32 @@ public void setObsTimeout(long obsTimeout) {
         return uriArray;
     }
 
-    private CouchbaseClient createClient() throws IOException, URISyntaxException {
+    //create from couchbase-client
+    private Bucket createClient() throws IOException, URISyntaxException {
         List<URI> hosts = Arrays.asList(makeBootstrapURI());
+        String connectionString;
 
-        CouchbaseConnectionFactoryBuilder cfb = new CouchbaseConnectionFactoryBuilder();
-
-        if (opTimeOut != DEFAULT_OP_TIMEOUT) {
-            cfb.setOpTimeout(opTimeOut);
+        ClusterEnvironment.Builder cfb = ClusterEnvironment.builder();
+        if (queryTimeout != DEFAULT_QUERY_TIMEOUT) {
+            cfb.timeoutConfig().queryTimeout(Duration.ofMillis(queryTimeout));
         }
-        if (timeoutExceptionThreshold != DEFAULT_TIMEOUT_EXCEPTION_THRESHOLD) {
-            cfb.setTimeoutExceptionThreshold(timeoutExceptionThreshold);
-        }
-        if (readBufferSize != DEFAULT_READ_BUFFER_SIZE) {
-            cfb.setReadBufferSize(readBufferSize);
-        }
-        if (shouldOptimize) {
-            cfb.setShouldOptimize(true);
-        }
-        if (maxReconnectDelay != DEFAULT_MAX_RECONNECT_DELAY) {
-            cfb.setMaxReconnectDelay(maxReconnectDelay);
-        }
-        if (opQueueMaxBlockTime != DEFAULT_OP_QUEUE_MAX_BLOCK_TIME) {
-            cfb.setOpQueueMaxBlockTime(opQueueMaxBlockTime);
-        }
-        if (obsPollInterval != DEFAULT_OBS_POLL_INTERVAL) {
-            cfb.setObsPollInterval(obsPollInterval);
-        }
-        if (obsTimeout != DEFAULT_OBS_TIMEOUT) {
-            cfb.setObsTimeout(obsTimeout);
+
+        ClusterEnvironment env = cfb.build();
+
+        String addHosts = hosts.stream()
+                .map(URI::getHost)
+                .collect(Collectors.joining("",""));
+
+        if (!"""".equals(addHosts)) {","[{'comment': ""This meant to check if is an empty string, isn't? Then wouldn't be better something like: \r\n`if(!addHosts.isEmpty())`"", 'commenter': 'omarsmak'}]"
3944,components/camel-couchbase/src/test/java/org/apache/camel/component/couchbase/CouchbaseProducerTest.java,"@@ -58,16 +66,21 @@
     private Message msg;
 
     @Mock
-    private OperationFuture<?> response;
+    private MutationResult response;
+//    Observable<String> myStringObservable","[{'comment': 'Need to remove this', 'commenter': 'davsclaus'}]"
3944,components/camel-couchbase/src/test/java/org/apache/camel/component/couchbase/CouchbaseProducerTest.java,"@@ -107,111 +120,28 @@ public void testMaximumValuesForPersistToAndRepicateTo() throws Exception {
         producer = new CouchbaseProducer(endpoint, client, 4, 3);
     }
 
+    //","[{'comment': 'Remove this', 'commenter': 'davsclaus'}]"
3970,components/camel-mail/src/test/java/org/apache/camel/dataformat/mime/multipart/MimeMultipartDataFormatTest.java,"@@ -261,9 +257,10 @@ public void marhsalOnlyMixed() throws IOException {
         headers.put(""X-AdditionalData"", ""additional data"");
         addAttachment(""application/octet-stream"", ""foobar"", ""attachment.bin"", headers);
         Exchange result = template.send(""direct:marshalonlymixed"", exchange);
-        assertThat(result.getOut().getHeader(""Content-Type"", String.class), startsWith(""multipart/mixed""));
-        String resultBody = result.getOut().getBody(String.class);
-        assertThat(resultBody, containsString(""Content-Description: Sample Attachment Data""));
+        assertTrue(result.getMessage().getHeader(""Content-Type"", String.class).startsWith(""multipart/mixed""));
+        //assertThat(result.getMessage().getHeader(""Content-Type"", String.class), startsWith(""multipart/mixed""));","[{'comment': 'I would remove this comment', 'commenter': 'aldettinger'}, {'comment': 'yes. I forgot that one !!', 'commenter': 'zbendhiba'}, {'comment': 'done !!', 'commenter': 'zbendhiba'}, {'comment': ""Well done @zbendhiba, it's rebased and pushed upstream now :)"", 'commenter': 'aldettinger'}]"
3983,components/camel-etcd3/pom.xml,"@@ -0,0 +1,162 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one or more
+    contributor license agreements.  See the NOTICE file distributed with
+    this work for additional information regarding copyright ownership.
+    The ASF licenses this file to You under the Apache License, Version 2.0
+    (the ""License""); you may not use this file except in compliance with
+    the License.  You may obtain a copy of the License at
+
+         http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an ""AS IS"" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+
+-->
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+
+    <modelVersion>4.0.0</modelVersion>
+
+    <parent>
+        <groupId>org.apache.camel</groupId>
+        <artifactId>components</artifactId>
+        <version>3.5.0-SNAPSHOT</version>
+    </parent>
+
+    <artifactId>camel-etcd3</artifactId>
+    <packaging>jar</packaging>
+    <name>Camel :: Etcd3</name>
+    <description>Camel Etcd3 support</description>
+
+    <dependencies>
+
+        <dependency>
+            <groupId>org.apache.camel</groupId>
+            <artifactId>camel-cloud</artifactId>
+        </dependency>
+
+        <!-- etcd -->
+        <dependency>
+            <groupId>org.mousio</groupId>","[{'comment': ""I don't think etcd4j is needed"", 'commenter': 'oscerd'}, {'comment': 'right, I remove this dependency', 'commenter': 'malogan82'}]"
3983,parent/pom.xml,"@@ -2021,6 +2027,11 @@
         <groupId>org.apache.camel</groupId>
         <artifactId>camel-reactor</artifactId>
         <version>${project.version}</version>
+      </dependency>
+	  <dependency>
+        <groupId>org.apache.camel</groupId>","[{'comment': ""I think camel-redis shouldn't be here"", 'commenter': 'oscerd'}]"
3983,camel-dependencies/pom.xml,"@@ -486,6 +487,7 @@
     <rdf4j-rio-version>2.4.4</rdf4j-rio-version>
     <reactive-streams-version>1.0.3</reactive-streams-version>
     <reactor-version>3.2.16.RELEASE</reactor-version>
+	<redisson-version>3.13.2</redisson-version>","[{'comment': 'does not seem to be related', 'commenter': 'lburgazzoli'}]"
3983,camel-dependencies/pom.xml,"@@ -332,6 +332,7 @@
     <jcr-version>2.0</jcr-version>
     <jedis-client-version>3.1.0</jedis-client-version>
     <jersey-version>2.28</jersey-version>
+	<jetcd-version>0.5.3</jetcd-version>","[{'comment': 'looks like this and other xml files have wrong indentation', 'commenter': 'lburgazzoli'}]"
3983,components/camel-etcd3/pom.xml,"@@ -0,0 +1,157 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one or more
+    contributor license agreements.  See the NOTICE file distributed with
+    this work for additional information regarding copyright ownership.
+    The ASF licenses this file to You under the Apache License, Version 2.0
+    (the ""License""); you may not use this file except in compliance with
+    the License.  You may obtain a copy of the License at
+
+         http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an ""AS IS"" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+
+-->
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+
+    <modelVersion>4.0.0</modelVersion>
+
+    <parent>
+        <groupId>org.apache.camel</groupId>
+        <artifactId>components</artifactId>
+        <version>3.5.0-SNAPSHOT</version>
+    </parent>
+
+    <artifactId>camel-etcd3</artifactId>
+    <packaging>jar</packaging>
+    <name>Camel :: Etcd3</name>
+    <description>Camel Etcd3 support</description>
+
+    <dependencies>
+
+        <dependency>
+            <groupId>org.apache.camel</groupId>
+            <artifactId>camel-cloud</artifactId>
+        </dependency>
+
+        <!-- etcd -->
+        <dependency>
+            <groupId>org.apache.commons</groupId>
+            <artifactId>commons-lang3</artifactId>
+            <version>${commons-lang3-version}</version>
+        </dependency>
+        
+        <dependency>
+            <groupId>io.etcd</groupId>
+            <artifactId>jetcd-all</artifactId>
+            <version>${jetcd-version}</version>
+        </dependency>
+
+        <dependency>
+            <groupId>io.etcd</groupId>
+            <artifactId>jetcd-core</artifactId>","[{'comment': 'either you use `jetcd-all` or you use `jetcd-core` as `jetcd-all` shades all the `jetcd` artefacts and dependencies', 'commenter': 'lburgazzoli'}]"
3983,components/camel-etcd3/pom.xml,"@@ -0,0 +1,157 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one or more
+    contributor license agreements.  See the NOTICE file distributed with
+    this work for additional information regarding copyright ownership.
+    The ASF licenses this file to You under the Apache License, Version 2.0
+    (the ""License""); you may not use this file except in compliance with
+    the License.  You may obtain a copy of the License at
+
+         http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an ""AS IS"" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+
+-->
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+
+    <modelVersion>4.0.0</modelVersion>
+
+    <parent>
+        <groupId>org.apache.camel</groupId>
+        <artifactId>components</artifactId>
+        <version>3.5.0-SNAPSHOT</version>
+    </parent>
+
+    <artifactId>camel-etcd3</artifactId>
+    <packaging>jar</packaging>
+    <name>Camel :: Etcd3</name>
+    <description>Camel Etcd3 support</description>
+
+    <dependencies>
+
+        <dependency>
+            <groupId>org.apache.camel</groupId>
+            <artifactId>camel-cloud</artifactId>
+        </dependency>
+
+        <!-- etcd -->
+        <dependency>
+            <groupId>org.apache.commons</groupId>
+            <artifactId>commons-lang3</artifactId>
+            <version>${commons-lang3-version}</version>
+        </dependency>
+        
+        <dependency>
+            <groupId>io.etcd</groupId>
+            <artifactId>jetcd-all</artifactId>
+            <version>${jetcd-version}</version>
+        </dependency>
+
+        <dependency>
+            <groupId>io.etcd</groupId>
+            <artifactId>jetcd-core</artifactId>
+            <version>${jetcd-version}</version>
+        </dependency>
+
+        <!-- logging -->
+        <dependency>
+            <groupId>org.apache.logging.log4j</groupId>
+            <artifactId>log4j-slf4j-impl</artifactId>
+            <scope>test</scope>
+        </dependency>
+
+        <!-- testing -->
+        <dependency>
+            <groupId>org.apache.camel</groupId>
+            <artifactId>camel-testcontainers-spring-junit5</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.apache.camel</groupId>
+            <artifactId>camel-testcontainers-junit5</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.apache.camel</groupId>
+            <artifactId>camel-http</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.apache.camel</groupId>
+            <artifactId>camel-jetty</artifactId>
+            <scope>test</scope>
+        </dependency>
+","[{'comment': 'Those dependencies need to be leaned up and you also need to add some test case for the aggregation repository', 'commenter': 'lburgazzoli'}]"
3983,components/camel-etcd3/src/main/java/org/apache/camel/component/etcd3/processor/aggregate/Etcd3AggregationRepository.java,"@@ -0,0 +1,459 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.camel.component.etcd3.processor.aggregate;
+
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.ObjectInputStream;
+import java.io.ObjectOutputStream;
+import java.util.Collections;
+import java.util.List;
+import java.util.Set;
+import java.util.TreeSet;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.TimeUnit;
+
+import org.apache.camel.CamelContext;
+import org.apache.camel.Exchange;
+import org.apache.camel.impl.DefaultExchange;
+import org.apache.camel.impl.DefaultExchangeHolder;
+import org.apache.camel.spi.OptimisticLockingAggregationRepository;
+import org.apache.camel.spi.RecoverableAggregationRepository;
+import org.apache.camel.support.ServiceSupport;
+import org.apache.camel.util.StringHelper;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import io.etcd.jetcd.ByteSequence;
+import io.etcd.jetcd.Client;
+import io.etcd.jetcd.KV;
+import io.etcd.jetcd.KeyValue;
+import io.etcd.jetcd.Lock;
+import io.etcd.jetcd.Txn;
+import io.etcd.jetcd.kv.DeleteResponse;
+import io.etcd.jetcd.kv.GetResponse;
+import io.etcd.jetcd.kv.PutResponse;
+import io.etcd.jetcd.op.Cmp;
+import io.etcd.jetcd.op.CmpTarget;
+import io.etcd.jetcd.op.Op;
+import io.etcd.jetcd.options.DeleteOption;
+import io.etcd.jetcd.options.GetOption;
+import io.etcd.jetcd.options.PutOption;
+
+public class Etcd3AggregationRepository extends ServiceSupport
+		implements RecoverableAggregationRepository, OptimisticLockingAggregationRepository {
+	private static final Logger LOG = LoggerFactory.getLogger(Etcd3AggregationRepository.class.getName());
+	private static final String COMPLETED_SUFFIX = ""-completed"";
+
+	private boolean optimistic;
+	private boolean useRecovery = true;
+	private String endpoint;
+	private Client client;
+	private KV kvClient;
+	private String prefixName;
+	private String persistencePrefixName;
+	private String deadLetterChannel;
+	private long recoveryInterval = 5000;
+	private int maximumRedeliveries = 3;
+	private boolean allowSerializedHeaders;
+
+	public Etcd3AggregationRepository(final String prefixName, final String endpoint) {
+		this.prefixName = prefixName;
+		this.persistencePrefixName = String.format(""%s%s"", prefixName, COMPLETED_SUFFIX);
+		this.optimistic = false;
+		this.endpoint = endpoint;
+	}
+
+	public Etcd3AggregationRepository(final String prefixName, final String persistencePrefixName,
+			final String endpoint) {
+		this.prefixName = prefixName;
+		this.persistencePrefixName = persistencePrefixName;
+		this.optimistic = false;
+		this.endpoint = endpoint;
+	}
+
+	public Etcd3AggregationRepository(final String prefixName, final String endpoint, boolean optimistic) {
+		this(prefixName, endpoint);
+		this.optimistic = optimistic;
+	}
+
+	public Etcd3AggregationRepository(final String repositoryName, final String persistentRepositoryName,
+			final String endpoint, boolean optimistic) {
+		this(repositoryName, persistentRepositoryName, endpoint);
+		this.optimistic = optimistic;
+	}
+
+	@Override
+	public Exchange add(CamelContext camelContext, String key, Exchange oldExchange, Exchange newExchange)
+			throws OptimisticLockingException {
+		if (!optimistic) {
+			throw new UnsupportedOperationException();
+		}
+		LOG.trace(""Adding an Exchange with ID {} for key {} in an optimistic manner."", newExchange.getExchangeId(),
+				key);
+		try {
+			if (oldExchange == null) {
+				DefaultExchangeHolder holder = DefaultExchangeHolder.marshal(newExchange, true, allowSerializedHeaders);
+				CompletableFuture<GetResponse> completableGetResponse = kvClient
+						.get(ByteSequence.from(String.format(""%s/%s"", prefixName, key).getBytes()));
+				GetResponse getResponse = completableGetResponse.get();
+				List<KeyValue> keyValues = getResponse.getKvs();
+				if (keyValues.isEmpty()) {
+					ByteArrayOutputStream bos = new ByteArrayOutputStream();
+					ObjectOutputStream oos = new ObjectOutputStream(bos);
+					oos.writeObject(holder);
+					oos.flush();
+					byte[] data = bos.toByteArray();
+					CompletableFuture<PutResponse> completablePutResponse = kvClient.put(
+							ByteSequence.from(String.format(""%s/%s"", prefixName, key).getBytes()),
+							ByteSequence.from(data));
+					completablePutResponse.get();
+				} else {
+					byte[] data = keyValues.get(0).getValue().getBytes();
+					ByteArrayInputStream in = new ByteArrayInputStream(data);
+					ObjectInputStream is = new ObjectInputStream(in);
+					DefaultExchangeHolder misbehaviorHolder = (DefaultExchangeHolder) is.readObject();
+					Exchange misbehaviorEx = unmarshallExchange(camelContext, misbehaviorHolder);
+					LOG.error(
+							""Optimistic locking failed for exchange with key {}: kvClient.get returned Exchange with ID {}, while it's expected no exchanges to be returned"",
+							key, misbehaviorEx != null ? misbehaviorEx.getExchangeId() : ""<null>"");
+					throw new OptimisticLockingException();
+				}
+			} else {
+				DefaultExchangeHolder newHolder = DefaultExchangeHolder.marshal(newExchange, true,
+						allowSerializedHeaders);
+				ByteArrayOutputStream bos = new ByteArrayOutputStream();
+				ObjectOutputStream oos = new ObjectOutputStream(bos);
+				oos.writeObject(newHolder);
+				oos.flush();
+				byte[] data = bos.toByteArray();
+				CompletableFuture<DeleteResponse> completableDeleteResponse = kvClient
+						.delete(ByteSequence.from(String.format(""%s/%s"", prefixName, key).getBytes()));
+				DeleteResponse deleteResponse = completableDeleteResponse.get();
+				if (deleteResponse.getDeleted() == 0) {
+					LOG.error(
+							""Optimistic locking failed for exchange with key {}: kvClient.get returned no Exchanges, while it's expected to replace one"",
+							key);
+					throw new OptimisticLockingException();
+				}
+				CompletableFuture<PutResponse> completablePutResponse = kvClient.put(
+						ByteSequence.from(String.format(""%s/%s"", prefixName, key).getBytes()), ByteSequence.from(data));
+				completablePutResponse.get();
+			}
+		} catch (InterruptedException | ExecutionException | IOException | ClassNotFoundException e) {
+			LOG.error(e.getMessage(), e);
+			throw new OptimisticLockingException();
+		}
+		LOG.trace(""Added an Exchange with ID {} for key {} in optimistic manner."", newExchange.getExchangeId(), key);
+		return oldExchange;
+	}
+
+	@Override
+	public Exchange add(CamelContext camelContext, String key, Exchange exchange) {
+		if (optimistic) {
+			throw new UnsupportedOperationException();
+		}
+		LOG.trace(""Adding an Exchange with ID {} for key {} in a thread-safe manner."", exchange.getExchangeId(), key);
+		Lock lock = null;
+		DefaultExchangeHolder newHolder = DefaultExchangeHolder.marshal(exchange, true, allowSerializedHeaders);
+		try {
+			lock = client.getLockClient();
+			lock.lock(ByteSequence.from(key.getBytes()), 60000);","[{'comment': ""the lease id need to be obtained from the `LeaseClient` and not hard-coded, however the `lock` APIs may not behave as you'd expect, see [notes-on-the-usage-of-lock-and-lease](https://github.com/etcd-io/etcd/blob/master/Documentation/learning/why.md#notes-on-the-usage-of-lock-and-lease).\r\n\r\nIt may be better to use transactions as you can specify the conditions to be met when performing the operation."", 'commenter': 'lburgazzoli'}, {'comment': ""I think I should have fixed this issue, using transaction as you suggested, I've also fixed the other issues in Etcd3AggregationRepository class, meanwhile I'll fix indentation problems on xml files and add some test cases,\r\nthanks"", 'commenter': 'malogan82'}]"
3983,components/camel-etcd3/src/main/java/org/apache/camel/component/etcd3/processor/aggregate/Etcd3AggregationRepository.java,"@@ -0,0 +1,459 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.camel.component.etcd3.processor.aggregate;
+
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.ObjectInputStream;
+import java.io.ObjectOutputStream;
+import java.util.Collections;
+import java.util.List;
+import java.util.Set;
+import java.util.TreeSet;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.TimeUnit;
+
+import org.apache.camel.CamelContext;
+import org.apache.camel.Exchange;
+import org.apache.camel.impl.DefaultExchange;
+import org.apache.camel.impl.DefaultExchangeHolder;
+import org.apache.camel.spi.OptimisticLockingAggregationRepository;
+import org.apache.camel.spi.RecoverableAggregationRepository;
+import org.apache.camel.support.ServiceSupport;
+import org.apache.camel.util.StringHelper;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import io.etcd.jetcd.ByteSequence;
+import io.etcd.jetcd.Client;
+import io.etcd.jetcd.KV;
+import io.etcd.jetcd.KeyValue;
+import io.etcd.jetcd.Lock;
+import io.etcd.jetcd.Txn;
+import io.etcd.jetcd.kv.DeleteResponse;
+import io.etcd.jetcd.kv.GetResponse;
+import io.etcd.jetcd.kv.PutResponse;
+import io.etcd.jetcd.op.Cmp;
+import io.etcd.jetcd.op.CmpTarget;
+import io.etcd.jetcd.op.Op;
+import io.etcd.jetcd.options.DeleteOption;
+import io.etcd.jetcd.options.GetOption;
+import io.etcd.jetcd.options.PutOption;
+
+public class Etcd3AggregationRepository extends ServiceSupport
+		implements RecoverableAggregationRepository, OptimisticLockingAggregationRepository {
+	private static final Logger LOG = LoggerFactory.getLogger(Etcd3AggregationRepository.class.getName());
+	private static final String COMPLETED_SUFFIX = ""-completed"";
+
+	private boolean optimistic;
+	private boolean useRecovery = true;
+	private String endpoint;
+	private Client client;
+	private KV kvClient;
+	private String prefixName;
+	private String persistencePrefixName;
+	private String deadLetterChannel;
+	private long recoveryInterval = 5000;
+	private int maximumRedeliveries = 3;
+	private boolean allowSerializedHeaders;
+
+	public Etcd3AggregationRepository(final String prefixName, final String endpoint) {
+		this.prefixName = prefixName;
+		this.persistencePrefixName = String.format(""%s%s"", prefixName, COMPLETED_SUFFIX);
+		this.optimistic = false;
+		this.endpoint = endpoint;
+	}
+
+	public Etcd3AggregationRepository(final String prefixName, final String persistencePrefixName,
+			final String endpoint) {
+		this.prefixName = prefixName;
+		this.persistencePrefixName = persistencePrefixName;
+		this.optimistic = false;
+		this.endpoint = endpoint;
+	}
+
+	public Etcd3AggregationRepository(final String prefixName, final String endpoint, boolean optimistic) {
+		this(prefixName, endpoint);
+		this.optimistic = optimistic;
+	}
+
+	public Etcd3AggregationRepository(final String repositoryName, final String persistentRepositoryName,
+			final String endpoint, boolean optimistic) {
+		this(repositoryName, persistentRepositoryName, endpoint);
+		this.optimistic = optimistic;
+	}
+
+	@Override
+	public Exchange add(CamelContext camelContext, String key, Exchange oldExchange, Exchange newExchange)
+			throws OptimisticLockingException {
+		if (!optimistic) {
+			throw new UnsupportedOperationException();
+		}
+		LOG.trace(""Adding an Exchange with ID {} for key {} in an optimistic manner."", newExchange.getExchangeId(),
+				key);
+		try {
+			if (oldExchange == null) {
+				DefaultExchangeHolder holder = DefaultExchangeHolder.marshal(newExchange, true, allowSerializedHeaders);
+				CompletableFuture<GetResponse> completableGetResponse = kvClient
+						.get(ByteSequence.from(String.format(""%s/%s"", prefixName, key).getBytes()));
+				GetResponse getResponse = completableGetResponse.get();
+				List<KeyValue> keyValues = getResponse.getKvs();
+				if (keyValues.isEmpty()) {
+					ByteArrayOutputStream bos = new ByteArrayOutputStream();
+					ObjectOutputStream oos = new ObjectOutputStream(bos);
+					oos.writeObject(holder);
+					oos.flush();
+					byte[] data = bos.toByteArray();
+					CompletableFuture<PutResponse> completablePutResponse = kvClient.put(
+							ByteSequence.from(String.format(""%s/%s"", prefixName, key).getBytes()),
+							ByteSequence.from(data));
+					completablePutResponse.get();
+				} else {
+					byte[] data = keyValues.get(0).getValue().getBytes();
+					ByteArrayInputStream in = new ByteArrayInputStream(data);
+					ObjectInputStream is = new ObjectInputStream(in);
+					DefaultExchangeHolder misbehaviorHolder = (DefaultExchangeHolder) is.readObject();
+					Exchange misbehaviorEx = unmarshallExchange(camelContext, misbehaviorHolder);
+					LOG.error(
+							""Optimistic locking failed for exchange with key {}: kvClient.get returned Exchange with ID {}, while it's expected no exchanges to be returned"",
+							key, misbehaviorEx != null ? misbehaviorEx.getExchangeId() : ""<null>"");
+					throw new OptimisticLockingException();
+				}
+			} else {
+				DefaultExchangeHolder newHolder = DefaultExchangeHolder.marshal(newExchange, true,
+						allowSerializedHeaders);
+				ByteArrayOutputStream bos = new ByteArrayOutputStream();
+				ObjectOutputStream oos = new ObjectOutputStream(bos);
+				oos.writeObject(newHolder);
+				oos.flush();
+				byte[] data = bos.toByteArray();
+				CompletableFuture<DeleteResponse> completableDeleteResponse = kvClient
+						.delete(ByteSequence.from(String.format(""%s/%s"", prefixName, key).getBytes()));
+				DeleteResponse deleteResponse = completableDeleteResponse.get();
+				if (deleteResponse.getDeleted() == 0) {
+					LOG.error(
+							""Optimistic locking failed for exchange with key {}: kvClient.get returned no Exchanges, while it's expected to replace one"",
+							key);
+					throw new OptimisticLockingException();
+				}
+				CompletableFuture<PutResponse> completablePutResponse = kvClient.put(
+						ByteSequence.from(String.format(""%s/%s"", prefixName, key).getBytes()), ByteSequence.from(data));
+				completablePutResponse.get();
+			}
+		} catch (InterruptedException | ExecutionException | IOException | ClassNotFoundException e) {
+			LOG.error(e.getMessage(), e);
+			throw new OptimisticLockingException();
+		}
+		LOG.trace(""Added an Exchange with ID {} for key {} in optimistic manner."", newExchange.getExchangeId(), key);
+		return oldExchange;
+	}
+
+	@Override
+	public Exchange add(CamelContext camelContext, String key, Exchange exchange) {
+		if (optimistic) {
+			throw new UnsupportedOperationException();
+		}
+		LOG.trace(""Adding an Exchange with ID {} for key {} in a thread-safe manner."", exchange.getExchangeId(), key);
+		Lock lock = null;
+		DefaultExchangeHolder newHolder = DefaultExchangeHolder.marshal(exchange, true, allowSerializedHeaders);
+		try {
+			lock = client.getLockClient();
+			lock.lock(ByteSequence.from(key.getBytes()), 60000);
+			ByteArrayOutputStream bos = new ByteArrayOutputStream();
+			ObjectOutputStream oos = new ObjectOutputStream(bos);
+			oos.writeObject(newHolder);
+			oos.flush();
+			byte[] data = bos.toByteArray();
+			CompletableFuture<PutResponse> completablePutResponse = kvClient.put(
+					ByteSequence.from(String.format(""%s/%s"", prefixName, key).getBytes()), ByteSequence.from(data));
+			completablePutResponse.get();
+		} catch (InterruptedException | ExecutionException | IOException e) {
+			LOG.error(e.getMessage(), e);
+		} finally {
+			if (lock != null) {
+				lock.unlock(ByteSequence.from(key.getBytes()));
+			}
+		}
+		return unmarshallExchange(camelContext, newHolder);
+	}
+
+	@Override
+	public Set<String> scan(CamelContext camelContext) {
+		if (useRecovery) {
+			LOG.trace(""Scanning for exchanges to recover in {} context"", camelContext.getName());
+			CompletableFuture<GetResponse> completableGetResponse = kvClient.get(
+					ByteSequence.from(persistencePrefixName.getBytes()),
+					GetOption.newBuilder().withPrefix(ByteSequence.from(persistencePrefixName.getBytes())).build());
+			Set<String> scanned = Collections.unmodifiableSet(new TreeSet<>());
+			try {
+				GetResponse getResponse = completableGetResponse.get();
+				Set<String> keys = new TreeSet<>();
+				getResponse.getKvs().forEach(kv -> keys.add(new String(kv.getKey().getBytes())));
+				scanned = Collections.unmodifiableSet(keys);
+				LOG.trace(""Found {} keys for exchanges to recover in {} context"", scanned.size(),
+						camelContext.getName());
+			} catch (InterruptedException | ExecutionException e) {
+				LOG.error(e.getMessage(), e);
+			}
+			return scanned;
+		} else {
+			LOG.warn(
+					""What for to run recovery scans in {} context while prefix {} is running in non-recoverable aggregation repository mode?!"",
+					camelContext.getName(), prefixName);
+			return Collections.emptySet();
+		}
+	}
+
+	@Override
+	public Exchange recover(CamelContext camelContext, String exchangeId) {
+		LOG.trace(""Recovering an Exchange with ID {}."", exchangeId);
+		CompletableFuture<GetResponse> completableResponse = kvClient
+				.get(ByteSequence.from(String.format(""%s/%s"", persistencePrefixName, exchangeId).getBytes()));
+		try {
+			GetResponse getResponse = completableResponse.get();
+			byte[] data = getResponse.getKvs().get(0).getValue().getBytes();
+			ByteArrayInputStream in = new ByteArrayInputStream(data);
+			ObjectInputStream is = new ObjectInputStream(in);
+			DefaultExchangeHolder holder = (DefaultExchangeHolder) is.readObject();
+			return useRecovery ? unmarshallExchange(camelContext, holder) : null;
+		} catch (InterruptedException | ExecutionException | IOException | ClassNotFoundException e) {
+			LOG.error(e.getMessage(), e);
+		}
+		return null;
+	}
+
+	@Override
+	public void setRecoveryInterval(long interval, TimeUnit timeUnit) {
+		this.recoveryInterval = timeUnit.toMillis(interval);
+	}
+
+	@Override
+	public void setRecoveryInterval(long interval) {
+		this.recoveryInterval = interval;
+	}
+
+	@Override
+	public long getRecoveryIntervalInMillis() {
+		return recoveryInterval;
+	}
+
+	@Override
+	public void setUseRecovery(boolean useRecovery) {
+		this.useRecovery = useRecovery;
+	}
+
+	@Override
+	public boolean isUseRecovery() {
+		return useRecovery;
+	}
+
+	@Override
+	public void setDeadLetterUri(String deadLetterUri) {
+		this.deadLetterChannel = deadLetterUri;
+	}
+
+	@Override
+	public String getDeadLetterUri() {
+		return deadLetterChannel;
+	}
+
+	@Override
+	public void setMaximumRedeliveries(int maximumRedeliveries) {
+		this.maximumRedeliveries = maximumRedeliveries;
+	}
+
+	@Override
+	public int getMaximumRedeliveries() {
+		return maximumRedeliveries;
+	}
+
+	@Override
+	public Exchange get(CamelContext camelContext, String key) {
+		CompletableFuture<GetResponse> completableResponse = kvClient
+				.get(ByteSequence.from(String.format(""%s/%s"", prefixName, key).getBytes()));
+		try {
+			GetResponse getResponse = completableResponse.get();
+			byte[] data = getResponse.getKvs().get(0).getValue().getBytes();
+			ByteArrayInputStream in = new ByteArrayInputStream(data);
+			ObjectInputStream is = new ObjectInputStream(in);
+			DefaultExchangeHolder holder = (DefaultExchangeHolder) is.readObject();
+			return unmarshallExchange(camelContext, holder);
+		} catch (InterruptedException | ExecutionException | IOException | ClassNotFoundException e) {
+			LOG.error(e.getMessage(), e);
+		}
+		return null;
+	}
+
+	public boolean isAllowSerializedHeaders() {
+		return allowSerializedHeaders;
+	}
+
+	public void setAllowSerializedHeaders(boolean allowSerializedHeaders) {
+		this.allowSerializedHeaders = allowSerializedHeaders;
+	}
+
+	@Override
+	public void remove(CamelContext camelContext, String key, Exchange exchange) {
+		DefaultExchangeHolder holder = DefaultExchangeHolder.marshal(exchange, true, allowSerializedHeaders);
+		if (optimistic) {
+			LOG.trace(""Removing an exchange with ID {} for key {} in an optimistic manner."", exchange.getExchangeId(),
+					key);
+			CompletableFuture<DeleteResponse> completableDeleteResponse = kvClient
+					.delete(ByteSequence.from(String.format(""%s/%s"", prefixName, key).getBytes()));
+			try {
+				DeleteResponse deleteResponse = completableDeleteResponse.get();
+				if (deleteResponse.getDeleted() == 0) {
+					LOG.error(
+							""Optimistic locking failed for exchange with key {}: kvClient.delete removed no Exchanges, while it's expected to remove one."",
+							key);
+					throw new OptimisticLockingException();
+				}
+			} catch (InterruptedException | ExecutionException e) {
+				LOG.error(e.getMessage(), e);
+			}
+			LOG.trace(""Removed an exchange with ID {} for key {} in an optimistic manner."", exchange.getExchangeId(),
+					key);
+			if (useRecovery) {
+				LOG.trace(
+						""Putting an exchange with ID {} for key {} into a recoverable storage in an optimistic manner."",
+						exchange.getExchangeId(), key);
+				try {
+					ByteArrayOutputStream bos = new ByteArrayOutputStream();
+					ObjectOutputStream oos = new ObjectOutputStream(bos);
+					oos.writeObject(holder);
+					oos.flush();
+					byte[] data = bos.toByteArray();
+					CompletableFuture<PutResponse> completablePutResponse = kvClient.put(
+							ByteSequence.from(String.format(""%s/%s"", persistencePrefixName, key).getBytes()),
+							ByteSequence.from(data));
+					completablePutResponse.get();
+					LOG.trace(
+							""Put an exchange with ID {} for key {} into a recoverable storage in an optimistic manner."",
+							exchange.getExchangeId(), key);
+				} catch (IOException | InterruptedException | ExecutionException e) {
+					LOG.error(e.getMessage(), e);
+				}
+
+			}
+		} else {
+			if (useRecovery) {
+				LOG.trace(""Removing an exchange with ID {} for key {} in a thread-safe manner."",
+						exchange.getExchangeId(), key);
+				Txn transaction = kvClient.txn();
+				try {
+					CompletableFuture<GetResponse> completableResponse = kvClient
+							.get(ByteSequence.from(String.format(""%s/%s"", prefixName, key).getBytes()));
+					GetResponse getResponse = completableResponse.get();
+					byte[] data = getResponse.getKvs().get(0).getValue().getBytes();
+					ByteArrayInputStream in = new ByteArrayInputStream(data);
+					ObjectInputStream is = new ObjectInputStream(in);
+					DefaultExchangeHolder removedHolder = (DefaultExchangeHolder) is.readObject();
+					ByteArrayOutputStream bos = new ByteArrayOutputStream();
+					ObjectOutputStream oos = new ObjectOutputStream(bos);
+					oos.writeObject(removedHolder);
+					oos.flush();
+					data = bos.toByteArray();
+					transaction
+							.If(new Cmp(ByteSequence.from(String.format(""%s/%s"", prefixName, key).getBytes()),
+									Cmp.Op.EQUAL,
+									CmpTarget.value(
+											ByteSequence.from(String.format(""%s/%s"", prefixName, key).getBytes()))))
+							.Then(Op.delete(ByteSequence.from(String.format(""%s/%s"", prefixName, key).getBytes()),
+									DeleteOption.DEFAULT),
+									Op.put(ByteSequence
+											.from(String.format(""%s/%s"", persistencePrefixName, key).getBytes()),
+											ByteSequence.from(data), PutOption.DEFAULT))
+							.commit();
+					LOG.trace(""Removed an exchange with ID {} for key {} in a thread-safe manner."",
+							exchange.getExchangeId(), key);
+					LOG.trace(
+							""Put an exchange with ID {} for key {} into a recoverable storage in a thread-safe manner."",
+							exchange.getExchangeId(), key);
+				} catch (Throwable throwable) {
+					throw new RuntimeException(throwable);
+				}
+			} else {
+				CompletableFuture<DeleteResponse> completableDeleteResponse = kvClient
+						.delete(ByteSequence.from(String.format(""%s/%s"", prefixName, key).getBytes()));
+				try {
+					completableDeleteResponse.get();
+				} catch (InterruptedException | ExecutionException e) {
+					LOG.error(e.getMessage(), e);
+				}
+			}
+		}
+	}
+
+	@Override
+	public void confirm(CamelContext camelContext, String exchangeId) {
+		LOG.trace(""Confirming an exchange with ID {}."", exchangeId);
+		if (useRecovery) {
+			CompletableFuture<DeleteResponse> completableDeleteResponse = kvClient
+					.delete(ByteSequence.from(String.format(""%s/%s"", persistencePrefixName, exchangeId).getBytes()));
+			try {
+				completableDeleteResponse.get();
+			} catch (InterruptedException | ExecutionException e) {
+				LOG.error(e.getMessage(), e);
+			}
+		}
+	}
+
+	@Override
+	public Set<String> getKeys() {
+		CompletableFuture<GetResponse> completableGetResponse = kvClient.get(ByteSequence.from(prefixName.getBytes()),
+				GetOption.newBuilder().withRange(ByteSequence.from(prefixName.getBytes())).build());
+		Set<String> scanned = Collections.unmodifiableSet(new TreeSet<>());
+		try {
+			GetResponse getResponse = completableGetResponse.get();
+			Set<String> keys = new TreeSet<>();
+			getResponse.getKvs().forEach(kv -> keys.add(new String(kv.getKey().getBytes())));
+			scanned = Collections.unmodifiableSet(keys);
+		} catch (InterruptedException | ExecutionException e) {
+			LOG.error(e.getMessage(), e);
+		}
+		return scanned;
+	}
+
+	@Override
+	protected void doStart() throws Exception {
+		if (maximumRedeliveries < 0) {
+			throw new IllegalArgumentException(""Maximum redelivery retries must be zero or a positive integer."");
+		}
+		if (recoveryInterval < 0) {
+			throw new IllegalArgumentException(""Recovery interval must be zero or a positive integer."");
+		}
+		StringHelper.notEmpty(prefixName, ""prefixName"");
+		client = Client.builder().endpoints(endpoint).build();
+		kvClient = client.getKVClient();
+	}
+
+	@Override
+	protected void doStop() throws Exception {
+		client.close();","[{'comment': 'Nee to check if client is `null`', 'commenter': 'lburgazzoli'}]"
3983,components/camel-etcd3/src/main/java/org/apache/camel/component/etcd3/processor/aggregate/Etcd3AggregationRepository.java,"@@ -0,0 +1,459 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.camel.component.etcd3.processor.aggregate;
+
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.ObjectInputStream;
+import java.io.ObjectOutputStream;
+import java.util.Collections;
+import java.util.List;
+import java.util.Set;
+import java.util.TreeSet;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.TimeUnit;
+
+import org.apache.camel.CamelContext;
+import org.apache.camel.Exchange;
+import org.apache.camel.impl.DefaultExchange;
+import org.apache.camel.impl.DefaultExchangeHolder;
+import org.apache.camel.spi.OptimisticLockingAggregationRepository;
+import org.apache.camel.spi.RecoverableAggregationRepository;
+import org.apache.camel.support.ServiceSupport;
+import org.apache.camel.util.StringHelper;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import io.etcd.jetcd.ByteSequence;
+import io.etcd.jetcd.Client;
+import io.etcd.jetcd.KV;
+import io.etcd.jetcd.KeyValue;
+import io.etcd.jetcd.Lock;
+import io.etcd.jetcd.Txn;
+import io.etcd.jetcd.kv.DeleteResponse;
+import io.etcd.jetcd.kv.GetResponse;
+import io.etcd.jetcd.kv.PutResponse;
+import io.etcd.jetcd.op.Cmp;
+import io.etcd.jetcd.op.CmpTarget;
+import io.etcd.jetcd.op.Op;
+import io.etcd.jetcd.options.DeleteOption;
+import io.etcd.jetcd.options.GetOption;
+import io.etcd.jetcd.options.PutOption;
+
+public class Etcd3AggregationRepository extends ServiceSupport
+		implements RecoverableAggregationRepository, OptimisticLockingAggregationRepository {
+	private static final Logger LOG = LoggerFactory.getLogger(Etcd3AggregationRepository.class.getName());
+	private static final String COMPLETED_SUFFIX = ""-completed"";
+
+	private boolean optimistic;
+	private boolean useRecovery = true;
+	private String endpoint;
+	private Client client;
+	private KV kvClient;
+	private String prefixName;
+	private String persistencePrefixName;
+	private String deadLetterChannel;
+	private long recoveryInterval = 5000;
+	private int maximumRedeliveries = 3;
+	private boolean allowSerializedHeaders;
+
+	public Etcd3AggregationRepository(final String prefixName, final String endpoint) {
+		this.prefixName = prefixName;
+		this.persistencePrefixName = String.format(""%s%s"", prefixName, COMPLETED_SUFFIX);
+		this.optimistic = false;
+		this.endpoint = endpoint;
+	}
+
+	public Etcd3AggregationRepository(final String prefixName, final String persistencePrefixName,
+			final String endpoint) {
+		this.prefixName = prefixName;
+		this.persistencePrefixName = persistencePrefixName;
+		this.optimistic = false;
+		this.endpoint = endpoint;
+	}
+
+	public Etcd3AggregationRepository(final String prefixName, final String endpoint, boolean optimistic) {
+		this(prefixName, endpoint);
+		this.optimistic = optimistic;
+	}
+
+	public Etcd3AggregationRepository(final String repositoryName, final String persistentRepositoryName,
+			final String endpoint, boolean optimistic) {
+		this(repositoryName, persistentRepositoryName, endpoint);
+		this.optimistic = optimistic;
+	}
+
+	@Override
+	public Exchange add(CamelContext camelContext, String key, Exchange oldExchange, Exchange newExchange)
+			throws OptimisticLockingException {
+		if (!optimistic) {
+			throw new UnsupportedOperationException();
+		}
+		LOG.trace(""Adding an Exchange with ID {} for key {} in an optimistic manner."", newExchange.getExchangeId(),
+				key);
+		try {
+			if (oldExchange == null) {
+				DefaultExchangeHolder holder = DefaultExchangeHolder.marshal(newExchange, true, allowSerializedHeaders);
+				CompletableFuture<GetResponse> completableGetResponse = kvClient
+						.get(ByteSequence.from(String.format(""%s/%s"", prefixName, key).getBytes()));
+				GetResponse getResponse = completableGetResponse.get();
+				List<KeyValue> keyValues = getResponse.getKvs();
+				if (keyValues.isEmpty()) {
+					ByteArrayOutputStream bos = new ByteArrayOutputStream();
+					ObjectOutputStream oos = new ObjectOutputStream(bos);
+					oos.writeObject(holder);
+					oos.flush();
+					byte[] data = bos.toByteArray();
+					CompletableFuture<PutResponse> completablePutResponse = kvClient.put(
+							ByteSequence.from(String.format(""%s/%s"", prefixName, key).getBytes()),
+							ByteSequence.from(data));
+					completablePutResponse.get();
+				} else {
+					byte[] data = keyValues.get(0).getValue().getBytes();
+					ByteArrayInputStream in = new ByteArrayInputStream(data);
+					ObjectInputStream is = new ObjectInputStream(in);
+					DefaultExchangeHolder misbehaviorHolder = (DefaultExchangeHolder) is.readObject();
+					Exchange misbehaviorEx = unmarshallExchange(camelContext, misbehaviorHolder);
+					LOG.error(
+							""Optimistic locking failed for exchange with key {}: kvClient.get returned Exchange with ID {}, while it's expected no exchanges to be returned"",
+							key, misbehaviorEx != null ? misbehaviorEx.getExchangeId() : ""<null>"");
+					throw new OptimisticLockingException();
+				}
+			} else {
+				DefaultExchangeHolder newHolder = DefaultExchangeHolder.marshal(newExchange, true,
+						allowSerializedHeaders);
+				ByteArrayOutputStream bos = new ByteArrayOutputStream();
+				ObjectOutputStream oos = new ObjectOutputStream(bos);
+				oos.writeObject(newHolder);
+				oos.flush();
+				byte[] data = bos.toByteArray();
+				CompletableFuture<DeleteResponse> completableDeleteResponse = kvClient
+						.delete(ByteSequence.from(String.format(""%s/%s"", prefixName, key).getBytes()));
+				DeleteResponse deleteResponse = completableDeleteResponse.get();
+				if (deleteResponse.getDeleted() == 0) {
+					LOG.error(
+							""Optimistic locking failed for exchange with key {}: kvClient.get returned no Exchanges, while it's expected to replace one"",
+							key);
+					throw new OptimisticLockingException();
+				}
+				CompletableFuture<PutResponse> completablePutResponse = kvClient.put(
+						ByteSequence.from(String.format(""%s/%s"", prefixName, key).getBytes()), ByteSequence.from(data));
+				completablePutResponse.get();
+			}
+		} catch (InterruptedException | ExecutionException | IOException | ClassNotFoundException e) {
+			LOG.error(e.getMessage(), e);
+			throw new OptimisticLockingException();
+		}
+		LOG.trace(""Added an Exchange with ID {} for key {} in optimistic manner."", newExchange.getExchangeId(), key);
+		return oldExchange;
+	}
+
+	@Override
+	public Exchange add(CamelContext camelContext, String key, Exchange exchange) {
+		if (optimistic) {
+			throw new UnsupportedOperationException();
+		}
+		LOG.trace(""Adding an Exchange with ID {} for key {} in a thread-safe manner."", exchange.getExchangeId(), key);
+		Lock lock = null;
+		DefaultExchangeHolder newHolder = DefaultExchangeHolder.marshal(exchange, true, allowSerializedHeaders);
+		try {
+			lock = client.getLockClient();
+			lock.lock(ByteSequence.from(key.getBytes()), 60000);
+			ByteArrayOutputStream bos = new ByteArrayOutputStream();
+			ObjectOutputStream oos = new ObjectOutputStream(bos);
+			oos.writeObject(newHolder);
+			oos.flush();
+			byte[] data = bos.toByteArray();
+			CompletableFuture<PutResponse> completablePutResponse = kvClient.put(
+					ByteSequence.from(String.format(""%s/%s"", prefixName, key).getBytes()), ByteSequence.from(data));
+			completablePutResponse.get();
+		} catch (InterruptedException | ExecutionException | IOException e) {
+			LOG.error(e.getMessage(), e);
+		} finally {
+			if (lock != null) {
+				lock.unlock(ByteSequence.from(key.getBytes()));
+			}
+		}
+		return unmarshallExchange(camelContext, newHolder);
+	}
+
+	@Override
+	public Set<String> scan(CamelContext camelContext) {
+		if (useRecovery) {
+			LOG.trace(""Scanning for exchanges to recover in {} context"", camelContext.getName());
+			CompletableFuture<GetResponse> completableGetResponse = kvClient.get(
+					ByteSequence.from(persistencePrefixName.getBytes()),
+					GetOption.newBuilder().withPrefix(ByteSequence.from(persistencePrefixName.getBytes())).build());
+			Set<String> scanned = Collections.unmodifiableSet(new TreeSet<>());
+			try {
+				GetResponse getResponse = completableGetResponse.get();
+				Set<String> keys = new TreeSet<>();
+				getResponse.getKvs().forEach(kv -> keys.add(new String(kv.getKey().getBytes())));
+				scanned = Collections.unmodifiableSet(keys);
+				LOG.trace(""Found {} keys for exchanges to recover in {} context"", scanned.size(),
+						camelContext.getName());
+			} catch (InterruptedException | ExecutionException e) {
+				LOG.error(e.getMessage(), e);
+			}
+			return scanned;
+		} else {
+			LOG.warn(
+					""What for to run recovery scans in {} context while prefix {} is running in non-recoverable aggregation repository mode?!"",
+					camelContext.getName(), prefixName);
+			return Collections.emptySet();
+		}
+	}
+
+	@Override
+	public Exchange recover(CamelContext camelContext, String exchangeId) {
+		LOG.trace(""Recovering an Exchange with ID {}."", exchangeId);
+		CompletableFuture<GetResponse> completableResponse = kvClient
+				.get(ByteSequence.from(String.format(""%s/%s"", persistencePrefixName, exchangeId).getBytes()));
+		try {
+			GetResponse getResponse = completableResponse.get();
+			byte[] data = getResponse.getKvs().get(0).getValue().getBytes();
+			ByteArrayInputStream in = new ByteArrayInputStream(data);
+			ObjectInputStream is = new ObjectInputStream(in);
+			DefaultExchangeHolder holder = (DefaultExchangeHolder) is.readObject();
+			return useRecovery ? unmarshallExchange(camelContext, holder) : null;
+		} catch (InterruptedException | ExecutionException | IOException | ClassNotFoundException e) {
+			LOG.error(e.getMessage(), e);
+		}
+		return null;
+	}
+
+	@Override
+	public void setRecoveryInterval(long interval, TimeUnit timeUnit) {
+		this.recoveryInterval = timeUnit.toMillis(interval);
+	}
+
+	@Override
+	public void setRecoveryInterval(long interval) {
+		this.recoveryInterval = interval;
+	}
+
+	@Override
+	public long getRecoveryIntervalInMillis() {
+		return recoveryInterval;
+	}
+
+	@Override
+	public void setUseRecovery(boolean useRecovery) {
+		this.useRecovery = useRecovery;
+	}
+
+	@Override
+	public boolean isUseRecovery() {
+		return useRecovery;
+	}
+
+	@Override
+	public void setDeadLetterUri(String deadLetterUri) {
+		this.deadLetterChannel = deadLetterUri;
+	}
+
+	@Override
+	public String getDeadLetterUri() {
+		return deadLetterChannel;
+	}
+
+	@Override
+	public void setMaximumRedeliveries(int maximumRedeliveries) {
+		this.maximumRedeliveries = maximumRedeliveries;
+	}
+
+	@Override
+	public int getMaximumRedeliveries() {
+		return maximumRedeliveries;
+	}
+
+	@Override
+	public Exchange get(CamelContext camelContext, String key) {
+		CompletableFuture<GetResponse> completableResponse = kvClient
+				.get(ByteSequence.from(String.format(""%s/%s"", prefixName, key).getBytes()));
+		try {
+			GetResponse getResponse = completableResponse.get();
+			byte[] data = getResponse.getKvs().get(0).getValue().getBytes();
+			ByteArrayInputStream in = new ByteArrayInputStream(data);
+			ObjectInputStream is = new ObjectInputStream(in);
+			DefaultExchangeHolder holder = (DefaultExchangeHolder) is.readObject();
+			return unmarshallExchange(camelContext, holder);
+		} catch (InterruptedException | ExecutionException | IOException | ClassNotFoundException e) {
+			LOG.error(e.getMessage(), e);
+		}
+		return null;
+	}
+
+	public boolean isAllowSerializedHeaders() {
+		return allowSerializedHeaders;
+	}
+
+	public void setAllowSerializedHeaders(boolean allowSerializedHeaders) {
+		this.allowSerializedHeaders = allowSerializedHeaders;
+	}
+
+	@Override
+	public void remove(CamelContext camelContext, String key, Exchange exchange) {
+		DefaultExchangeHolder holder = DefaultExchangeHolder.marshal(exchange, true, allowSerializedHeaders);
+		if (optimistic) {
+			LOG.trace(""Removing an exchange with ID {} for key {} in an optimistic manner."", exchange.getExchangeId(),
+					key);
+			CompletableFuture<DeleteResponse> completableDeleteResponse = kvClient
+					.delete(ByteSequence.from(String.format(""%s/%s"", prefixName, key).getBytes()));
+			try {
+				DeleteResponse deleteResponse = completableDeleteResponse.get();
+				if (deleteResponse.getDeleted() == 0) {
+					LOG.error(
+							""Optimistic locking failed for exchange with key {}: kvClient.delete removed no Exchanges, while it's expected to remove one."",
+							key);
+					throw new OptimisticLockingException();
+				}
+			} catch (InterruptedException | ExecutionException e) {
+				LOG.error(e.getMessage(), e);
+			}
+			LOG.trace(""Removed an exchange with ID {} for key {} in an optimistic manner."", exchange.getExchangeId(),
+					key);
+			if (useRecovery) {
+				LOG.trace(
+						""Putting an exchange with ID {} for key {} into a recoverable storage in an optimistic manner."",
+						exchange.getExchangeId(), key);
+				try {
+					ByteArrayOutputStream bos = new ByteArrayOutputStream();
+					ObjectOutputStream oos = new ObjectOutputStream(bos);
+					oos.writeObject(holder);
+					oos.flush();
+					byte[] data = bos.toByteArray();
+					CompletableFuture<PutResponse> completablePutResponse = kvClient.put(
+							ByteSequence.from(String.format(""%s/%s"", persistencePrefixName, key).getBytes()),
+							ByteSequence.from(data));
+					completablePutResponse.get();
+					LOG.trace(
+							""Put an exchange with ID {} for key {} into a recoverable storage in an optimistic manner."",
+							exchange.getExchangeId(), key);
+				} catch (IOException | InterruptedException | ExecutionException e) {
+					LOG.error(e.getMessage(), e);
+				}
+
+			}
+		} else {
+			if (useRecovery) {
+				LOG.trace(""Removing an exchange with ID {} for key {} in a thread-safe manner."",
+						exchange.getExchangeId(), key);
+				Txn transaction = kvClient.txn();
+				try {
+					CompletableFuture<GetResponse> completableResponse = kvClient
+							.get(ByteSequence.from(String.format(""%s/%s"", prefixName, key).getBytes()));
+					GetResponse getResponse = completableResponse.get();
+					byte[] data = getResponse.getKvs().get(0).getValue().getBytes();
+					ByteArrayInputStream in = new ByteArrayInputStream(data);
+					ObjectInputStream is = new ObjectInputStream(in);
+					DefaultExchangeHolder removedHolder = (DefaultExchangeHolder) is.readObject();
+					ByteArrayOutputStream bos = new ByteArrayOutputStream();
+					ObjectOutputStream oos = new ObjectOutputStream(bos);
+					oos.writeObject(removedHolder);
+					oos.flush();
+					data = bos.toByteArray();
+					transaction
+							.If(new Cmp(ByteSequence.from(String.format(""%s/%s"", prefixName, key).getBytes()),
+									Cmp.Op.EQUAL,
+									CmpTarget.value(
+											ByteSequence.from(String.format(""%s/%s"", prefixName, key).getBytes()))))
+							.Then(Op.delete(ByteSequence.from(String.format(""%s/%s"", prefixName, key).getBytes()),
+									DeleteOption.DEFAULT),
+									Op.put(ByteSequence
+											.from(String.format(""%s/%s"", persistencePrefixName, key).getBytes()),
+											ByteSequence.from(data), PutOption.DEFAULT))
+							.commit();
+					LOG.trace(""Removed an exchange with ID {} for key {} in a thread-safe manner."",
+							exchange.getExchangeId(), key);
+					LOG.trace(
+							""Put an exchange with ID {} for key {} into a recoverable storage in a thread-safe manner."",
+							exchange.getExchangeId(), key);
+				} catch (Throwable throwable) {
+					throw new RuntimeException(throwable);
+				}
+			} else {
+				CompletableFuture<DeleteResponse> completableDeleteResponse = kvClient
+						.delete(ByteSequence.from(String.format(""%s/%s"", prefixName, key).getBytes()));
+				try {
+					completableDeleteResponse.get();
+				} catch (InterruptedException | ExecutionException e) {
+					LOG.error(e.getMessage(), e);
+				}
+			}
+		}
+	}
+
+	@Override
+	public void confirm(CamelContext camelContext, String exchangeId) {
+		LOG.trace(""Confirming an exchange with ID {}."", exchangeId);
+		if (useRecovery) {
+			CompletableFuture<DeleteResponse> completableDeleteResponse = kvClient
+					.delete(ByteSequence.from(String.format(""%s/%s"", persistencePrefixName, exchangeId).getBytes()));
+			try {
+				completableDeleteResponse.get();
+			} catch (InterruptedException | ExecutionException e) {
+				LOG.error(e.getMessage(), e);
+			}
+		}
+	}
+
+	@Override
+	public Set<String> getKeys() {
+		CompletableFuture<GetResponse> completableGetResponse = kvClient.get(ByteSequence.from(prefixName.getBytes()),
+				GetOption.newBuilder().withRange(ByteSequence.from(prefixName.getBytes())).build());
+		Set<String> scanned = Collections.unmodifiableSet(new TreeSet<>());
+		try {
+			GetResponse getResponse = completableGetResponse.get();
+			Set<String> keys = new TreeSet<>();
+			getResponse.getKvs().forEach(kv -> keys.add(new String(kv.getKey().getBytes())));
+			scanned = Collections.unmodifiableSet(keys);
+		} catch (InterruptedException | ExecutionException e) {
+			LOG.error(e.getMessage(), e);
+		}
+		return scanned;
+	}
+
+	@Override
+	protected void doStart() throws Exception {
+		if (maximumRedeliveries < 0) {","[{'comment': 'Validation can be moved to `onInit` to check correctness of the parameters early', 'commenter': 'lburgazzoli'}]"
3983,components/camel-etcd3/src/main/java/org/apache/camel/component/etcd3/processor/aggregate/Etcd3AggregationRepository.java,"@@ -0,0 +1,459 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.camel.component.etcd3.processor.aggregate;
+
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.ObjectInputStream;
+import java.io.ObjectOutputStream;
+import java.util.Collections;
+import java.util.List;
+import java.util.Set;
+import java.util.TreeSet;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.TimeUnit;
+
+import org.apache.camel.CamelContext;
+import org.apache.camel.Exchange;
+import org.apache.camel.impl.DefaultExchange;
+import org.apache.camel.impl.DefaultExchangeHolder;
+import org.apache.camel.spi.OptimisticLockingAggregationRepository;
+import org.apache.camel.spi.RecoverableAggregationRepository;
+import org.apache.camel.support.ServiceSupport;
+import org.apache.camel.util.StringHelper;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import io.etcd.jetcd.ByteSequence;
+import io.etcd.jetcd.Client;
+import io.etcd.jetcd.KV;
+import io.etcd.jetcd.KeyValue;
+import io.etcd.jetcd.Lock;
+import io.etcd.jetcd.Txn;
+import io.etcd.jetcd.kv.DeleteResponse;
+import io.etcd.jetcd.kv.GetResponse;
+import io.etcd.jetcd.kv.PutResponse;
+import io.etcd.jetcd.op.Cmp;
+import io.etcd.jetcd.op.CmpTarget;
+import io.etcd.jetcd.op.Op;
+import io.etcd.jetcd.options.DeleteOption;
+import io.etcd.jetcd.options.GetOption;
+import io.etcd.jetcd.options.PutOption;
+
+public class Etcd3AggregationRepository extends ServiceSupport
+		implements RecoverableAggregationRepository, OptimisticLockingAggregationRepository {
+	private static final Logger LOG = LoggerFactory.getLogger(Etcd3AggregationRepository.class.getName());
+	private static final String COMPLETED_SUFFIX = ""-completed"";
+
+	private boolean optimistic;
+	private boolean useRecovery = true;
+	private String endpoint;
+	private Client client;
+	private KV kvClient;
+	private String prefixName;
+	private String persistencePrefixName;
+	private String deadLetterChannel;
+	private long recoveryInterval = 5000;
+	private int maximumRedeliveries = 3;
+	private boolean allowSerializedHeaders;
+
+	public Etcd3AggregationRepository(final String prefixName, final String endpoint) {
+		this.prefixName = prefixName;
+		this.persistencePrefixName = String.format(""%s%s"", prefixName, COMPLETED_SUFFIX);
+		this.optimistic = false;
+		this.endpoint = endpoint;
+	}
+
+	public Etcd3AggregationRepository(final String prefixName, final String persistencePrefixName,
+			final String endpoint) {
+		this.prefixName = prefixName;
+		this.persistencePrefixName = persistencePrefixName;
+		this.optimistic = false;
+		this.endpoint = endpoint;
+	}
+
+	public Etcd3AggregationRepository(final String prefixName, final String endpoint, boolean optimistic) {
+		this(prefixName, endpoint);
+		this.optimistic = optimistic;
+	}
+
+	public Etcd3AggregationRepository(final String repositoryName, final String persistentRepositoryName,
+			final String endpoint, boolean optimistic) {
+		this(repositoryName, persistentRepositoryName, endpoint);
+		this.optimistic = optimistic;
+	}
+
+	@Override
+	public Exchange add(CamelContext camelContext, String key, Exchange oldExchange, Exchange newExchange)
+			throws OptimisticLockingException {
+		if (!optimistic) {
+			throw new UnsupportedOperationException();
+		}
+		LOG.trace(""Adding an Exchange with ID {} for key {} in an optimistic manner."", newExchange.getExchangeId(),
+				key);
+		try {
+			if (oldExchange == null) {
+				DefaultExchangeHolder holder = DefaultExchangeHolder.marshal(newExchange, true, allowSerializedHeaders);
+				CompletableFuture<GetResponse> completableGetResponse = kvClient
+						.get(ByteSequence.from(String.format(""%s/%s"", prefixName, key).getBytes()));
+				GetResponse getResponse = completableGetResponse.get();
+				List<KeyValue> keyValues = getResponse.getKvs();
+				if (keyValues.isEmpty()) {
+					ByteArrayOutputStream bos = new ByteArrayOutputStream();
+					ObjectOutputStream oos = new ObjectOutputStream(bos);
+					oos.writeObject(holder);
+					oos.flush();
+					byte[] data = bos.toByteArray();
+					CompletableFuture<PutResponse> completablePutResponse = kvClient.put(
+							ByteSequence.from(String.format(""%s/%s"", prefixName, key).getBytes()),
+							ByteSequence.from(data));
+					completablePutResponse.get();
+				} else {
+					byte[] data = keyValues.get(0).getValue().getBytes();
+					ByteArrayInputStream in = new ByteArrayInputStream(data);
+					ObjectInputStream is = new ObjectInputStream(in);
+					DefaultExchangeHolder misbehaviorHolder = (DefaultExchangeHolder) is.readObject();
+					Exchange misbehaviorEx = unmarshallExchange(camelContext, misbehaviorHolder);
+					LOG.error(
+							""Optimistic locking failed for exchange with key {}: kvClient.get returned Exchange with ID {}, while it's expected no exchanges to be returned"",
+							key, misbehaviorEx != null ? misbehaviorEx.getExchangeId() : ""<null>"");
+					throw new OptimisticLockingException();
+				}
+			} else {
+				DefaultExchangeHolder newHolder = DefaultExchangeHolder.marshal(newExchange, true,
+						allowSerializedHeaders);
+				ByteArrayOutputStream bos = new ByteArrayOutputStream();
+				ObjectOutputStream oos = new ObjectOutputStream(bos);
+				oos.writeObject(newHolder);
+				oos.flush();
+				byte[] data = bos.toByteArray();
+				CompletableFuture<DeleteResponse> completableDeleteResponse = kvClient
+						.delete(ByteSequence.from(String.format(""%s/%s"", prefixName, key).getBytes()));
+				DeleteResponse deleteResponse = completableDeleteResponse.get();
+				if (deleteResponse.getDeleted() == 0) {
+					LOG.error(
+							""Optimistic locking failed for exchange with key {}: kvClient.get returned no Exchanges, while it's expected to replace one"",
+							key);
+					throw new OptimisticLockingException();
+				}
+				CompletableFuture<PutResponse> completablePutResponse = kvClient.put(
+						ByteSequence.from(String.format(""%s/%s"", prefixName, key).getBytes()), ByteSequence.from(data));
+				completablePutResponse.get();
+			}
+		} catch (InterruptedException | ExecutionException | IOException | ClassNotFoundException e) {
+			LOG.error(e.getMessage(), e);
+			throw new OptimisticLockingException();
+		}
+		LOG.trace(""Added an Exchange with ID {} for key {} in optimistic manner."", newExchange.getExchangeId(), key);
+		return oldExchange;
+	}
+
+	@Override
+	public Exchange add(CamelContext camelContext, String key, Exchange exchange) {
+		if (optimistic) {
+			throw new UnsupportedOperationException();
+		}
+		LOG.trace(""Adding an Exchange with ID {} for key {} in a thread-safe manner."", exchange.getExchangeId(), key);
+		Lock lock = null;
+		DefaultExchangeHolder newHolder = DefaultExchangeHolder.marshal(exchange, true, allowSerializedHeaders);
+		try {
+			lock = client.getLockClient();
+			lock.lock(ByteSequence.from(key.getBytes()), 60000);
+			ByteArrayOutputStream bos = new ByteArrayOutputStream();
+			ObjectOutputStream oos = new ObjectOutputStream(bos);
+			oos.writeObject(newHolder);
+			oos.flush();
+			byte[] data = bos.toByteArray();
+			CompletableFuture<PutResponse> completablePutResponse = kvClient.put(
+					ByteSequence.from(String.format(""%s/%s"", prefixName, key).getBytes()), ByteSequence.from(data));
+			completablePutResponse.get();
+		} catch (InterruptedException | ExecutionException | IOException e) {
+			LOG.error(e.getMessage(), e);
+		} finally {
+			if (lock != null) {
+				lock.unlock(ByteSequence.from(key.getBytes()));
+			}
+		}
+		return unmarshallExchange(camelContext, newHolder);
+	}
+
+	@Override
+	public Set<String> scan(CamelContext camelContext) {
+		if (useRecovery) {
+			LOG.trace(""Scanning for exchanges to recover in {} context"", camelContext.getName());
+			CompletableFuture<GetResponse> completableGetResponse = kvClient.get(
+					ByteSequence.from(persistencePrefixName.getBytes()),
+					GetOption.newBuilder().withPrefix(ByteSequence.from(persistencePrefixName.getBytes())).build());
+			Set<String> scanned = Collections.unmodifiableSet(new TreeSet<>());
+			try {
+				GetResponse getResponse = completableGetResponse.get();
+				Set<String> keys = new TreeSet<>();
+				getResponse.getKvs().forEach(kv -> keys.add(new String(kv.getKey().getBytes())));
+				scanned = Collections.unmodifiableSet(keys);
+				LOG.trace(""Found {} keys for exchanges to recover in {} context"", scanned.size(),
+						camelContext.getName());
+			} catch (InterruptedException | ExecutionException e) {
+				LOG.error(e.getMessage(), e);
+			}
+			return scanned;
+		} else {
+			LOG.warn(
+					""What for to run recovery scans in {} context while prefix {} is running in non-recoverable aggregation repository mode?!"",
+					camelContext.getName(), prefixName);
+			return Collections.emptySet();
+		}
+	}
+
+	@Override
+	public Exchange recover(CamelContext camelContext, String exchangeId) {
+		LOG.trace(""Recovering an Exchange with ID {}."", exchangeId);
+		CompletableFuture<GetResponse> completableResponse = kvClient
+				.get(ByteSequence.from(String.format(""%s/%s"", persistencePrefixName, exchangeId).getBytes()));
+		try {
+			GetResponse getResponse = completableResponse.get();
+			byte[] data = getResponse.getKvs().get(0).getValue().getBytes();
+			ByteArrayInputStream in = new ByteArrayInputStream(data);
+			ObjectInputStream is = new ObjectInputStream(in);
+			DefaultExchangeHolder holder = (DefaultExchangeHolder) is.readObject();
+			return useRecovery ? unmarshallExchange(camelContext, holder) : null;
+		} catch (InterruptedException | ExecutionException | IOException | ClassNotFoundException e) {
+			LOG.error(e.getMessage(), e);
+		}
+		return null;
+	}
+
+	@Override
+	public void setRecoveryInterval(long interval, TimeUnit timeUnit) {
+		this.recoveryInterval = timeUnit.toMillis(interval);
+	}
+
+	@Override
+	public void setRecoveryInterval(long interval) {
+		this.recoveryInterval = interval;
+	}
+
+	@Override
+	public long getRecoveryIntervalInMillis() {
+		return recoveryInterval;
+	}
+
+	@Override
+	public void setUseRecovery(boolean useRecovery) {
+		this.useRecovery = useRecovery;
+	}
+
+	@Override
+	public boolean isUseRecovery() {
+		return useRecovery;
+	}
+
+	@Override
+	public void setDeadLetterUri(String deadLetterUri) {
+		this.deadLetterChannel = deadLetterUri;
+	}
+
+	@Override
+	public String getDeadLetterUri() {
+		return deadLetterChannel;
+	}
+
+	@Override
+	public void setMaximumRedeliveries(int maximumRedeliveries) {
+		this.maximumRedeliveries = maximumRedeliveries;
+	}
+
+	@Override
+	public int getMaximumRedeliveries() {
+		return maximumRedeliveries;
+	}
+
+	@Override
+	public Exchange get(CamelContext camelContext, String key) {
+		CompletableFuture<GetResponse> completableResponse = kvClient
+				.get(ByteSequence.from(String.format(""%s/%s"", prefixName, key).getBytes()));
+		try {
+			GetResponse getResponse = completableResponse.get();
+			byte[] data = getResponse.getKvs().get(0).getValue().getBytes();
+			ByteArrayInputStream in = new ByteArrayInputStream(data);
+			ObjectInputStream is = new ObjectInputStream(in);
+			DefaultExchangeHolder holder = (DefaultExchangeHolder) is.readObject();
+			return unmarshallExchange(camelContext, holder);
+		} catch (InterruptedException | ExecutionException | IOException | ClassNotFoundException e) {
+			LOG.error(e.getMessage(), e);
+		}
+		return null;
+	}
+
+	public boolean isAllowSerializedHeaders() {
+		return allowSerializedHeaders;
+	}
+
+	public void setAllowSerializedHeaders(boolean allowSerializedHeaders) {
+		this.allowSerializedHeaders = allowSerializedHeaders;
+	}
+
+	@Override
+	public void remove(CamelContext camelContext, String key, Exchange exchange) {
+		DefaultExchangeHolder holder = DefaultExchangeHolder.marshal(exchange, true, allowSerializedHeaders);
+		if (optimistic) {
+			LOG.trace(""Removing an exchange with ID {} for key {} in an optimistic manner."", exchange.getExchangeId(),
+					key);
+			CompletableFuture<DeleteResponse> completableDeleteResponse = kvClient
+					.delete(ByteSequence.from(String.format(""%s/%s"", prefixName, key).getBytes()));
+			try {
+				DeleteResponse deleteResponse = completableDeleteResponse.get();
+				if (deleteResponse.getDeleted() == 0) {
+					LOG.error(
+							""Optimistic locking failed for exchange with key {}: kvClient.delete removed no Exchanges, while it's expected to remove one."",
+							key);
+					throw new OptimisticLockingException();
+				}
+			} catch (InterruptedException | ExecutionException e) {
+				LOG.error(e.getMessage(), e);
+			}
+			LOG.trace(""Removed an exchange with ID {} for key {} in an optimistic manner."", exchange.getExchangeId(),
+					key);
+			if (useRecovery) {
+				LOG.trace(
+						""Putting an exchange with ID {} for key {} into a recoverable storage in an optimistic manner."",
+						exchange.getExchangeId(), key);
+				try {
+					ByteArrayOutputStream bos = new ByteArrayOutputStream();
+					ObjectOutputStream oos = new ObjectOutputStream(bos);
+					oos.writeObject(holder);
+					oos.flush();","[{'comment': 'seems like serialize/deserialize of the exchange holder is quite common so you may think to extract the logic in some methods ', 'commenter': 'lburgazzoli'}]"
3983,components/camel-etcd3/src/main/java/org/apache/camel/component/etcd3/processor/aggregate/Etcd3AggregationRepository.java,"@@ -0,0 +1,459 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.camel.component.etcd3.processor.aggregate;
+
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.ObjectInputStream;
+import java.io.ObjectOutputStream;
+import java.util.Collections;
+import java.util.List;
+import java.util.Set;
+import java.util.TreeSet;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.TimeUnit;
+
+import org.apache.camel.CamelContext;
+import org.apache.camel.Exchange;
+import org.apache.camel.impl.DefaultExchange;
+import org.apache.camel.impl.DefaultExchangeHolder;
+import org.apache.camel.spi.OptimisticLockingAggregationRepository;
+import org.apache.camel.spi.RecoverableAggregationRepository;
+import org.apache.camel.support.ServiceSupport;
+import org.apache.camel.util.StringHelper;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import io.etcd.jetcd.ByteSequence;
+import io.etcd.jetcd.Client;
+import io.etcd.jetcd.KV;
+import io.etcd.jetcd.KeyValue;
+import io.etcd.jetcd.Lock;
+import io.etcd.jetcd.Txn;
+import io.etcd.jetcd.kv.DeleteResponse;
+import io.etcd.jetcd.kv.GetResponse;
+import io.etcd.jetcd.kv.PutResponse;
+import io.etcd.jetcd.op.Cmp;
+import io.etcd.jetcd.op.CmpTarget;
+import io.etcd.jetcd.op.Op;
+import io.etcd.jetcd.options.DeleteOption;
+import io.etcd.jetcd.options.GetOption;
+import io.etcd.jetcd.options.PutOption;
+
+public class Etcd3AggregationRepository extends ServiceSupport
+		implements RecoverableAggregationRepository, OptimisticLockingAggregationRepository {
+	private static final Logger LOG = LoggerFactory.getLogger(Etcd3AggregationRepository.class.getName());
+	private static final String COMPLETED_SUFFIX = ""-completed"";
+
+	private boolean optimistic;
+	private boolean useRecovery = true;
+	private String endpoint;
+	private Client client;
+	private KV kvClient;
+	private String prefixName;
+	private String persistencePrefixName;
+	private String deadLetterChannel;
+	private long recoveryInterval = 5000;
+	private int maximumRedeliveries = 3;
+	private boolean allowSerializedHeaders;
+
+	public Etcd3AggregationRepository(final String prefixName, final String endpoint) {
+		this.prefixName = prefixName;
+		this.persistencePrefixName = String.format(""%s%s"", prefixName, COMPLETED_SUFFIX);
+		this.optimistic = false;
+		this.endpoint = endpoint;
+	}
+
+	public Etcd3AggregationRepository(final String prefixName, final String persistencePrefixName,
+			final String endpoint) {
+		this.prefixName = prefixName;
+		this.persistencePrefixName = persistencePrefixName;
+		this.optimistic = false;
+		this.endpoint = endpoint;
+	}
+
+	public Etcd3AggregationRepository(final String prefixName, final String endpoint, boolean optimistic) {
+		this(prefixName, endpoint);
+		this.optimistic = optimistic;
+	}
+
+	public Etcd3AggregationRepository(final String repositoryName, final String persistentRepositoryName,
+			final String endpoint, boolean optimistic) {
+		this(repositoryName, persistentRepositoryName, endpoint);
+		this.optimistic = optimistic;
+	}
+
+	@Override
+	public Exchange add(CamelContext camelContext, String key, Exchange oldExchange, Exchange newExchange)
+			throws OptimisticLockingException {
+		if (!optimistic) {
+			throw new UnsupportedOperationException();
+		}
+		LOG.trace(""Adding an Exchange with ID {} for key {} in an optimistic manner."", newExchange.getExchangeId(),
+				key);
+		try {
+			if (oldExchange == null) {
+				DefaultExchangeHolder holder = DefaultExchangeHolder.marshal(newExchange, true, allowSerializedHeaders);
+				CompletableFuture<GetResponse> completableGetResponse = kvClient
+						.get(ByteSequence.from(String.format(""%s/%s"", prefixName, key).getBytes()));
+				GetResponse getResponse = completableGetResponse.get();
+				List<KeyValue> keyValues = getResponse.getKvs();
+				if (keyValues.isEmpty()) {
+					ByteArrayOutputStream bos = new ByteArrayOutputStream();
+					ObjectOutputStream oos = new ObjectOutputStream(bos);
+					oos.writeObject(holder);
+					oos.flush();
+					byte[] data = bos.toByteArray();
+					CompletableFuture<PutResponse> completablePutResponse = kvClient.put(
+							ByteSequence.from(String.format(""%s/%s"", prefixName, key).getBytes()),
+							ByteSequence.from(data));
+					completablePutResponse.get();
+				} else {
+					byte[] data = keyValues.get(0).getValue().getBytes();
+					ByteArrayInputStream in = new ByteArrayInputStream(data);
+					ObjectInputStream is = new ObjectInputStream(in);
+					DefaultExchangeHolder misbehaviorHolder = (DefaultExchangeHolder) is.readObject();
+					Exchange misbehaviorEx = unmarshallExchange(camelContext, misbehaviorHolder);
+					LOG.error(
+							""Optimistic locking failed for exchange with key {}: kvClient.get returned Exchange with ID {}, while it's expected no exchanges to be returned"",
+							key, misbehaviorEx != null ? misbehaviorEx.getExchangeId() : ""<null>"");
+					throw new OptimisticLockingException();
+				}
+			} else {
+				DefaultExchangeHolder newHolder = DefaultExchangeHolder.marshal(newExchange, true,
+						allowSerializedHeaders);
+				ByteArrayOutputStream bos = new ByteArrayOutputStream();
+				ObjectOutputStream oos = new ObjectOutputStream(bos);
+				oos.writeObject(newHolder);
+				oos.flush();
+				byte[] data = bos.toByteArray();
+				CompletableFuture<DeleteResponse> completableDeleteResponse = kvClient
+						.delete(ByteSequence.from(String.format(""%s/%s"", prefixName, key).getBytes()));
+				DeleteResponse deleteResponse = completableDeleteResponse.get();
+				if (deleteResponse.getDeleted() == 0) {
+					LOG.error(
+							""Optimistic locking failed for exchange with key {}: kvClient.get returned no Exchanges, while it's expected to replace one"",
+							key);
+					throw new OptimisticLockingException();
+				}
+				CompletableFuture<PutResponse> completablePutResponse = kvClient.put(
+						ByteSequence.from(String.format(""%s/%s"", prefixName, key).getBytes()), ByteSequence.from(data));
+				completablePutResponse.get();
+			}
+		} catch (InterruptedException | ExecutionException | IOException | ClassNotFoundException e) {
+			LOG.error(e.getMessage(), e);
+			throw new OptimisticLockingException();
+		}
+		LOG.trace(""Added an Exchange with ID {} for key {} in optimistic manner."", newExchange.getExchangeId(), key);
+		return oldExchange;
+	}
+
+	@Override
+	public Exchange add(CamelContext camelContext, String key, Exchange exchange) {
+		if (optimistic) {
+			throw new UnsupportedOperationException();
+		}
+		LOG.trace(""Adding an Exchange with ID {} for key {} in a thread-safe manner."", exchange.getExchangeId(), key);
+		Lock lock = null;
+		DefaultExchangeHolder newHolder = DefaultExchangeHolder.marshal(exchange, true, allowSerializedHeaders);
+		try {
+			lock = client.getLockClient();
+			lock.lock(ByteSequence.from(key.getBytes()), 60000);
+			ByteArrayOutputStream bos = new ByteArrayOutputStream();
+			ObjectOutputStream oos = new ObjectOutputStream(bos);
+			oos.writeObject(newHolder);
+			oos.flush();
+			byte[] data = bos.toByteArray();
+			CompletableFuture<PutResponse> completablePutResponse = kvClient.put(
+					ByteSequence.from(String.format(""%s/%s"", prefixName, key).getBytes()), ByteSequence.from(data));
+			completablePutResponse.get();
+		} catch (InterruptedException | ExecutionException | IOException e) {
+			LOG.error(e.getMessage(), e);","[{'comment': ""doesn't this case need to be properly handled ?"", 'commenter': 'lburgazzoli'}]"
3984,components/camel-opentracing/src/test/java/org/apache/camel/opentracing/CustomSpanAdder.java,"@@ -0,0 +1,17 @@
+package org.apache.camel.opentracing;","[{'comment': 'license header is missing', 'commenter': 'oscerd'}, {'comment': 'good spot, added', 'commenter': 'mcrmfc'}]"
3989,components/camel-jsonata/pom.xml,"@@ -0,0 +1,75 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one or more
+    contributor license agreements.  See the NOTICE file distributed with
+    this work for additional information regarding copyright ownership.
+    The ASF licenses this file to You under the Apache License, Version 2.0
+    (the ""License""); you may not use this file except in compliance with
+    the License.  You may obtain a copy of the License at
+
+         http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an ""AS IS"" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+
+-->
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+
+    <modelVersion>4.0.0</modelVersion>
+
+    <parent>
+        <artifactId>components</artifactId>
+        <groupId>org.apache.camel</groupId>
+        <version>3.5.0-SNAPSHOT</version>
+    </parent>
+
+    <artifactId>camel-jsonata</artifactId>
+    <packaging>jar</packaging>
+    <name>Camel :: JSONATA</name>
+    <description>Camel JSONATA Support</description>
+
+    <properties>
+    </properties>
+
+    <dependencies>
+        <dependency>
+            <groupId>org.apache.camel</groupId>
+            <artifactId>camel-support</artifactId>
+        </dependency>
+
+        <dependency>
+            <groupId>com.fasterxml.jackson.core</groupId>
+            <artifactId>jackson-annotations</artifactId>
+        </dependency>
+        <dependency>
+            <groupId>com.fasterxml.jackson.core</groupId>
+            <artifactId>jackson-databind</artifactId>
+        </dependency>
+
+        <!-- https://mvnrepository.com/artifact/com.ibm.jsonata4java/JSONata4Java -->
+        <dependency>
+            <groupId>com.ibm.jsonata4java</groupId>
+            <artifactId>JSONata4Java</artifactId>
+            <version>1.0.0</version>","[{'comment': 'This should go as property placeholder at parent pom', 'commenter': 'oscerd'}, {'comment': 'Moved to property in parent pom.', 'commenter': 'jamesmacinnes'}]"
3989,components/camel-jsonata/src/generated/resources/org/apache/camel/component/jsonata/jsonata.json,"@@ -0,0 +1,37 @@
+{
+  ""component"": {
+    ""kind"": ""component"",
+    ""name"": ""jsonata"",
+    ""title"": ""JSONATA"",
+    ""description"": ""JSON to JSON transformation using JSONATA."",
+    ""deprecated"": false,
+    ""firstVersion"": ""3.4.0"",","[{'comment': ""You need to regenerate the src/generated.. it's 3.5.0"", 'commenter': 'oscerd'}, {'comment': 'Done.', 'commenter': 'jamesmacinnes'}]"
3989,components/camel-jsonata/src/main/java/org/apache/camel/component/jsonata/JsonataEndpoint.java,"@@ -0,0 +1,126 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.jsonata;
+
+import java.io.InputStream;
+import java.io.BufferedReader;
+import java.io.InputStreamReader;
+import java.nio.charset.StandardCharsets;
+import java.util.stream.Collectors;
+import java.util.Map;
+import org.apache.camel.Category;
+import org.apache.camel.Exchange;
+import org.apache.camel.ExchangePattern;
+import org.apache.camel.Message;
+import org.apache.camel.component.ResourceEndpoint;
+import org.apache.camel.spi.UriEndpoint;
+import org.apache.camel.spi.UriParam;
+import org.apache.camel.util.ObjectHelper;
+import com.api.jsonata4java.expressions.EvaluateException;
+import com.api.jsonata4java.expressions.EvaluateRuntimeException;
+import com.api.jsonata4java.expressions.Expressions;
+import com.api.jsonata4java.expressions.ParseException;
+import com.fasterxml.jackson.core.JsonProcessingException;
+import com.fasterxml.jackson.databind.JsonNode;
+import com.fasterxml.jackson.databind.ObjectMapper;
+
+/**
+ * JSON to JSON transformation using JSONATA.
+ */
+@UriEndpoint(firstVersion = ""3.4.0"", scheme = ""jsonata"", title = ""JSONATA"", syntax = ""jsonata:resourceUri"", producerOnly = true, category = {Category.TRANSFORMATION})
+public class JsonataEndpoint extends ResourceEndpoint {
+
+    private Expressions expressions = null;
+
+    @UriParam(defaultValue = ""Jackson"")
+    private JsonataInputOutputType outputType;
+
+    @UriParam(defaultValue = ""Jackson"")
+    private JsonataInputOutputType inputType;
+
+    public JsonataEndpoint() {
+    }
+
+    public JsonataEndpoint(String uri, JsonataComponent component, String resourceUri) {
+        super(uri, component, resourceUri);
+    }
+
+    @Override
+    public ExchangePattern getExchangePattern() {
+        return ExchangePattern.InOut;
+    }
+
+    @Override
+    protected String createEndpointUri() {
+        return ""Jsonata:"" + getResourceUri();
+    }
+
+    public JsonataInputOutputType getOutputType() {
+        return outputType;
+    }
+
+    /**
+     * Specifies if the output should be Jackson JsNode or a JSON String.
+     */
+    public void setOutputType(JsonataInputOutputType outputType) {
+        this.outputType = outputType;
+    }
+
+    public JsonataInputOutputType getInputType() {
+        return inputType;
+    }
+
+    /**
+     * Specifies if the input is hydrated JSON or a JSON String.
+     */
+    public void setInputType(JsonataInputOutputType inputType) {
+        this.inputType = inputType;
+    }
+
+    @Override
+    protected void onExchange(Exchange exchange) throws Exception {
+        String path = getResourceUri();
+        ObjectHelper.notNull(path, ""resourceUri"");
+        
+        JsonNode input;
+        ObjectMapper mapper = new ObjectMapper();
+        if (getInputType() == JsonataInputOutputType.JsonString) {
+            input =  mapper.readTree(exchange.getIn().getBody(InputStream.class));
+        } else {
+            input = (JsonNode)exchange.getIn().getBody();
+        }
+
+        JsonNode output=null;","[{'comment': 'Please run man clean install -Psourcecheck. There are code style errors', 'commenter': 'oscerd'}, {'comment': 'Done.', 'commenter': 'jamesmacinnes'}]"
3989,components/camel-jsonata/src/test/java/org/apache/camel/component/jolt/JsonataFirstSampleTest.java,"@@ -0,0 +1,74 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.jsonata;
+
+import java.util.HashMap;
+import java.util.Map;
+
+import org.apache.camel.Exchange;
+import org.apache.camel.Processor;
+import org.apache.camel.builder.RouteBuilder;
+import org.apache.camel.support.ResourceHelper;
+import org.apache.camel.test.junit5.CamelTestSupport;
+import org.apache.camel.util.IOHelper;
+import org.junit.jupiter.api.Test;
+
+/**
+ * Unit test based on the first sample test from the Jsonata project.
+ */
+public class JsonataFirstSampleTest extends CamelTestSupport {
+
+    @Test
+    public void testFirstSampleJsonata() throws Exception {
+        //getMockEndpoint(""mock:result"").expectedMinimumMessageCount(1);","[{'comment': 'Please remove', 'commenter': 'oscerd'}, {'comment': 'Done.', 'commenter': 'jamesmacinnes'}]"
3993,components/camel-redis/pom.xml,"@@ -0,0 +1,86 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one or more
+    contributor license agreements.  See the NOTICE file distributed with
+    this work for additional information regarding copyright ownership.
+    The ASF licenses this file to You under the Apache License, Version 2.0
+    (the ""License""); you may not use this file except in compliance with
+    the License.  You may obtain a copy of the License at
+
+         http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an ""AS IS"" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+
+-->
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+
+    <modelVersion>4.0.0</modelVersion>
+
+    <parent>
+        <groupId>org.apache.camel</groupId>
+        <artifactId>components</artifactId>
+        <version>3.5.0-SNAPSHOT</version>
+    </parent>
+
+    <artifactId>camel-redis</artifactId>
+    <packaging>jar</packaging>
+    <name>Camel :: Redis</name>
+    <description>Camel Redis support</description>
+
+    <dependencies>
+
+        <dependency>
+            <groupId>org.apache.camel</groupId>
+            <artifactId>camel-cloud</artifactId>
+        </dependency>
+
+        <!-- etcd -->","[{'comment': 'seems not right', 'commenter': 'lburgazzoli'}]"
3993,components/camel-redis/pom.xml,"@@ -0,0 +1,86 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one or more
+    contributor license agreements.  See the NOTICE file distributed with
+    this work for additional information regarding copyright ownership.
+    The ASF licenses this file to You under the Apache License, Version 2.0
+    (the ""License""); you may not use this file except in compliance with
+    the License.  You may obtain a copy of the License at
+
+         http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an ""AS IS"" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+
+-->
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+
+    <modelVersion>4.0.0</modelVersion>
+
+    <parent>
+        <groupId>org.apache.camel</groupId>
+        <artifactId>components</artifactId>
+        <version>3.5.0-SNAPSHOT</version>
+    </parent>
+
+    <artifactId>camel-redis</artifactId>
+    <packaging>jar</packaging>
+    <name>Camel :: Redis</name>
+    <description>Camel Redis support</description>
+
+    <dependencies>
+
+        <dependency>
+            <groupId>org.apache.camel</groupId>
+            <artifactId>camel-cloud</artifactId>
+        </dependency>
+
+        <!-- etcd -->
+        <dependency>
+            <groupId>org.apache.commons</groupId>
+            <artifactId>commons-lang3</artifactId>
+            <version>${commons-lang3-version}</version>
+        </dependency>
+        
+        <dependency>
+	       <groupId>org.redisson</groupId>
+           <artifactId>redisson</artifactId>
+           <version>${redisson-version}</version>
+        </dependency>
+
+        <!-- logging -->
+        <dependency>
+            <groupId>org.apache.logging.log4j</groupId>
+            <artifactId>log4j-slf4j-impl</artifactId>
+            <scope>test</scope>
+        </dependency>
+
+        <!-- testing -->
+        <dependency>
+            <groupId>org.apache.camel</groupId>
+            <artifactId>camel-testcontainers-spring-junit5</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.apache.camel</groupId>
+            <artifactId>camel-testcontainers-junit5</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.apache.camel</groupId>
+            <artifactId>camel-http</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.apache.camel</groupId>
+            <artifactId>camel-jetty</artifactId>
+            <scope>test</scope>
+        </dependency>","[{'comment': ""not sure about what dependencies are really needed since there's no tests"", 'commenter': 'lburgazzoli'}]"
3993,components/camel-redis/src/main/java/org/apache/camel/component/redis/processor/aggregate/RedisAggregationRepository.java,"@@ -0,0 +1,338 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.camel.component.redis.processor.aggregate;
+
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.ObjectInputStream;
+import java.io.ObjectOutputStream;
+import java.util.Collections;
+import java.util.Map;
+import java.util.Set;
+import java.util.TreeSet;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.TimeUnit;
+
+import org.apache.camel.CamelContext;
+import org.apache.camel.Exchange;
+import org.apache.camel.spi.OptimisticLockingAggregationRepository;
+import org.apache.camel.spi.RecoverableAggregationRepository;
+import org.apache.camel.spi.OptimisticLockingAggregationRepository.OptimisticLockingException;
+import org.apache.camel.support.DefaultExchange;
+import org.apache.camel.support.DefaultExchangeHolder;
+import org.apache.camel.support.service.ServiceSupport;
+import org.apache.camel.util.StringHelper;
+import org.redisson.Redisson;
+import org.redisson.api.RLock;
+import org.redisson.api.RMap;
+import org.redisson.api.RTransaction;
+import org.redisson.api.RedissonClient;
+import org.redisson.api.TransactionOptions;
+import org.redisson.config.Config;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class RedisAggregationRepository extends ServiceSupport
+		implements RecoverableAggregationRepository, OptimisticLockingAggregationRepository {
+	private static final Logger LOG = LoggerFactory.getLogger(RedisAggregationRepository.class.getName());","[{'comment': '`.getName()` can be omitted', 'commenter': 'lburgazzoli'}]"
3993,components/camel-redis/src/main/java/org/apache/camel/component/redis/processor/aggregate/RedisAggregationRepository.java,"@@ -0,0 +1,338 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.camel.component.redis.processor.aggregate;
+
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.ObjectInputStream;
+import java.io.ObjectOutputStream;
+import java.util.Collections;
+import java.util.Map;
+import java.util.Set;
+import java.util.TreeSet;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.TimeUnit;
+
+import org.apache.camel.CamelContext;
+import org.apache.camel.Exchange;
+import org.apache.camel.spi.OptimisticLockingAggregationRepository;
+import org.apache.camel.spi.RecoverableAggregationRepository;
+import org.apache.camel.spi.OptimisticLockingAggregationRepository.OptimisticLockingException;
+import org.apache.camel.support.DefaultExchange;
+import org.apache.camel.support.DefaultExchangeHolder;
+import org.apache.camel.support.service.ServiceSupport;
+import org.apache.camel.util.StringHelper;
+import org.redisson.Redisson;
+import org.redisson.api.RLock;
+import org.redisson.api.RMap;
+import org.redisson.api.RTransaction;
+import org.redisson.api.RedissonClient;
+import org.redisson.api.TransactionOptions;
+import org.redisson.config.Config;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class RedisAggregationRepository extends ServiceSupport
+		implements RecoverableAggregationRepository, OptimisticLockingAggregationRepository {
+	private static final Logger LOG = LoggerFactory.getLogger(RedisAggregationRepository.class.getName());
+	private static final String COMPLETED_SUFFIX = ""-completed"";
+
+	private boolean optimistic;
+	private boolean useRecovery = true;
+	private Map<String, DefaultExchangeHolder> cache;
+    private Map<String, DefaultExchangeHolder> persistedCache;
+	private String endpoint;
+	private String mapName;
+	private String persistenceMapName;
+	private RedissonClient redisson;
+	private String deadLetterChannel;
+	private long recoveryInterval = 5000;
+	private int maximumRedeliveries = 3;
+	private boolean allowSerializedHeaders;
+
+	public RedisAggregationRepository(final String mapName, final String endpoint) {
+		this.mapName = mapName;
+		this.persistenceMapName = String.format(""%s%s"", mapName, COMPLETED_SUFFIX);
+		this.optimistic = false;
+		this.endpoint = endpoint;
+	}
+
+	public RedisAggregationRepository(final String mapName, final String persistenceMapName,
+			final String endpoint) {
+		this.mapName = mapName;
+		this.persistenceMapName = persistenceMapName;
+		this.optimistic = false;
+		this.endpoint = endpoint;
+	}
+
+	public RedisAggregationRepository(final String mapName, final String endpoint, boolean optimistic) {
+		this(mapName, endpoint);
+		this.optimistic = optimistic;
+	}
+
+	public RedisAggregationRepository(final String mapName, final String persistenceMapName,
+			final String endpoint, boolean optimistic) {
+		this(mapName, persistenceMapName, endpoint);
+		this.optimistic = optimistic;
+	}
+
+	@Override
+    public Exchange add(CamelContext camelContext, String key, Exchange oldExchange, Exchange newExchange) throws OptimisticLockingException {
+        if (!optimistic) {
+            throw new UnsupportedOperationException();
+        }
+        LOG.trace(""Adding an Exchange with ID {} for key {} in an optimistic manner."", newExchange.getExchangeId(), key);
+        if (oldExchange == null) {
+            DefaultExchangeHolder holder = DefaultExchangeHolder.marshal(newExchange, true, allowSerializedHeaders);
+            final DefaultExchangeHolder misbehaviorHolder = cache.putIfAbsent(key, holder);
+            if (misbehaviorHolder != null) {
+                Exchange misbehaviorEx = unmarshallExchange(camelContext, misbehaviorHolder);
+                LOG.error(""Optimistic locking failed for exchange with key {}: IMap#putIfAbsend returned Exchange with ID {}, while it's expected no exchanges to be returned"",
+                        key, misbehaviorEx != null ? misbehaviorEx.getExchangeId() : ""<null>"");
+                throw  new OptimisticLockingException();
+            }
+        } else {
+            DefaultExchangeHolder oldHolder = DefaultExchangeHolder.marshal(oldExchange, true, allowSerializedHeaders);
+            DefaultExchangeHolder newHolder = DefaultExchangeHolder.marshal(newExchange, true, allowSerializedHeaders);
+            if (!cache.replace(key, oldHolder, newHolder)) {
+                LOG.error(""Optimistic locking failed for exchange with key {}: IMap#replace returned no Exchanges, while it's expected to replace one"",
+                        key);
+                throw new OptimisticLockingException();
+            }
+        }
+        LOG.trace(""Added an Exchange with ID {} for key {} in optimistic manner."", newExchange.getExchangeId(), key);
+        return oldExchange;
+    }
+
+	@Override
+	public Exchange add(CamelContext camelContext, String key, Exchange exchange) {
+		if (optimistic) {
+			throw new UnsupportedOperationException();
+		}
+		LOG.trace(""Adding an Exchange with ID {} for key {} in a thread-safe manner."", exchange.getExchangeId(), key);
+		Config config = new Config();
+		config.useSingleServer().setAddress(String.format(""redis://%s"",endpoint));
+		RedissonClient redisson = Redisson.create(config);","[{'comment': 'The global `redisson` instance is created by `onStart` so I guess this code can be replaced by using the shared instance', 'commenter': 'lburgazzoli'}]"
3993,components/camel-redis/src/main/java/org/apache/camel/component/redis/processor/aggregate/RedisAggregationRepository.java,"@@ -0,0 +1,338 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.camel.component.redis.processor.aggregate;
+
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.ObjectInputStream;
+import java.io.ObjectOutputStream;
+import java.util.Collections;
+import java.util.Map;
+import java.util.Set;
+import java.util.TreeSet;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.TimeUnit;
+
+import org.apache.camel.CamelContext;
+import org.apache.camel.Exchange;
+import org.apache.camel.spi.OptimisticLockingAggregationRepository;
+import org.apache.camel.spi.RecoverableAggregationRepository;
+import org.apache.camel.spi.OptimisticLockingAggregationRepository.OptimisticLockingException;
+import org.apache.camel.support.DefaultExchange;
+import org.apache.camel.support.DefaultExchangeHolder;
+import org.apache.camel.support.service.ServiceSupport;
+import org.apache.camel.util.StringHelper;
+import org.redisson.Redisson;
+import org.redisson.api.RLock;
+import org.redisson.api.RMap;
+import org.redisson.api.RTransaction;
+import org.redisson.api.RedissonClient;
+import org.redisson.api.TransactionOptions;
+import org.redisson.config.Config;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class RedisAggregationRepository extends ServiceSupport
+		implements RecoverableAggregationRepository, OptimisticLockingAggregationRepository {
+	private static final Logger LOG = LoggerFactory.getLogger(RedisAggregationRepository.class.getName());
+	private static final String COMPLETED_SUFFIX = ""-completed"";
+
+	private boolean optimistic;
+	private boolean useRecovery = true;
+	private Map<String, DefaultExchangeHolder> cache;
+    private Map<String, DefaultExchangeHolder> persistedCache;
+	private String endpoint;
+	private String mapName;
+	private String persistenceMapName;
+	private RedissonClient redisson;
+	private String deadLetterChannel;
+	private long recoveryInterval = 5000;
+	private int maximumRedeliveries = 3;
+	private boolean allowSerializedHeaders;
+
+	public RedisAggregationRepository(final String mapName, final String endpoint) {
+		this.mapName = mapName;
+		this.persistenceMapName = String.format(""%s%s"", mapName, COMPLETED_SUFFIX);
+		this.optimistic = false;
+		this.endpoint = endpoint;
+	}
+
+	public RedisAggregationRepository(final String mapName, final String persistenceMapName,
+			final String endpoint) {
+		this.mapName = mapName;
+		this.persistenceMapName = persistenceMapName;
+		this.optimistic = false;
+		this.endpoint = endpoint;
+	}
+
+	public RedisAggregationRepository(final String mapName, final String endpoint, boolean optimistic) {
+		this(mapName, endpoint);
+		this.optimistic = optimistic;
+	}
+
+	public RedisAggregationRepository(final String mapName, final String persistenceMapName,
+			final String endpoint, boolean optimistic) {
+		this(mapName, persistenceMapName, endpoint);
+		this.optimistic = optimistic;
+	}
+
+	@Override
+    public Exchange add(CamelContext camelContext, String key, Exchange oldExchange, Exchange newExchange) throws OptimisticLockingException {
+        if (!optimistic) {
+            throw new UnsupportedOperationException();
+        }
+        LOG.trace(""Adding an Exchange with ID {} for key {} in an optimistic manner."", newExchange.getExchangeId(), key);
+        if (oldExchange == null) {
+            DefaultExchangeHolder holder = DefaultExchangeHolder.marshal(newExchange, true, allowSerializedHeaders);
+            final DefaultExchangeHolder misbehaviorHolder = cache.putIfAbsent(key, holder);
+            if (misbehaviorHolder != null) {
+                Exchange misbehaviorEx = unmarshallExchange(camelContext, misbehaviorHolder);
+                LOG.error(""Optimistic locking failed for exchange with key {}: IMap#putIfAbsend returned Exchange with ID {}, while it's expected no exchanges to be returned"",
+                        key, misbehaviorEx != null ? misbehaviorEx.getExchangeId() : ""<null>"");
+                throw  new OptimisticLockingException();
+            }
+        } else {
+            DefaultExchangeHolder oldHolder = DefaultExchangeHolder.marshal(oldExchange, true, allowSerializedHeaders);
+            DefaultExchangeHolder newHolder = DefaultExchangeHolder.marshal(newExchange, true, allowSerializedHeaders);
+            if (!cache.replace(key, oldHolder, newHolder)) {
+                LOG.error(""Optimistic locking failed for exchange with key {}: IMap#replace returned no Exchanges, while it's expected to replace one"",
+                        key);
+                throw new OptimisticLockingException();
+            }
+        }
+        LOG.trace(""Added an Exchange with ID {} for key {} in optimistic manner."", newExchange.getExchangeId(), key);
+        return oldExchange;
+    }
+
+	@Override
+	public Exchange add(CamelContext camelContext, String key, Exchange exchange) {
+		if (optimistic) {
+			throw new UnsupportedOperationException();
+		}
+		LOG.trace(""Adding an Exchange with ID {} for key {} in a thread-safe manner."", exchange.getExchangeId(), key);
+		Config config = new Config();
+		config.useSingleServer().setAddress(String.format(""redis://%s"",endpoint));
+		RedissonClient redisson = Redisson.create(config);
+		RLock lock = redisson.getLock(""aggregationLock"");
+		try {
+            lock.lock();
+            DefaultExchangeHolder newHolder = DefaultExchangeHolder.marshal(exchange, true, allowSerializedHeaders);
+            DefaultExchangeHolder oldHolder = cache.put(key, newHolder);
+            return unmarshallExchange(camelContext, oldHolder);
+        } finally {
+            LOG.trace(""Added an Exchange with ID {} for key {} in a thread-safe manner."", exchange.getExchangeId(), key);
+            lock.unlock();
+        }
+	}
+
+	@Override
+    public Set<String> scan(CamelContext camelContext) {
+        if (useRecovery) {
+            LOG.trace(""Scanning for exchanges to recover in {} context"", camelContext.getName());
+            Set<String> scanned = Collections.unmodifiableSet(persistedCache.keySet());
+            LOG.trace(""Found {} keys for exchanges to recover in {} context"", scanned.size(), camelContext.getName());
+            return scanned;
+        } else {
+            LOG.warn(""What for to run recovery scans in {} context while repository {} is running in non-recoverable aggregation repository mode?!"",
+                    camelContext.getName(), mapName);
+            return Collections.emptySet();
+        }
+    }
+
+    @Override
+    public Exchange recover(CamelContext camelContext, String exchangeId) {
+        LOG.trace(""Recovering an Exchange with ID {}."", exchangeId);
+        return useRecovery ? unmarshallExchange(camelContext, persistedCache.get(exchangeId)) : null;
+    }
+
+    @Override
+    public void setRecoveryInterval(long interval, TimeUnit timeUnit) {
+        this.recoveryInterval = timeUnit.toMillis(interval);
+    }
+
+    @Override
+    public void setRecoveryInterval(long interval) {
+        this.recoveryInterval = interval;
+    }
+
+    @Override
+    public long getRecoveryIntervalInMillis() {
+        return recoveryInterval;
+    }
+
+    @Override
+    public void setUseRecovery(boolean useRecovery) {
+        this.useRecovery = useRecovery;
+    }
+
+    @Override
+    public boolean isUseRecovery() {
+        return useRecovery;
+    }
+
+    @Override
+    public void setDeadLetterUri(String deadLetterUri) {
+        this.deadLetterChannel = deadLetterUri;
+    }
+
+    @Override
+    public String getDeadLetterUri() {
+        return deadLetterChannel;
+    }
+
+    @Override
+    public void setMaximumRedeliveries(int maximumRedeliveries) {
+        this.maximumRedeliveries = maximumRedeliveries;
+    }
+
+    @Override
+    public int getMaximumRedeliveries() {
+        return maximumRedeliveries;
+    }
+
+    @Override
+    public Exchange get(CamelContext camelContext, String key) {
+        return unmarshallExchange(camelContext, cache.get(key));
+    }
+    
+    /**
+     * Checks if the key in question is in the repository.
+     * 
+     * @param key Object - key in question
+     */
+    public boolean containsKey(Object key) {
+        if (cache != null) {
+            return cache.containsKey(key);
+        } else {
+            return false;
+        }
+    }
+    
+    public boolean isAllowSerializedHeaders() {
+        return allowSerializedHeaders;
+    }
+
+    public void setAllowSerializedHeaders(boolean allowSerializedHeaders) {
+        this.allowSerializedHeaders = allowSerializedHeaders;
+    }
+
+    @Override
+    public void remove(CamelContext camelContext, String key, Exchange exchange) {
+        DefaultExchangeHolder holder = DefaultExchangeHolder.marshal(exchange, true, allowSerializedHeaders);
+        if (optimistic) {
+            LOG.trace(""Removing an exchange with ID {} for key {} in an optimistic manner."", exchange.getExchangeId(), key);
+            if (!cache.remove(key, holder)) {
+                LOG.error(""Optimistic locking failed for exchange with key {}: IMap#remove removed no Exchanges, while it's expected to remove one."",
+                        key);
+                throw new OptimisticLockingException();
+            }
+            LOG.trace(""Removed an exchange with ID {} for key {} in an optimistic manner."", exchange.getExchangeId(), key);
+            if (useRecovery) {
+                LOG.trace(""Putting an exchange with ID {} for key {} into a recoverable storage in an optimistic manner."",
+                        exchange.getExchangeId(), key);
+                persistedCache.put(exchange.getExchangeId(), holder);
+                LOG.trace(""Put an exchange with ID {} for key {} into a recoverable storage in an optimistic manner."",
+                        exchange.getExchangeId(), key);
+            }
+        } else {
+            if (useRecovery) {
+                LOG.trace(""Removing an exchange with ID {} for key {} in a thread-safe manner."", exchange.getExchangeId(), key);
+                TransactionOptions tOpts = TransactionOptions.defaults();
+                RTransaction transaction = redisson.createTransaction(tOpts);
+
+                try {
+                	RMap<String, DefaultExchangeHolder> tCache = transaction.getMap(mapName);
+                	RMap<String, DefaultExchangeHolder> tPersistentCache = transaction.getMap(persistenceMapName);
+
+                    DefaultExchangeHolder removedHolder = tCache.remove(key);
+                    LOG.trace(""Putting an exchange with ID {} for key {} into a recoverable storage in a thread-safe manner."",
+                            exchange.getExchangeId(), key);
+                    tPersistentCache.put(exchange.getExchangeId(), removedHolder);
+
+                    transaction.commit();
+                    LOG.trace(""Removed an exchange with ID {} for key {} in a thread-safe manner."", exchange.getExchangeId(), key);
+                    LOG.trace(""Put an exchange with ID {} for key {} into a recoverable storage in a thread-safe manner."",
+                            exchange.getExchangeId(), key);
+                } catch (Throwable throwable) {
+                	transaction.rollback();
+
+                    final String msg = String.format(""Transaction was rolled back for remove operation with a key %s and an Exchange ID %s."",
+                    		key, exchange.getExchangeId());
+                    LOG.warn(msg, throwable);
+                    throw new RuntimeException(msg, throwable);
+                }
+            } else {
+                cache.remove(key);
+            }
+        }
+    }
+
+    @Override
+    public void confirm(CamelContext camelContext, String exchangeId) {
+        LOG.trace(""Confirming an exchange with ID {}."", exchangeId);
+        if (useRecovery) {
+            persistedCache.remove(exchangeId);
+        }
+    }
+
+    @Override
+    public Set<String> getKeys() {
+        return Collections.unmodifiableSet(cache.keySet());
+    }
+
+    /**
+     * @return Persistent repository {@link IMap} name;
+     */
+    public String getPersistentRepositoryName() {
+        return persistenceMapName;
+    }
+
+	@Override
+	protected void doStart() throws Exception {
+		if (maximumRedeliveries < 0) {
+			throw new IllegalArgumentException(""Maximum redelivery retries must be zero or a positive integer."");
+		}
+		if (recoveryInterval < 0) {
+			throw new IllegalArgumentException(""Recovery interval must be zero or a positive integer."");
+		}
+		StringHelper.notEmpty(mapName, ""repositoryName"");
+		Config config = new Config();
+		config.useSingleServer().setAddress(String.format(""redis://%s"",endpoint));
+		redisson = Redisson.create(config);
+		cache = redisson.getMap(mapName);
+		if (useRecovery) {
+            persistedCache = redisson.getMap(persistenceMapName);
+        }
+	}
+
+	@Override
+	protected void doStop() throws Exception {
+		redisson.shutdown();","[{'comment': 'you may need to check if the `redisson` instance is `null` ', 'commenter': 'lburgazzoli'}]"
3993,components/pom.xml,"@@ -306,6 +306,7 @@
         <module>camel-reactive-executor-vertx</module>
         <module>camel-reactive-streams</module>
         <module>camel-reactor</module>
+		<module>camel-redis</module>","[{'comment': 'would be better to fix the indentation in this and the other xml files', 'commenter': 'lburgazzoli'}]"
4000,components/camel-cassandraql/pom.xml,"@@ -45,8 +45,13 @@
 
         <!-- cassandra -->
         <dependency>
-            <groupId>com.datastax.cassandra</groupId>
-            <artifactId>cassandra-driver-core</artifactId>
+            <groupId>com.datastax.oss</groupId>
+            <artifactId>java-driver-core</artifactId>
+        </dependency>
+        <dependency>
+            <groupId>com.datastax.oss</groupId>
+            <artifactId>java-driver-query-builder</artifactId>
+            <version>4.7.2</version>","[{'comment': 'This should go in parent pom', 'commenter': 'oscerd'}, {'comment': ""sounds great, I'll rework it and I think that tests could be allowed on CI with testcontainers. (I'v kept cassandra-util as it was used before)"", 'commenter': 'JiriOndrusek'}, {'comment': ""I'll fix that version, I've missed it"", 'commenter': 'JiriOndrusek'}]"
4002,components/camel-arangodb/pom.xml,"@@ -0,0 +1,156 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one or more
+    contributor license agreements.  See the NOTICE file distributed with
+    this work for additional information regarding copyright ownership.
+    The ASF licenses this file to You under the Apache License, Version 2.0
+    (the ""License""); you may not use this file except in compliance with
+    the License.  You may obtain a copy of the License at
+
+         http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an ""AS IS"" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+
+-->
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <artifactId>components</artifactId>
+    <groupId>org.apache.camel</groupId>
+    <version>3.5.0-SNAPSHOT</version>
+  </parent>
+
+  <groupId>org.apache.camel</groupId>
+  <artifactId>camel-arangodb</artifactId>
+  <packaging>jar</packaging>
+
+  <name>Camel ArangoDb Component</name>
+  <description>Camel ArangoDb (Java Driver) component</description>
+
+  <properties>
+    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
+    <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
+  </properties>
+
+  <dependencyManagement>
+    <dependencies>
+      <!-- Camel BOM -->
+      <dependency>
+        <groupId>org.apache.camel</groupId>
+        <artifactId>camel-bom</artifactId>","[{'comment': ""This shouldn't be used in the internal components"", 'commenter': 'oscerd'}, {'comment': 'done', 'commenter': 'zbendhiba'}]"
4002,components/camel-arangodb/pom.xml,"@@ -0,0 +1,156 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one or more
+    contributor license agreements.  See the NOTICE file distributed with
+    this work for additional information regarding copyright ownership.
+    The ASF licenses this file to You under the Apache License, Version 2.0
+    (the ""License""); you may not use this file except in compliance with
+    the License.  You may obtain a copy of the License at
+
+         http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an ""AS IS"" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+
+-->
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <artifactId>components</artifactId>
+    <groupId>org.apache.camel</groupId>
+    <version>3.5.0-SNAPSHOT</version>
+  </parent>
+
+  <groupId>org.apache.camel</groupId>
+  <artifactId>camel-arangodb</artifactId>
+  <packaging>jar</packaging>
+
+  <name>Camel ArangoDb Component</name>
+  <description>Camel ArangoDb (Java Driver) component</description>
+
+  <properties>
+    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
+    <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
+  </properties>
+
+  <dependencyManagement>
+    <dependencies>
+      <!-- Camel BOM -->
+      <dependency>
+        <groupId>org.apache.camel</groupId>
+        <artifactId>camel-bom</artifactId>
+        <version>3.5.0-SNAPSHOT</version>
+        <scope>import</scope>
+        <type>pom</type>
+      </dependency>
+    </dependencies>
+  </dependencyManagement>
+
+  <dependencies>
+    <!-- ArangoDb driver dependency -->
+    <dependency>
+      <groupId>com.arangodb</groupId>
+      <artifactId>arangodb-java-driver</artifactId>
+      <version>6.7.0</version>
+    </dependency>
+
+    <!-- camel -->
+    <dependency>
+      <groupId>org.apache.camel</groupId>
+      <artifactId>camel-support</artifactId>
+    </dependency>
+    
+    <!-- logging -->
+    <dependency>
+      <groupId>org.apache.logging.log4j</groupId>
+      <artifactId>log4j-slf4j-impl</artifactId>
+      <version>2.13.3</version>","[{'comment': 'Use the version coming from parent/pom', 'commenter': 'oscerd'}, {'comment': 'done', 'commenter': 'zbendhiba'}]"
4002,components/camel-arangodb/pom.xml,"@@ -0,0 +1,156 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one or more
+    contributor license agreements.  See the NOTICE file distributed with
+    this work for additional information regarding copyright ownership.
+    The ASF licenses this file to You under the Apache License, Version 2.0
+    (the ""License""); you may not use this file except in compliance with
+    the License.  You may obtain a copy of the License at
+
+         http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an ""AS IS"" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+
+-->
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <artifactId>components</artifactId>
+    <groupId>org.apache.camel</groupId>
+    <version>3.5.0-SNAPSHOT</version>
+  </parent>
+
+  <groupId>org.apache.camel</groupId>
+  <artifactId>camel-arangodb</artifactId>
+  <packaging>jar</packaging>
+
+  <name>Camel ArangoDb Component</name>
+  <description>Camel ArangoDb (Java Driver) component</description>
+
+  <properties>
+    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
+    <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
+  </properties>
+
+  <dependencyManagement>
+    <dependencies>
+      <!-- Camel BOM -->
+      <dependency>
+        <groupId>org.apache.camel</groupId>
+        <artifactId>camel-bom</artifactId>
+        <version>3.5.0-SNAPSHOT</version>
+        <scope>import</scope>
+        <type>pom</type>
+      </dependency>
+    </dependencies>
+  </dependencyManagement>
+
+  <dependencies>
+    <!-- ArangoDb driver dependency -->
+    <dependency>
+      <groupId>com.arangodb</groupId>
+      <artifactId>arangodb-java-driver</artifactId>
+      <version>6.7.0</version>","[{'comment': 'This property placeholder version should go in parent/pom', 'commenter': 'oscerd'}, {'comment': 'done', 'commenter': 'zbendhiba'}]"
4002,components/camel-arangodb/pom.xml,"@@ -0,0 +1,156 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one or more
+    contributor license agreements.  See the NOTICE file distributed with
+    this work for additional information regarding copyright ownership.
+    The ASF licenses this file to You under the Apache License, Version 2.0
+    (the ""License""); you may not use this file except in compliance with
+    the License.  You may obtain a copy of the License at
+
+         http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an ""AS IS"" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+
+-->
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <artifactId>components</artifactId>
+    <groupId>org.apache.camel</groupId>
+    <version>3.5.0-SNAPSHOT</version>
+  </parent>
+
+  <groupId>org.apache.camel</groupId>
+  <artifactId>camel-arangodb</artifactId>
+  <packaging>jar</packaging>
+
+  <name>Camel ArangoDb Component</name>
+  <description>Camel ArangoDb (Java Driver) component</description>
+
+  <properties>
+    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
+    <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
+  </properties>
+
+  <dependencyManagement>
+    <dependencies>
+      <!-- Camel BOM -->
+      <dependency>
+        <groupId>org.apache.camel</groupId>
+        <artifactId>camel-bom</artifactId>
+        <version>3.5.0-SNAPSHOT</version>
+        <scope>import</scope>
+        <type>pom</type>
+      </dependency>
+    </dependencies>
+  </dependencyManagement>
+
+  <dependencies>
+    <!-- ArangoDb driver dependency -->
+    <dependency>
+      <groupId>com.arangodb</groupId>
+      <artifactId>arangodb-java-driver</artifactId>
+      <version>6.7.0</version>
+    </dependency>
+
+    <!-- camel -->
+    <dependency>
+      <groupId>org.apache.camel</groupId>
+      <artifactId>camel-support</artifactId>
+    </dependency>
+    
+    <!-- logging -->
+    <dependency>
+      <groupId>org.apache.logging.log4j</groupId>
+      <artifactId>log4j-slf4j-impl</artifactId>
+      <version>2.13.3</version>
+      <scope>test</scope>
+    </dependency>
+
+    <!-- testing -->
+    <dependency>
+      <groupId>org.apache.camel</groupId>
+      <artifactId>camel-test</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.apache.camel</groupId>
+      <artifactId>camel-testcontainers-spring-junit5</artifactId>
+      <scope>test</scope>
+    </dependency>
+  </dependencies>
+
+  <build>
+    <defaultGoal>install</defaultGoal>
+
+    <plugins>
+      
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-compiler-plugin</artifactId>
+        <version>3.8.1</version>
+        <configuration>
+          <source>1.8</source>
+          <target>1.8</target>
+        </configuration>
+      </plugin>
+      
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-resources-plugin</artifactId>
+        <version>3.1.0</version>
+        <configuration>
+          <encoding>UTF-8</encoding>
+        </configuration>
+      </plugin>
+
+      <!-- generate camel meta-data -->","[{'comment': 'No need for this, have a look at the other components pom to have an example of internal components POM', 'commenter': 'oscerd'}, {'comment': 'done. Replaced by the profiles for testcontainers', 'commenter': 'zbendhiba'}]"
4002,components/camel-arangodb/src/main/java/org/apache/camel/component/arangodb/ArangoDbEndpoint.java,"@@ -0,0 +1,197 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.arangodb;
+
+import com.arangodb.ArangoDB;
+import org.apache.camel.Category;
+import org.apache.camel.Consumer;
+import org.apache.camel.Processor;
+import org.apache.camel.Producer;
+import org.apache.camel.spi.Metadata;
+import org.apache.camel.spi.UriEndpoint;
+import org.apache.camel.spi.UriParam;
+import org.apache.camel.spi.UriPath;
+import org.apache.camel.support.DefaultEndpoint;
+
+/**
+ * Perform operations on ArangoDb documents, collections and graphs.
+ */
+@UriEndpoint(firstVersion = ""3.5.0-SNAPSHOT"", scheme = ""arangodb"", title = ""ArangoDb"", syntax = ""arangodb:name"", category = {Category.DATABASE, Category.NOSQL}, producerOnly = true)
+public class ArangoDbEndpoint extends DefaultEndpoint {
+    private ArangoDB arango;
+
+    @UriPath
+    @Metadata(required = true)
+    private String database;
+    @UriParam
+    private String host;
+    @UriParam
+    private int port;
+    @UriParam(label = ""security"", secret = true)
+    private String user;
+    @UriParam(label = ""security"", secret = true)
+    private String password;
+    @UriParam
+    private String collection;
+    @UriParam
+    private ArangoDbOperation operation;
+
+    public ArangoDbEndpoint() {
+    }
+
+    public ArangoDbEndpoint(String uri, ArangoDbComponent component) {
+        super(uri, component);
+    }
+
+    public Producer createProducer() {
+        return new ArangoDbProducer(this);
+    }
+
+    public Consumer createConsumer(Processor processor) {
+        throw new UnsupportedOperationException(""You cannot receive messages at this endpoint: "" + getEndpointUri());
+    }
+
+    public String getDatabase() {
+        return database;
+    }
+
+    /**
+     * database name
+     *
+     * @param database
+     */
+    public void setDatabase(String database) {
+        this.database = database;
+    }
+
+    public ArangoDB getArango() {
+        return arango;
+    }
+
+    public void setArango(ArangoDB arango) {
+        this.arango = arango;
+    }
+
+    public String getHost() {
+        return host;
+    }
+
+    /**
+     * host if host and/or port different from default
+     *
+     * @param host
+     */
+    public void setHost(String host) {
+        this.host = host;
+    }
+
+    public int getPort() {
+        return port;
+    }
+
+    /**
+     * port if  host and/or port different from default
+     *
+     * @param port
+     */
+    public void setPort(int port) {
+        this.port = port;
+    }
+
+    public String getUser() {
+        return user;
+    }
+
+    /**
+     * user if user and/or password different from default
+     *
+     * @param user
+     */
+    public void setUser(String user) {
+        this.user = user;
+    }
+
+    public String getPassword() {
+        return password;
+    }
+
+    /**
+     * password if user and/or password different from default
+     *
+     * @param password
+     */
+    public void setPassword(String password) {
+        this.password = password;
+    }
+
+
+    public String getCollection() {
+        return collection;
+    }
+
+    /**
+     * collection in the database
+     *
+     * @param collection
+     */
+    public void setCollection(String collection) {
+        this.collection = collection;
+    }
+
+    public ArangoDbOperation getOperation() {
+        return operation;
+    }
+
+    /**
+     * operation to perform
+     *
+     * @param operation
+     */
+    public void setOperation(ArangoDbOperation operation) {
+        this.operation = operation;
+    }
+
+    @Override
+    protected void doStart() throws Exception {
+        super.doStart();
+
+        if (arango == null) {
+
+            final ArangoDB.Builder builder = new ArangoDB.Builder();
+
+            if (host != null) {
+                builder.host(host, port);
+            }
+
+            if (user != null) {","[{'comment': 'You can use the ObjectHelper methods for checking', 'commenter': 'oscerd'}, {'comment': 'done', 'commenter': 'zbendhiba'}]"
4002,components/camel-arangodb/src/main/resources/META-INF/services/org/apache/camel/component/arangodb,"@@ -0,0 +1,17 @@
+## ---------------------------------------------------------------------------","[{'comment': 'This file is not needed anymore.', 'commenter': 'oscerd'}, {'comment': 'done', 'commenter': 'zbendhiba'}]"
4002,components/camel-arangodb/src/test/java/org/apache/camel/component/arangodb/ArangoCollectionFindByKeyTest.java,"@@ -0,0 +1,148 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.arangodb;
+
+import com.arangodb.ArangoCollection;
+import com.arangodb.entity.BaseDocument;
+import com.arangodb.velocypack.VPackSlice;
+import org.apache.camel.Exchange;
+import org.apache.camel.builder.RouteBuilder;
+import org.junit.jupiter.api.AfterEach;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+
+import java.util.Map;
+
+import static org.apache.camel.component.arangodb.ArangoDbConstants.RESULT_CLASS_TYPE;
+import static org.junit.jupiter.api.Assertions.*;","[{'comment': 'Better to avoid * for code style purpose.', 'commenter': 'oscerd'}, {'comment': 'done', 'commenter': 'zbendhiba'}]"
4002,components/camel-arangodb/src/test/java/org/apache/camel/component/arangodb/ArangoCollectionQueryTest.java,"@@ -0,0 +1,80 @@
+package org.apache.camel.component.arangodb;","[{'comment': 'missing asf license', 'commenter': 'oscerd'}, {'comment': 'done', 'commenter': 'zbendhiba'}]"
4010,docs/user-manual/modules/ROOT/pages/contributing.adoc,"@@ -169,7 +170,7 @@ We gladly accept patches if you can find ways to improve, tune or fix Camel in s
 
 We recommend using github PRs instead of manual patch files. Especially for bigger patches.
 
-Most IDEs can create nice patches now very easily. e.g. in Eclipse just right click on a file/directory and select Team \-> Create Patch. Then just save the patch as a file and attach it to the corresponding issue on our https://issues.apache.org/jira/browse/CAMEL[JIRA issue tracker].
+Most IDEs can create nice patches now very easily. e.g. in Eclipse just right click on a file/directory and select Team \-> Create Patch. Then just save the patch as a file and attach it to the corresponding issue on our https://issues.apache.org/jira/browse/CAMEL[JIRA issue tracker]. (You may have to click on Team -> Share... first to enable the Subversion options).","[{'comment': 'I think there is anybody out there still using subversion for Apache Camel.', 'commenter': 'oscerd'}]"
4010,docs/user-manual/modules/ROOT/pages/contributing.adoc,"@@ -86,6 +86,7 @@ For more information see xref:faq:how-does-the-website-work.adoc[How does the we
 
 Please raise a new issue on our https://issues.apache.org/jira/browse/CAMEL[JIRA issue tracker]. This way we’ll know when it’s really fixed and we can ensure that the problem stays fixed in future releases. Please describe the bug/issue clearly, and add pictures/screenshots if necessary. If you can create a JUnit test case then your issue is more likely to be resolved quicker.
 e.g. take a look at some of the existing https://svn.apache.org/repos/asf/camel/trunk/camel-core/src/test/java/[unit tests cases]
+Then we can add your issue to Subversion and then we'll know when its really fixed and we can ensure that the problem stays fixed in future releases.","[{'comment': 'Ditto', 'commenter': 'oscerd'}]"
4016,components/camel-opentelemetry/pom.xml,"@@ -0,0 +1,73 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one or more
+    contributor license agreements.  See the NOTICE file distributed with
+    this work for additional information regarding copyright ownership.
+    The ASF licenses this file to You under the Apache License, Version 2.0
+    (the ""License""); you may not use this file except in compliance with
+    the License.  You may obtain a copy of the License at
+
+         http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an ""AS IS"" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+
+-->
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>org.apache.camel</groupId>
+    <artifactId>components</artifactId>
+    <version>3.5.0-SNAPSHOT</version>
+  </parent>
+
+
+  <artifactId>camel-opentelemetry</artifactId>
+  <packaging>jar</packaging>
+  <name>Camel :: OpenTelemetry</name>
+  <description>Distributed tracing using OpenTelemetry</description>
+
+  <properties>
+    <firstVersion>3.5.0</firstVersion>
+    <label>monitoring,microservice</label>
+    <title>OpenTelemetry</title>
+    <opentracing-agent.lib>${project.build.directory}/lib</opentracing-agent.lib>
+  </properties>
+
+  <dependencies>
+    <dependency>
+      <groupId>org.apache.camel</groupId>
+      <artifactId>camel-support</artifactId>
+    </dependency>
+    <dependency>
+      <groupId>org.apache.camel</groupId>
+      <artifactId>camel-tracing</artifactId>
+    </dependency>
+    <dependency>
+      <groupId>io.grpc</groupId>
+      <artifactId>grpc-netty-shaded</artifactId>
+      <version>1.28.0</version>","[{'comment': 'you should use the version from parent POM', 'commenter': 'oscerd'}]"
4016,components/camel-opentelemetry/pom.xml,"@@ -0,0 +1,73 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one or more
+    contributor license agreements.  See the NOTICE file distributed with
+    this work for additional information regarding copyright ownership.
+    The ASF licenses this file to You under the Apache License, Version 2.0
+    (the ""License""); you may not use this file except in compliance with
+    the License.  You may obtain a copy of the License at
+
+         http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an ""AS IS"" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+
+-->
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>org.apache.camel</groupId>
+    <artifactId>components</artifactId>
+    <version>3.5.0-SNAPSHOT</version>
+  </parent>
+
+
+  <artifactId>camel-opentelemetry</artifactId>
+  <packaging>jar</packaging>
+  <name>Camel :: OpenTelemetry</name>
+  <description>Distributed tracing using OpenTelemetry</description>
+
+  <properties>
+    <firstVersion>3.5.0</firstVersion>
+    <label>monitoring,microservice</label>
+    <title>OpenTelemetry</title>
+    <opentracing-agent.lib>${project.build.directory}/lib</opentracing-agent.lib>
+  </properties>
+
+  <dependencies>
+    <dependency>
+      <groupId>org.apache.camel</groupId>
+      <artifactId>camel-support</artifactId>
+    </dependency>
+    <dependency>
+      <groupId>org.apache.camel</groupId>
+      <artifactId>camel-tracing</artifactId>
+    </dependency>
+    <dependency>
+      <groupId>io.grpc</groupId>
+      <artifactId>grpc-netty-shaded</artifactId>
+      <version>1.28.0</version>
+    </dependency>
+    <dependency>
+      <groupId>io.opentelemetry</groupId>
+      <artifactId>opentelemetry-sdk</artifactId>
+      <version>0.6.0</version>","[{'comment': 'It should be declared in the parent POM', 'commenter': 'oscerd'}]"
4016,components/camel-opentelemetry/src/main/java/org/apache/camel/opentelemetry/OpenTelemetrySpanWrapper.java,"@@ -0,0 +1,126 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.opentelemetry;
+
+import java.util.*;","[{'comment': 'Please use the explicit imports, no * operator', 'commenter': 'oscerd'}]"
4016,components/camel-opentracing/src/main/java/org/apache/camel/opentracing/GetBaggageProcessor.java,"@@ -24,6 +24,7 @@
 import org.apache.camel.spi.IdAware;","[{'comment': 'This will probably create conflicts with this #4001 once we merge it', 'commenter': 'oscerd'}, {'comment': ""I see :( I'll fix those conflicts."", 'commenter': 'rubenvp8510'}]"
4016,components/camel-opentracing/src/test/java/org/apache/camel/opentracing/CamelOpenTracingTestSupport.java,"@@ -14,16 +14,11 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package org.apache.camel.opentracing;
 
-import java.net.URI;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
+import java.net.*;","[{'comment': 'Please use the explicit imports.', 'commenter': 'oscerd'}]"
4016,components/camel-opentelemetry/pom.xml,"@@ -0,0 +1,89 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one or more
+    contributor license agreements.  See the NOTICE file distributed with
+    this work for additional information regarding copyright ownership.
+    The ASF licenses this file to You under the Apache License, Version 2.0
+    (the ""License""); you may not use this file except in compliance with
+    the License.  You may obtain a copy of the License at
+
+         http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an ""AS IS"" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+
+-->
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>org.apache.camel</groupId>
+    <artifactId>components</artifactId>
+    <version>3.5.0-SNAPSHOT</version>
+  </parent>
+
+
+  <artifactId>camel-opentelemetry</artifactId>
+  <packaging>jar</packaging>
+  <name>Camel :: OpenTelemetry</name>
+  <description>Distributed tracing using OpenTelemetry</description>
+
+  <properties>
+    <firstVersion>3.5.0</firstVersion>
+    <label>monitoring,microservice</label>
+    <title>OpenTelemetry</title>
+    <opentracing-agent.lib>${project.build.directory}/lib</opentracing-agent.lib>
+  </properties>
+
+  <dependencies>
+    <dependency>
+      <groupId>org.apache.camel</groupId>
+      <artifactId>camel-support</artifactId>
+    </dependency>
+    <dependency>
+      <groupId>org.apache.camel</groupId>
+      <artifactId>camel-tracing</artifactId>
+    </dependency>
+    <dependency>
+      <groupId>io.grpc</groupId>
+      <artifactId>grpc-netty-shaded</artifactId>
+      <version>${grpc-version}</version>
+    </dependency>
+    <dependency>
+      <groupId>io.opentelemetry</groupId>
+      <artifactId>opentelemetry-sdk</artifactId>
+      <version>${opentelemetry-version}</version>
+    </dependency>
+    <dependency>
+      <groupId>io.opentelemetry</groupId>
+      <artifactId>opentelemetry-api</artifactId>
+      <version>${opentelemetry-version}</version>
+    </dependency>
+    <dependency>
+      <groupId>io.opentelemetry</groupId>
+      <artifactId>opentelemetry-exporters-otlp</artifactId>
+      <version>${opentelemetry-version}</version>
+    </dependency>
+    <dependency>
+      <groupId>org.apache.logging.log4j</groupId>
+      <artifactId>log4j-slf4j-impl</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.apache.camel</groupId>
+      <artifactId>camel-test-spring-junit5</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>io.opentelemetry</groupId>
+      <artifactId>opentelemetry-exporters-inmemory</artifactId>
+      <version>0.6.0</version>","[{'comment': 'Use version placeholder', 'commenter': 'davsclaus'}]"
4016,components/camel-opentelemetry/src/main/java/org/apache/camel/opentelemetry/OpenTelemetrySpanAdapter.java,"@@ -0,0 +1,121 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.opentelemetry;
+
+import java.util.EnumMap;
+import java.util.Map;
+
+import io.opentelemetry.common.AttributeValue;
+import io.opentelemetry.common.Attributes;
+import io.opentelemetry.trace.attributes.SemanticAttributes;
+import org.apache.camel.tracing.SpanAdapter;
+import org.apache.camel.tracing.Tag;
+
+public class OpenTelemetrySpanAdapter implements SpanAdapter {
+    private static final String DEFAULT_EVENT_NAME = ""log"";
+
+    private static EnumMap<Tag, String> tagMap = new EnumMap<>(Tag.class);
+
+    static {
+        tagMap.put(Tag.COMPONENT, ""component"");
+        tagMap.put(Tag.DB_TYPE, SemanticAttributes.DB_TYPE.key());
+        tagMap.put(Tag.DB_STATEMENT, SemanticAttributes.DB_STATEMENT.key());
+        tagMap.put(Tag.DB_INSTANCE, SemanticAttributes.DB_INSTANCE.key());
+        tagMap.put(Tag.HTTP_METHOD, SemanticAttributes.HTTP_METHOD.key());
+        tagMap.put(Tag.HTTP_STATUS, SemanticAttributes.HTTP_STATUS_CODE.key());
+        tagMap.put(Tag.HTTP_URL, SemanticAttributes.HTTP_URL.key());
+        tagMap.put(Tag.MESSAGE_BUS_DESTINATION, ""message_bus.destination"");
+    }
+
+
+    io.opentelemetry.trace.Span span;
+
+    OpenTelemetrySpanAdapter(io.opentelemetry.trace.Span span) {
+        this.span = span;
+    }
+
+    io.opentelemetry.trace.Span getOpenTelemetrySpan() {
+        return this.span;
+    }
+
+    @Override public void setComponent(String component) {
+        this.span.setAttribute(""component"", component);
+    }
+
+    @Override public void setError(boolean error) {
+        this.span.setAttribute(""error"", error);
+    }
+
+    @Override public void setTag(Tag key, String value) {
+        this.span.setAttribute(tagMap.get(key), value);
+    }
+
+    @Override public void setTag(Tag key, Number value) {
+        this.span.setAttribute(tagMap.get(key), value.intValue());
+    }
+
+    @Override public void setTag(String key, String value) {
+        this.span.setAttribute(key, value);
+    }
+
+    @Override public void setTag(String key, Number value) {
+        this.span.setAttribute(key, value.intValue());
+    }
+
+    @Override public void setTag(String key, Boolean value) {
+        this.span.setAttribute(key, value);
+    }
+
+    @Override public void log(Map<String, String> fields) {
+        span.addEvent(getEventNameFromFields(fields), convertToAttributes(fields));
+","[{'comment': 'Remove empty line', 'commenter': 'davsclaus'}]"
4016,components/camel-opentelemetry/src/main/java/org/apache/camel/opentelemetry/propagators/OpenTelemetryGetter.java,"@@ -0,0 +1,29 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.opentelemetry.propagators;
+
+import javax.annotation.Nullable;
+
+import io.opentelemetry.context.propagation.HttpTextFormat;
+import org.apache.camel.tracing.ExtractAdapter;
+
+public class OpenTelemetryGetter implements HttpTextFormat.Getter<ExtractAdapter> {
+
+    @Nullable @Override public String get(ExtractAdapter adapter, String key) {","[{'comment': 'We do not use Nullable annotations in camel (yet)', 'commenter': 'davsclaus'}]"
4016,components/camel-tracing/src/main/java/org/apache/camel/tracing/Tracer.java,"@@ -0,0 +1,345 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.tracing;
+
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Map;
+import java.util.ServiceLoader;
+import java.util.Set;
+
+import org.apache.camel.CamelContext;
+import org.apache.camel.CamelContextAware;
+import org.apache.camel.Component;
+import org.apache.camel.Endpoint;
+import org.apache.camel.Exchange;
+import org.apache.camel.ExtendedCamelContext;
+import org.apache.camel.NamedNode;
+import org.apache.camel.Route;
+import org.apache.camel.RuntimeCamelException;
+import org.apache.camel.StaticService;
+import org.apache.camel.spi.CamelEvent;
+import org.apache.camel.spi.CamelLogger;
+import org.apache.camel.spi.InterceptStrategy;
+import org.apache.camel.spi.LogListener;
+import org.apache.camel.spi.RoutePolicy;
+import org.apache.camel.spi.RoutePolicyFactory;
+import org.apache.camel.support.DefaultEndpoint;
+import org.apache.camel.support.EndpointHelper;
+import org.apache.camel.support.EventNotifierSupport;
+import org.apache.camel.support.RoutePolicySupport;
+import org.apache.camel.support.service.ServiceHelper;
+import org.apache.camel.support.service.ServiceSupport;
+import org.apache.camel.tracing.decorators.AbstractInternalSpanDecorator;
+import org.apache.camel.util.ObjectHelper;
+import org.apache.camel.util.StringHelper;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public abstract class Tracer extends ServiceSupport implements RoutePolicyFactory, StaticService, CamelContextAware {
+    protected static final Map<String, SpanDecorator> DECORATORS = new HashMap<>();
+    private static final Logger LOG = LoggerFactory.getLogger(Tracer.class);
+
+    static {
+        ServiceLoader.load(SpanDecorator.class).forEach(d -> {
+            SpanDecorator existing = DECORATORS.get(d.getComponent());
+            // Add span decorator if no existing decorator for the component,
+            // or if derived from the existing decorator's class, allowing
+            // custom decorators to be added if they extend the standard
+            // decorators
+            if (existing == null || existing.getClass().isInstance(d)) {
+                DECORATORS.put(d.getComponent(), d);
+            }
+        });
+    }
+
+    private final TracingLogListener logListener = new TracingLogListener();
+    private final TracingEventNotifier eventNotifier = new TracingEventNotifier();
+    private Set<String> excludePatterns = new HashSet<>(0);
+    private InterceptStrategy tracingStrategy;
+    private boolean encoding;
+    private CamelContext camelContext;
+
+    protected abstract void initTracer();
+
+    protected abstract SpanAdapter startSendingEventSpan(String operationName, SpanKind kind, SpanAdapter parent);
+
+    protected abstract SpanAdapter startExchangeBeginSpan(String operationName, SpanKind kind, SpanAdapter parent);
+
+    protected abstract void finishSpan(SpanAdapter span);
+
+    protected abstract void inject(SpanAdapter span, InjectAdapter adapter);
+
+    /**
+     * Returns the currently used tracing strategy which is responsible for tracking invoked EIP or
+     * beans.
+     *
+     * @return The currently used tracing strategy
+     */
+    public InterceptStrategy getTracingStrategy() {
+        return tracingStrategy;
+    }
+
+    /**
+     * Specifies the instance responsible for tracking invoked EIP and beans with OpenTracing.
+     *
+     * @param tracingStrategy The instance which tracks invoked EIP and beans
+     */
+    public void setTracingStrategy(InterceptStrategy tracingStrategy) {
+        this.tracingStrategy = tracingStrategy;
+    }
+
+    public void addDecorator(SpanDecorator decorator) {
+        DECORATORS.put(decorator.getComponent(), decorator);
+    }
+
+    @Override
+    public CamelContext getCamelContext() {
+        return camelContext;
+    }
+
+    @Override
+    public void setCamelContext(CamelContext camelContext) {
+        this.camelContext = camelContext;
+    }
+
+    public Set<String> getExcludePatterns() {
+        return excludePatterns;
+    }
+
+    public void setExcludePatterns(Set<String> excludePatterns) {
+        this.excludePatterns = excludePatterns;
+    }
+
+    public boolean isEncoding() {
+        return encoding;
+    }
+
+    public void setEncoding(boolean encoding) {
+        this.encoding = encoding;
+    }
+
+    /**
+     * Adds an exclude pattern that will disable tracing for Camel messages that
+     * matches the pattern.
+     *
+     * @param pattern the pattern such as route id, endpoint url
+     */
+    public void addExcludePattern(String pattern) {
+        excludePatterns.add(pattern);
+    }
+
+    @Override public RoutePolicy createRoutePolicy(CamelContext camelContext, String routeId, NamedNode route) {
+        init(camelContext);
+        return new TracingRoutePolicy();
+
+    }
+
+    /**
+     * Registers this {@link Tracer} on the {@link CamelContext} if
+     * not already registered.
+     */
+    public void init(CamelContext camelContext) {
+        if (!camelContext.hasService(this)) {
+            try {
+                // start this service eager so we init before Camel is starting up
+                camelContext.addService(this, true, true);
+            } catch (Exception e) {
+                throw RuntimeCamelException.wrapRuntimeCamelException(e);
+            }
+        }
+    }
+
+    @Override protected void doInit() throws Exception {
+        ObjectHelper.notNull(camelContext, ""CamelContext"", this);
+
+        camelContext.getManagementStrategy().addEventNotifier(eventNotifier);
+        if (!camelContext.getRoutePolicyFactories().contains(this)) {
+            camelContext.addRoutePolicyFactory(this);
+        }
+        camelContext.adapt(ExtendedCamelContext.class).addLogListener(logListener);
+
+        if (tracingStrategy != null) {
+            camelContext.adapt(ExtendedCamelContext.class).addInterceptStrategy(tracingStrategy);
+        }
+        initTracer();
+        ServiceHelper.startService(eventNotifier);
+    }
+
+    @Override
+    protected void doShutdown() throws Exception {
+        // stop event notifier
+        camelContext.getManagementStrategy().removeEventNotifier(eventNotifier);
+        ServiceHelper.stopService(eventNotifier);
+
+        // remove route policy
+        camelContext.getRoutePolicyFactories().remove(this);
+    }
+
+    protected SpanDecorator getSpanDecorator(Endpoint endpoint) {
+        SpanDecorator sd = null;
+
+        String uri = endpoint.getEndpointUri();
+        String splitURI[] = StringHelper.splitOnCharacter(uri, "":"", 2);
+        if (splitURI[1] != null) {
+            String scheme = splitURI[0];
+            sd = DECORATORS.get(scheme);
+        }
+        if (sd == null) {
+            // okay there was no decorator found via component name (scheme), then try FQN
+            if (endpoint instanceof DefaultEndpoint) {
+                Component comp = ((DefaultEndpoint) endpoint).getComponent();
+                String fqn = comp.getClass().getName();
+                // lookup via FQN
+                sd = DECORATORS.values().stream().filter(d -> fqn.equals(d.getComponentClassName())).findFirst()
+                .orElse(null);
+            }
+        }
+        if (sd == null) {
+            sd = SpanDecorator.DEFAULT;
+        }
+
+        return sd;
+    }
+
+    private boolean isExcluded(Exchange exchange, Endpoint endpoint) {
+        String url = endpoint.getEndpointUri();
+        if (url != null && !excludePatterns.isEmpty()) {
+            for (String pattern : excludePatterns) {
+                if (EndpointHelper.matchEndpoint(exchange.getContext(), url, pattern)) {
+                    return true;
+                }
+            }
+        }
+        return false;
+    }
+
+    private final class TracingEventNotifier extends EventNotifierSupport {","[{'comment': 'In the logging below change OpenTracing to Tracing', 'commenter': 'davsclaus'}]"
4019,core/camel-core-engine/src/main/docs/modules/eips/pages/dynamic-router.adoc,"@@ -1,198 +0,0 @@
-[[DynamicRouter-DynamicRouter]]","[{'comment': 'Why removing this?', 'commenter': 'oscerd'}, {'comment': 'I have removed the whole file as `dynamic-router.adoc` as well as `dynamicRouter-eip.adoc` encompasses the same information. The same deal goes along with `request-reply.adoc` and `requestReply-eip.adoc`.', 'commenter': 'AemieJ'}]"
4028,components/camel-arangodb/src/main/java/org/apache/camel/component/arangodb/ArangoDbConfiguration.java,"@@ -0,0 +1,141 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.arangodb;
+
+import org.apache.camel.RuntimeCamelException;
+import org.apache.camel.spi.UriParam;
+import org.apache.camel.spi.UriParams;
+
+@UriParams
+public class ArangoDbConfiguration implements Cloneable {
+    private String database;
+    @UriParam
+    private String host;","[{'comment': ""I'd assume at least host and port are required, then I think it makes sense to add `required` metadata to any required fields. "", 'commenter': 'omarsmak'}, {'comment': ""I didn't make them required actually. Since the arangoDb driver has default values if no host/port indicated (same for user/password)"", 'commenter': 'zbendhiba'}, {'comment': 'ah then is all fine', 'commenter': 'omarsmak'}]"
4028,components/camel-arangodb/src/main/java/org/apache/camel/component/arangodb/ArangoDbConfiguration.java,"@@ -0,0 +1,141 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.arangodb;
+
+import org.apache.camel.RuntimeCamelException;
+import org.apache.camel.spi.UriParam;
+import org.apache.camel.spi.UriParams;
+
+@UriParams
+public class ArangoDbConfiguration implements Cloneable {
+    private String database;
+    @UriParam
+    private String host;
+    @UriParam
+    private int port;
+    @UriParam(label = ""security"", secret = true)
+    private String user;
+    @UriParam(label = ""security"", secret = true)
+    private String password;
+    @UriParam","[{'comment': 'Also label here are missing for the configurations, e.g: `producer`, `consumer` or `common` .. etc ', 'commenter': 'omarsmak'}, {'comment': '@zbendhiba can you please add labels here?', 'commenter': 'oscerd'}, {'comment': 'yes , done !!', 'commenter': 'zbendhiba'}]"
4028,components/camel-arangodb/src/main/java/org/apache/camel/component/arangodb/ArangoDbComponent.java,"@@ -18,15 +18,44 @@
 
 import java.util.Map;
 
+import org.apache.camel.CamelContext;
 import org.apache.camel.Endpoint;
+import org.apache.camel.spi.Metadata;
+import org.apache.camel.spi.annotations.Component;
 import org.apache.camel.support.DefaultComponent;
 
-@org.apache.camel.spi.annotations.Component(""arangodb"")
+@Component(""arangodb"")
 public class ArangoDbComponent extends DefaultComponent {
 
+    @Metadata
+    private ArangoDbConfiguration configuration = new ArangoDbConfiguration();
+
+    public ArangoDbComponent() {
+        this(null);
+    }
+
+    public ArangoDbComponent(CamelContext context) {
+        super(context);
+    }
+
     protected Endpoint createEndpoint(String uri, String remaining, Map<String, Object> parameters) throws Exception {
-        Endpoint endpoint = new ArangoDbEndpoint(uri, this);
+        final ArangoDbConfiguration configuration = this.configuration != null ? this.configuration.copy() : new ArangoDbConfiguration();
+        configuration.setDatabase(remaining);","[{'comment': 'Perhaps before setting the `database`, it would make sense to check its validity (e.g: is not empty) ', 'commenter': 'omarsmak'}, {'comment': ""since arango driver has default values, I don't see the need for the check here"", 'commenter': 'omarsmak'}, {'comment': 'we do need database name at minimum for any operation', 'commenter': 'zbendhiba'}]"
4088,components/camel-platform-http/src/test/java/org/apache/camel/component/platform/http/PlatformHttpTest.java,"@@ -0,0 +1,93 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.platform.http;
+
+import io.restassured.RestAssured;
+import io.restassured.response.Response;
+import io.restassured.specification.RequestSpecification;
+import org.apache.camel.CamelContext;
+import org.apache.camel.builder.RouteBuilder;
+import org.apache.camel.impl.DefaultCamelContext;
+import org.apache.camel.test.AvailablePortFinder;
+import org.apache.camel.test.junit5.CamelTestSupport;
+import org.junit.jupiter.api.AfterAll;
+import org.junit.jupiter.api.BeforeAll;
+import org.junit.jupiter.api.Test;
+
+import static io.restassured.RestAssured.given;
+import static org.junit.jupiter.api.Assertions.assertEquals;
+
+
+public class PlatformHttpTest extends CamelTestSupport {
+    private static JettyServerTest server;
+    private static CamelContext ctx;
+    private static int port;
+
+    @BeforeAll
+    public static void init() throws Exception {
+
+        ctx = new DefaultCamelContext();
+        ctx.getRegistry().bind(PlatformHttpConstants.PLATFORM_HTTP_ENGINE_FACTORY, new JettyCustomPlatformHttpEngine());
+
+        port = AvailablePortFinder.getNextAvailable();
+        server = new JettyServerTest(port);
+
+        ctx.getRegistry().bind(JettyServerTest.JETTY_SERVER_NAME, server);
+        server.start();
+
+        ctx.addRoutes(new RouteBuilder() {
+            @Override
+            public void configure() throws Exception {
+                from(""platform-http:/get"")
+                        .setBody().constant(""get"");
+                from(""platform-http:/post"")
+                        .transform().body(String.class, b -> b.toUpperCase());
+            }
+        });
+        ctx.start();
+    }
+
+    @AfterAll
+    public static void initPort() throws Exception {
+        ctx.stop();","[{'comment': 'I would change the name of the method, e.g. `tearDown()`', 'commenter': 'aldettinger'}, {'comment': 'yes!! ', 'commenter': 'zbendhiba'}, {'comment': 'done !!', 'commenter': 'zbendhiba'}]"
4088,components/camel-platform-http/src/test/resources/log4j2.properties,"@@ -0,0 +1,29 @@
+## ---------------------------------------------------------------------------
+## Licensed to the Apache Software Foundation (ASF) under one or more
+## contributor license agreements.  See the NOTICE file distributed with
+## this work for additional information regarding copyright ownership.
+## The ASF licenses this file to You under the Apache License, Version 2.0
+## (the ""License""); you may not use this file except in compliance with
+## the License.  You may obtain a copy of the License at
+##
+##      http://www.apache.org/licenses/LICENSE-2.0
+##
+## Unless required by applicable law or agreed to in writing, software
+## distributed under the License is distributed on an ""AS IS"" BASIS,
+## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+## See the License for the specific language governing permissions and
+## limitations under the License.
+## ---------------------------------------------------------------------------
+appender.file.type = File
+appender.file.name = file
+appender.file.fileName = target/camel-platform-http-test.log
+appender.file.layout.type = PatternLayout
+appender.file.layout.pattern = %d [%-15.15t] %-5p %-30.30c{1} - %m%n
+appender.out.type = Console
+appender.out.name = out
+appender.out.layout.type = PatternLayout
+appender.out.layout.pattern = [%30.30t] %-30.30c{1} %-5p %m%n
+
+rootLogger.level = INFO
+rootLogger.appenderRef.file.ref = file
+#rootLogger.appenderRef.out.ref = out","[{'comment': 'We may remove this line if not needed ?', 'commenter': 'aldettinger'}, {'comment': 'done!!', 'commenter': 'zbendhiba'}]"
4089,components/camel-aws-s3/src/main/java/org/apache/camel/component/aws/s3/client/impl/S3ClientIAMOptimizedImpl.java,"@@ -74,12 +74,14 @@ public AmazonS3 getS3Client() {
 
         if (!configuration.isUseEncryption()) {
             clientBuilder = AmazonS3ClientBuilder.standard().withCredentials(new InstanceProfileCredentialsProvider(false));
-        } else if (configuration.isUseEncryption()) {
+
+            if (configuration.hasProxyConfiguration()) {
+                clientBuilder = clientBuilder.withClientConfiguration(clientConfiguration);
+            }","[{'comment': 'This seems a slightly different issue.  Should this be in a separate commit ?', 'commenter': 'gnodet'}, {'comment': 'Absolutely! I can move this change to a separate commit. Let me modify this one and push again.\r\n', 'commenter': 'orpiske'}, {'comment': 'I have just moved this part of the PR to a separate commit. ', 'commenter': 'orpiske'}]"
4091,components/camel-azure-eventhubs/src/main/java/org/apache/camel/component/azure/eventhubs/EventHubsConsumer.java,"@@ -0,0 +1,127 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.azure.eventhubs;
+
+import com.azure.messaging.eventhubs.EventProcessorClient;
+import com.azure.messaging.eventhubs.models.ErrorContext;
+import com.azure.messaging.eventhubs.models.EventContext;
+import org.apache.camel.Exchange;
+import org.apache.camel.ExtendedExchange;
+import org.apache.camel.Processor;
+import org.apache.camel.component.azure.eventhubs.client.EventHubsClientFactory;
+import org.apache.camel.spi.Synchronization;
+import org.apache.camel.support.DefaultConsumer;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class EventHubsConsumer extends DefaultConsumer {
+
+    private static final Logger LOG = LoggerFactory.getLogger(EventHubsConsumer.class);
+
+    // we use the EventProcessorClient as recommended by Azure docs to consume from all partitions
+    private EventProcessorClient processorClient;
+
+    public EventHubsConsumer(final EventHubsEndpoint endpoint, final Processor processor) {
+        super(endpoint, processor);
+    }
+
+    @Override
+    protected void doStart() throws Exception {
+        super.doStart();
+
+        // create the client
+        processorClient = EventHubsClientFactory.createEventProcessorClient(getConfiguration(),
+                this::onEventListener, this::onErrorListener);
+
+        // start the client but we will rely on the Azure Client Scheduler for thread management
+        processorClient.start();
+    }
+
+    @Override
+    protected void doStop() throws Exception {
+        // shutdown the client
+        processorClient.stop();","[{'comment': 'guard with != null as if camel fails to startup then this start method may not have been invoked and camel will call stop ', 'commenter': 'davsclaus'}]"
4091,components/camel-azure-eventhubs/src/main/java/org/apache/camel/component/azure/eventhubs/EventHubsEndpoint.java,"@@ -0,0 +1,97 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.azure.eventhubs;
+
+import com.azure.messaging.eventhubs.models.ErrorContext;
+import com.azure.messaging.eventhubs.models.EventContext;
+import org.apache.camel.Category;
+import org.apache.camel.Component;
+import org.apache.camel.Consumer;
+import org.apache.camel.Exchange;
+import org.apache.camel.Message;
+import org.apache.camel.Processor;
+import org.apache.camel.Producer;
+import org.apache.camel.spi.UriEndpoint;
+import org.apache.camel.spi.UriParam;
+import org.apache.camel.support.DefaultEndpoint;
+
+/**
+ * The azure-eventhubs component that integrates Azure Event Hubs using AMQP protocol. Azure EventHubs is a highly scalable publish-subscribe service that
+ * can ingest millions of events per second and stream them to multiple consumers.
+ */
+@UriEndpoint(firstVersion = ""3.5.0"", scheme = ""azure-eventhubs"", title = ""Azure Event Hubs"", syntax = ""azure-eventhubs:namespace/eventHubName"", category = {
+        Category.CLOUD, Category.MESSAGING })
+public class EventHubsEndpoint extends DefaultEndpoint {
+
+    @UriParam
+    private EventHubsConfiguration configuration;
+
+    public EventHubsEndpoint(final String uri, final Component component, final EventHubsConfiguration configuration) {
+        super(uri, component);
+        this.configuration = configuration;
+    }
+
+    @Override
+    public Producer createProducer() throws Exception {
+        return new EventHubsProducer(this);
+    }
+
+    @Override
+    public Consumer createConsumer(Processor processor) throws Exception {
+        return new EventHubsConsumer(this, processor);","[{'comment': 'Call configureConsumer(consumer) also, see other components how-to', 'commenter': 'davsclaus'}]"
4091,components/camel-azure-eventhubs/src/main/java/org/apache/camel/component/azure/eventhubs/EventHubsProducer.java,"@@ -0,0 +1,75 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.azure.eventhubs;
+
+import com.azure.messaging.eventhubs.EventHubProducerAsyncClient;
+import org.apache.camel.AsyncCallback;
+import org.apache.camel.Endpoint;
+import org.apache.camel.Exchange;
+import org.apache.camel.component.azure.eventhubs.client.EventHubsClientFactory;
+import org.apache.camel.component.azure.eventhubs.operations.EventHubsProducerOperations;
+import org.apache.camel.support.DefaultAsyncProducer;
+
+public class EventHubsProducer extends DefaultAsyncProducer {
+
+    private EventHubProducerAsyncClient producerAsyncClient;
+    private EventHubsProducerOperations producerOperations;
+
+    public EventHubsProducer(final Endpoint endpoint) {
+        super(endpoint);
+    }
+
+    @Override
+    protected void doStart() throws Exception {
+        super.doStart();
+
+        // create the client
+        producerAsyncClient = EventHubsClientFactory.createEventHubProducerAsyncClient(getEndpoint().getConfiguration());
+
+        // create our operations
+        producerOperations = new EventHubsProducerOperations(producerAsyncClient, getConfiguration());
+    }
+
+    @Override
+    public boolean process(Exchange exchange, AsyncCallback callback) {
+        try {
+            return producerOperations.sendEvents(exchange, callback);
+        } catch (Exception e) {
+            exchange.setException(e);
+            callback.done(true);
+            return true;
+        }
+
+    }
+
+    @Override
+    protected void doStop() throws Exception {
+        // shutdown async client
+        producerAsyncClient.close();","[{'comment': 'The != null here', 'commenter': 'davsclaus'}]"
4091,components/camel-azure-eventhubs/src/main/java/org/apache/camel/component/azure/eventhubs/operations/EventHubsProducerOperations.java,"@@ -0,0 +1,116 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.azure.eventhubs.operations;
+
+import java.util.Collections;
+import java.util.concurrent.atomic.AtomicBoolean;
+
+import com.azure.messaging.eventhubs.EventData;
+import com.azure.messaging.eventhubs.EventHubProducerAsyncClient;
+import com.azure.messaging.eventhubs.models.SendOptions;
+import org.apache.camel.AsyncCallback;
+import org.apache.camel.Exchange;
+import org.apache.camel.component.azure.eventhubs.EventHubsConfiguration;
+import org.apache.camel.component.azure.eventhubs.EventHubsConfigurationOptionsProxy;
+import org.apache.camel.util.ObjectHelper;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import reactor.core.publisher.Mono;
+
+public class EventHubsProducerOperations {
+
+    private static final Logger LOG = LoggerFactory.getLogger(EventHubsProducerOperations.class);
+
+    private final EventHubProducerAsyncClient producerAsyncClient;
+    private final EventHubsConfigurationOptionsProxy configurationOptionsProxy;
+
+    public EventHubsProducerOperations(final EventHubProducerAsyncClient producerAsyncClient, final EventHubsConfiguration configuration) {
+        ObjectHelper.notNull(producerAsyncClient, ""client cannot be null"");
+
+        this.producerAsyncClient = producerAsyncClient;
+        configurationOptionsProxy = new EventHubsConfigurationOptionsProxy(configuration);
+    }
+
+    public boolean sendEvents(final Exchange exchange, final AsyncCallback callback) {
+        ObjectHelper.notNull(exchange, ""exchange cannot be null"");
+        ObjectHelper.notNull(callback, ""callback cannot be null"");
+
+        final SendOptions sendOptions = createSendOptions(configurationOptionsProxy.getPartitionKey(exchange), configurationOptionsProxy.getPartitionId(exchange));
+        final Iterable<EventData> eventData = createEventData(exchange);
+
+        return sendAsyncEvents(eventData, sendOptions, exchange, callback);
+    }
+
+    private boolean sendAsyncEvents(final Iterable<EventData> eventData, final SendOptions sendOptions, final Exchange exchange, final AsyncCallback asyncCallback) {
+        final AtomicBoolean done = new AtomicBoolean(false);","[{'comment': 'The asyncCallback must only be invoked once, not sure if the 3 branches below can cause it to be invoked twice etc.\r\n\r\nSo you should essentially only return true if the method exits early and its the same thread that called this method that is calling the callback.\r\n\r\nSo I would remove the atomic boolean, and make this method return false. And then in the sendAsyncEventsWithSuitableMethod you call the callback with (false) as parameter as it must match what this method returned.', 'commenter': 'davsclaus'}, {'comment': 'Also does the subcribe event below make any sense to react on? I would assume its either only the error or the completion.', 'commenter': 'davsclaus'}]"
4091,components/camel-azure-eventhubs/src/main/java/org/apache/camel/component/azure/eventhubs/operations/EventHubsProducerOperations.java,"@@ -0,0 +1,113 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.azure.eventhubs.operations;
+
+import java.util.Collections;
+
+import com.azure.messaging.eventhubs.EventData;
+import com.azure.messaging.eventhubs.EventHubProducerAsyncClient;
+import com.azure.messaging.eventhubs.models.SendOptions;
+import org.apache.camel.AsyncCallback;
+import org.apache.camel.Exchange;
+import org.apache.camel.component.azure.eventhubs.EventHubsConfiguration;
+import org.apache.camel.component.azure.eventhubs.EventHubsConfigurationOptionsProxy;
+import org.apache.camel.util.ObjectHelper;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import reactor.core.publisher.Mono;
+
+public class EventHubsProducerOperations {
+
+    private static final Logger LOG = LoggerFactory.getLogger(EventHubsProducerOperations.class);
+
+    private final EventHubProducerAsyncClient producerAsyncClient;
+    private final EventHubsConfigurationOptionsProxy configurationOptionsProxy;
+
+    public EventHubsProducerOperations(final EventHubProducerAsyncClient producerAsyncClient, final EventHubsConfiguration configuration) {
+        ObjectHelper.notNull(producerAsyncClient, ""client cannot be null"");
+
+        this.producerAsyncClient = producerAsyncClient;
+        configurationOptionsProxy = new EventHubsConfigurationOptionsProxy(configuration);
+    }
+
+    public boolean sendEvents(final Exchange exchange, final AsyncCallback callback) {
+        ObjectHelper.notNull(exchange, ""exchange cannot be null"");
+        ObjectHelper.notNull(callback, ""callback cannot be null"");
+
+        final SendOptions sendOptions = createSendOptions(configurationOptionsProxy.getPartitionKey(exchange), configurationOptionsProxy.getPartitionId(exchange));
+        final Iterable<EventData> eventData = createEventData(exchange);
+
+        return sendAsyncEvents(eventData, sendOptions, exchange, callback);
+    }
+
+    private boolean sendAsyncEvents(final Iterable<EventData> eventData, final SendOptions sendOptions, final Exchange exchange, final AsyncCallback asyncCallback) {
+        sendAsyncEventsWithSuitableMethod(eventData, sendOptions, asyncCallback)
+                .subscribe(unused -> LOG.debug(""Processed one event...""), error -> {
+                    // error but we continue
+                    LOG.debug(""Error processing async exchange with error:"" + error.getMessage());
+                    exchange.setException(error);
+                }, () -> {
+                    // we are done from everything, so mark it as sync done
+                    LOG.debug(""All events with exchange have been sent successfully."");
+                });
+
+        return false;
+    }
+
+    private Mono<Void> sendAsyncEventsWithSuitableMethod(final Iterable<EventData> eventData, final SendOptions sendOptions,
+                                                         final AsyncCallback asyncCallback) {
+        final Mono<Void> deferredSendResult;
+
+        if (ObjectHelper.isEmpty(sendOptions)) {
+            deferredSendResult = producerAsyncClient.send(eventData);
+        } else {
+            deferredSendResult = producerAsyncClient.send(eventData, sendOptions);
+        }
+
+        // call callback on false since this process is running on the scheduler method of reactor and not needed
+        // to have callback to returns true. Also false, will tell camel async to watch method to which it returns
+        asyncCallback.done(false);","[{'comment': 'I would asumme this asyncCallback.done(false) should be in the previous method inside those 2 callbacks after ( // error but we continue) and also after ( // we are done from everything, so mark it as sync done). As this Camel callback should only be invoked when the azure client is fully complete with its work (either in error or with success).', 'commenter': 'davsclaus'}]"
4092,docs/components/modules/ROOT/pages/bean-component.adoc,"@@ -167,7 +167,7 @@ from(""direct:start"").bean(ExampleBean.class);
 How bean methods to be invoked are chosen (if they are not specified
 explicitly through the *method* parameter) and how parameter values are
 constructed from the Message are all defined by the
-Bean Binding mechanism which is used throughout
+https://camel.apache.org/manual/latest/bean-binding.html[Bean Binding] mechanism which is used throughout","[{'comment': ""We're using [Antora](https://antora.org/) to build the documentation, so we need to adhere to the [xref syntax](https://docs.antora.org/antora/2.3/page/page-id/#whats-a-cross-reference) for linking to pages.\r\n\r\n```suggestion\r\nxref:ROOT:bean-binding.adoc[Bean Binding] mechanism which is used throughout\r\n```"", 'commenter': 'zregvart'}, {'comment': '@zregvart Thank you', 'commenter': 'ctataryn'}]"
4097,components/camel-cmis/src/main/java/org/apache/camel/component/cmis/CMISProducer.java,"@@ -345,7 +347,12 @@ public Document copyDocument(Exchange exchange) throws Exception {
         Folder destinationFolder = (Folder) getSessionFacade().getObjectById(destinationFolderId);
 
         Document document = (Document) getSessionFacade().getObjectById(objectId);
+        String newDocumentName = message.getHeader(PropertyIds.NAME, String.class);
+        if(!StringUtils.isEmpty(newDocumentName))","[{'comment': 'Can you please use ObjectHelper instead of StringUtils?', 'commenter': 'oscerd'}, {'comment': 'There is no isEmpty or notNull or some similar method in ObjectHelper class.\r\nAm I looking at the right class ? ObjectHelper from camel-support module.', 'commenter': 'cherepnalkovski'}, {'comment': 'The class from camel-util\r\n\r\nhttps://github.com/apache/camel/blob/master/core/camel-util/src/main/java/org/apache/camel/util/ObjectHelper.java#L183', 'commenter': 'oscerd'}]"
4101,components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/testContainers/MinioComponentIntegrationTest.java,"@@ -0,0 +1,139 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.minio.integration.testContainers;
+
+import java.io.IOException;
+import java.time.Duration;
+import java.util.Properties;
+
+import org.apache.camel.EndpointInject;
+import org.apache.camel.Exchange;
+import org.apache.camel.ExchangePattern;
+import org.apache.camel.Message;
+import org.apache.camel.ProducerTemplate;
+import org.apache.camel.builder.RouteBuilder;
+import org.apache.camel.component.minio.MinioConstants;
+import org.apache.camel.component.minio.integration.MinioTestUtils;
+import org.apache.camel.component.mock.MockEndpoint;
+import org.apache.camel.test.testcontainers.junit5.ContainerAwareTestSupport;
+import org.junit.jupiter.api.Test;
+import org.testcontainers.containers.GenericContainer;
+import org.testcontainers.containers.wait.strategy.HttpWaitStrategy;
+
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertTrue;
+import static org.junit.jupiter.api.Assertions.assertNotNull;
+import static org.junit.jupiter.api.Assertions.assertNull;
+
+public class MinioComponentIntegrationTest extends ContainerAwareTestSupport {
+
+    final Properties properties = MinioTestUtils.loadMinioPropertiesFile();
+    final int port = 9000;
+
+    @EndpointInject(""direct:start"")
+    private ProducerTemplate template;
+
+    @EndpointInject(""mock:result"")
+    private MockEndpoint result;
+
+    public MinioComponentIntegrationTest() throws IOException {
+    }
+
+    @Test
+    public void sendInOnly() throws Exception {
+        result.expectedMessageCount(1);
+
+        Exchange exchange1 = template.send(""direct:start"", ExchangePattern.InOnly, exchange -> {
+            exchange.getIn().setHeader(MinioConstants.OBJECT_NAME, ""CamelUnitTest"");
+            exchange.getIn().setBody(""This is my bucket content."");
+        });
+
+        Exchange exchange2 = template.send(""direct:start"", ExchangePattern.InOnly, exchange -> {
+            exchange.getIn().setHeader(MinioConstants.OBJECT_NAME, ""CamelUnitTest"");
+            exchange.getIn().setBody(""This is my bucket content."");
+        });
+
+        assertMockEndpointsSatisfied();
+
+        assertResultExchange(result.getExchanges().get(0));
+
+        assertResponseMessage(exchange1.getIn());
+        assertResponseMessage(exchange2.getIn());
+    }
+
+    @Test
+    public void sendInOut() throws Exception {
+        result.expectedMessageCount(1);
+
+        Exchange exchange = template.send(""direct:start"", ExchangePattern.InOut, exchange1 -> {
+            exchange1.getIn().setHeader(MinioConstants.OBJECT_NAME, ""CamelUnitTest"");
+            exchange1.getIn().setBody(""This is my bucket content."");
+        });
+
+        assertMockEndpointsSatisfied();
+
+        assertResultExchange(result.getExchanges().get(0));
+
+        assertResponseMessage(exchange.getMessage());
+    }
+
+    private void assertResultExchange(Exchange resultExchange) {
+        assertEquals(""This is my bucket content."", resultExchange.getIn().getBody(String.class));
+        assertEquals(""mycamelbucket"", resultExchange.getIn().getHeader(MinioConstants.BUCKET_NAME));
+        assertTrue(resultExchange.getIn().getHeader(MinioConstants.OBJECT_NAME, String.class).startsWith(""CamelUnitTest""));
+        assertNull(resultExchange.getIn().getHeader(MinioConstants.VERSION_ID)); // not enabled on this bucket
+        assertNotNull(resultExchange.getIn().getHeader(MinioConstants.LAST_MODIFIED));
+        assertEquals(""application/octet-stream"", resultExchange.getIn().getHeader(MinioConstants.CONTENT_TYPE));
+        assertNull(resultExchange.getIn().getHeader(MinioConstants.CONTENT_ENCODING));
+        assertEquals(26L, resultExchange.getIn().getHeader(MinioConstants.CONTENT_LENGTH));
+        assertNull(resultExchange.getIn().getHeader(MinioConstants.CONTENT_DISPOSITION));
+        assertNull(resultExchange.getIn().getHeader(MinioConstants.CONTENT_MD5));
+        assertNull(resultExchange.getIn().getHeader(MinioConstants.CACHE_CONTROL));
+    }
+
+    private void assertResponseMessage(Message message) {
+        assertNull(message.getHeader(MinioConstants.VERSION_ID));
+    }
+
+    @Override
+    protected RouteBuilder createRouteBuilder() {
+        return new RouteBuilder() {
+            @Override
+            public void configure() {
+                String minioEndpointUri =
+                        ""minio://mycamelbucket?accessKey=Q3AM3UQ867SPQQA43P2F&secretKey=RAW(zuf+tfteSlswRu7BJ86wekitnifILbZam1KYY3TG)&region=us-west-1&autoCreateBucket=true&endpoint=http://127.0.0.1&proxyPort=9000"";","[{'comment': ""Please don't add credentials to the source code files"", 'commenter': 'omarsmak'}, {'comment': ""@omarsmak sure I'll import them from a resource file, Any suggestions regarding above error?"", 'commenter': 'Nayananga'}, {'comment': ""@Nayananga Try to use something similar to [this](https://github.com/apache/camel/blob/992a6b9685f4db49236e540af2546548cf99a7d3/components/camel-couchdb/src/test/java/org/apache/camel/component/couchdb/CouchDbTestSupport.java) as I think testcontainer will generate dynamic IP but then needs to be mapped and then something like `getContainer(CONTAINER_NAME).getContainerIpAddress();` to access your container's IP"", 'commenter': 'omarsmak'}]"
4101,components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioComponentIntegrationTest.java,"@@ -33,18 +36,22 @@
 import static org.junit.jupiter.api.Assertions.assertNull;
 import static org.junit.jupiter.api.Assertions.assertTrue;
 
-@Disabled(""Must be manually tested. Provide your own accessKey and secretKey!"")
+@Disabled(""Goto https://play.min.io and search for 'mycamelbucket'. If bucket(s) does not exist, set 'autoCreateBucket=true' in route(s)"")
 public class MinioComponentIntegrationTest extends CamelTestSupport {","[{'comment': 'Junit5 is used, would be better to remove `public` access modifier in all test classes and all tests methods. So they will have default access modifier:\r\n```\r\nclass MinioComponentIntegrationTest extends CamelTestSupport {\r\n```', 'commenter': 'DenisIstomin'}]"
4101,components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioComponentIntegrationTest.java,"@@ -33,18 +36,22 @@
 import static org.junit.jupiter.api.Assertions.assertNull;
 import static org.junit.jupiter.api.Assertions.assertTrue;
 
-@Disabled(""Must be manually tested. Provide your own accessKey and secretKey!"")
+@Disabled(""Goto https://play.min.io and search for 'mycamelbucket'. If bucket(s) does not exist, set 'autoCreateBucket=true' in route(s)"")
 public class MinioComponentIntegrationTest extends CamelTestSupport {
+    final Properties properties = MinioTestUtils.loadMinioPropertiesFile();
 
     @EndpointInject(""direct:start"")
     private ProducerTemplate template;
 
     @EndpointInject(""mock:result"")
     private MockEndpoint result;
 
+    public MinioComponentIntegrationTest() throws IOException {
+    }
+
     @Test
     public void sendInOnly() throws Exception {","[{'comment': 'Junit5 is used, would be better to remove `public` access modifier in all test classes and all tests methods. So they will have default access modifier:\r\n```\r\nvoid sendInOnly() throws Exception {\r\n```', 'commenter': 'DenisIstomin'}]"
4105,components/camel-http-base/src/main/java/org/apache/camel/http/base/HttpSendDynamicAware.java,"@@ -100,6 +100,10 @@ public Processor createPreProcessor(Exchange exchange, DynamicAwareEntry entry)
             query = URISupport.createQueryString(new LinkedHashMap<>(entry.getLenientProperties()));
         }
 
+        if (query == null && exchange.getIn().getHeader(Exchange.HTTP_QUERY) != null) {","[{'comment': 'Please use ObjectHelper', 'commenter': 'oscerd'}, {'comment': 'Thanks for the suggestion, Used ObjectHelper to check the Header', 'commenter': 'chandra-h-bitd'}]"
4105,components/camel-http/src/test/java/org/apache/camel/component/http/HttpSendDynamicAwareHeadersTest.java,"@@ -0,0 +1,76 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.http;
+
+import org.apache.camel.Exchange;
+import org.apache.camel.RoutesBuilder;
+import org.apache.camel.builder.RouteBuilder;
+import org.apache.camel.component.http.handler.BasicValidationHandler;
+import org.apache.http.impl.bootstrap.HttpServer;
+import org.apache.http.impl.bootstrap.ServerBootstrap;
+import org.junit.jupiter.api.AfterEach;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+
+import static org.apache.camel.component.http.HttpMethods.GET;
+import static org.junit.jupiter.api.Assertions.assertEquals;
+
+public class HttpSendDynamicAwareHeadersTest extends BaseHttpTest {
+
+    private HttpServer localServer;
+
+    @BeforeEach
+    @Override
+    public void setUp() throws Exception {
+        localServer = ServerBootstrap.bootstrap().setHttpProcessor(getBasicHttpProcessor())
+                .setConnectionReuseStrategy(getConnectionReuseStrategy()).setResponseFactory(getHttpResponseFactory())
+                .setExpectationVerifier(getHttpExpectationVerifier()).setSslContext(getSSLContext())
+                .registerHandler(""/dynamicAware"", new BasicValidationHandler(GET.name(), null, null, null)).create();
+        localServer.start();
+
+        super.setUp();
+    }
+
+    @AfterEach
+    @Override
+    public void tearDown() throws Exception {
+        super.tearDown();
+
+        if (localServer != null) {
+            localServer.stop();
+        }
+    }
+
+    @Override
+    protected RoutesBuilder createRouteBuilder() throws Exception {
+        return new RouteBuilder() {
+            @Override
+            public void configure() throws Exception {
+                from(""direct:dynamicAwareWithoutPathHeader"")
+                        .setHeader(Exchange.HTTP_QUERY, constant(""par1=val1&par2=val2""))
+                        .toD(""http://localhost:"" + localServer.getLocalPort() + ""/dynamicAware"");
+            }
+        };
+    }
+
+    @Test
+    public void testDynamicAwareHeadersQuery() throws Exception {
+        Exchange e = fluentTemplate.to(""direct:dynamicAwareWithoutPathHeader"").send();
+        assertEquals(""/dynamicAware"", e.getIn().getHeader(Exchange.HTTP_PATH));
+        assertEquals(""par1=val1&par2=val2"", e.getIn().getHeader(Exchange.HTTP_QUERY));","[{'comment': 'No this just checks that the headers was set via Camel, not really that the HTTP server received those headers. Its something up in your setup you need to add this check', 'commenter': 'davsclaus'}, {'comment': 'See something like: https://github.com/apache/camel/blob/master/components/camel-http/src/test/java/org/apache/camel/component/http/HttpCamelHeadersTest.java#L48', 'commenter': 'davsclaus'}]"
4129,components/camel-http4/src/test/java/org/apache/camel/component/http4/HttpSendDynamicAwareHeadersTest.java,"@@ -0,0 +1,76 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.http4;
+
+import org.apache.camel.Exchange;
+import org.apache.camel.RoutesBuilder;
+import org.apache.camel.builder.RouteBuilder;
+import org.apache.camel.component.http4.handler.BasicValidationHandler;
+import org.apache.http.impl.bootstrap.HttpServer;
+import org.apache.http.impl.bootstrap.ServerBootstrap;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+
+public class HttpSendDynamicAwareHeadersTest extends BaseHttpTest {
+
+    private HttpServer localServer;
+
+    @Before
+    @Override
+    public void setUp() throws Exception {
+        localServer = ServerBootstrap.bootstrap()
+                .setHttpProcessor(getBasicHttpProcessor())
+                .setConnectionReuseStrategy(getConnectionReuseStrategy())
+                .setResponseFactory(getHttpResponseFactory())
+                .setExpectationVerifier(getHttpExpectationVerifier())
+                .setSslContext(getSSLContext())
+                .registerHandler(""/dynamicAware"", new BasicValidationHandler(""GET"", null, null, null)).create();","[{'comment': 'You need to check for the headers like done here: https://github.com/apache/camel/blob/master/components/camel-http/src/test/java/org/apache/camel/component/http/HttpSendDynamicAwareHeadersTest.java#L42', 'commenter': 'davsclaus'}]"
4137,components/camel-jira/src/main/java/org/apache/camel/component/jira/consumer/WatchUpdatesConsumer.java,"@@ -0,0 +1,109 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.camel.component.jira.consumer;
+
+import java.lang.reflect.Method;
+import java.util.*;","[{'comment': ""Can you please fix this? It's better to import only the needed bits."", 'commenter': 'oscerd'}, {'comment': 'It should be fixed now. Thanks!', 'commenter': 'mmelko'}]"
4180,docs/user-manual/modules/ROOT/pages/uuidgenerator.adoc,"@@ -46,11 +46,15 @@ bean registry to find the bean of the type
 [[UuidGenerator-Providedimplementations]]
 == Provided implementations
 
-Camel comes with two implementations of
+Camel comes with three implementations of
 `org.apache.camel.spi.UuidGenerator`:
 
-* `org.apache.camel.support.SimpleUuidGenerator` - This implementation use
-internally a `java.util.concurrent.atomic.AtomicLong` and increase the
+* `org.apache.camel.support.SimpleUuidGenerator` - This implementation uses
+internally a `java.util.concurrent.atomic.AtomicLong` and increases the
 ID for every call by one. Starting with 1 as the first id.
 * `org.apache.camel.impl.engine.DefaultUuidGenerator` - This implementation
-use a fast unique UUID generation that is cluster safe (similar to uuid generator in ActiveMQ)
+uses a fast unique UUID generation that is cluster safe (similar to uuid
+generator in ActiveMQ). This is the default implementation in use by Camel.
+* `org.apache.camel.support.SimpleUuidGenerator` - This implementation","[{'comment': 'This seems to be the same first implementation, I guess', 'commenter': 'oscerd'}]"
4238,docs/components/modules/ROOT/pages/properties-component.adoc,"@@ -31,7 +31,7 @@ The component supports 10 options, which are listed below.
 | *camel.component.properties.ignore-missing-location* | Whether to silently ignore if a location cannot be located, such as a properties file not found. | false | Boolean
 | *camel.component.properties.initial-properties* | Sets initial properties which will be used before any locations are resolved. The option is a java.util.Properties type. |  | String
 | *camel.component.properties.location* | A list of locations to load properties. You can use comma to separate multiple locations. This option will override any default locations and only use the locations from this option. |  | String
-| *camel.component.properties.override-properties* | Sets a special list of override properties that take precedence and will use first, if a property exist. The option is a java.util.Properties type. |  | String
+| *camel.component.properties.override-properties* | Sets a special list of override properties that take precedence and will use first, if a property exists. The option is a java.util.Properties type. |  | String","[{'comment': 'This needs to be done in the javadoc of the componet', 'commenter': 'oscerd'}]"
4238,docs/components/modules/ROOT/pages/properties-component.adoc,"@@ -368,7 +368,7 @@ The default mode is that both of them are in override mode, and they are check i
 The check stops at first found property value for the key.
 
 You can control these modes using the `systemPropertiesMode` and `environmentVariableMode`
-options on the properties component.
+options on the property's component.","[{'comment': 'IMO the original wording is correct given that the name of the component is `properties`.', 'commenter': 'jamesnetherton'}, {'comment': 'sure thanks.', 'commenter': 'NiteshKoushik'}]"
4240,components/camel-optaplanner/src/main/java/org/apache/camel/component/optaplanner/OptaPlannerProducer.java,"@@ -59,12 +63,38 @@ protected void doStop() throws Exception {
         super.doStop();
     }
 
-    @SuppressWarnings(""unchecked"")
     @Override
-    public synchronized void process(Exchange exchange) throws Exception {
-        final Object body = exchange.getIn().getMandatoryBody();
-        final String solverId = getSolverId(exchange);
+    public boolean process(Exchange exchange, AsyncCallback callback) {","[{'comment': 'The callback must ALWAYS be called, so here is a few problems.\r\n\r\nThere is no return false for the async processing. And in case of an exception in try .. catch, you need to call callback.done(true) also (for example if mandatory body throws exception), which can be done in a finally block, or just above return true etc.', 'commenter': 'davsclaus'}]"
4240,components/camel-optaplanner/src/main/java/org/apache/camel/component/optaplanner/OptaPlannerProducer.java,"@@ -113,6 +143,54 @@ public void run() {
         }
     }
 
+    /**
+     * Using SolverManager
+     *
+     * @param  exchange
+     * @param  body
+     * @throws Exception
+     */
+    private void processWithSolverManager(Exchange exchange, Object body, AsyncCallback callback)
+            throws Exception {
+        final SolverManager solverManager = getSolverManager(exchange);
+
+        if (body.getClass().isAnnotationPresent(PlanningSolution.class)) {
+            LOGGER.debug(""Asynchronously solving problem: [{}] with id [{}]"", body);
+            Long problemId = endpoint.getConfiguration().getProblemId();
+            if (isAsync(exchange)) {
+                executor.submit(() -> {
+                    try {
+                        // create a consumer for best solution
+                        OptaplannerSolution consumer = endpoint.getOrCreateSolution(problemId);
+                        consumer.bestSolution(body);
+                        // start solving :: Solver Job is a thread
+                        SolverJob solverJob = solverManager.solveAndListen(problemId, t -> body, consumer::bestSolution);
+                        // wait for result
+                        populateResultWithSolverManager(exchange, solverJob);
+                    } catch (Throwable e) {
+                        LOGGER.error(""Asynchronously solving failed with SolverManager, for problemId ({})"", problemId, e);","[{'comment': 'You may want to set that exception on exchange, so Camel can react upon that.', 'commenter': 'davsclaus'}]"
4240,components/camel-optaplanner/src/main/java/org/apache/camel/component/optaplanner/OptaPlannerProducer.java,"@@ -113,6 +143,54 @@ public void run() {
         }
     }
 
+    /**
+     * Using SolverManager
+     *
+     * @param  exchange
+     * @param  body
+     * @throws Exception
+     */
+    private void processWithSolverManager(Exchange exchange, Object body, AsyncCallback callback)
+            throws Exception {
+        final SolverManager solverManager = getSolverManager(exchange);
+
+        if (body.getClass().isAnnotationPresent(PlanningSolution.class)) {
+            LOGGER.debug(""Asynchronously solving problem: [{}] with id [{}]"", body);
+            Long problemId = endpoint.getConfiguration().getProblemId();
+            if (isAsync(exchange)) {
+                executor.submit(() -> {","[{'comment': 'Here you need to return false after submit, as its another thread that continues this callback, so return false, and then return false from the process method that called this, then Camel knows its async now.\r\n\r\n', 'commenter': 'davsclaus'}]"
4240,components/camel-optaplanner/src/main/java/org/apache/camel/component/optaplanner/OptaPlannerProducer.java,"@@ -113,6 +143,54 @@ public void run() {
         }
     }
 
+    /**
+     * Using SolverManager
+     *
+     * @param  exchange
+     * @param  body
+     * @throws Exception
+     */
+    private void processWithSolverManager(Exchange exchange, Object body, AsyncCallback callback)
+            throws Exception {
+        final SolverManager solverManager = getSolverManager(exchange);
+
+        if (body.getClass().isAnnotationPresent(PlanningSolution.class)) {
+            LOGGER.debug(""Asynchronously solving problem: [{}] with id [{}]"", body);
+            Long problemId = endpoint.getConfiguration().getProblemId();
+            if (isAsync(exchange)) {
+                executor.submit(() -> {
+                    try {
+                        // create a consumer for best solution
+                        OptaplannerSolution consumer = endpoint.getOrCreateSolution(problemId);
+                        consumer.bestSolution(body);
+                        // start solving :: Solver Job is a thread
+                        SolverJob solverJob = solverManager.solveAndListen(problemId, t -> body, consumer::bestSolution);
+                        // wait for result
+                        populateResultWithSolverManager(exchange, solverJob);
+                    } catch (Throwable e) {
+                        LOGGER.error(""Asynchronously solving failed with SolverManager, for problemId ({})"", problemId, e);
+                    } finally {
+                        callback.done(false);","[{'comment': 'Yes this is correct, after we have the response we can tell Camel to continue by calling false on the callback', 'commenter': 'davsclaus'}]"
4240,components/camel-optaplanner/src/main/java/org/apache/camel/component/optaplanner/OptaPlannerProducer.java,"@@ -113,6 +143,54 @@ public void run() {
         }
     }
 
+    /**
+     * Using SolverManager
+     *
+     * @param  exchange
+     * @param  body
+     * @throws Exception
+     */
+    private void processWithSolverManager(Exchange exchange, Object body, AsyncCallback callback)
+            throws Exception {
+        final SolverManager solverManager = getSolverManager(exchange);
+
+        if (body.getClass().isAnnotationPresent(PlanningSolution.class)) {
+            LOGGER.debug(""Asynchronously solving problem: [{}] with id [{}]"", body);
+            Long problemId = endpoint.getConfiguration().getProblemId();
+            if (isAsync(exchange)) {
+                executor.submit(() -> {
+                    try {
+                        // create a consumer for best solution
+                        OptaplannerSolution consumer = endpoint.getOrCreateSolution(problemId);
+                        consumer.bestSolution(body);
+                        // start solving :: Solver Job is a thread
+                        SolverJob solverJob = solverManager.solveAndListen(problemId, t -> body, consumer::bestSolution);
+                        // wait for result
+                        populateResultWithSolverManager(exchange, solverJob);
+                    } catch (Throwable e) {
+                        LOGGER.error(""Asynchronously solving failed with SolverManager, for problemId ({})"", problemId, e);
+                    } finally {
+                        callback.done(false);
+                    }
+                });
+            } else {
+                // no need for a consumer for sync call
+                SolverJob solverJob = solverManager.solve(problemId, body);
+                // wait for result
+                populateResultWithSolverManager(exchange, solverJob);
+                callback.done(true);","[{'comment': 'return true to know that it was processed sync', 'commenter': 'davsclaus'}]"
4240,components/camel-optaplanner/src/main/java/org/apache/camel/component/optaplanner/OptaPlannerProducer.java,"@@ -113,6 +143,54 @@ public void run() {
         }
     }
 
+    /**
+     * Using SolverManager
+     *
+     * @param  exchange
+     * @param  body
+     * @throws Exception
+     */
+    private void processWithSolverManager(Exchange exchange, Object body, AsyncCallback callback)
+            throws Exception {
+        final SolverManager solverManager = getSolverManager(exchange);
+
+        if (body.getClass().isAnnotationPresent(PlanningSolution.class)) {
+            LOGGER.debug(""Asynchronously solving problem: [{}] with id [{}]"", body);
+            Long problemId = endpoint.getConfiguration().getProblemId();
+            if (isAsync(exchange)) {
+                executor.submit(() -> {
+                    try {
+                        // create a consumer for best solution
+                        OptaplannerSolution consumer = endpoint.getOrCreateSolution(problemId);
+                        consumer.bestSolution(body);
+                        // start solving :: Solver Job is a thread
+                        SolverJob solverJob = solverManager.solveAndListen(problemId, t -> body, consumer::bestSolution);
+                        // wait for result
+                        populateResultWithSolverManager(exchange, solverJob);
+                    } catch (Throwable e) {
+                        LOGGER.error(""Asynchronously solving failed with SolverManager, for problemId ({})"", problemId, e);
+                    } finally {
+                        callback.done(false);
+                    }
+                });
+            } else {
+                // no need for a consumer for sync call
+                SolverJob solverJob = solverManager.solve(problemId, body);
+                // wait for result
+                populateResultWithSolverManager(exchange, solverJob);
+                callback.done(true);
+            }
+        } else {
+            throw new Exception(""Unsuported type"");","[{'comment': 'Can we make a better exception message what this means?', 'commenter': 'davsclaus'}]"
4240,components/camel-optaplanner/src/main/java/org/apache/camel/component/optaplanner/OptaplannerSolution.java,"@@ -0,0 +1,46 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.optaplanner;
+
+import java.beans.PropertyChangeListener;","[{'comment': 'Can you please use something else as java.beans is some very old crap in Java that is bloated and may make quarkus pull in alot of extra classes.\r\n\r\nInstead add you own little event listener api', 'commenter': 'davsclaus'}]"
4241,archetypes/camel-archetype-api-component/src/main/resources/archetype-resources/__artifactId__-api/pom.xml,"@@ -78,7 +78,7 @@
             <groupId>org.apache.maven.plugins</groupId>
             <artifactId>maven-javadoc-plugin</artifactId>
             <configuration>
-              <additionalparam>-Xdoclint:none</additionalparam>
+              <doclint>none</doclint>","[{'comment': 'This seems to be wrong', 'commenter': 'oscerd'}]"
4241,components/camel-as2/camel-as2-api/pom.xml,"@@ -127,7 +127,7 @@
                         <groupId>org.apache.maven.plugins</groupId>
                         <artifactId>maven-javadoc-plugin</artifactId>
                         <configuration>
-                            <additionalparam>-Xdoclint:none</additionalparam>
+                            <doclint>none</doclint>","[{'comment': 'Seems to be not related to this PR, please rebuild the whole project', 'commenter': 'oscerd'}, {'comment': 'Agreed. Thanks. \r\nI will remove these changes.', 'commenter': 'rgannu'}]"
4241,components/camel-box/camel-box-api/pom.xml,"@@ -87,7 +87,7 @@
                         <groupId>org.apache.maven.plugins</groupId>
                         <artifactId>maven-javadoc-plugin</artifactId>
                         <configuration>
-                            <additionalparam>-Xdoclint:none</additionalparam>
+                            <doclint>none</doclint>","[{'comment': 'Ditto', 'commenter': 'oscerd'}, {'comment': 'Agreed. Thanks. \r\nI will remove these changes.', 'commenter': 'rgannu'}]"
4241,components/camel-fhir/camel-fhir-api/pom.xml,"@@ -92,7 +92,7 @@
                         <groupId>org.apache.maven.plugins</groupId>
                         <artifactId>maven-javadoc-plugin</artifactId>
                         <configuration>
-                            <additionalparam>-Xdoclint:none</additionalparam>
+                            <doclint>none</doclint>","[{'comment': 'Ditto', 'commenter': 'oscerd'}]"
4241,components/camel-olingo2/camel-olingo2-api/pom.xml,"@@ -122,7 +122,7 @@
                         <groupId>org.apache.maven.plugins</groupId>
                         <artifactId>maven-javadoc-plugin</artifactId>
                         <configuration>
-                            <additionalparam>-Xdoclint:none</additionalparam>
+                            <doclint>none</doclint>","[{'comment': 'This seems wrong, please rebuild the whole project', 'commenter': 'oscerd'}, {'comment': 'Agreed. Thanks. \r\nI will remove these changes.', 'commenter': 'rgannu'}]"
4241,components/camel-olingo4/camel-olingo4-api/pom.xml,"@@ -136,7 +136,7 @@
                         <groupId>org.apache.maven.plugins</groupId>
                         <artifactId>maven-javadoc-plugin</artifactId>
                         <configuration>
-                            <additionalparam>-Xdoclint:none</additionalparam>
+                            <doclint>none</doclint>","[{'comment': 'This seems wrong, please rebuild the whole project', 'commenter': 'oscerd'}, {'comment': 'Agreed. Thanks. \r\nI will remove these changes.', 'commenter': 'rgannu'}]"
4241,components/camel-rabbitmq/src/main/java/org/apache/camel/component/rabbitmq/RabbitMQConstants.java,"@@ -16,42 +16,76 @@
  */
 package org.apache.camel.component.rabbitmq;
 
-public final class RabbitMQConstants {
+import java.util.Set;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+public enum RabbitMQConstants {
 
     // TODO need to change the constant which is start with camel
-    public static final String ROUTING_KEY = ""rabbitmq.ROUTING_KEY"";
-    public static final String EXCHANGE_OVERRIDE_NAME = ""rabbitmq.EXCHANGE_OVERRIDE_NAME"";
-    public static final String EXCHANGE_NAME = ""rabbitmq.EXCHANGE_NAME"";
-    public static final String CONTENT_TYPE = ""rabbitmq.CONTENT_TYPE"";
-    public static final String PRIORITY = ""rabbitmq.PRIORITY"";
-    public static final String DELIVERY_TAG = ""rabbitmq.DELIVERY_TAG"";
-    public static final String REDELIVERY_TAG = ""rabbitmq.REDELIVERY_TAG"";
-    public static final String CORRELATIONID = ""rabbitmq.CORRELATIONID"";
-    public static final String MESSAGE_ID = ""rabbitmq.MESSAGE_ID"";
-    public static final String DELIVERY_MODE = ""rabbitmq.DELIVERY_MODE"";
-    public static final String USERID = ""rabbitmq.USERID"";
-    public static final String CLUSTERID = ""rabbitmq.CLUSTERID"";
-    public static final String REQUEST_TIMEOUT = ""rabbitmq.REQUEST_TIMEOUT"";
-    public static final String REPLY_TO = ""rabbitmq.REPLY_TO"";
-    public static final String CONTENT_ENCODING = ""rabbitmq.CONTENT_ENCODING"";
-    public static final String TYPE = ""rabbitmq.TYPE"";
-    public static final String EXPIRATION = ""rabbitmq.EXPIRATION"";
-    public static final String TIMESTAMP = ""rabbitmq.TIMESTAMP"";
-    public static final String APP_ID = ""rabbitmq.APP_ID"";
-    public static final String REQUEUE = ""rabbitmq.REQUEUE"";
-    public static final String MANDATORY = ""rabbitmq.MANDATORY"";
-    public static final String IMMEDIATE = ""rabbitmq.IMMEDIATE"";
-    public static final String RABBITMQ_DEAD_LETTER_EXCHANGE = ""x-dead-letter-exchange"";
-    public static final String RABBITMQ_DEAD_LETTER_ROUTING_KEY = ""x-dead-letter-routing-key"";
-    public static final String RABBITMQ_DIRECT_REPLY_EXCHANGE = """";
-    public static final String RABBITMQ_DIRECT_REPLY_ROUTING_KEY = ""amq.rabbitmq.reply-to"";
-    public static final String RABBITMQ_QUEUE_LENGTH_LIMIT_KEY = ""x-max-length"";
-    public static final String RABBITMQ_QUEUE_MAX_PRIORITY_KEY = ""x-max-priority"";
-    public static final String RABBITMQ_QUEUE_MESSAGE_TTL_KEY = ""x-message-ttl"";
-    public static final String RABBITMQ_QUEUE_TTL_KEY = ""x-expires"";
-    public static final String RABBITMQ_QUEUE_SINGLE_ACTIVE_CONSUMER_KEY = ""x-single-active-consumer"";
-
-    private RabbitMQConstants() {
-        // Constants class
+    ROUTING_KEY(""rabbitmq-ROUTING_KEY"", ""The routing key that will be used when sending the message""),","[{'comment': ""This will breaks existing users and I don't see a good reason for this"", 'commenter': 'oscerd'}, {'comment': ""Also you're changing the headers name. "", 'commenter': 'oscerd'}, {'comment': 'Header names are not changed.. I checked myself... \r\nFor my PR, I added support to add via the sink connector configuration way to add any Basic AMQP properties as \r\n\r\n```\r\n""camel.sink.endpoint.additionalProperties"": ""#bean:addProperties"",\r\n\r\n""camel.beans.addProperties"": ""#class:org.apache.camel.support.beans.SimpleDataHolderBean"",\r\n""camel.beans.addProperties.mapData[rabbitmq-CONTENT_TYPE]"": ""application/octet-stream"",\r\n""camel.beans.addProperties.mapData[""camel.sink.endpoint.additionalProperties"": ""#bean:addProperties"",\r\n\r\n""camel.beans.addProperties"": ""#class:org.apache.camel.support.beans.SimpleDataHolderBean"",\r\n""camel.beans.addProperties.mapData[rabbitmq-CONTENT_TYPE]"": ""application/octet-stream"",\r\n""camel.beans.addProperties.mapData[rabbitmq-CONTENT_ENCODING]"": ""binary"",\r\nrabbitmq-CONTENT_ENCODING]"": ""binary"",\r\n\r\n```\r\n\r\nWhen the property value is given as `mapData[rabbitmq.CONTENT_TYPE]`, due to the fix done as part of CAMEL-15394, \r\nhttps://github.com/apache/camel/blob/master/core/camel-support/src/main/java/org/apache/camel/support/PropertyBindingSupport.java#L408\r\nthe property is split into parts and then we are trying to search for property value for `CONTENT_TYPE]` which will not be there. \r\n\r\nI do not want to change this part and so I can in RabbitMQConstants.java\r\n - Remove the prefix `rabbitmq.` or\r\n - Change the prefix to `rabbitmq-` (which is what I have done)\r\nBoth of these solution works, without changing the changes done for CAMEL-15394.\r\n\r\nAlso the properties get set properly in the AMQP message as this is based on the com.rabbitmq.client.AMQP.BasicProperties in which we need to explicitly set the basic AMQP properties. ', 'commenter': 'rgannu'}, {'comment': ""Rabbitmq. Was the original prefix, now it's rabbitmq-.. anyone using the header explicitly will have his route broken."", 'commenter': 'oscerd'}, {'comment': ""You don't have to think only about camel kafka connector, this is something related to pure camel too"", 'commenter': 'oscerd'}, {'comment': ""so it's -1 for me."", 'commenter': 'oscerd'}, {'comment': ""> Rabbitmq. Was the original prefix, now it's rabbitmq-.. anyone using the header explicitly will have his route broken.\r\n\r\nI understand completely. \r\nEarlier my PR to support adding property with `mapData[rabbitmq.CONTENT_TYPE]` was working fine in camel-3.4.0.\r\n\r\nI had to submit the PR against the master and this is an enhancement work. \r\nWhen I did the changes against the master, I got `null` value for all properties (with prefix `rabbitmq.`), due to the changes done in CAMEL-15394. As the values is `null` these properties were removed from getting set as part of the AMQP header.\r\n\r\nNow, please let me know how I can fix this. \r\nWithout the changes to the **prefix so that it doesn't contain the dot (.) character, I couldn't submit this PR**.  \r\nI hope you understand my problem.\r\n"", 'commenter': 'rgannu'}, {'comment': ""now I'm getting the point."", 'commenter': 'oscerd'}]"
4343,components/camel-google-pubsub/pom.xml,"@@ -47,83 +47,7 @@
             <groupId>com.google.cloud</groupId>
             <artifactId>google-cloud-pubsub</artifactId>
             <version>${google-cloud-pubsub-version}</version>
-            <exclusions>","[{'comment': 'Are you sure about removing the exclusions?', 'commenter': 'oscerd'}, {'comment': ""PubSub 1.108.1 has a dependency on GRPC 1.30.2 and it doesn't work with the GRPC 1.28.0 as defined in the parent.\r\nShould I increase the version in the parent, add a pubsub specific version in the parent of leave it like so?"", 'commenter': 'alvinkwekel'}, {'comment': 'Do you mean 1.27.1? I think it makes sense to add a property placeholder only for pubsub and use it in this component only. We can do the same for the karaf feature. Camel-grpc is based on 1.28.0 so we cannot generally downgrade', 'commenter': 'oscerd'}, {'comment': 'Sorry, GRPC 1.30.2. So that would mean a general _upgrade_. Would that be possible?', 'commenter': 'alvinkwekel'}, {'comment': ""I don't think camel-grpc is ready for this. So I believe it would be better to use a specific version only in this component "", 'commenter': 'oscerd'}, {'comment': ""I've created an explicit dependency on GRPC 1.30.2 now.\r\n\r\n"", 'commenter': 'alvinkwekel'}]"
4343,parent/pom.xml,"@@ -205,7 +205,7 @@
         <geronimo-ws-metadata-spec-version>1.1.3</geronimo-ws-metadata-spec-version>
         <gmetric4j-version>1.0.10</gmetric4j-version>
         <google-guava-version>19.0</google-guava-version>
-        <google-pubsub-guava-version>28.2-jre</google-pubsub-guava-version>
+        <google-pubsub-guava-version>29.0-jre</google-pubsub-guava-version>","[{'comment': 'I think this require a check on the karaf feature if needed', 'commenter': 'oscerd'}, {'comment': ""You mean in the camel-dependencies project right? I've updated it there now."", 'commenter': 'alvinkwekel'}, {'comment': 'We need to check the camel-googke-pubsub karaf feature in the camel-karaf repo, but we can do that later', 'commenter': 'oscerd'}]"
4343,parent/pom.xml,"@@ -215,7 +215,7 @@
         <google-api-services-mail-version>v1-rev81-1.22.0</google-api-services-mail-version>
         <google-api-services-bigquery-version>v2-rev352-1.22.0</google-api-services-bigquery-version>
         <google-api-services-pubsub-version>v1-rev12-1.22.0</google-api-services-pubsub-version>
-        <google-cloud-pubsub-version>1.102.0</google-cloud-pubsub-version>
+        <google-cloud-pubsub-version>1.108.1</google-cloud-pubsub-version>","[{'comment': ""I think that's the reason for removing the exclusions, but we need to double check"", 'commenter': 'oscerd'}, {'comment': 'Yes that is correct, see my comment above.', 'commenter': 'alvinkwekel'}]"
4359,core/camel-base/src/main/java/org/apache/camel/processor/aggregate/StringAggregationStrategy.java,"@@ -63,12 +63,12 @@ public StringAggregationStrategy pick(Expression expression) {
      */
     @Override
     public Exchange aggregate(Exchange oldExchange, Exchange newExchange) {
-        StringBuffer result; // Aggregate in StringBuffer instead of StringBuilder, to make it thread safe","[{'comment': 'StringBuffer is here intentionally because it is mutable and ensures locks. As aggregate method can be called in many threads in parallel, you need to ensure locking in different way (synchronized block, ReentrantLock, ...) before changing this to StringBuilder, otherwise the output will be corrupted.', 'commenter': 'bedlaj'}, {'comment': ""Ok, so maybe it's just simpler to keep StringBuffer... I removed the changes on that file. Thanks"", 'commenter': 'mcserra'}]"
4367,components/camel-saxon/pom.xml,"@@ -33,7 +33,7 @@
 
     <properties>
         <camel.osgi.import.additional>
-            net.sf.saxon.*;version=""[9.9.0,10)""
+            net.sf.saxon.*;version=""[9.9.0,11)""","[{'comment': 'Those API changes later would mean that we require saxon 10, 11', 'commenter': 'davsclaus'}, {'comment': '@davsclaus  can i keep only version 10\r\n net.sf.saxon.*;version=""[10.0,10.3)', 'commenter': 'ramu11'}, {'comment': '[10.0,10.3)  means include 10.0,10.1,10.2 and exclude 10.3', 'commenter': 'ramu11'}, {'comment': ""It doesn't makes sense to restrict to 10.3 the range. Use 11 as upper limit"", 'commenter': 'oscerd'}, {'comment': 'Thanks oscerd. then i think there is no need to change', 'commenter': 'ramu11'}, {'comment': 'I have already provided upper limit 11\r\nnet.sf.saxon.*;version=""[9.9.0,11)""', 'commenter': 'ramu11'}, {'comment': 'No it should be [10,11)', 'commenter': 'davsclaus'}, {'comment': '+1, it needs to be strict [10,11)', 'commenter': 'oscerd'}]"
4399,components/camel-pgevent/pom.xml,"@@ -64,6 +65,94 @@
             <artifactId>log4j-slf4j-impl</artifactId>
             <scope>test</scope>
         </dependency>
+
+        <dependency>
+            <groupId>org.apache.camel</groupId>
+            <artifactId>camel-testcontainers-junit5</artifactId>
+            <scope>test</scope>
+        </dependency>
     </dependencies>
 
+    <profiles>
+        <profile>
+            <id>testcontainers-skip-tests</id>","[{'comment': ""Maybe it's better to have the component name too here"", 'commenter': 'oscerd'}, {'comment': 'OK', 'commenter': 'zbendhiba'}, {'comment': 'done !!', 'commenter': 'zbendhiba'}]"
4399,components/camel-pgevent/pom.xml,"@@ -64,6 +65,94 @@
             <artifactId>log4j-slf4j-impl</artifactId>
             <scope>test</scope>
         </dependency>
+
+        <dependency>
+            <groupId>org.apache.camel</groupId>
+            <artifactId>camel-testcontainers-junit5</artifactId>
+            <scope>test</scope>
+        </dependency>
     </dependencies>
 
+    <profiles>
+        <profile>
+            <id>testcontainers-skip-tests</id>
+            <activation>
+                <activeByDefault>true</activeByDefault>
+            </activation>
+            <build>
+                <plugins>
+                    <plugin>
+                        <artifactId>maven-surefire-plugin</artifactId>
+                        <configuration>
+                            <skipTests>true</skipTests>
+                        </configuration>
+                    </plugin>
+                </plugins>
+            </build>
+        </profile>
+        <!-- activate integration test if the docker socket file is accessible -->
+        <profile>
+            <id>testcontainers-integration-tests-docker-file</id>","[{'comment': 'ditto', 'commenter': 'oscerd'}, {'comment': 'done', 'commenter': 'zbendhiba'}]"
4399,components/camel-pgevent/pom.xml,"@@ -64,6 +65,94 @@
             <artifactId>log4j-slf4j-impl</artifactId>
             <scope>test</scope>
         </dependency>
+
+        <dependency>
+            <groupId>org.apache.camel</groupId>
+            <artifactId>camel-testcontainers-junit5</artifactId>
+            <scope>test</scope>
+        </dependency>
     </dependencies>
 
+    <profiles>
+        <profile>
+            <id>testcontainers-skip-tests</id>
+            <activation>
+                <activeByDefault>true</activeByDefault>
+            </activation>
+            <build>
+                <plugins>
+                    <plugin>
+                        <artifactId>maven-surefire-plugin</artifactId>
+                        <configuration>
+                            <skipTests>true</skipTests>
+                        </configuration>
+                    </plugin>
+                </plugins>
+            </build>
+        </profile>
+        <!-- activate integration test if the docker socket file is accessible -->
+        <profile>
+            <id>testcontainers-integration-tests-docker-file</id>
+            <activation>
+                <file>
+                    <exists>/var/run/docker.sock</exists>
+                </file>
+            </activation>
+            <build>
+                <plugins>
+                    <plugin>
+                        <groupId>org.apache.maven.plugins</groupId>
+                        <artifactId>maven-failsafe-plugin</artifactId>
+                        <configuration>
+                            <skipTests>${skipTests}</skipTests>
+                            <systemPropertyVariables>
+                                <visibleassertions.silence>true</visibleassertions.silence>
+                            </systemPropertyVariables>
+                        </configuration>
+                        <executions>
+                            <execution>
+                                <goals>
+                                    <goal>integration-test</goal>
+                                    <goal>verify</goal>
+                                </goals>
+                            </execution>
+                        </executions>
+                    </plugin>
+                </plugins>
+            </build>
+        </profile>
+
+        <!-- activate integration test if the DOCKER_HOST env var is set -->
+        <profile>
+            <id>testcontainers-integration-tests-docker-env</id>","[{'comment': 'ditto', 'commenter': 'oscerd'}]"
4414,core/camel-support/src/main/java/org/apache/camel/support/DefaultComponent.java,"@@ -551,6 +551,9 @@ protected boolean useIntrospectionOnEndpoint() {
      * @throws IllegalArgumentException if referenced object was not found in registry.
      */
     public <T> T resolveAndRemoveReferenceParameter(Map<String, Object> parameters, String key, Class<T> type, T defaultValue) {
+        if (parameters.containsKey(key) && type.isInstance(parameters.get(key).getClass())) {","[{'comment': 'Parameter value can be null. Actually many tests are failing with `NullPointerException`.', 'commenter': 'bedlaj'}, {'comment': 'Should be OK now. Thanks.', 'commenter': 'Drezir'}, {'comment': 'No. `parameters` will be never null. But value in map (`parameters.get(key)`) can be null. The NPE is still there. You can rollback last commit and instead replace `parameters.containsKey(key)` with `parameters.get(key) != null`', 'commenter': 'bedlaj'}, {'comment': 'Done, thanks', 'commenter': 'Drezir'}]"
4414,core/camel-support/src/main/java/org/apache/camel/support/DefaultComponent.java,"@@ -551,6 +551,9 @@ protected boolean useIntrospectionOnEndpoint() {
      * @throws IllegalArgumentException if referenced object was not found in registry.
      */
     public <T> T resolveAndRemoveReferenceParameter(Map<String, Object> parameters, String key, Class<T> type, T defaultValue) {
+        if (parameters.get(key) != null && type.isInstance(parameters.get(key))) {","[{'comment': 'Now, when is `getClass` removed, the null check is redundant, as `type.isInstance(null)` returns false. The condition can be simplified to `if (type.isInstance(parameters.get(key)))`. Previous comments about String beans and unit test are still unresolved.', 'commenter': 'bedlaj'}]"
4480,components/camel-azure-storage-blob/src/main/java/org/apache/camel/component/azure/storage/blob/BlobConsumer.java,"@@ -94,6 +94,7 @@ private Exchange createExchangeFromBlob(final String blobName, final BlobContain
 
         getEndpoint().setResponseOnExchange(response, exchange);
 
+        exchange.getIn().setHeader(BlobConstants.BLOB_NAME, blobName);","[{'comment': ""This doesn't seem to be related to it test"", 'commenter': 'oscerd'}, {'comment': ""I guess this info can simplify the tests as I recall the name wasn't populated in the headers but now with regex and batch blob, I guess is needed to have the name in the headers, hence I don't see any problems here "", 'commenter': 'omarsmak'}]"
4495,docs/user-manual/modules/ROOT/pages/type-converter.adoc,"@@ -134,7 +134,7 @@ You can declare multiple `<bean>`s if you have more classes.
 Camel will automatic discover and load type converters from all the JARs in the classpath on startup.
 
 Camel will search the classpath for a file called
-`META-INF/services/org/apache/camel/TypeConverterLoader`, which lists
+`META-INF/services/org/apache/camel/TypeConverter`, which lists","[{'comment': 'This is wrong, it should be as it was before', 'commenter': 'davsclaus'}, {'comment': 'With all due respect, please see verifiable example with unit test.\r\nhttps://github.com/fg78nc/camel-type-converter', 'commenter': 'fg78nc'}, {'comment': 'You are using the old way (camel 2.x style). In Camel 3.x there is a fast TypeConverterLoader that is recommended to use.', 'commenter': 'davsclaus'}, {'comment': 'Where can I find relevant documentation for Camel 3.x?', 'commenter': 'fg78nc'}, {'comment': 'You are looking at it - that doc file has specific sections about 2.x', 'commenter': 'davsclaus'}, {'comment': '`@Converter(loader = true)` -  I don\'t see this ""loader"" element in `@Converter `https://www.javadoc.io/doc/org.apache.camel/camel-api/latest/org/apache/camel/Converter.html', 'commenter': 'fg78nc'}, {'comment': 'Ah yeah the option is renamed \r\n\r\n@Converter(generateLoader = true)\r\n\r\nCan you fix that in the docs', 'commenter': 'davsclaus'}, {'comment': 'I fixed the docs. Now with those changes I have working example for Camel 3.x. \r\nI still think documentation is scarce. Would you like to add more details to documentation and probably add working example to Camel examples?', 'commenter': 'fg78nc'}, {'comment': 'Yeah an example is welcome with a custom type converter. The old way with loader disabled is still possible, but its slower and uses reflection at invoking the converter at runtime. The loader generates source code so its very fast.', 'commenter': 'davsclaus'}, {'comment': 'You can tidy up this PR and we can merge it. Then you can do new PRs for more docs, and another with the example', 'commenter': 'davsclaus'}, {'comment': 'Done, please review.', 'commenter': 'fg78nc'}]"
4508,components/camel-grpc/src/main/java/org/apache/camel/component/grpc/server/GrpcMethodHandler.java,"@@ -39,19 +39,30 @@ public GrpcMethodHandler(GrpcConsumer consumer) {
         this.consumer = consumer;
     }
 
+    /**
+     * This method deals with the unary and server streaming gRPC calls
+     *
+     * @param  body             The request object sent by the gRPC client to the server
+     * @param  responseObserver The response stream observer
+     * @param  methodName       The name of the method invoked using the stub.
+     * @throws Exception        java.lang.Exception
+     */
     public void handle(Object body, StreamObserver<Object> responseObserver, String methodName) throws Exception {
         Map<String, Object> grcpHeaders = populateGrpcHeaders(methodName);
         GrpcEndpoint endpoint = (GrpcEndpoint) consumer.getEndpoint();
+
         Exchange exchange = endpoint.createExchange();
         exchange.getIn().setBody(body);
         exchange.getIn().setHeaders(grcpHeaders);
 
-        if (endpoint.isSynchronous()) {
-            consumer.getProcessor().process(exchange);
-        } else {
-            consumer.getAsyncProcessor().process(exchange);
+        if (endpoint.getConfiguration().isRouteControlledStreamObserver()) {
+            exchange.setProperty(""responseObserver"", responseObserver);","[{'comment': '@rajasekharb would be nice to store this value in constants and give a name like `grpcResponseObserver` as generic name `responseObserver` can be intersected with other components property.', 'commenter': 'dmvolod'}, {'comment': 'I agree. Have set a constant in GrpcConstants.java.\r\n    String GRPC_RESPONSE_OBSERVER = ""grpcResponseObserver"";', 'commenter': 'rajasekharb'}]"
4508,components/camel-grpc/src/main/java/org/apache/camel/component/grpc/server/GrpcMethodHandler.java,"@@ -62,16 +73,29 @@ public void handle(Object body, StreamObserver<Object> responseObserver, String
             Object responseBody = exchange.getIn().getBody();
             if (responseBody instanceof List) {
                 List<Object> responseList = (List<Object>) responseBody;
-                responseList.forEach(responseItem -> {
-                    responseObserver.onNext(responseItem);
-                });
+                responseList.forEach(responseObserver::onNext);
             } else {
                 responseObserver.onNext(responseBody);
             }
             responseObserver.onCompleted();
         }
     }
 
+    private void invokeCamelRoute(GrpcEndpoint endpoint, Exchange exchange) throws Exception {","[{'comment': ""Camel in this name is redundant. Let's call this function as\r\n```suggestion\r\n    private void invokeRoute(GrpcEndpoint endpoint, Exchange exchange) throws Exception {\r\n```"", 'commenter': 'dmvolod'}, {'comment': 'Done.', 'commenter': 'rajasekharb'}]"
4508,components/camel-grpc/src/main/java/org/apache/camel/component/grpc/GrpcConfiguration.java,"@@ -353,15 +356,33 @@ public void setFlowControlWindow(int flowControlWindow) {
         this.flowControlWindow = flowControlWindow;
     }
 
+    public int getMaxMessageSize() {
+        return maxMessageSize;
+    }
+
     /**
      * The maximum message size allowed to be received/sent (MiB)
      */
     public void setMaxMessageSize(int maxMessageSize) {
         this.maxMessageSize = maxMessageSize;
     }
 
-    public int getMaxMessageSize() {
-        return maxMessageSize;
+    /**
+     * Lets the camel route to take control over stream observer. If this value is set to true, then the stream","[{'comment': ""Camel must be in CamelCase as it's project name but also a bit redundant :smile:\r\nAlso name of the property must be documented or separate micro example can be provided.\r\nPlease don't forget about constant described below. Info about default false value as also redundant as it always false by default."", 'commenter': 'dmvolod'}, {'comment': 'I agree. Made the relevant changes as per the conversation on zulip chat', 'commenter': 'rajasekharb'}]"
4508,components/camel-grpc/src/test/java/org/apache/camel/component/grpc/RouteControlledStreamObserverTest.java,"@@ -0,0 +1,242 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.grpc;
+
+import java.util.Iterator;
+import java.util.List;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+
+import io.grpc.ManagedChannel;
+import io.grpc.ManagedChannelBuilder;
+import io.grpc.stub.StreamObserver;
+import org.apache.camel.Exchange;
+import org.apache.camel.Message;
+import org.apache.camel.builder.RouteBuilder;
+import org.apache.camel.test.AvailablePortFinder;
+import org.apache.camel.test.junit5.CamelTestSupport;
+import org.junit.jupiter.api.AfterEach;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertNotNull;
+
+public class RouteControlledStreamObserverTest extends CamelTestSupport {
+
+    private static final Logger LOG = LoggerFactory.getLogger(GrpcConsumerAggregationTest.class);
+
+    private static final int GRPC_SYNC_REQUEST_TEST_PORT = AvailablePortFinder.getNextAvailable();
+    private static final int GRPC_ASYNC_REQUEST_TEST_PORT = AvailablePortFinder.getNextAvailable();
+    private static final int GRPC_TEST_PING_ID = 1;
+    private static final String GRPC_TEST_PING_VALUE = ""PING"";
+    private static final String GRPC_TEST_PONG_VALUE = ""PONG"";
+
+    private ManagedChannel syncRequestChannel;
+    private ManagedChannel asyncRequestChannel;
+    private PingPongGrpc.PingPongBlockingStub blockingStub;
+    private PingPongGrpc.PingPongStub nonBlockingStub;
+    private PingPongGrpc.PingPongStub asyncNonBlockingStub;
+
+    @BeforeEach
+    public void startGrpcChannels() {
+        syncRequestChannel = ManagedChannelBuilder.forAddress(""localhost"", GRPC_SYNC_REQUEST_TEST_PORT).usePlaintext().build();
+        asyncRequestChannel
+                = ManagedChannelBuilder.forAddress(""localhost"", GRPC_ASYNC_REQUEST_TEST_PORT).usePlaintext().build();
+        blockingStub = PingPongGrpc.newBlockingStub(syncRequestChannel);
+        nonBlockingStub = PingPongGrpc.newStub(syncRequestChannel);
+        asyncNonBlockingStub = PingPongGrpc.newStub(asyncRequestChannel);
+    }
+
+    @AfterEach
+    public void stopGrpcChannels() {
+        syncRequestChannel.shutdown().shutdownNow();
+        asyncRequestChannel.shutdown().shutdownNow();
+    }
+
+    @Test
+    public void testSyncSyncMethodInSync() {
+        LOG.info(""gRPC pingSyncSync method blocking test start"");
+        PingRequest pingRequest
+                = PingRequest.newBuilder().setPingName(GRPC_TEST_PING_VALUE).setPingId(GRPC_TEST_PING_ID).build();
+        PongResponse pongResponse = blockingStub.pingSyncSync(pingRequest);
+
+        assertNotNull(pongResponse);
+        assertEquals(GRPC_TEST_PING_ID, pongResponse.getPongId());
+        assertEquals(GRPC_TEST_PING_VALUE + GRPC_TEST_PONG_VALUE, pongResponse.getPongName());
+    }
+
+    @Test
+    public void testSyncAsyncMethodInSync() {
+        LOG.info(""gRPC pingSyncAsync method blocking test start"");
+        PingRequest pingRequest
+                = PingRequest.newBuilder().setPingName(GRPC_TEST_PING_VALUE).setPingId(GRPC_TEST_PING_ID).build();
+        Iterator<PongResponse> pongResponseIter = blockingStub.pingSyncAsync(pingRequest);
+        while (pongResponseIter.hasNext()) {
+            PongResponse pongResponse = pongResponseIter.next();
+            assertNotNull(pongResponse);
+            assertEquals(GRPC_TEST_PING_ID, pongResponse.getPongId());
+            assertEquals(GRPC_TEST_PING_VALUE + GRPC_TEST_PONG_VALUE, pongResponse.getPongName());
+        }
+    }
+
+    @Test
+    public void testSyncSyncMethodInAsync() throws Exception {
+        LOG.info(""gRPC pingSyncSync method async test start"");
+        final CountDownLatch latch = new CountDownLatch(1);
+        PingRequest pingRequest
+                = PingRequest.newBuilder().setPingName(GRPC_TEST_PING_VALUE).setPingId(GRPC_TEST_PING_ID).build();
+        PongResponseStreamObserver responseObserver = new PongResponseStreamObserver(latch);
+
+        nonBlockingStub.pingSyncSync(pingRequest, responseObserver);
+        latch.await(5, TimeUnit.SECONDS);
+
+        PongResponse pongResponse = responseObserver.getPongResponse();
+
+        assertNotNull(pongResponse);
+        assertEquals(GRPC_TEST_PING_ID, pongResponse.getPongId());
+        assertEquals(GRPC_TEST_PING_VALUE + GRPC_TEST_PONG_VALUE, pongResponse.getPongName());
+    }
+
+    @Test
+    public void testSyncAsyncMethodInAsync() throws Exception {
+        LOG.info(""gRPC pingSyncAsync method async test start"");
+        final CountDownLatch latch = new CountDownLatch(1);
+        PingRequest pingRequest
+                = PingRequest.newBuilder().setPingName(GRPC_TEST_PING_VALUE).setPingId(GRPC_TEST_PING_ID).build();
+        PongResponseStreamObserver responseObserver = new PongResponseStreamObserver(latch);
+
+        nonBlockingStub.pingSyncAsync(pingRequest, responseObserver);
+        latch.await(5, TimeUnit.SECONDS);
+
+        PongResponse pongResponse = responseObserver.getPongResponse();
+
+        assertNotNull(pongResponse);
+        assertEquals(GRPC_TEST_PING_ID, pongResponse.getPongId());
+        assertEquals(GRPC_TEST_PING_VALUE + GRPC_TEST_PONG_VALUE, pongResponse.getPongName());
+    }
+
+    @Test
+    public void testAsyncSyncMethodInAsync() throws Exception {
+        LOG.info(""gRPC pingAsyncSync method async test start"");
+        final CountDownLatch latch = new CountDownLatch(1);
+        PingRequest pingRequest
+                = PingRequest.newBuilder().setPingName(GRPC_TEST_PING_VALUE).setPingId(GRPC_TEST_PING_ID).build();
+        PongResponseStreamObserver responseObserver = new PongResponseStreamObserver(latch);
+
+        StreamObserver<PingRequest> requestObserver = asyncNonBlockingStub.pingAsyncSync(responseObserver);
+        requestObserver.onNext(pingRequest);
+        requestObserver.onNext(pingRequest);
+        requestObserver.onCompleted();
+        latch.await(5, TimeUnit.SECONDS);
+
+        PongResponse pongResponse = responseObserver.getPongResponse();
+
+        assertNotNull(pongResponse);
+        assertEquals(GRPC_TEST_PING_ID, pongResponse.getPongId());
+        assertEquals(GRPC_TEST_PING_VALUE + GRPC_TEST_PONG_VALUE, pongResponse.getPongName());
+    }
+
+    @Test
+    public void testAsyncAsyncMethodInAsync() throws Exception {
+        LOG.info(""gRPC pingAsyncAsync method async test start"");
+        final CountDownLatch latch = new CountDownLatch(1);
+        PingRequest pingRequest
+                = PingRequest.newBuilder().setPingName(GRPC_TEST_PING_VALUE).setPingId(GRPC_TEST_PING_ID).build();
+        PongResponseStreamObserver responseObserver = new PongResponseStreamObserver(latch);
+
+        StreamObserver<PingRequest> requestObserver = asyncNonBlockingStub.pingAsyncAsync(responseObserver);
+        requestObserver.onNext(pingRequest);
+        requestObserver.onNext(pingRequest);
+        requestObserver.onCompleted();
+        latch.await(5, TimeUnit.SECONDS);
+
+        PongResponse pongResponse = responseObserver.getPongResponse();
+
+        assertNotNull(pongResponse);
+        assertEquals(GRPC_TEST_PING_ID, pongResponse.getPongId());
+        assertEquals(GRPC_TEST_PING_VALUE + GRPC_TEST_PONG_VALUE, pongResponse.getPongName());
+    }
+
+    @Override
+    protected RouteBuilder createRouteBuilder() {
+        return new RouteBuilder() {
+            private void process(Exchange exchange) {
+                Message message = exchange.getIn();
+                PingRequest pingRequest = message.getBody(PingRequest.class);
+                StreamObserver<Object> responseObserver = (StreamObserver<Object>) exchange.getProperty(""responseObserver"");
+                PongResponse pongResponse
+                        = PongResponse.newBuilder().setPongName(pingRequest.getPingName() + GRPC_TEST_PONG_VALUE)
+                                .setPongId(pingRequest.getPingId()).build();
+                message.setBody(pongResponse, PongResponse.class);
+                exchange.setMessage(message);
+                responseObserver.onNext(pongResponse);
+                responseObserver.onCompleted();
+            }
+
+            @Override
+            public void configure() {
+                from(""grpc://localhost:"" + GRPC_SYNC_REQUEST_TEST_PORT
+                     + ""/org.apache.camel.component.grpc.PingPong?synchronous=true&consumerStrategy=PROPAGATION&routeControlledStreamObserver=true"")
+                             .process(this::process);
+
+                from(""grpc://localhost:"" + GRPC_ASYNC_REQUEST_TEST_PORT
+                     + ""/org.apache.camel.component.grpc.PingPong?synchronous=true&consumerStrategy=AGGREGATION"")","[{'comment': 'Seems to routeControlledStreamObserver=true and consumerStrategy=AGGREGATION not compatible. We should notify that option will be ignored and not applied or just fail route start as it cause unpredictable result.', 'commenter': 'dmvolod'}, {'comment': 'Agree. Included a failure test case and added a check in the GrpcConsumer to prevent server start event in case of incorrect configuration.', 'commenter': 'rajasekharb'}]"
4514,components/camel-salesforce/camel-salesforce-component/src/main/java/org/apache/camel/component/salesforce/internal/processor/JsonRestProcessor.java,"@@ -98,6 +98,14 @@ protected void processRequest(Exchange exchange) throws SalesforceException {
                 exchange.setProperty(RESPONSE_CLASS, CreateSObjectResult.class);
                 break;
 
+            /**
+             * TODO AHMEDBS","[{'comment': 'Please remove todos', 'commenter': 'oscerd'}, {'comment': 'I will. Thanks.', 'commenter': 'jbonofre'}]"
4514,components/camel-salesforce/camel-salesforce-component/src/main/java/org/apache/camel/component/salesforce/internal/processor/XmlRestProcessor.java,"@@ -124,6 +124,13 @@ protected void processRequest(Exchange exchange) throws SalesforceException {
                 exchange.setProperty(RESPONSE_CLASS, CreateSObjectResult.class);
                 break;
 
+            /**
+             * TODO AHMEDBS","[{'comment': 'Ditto', 'commenter': 'oscerd'}, {'comment': ' I will fix. Thanks.', 'commenter': 'jbonofre'}]"
4514,components/camel-salesforce/camel-salesforce-component/src/main/java/org/apache/camel/component/salesforce/internal/client/DefaultCompositeApiClient.java,"@@ -93,6 +93,35 @@ public DefaultCompositeApiClient(final SalesforceEndpointConfig configuration, f
         xStreamCompositeTree.alias(""SObjectTreeResponse"", SObjectTreeResponse.class);
     }
 
+    public void submitCompositeRaw(
+            final InputStream raw, final Map<String, List<String>> headers,
+            final ResponseCallback<InputStream> callback,
+            final String sObjectName, final String extId, String compositeMethod)
+            throws SalesforceException {
+        checkCompositeFormat(format, SObjectComposite.REQUIRED_PAYLOAD_FORMAT);
+
+        final String url = String.format(""%s%s/%s/%s/%s"", versionUrl(), ""composite"", ""sobjects"", sObjectName, extId);
+
+        System.out.println(""URL: "" + url);","[{'comment': 'Remove system out, or change into a debug LOG', 'commenter': 'davsclaus'}, {'comment': '+1 (was debugging)', 'commenter': 'jbonofre'}]"
4514,components/camel-salesforce/camel-salesforce-component/src/main/java/org/apache/camel/component/salesforce/SalesforceEndpointConfig.java,"@@ -126,6 +127,8 @@
     @UriParam
     private String apexMethod;
     @UriParam
+    private String compositeMethod;","[{'comment': 'Can this be used both on consumer or producer? If not then add label to mark it as consumer or producer only.', 'commenter': 'davsclaus'}, {'comment': ""Like `apexMethod` it's consumer only for now. Let me improve this (we should update `apexMethod` as well but it's another PR)."", 'commenter': 'jbonofre'}]"
4535,components/camel-pulsar/src/main/java/org/apache/camel/component/pulsar/PulsarConfiguration.java,"@@ -63,6 +63,8 @@
     private long ackGroupTimeMillis = 100;
     @UriParam(label = ""consumer"", defaultValue = ""LATEST"")
     private SubscriptionInitialPosition subscriptionInitialPosition = LATEST;
+    @UriParam(label = ""consumer"", defaultValue = ""false"")
+    private boolean readCompacted = false;","[{'comment': 'The defaultValue at field level is not needed, it is false by default.', 'commenter': 'oscerd'}, {'comment': 'done. :)', 'commenter': 'ludovic-boutros'}]"
4541,components/camel-kubernetes/pom.xml,"@@ -47,6 +47,15 @@
             <groupId>org.apache.camel</groupId>
             <artifactId>camel-cluster</artifactId>
         </dependency>
+        <dependency>
+            <groupId>org.apache.camel</groupId>
+            <artifactId>camel-util-json</artifactId>
+        </dependency>
+        <dependency>
+            <groupId>org.json</groupId>
+            <artifactId>json</artifactId>
+            <version>20200518</version>","[{'comment': 'Please avoid using org.json:json, the license is not complaint with ASF, remove this.', 'commenter': 'oscerd'}, {'comment': ""I'll change not to use this package."", 'commenter': 'akihikokuroda'}]"
4541,components/camel-kubernetes/src/main/java/org/apache/camel/component/kubernetes/customresources/KubernetesCustomResourcesConsumer.java,"@@ -0,0 +1,193 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.kubernetes.customresources;
+
+import java.util.concurrent.ExecutorService;
+
+import io.fabric8.kubernetes.client.KubernetesClientException;
+import io.fabric8.kubernetes.client.Watch;
+import io.fabric8.kubernetes.client.Watcher;
+import io.fabric8.kubernetes.client.dsl.base.CustomResourceDefinitionContext;
+import io.fabric8.kubernetes.client.dsl.internal.RawCustomResourceOperationsImpl;
+/*
+import io.fabric8.kubernetes.api.model.apps.Deployment;
+import io.fabric8.kubernetes.api.model.apps.DeploymentList;
+import io.fabric8.kubernetes.api.model.apps.DoneableDeployment;
+import io.fabric8.kubernetes.client.KubernetesClientException;
+import io.fabric8.kubernetes.client.Watch;
+import io.fabric8.kubernetes.client.Watcher;
+import io.fabric8.kubernetes.client.dsl.NonNamespaceOperation;
+import io.fabric8.kubernetes.client.dsl.RollableScalableResource;
+*/
+import org.apache.camel.Exchange;
+import org.apache.camel.Processor;
+import org.apache.camel.component.kubernetes.AbstractKubernetesEndpoint;
+import org.apache.camel.component.kubernetes.KubernetesConfiguration;
+import org.apache.camel.component.kubernetes.KubernetesConstants;
+import org.apache.camel.support.DefaultConsumer;
+import org.apache.camel.util.ObjectHelper;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class KubernetesCustomResourcesConsumer extends DefaultConsumer {
+
+    private static final Logger LOG = LoggerFactory.getLogger(KubernetesCustomResourcesConsumer.class);
+
+    private final Processor processor;
+    private ExecutorService executor;
+    private CustomResourcesConsumerTask customResourcesWatcher;
+
+    public KubernetesCustomResourcesConsumer(AbstractKubernetesEndpoint endpoint, Processor processor) {
+        super(endpoint, processor);
+        this.processor = processor;
+    }
+
+    @Override
+    public AbstractKubernetesEndpoint getEndpoint() {
+        return (AbstractKubernetesEndpoint) super.getEndpoint();
+    }
+
+    @Override
+    protected void doStart() throws Exception {
+        super.doStart();
+        executor = getEndpoint().createExecutor();
+
+        customResourcesWatcher = new CustomResourcesConsumerTask();
+        executor.submit(customResourcesWatcher);
+    }
+
+    @Override
+    protected void doStop() throws Exception {
+        super.doStop();
+
+        LOG.debug(""Stopping Kubernetes Custom Resources Consumer"");
+        if (executor != null) {
+            if (getEndpoint() != null && getEndpoint().getCamelContext() != null) {
+                if (customResourcesWatcher != null) {
+                    customResourcesWatcher.getWatch().close();
+                }
+                getEndpoint().getCamelContext().getExecutorServiceManager().shutdownNow(executor);
+            } else {
+                if (customResourcesWatcher != null) {
+                    customResourcesWatcher.getWatch().close();
+                }
+                executor.shutdownNow();
+            }
+        }
+        executor = null;
+    }
+
+    class CustomResourcesConsumerTask implements Runnable {
+
+        private Watch watch;
+
+        @Override
+        public void run() {
+            RawCustomResourceOperationsImpl w = getEndpoint().getKubernetesClient()
+                    .customResource(getCRDContext(getEndpoint().getKubernetesConfiguration()));
+            if (ObjectHelper.isNotEmpty(getEndpoint().getKubernetesConfiguration().getNamespace())) {
+                LOG.error(""namespace is not specified."");
+            }
+            String namespace = getEndpoint().getKubernetesConfiguration().getNamespace();
+            try {
+                w.watch(namespace, new Watcher<String>() {
+
+                    @Override
+                    public void eventReceived(Action action, String resource) {
+                        Exchange exchange = getEndpoint().createExchange();
+                        exchange.getIn().setBody(resource);
+                        exchange.getIn().setHeader(KubernetesConstants.KUBERNETES_CRD_EVENT_ACTION, action);
+                        exchange.getIn().setHeader(KubernetesConstants.KUBERNETES_CRD_EVENT_TIMESTAMP,
+                                System.currentTimeMillis());
+                        try {
+                            processor.process(exchange);
+                        } catch (Exception e) {
+                            getExceptionHandler().handleException(""Error during processing"", exchange, e);
+                        }
+                    }
+
+                    @Override
+                    public void onClose(KubernetesClientException cause) {
+                        if (cause != null) {
+                            LOG.error(cause.getMessage(), cause);
+                        }
+
+                    }
+                });
+            } catch (Exception e) {
+                LOG.error(""Exception in handling githubsource instance change"", e);
+            }
+
+            /*","[{'comment': 'Is there a reason for commented part?', 'commenter': 'oscerd'}, {'comment': 'No, I forgot to clean up.  I take it out.  Thanks.', 'commenter': 'akihikokuroda'}]"
4541,components/camel-kubernetes/src/main/java/org/apache/camel/component/kubernetes/customresources/KubernetesCustomResourcesEndpoint.java,"@@ -0,0 +1,51 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.kubernetes.customresources;
+
+import org.apache.camel.Category;
+import org.apache.camel.Consumer;
+import org.apache.camel.Processor;
+import org.apache.camel.Producer;
+import org.apache.camel.component.kubernetes.AbstractKubernetesEndpoint;
+import org.apache.camel.component.kubernetes.KubernetesConfiguration;
+import org.apache.camel.spi.UriEndpoint;
+
+/**
+ * Perform operations on Kubernetes Custom Resources and get notified on Deployment changes.
+ */
+@UriEndpoint(firstVersion = ""2.20.0"", scheme = ""kubernetes-custom-resources"", title = ""Kubernetes Custom Resources"",","[{'comment': 'firstVersion is wrong', 'commenter': 'oscerd'}, {'comment': 'Thanks!  I change it to 3.7.0.', 'commenter': 'akihikokuroda'}]"
4541,components/camel-kubernetes/src/main/java/org/apache/camel/component/kubernetes/customresources/KubernetesCustomResourcesConsumer.java,"@@ -0,0 +1,193 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.kubernetes.customresources;
+
+import java.util.concurrent.ExecutorService;
+
+import io.fabric8.kubernetes.client.KubernetesClientException;
+import io.fabric8.kubernetes.client.Watch;
+import io.fabric8.kubernetes.client.Watcher;
+import io.fabric8.kubernetes.client.dsl.base.CustomResourceDefinitionContext;
+import io.fabric8.kubernetes.client.dsl.internal.RawCustomResourceOperationsImpl;
+/*","[{'comment': 'Please remove commented imports', 'commenter': 'oscerd'}, {'comment': 'Yes, I do.  Thanks!', 'commenter': 'akihikokuroda'}]"
4541,components/camel-kubernetes/src/main/java/org/apache/camel/component/kubernetes/KubernetesConfiguration.java,"@@ -105,6 +105,21 @@
     @UriParam(label = ""advanced"")
     private Integer connectionTimeout;
 
+    @UriParam(label = ""consumer"")
+    private String cRDName;
+
+    @UriParam(label = ""consumer"")
+    private String cRDGroup;","[{'comment': 'Please use crdGroup cRDGroup is really ugly to read and see :-)', 'commenter': 'oscerd'}, {'comment': 'I change.', 'commenter': 'akihikokuroda'}]"
4541,components/camel-kubernetes/src/main/java/org/apache/camel/component/kubernetes/KubernetesConfiguration.java,"@@ -105,6 +105,21 @@
     @UriParam(label = ""advanced"")
     private Integer connectionTimeout;
 
+    @UriParam(label = ""consumer"")
+    private String cRDName;","[{'comment': 'crdName', 'commenter': 'oscerd'}, {'comment': 'I change.', 'commenter': 'akihikokuroda'}]"
4541,components/camel-kubernetes/src/main/java/org/apache/camel/component/kubernetes/KubernetesConfiguration.java,"@@ -105,6 +105,21 @@
     @UriParam(label = ""advanced"")
     private Integer connectionTimeout;
 
+    @UriParam(label = ""consumer"")
+    private String cRDName;
+
+    @UriParam(label = ""consumer"")
+    private String cRDGroup;
+
+    @UriParam(label = ""consumer"")
+    private String cRDScope;","[{'comment': 'crdScope', 'commenter': 'oscerd'}, {'comment': 'I change.', 'commenter': 'akihikokuroda'}]"
4541,components/camel-kubernetes/src/main/java/org/apache/camel/component/kubernetes/KubernetesConfiguration.java,"@@ -105,6 +105,21 @@
     @UriParam(label = ""advanced"")
     private Integer connectionTimeout;
 
+    @UriParam(label = ""consumer"")
+    private String cRDName;
+
+    @UriParam(label = ""consumer"")
+    private String cRDGroup;
+
+    @UriParam(label = ""consumer"")
+    private String cRDScope;
+
+    @UriParam(label = ""consumer"")
+    private String cRDVersion;","[{'comment': 'crdVersion', 'commenter': 'oscerd'}, {'comment': 'I change.', 'commenter': 'akihikokuroda'}]"
4541,components/camel-kubernetes/src/main/java/org/apache/camel/component/kubernetes/KubernetesConfiguration.java,"@@ -105,6 +105,21 @@
     @UriParam(label = ""advanced"")
     private Integer connectionTimeout;
 
+    @UriParam(label = ""consumer"")
+    private String cRDName;
+
+    @UriParam(label = ""consumer"")
+    private String cRDGroup;
+
+    @UriParam(label = ""consumer"")
+    private String cRDScope;
+
+    @UriParam(label = ""consumer"")
+    private String cRDVersion;
+
+    @UriParam(label = ""consumer"")
+    private String cRDPlural;","[{'comment': 'crdPlural', 'commenter': 'oscerd'}, {'comment': 'I change.', 'commenter': 'akihikokuroda'}]"
4541,components/camel-kubernetes/src/main/java/org/apache/camel/component/kubernetes/customresources/KubernetesCustomResourcesProducer.java,"@@ -0,0 +1,199 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.kubernetes.customresources;
+
+import java.util.Map;
+
+import io.fabric8.kubernetes.client.KubernetesClientException;
+import io.fabric8.kubernetes.client.dsl.base.CustomResourceDefinitionContext;
+import org.apache.camel.Exchange;
+import org.apache.camel.Message;
+import org.apache.camel.component.kubernetes.AbstractKubernetesEndpoint;
+import org.apache.camel.component.kubernetes.KubernetesConstants;
+import org.apache.camel.component.kubernetes.KubernetesOperations;
+import org.apache.camel.support.DefaultProducer;
+import org.apache.camel.support.MessageHelper;
+import org.apache.camel.util.ObjectHelper;
+import org.apache.camel.util.json.JsonArray;
+import org.apache.camel.util.json.JsonObject;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class KubernetesCustomResourcesProducer extends DefaultProducer {
+
+    private static final Logger LOG = LoggerFactory.getLogger(KubernetesCustomResourcesProducer.class);
+
+    public KubernetesCustomResourcesProducer(AbstractKubernetesEndpoint endpoint) {
+        super(endpoint);
+    }
+
+    @Override
+    public AbstractKubernetesEndpoint getEndpoint() {
+        return (AbstractKubernetesEndpoint) super.getEndpoint();
+    }
+
+    @Override
+    public void process(Exchange exchange) throws Exception {
+        String operation;
+
+        if (ObjectHelper.isEmpty(getEndpoint().getKubernetesConfiguration().getOperation())) {
+            operation = exchange.getIn().getHeader(KubernetesConstants.KUBERNETES_OPERATION, String.class);
+        } else {
+            operation = getEndpoint().getKubernetesConfiguration().getOperation();
+        }
+
+        switch (operation) {
+
+            case KubernetesOperations.LIST_CUSTOMRESOURCES:
+                doList(exchange, operation);
+                break;
+
+            case KubernetesOperations.LIST_CUSTOMRESOURCES_BY_LABELS_OPERATION:
+                doListByLabels(exchange, operation);
+                break;
+
+            case KubernetesOperations.GET_CUSTOMRESOURCE:
+                doGet(exchange, operation);
+                break;
+
+            case KubernetesOperations.DELETE_CUSTOMRESOURCE:
+                doDelete(exchange, operation);
+                break;
+
+            case KubernetesOperations.CREATE_CUSTOMRESOURCE:
+                doCreate(exchange, operation);
+                break;
+
+            default:
+                throw new IllegalArgumentException(""Unsupported operation "" + operation);
+        }
+    }
+
+    protected void doList(Exchange exchange, String operation) throws Exception {
+        String namespaceName = exchange.getIn().getHeader(KubernetesConstants.KUBERNETES_NAMESPACE_NAME, String.class);
+        JsonObject customResourcesListJSON = new JsonObject(
+                getEndpoint().getKubernetesClient().customResource(getCRDContext(exchange.getIn())).list(namespaceName));
+        LOG.info(customResourcesListJSON.toString());
+        JsonArray customResourcesListItems = new JsonArray(customResourcesListJSON.getCollection(""items""));
+
+        MessageHelper.copyHeaders(exchange.getIn(), exchange.getOut(), true);
+        exchange.getOut().setBody(customResourcesListItems);
+    }
+
+    protected void doListByLabels(Exchange exchange, String operation) throws Exception {
+        String namespaceName = exchange.getIn().getHeader(KubernetesConstants.KUBERNETES_NAMESPACE_NAME, String.class);
+        Map<String, String> labels = exchange.getIn().getHeader(KubernetesConstants.KUBERNETES_CRD_LABELS, Map.class);
+        JsonObject customResourcesListJSON = new JsonObject(
+                getEndpoint().getKubernetesClient().customResource(getCRDContext(exchange.getIn())).list(namespaceName));
+        LOG.info(customResourcesListJSON.toString());
+        JsonArray customResourcesListItems = new JsonArray(customResourcesListJSON.getCollection(""items""));
+
+        MessageHelper.copyHeaders(exchange.getIn(), exchange.getOut(), true);
+        exchange.getOut().setBody(customResourcesListItems);
+    }
+
+    protected void doGet(Exchange exchange, String operation) throws Exception {
+        String customResourceName = exchange.getIn().getHeader(KubernetesConstants.KUBERNETES_CRD_INSTANCE_NAME, String.class);
+        String namespaceName = exchange.getIn().getHeader(KubernetesConstants.KUBERNETES_NAMESPACE_NAME, String.class);
+        if (ObjectHelper.isEmpty(customResourceName)) {
+            LOG.error(""Get a specific Deployment require specify a Deployment name"");
+            throw new IllegalArgumentException(""Get a specific Deployment require specify a Deployment name"");
+        }
+        JsonObject customResourceJSON = new JsonObject();
+        try {
+            customResourceJSON = new JsonObject(
+                    getEndpoint().getKubernetesClient().customResource(getCRDContext(exchange.getIn())).get(namespaceName,
+                            customResourceName));
+        } catch (KubernetesClientException e) {
+            if (e.getCode() == 404) {
+                LOG.info(""Custom resource instance not found"", e);
+            } else {
+                throw e;
+            }
+        }
+        LOG.info(customResourceJSON.toString());
+
+        MessageHelper.copyHeaders(exchange.getIn(), exchange.getOut(), true);
+        exchange.getOut().setBody(customResourceJSON);
+    }
+
+    protected void doDelete(Exchange exchange, String operation) throws Exception {
+        String customResourceName = exchange.getIn().getHeader(KubernetesConstants.KUBERNETES_CRD_INSTANCE_NAME, String.class);
+        String namespaceName = exchange.getIn().getHeader(KubernetesConstants.KUBERNETES_NAMESPACE_NAME, String.class);
+        if (ObjectHelper.isEmpty(customResourceName)) {
+            LOG.error(""Delete a specific deployment require specify a deployment name"");
+            throw new IllegalArgumentException(""Delete a specific deployment require specify a deployment name"");
+        }
+        if (ObjectHelper.isEmpty(namespaceName)) {
+            LOG.error(""Delete a specific deployment require specify a namespace name"");
+            throw new IllegalArgumentException(""Delete a specific deployment require specify a namespace name"");
+        }
+
+        JsonObject customResourceJSON = new JsonObject();
+        try {
+            customResourceJSON = new JsonObject(
+                    getEndpoint().getKubernetesClient().customResource(getCRDContext(exchange.getIn())).delete(namespaceName,
+                            customResourceName));
+        } catch (KubernetesClientException e) {
+            if (e.getCode() == 404) {
+                LOG.info(""Custom resource instance not found"", e);
+            } else {
+                throw e;
+            }
+        }
+
+        MessageHelper.copyHeaders(exchange.getIn(), exchange.getOut(), true);
+        exchange.getOut().setBody(customResourceJSON);
+    }
+
+    protected void doCreate(Exchange exchange, String operation) throws Exception {
+        String customResourceInstance = exchange.getIn().getHeader(KubernetesConstants.KUBERNETES_CRD_INSTANCE, String.class);
+        String namespaceName = exchange.getIn().getHeader(KubernetesConstants.KUBERNETES_NAMESPACE_NAME, String.class);
+
+        JsonObject gitHubSourceJSON = new JsonObject();
+        try {
+            gitHubSourceJSON = new JsonObject(
+                    getEndpoint().getKubernetesClient().customResource(getCRDContext(exchange.getIn())).create(namespaceName,
+                            customResourceInstance));
+        } catch (KubernetesClientException e) {
+            if (e.getCode() == 409) {
+                LOG.info(""Custom resoure instance already exists"", e);
+            } else {
+                throw e;
+            }
+        }
+        MessageHelper.copyHeaders(exchange.getIn(), exchange.getOut(), true);
+        exchange.getOut().setBody(gitHubSourceJSON);
+    }
+
+    private CustomResourceDefinitionContext getCRDContext(Message message) {
+        LOG.info(""getCRDContext:"" + message.getHeader(KubernetesConstants.KUBERNETES_CRD_NAME, String.class));","[{'comment': 'No need for this log at info level. Too noisy. At least use debug level.', 'commenter': 'oscerd'}, {'comment': ""Yes, it's too much.  I take them out.  Thanks!"", 'commenter': 'akihikokuroda'}]"
4541,components/camel-kubernetes/src/main/java/org/apache/camel/component/kubernetes/customresources/KubernetesCustomResourcesConsumer.java,"@@ -0,0 +1,145 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.kubernetes.customresources;
+
+import java.util.concurrent.ExecutorService;
+
+import io.fabric8.kubernetes.client.KubernetesClientException;
+import io.fabric8.kubernetes.client.Watch;
+import io.fabric8.kubernetes.client.Watcher;
+import io.fabric8.kubernetes.client.dsl.base.CustomResourceDefinitionContext;
+import io.fabric8.kubernetes.client.dsl.internal.RawCustomResourceOperationsImpl;
+import org.apache.camel.Exchange;
+import org.apache.camel.Processor;
+import org.apache.camel.component.kubernetes.AbstractKubernetesEndpoint;
+import org.apache.camel.component.kubernetes.KubernetesConfiguration;
+import org.apache.camel.component.kubernetes.KubernetesConstants;
+import org.apache.camel.support.DefaultConsumer;
+import org.apache.camel.util.ObjectHelper;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class KubernetesCustomResourcesConsumer extends DefaultConsumer {
+
+    private static final Logger LOG = LoggerFactory.getLogger(KubernetesCustomResourcesConsumer.class);
+
+    private final Processor processor;
+    private ExecutorService executor;
+    private CustomResourcesConsumerTask customResourcesWatcher;
+
+    public KubernetesCustomResourcesConsumer(AbstractKubernetesEndpoint endpoint, Processor processor) {
+        super(endpoint, processor);
+        this.processor = processor;
+    }
+
+    @Override
+    public AbstractKubernetesEndpoint getEndpoint() {
+        return (AbstractKubernetesEndpoint) super.getEndpoint();
+    }
+
+    @Override
+    protected void doStart() throws Exception {
+        super.doStart();
+        executor = getEndpoint().createExecutor();
+
+        customResourcesWatcher = new CustomResourcesConsumerTask();
+        executor.submit(customResourcesWatcher);
+    }
+
+    @Override
+    protected void doStop() throws Exception {
+        super.doStop();","[{'comment': ""IMHO I'd stop the camel context last after stopping the executor"", 'commenter': 'omarsmak'}, {'comment': 'Thanks!  I move the call.', 'commenter': 'akihikokuroda'}]"
4541,components/camel-kubernetes/src/main/java/org/apache/camel/component/kubernetes/customresources/KubernetesCustomResourcesConsumer.java,"@@ -0,0 +1,145 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.kubernetes.customresources;
+
+import java.util.concurrent.ExecutorService;
+
+import io.fabric8.kubernetes.client.KubernetesClientException;
+import io.fabric8.kubernetes.client.Watch;
+import io.fabric8.kubernetes.client.Watcher;
+import io.fabric8.kubernetes.client.dsl.base.CustomResourceDefinitionContext;
+import io.fabric8.kubernetes.client.dsl.internal.RawCustomResourceOperationsImpl;
+import org.apache.camel.Exchange;
+import org.apache.camel.Processor;
+import org.apache.camel.component.kubernetes.AbstractKubernetesEndpoint;
+import org.apache.camel.component.kubernetes.KubernetesConfiguration;
+import org.apache.camel.component.kubernetes.KubernetesConstants;
+import org.apache.camel.support.DefaultConsumer;
+import org.apache.camel.util.ObjectHelper;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class KubernetesCustomResourcesConsumer extends DefaultConsumer {
+
+    private static final Logger LOG = LoggerFactory.getLogger(KubernetesCustomResourcesConsumer.class);
+
+    private final Processor processor;
+    private ExecutorService executor;
+    private CustomResourcesConsumerTask customResourcesWatcher;
+
+    public KubernetesCustomResourcesConsumer(AbstractKubernetesEndpoint endpoint, Processor processor) {
+        super(endpoint, processor);
+        this.processor = processor;
+    }
+
+    @Override
+    public AbstractKubernetesEndpoint getEndpoint() {
+        return (AbstractKubernetesEndpoint) super.getEndpoint();
+    }
+
+    @Override
+    protected void doStart() throws Exception {
+        super.doStart();
+        executor = getEndpoint().createExecutor();
+
+        customResourcesWatcher = new CustomResourcesConsumerTask();
+        executor.submit(customResourcesWatcher);
+    }
+
+    @Override
+    protected void doStop() throws Exception {
+        super.doStop();
+
+        LOG.debug(""Stopping Kubernetes Custom Resources Consumer"");
+        if (executor != null) {
+            if (getEndpoint() != null && getEndpoint().getCamelContext() != null) {
+                if (customResourcesWatcher != null) {
+                    customResourcesWatcher.getWatch().close();
+                }
+                getEndpoint().getCamelContext().getExecutorServiceManager().shutdownNow(executor);
+            } else {
+                if (customResourcesWatcher != null) {
+                    customResourcesWatcher.getWatch().close();
+                }
+                executor.shutdownNow();
+            }
+        }
+        executor = null;
+    }
+
+    class CustomResourcesConsumerTask implements Runnable {
+
+        private Watch watch;
+
+        @Override
+        public void run() {
+            RawCustomResourceOperationsImpl w = getEndpoint().getKubernetesClient()","[{'comment': 'Can we have more meaningful name instead of `w`? ', 'commenter': 'omarsmak'}, {'comment': 'I change it to operations. ', 'commenter': 'akihikokuroda'}]"
4541,components/camel-kubernetes/src/main/java/org/apache/camel/component/kubernetes/customresources/KubernetesCustomResourcesProducer.java,"@@ -0,0 +1,194 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.kubernetes.customresources;
+
+import java.util.Map;
+
+import io.fabric8.kubernetes.client.KubernetesClientException;
+import io.fabric8.kubernetes.client.dsl.base.CustomResourceDefinitionContext;
+import org.apache.camel.Exchange;
+import org.apache.camel.Message;
+import org.apache.camel.component.kubernetes.AbstractKubernetesEndpoint;
+import org.apache.camel.component.kubernetes.KubernetesConstants;
+import org.apache.camel.component.kubernetes.KubernetesOperations;
+import org.apache.camel.support.DefaultProducer;
+import org.apache.camel.support.MessageHelper;
+import org.apache.camel.util.ObjectHelper;
+import org.apache.camel.util.json.JsonArray;
+import org.apache.camel.util.json.JsonObject;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class KubernetesCustomResourcesProducer extends DefaultProducer {
+
+    private static final Logger LOG = LoggerFactory.getLogger(KubernetesCustomResourcesProducer.class);
+
+    public KubernetesCustomResourcesProducer(AbstractKubernetesEndpoint endpoint) {
+        super(endpoint);
+    }
+
+    @Override
+    public AbstractKubernetesEndpoint getEndpoint() {
+        return (AbstractKubernetesEndpoint) super.getEndpoint();
+    }
+
+    @Override
+    public void process(Exchange exchange) throws Exception {
+        String operation;
+
+        if (ObjectHelper.isEmpty(getEndpoint().getKubernetesConfiguration().getOperation())) {
+            operation = exchange.getIn().getHeader(KubernetesConstants.KUBERNETES_OPERATION, String.class);
+        } else {
+            operation = getEndpoint().getKubernetesConfiguration().getOperation();
+        }
+
+        switch (operation) {
+
+            case KubernetesOperations.LIST_CUSTOMRESOURCES:
+                doList(exchange, operation);
+                break;
+
+            case KubernetesOperations.LIST_CUSTOMRESOURCES_BY_LABELS_OPERATION:
+                doListByLabels(exchange, operation);
+                break;
+
+            case KubernetesOperations.GET_CUSTOMRESOURCE:
+                doGet(exchange, operation);
+                break;
+
+            case KubernetesOperations.DELETE_CUSTOMRESOURCE:
+                doDelete(exchange, operation);
+                break;
+
+            case KubernetesOperations.CREATE_CUSTOMRESOURCE:
+                doCreate(exchange, operation);
+                break;
+
+            default:
+                throw new IllegalArgumentException(""Unsupported operation "" + operation);
+        }
+    }
+
+    protected void doList(Exchange exchange, String operation) throws Exception {
+        String namespaceName = exchange.getIn().getHeader(KubernetesConstants.KUBERNETES_NAMESPACE_NAME, String.class);","[{'comment': ""The namespace here is essential for the operation, isn't? If so, can we add checks for the required options (in this operation and the other operation) that being obtained from the headers and throw an exception with meaningful message to the user?  "", 'commenter': 'omarsmak'}, {'comment': 'All operations require the namespace argument so I add check the check in the `process` mentod.', 'commenter': 'akihikokuroda'}]"
4541,components/camel-kubernetes/src/main/java/org/apache/camel/component/kubernetes/customresources/KubernetesCustomResourcesProducer.java,"@@ -0,0 +1,194 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.kubernetes.customresources;
+
+import java.util.Map;
+
+import io.fabric8.kubernetes.client.KubernetesClientException;
+import io.fabric8.kubernetes.client.dsl.base.CustomResourceDefinitionContext;
+import org.apache.camel.Exchange;
+import org.apache.camel.Message;
+import org.apache.camel.component.kubernetes.AbstractKubernetesEndpoint;
+import org.apache.camel.component.kubernetes.KubernetesConstants;
+import org.apache.camel.component.kubernetes.KubernetesOperations;
+import org.apache.camel.support.DefaultProducer;
+import org.apache.camel.support.MessageHelper;
+import org.apache.camel.util.ObjectHelper;
+import org.apache.camel.util.json.JsonArray;
+import org.apache.camel.util.json.JsonObject;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class KubernetesCustomResourcesProducer extends DefaultProducer {
+
+    private static final Logger LOG = LoggerFactory.getLogger(KubernetesCustomResourcesProducer.class);
+
+    public KubernetesCustomResourcesProducer(AbstractKubernetesEndpoint endpoint) {
+        super(endpoint);
+    }
+
+    @Override
+    public AbstractKubernetesEndpoint getEndpoint() {
+        return (AbstractKubernetesEndpoint) super.getEndpoint();
+    }
+
+    @Override
+    public void process(Exchange exchange) throws Exception {
+        String operation;
+
+        if (ObjectHelper.isEmpty(getEndpoint().getKubernetesConfiguration().getOperation())) {
+            operation = exchange.getIn().getHeader(KubernetesConstants.KUBERNETES_OPERATION, String.class);
+        } else {
+            operation = getEndpoint().getKubernetesConfiguration().getOperation();
+        }
+
+        switch (operation) {
+
+            case KubernetesOperations.LIST_CUSTOMRESOURCES:
+                doList(exchange, operation);
+                break;
+
+            case KubernetesOperations.LIST_CUSTOMRESOURCES_BY_LABELS_OPERATION:
+                doListByLabels(exchange, operation);
+                break;
+
+            case KubernetesOperations.GET_CUSTOMRESOURCE:
+                doGet(exchange, operation);
+                break;
+
+            case KubernetesOperations.DELETE_CUSTOMRESOURCE:
+                doDelete(exchange, operation);
+                break;
+
+            case KubernetesOperations.CREATE_CUSTOMRESOURCE:
+                doCreate(exchange, operation);
+                break;
+
+            default:
+                throw new IllegalArgumentException(""Unsupported operation "" + operation);
+        }
+    }
+
+    protected void doList(Exchange exchange, String operation) throws Exception {
+        String namespaceName = exchange.getIn().getHeader(KubernetesConstants.KUBERNETES_NAMESPACE_NAME, String.class);
+        JsonObject customResourcesListJSON = new JsonObject(
+                getEndpoint().getKubernetesClient().customResource(getCRDContext(exchange.getIn())).list(namespaceName));
+        LOG.info(customResourcesListJSON.toString());
+        JsonArray customResourcesListItems = new JsonArray(customResourcesListJSON.getCollection(""items""));
+
+        MessageHelper.copyHeaders(exchange.getIn(), exchange.getOut(), true);
+        exchange.getOut().setBody(customResourcesListItems);
+    }
+
+    protected void doListByLabels(Exchange exchange, String operation) throws Exception {
+        String namespaceName = exchange.getIn().getHeader(KubernetesConstants.KUBERNETES_NAMESPACE_NAME, String.class);","[{'comment': ""Apart from my other comment, I think these configurations can be obtained either from the endpoint configurations or the exchange headers, not only the exchange headers, isn't? If so, IMHO, I'd add a logic to first check if these options being set in the exchange headers first and fall back to the endpoint options aka `KubernetesConfiguration`."", 'commenter': 'omarsmak'}, {'comment': ""Thanks!  I'll add it."", 'commenter': 'akihikokuroda'}]"
4541,components/camel-kubernetes/src/main/java/org/apache/camel/component/kubernetes/customresources/KubernetesCustomResourcesProducer.java,"@@ -0,0 +1,194 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.kubernetes.customresources;
+
+import java.util.Map;
+
+import io.fabric8.kubernetes.client.KubernetesClientException;
+import io.fabric8.kubernetes.client.dsl.base.CustomResourceDefinitionContext;
+import org.apache.camel.Exchange;
+import org.apache.camel.Message;
+import org.apache.camel.component.kubernetes.AbstractKubernetesEndpoint;
+import org.apache.camel.component.kubernetes.KubernetesConstants;
+import org.apache.camel.component.kubernetes.KubernetesOperations;
+import org.apache.camel.support.DefaultProducer;
+import org.apache.camel.support.MessageHelper;
+import org.apache.camel.util.ObjectHelper;
+import org.apache.camel.util.json.JsonArray;
+import org.apache.camel.util.json.JsonObject;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class KubernetesCustomResourcesProducer extends DefaultProducer {
+
+    private static final Logger LOG = LoggerFactory.getLogger(KubernetesCustomResourcesProducer.class);
+
+    public KubernetesCustomResourcesProducer(AbstractKubernetesEndpoint endpoint) {
+        super(endpoint);
+    }
+
+    @Override
+    public AbstractKubernetesEndpoint getEndpoint() {
+        return (AbstractKubernetesEndpoint) super.getEndpoint();
+    }
+
+    @Override
+    public void process(Exchange exchange) throws Exception {
+        String operation;
+
+        if (ObjectHelper.isEmpty(getEndpoint().getKubernetesConfiguration().getOperation())) {
+            operation = exchange.getIn().getHeader(KubernetesConstants.KUBERNETES_OPERATION, String.class);
+        } else {
+            operation = getEndpoint().getKubernetesConfiguration().getOperation();
+        }
+
+        switch (operation) {
+
+            case KubernetesOperations.LIST_CUSTOMRESOURCES:
+                doList(exchange, operation);
+                break;
+
+            case KubernetesOperations.LIST_CUSTOMRESOURCES_BY_LABELS_OPERATION:
+                doListByLabels(exchange, operation);
+                break;
+
+            case KubernetesOperations.GET_CUSTOMRESOURCE:
+                doGet(exchange, operation);
+                break;
+
+            case KubernetesOperations.DELETE_CUSTOMRESOURCE:
+                doDelete(exchange, operation);
+                break;
+
+            case KubernetesOperations.CREATE_CUSTOMRESOURCE:
+                doCreate(exchange, operation);
+                break;
+
+            default:
+                throw new IllegalArgumentException(""Unsupported operation "" + operation);
+        }
+    }
+
+    protected void doList(Exchange exchange, String operation) throws Exception {
+        String namespaceName = exchange.getIn().getHeader(KubernetesConstants.KUBERNETES_NAMESPACE_NAME, String.class);
+        JsonObject customResourcesListJSON = new JsonObject(
+                getEndpoint().getKubernetesClient().customResource(getCRDContext(exchange.getIn())).list(namespaceName));
+        LOG.info(customResourcesListJSON.toString());
+        JsonArray customResourcesListItems = new JsonArray(customResourcesListJSON.getCollection(""items""));
+
+        MessageHelper.copyHeaders(exchange.getIn(), exchange.getOut(), true);
+        exchange.getOut().setBody(customResourcesListItems);
+    }
+
+    protected void doListByLabels(Exchange exchange, String operation) throws Exception {
+        String namespaceName = exchange.getIn().getHeader(KubernetesConstants.KUBERNETES_NAMESPACE_NAME, String.class);
+        Map<String, String> labels = exchange.getIn().getHeader(KubernetesConstants.KUBERNETES_CRD_LABELS, Map.class);
+        JsonObject customResourcesListJSON = new JsonObject(
+                getEndpoint().getKubernetesClient().customResource(getCRDContext(exchange.getIn())).list(namespaceName));
+        LOG.info(customResourcesListJSON.toString());
+        JsonArray customResourcesListItems = new JsonArray(customResourcesListJSON.getCollection(""items""));
+
+        MessageHelper.copyHeaders(exchange.getIn(), exchange.getOut(), true);
+        exchange.getOut().setBody(customResourcesListItems);
+    }
+
+    protected void doGet(Exchange exchange, String operation) throws Exception {
+        String customResourceName = exchange.getIn().getHeader(KubernetesConstants.KUBERNETES_CRD_INSTANCE_NAME, String.class);
+        String namespaceName = exchange.getIn().getHeader(KubernetesConstants.KUBERNETES_NAMESPACE_NAME, String.class);
+        if (ObjectHelper.isEmpty(customResourceName)) {
+            LOG.error(""Get a specific Deployment require specify a Deployment name"");
+            throw new IllegalArgumentException(""Get a specific Deployment require specify a Deployment name"");
+        }
+        JsonObject customResourceJSON = new JsonObject();
+        try {
+            customResourceJSON = new JsonObject(
+                    getEndpoint().getKubernetesClient().customResource(getCRDContext(exchange.getIn())).get(namespaceName,
+                            customResourceName));
+        } catch (KubernetesClientException e) {
+            if (e.getCode() == 404) {
+                LOG.info(""Custom resource instance not found"", e);
+            } else {
+                throw e;
+            }
+        }
+        LOG.info(customResourceJSON.toString());
+
+        MessageHelper.copyHeaders(exchange.getIn(), exchange.getOut(), true);
+        exchange.getOut().setBody(customResourceJSON);
+    }
+
+    protected void doDelete(Exchange exchange, String operation) throws Exception {
+        String customResourceName = exchange.getIn().getHeader(KubernetesConstants.KUBERNETES_CRD_INSTANCE_NAME, String.class);
+        String namespaceName = exchange.getIn().getHeader(KubernetesConstants.KUBERNETES_NAMESPACE_NAME, String.class);
+        if (ObjectHelper.isEmpty(customResourceName)) {
+            LOG.error(""Delete a specific deployment require specify a deployment name"");
+            throw new IllegalArgumentException(""Delete a specific deployment require specify a deployment name"");
+        }
+        if (ObjectHelper.isEmpty(namespaceName)) {
+            LOG.error(""Delete a specific deployment require specify a namespace name"");
+            throw new IllegalArgumentException(""Delete a specific deployment require specify a namespace name"");
+        }
+
+        JsonObject customResourceJSON = new JsonObject();
+        try {
+            customResourceJSON = new JsonObject(
+                    getEndpoint().getKubernetesClient().customResource(getCRDContext(exchange.getIn())).delete(namespaceName,
+                            customResourceName));
+        } catch (KubernetesClientException e) {
+            if (e.getCode() == 404) {
+                LOG.info(""Custom resource instance not found"", e);
+            } else {
+                throw e;
+            }
+        }
+
+        MessageHelper.copyHeaders(exchange.getIn(), exchange.getOut(), true);
+        exchange.getOut().setBody(customResourceJSON);
+    }
+
+    protected void doCreate(Exchange exchange, String operation) throws Exception {
+        String customResourceInstance = exchange.getIn().getHeader(KubernetesConstants.KUBERNETES_CRD_INSTANCE, String.class);
+        String namespaceName = exchange.getIn().getHeader(KubernetesConstants.KUBERNETES_NAMESPACE_NAME, String.class);
+
+        JsonObject gitHubSourceJSON = new JsonObject();
+        try {
+            gitHubSourceJSON = new JsonObject(
+                    getEndpoint().getKubernetesClient().customResource(getCRDContext(exchange.getIn())).create(namespaceName,
+                            customResourceInstance));
+        } catch (KubernetesClientException e) {
+            if (e.getCode() == 409) {
+                LOG.info(""Custom resoure instance already exists"", e);
+            } else {
+                throw e;
+            }
+        }
+        MessageHelper.copyHeaders(exchange.getIn(), exchange.getOut(), true);
+        exchange.getOut().setBody(gitHubSourceJSON);
+    }
+
+    private CustomResourceDefinitionContext getCRDContext(Message message) {
+        CustomResourceDefinitionContext cRDContext = new CustomResourceDefinitionContext.Builder()
+                .withName(message.getHeader(KubernetesConstants.KUBERNETES_CRD_NAME, String.class))       // example: ""githubsources.sources.knative.dev""","[{'comment': ""Also here, if not mistaken, all these options are required for the CRD context, isn't? Then checks here would help if this option is set or not and throw an exception with meaningful message to the user."", 'commenter': 'omarsmak'}, {'comment': 'Thanks!  I add check for these arguments.', 'commenter': 'akihikokuroda'}]"
4542,archetypes/camel-archetype-endpointdsl/src/main/resources/archetype-resources/src/main/java/MyRouteBuilder.java,"@@ -0,0 +1,46 @@
+## ------------------------------------------------------------------------
+## Licensed to the Apache Software Foundation (ASF) under one or more
+## contributor license agreements.  See the NOTICE file distributed with
+## this work for additional information regarding copyright ownership.
+## The ASF licenses this file to You under the Apache License, Version 2.0
+## (the ""License""); you may not use this file except in compliance with
+## the License.  You may obtain a copy of the License at
+##
+## http://www.apache.org/licenses/LICENSE-2.0
+##
+## Unless required by applicable law or agreed to in writing, software
+## distributed under the License is distributed on an ""AS IS"" BASIS,
+## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+## See the License for the specific language governing permissions and
+## limitations under the License.
+## ------------------------------------------------------------------------
+package ${package};
+
+import org.apache.camel.builder.RouteBuilder;
+import org.apache.camel.builder.endpoint.dsl.FileEndpointBuilderFactory;
+
+import static org.apache.camel.builder.endpoint.StaticEndpointBuilders.file;
+import static org.apache.camel.builder.endpoint.StaticEndpointBuilders.timer;
+/**
+ * A Camel Java DSL Router
+ */
+public class MyRouteBuilder extends RouteBuilder {","[{'comment': 'Its better to extend EndpointRouteBuilder, then you dont need those static imports, see for example https://github.com/apache/camel/blob/4ea9e6c357371682b855d2d79655b41120331b7a/core/camel-endpointdsl/src/test/java/org/apache/camel/builder/endpoint/FileDelayTest.java#L50', 'commenter': 'davsclaus'}, {'comment': 'Commit [77cd11e](https://github.com/apache/camel/pull/4542/commits/77cd11e9e2954d9723499329159ab5b2ff042825) resolves both observations. Thank you for your support.', 'commenter': 'PickledDragon'}]"
4542,archetypes/camel-archetype-endpointdsl/src/main/resources/archetype-resources/src/main/java/MyRouteBuilder.java,"@@ -0,0 +1,46 @@
+## ------------------------------------------------------------------------
+## Licensed to the Apache Software Foundation (ASF) under one or more
+## contributor license agreements.  See the NOTICE file distributed with
+## this work for additional information regarding copyright ownership.
+## The ASF licenses this file to You under the Apache License, Version 2.0
+## (the ""License""); you may not use this file except in compliance with
+## the License.  You may obtain a copy of the License at
+##
+## http://www.apache.org/licenses/LICENSE-2.0
+##
+## Unless required by applicable law or agreed to in writing, software
+## distributed under the License is distributed on an ""AS IS"" BASIS,
+## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+## See the License for the specific language governing permissions and
+## limitations under the License.
+## ------------------------------------------------------------------------
+package ${package};
+
+import org.apache.camel.builder.RouteBuilder;
+import org.apache.camel.builder.endpoint.dsl.FileEndpointBuilderFactory;
+
+import static org.apache.camel.builder.endpoint.StaticEndpointBuilders.file;
+import static org.apache.camel.builder.endpoint.StaticEndpointBuilders.timer;
+/**","[{'comment': 'Add empty line above', 'commenter': 'davsclaus'}]"
4561,components/camel-datasonnet/pom.xml,"@@ -0,0 +1,142 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one or more
+    contributor license agreements.  See the NOTICE file distributed with
+    this work for additional information regarding copyright ownership.
+    The ASF licenses this file to You under the Apache License, Version 2.0
+    (the ""License""); you may not use this file except in compliance with
+    the License.  You may obtain a copy of the License at
+
+         http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an ""AS IS"" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+
+-->
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"">
+    <modelVersion>4.0.0</modelVersion>
+
+    <parent>
+        <groupId>org.apache.camel</groupId>
+        <artifactId>components</artifactId>
+        <version>3.7.0-SNAPSHOT</version>
+    </parent>
+
+    <artifactId>camel-datasonnet</artifactId>
+    <packaging>jar</packaging>
+
+    <name>Camel :: DataSonnet</name>
+    <description>Camel DataSonnet support</description>
+
+    <properties>
+        <maven.compiler.source>1.8</maven.compiler.source>
+        <maven.compiler.target>1.8</maven.compiler.target>
+    </properties>
+
+    <build>
+        <plugins>
+            <plugin>
+                <groupId>net.alchim31.maven</groupId>
+                <artifactId>scala-maven-plugin</artifactId>
+                <executions>
+                    <execution>
+                        <id>scala-compile-first</id>
+                        <phase>process-resources</phase>
+                        <goals>
+                            <goal>add-source</goal>
+                            <goal>compile</goal>
+                        </goals>
+                    </execution>
+                    <execution>
+                        <id>scala-test-compile</id>
+                        <phase>process-test-resources</phase>
+                        <goals>
+                            <goal>testCompile</goal>
+                        </goals>
+                    </execution>
+                </executions>
+            </plugin>
+            <plugin>
+                <groupId>org.apache.maven.plugins</groupId>
+                <artifactId>maven-surefire-plugin</artifactId>
+                <configuration>
+                    <additionalClasspathElements>
+                        <additionalClasspathElement>${project.basedir}/src/test/resources/dslibs.jar</additionalClasspathElement>","[{'comment': 'What is this library here?', 'commenter': 'oscerd'}]"
4561,components/camel-datasonnet/pom.xml,"@@ -0,0 +1,142 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one or more
+    contributor license agreements.  See the NOTICE file distributed with
+    this work for additional information regarding copyright ownership.
+    The ASF licenses this file to You under the Apache License, Version 2.0
+    (the ""License""); you may not use this file except in compliance with
+    the License.  You may obtain a copy of the License at
+
+         http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an ""AS IS"" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+
+-->
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"">
+    <modelVersion>4.0.0</modelVersion>
+
+    <parent>
+        <groupId>org.apache.camel</groupId>
+        <artifactId>components</artifactId>
+        <version>3.7.0-SNAPSHOT</version>
+    </parent>
+
+    <artifactId>camel-datasonnet</artifactId>
+    <packaging>jar</packaging>
+
+    <name>Camel :: DataSonnet</name>
+    <description>Camel DataSonnet support</description>
+
+    <properties>
+        <maven.compiler.source>1.8</maven.compiler.source>
+        <maven.compiler.target>1.8</maven.compiler.target>
+    </properties>
+
+    <build>
+        <plugins>
+            <plugin>
+                <groupId>net.alchim31.maven</groupId>
+                <artifactId>scala-maven-plugin</artifactId>
+                <executions>
+                    <execution>
+                        <id>scala-compile-first</id>
+                        <phase>process-resources</phase>
+                        <goals>
+                            <goal>add-source</goal>
+                            <goal>compile</goal>
+                        </goals>
+                    </execution>
+                    <execution>
+                        <id>scala-test-compile</id>
+                        <phase>process-test-resources</phase>
+                        <goals>
+                            <goal>testCompile</goal>
+                        </goals>
+                    </execution>
+                </executions>
+            </plugin>
+            <plugin>
+                <groupId>org.apache.maven.plugins</groupId>
+                <artifactId>maven-surefire-plugin</artifactId>
+                <configuration>
+                    <additionalClasspathElements>
+                        <additionalClasspathElement>${project.basedir}/src/test/resources/dslibs.jar</additionalClasspathElement>
+                    </additionalClasspathElements>
+                </configuration>
+            </plugin>
+        </plugins>
+    </build>
+
+    <dependencies>
+        <!-- todo: confirm the scala incompatbility is with datasonnet -->
+        <dependency>
+            <groupId>org.scala-lang</groupId>
+            <artifactId>scala-library</artifactId>
+            <version>2.13.3</version>","[{'comment': 'If we need this, we need to move the property version placeholder in parent/pom', 'commenter': 'oscerd'}]"
4561,components/camel-datasonnet/pom.xml,"@@ -0,0 +1,142 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one or more
+    contributor license agreements.  See the NOTICE file distributed with
+    this work for additional information regarding copyright ownership.
+    The ASF licenses this file to You under the Apache License, Version 2.0
+    (the ""License""); you may not use this file except in compliance with
+    the License.  You may obtain a copy of the License at
+
+         http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an ""AS IS"" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+
+-->
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"">
+    <modelVersion>4.0.0</modelVersion>
+
+    <parent>
+        <groupId>org.apache.camel</groupId>
+        <artifactId>components</artifactId>
+        <version>3.7.0-SNAPSHOT</version>
+    </parent>
+
+    <artifactId>camel-datasonnet</artifactId>
+    <packaging>jar</packaging>
+
+    <name>Camel :: DataSonnet</name>
+    <description>Camel DataSonnet support</description>
+
+    <properties>
+        <maven.compiler.source>1.8</maven.compiler.source>
+        <maven.compiler.target>1.8</maven.compiler.target>
+    </properties>
+
+    <build>
+        <plugins>
+            <plugin>
+                <groupId>net.alchim31.maven</groupId>
+                <artifactId>scala-maven-plugin</artifactId>
+                <executions>
+                    <execution>
+                        <id>scala-compile-first</id>
+                        <phase>process-resources</phase>
+                        <goals>
+                            <goal>add-source</goal>
+                            <goal>compile</goal>
+                        </goals>
+                    </execution>
+                    <execution>
+                        <id>scala-test-compile</id>
+                        <phase>process-test-resources</phase>
+                        <goals>
+                            <goal>testCompile</goal>
+                        </goals>
+                    </execution>
+                </executions>
+            </plugin>
+            <plugin>
+                <groupId>org.apache.maven.plugins</groupId>
+                <artifactId>maven-surefire-plugin</artifactId>
+                <configuration>
+                    <additionalClasspathElements>
+                        <additionalClasspathElement>${project.basedir}/src/test/resources/dslibs.jar</additionalClasspathElement>
+                    </additionalClasspathElements>
+                </configuration>
+            </plugin>
+        </plugins>
+    </build>
+
+    <dependencies>
+        <!-- todo: confirm the scala incompatbility is with datasonnet -->
+        <dependency>
+            <groupId>org.scala-lang</groupId>
+            <artifactId>scala-library</artifactId>
+            <version>2.13.3</version>
+        </dependency>
+        <!-- apparently scala compiler needs this -->
+        <dependency>
+            <groupId>org.hamcrest</groupId>
+            <artifactId>hamcrest</artifactId>
+            <version>2.2</version>","[{'comment': 'There is a placeholder in parent/pom', 'commenter': 'oscerd'}]"
4561,components/camel-datasonnet/pom.xml,"@@ -0,0 +1,142 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one or more
+    contributor license agreements.  See the NOTICE file distributed with
+    this work for additional information regarding copyright ownership.
+    The ASF licenses this file to You under the Apache License, Version 2.0
+    (the ""License""); you may not use this file except in compliance with
+    the License.  You may obtain a copy of the License at
+
+         http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an ""AS IS"" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+
+-->
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"">
+    <modelVersion>4.0.0</modelVersion>
+
+    <parent>
+        <groupId>org.apache.camel</groupId>
+        <artifactId>components</artifactId>
+        <version>3.7.0-SNAPSHOT</version>
+    </parent>
+
+    <artifactId>camel-datasonnet</artifactId>
+    <packaging>jar</packaging>
+
+    <name>Camel :: DataSonnet</name>
+    <description>Camel DataSonnet support</description>
+
+    <properties>
+        <maven.compiler.source>1.8</maven.compiler.source>
+        <maven.compiler.target>1.8</maven.compiler.target>
+    </properties>
+
+    <build>
+        <plugins>
+            <plugin>
+                <groupId>net.alchim31.maven</groupId>
+                <artifactId>scala-maven-plugin</artifactId>
+                <executions>
+                    <execution>
+                        <id>scala-compile-first</id>
+                        <phase>process-resources</phase>
+                        <goals>
+                            <goal>add-source</goal>
+                            <goal>compile</goal>
+                        </goals>
+                    </execution>
+                    <execution>
+                        <id>scala-test-compile</id>
+                        <phase>process-test-resources</phase>
+                        <goals>
+                            <goal>testCompile</goal>
+                        </goals>
+                    </execution>
+                </executions>
+            </plugin>
+            <plugin>
+                <groupId>org.apache.maven.plugins</groupId>
+                <artifactId>maven-surefire-plugin</artifactId>
+                <configuration>
+                    <additionalClasspathElements>
+                        <additionalClasspathElement>${project.basedir}/src/test/resources/dslibs.jar</additionalClasspathElement>
+                    </additionalClasspathElements>
+                </configuration>
+            </plugin>
+        </plugins>
+    </build>
+
+    <dependencies>
+        <!-- todo: confirm the scala incompatbility is with datasonnet -->
+        <dependency>
+            <groupId>org.scala-lang</groupId>
+            <artifactId>scala-library</artifactId>
+            <version>2.13.3</version>
+        </dependency>
+        <!-- apparently scala compiler needs this -->
+        <dependency>
+            <groupId>org.hamcrest</groupId>
+            <artifactId>hamcrest</artifactId>
+            <version>2.2</version>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.apache.camel</groupId>
+            <artifactId>camel-support</artifactId>
+        </dependency>
+        <dependency>
+            <groupId>com.datasonnet</groupId>
+            <artifactId>datasonnet-mapper</artifactId>
+            <version>0.6.0-MS3</version>","[{'comment': 'It should go as a placeholder in parent/pom', 'commenter': 'oscerd'}]"
4561,components/camel-datasonnet/pom.xml,"@@ -0,0 +1,142 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one or more
+    contributor license agreements.  See the NOTICE file distributed with
+    this work for additional information regarding copyright ownership.
+    The ASF licenses this file to You under the Apache License, Version 2.0
+    (the ""License""); you may not use this file except in compliance with
+    the License.  You may obtain a copy of the License at
+
+         http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an ""AS IS"" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+
+-->
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"">
+    <modelVersion>4.0.0</modelVersion>
+
+    <parent>
+        <groupId>org.apache.camel</groupId>
+        <artifactId>components</artifactId>
+        <version>3.7.0-SNAPSHOT</version>
+    </parent>
+
+    <artifactId>camel-datasonnet</artifactId>
+    <packaging>jar</packaging>
+
+    <name>Camel :: DataSonnet</name>
+    <description>Camel DataSonnet support</description>
+
+    <properties>
+        <maven.compiler.source>1.8</maven.compiler.source>
+        <maven.compiler.target>1.8</maven.compiler.target>
+    </properties>
+
+    <build>
+        <plugins>
+            <plugin>
+                <groupId>net.alchim31.maven</groupId>
+                <artifactId>scala-maven-plugin</artifactId>
+                <executions>
+                    <execution>
+                        <id>scala-compile-first</id>
+                        <phase>process-resources</phase>
+                        <goals>
+                            <goal>add-source</goal>
+                            <goal>compile</goal>
+                        </goals>
+                    </execution>
+                    <execution>
+                        <id>scala-test-compile</id>
+                        <phase>process-test-resources</phase>
+                        <goals>
+                            <goal>testCompile</goal>
+                        </goals>
+                    </execution>
+                </executions>
+            </plugin>
+            <plugin>
+                <groupId>org.apache.maven.plugins</groupId>
+                <artifactId>maven-surefire-plugin</artifactId>
+                <configuration>
+                    <additionalClasspathElements>
+                        <additionalClasspathElement>${project.basedir}/src/test/resources/dslibs.jar</additionalClasspathElement>
+                    </additionalClasspathElements>
+                </configuration>
+            </plugin>
+        </plugins>
+    </build>
+
+    <dependencies>
+        <!-- todo: confirm the scala incompatbility is with datasonnet -->
+        <dependency>
+            <groupId>org.scala-lang</groupId>
+            <artifactId>scala-library</artifactId>
+            <version>2.13.3</version>
+        </dependency>
+        <!-- apparently scala compiler needs this -->
+        <dependency>
+            <groupId>org.hamcrest</groupId>
+            <artifactId>hamcrest</artifactId>
+            <version>2.2</version>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.apache.camel</groupId>
+            <artifactId>camel-support</artifactId>
+        </dependency>
+        <dependency>
+            <groupId>com.datasonnet</groupId>
+            <artifactId>datasonnet-mapper</artifactId>
+            <version>0.6.0-MS3</version>
+        </dependency>
+        <dependency>
+            <groupId>commons-io</groupId>
+            <artifactId>commons-io</artifactId>
+            <version>2.4</version>","[{'comment': 'ditto', 'commenter': 'oscerd'}]"
4561,components/camel-datasonnet/pom.xml,"@@ -0,0 +1,142 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one or more
+    contributor license agreements.  See the NOTICE file distributed with
+    this work for additional information regarding copyright ownership.
+    The ASF licenses this file to You under the Apache License, Version 2.0
+    (the ""License""); you may not use this file except in compliance with
+    the License.  You may obtain a copy of the License at
+
+         http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an ""AS IS"" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+
+-->
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"">
+    <modelVersion>4.0.0</modelVersion>
+
+    <parent>
+        <groupId>org.apache.camel</groupId>
+        <artifactId>components</artifactId>
+        <version>3.7.0-SNAPSHOT</version>
+    </parent>
+
+    <artifactId>camel-datasonnet</artifactId>
+    <packaging>jar</packaging>
+
+    <name>Camel :: DataSonnet</name>
+    <description>Camel DataSonnet support</description>
+
+    <properties>
+        <maven.compiler.source>1.8</maven.compiler.source>
+        <maven.compiler.target>1.8</maven.compiler.target>
+    </properties>
+
+    <build>
+        <plugins>
+            <plugin>
+                <groupId>net.alchim31.maven</groupId>
+                <artifactId>scala-maven-plugin</artifactId>
+                <executions>
+                    <execution>
+                        <id>scala-compile-first</id>
+                        <phase>process-resources</phase>
+                        <goals>
+                            <goal>add-source</goal>
+                            <goal>compile</goal>
+                        </goals>
+                    </execution>
+                    <execution>
+                        <id>scala-test-compile</id>
+                        <phase>process-test-resources</phase>
+                        <goals>
+                            <goal>testCompile</goal>
+                        </goals>
+                    </execution>
+                </executions>
+            </plugin>
+            <plugin>
+                <groupId>org.apache.maven.plugins</groupId>
+                <artifactId>maven-surefire-plugin</artifactId>
+                <configuration>
+                    <additionalClasspathElements>
+                        <additionalClasspathElement>${project.basedir}/src/test/resources/dslibs.jar</additionalClasspathElement>
+                    </additionalClasspathElements>
+                </configuration>
+            </plugin>
+        </plugins>
+    </build>
+
+    <dependencies>
+        <!-- todo: confirm the scala incompatbility is with datasonnet -->
+        <dependency>
+            <groupId>org.scala-lang</groupId>
+            <artifactId>scala-library</artifactId>
+            <version>2.13.3</version>
+        </dependency>
+        <!-- apparently scala compiler needs this -->
+        <dependency>
+            <groupId>org.hamcrest</groupId>
+            <artifactId>hamcrest</artifactId>
+            <version>2.2</version>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.apache.camel</groupId>
+            <artifactId>camel-support</artifactId>
+        </dependency>
+        <dependency>
+            <groupId>com.datasonnet</groupId>
+            <artifactId>datasonnet-mapper</artifactId>
+            <version>0.6.0-MS3</version>
+        </dependency>
+        <dependency>
+            <groupId>commons-io</groupId>
+            <artifactId>commons-io</artifactId>
+            <version>2.4</version>
+        </dependency>
+        <dependency>
+            <groupId>io.github.classgraph</groupId>
+            <artifactId>classgraph</artifactId>
+            <version>4.8.52</version>","[{'comment': 'ditto', 'commenter': 'oscerd'}]"
4561,components/camel-datasonnet/pom.xml,"@@ -0,0 +1,142 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one or more
+    contributor license agreements.  See the NOTICE file distributed with
+    this work for additional information regarding copyright ownership.
+    The ASF licenses this file to You under the Apache License, Version 2.0
+    (the ""License""); you may not use this file except in compliance with
+    the License.  You may obtain a copy of the License at
+
+         http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an ""AS IS"" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+
+-->
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"">
+    <modelVersion>4.0.0</modelVersion>
+
+    <parent>
+        <groupId>org.apache.camel</groupId>
+        <artifactId>components</artifactId>
+        <version>3.7.0-SNAPSHOT</version>
+    </parent>
+
+    <artifactId>camel-datasonnet</artifactId>
+    <packaging>jar</packaging>
+
+    <name>Camel :: DataSonnet</name>
+    <description>Camel DataSonnet support</description>
+
+    <properties>
+        <maven.compiler.source>1.8</maven.compiler.source>
+        <maven.compiler.target>1.8</maven.compiler.target>
+    </properties>
+
+    <build>
+        <plugins>
+            <plugin>
+                <groupId>net.alchim31.maven</groupId>
+                <artifactId>scala-maven-plugin</artifactId>
+                <executions>
+                    <execution>
+                        <id>scala-compile-first</id>
+                        <phase>process-resources</phase>
+                        <goals>
+                            <goal>add-source</goal>
+                            <goal>compile</goal>
+                        </goals>
+                    </execution>
+                    <execution>
+                        <id>scala-test-compile</id>
+                        <phase>process-test-resources</phase>
+                        <goals>
+                            <goal>testCompile</goal>
+                        </goals>
+                    </execution>
+                </executions>
+            </plugin>
+            <plugin>
+                <groupId>org.apache.maven.plugins</groupId>
+                <artifactId>maven-surefire-plugin</artifactId>
+                <configuration>
+                    <additionalClasspathElements>
+                        <additionalClasspathElement>${project.basedir}/src/test/resources/dslibs.jar</additionalClasspathElement>
+                    </additionalClasspathElements>
+                </configuration>
+            </plugin>
+        </plugins>
+    </build>
+
+    <dependencies>
+        <!-- todo: confirm the scala incompatbility is with datasonnet -->
+        <dependency>
+            <groupId>org.scala-lang</groupId>
+            <artifactId>scala-library</artifactId>
+            <version>2.13.3</version>
+        </dependency>
+        <!-- apparently scala compiler needs this -->
+        <dependency>
+            <groupId>org.hamcrest</groupId>
+            <artifactId>hamcrest</artifactId>
+            <version>2.2</version>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.apache.camel</groupId>
+            <artifactId>camel-support</artifactId>
+        </dependency>
+        <dependency>
+            <groupId>com.datasonnet</groupId>
+            <artifactId>datasonnet-mapper</artifactId>
+            <version>0.6.0-MS3</version>
+        </dependency>
+        <dependency>
+            <groupId>commons-io</groupId>
+            <artifactId>commons-io</artifactId>
+            <version>2.4</version>
+        </dependency>
+        <dependency>
+            <groupId>io.github.classgraph</groupId>
+            <artifactId>classgraph</artifactId>
+            <version>4.8.52</version>
+        </dependency>
+
+        <!-- testing -->
+        <dependency>
+            <groupId>org.apache.camel</groupId>
+            <artifactId>camel-test-spring-junit5</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.apache.logging.log4j</groupId>
+            <artifactId>log4j-slf4j-impl</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.junit.jupiter</groupId>
+            <artifactId>junit-jupiter</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.skyscreamer</groupId>
+            <artifactId>jsonassert</artifactId>
+            <version>1.5.0</version>","[{'comment': 'ditto', 'commenter': 'oscerd'}]"
4561,components/camel-datasonnet/pom.xml,"@@ -0,0 +1,142 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one or more
+    contributor license agreements.  See the NOTICE file distributed with
+    this work for additional information regarding copyright ownership.
+    The ASF licenses this file to You under the Apache License, Version 2.0
+    (the ""License""); you may not use this file except in compliance with
+    the License.  You may obtain a copy of the License at
+
+         http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an ""AS IS"" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+
+-->
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"">
+    <modelVersion>4.0.0</modelVersion>
+
+    <parent>
+        <groupId>org.apache.camel</groupId>
+        <artifactId>components</artifactId>
+        <version>3.7.0-SNAPSHOT</version>
+    </parent>
+
+    <artifactId>camel-datasonnet</artifactId>
+    <packaging>jar</packaging>
+
+    <name>Camel :: DataSonnet</name>
+    <description>Camel DataSonnet support</description>
+
+    <properties>
+        <maven.compiler.source>1.8</maven.compiler.source>
+        <maven.compiler.target>1.8</maven.compiler.target>
+    </properties>
+
+    <build>
+        <plugins>
+            <plugin>
+                <groupId>net.alchim31.maven</groupId>
+                <artifactId>scala-maven-plugin</artifactId>
+                <executions>
+                    <execution>
+                        <id>scala-compile-first</id>
+                        <phase>process-resources</phase>
+                        <goals>
+                            <goal>add-source</goal>
+                            <goal>compile</goal>
+                        </goals>
+                    </execution>
+                    <execution>
+                        <id>scala-test-compile</id>
+                        <phase>process-test-resources</phase>
+                        <goals>
+                            <goal>testCompile</goal>
+                        </goals>
+                    </execution>
+                </executions>
+            </plugin>
+            <plugin>
+                <groupId>org.apache.maven.plugins</groupId>
+                <artifactId>maven-surefire-plugin</artifactId>
+                <configuration>
+                    <additionalClasspathElements>
+                        <additionalClasspathElement>${project.basedir}/src/test/resources/dslibs.jar</additionalClasspathElement>
+                    </additionalClasspathElements>
+                </configuration>
+            </plugin>
+        </plugins>
+    </build>
+
+    <dependencies>
+        <!-- todo: confirm the scala incompatbility is with datasonnet -->
+        <dependency>
+            <groupId>org.scala-lang</groupId>
+            <artifactId>scala-library</artifactId>
+            <version>2.13.3</version>
+        </dependency>
+        <!-- apparently scala compiler needs this -->
+        <dependency>
+            <groupId>org.hamcrest</groupId>
+            <artifactId>hamcrest</artifactId>
+            <version>2.2</version>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.apache.camel</groupId>
+            <artifactId>camel-support</artifactId>
+        </dependency>
+        <dependency>
+            <groupId>com.datasonnet</groupId>
+            <artifactId>datasonnet-mapper</artifactId>
+            <version>0.6.0-MS3</version>
+        </dependency>
+        <dependency>
+            <groupId>commons-io</groupId>
+            <artifactId>commons-io</artifactId>
+            <version>2.4</version>
+        </dependency>
+        <dependency>
+            <groupId>io.github.classgraph</groupId>
+            <artifactId>classgraph</artifactId>
+            <version>4.8.52</version>
+        </dependency>
+
+        <!-- testing -->
+        <dependency>
+            <groupId>org.apache.camel</groupId>
+            <artifactId>camel-test-spring-junit5</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.apache.logging.log4j</groupId>
+            <artifactId>log4j-slf4j-impl</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.junit.jupiter</groupId>
+            <artifactId>junit-jupiter</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.skyscreamer</groupId>
+            <artifactId>jsonassert</artifactId>
+            <version>1.5.0</version>
+            <scope>test</scope>
+        </dependency>
+    </dependencies>
+
+    <repositories>
+        <repository>
+            <id>ms3-nexus</id>","[{'comment': 'We essentially avoid external repository for multiple reasons: our experience with 3rd parties repository was really bad, so if possible please release in maven central.', 'commenter': 'oscerd'}]"
4561,components/camel-datasonnet/src/main/java/org/apache/camel/language/datasonnet/Datasonnet.java,"@@ -0,0 +1,20 @@
+package org.apache.camel.language.datasonnet;","[{'comment': 'Add ASF license please', 'commenter': 'oscerd'}]"
4561,components/camel-datasonnet/src/main/java/org/apache/camel/language/datasonnet/Datasonnet.java,"@@ -0,0 +1,20 @@
+package org.apache.camel.language.datasonnet;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+import org.apache.camel.support.language.LanguageAnnotation;
+
+/**
+ * Datasonnet TODO: 7/21/20 docs","[{'comment': 'remove TODO', 'commenter': 'oscerd'}]"
4561,components/camel-datasonnet/src/main/java/org/apache/camel/language/datasonnet/DatasonnetConstants.java,"@@ -0,0 +1,6 @@
+package org.apache.camel.language.datasonnet;","[{'comment': 'Add ASF license please', 'commenter': 'oscerd'}]"
4561,components/camel-datasonnet/src/main/java/org/apache/camel/language/datasonnet/DatasonnetExpression.java,"@@ -0,0 +1,240 @@
+package org.apache.camel.language.datasonnet;","[{'comment': 'Add ASF license please', 'commenter': 'oscerd'}]"
4561,components/camel-datasonnet/src/main/java/org/apache/camel/language/datasonnet/DatasonnetExpression.java,"@@ -0,0 +1,240 @@
+package org.apache.camel.language.datasonnet;
+
+import java.io.File;
+import java.io.IOException;
+import java.nio.charset.StandardCharsets;
+import java.nio.file.FileVisitResult;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.SimpleFileVisitor;
+import java.nio.file.attribute.BasicFileAttributes;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Objects;
+
+import com.datasonnet.Mapper;
+import com.datasonnet.MapperBuilder;
+import com.datasonnet.document.DefaultDocument;
+import com.datasonnet.document.Document;
+import com.datasonnet.document.MediaType;
+import com.datasonnet.document.MediaTypes;
+import io.github.classgraph.ClassGraph;
+import io.github.classgraph.ScanResult;
+import org.apache.camel.Exchange;
+import org.apache.camel.Expression;
+import org.apache.camel.RuntimeExpressionException;
+import org.apache.camel.spi.ExpressionResultTypeAware;
+import org.apache.camel.support.ExchangeHelper;
+import org.apache.camel.support.ExpressionAdapter;
+import org.apache.camel.support.MessageHelper;
+import org.apache.commons.io.IOUtils;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class DatasonnetExpression extends ExpressionAdapter implements ExpressionResultTypeAware {
+    private static final Logger LOGGER = LoggerFactory.getLogger(DatasonnetExpression.class);
+    private static final Map<String, String> CLASSPATH_IMPORTS = new HashMap<>();
+
+    static {
+        LOGGER.debug(""One time classpath search..."");
+        try (ScanResult scanResult = new ClassGraph().whitelistPaths(""/"").scan()) {
+            scanResult.getResourcesWithExtension(""libsonnet"")
+                    .forEachByteArray((resource, bytes) -> {
+                        LOGGER.debug(""Loading DataSonnet library: "" + resource.getPath());
+                        CLASSPATH_IMPORTS.put(resource.getPath(), new String(bytes, StandardCharsets.UTF_8));
+                    });
+        }
+    }
+
+    private String expression;
+    private Expression metaExpression;
+    private MediaType bodyMediaType;
+    private MediaType outputMediaType;
+    private Class<?> resultType;
+    private Collection<String> libraryPaths;
+
+    public DatasonnetExpression(String expression) {
+        this.expression = expression;
+    }
+
+    public DatasonnetExpression(Expression expression) {
+        this.metaExpression = expression;
+    }
+
+    @Override
+    public boolean matches(Exchange exchange) {
+        this.outputMediaType = MediaTypes.APPLICATION_JAVA;
+        return evaluate(exchange, Boolean.class);
+    }
+
+    @SuppressWarnings(""unchecked"")
+    @Override
+    public <T> T evaluate(Exchange exchange, Class<T> type) {
+        try {
+            if (metaExpression != null) {
+                expression = metaExpression.evaluate(exchange, String.class);
+            }
+
+            Objects.requireNonNull(expression, ""String expression property must be set!"");
+
+            Document<?> result = doEvaluate(exchange);
+            // TODO: 9/8/20 see if we can offload some of this to a Document specific custom type converter","[{'comment': 'Remove TODO', 'commenter': 'oscerd'}]"
4561,components/camel-datasonnet/src/main/java/org/apache/camel/language/datasonnet/DatasonnetLanguage.java,"@@ -0,0 +1,130 @@
+package org.apache.camel.language.datasonnet;","[{'comment': 'Add ASF license please', 'commenter': 'oscerd'}]"
4561,components/camel-datasonnet/src/main/scala/org/apache/camel/language/datasonnet/CML.scala,"@@ -0,0 +1,58 @@
+package org.apache.camel.language.datasonnet","[{'comment': 'Add ASF license please', 'commenter': 'oscerd'}]"
4561,components/camel-datasonnet/src/test/java/org/apache/camel/language/datasonnet/CamelDatasonnetTest.java,"@@ -0,0 +1,141 @@
+package org.apache.camel.language.datasonnet;","[{'comment': 'Add ASF license please', 'commenter': 'oscerd'}]"
4561,components/camel-datasonnet/src/test/java/org/apache/camel/language/datasonnet/ExpressionsInJavaTest.java,"@@ -0,0 +1,64 @@
+package org.apache.camel.language.datasonnet;","[{'comment': 'Add ASF license please', 'commenter': 'oscerd'}]"
4561,components/camel-datasonnet/src/test/java/org/apache/camel/language/datasonnet/Gizmo.java,"@@ -0,0 +1,94 @@
+package org.apache.camel.language.datasonnet;","[{'comment': 'Add ASF license please', 'commenter': 'oscerd'}]"
4561,components/camel-datasonnet/src/test/java/org/apache/camel/language/datasonnet/Manufacturer.java,"@@ -0,0 +1,48 @@
+package org.apache.camel.language.datasonnet;","[{'comment': 'Add ASF license please', 'commenter': 'oscerd'}]"
4561,components/camel-datasonnet/src/test/java/org/apache/camel/language/datasonnet/PropertiesTest.java,"@@ -0,0 +1,36 @@
+package org.apache.camel.language.datasonnet;","[{'comment': 'Add ASF license please', 'commenter': 'oscerd'}]"
4561,components/camel-datasonnet/src/test/resources/javaTest.json,"@@ -0,0 +1,15 @@
+{","[{'comment': 'I guess a license should be good here to', 'commenter': 'oscerd'}]"
4561,components/camel-datasonnet/src/test/resources/namedImports.ds,"@@ -0,0 +1,11 @@
+local testlib1 = import 'testlib.libsonnet';","[{'comment': 'Add ASF license please', 'commenter': 'oscerd'}]"
4561,components/camel-datasonnet/src/test/resources/namedImportsFS.ds,"@@ -0,0 +1,7 @@
+local testlib3 = import 'testlib3.libsonnet';","[{'comment': 'Add ASF license please', 'commenter': 'oscerd'}]"
4561,components/camel-datasonnet/src/test/resources/namedImports_result.json,"@@ -0,0 +1 @@
+{""Lib1JAR"":""Hello, World"",""Lib2JAR"":""Bye, World"",""Lib3FS"":""Hello, World : TestLib3"",""Lib4FS"":""Bye, World : TestLib4""}","[{'comment': 'Add ASF license please', 'commenter': 'oscerd'}]"
4561,components/camel-datasonnet/src/test/resources/org/apache/camel/language.datasonnet/camel-context.xml,"@@ -0,0 +1,155 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>","[{'comment': 'Add ASF license please', 'commenter': 'oscerd'}]"
4561,components/camel-datasonnet/src/test/resources/payload.csv,"@@ -0,0 +1,2 @@
+account,firstName,lastName","[{'comment': 'Add ASF license please', 'commenter': 'oscerd'}]"
4561,components/camel-datasonnet/src/test/resources/payload.xml,"@@ -0,0 +1,4 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>","[{'comment': 'Add ASF license please', 'commenter': 'oscerd'}]"
4561,components/camel-datasonnet/src/test/resources/readCSVTest.ds,"@@ -0,0 +1,3 @@
+{","[{'comment': 'Add ASF license please', 'commenter': 'oscerd'}]"
4561,components/camel-datasonnet/src/test/resources/readJavaTest.ds,"@@ -0,0 +1,12 @@
+/** DataSonnet","[{'comment': 'Add ASF license please', 'commenter': 'oscerd'}]"
4561,components/camel-datasonnet/src/test/resources/readXMLExtTest.ds,"@@ -0,0 +1,6 @@
+/** DataSonnet","[{'comment': 'Add ASF license please', 'commenter': 'oscerd'}]"
4614,tooling/maven/camel-restdsl-openapi-plugin/pom.xml,"@@ -55,6 +55,11 @@
             <artifactId>snakeyaml</artifactId>
             <version>${snakeyaml-version}</version>
         </dependency>
+        <dependency>
+            <groupId>org.openapitools</groupId>
+            <artifactId>openapi-generator</artifactId>
+            <version>4.3.1</version>","[{'comment': 'This can be a placeholder for property version in parent/pom', 'commenter': 'oscerd'}, {'comment': 'Hi. Thanks for the input. Would you like the according property in the maven-plugins pom or in another, e.g. tooling-parent pom?', 'commenter': 'ex324'}, {'comment': 'Morning. I meant here: https://github.com/apache/camel/blob/master/parent/pom.xml', 'commenter': 'oscerd'}, {'comment': 'Thanks', 'commenter': 'oscerd'}]"
4614,tooling/maven/camel-restdsl-openapi-plugin/src/main/java/org/apache/camel/maven/generator/openapi/AbstractGenerateMojo.java,"@@ -33,6 +40,7 @@
 import com.fasterxml.jackson.databind.ObjectMapper;
 import io.apicurio.datamodels.Library;
 import io.apicurio.datamodels.openapi.models.OasDocument;
+import io.swagger.v3.parser.core.models.AuthorizationValue;","[{'comment': 'Can we avoid swagger imports, as we should ideally only use the datamodel from apicurio.', 'commenter': 'davsclaus'}, {'comment': 'I removed the openapi / swagger dependencies...', 'commenter': 'ex324'}]"
4630,components/camel-salesforce/camel-salesforce-component/src/main/java/org/apache/camel/component/salesforce/api/dto/SearchResult2.java,"@@ -0,0 +1,27 @@
+package org.apache.camel.component.salesforce.api.dto;","[{'comment': 'Please add license', 'commenter': 'oscerd'}]"
4630,components/camel-salesforce/camel-salesforce-component/src/main/java/org/apache/camel/component/salesforce/internal/processor/JsonRestProcessor.java,"@@ -100,7 +101,11 @@ protected void processRequest(Exchange exchange) throws SalesforceException {
 
             case SEARCH:
                 // handle known response type
-                exchange.setProperty(RESPONSE_TYPE, TypeReferences.SEARCH_RESULT_TYPE);
+                if (Double.parseDouble(endpoint.getConfiguration().getApiVersion()) >= 37.0) {","[{'comment': 'can we somewhat move the version `37.0` number into a constant?', 'commenter': 'omarsmak'}, {'comment': ""I considered that, but couldn't think of a good name. There's no concept that symbolizes any given version. Open to suggestions."", 'commenter': 'jeremyross'}, {'comment': 'True, another option is, we can create a common function in the `AbstractRestProcessor` that sets response type property for `Json` and `XML`, e.g:\r\n```\r\nprotected void setSearchResponseType(Object fallbackType) {\r\nif (Double.parseDouble(endpoint.getConfiguration().getApiVersion()) >= 37.0) {\r\n       exchange.setProperty(RESPONSE_TYPE, SearchResult2.class);\r\n} else {\r\n       exchange.setProperty(RESPONSE_TYPE, fallbackType);\r\n     }\r\n}\r\n```\r\n\r\nAnd then called either `setSearchResponseType(TypeReferences.SEARCH_RESULT_TYPE)` or `setSearchResponseType(SearchResults.class)`. WDYT?\r\n', 'commenter': 'omarsmak'}, {'comment': ""Hmm. JsonRestProcessor sets the RESPONSE_TYPE property, whereas XmlRestProcessor sets the RESPONSE_CLASS property. And for  < 37.0, the type is different. I'm struggling to find enough in common to extract."", 'commenter': 'jeremyross'}, {'comment': ""But I'm glad you asked this, because I now realize that JsonRestProcessor should be using RESPONSE_CLASS for SearchResult2. "", 'commenter': 'jeremyross'}, {'comment': ""ah sorry didn't realize that, you are right, only the version need to be extracted. Anyway, if you can't find a some meaningful naming, is also fine like this as long not much of duplications happening, just wanted to avoid the magic number ;)"", 'commenter': 'omarsmak'}, {'comment': 'I know, it bothers me too. But I think `public static final String API_VERSION_37_0 = ""37.0"";` would bother me more. It brings nothing to the party, ya know?', 'commenter': 'jeremyross'}, {'comment': 'yeah I know, is fine then ', 'commenter': 'omarsmak'}]"
4638,components/camel-milo/src/main/java/org/apache/camel/component/milo/server/internal/CamelServerItem.java,"@@ -55,7 +55,7 @@ public CamelServerItem(final String itemId, final UaNodeContext nodeContext, fin
         this.itemId = itemId;
         this.baseNode = baseNode;
 
-        final NodeId nodeId = new NodeId(namespaceIndex, ""items-"" + itemId);
+        final NodeId nodeId = new NodeId(namespaceIndex, """" + itemId);","[{'comment': 'I think you can remove the empty string concatenation.', 'commenter': 'oscerd'}, {'comment': 'yes, of course. it is done.', 'commenter': 'schernolyas'}]"
4643,components/camel-graphql/src/main/java/org/apache/camel/component/graphql/GraphqlEndpoint.java,"@@ -187,6 +193,18 @@ public String getQuery() {
         return query;
     }
 
+    /**
+     * The JWT Authorization type. Default is Bearer.
+     * @param jwtAuthorizationType","[{'comment': 'Please remove param annotation.', 'commenter': 'oscerd'}, {'comment': 'Removed', 'commenter': 'tapiiron'}]"
4643,components/camel-graphql/src/main/java/org/apache/camel/component/graphql/GraphqlEndpoint.java,"@@ -110,8 +112,12 @@ private CloseableHttpClient createHttpClient() {
             httpClientBuilder.setProxy(new HttpHost(hostname, port));
         }
         if (accessToken != null) {
+            String authType = ""Bearer"";
+            if(this.jwtAuthorizationType != null) {","[{'comment': 'If you run a full build, this should be formatted to respect the camel code style standards.', 'commenter': 'oscerd'}, {'comment': 'That missed my eye but should be fixed now', 'commenter': 'tapiiron'}]"
4643,components/camel-graphql/src/main/java/org/apache/camel/component/graphql/GraphqlEndpoint.java,"@@ -65,6 +65,8 @@
     @UriParam(label = ""security"", secret = true)
     private String password;
     @UriParam
+    private String jwtAuthorizationType;","[{'comment': 'Can you set label = ""security"", and default = ""Bearer"" in the uri param annotation', 'commenter': 'davsclaus'}, {'comment': 'Sure thing, added those now', 'commenter': 'tapiiron'}]"
4684,components/camel-opentelemetry/pom.xml,"@@ -80,7 +75,7 @@
     </dependency>
     <dependency>
       <groupId>io.opentelemetry</groupId>
-      <artifactId>opentelemetry-exporters-inmemory</artifactId>
+      <artifactId>opentelemetry-sdk-testing</artifactId>","[{'comment': 'Is this a test scope dependency?', 'commenter': 'oscerd'}, {'comment': 'Yes.', 'commenter': 'rubenvp8510'}, {'comment': 'It makes sense to add scope test then', 'commenter': 'oscerd'}]"
4694,components/camel-hazelcast/src/main/java/org/apache/camel/component/hazelcast/list/HazelcastListConsumer.java,"@@ -16,25 +16,51 @@
  */
 package org.apache.camel.component.hazelcast.list;
 
-import com.hazelcast.collection.IList;
-import com.hazelcast.core.HazelcastInstance;
+import java.util.UUID;
+
 import org.apache.camel.Consumer;
 import org.apache.camel.Endpoint;
 import org.apache.camel.Processor;
 import org.apache.camel.component.hazelcast.HazelcastDefaultConsumer;
 import org.apache.camel.component.hazelcast.listener.CamelItemListener;
 
+import com.hazelcast.collection.IList;","[{'comment': ""I think this will make the camel codestyle fails, but it's not a problem"", 'commenter': 'oscerd'}, {'comment': 'I updated the import order', 'commenter': 'scriptease'}]"
4697,components/camel-azure-storage-datalake/pom.xml,"@@ -0,0 +1,89 @@
+<?xml version=""1.0"" encoding=""UTF-8"" ?>
+<!--
+    Licensed to the Apache Software Foundation (ASF) under one or more
+    contributor license agreements.  See the NOTICE file distributed with
+    this work for additional information regarding copyright ownership.
+    The ASF licenses this file to You under the Apache License, Version 2.0
+    (the ""License""); you may not use this file except in compliance with
+    the License.  You may obtain a copy of the License at
+         http://www.apache.org/licenses/LICENSE-2.0
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an ""AS IS"" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
+    xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+    <modelVersion>4.0.0</modelVersion>
+
+    <parent>
+        <groupId>org.apache.camel</groupId>
+        <artifactId>components</artifactId>
+        <version>3.7.0-SNAPSHOT</version>
+    </parent>
+
+    <artifactId>camel-azure-storage-datalake</artifactId>
+    <packaging>jar</packaging>
+
+    <name>Camel :: Azure Datalake Gen2</name>
+    <description>Camel Azure Datalake Gen2 Component</description>
+
+    <dependencies>
+        <dependency>
+            <groupId>org.apache.camel</groupId>
+            <artifactId>camel-support</artifactId>
+        </dependency>
+        
+        <dependency>
+            <groupId>com.azure</groupId>
+            <artifactId>azure-storage-file-datalake</artifactId>
+            <version>12.2.0</version>","[{'comment': 'This needs to be a property placeholder in parent/pom', 'commenter': 'oscerd'}]"
4697,components/camel-azure-storage-datalake/pom.xml,"@@ -0,0 +1,89 @@
+<?xml version=""1.0"" encoding=""UTF-8"" ?>
+<!--
+    Licensed to the Apache Software Foundation (ASF) under one or more
+    contributor license agreements.  See the NOTICE file distributed with
+    this work for additional information regarding copyright ownership.
+    The ASF licenses this file to You under the Apache License, Version 2.0
+    (the ""License""); you may not use this file except in compliance with
+    the License.  You may obtain a copy of the License at
+         http://www.apache.org/licenses/LICENSE-2.0
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an ""AS IS"" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
+    xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+    <modelVersion>4.0.0</modelVersion>
+
+    <parent>
+        <groupId>org.apache.camel</groupId>
+        <artifactId>components</artifactId>
+        <version>3.7.0-SNAPSHOT</version>
+    </parent>
+
+    <artifactId>camel-azure-storage-datalake</artifactId>
+    <packaging>jar</packaging>
+
+    <name>Camel :: Azure Datalake Gen2</name>
+    <description>Camel Azure Datalake Gen2 Component</description>
+
+    <dependencies>
+        <dependency>
+            <groupId>org.apache.camel</groupId>
+            <artifactId>camel-support</artifactId>
+        </dependency>
+        
+        <dependency>
+            <groupId>com.azure</groupId>
+            <artifactId>azure-storage-file-datalake</artifactId>
+            <version>12.2.0</version>
+        </dependency>
+        <dependency>
+            <groupId>com.azure</groupId>
+            <artifactId>azure-identity</artifactId>
+            <version>1.1.3</version>","[{'comment': 'Same', 'commenter': 'oscerd'}]"
4697,components/camel-azure-storage-datalake/src/main/java/org/apache/camel/component/azure/storage/datalake/DataLakeComponent.java,"@@ -0,0 +1,126 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.azure.storage.datalake;
+
+import java.util.Map;
+import java.util.Set;
+
+import com.azure.identity.ClientSecretCredential;
+import com.azure.storage.common.StorageSharedKeyCredential;
+import com.azure.storage.file.datalake.DataLakeServiceClient;
+import org.apache.camel.CamelContext;
+import org.apache.camel.Endpoint;
+import org.apache.camel.spi.Metadata;
+import org.apache.camel.spi.annotations.Component;
+import org.apache.camel.support.DefaultComponent;
+import org.apache.camel.util.ObjectHelper;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+@Component(""azure-storage-datalake"")
+public class DataLakeComponent extends DefaultComponent {
+
+    private static final Logger LOG = LoggerFactory.getLogger(DataLakeComponent.class);
+
+    @Metadata(description = ""configuration object for datalake"")
+    private DataLakeConfiguration configuration = new DataLakeConfiguration();
+
+    public DataLakeComponent() {
+    }
+
+    public DataLakeComponent(final CamelContext camelContext) {
+        super(camelContext);
+    }
+
+    @Override
+    protected Endpoint createEndpoint(String uri, String remaining, Map<String, Object> parameters) throws Exception {
+
+        if (remaining == null || remaining.trim().isEmpty()) {
+            throw new IllegalArgumentException(""At least the account name must be specified"");
+        }
+
+        final DataLakeConfiguration configuration;
+        if (this.configuration != null) {
+            configuration = this.configuration.copy();
+        } else {
+            configuration = new DataLakeConfiguration();
+        }
+
+        final String[] details = remaining.split(""/"");
+
+        configuration.setAccountName(details[0]);
+
+        if (details.length > 1) {
+            configuration.setFileSystemName(details[1]);
+        }
+
+        final DataLakeEndpoint endpoint = new DataLakeEndpoint(uri, this, configuration);
+        setProperties(endpoint, parameters);
+        setClientFromRegistry(configuration);
+
+        setCredentialsFromRegistry(configuration);
+        validateConfiguration(configuration);
+
+        return endpoint;
+    }
+
+    public DataLakeConfiguration getConfiguration() {
+        return configuration;
+    }
+
+    public void setConfiguration(DataLakeConfiguration configuration) {
+        this.configuration = configuration;
+    }
+
+    private void setCredentialsFromRegistry(final DataLakeConfiguration configuration) {
+        final DataLakeServiceClient client = configuration.getServiceClient();
+
+        if (client == null) {
+            Set<StorageSharedKeyCredential> storageSharedKeyCredentials
+                    = getCamelContext().getRegistry().findByType(StorageSharedKeyCredential.class);
+            Set<ClientSecretCredential> clientSecretCredentials
+                    = getCamelContext().getRegistry().findByType(ClientSecretCredential.class);
+
+            if (storageSharedKeyCredentials.size() == 1) {
+                configuration.setSharedKeyCredential(storageSharedKeyCredentials.stream().findFirst().get());
+            }
+
+            if (clientSecretCredentials.size() == 1) {
+                configuration.setClientSecretCredential(clientSecretCredentials.stream().findFirst().get());
+            }
+
+        }
+    }
+
+    private void setClientFromRegistry(final DataLakeConfiguration configuration) {
+        if (ObjectHelper.isEmpty(configuration.getServiceClient())) {
+            final Set<DataLakeServiceClient> clients = getCamelContext().getRegistry().findByType(DataLakeServiceClient.class);
+
+            if (clients.size() == 1) {
+                configuration.setServiceClient(clients.stream().findFirst().get());
+            }
+
+        }
+    }
+
+    private void validateConfiguration(final DataLakeConfiguration config) {
+        if (config.getServiceClient() == null && config.getClientSecretCredential() == null) {
+            throw new IllegalArgumentException(""cliet or credentials must be specified"");","[{'comment': 'typo here', 'commenter': 'omarsmak'}]"
4697,components/camel-azure-storage-datalake/src/main/java/org/apache/camel/component/azure/storage/datalake/DataLakeComponent.java,"@@ -0,0 +1,126 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.azure.storage.datalake;
+
+import java.util.Map;
+import java.util.Set;
+
+import com.azure.identity.ClientSecretCredential;
+import com.azure.storage.common.StorageSharedKeyCredential;
+import com.azure.storage.file.datalake.DataLakeServiceClient;
+import org.apache.camel.CamelContext;
+import org.apache.camel.Endpoint;
+import org.apache.camel.spi.Metadata;
+import org.apache.camel.spi.annotations.Component;
+import org.apache.camel.support.DefaultComponent;
+import org.apache.camel.util.ObjectHelper;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+@Component(""azure-storage-datalake"")
+public class DataLakeComponent extends DefaultComponent {
+
+    private static final Logger LOG = LoggerFactory.getLogger(DataLakeComponent.class);
+
+    @Metadata(description = ""configuration object for datalake"")
+    private DataLakeConfiguration configuration = new DataLakeConfiguration();
+
+    public DataLakeComponent() {
+    }
+
+    public DataLakeComponent(final CamelContext camelContext) {
+        super(camelContext);
+    }
+
+    @Override
+    protected Endpoint createEndpoint(String uri, String remaining, Map<String, Object> parameters) throws Exception {
+
+        if (remaining == null || remaining.trim().isEmpty()) {
+            throw new IllegalArgumentException(""At least the account name must be specified"");
+        }
+
+        final DataLakeConfiguration configuration;
+        if (this.configuration != null) {
+            configuration = this.configuration.copy();
+        } else {
+            configuration = new DataLakeConfiguration();
+        }
+
+        final String[] details = remaining.split(""/"");
+
+        configuration.setAccountName(details[0]);
+
+        if (details.length > 1) {
+            configuration.setFileSystemName(details[1]);
+        }
+
+        final DataLakeEndpoint endpoint = new DataLakeEndpoint(uri, this, configuration);
+        setProperties(endpoint, parameters);
+        setClientFromRegistry(configuration);
+
+        setCredentialsFromRegistry(configuration);
+        validateConfiguration(configuration);
+
+        return endpoint;
+    }
+
+    public DataLakeConfiguration getConfiguration() {
+        return configuration;
+    }
+
+    public void setConfiguration(DataLakeConfiguration configuration) {
+        this.configuration = configuration;
+    }
+
+    private void setCredentialsFromRegistry(final DataLakeConfiguration configuration) {
+        final DataLakeServiceClient client = configuration.getServiceClient();
+
+        if (client == null) {
+            Set<StorageSharedKeyCredential> storageSharedKeyCredentials
+                    = getCamelContext().getRegistry().findByType(StorageSharedKeyCredential.class);
+            Set<ClientSecretCredential> clientSecretCredentials
+                    = getCamelContext().getRegistry().findByType(ClientSecretCredential.class);
+
+            if (storageSharedKeyCredentials.size() == 1) {
+                configuration.setSharedKeyCredential(storageSharedKeyCredentials.stream().findFirst().get());
+            }
+
+            if (clientSecretCredentials.size() == 1) {
+                configuration.setClientSecretCredential(clientSecretCredentials.stream().findFirst().get());
+            }
+
+        }
+    }
+
+    private void setClientFromRegistry(final DataLakeConfiguration configuration) {","[{'comment': 'Actually we no longer need this, we can now autowire the client by adding `@Metadata(autowired = true)` to the serviceClient configuration and remove this. An example [here](https://github.com/apache/camel/commit/bc8fa176a66bfab4b5385305c626fddc01d29c2b#diff-fa0be9a42d8b24af5d483c6e806968d302c829087bcf363ce5fc2e67559ca863)', 'commenter': 'omarsmak'}]"
4697,components/camel-azure-storage-datalake/src/main/java/org/apache/camel/component/azure/storage/datalake/DataLakeEndpoint.java,"@@ -0,0 +1,97 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.azure.storage.datalake;
+
+import com.azure.storage.file.datalake.DataLakeServiceClient;
+import org.apache.camel.Category;
+import org.apache.camel.Component;
+import org.apache.camel.Consumer;
+import org.apache.camel.Exchange;
+import org.apache.camel.Message;
+import org.apache.camel.Processor;
+import org.apache.camel.Producer;
+import org.apache.camel.component.azure.storage.datalake.client.DataLakeClientFactory;
+import org.apache.camel.component.azure.storage.datalake.operations.DataLakeOperationResponse;
+import org.apache.camel.spi.UriEndpoint;
+import org.apache.camel.spi.UriParam;
+import org.apache.camel.support.DefaultEndpoint;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+@UriEndpoint(firstVersion = ""3.5.0"", scheme = ""azure-storage-datalake"", title = ""Azure storage datalake service"",","[{'comment': 'the first version should be 3.7.0', 'commenter': 'omarsmak'}]"
4697,components/camel-azure-storage-datalake/src/main/java/org/apache/camel/component/azure/storage/datalake/operations/DataLakeDirectoryOperations.java,"@@ -0,0 +1,33 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.azure.storage.datalake.operations;
+
+import org.apache.camel.component.azure.storage.datalake.DataLakeConfiguration;
+import org.apache.camel.component.azure.storage.datalake.DataLakeConfigurationOptionsProxy;
+import org.apache.camel.component.azure.storage.datalake.client.DataLakeDirectoryClientWrapper;
+import org.apache.camel.util.ObjectHelper;
+
+public class DataLakeDirectoryOperations {","[{'comment': 'Is there any good use for this class?', 'commenter': 'omarsmak'}, {'comment': 'So, there are some operations on directory as well in datalake gen2. I am gonna add those in here.', 'commenter': 'aryankoul'}]"
4697,components/camel-azure-storage-datalake/src/main/java/org/apache/camel/component/azure/storage/datalake/DataLakeEndpoint.java,"@@ -0,0 +1,97 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.azure.storage.datalake;
+
+import com.azure.storage.file.datalake.DataLakeServiceClient;
+import org.apache.camel.Category;
+import org.apache.camel.Component;
+import org.apache.camel.Consumer;
+import org.apache.camel.Exchange;
+import org.apache.camel.Message;
+import org.apache.camel.Processor;
+import org.apache.camel.Producer;
+import org.apache.camel.component.azure.storage.datalake.client.DataLakeClientFactory;
+import org.apache.camel.component.azure.storage.datalake.operations.DataLakeOperationResponse;
+import org.apache.camel.spi.UriEndpoint;
+import org.apache.camel.spi.UriParam;
+import org.apache.camel.support.DefaultEndpoint;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+@UriEndpoint(firstVersion = ""3.7.0"", scheme = ""azure-storage-datalake"", title = ""Azure storage datalake service"",","[{'comment': 'is `3.8.0`.', 'commenter': 'omarsmak'}]"
4697,components/camel-azure-storage-datalake/src/main/java/org/apache/camel/component/azure/storage/datalake/DataLakeEndpoint.java,"@@ -0,0 +1,97 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.azure.storage.datalake;
+
+import com.azure.storage.file.datalake.DataLakeServiceClient;
+import org.apache.camel.Category;
+import org.apache.camel.Component;
+import org.apache.camel.Consumer;
+import org.apache.camel.Exchange;
+import org.apache.camel.Message;
+import org.apache.camel.Processor;
+import org.apache.camel.Producer;
+import org.apache.camel.component.azure.storage.datalake.client.DataLakeClientFactory;
+import org.apache.camel.component.azure.storage.datalake.operations.DataLakeOperationResponse;
+import org.apache.camel.spi.UriEndpoint;
+import org.apache.camel.spi.UriParam;
+import org.apache.camel.support.DefaultEndpoint;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+@UriEndpoint(firstVersion = ""3.7.0"", scheme = ""azure-storage-datalake"", title = ""Azure storage datalake service"",
+             syntax = ""azure-storage-datalake:accounName/fileSystemName"", category = { Category.CLOUD, Category.FILE })","[{'comment': 'typo `accountName`', 'commenter': 'omarsmak'}]"
4697,components/camel-azure-storage-datalake/src/main/java/org/apache/camel/component/azure/storage/datalake/DataLakeEndpoint.java,"@@ -0,0 +1,97 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.azure.storage.datalake;
+
+import com.azure.storage.file.datalake.DataLakeServiceClient;
+import org.apache.camel.Category;
+import org.apache.camel.Component;
+import org.apache.camel.Consumer;
+import org.apache.camel.Exchange;
+import org.apache.camel.Message;
+import org.apache.camel.Processor;
+import org.apache.camel.Producer;
+import org.apache.camel.component.azure.storage.datalake.client.DataLakeClientFactory;
+import org.apache.camel.component.azure.storage.datalake.operations.DataLakeOperationResponse;
+import org.apache.camel.spi.UriEndpoint;
+import org.apache.camel.spi.UriParam;
+import org.apache.camel.support.DefaultEndpoint;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+@UriEndpoint(firstVersion = ""3.7.0"", scheme = ""azure-storage-datalake"", title = ""Azure storage datalake service"",
+             syntax = ""azure-storage-datalake:accounName/fileSystemName"", category = { Category.CLOUD, Category.FILE })
+public class DataLakeEndpoint extends DefaultEndpoint {
+    private static final Logger LOG = LoggerFactory.getLogger(DataLakeEndpoint.class);
+
+    @UriParam(description = ""service client of datalake"")
+    private DataLakeServiceClient dataLakeServiceClient;
+
+    @UriParam(description = ""configuration object of azure datalake"")
+    private DataLakeConfiguration configuration;
+
+    public DataLakeEndpoint() {
+    }
+
+    public DataLakeEndpoint(final String uri, final Component component, final DataLakeConfiguration configuration) {
+        super(uri, component);
+        this.configuration = configuration;
+    }
+
+    @Override
+    public Producer createProducer() throws Exception {
+        return new DataLakeProducer(this);
+    }
+
+    @Override
+    public Consumer createConsumer(Processor processor) throws Exception {
+        return new DataLakeConsumer(this, processor);
+    }
+
+    public DataLakeConfiguration getConfiguration() {
+        return configuration;
+    }
+
+    public void setConfiguration(DataLakeConfiguration configuration) {
+        this.configuration = configuration;
+    }
+
+    public DataLakeServiceClient getDataLakeServiceClient() {
+        return dataLakeServiceClient;
+    }
+
+    public void setDataLakeServiceClient(DataLakeServiceClient dataLakeServiceClient) {
+        this.dataLakeServiceClient = dataLakeServiceClient;
+    }
+
+    public void setResponseOnExchange(final DataLakeOperationResponse response, final Exchange exchange) {
+        final Message message = exchange.getIn();
+        message.setBody(response.getBody());
+        message.setHeaders(response.getHeaders());
+    }
+
+    @Override
+    protected void doStart() throws Exception {
+        super.doStart();
+
+        if (configuration.getServiceClient() != null) {","[{'comment': 'if the client can be set on the endpoint, can you add an extra check if endpoint it set on the endpoint as well', 'commenter': 'omarsmak'}, {'comment': 'Can you please elaborate a bit?', 'commenter': 'aryankoul'}, {'comment': 'Actually what you did here is fine, I forgot that will help to bind the client into the endpoint params, hence please ignore this comment :) ', 'commenter': 'omarsmak'}]"
4697,components/camel-azure-storage-datalake/src/main/java/org/apache/camel/component/azure/storage/datalake/DataLakeConstants.java,"@@ -0,0 +1,86 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.azure.storage.datalake;
+
+public final class DataLakeConstants {
+    private static final String HEADER_PREFIX = ""CamelAzureStorageDataLake"";
+
+    public static final String LIST_FILESYSTEMS_OPTIONS = HEADER_PREFIX + ""ListFileSystemsOptions"";
+    public static final String TIMEOUT = HEADER_PREFIX + ""Timeout"";
+    public static final String DATALAKE_OPERATION = HEADER_PREFIX + ""Operation"";
+    public static final String FILESYSTEM_NAME = HEADER_PREFIX + ""FileSystemName"";
+    public static final String DIRECTORY_NAME = HEADER_PREFIX + ""DirectoryName"";
+    public static final String FILE_NAME = HEADER_PREFIX + ""FileName"";
+    public static final String METADATA = HEADER_PREFIX + ""Metadata"";
+    public static final String PUBLIC_ACCESS_TYPE = HEADER_PREFIX + ""PublicAccessType"";
+    public static final String RAW_HTTP_HEADERS = HEADER_PREFIX + ""RawHttpHeaders"";
+    public static final String DATALAKE_REQUEST_CONDITION = HEADER_PREFIX + ""RequestCondition"";
+    public static final String LIST_PATH_OPTIONS = HEADER_PREFIX + ""ListPathOptions"";","[{'comment': 'This constant seems to be used, can you please check?', 'commenter': 'omarsmak'}]"
4697,components/camel-azure-storage-datalake/src/main/java/org/apache/camel/component/azure/storage/datalake/DataLakeConsumer.java,"@@ -0,0 +1,166 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.azure.storage.datalake;
+
+import java.io.IOException;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Queue;
+
+import com.azure.storage.file.datalake.DataLakeFileSystemClient;
+import com.azure.storage.file.datalake.models.DataLakeStorageException;
+import com.azure.storage.file.datalake.models.PathItem;
+import org.apache.camel.Endpoint;
+import org.apache.camel.Exchange;
+import org.apache.camel.ExtendedExchange;
+import org.apache.camel.Processor;
+import org.apache.camel.component.azure.storage.datalake.client.DataLakeFileClientWrapper;
+import org.apache.camel.component.azure.storage.datalake.client.DataLakeFileSystemClientWrapper;
+import org.apache.camel.component.azure.storage.datalake.operations.DataLakeFileOperations;
+import org.apache.camel.component.azure.storage.datalake.operations.DataLakeFileSystemOperations;
+import org.apache.camel.component.azure.storage.datalake.operations.DataLakeOperationResponse;
+import org.apache.camel.spi.Synchronization;
+import org.apache.camel.support.ScheduledBatchPollingConsumer;
+import org.apache.camel.util.CastUtils;
+import org.apache.camel.util.ObjectHelper;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+class DataLakeConsumer extends ScheduledBatchPollingConsumer {
+
+    public static final int NOT_FOUND = 404;
+    private static final Logger LOG = LoggerFactory.getLogger(DataLakeConsumer.class);
+
+    public DataLakeConsumer(Endpoint endpoint, Processor processor) {
+        super(endpoint, processor);
+    }
+
+    @Override
+    protected int poll() throws Exception {
+        final String fileSystemName = getEndpoint().getConfiguration().getFileSystemName();
+        final String fileName = getEndpoint().getConfiguration().getFileName();
+        final String directoryName = getEndpoint().getConfiguration().getDirectoryName();","[{'comment': '`directoryName` is not used here, any purpose?', 'commenter': 'omarsmak'}]"
4697,components/camel-azure-storage-datalake/src/main/java/org/apache/camel/component/azure/storage/datalake/DataLakeProducer.java,"@@ -0,0 +1,169 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.azure.storage.datalake;
+
+import java.io.IOException;
+
+import org.apache.camel.Endpoint;
+import org.apache.camel.Exchange;
+import org.apache.camel.component.azure.storage.datalake.client.DataLakeDirectoryClientWrapper;
+import org.apache.camel.component.azure.storage.datalake.client.DataLakeFileClientWrapper;
+import org.apache.camel.component.azure.storage.datalake.client.DataLakeFileSystemClientWrapper;
+import org.apache.camel.component.azure.storage.datalake.client.DataLakeServiceClientWrapper;
+import org.apache.camel.component.azure.storage.datalake.operations.DataLakeDirectoryOperations;
+import org.apache.camel.component.azure.storage.datalake.operations.DataLakeFileOperations;
+import org.apache.camel.component.azure.storage.datalake.operations.DataLakeFileSystemOperations;
+import org.apache.camel.component.azure.storage.datalake.operations.DataLakeOperationResponse;
+import org.apache.camel.component.azure.storage.datalake.operations.DataLakeServiceOperations;
+import org.apache.camel.support.DefaultProducer;
+import org.apache.camel.util.ObjectHelper;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class DataLakeProducer extends DefaultProducer {
+
+    private static final Logger LOG = LoggerFactory.getLogger(DataLakeProducer.class);
+    private final DataLakeConfiguration configuration;
+    private final DataLakeConfigurationOptionsProxy configurationProxy;
+    private final DataLakeServiceClientWrapper dataLakeServiceClientWrapper;
+
+    public DataLakeProducer(final Endpoint endpoint) {
+        super(endpoint);
+        //        this.configuration = getEndpoint().getConfiguration();
+        configuration = getEndpoint().getConfiguration();
+        configurationProxy = new DataLakeConfigurationOptionsProxy(configuration);
+        dataLakeServiceClientWrapper = new DataLakeServiceClientWrapper(getEndpoint().getDataLakeServiceClient());
+    }
+
+    @Override
+    public DataLakeEndpoint getEndpoint() {
+        return (DataLakeEndpoint) super.getEndpoint();
+    }
+
+    @Override
+    public void process(Exchange exchange) throws IllegalArgumentException, IOException {
+        DataLakeOperationsDefinition operation = determineOperation(exchange);
+        switch (operation) {
+            case listFileSystem:
+                setResponse(exchange, getServiceOperations(exchange).listFileSystems(exchange));
+                break;
+            case createFileSystem:
+                setResponse(exchange, getFileSystemOperations(exchange).createFileSystem(exchange));
+                break;
+            case deleteFileSystem:
+                setResponse(exchange, getFileSystemOperations(exchange).deleteFileSystem(exchange));
+                break;
+            case listPaths:
+                setResponse(exchange, getFileSystemOperations(exchange).listPaths(exchange));
+                break;
+            case getFile:
+                setResponse(exchange, getFileOperations(exchange).getFile(exchange));
+                break;
+            case downloadToFile:
+                setResponse(exchange, getFileOperations(exchange).downloadToFile(exchange));
+                break;
+            case downloadLink:
+                setResponse(exchange, getFileOperations(exchange).downloadLink(exchange));
+                break;
+            case deleteFile:
+                setResponse(exchange, getFileOperations(exchange).deleteFile(exchange));
+                break;
+            case appendToFile:
+                setResponse(exchange, getFileOperations(exchange).appendToFile(exchange));
+                break;
+            case flushToFile:
+                setResponse(exchange, getFileOperations(exchange).flushToFile(exchange));
+                break;
+            case uploadFromFile:
+                setResponse(exchange, getFileOperations(exchange).uploadFromFile(exchange));
+                break;
+            case openQueryInputStream:
+                setResponse(exchange, getFileOperations(exchange).openQueryInputStream(exchange));
+                break;
+            case upload:
+                setResponse(exchange, getFileOperations(exchange).upload(exchange));
+                break;
+            default:
+                throw new IllegalArgumentException(""Unsupported operation"");
+        }
+    }
+
+    private void setResponse(final Exchange exchange, final DataLakeOperationResponse dataLakeOperationResponse) {
+        exchange.getMessage().setBody(dataLakeOperationResponse.getBody());
+        exchange.getMessage().setHeaders(dataLakeOperationResponse.getHeaders());
+    }
+
+    private DataLakeOperationsDefinition determineOperation(final Exchange exchange) {
+        return configurationProxy.getOperation(exchange);
+    }
+
+    private DataLakeServiceOperations getServiceOperations(final Exchange exchange) {
+        return new DataLakeServiceOperations(configuration, dataLakeServiceClientWrapper);
+    }
+
+    private DataLakeFileSystemOperations getFileSystemOperations(final Exchange exchange) {
+        LOG.info(""getting file system operation object"");
+        final DataLakeFileSystemClientWrapper clientWrapper
+                = dataLakeServiceClientWrapper.getDataLakeFileSystemClientWrapper(determineFileSystemName(exchange));
+
+        return new DataLakeFileSystemOperations(configuration, clientWrapper);
+    }
+
+    private DataLakeDirectoryOperations getDirectoryOperations(final Exchange exchange) {","[{'comment': 'I see this operation is not used', 'commenter': 'omarsmak'}]"
4697,catalog/camel-catalog/src/generated/resources/org/apache/camel/catalog/docs/azure-storage-datalake-component.adoc,"@@ -0,0 +1,119 @@
+[[azure-storage-datalake-component]]","[{'comment': 'The documentation is laking a lot of info, please add info about the component, examples, usage, info about the headers that users can use in the producer and expect in the consumer,  any features that you implemented and you want users to try out ... etc. Ex:  https://camel.apache.org/components/latest/azure-storage-blob-component.html', 'commenter': 'omarsmak'}]"
4697,test-infra/camel-test-infra-azure-storage-datalake/src/test/java/org/apache/camel/test/infra/azure/storage/datalake/clients/AzureStorageDataLakeClientUtils.java,"@@ -0,0 +1,48 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.camel.test.infra.azure.storage.datalake.clients;
+
+import com.azure.storage.common.StorageSharedKeyCredential;
+import com.azure.storage.file.datalake.DataLakeServiceClient;
+import com.azure.storage.file.datalake.DataLakeServiceClientBuilder;
+import org.apache.camel.test.infra.azure.common.AzureConfigs;
+
+public final class AzureStorageDataLakeClientUtils {
+
+    private AzureStorageDataLakeClientUtils() {
+
+    }
+
+    public static DataLakeServiceClient getClient() {
+        String instanceType = System.getProperty(""azure.instance.type"");
+
+        String accountName = System.getProperty(AzureConfigs.ACCOUNT_NAME);
+        String accountKey = System.getProperty(AzureConfigs.ACCOUNT_KEY);
+        StorageSharedKeyCredential credential = new StorageSharedKeyCredential(accountName, accountKey);
+
+        String host = System.getProperty(AzureConfigs.HOST);","[{'comment': 'I see `HOST` and `PORT` is not used. Can you remove these since Azurite is not yet supporting `Datalake` ', 'commenter': 'omarsmak'}]"
4698,components/camel-salesforce/camel-salesforce-component/src/main/java/org/apache/camel/component/salesforce/SalesforceEndpointConfig.java,"@@ -166,8 +167,10 @@
     private String instanceId;
 
     // Streaming API properties
-    @UriParam
-    private Long defaultReplayId;
+    @UriParam(description = ""Default replayId setting if no value is found in "" +
+                            ""{@link #initialReplayIdMap}"",","[{'comment': 'Can you remove this @link as this is not javadoc and we want to keep those descriptions just text based.', 'commenter': 'davsclaus'}, {'comment': 'Ah, nice catch.', 'commenter': 'jeremyross'}]"
4876,components/camel-google-calendar/src/main/java/org/apache/camel/component/google/calendar/stream/GoogleCalendarStreamConsumer.java,"@@ -59,19 +70,21 @@ public GoogleCalendarStreamEndpoint getEndpoint() {
 
     @Override
     protected int poll() throws Exception {
-        com.google.api.services.calendar.Calendar.Events.List request
-                = getClient().events().list(getConfiguration().getCalendarId()).setOrderBy(""updated"");
+        Calendar.Events.List request = getClient().events().list(getConfiguration().getCalendarId());
         if (ObjectHelper.isNotEmpty(getConfiguration().getQuery())) {","[{'comment': ""Please don't use this class, we have all the tools to check this stuff the camel way"", 'commenter': 'oscerd'}, {'comment': 'I guess this refers to `Preconditions`? What is the Camel way? Could you point me in the right direction?', 'commenter': 'jmerljak'}, {'comment': ""Use ObjectHelper class, check if the syncFlow is not empty and log a warning, I don't think we have to throw an exception."", 'commenter': 'oscerd'}, {'comment': ""I was referring to https://github.com/apache/camel/blob/master/components/camel-google-calendar/src/main/java/org/apache/camel/component/google/calendar/GoogleCalendarEndpoint.java#L66 where an exception is thrown when incompatible option is set. Invalid configuration results in request failures, so it's better to fail fast. \r\n\r\nMoreover, `syncFlow` may be set, it just shouldn't be set to `true`."", 'commenter': 'jmerljak'}, {'comment': ""Then instead of doing this check here in the poll, check if syncFlow is true and query is set in the endpoint consumer creation and fail there. Don't use Precondition, is just another class that will change in the future and we'll have to align, you just need to check a boolean value."", 'commenter': 'oscerd'}, {'comment': 'Done.', 'commenter': 'jmerljak'}]"
4876,components/camel-google-calendar/src/main/java/org/apache/camel/component/google/calendar/stream/GoogleCalendarStreamConsumer.java,"@@ -59,19 +70,21 @@ public GoogleCalendarStreamEndpoint getEndpoint() {
 
     @Override
     protected int poll() throws Exception {
-        com.google.api.services.calendar.Calendar.Events.List request
-                = getClient().events().list(getConfiguration().getCalendarId()).setOrderBy(""updated"");
+        Calendar.Events.List request = getClient().events().list(getConfiguration().getCalendarId());
         if (ObjectHelper.isNotEmpty(getConfiguration().getQuery())) {
+            Preconditions.checkArgument(!getConfiguration().isSyncFlow(), ""query is incompatible with sync flow."");
             request.setQ(getConfiguration().getQuery());
         }
         if (ObjectHelper.isNotEmpty(getConfiguration().getMaxResults())) {
             request.setMaxResults(getConfiguration().getMaxResults());
         }
-        if (getConfiguration().isConsumeFromNow()) {
+        // in synchronization flow only set timeMin on first request
+        if (getConfiguration().isConsumeFromNow() && syncToken == null) {
             Date date = new Date();
             request.setTimeMin(new DateTime(date));
         }
         if (getConfiguration().isConsiderLastUpdate()) {
+            Preconditions.checkArgument(!getConfiguration().isSyncFlow(), ""considerLastUpdate is incompatible with sync flow."");","[{'comment': 'Same', 'commenter': 'oscerd'}]"
4881,components/camel-paho-mqtt5/pom.xml,"@@ -0,0 +1,96 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one or more
+    contributor license agreements.  See the NOTICE file distributed with
+    this work for additional information regarding copyright ownership.
+    The ASF licenses this file to You under the Apache License, Version 2.0
+    (the ""License""); you may not use this file except in compliance with
+    the License.  You may obtain a copy of the License at
+
+         http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an ""AS IS"" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+
+-->
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"">
+
+    <modelVersion>4.0.0</modelVersion>
+
+    <parent>
+        <groupId>org.apache.camel</groupId>
+        <artifactId>components</artifactId>
+        <version>3.8.0-SNAPSHOT</version>
+    </parent>
+
+    <artifactId>camel-paho-mqtt5</artifactId>
+    <packaging>jar</packaging>
+    <name>Camel :: Paho MQTT 5</name>
+    <description>Camel Eclipse Paho support for MQTT v5</description>
+
+    <properties>
+    </properties>
+
+    <dependencies>
+        <dependency>
+            <groupId>org.apache.camel</groupId>
+            <artifactId>camel-support</artifactId>
+        </dependency>
+        <dependency>
+            <groupId>org.eclipse.paho</groupId>
+            <artifactId>org.eclipse.paho.mqttv5.client</artifactId>
+            <version>${paho-version}</version>
+        </dependency>
+
+        <dependency>
+            <groupId>org.apache.camel</groupId>
+            <artifactId>camel-test-junit5</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.apache.camel</groupId>
+            <artifactId>camel-core-catalog</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.apache.logging.log4j</groupId>
+            <artifactId>log4j-slf4j-impl</artifactId>
+            <scope>test</scope>
+        </dependency>
+
+        <!-- test infra -->
+        <dependency>
+            <groupId>org.apache.camel</groupId>
+            <artifactId>camel-test-infra-common</artifactId>
+            <version>${project.version}</version>
+            <type>test-jar</type>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.apache.camel</groupId>
+            <artifactId>camel-test-infra-mosquitto</artifactId>
+            <version>${project.version}</version>
+            <type>test-jar</type>
+            <scope>test</scope>
+        </dependency>
+    </dependencies>
+
+    <build>","[{'comment': 'Do we need this flatten plugin - cant we use global configured instead?', 'commenter': 'davsclaus'}, {'comment': 'I guess this is because the original camel-paho has the same plugin in his pom', 'commenter': 'oscerd'}, {'comment': 'Yes, it was leftover from original camel-paho. Will remove. Thanks.', 'commenter': 'tadayosi'}]"
4881,components/camel-paho-mqtt5/src/main/java/org/apache/camel/component/paho/mqtt5/PahoComponent.java,"@@ -0,0 +1,85 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.paho.mqtt5;
+
+import java.util.Map;
+
+import org.apache.camel.CamelContext;
+import org.apache.camel.Endpoint;
+import org.apache.camel.spi.Metadata;
+import org.apache.camel.spi.annotations.Component;
+import org.apache.camel.support.DefaultComponent;
+import org.eclipse.paho.mqttv5.client.MqttClient;
+
+/**
+ * Component to integrate with the Eclipse Paho MQTT library.","[{'comment': 'v5', 'commenter': 'davsclaus'}]"
4900,components/camel-huaweicloud-smn/src/test/java/org/apache/camel/component/huaweicloud/smn/PublishTemplatedMessageTest.java,"@@ -0,0 +1,129 @@
+package org.apache.camel.component.huaweicloud.smn;","[{'comment': 'Please add the License header on all the test java files.', 'commenter': 'WillemJiang'}, {'comment': 'License header added on all test files', 'commenter': 'mathewsreji'}]"
4900,components/camel-huaweicloud-smn/src/test/java/org/apache/camel/component/huaweicloud/smn/PublishTemplatedMessageTest.java,"@@ -0,0 +1,129 @@
+package org.apache.camel.component.huaweicloud.smn;
+
+import java.nio.file.Files;
+import java.nio.file.Paths;
+import java.util.HashMap;
+import java.util.Map;
+
+import com.github.tomakehurst.wiremock.WireMockServer;
+import com.github.tomakehurst.wiremock.verification.LoggedRequest;
+import org.apache.camel.BindToRegistry;
+import org.apache.camel.Exchange;
+import org.apache.camel.builder.RouteBuilder;
+import org.apache.camel.component.huaweicloud.smn.models.ServiceKeys;
+import org.apache.camel.component.mock.MockEndpoint;
+import org.apache.camel.test.junit4.CamelTestSupport;
+import org.junit.Assert;
+import org.junit.Test;
+import org.mockito.Mockito;
+import org.mockito.exceptions.base.MockitoException;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import static com.github.tomakehurst.wiremock.client.WireMock.*;
+
+public class PublishTemplatedMessageTest extends CamelTestSupport {
+
+    private static final Logger LOGGER = LoggerFactory.getLogger(PublishTemplatedMessageTest.class.getName());
+    private static int wiremockServerPort = 8080;","[{'comment': 'It may cause some trouble in CI if the test port is used.\r\nThere is a port lookup util method in Camel that you can take a look.', 'commenter': 'WillemJiang'}, {'comment': 'as suggested by @omarsmak , have removed external mocks and instead mocked the SmnClient class and stubbed the operation method', 'commenter': 'mathewsreji'}]"
4900,components/camel-huaweicloud-smn/src/test/java/org/apache/camel/component/huaweicloud/smn/PublishTemplatedMessageTest.java,"@@ -0,0 +1,129 @@
+package org.apache.camel.component.huaweicloud.smn;
+
+import java.nio.file.Files;
+import java.nio.file.Paths;
+import java.util.HashMap;
+import java.util.Map;
+
+import com.github.tomakehurst.wiremock.WireMockServer;
+import com.github.tomakehurst.wiremock.verification.LoggedRequest;
+import org.apache.camel.BindToRegistry;
+import org.apache.camel.Exchange;
+import org.apache.camel.builder.RouteBuilder;
+import org.apache.camel.component.huaweicloud.smn.models.ServiceKeys;
+import org.apache.camel.component.mock.MockEndpoint;
+import org.apache.camel.test.junit4.CamelTestSupport;
+import org.junit.Assert;
+import org.junit.Test;
+import org.mockito.Mockito;
+import org.mockito.exceptions.base.MockitoException;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import static com.github.tomakehurst.wiremock.client.WireMock.*;
+
+public class PublishTemplatedMessageTest extends CamelTestSupport {
+
+    private static final Logger LOGGER = LoggerFactory.getLogger(PublishTemplatedMessageTest.class.getName());
+    private static int wiremockServerPort = 8080;
+
+    TestConfiguration testConfiguration = new TestConfiguration();
+
+    WireMockServer wireMockServer;
+
+    @BindToRegistry(""serviceKeys"")
+    ServiceKeys serviceKeys
+            = new ServiceKeys(testConfiguration.getProperty(""authKey""), testConfiguration.getProperty(""secretKey""));
+
+    protected RouteBuilder createRouteBuilder() throws Exception {
+
+        // populating tag values. user has to adjust the map entries according to the structure of their respective templates
+        Map<String, String> tags = new HashMap<>();
+        tags.put(""name"", ""reji"");
+        tags.put(""phone"", ""1234567890"");
+
+        return new RouteBuilder() {
+            public void configure() {
+                from(""direct:publish_templated_message"")
+                        .setProperty(""CamelHwCloudSmnSubject"", constant(""This is my subjectline""))
+                        .setProperty(""CamelHwCloudSmnTopic"", constant(testConfiguration.getProperty(""topic"")))
+                        .setProperty(""CamelHwCloudSmnMessageTtl"", constant(60))
+                        .setProperty(""CamelHwCloudSmnTemplateTags"", constant(tags))
+                        .setProperty(""CamelHwCloudSmnTemplateName"", constant(""hello-template""))
+                        //.to(""hwcloud-smn:publishMessageService?serviceKeys=#serviceKeys&operation=publishAsTemplatedMessage""+""&projectId=""+testConfiguration.getProperty(""projectId"")+""&region=""+testConfiguration.getProperty(""region"")+""&proxyHost=localhost&proxyPort=3128&ignoreSslVerification=true"")
+                        .to(""hwcloud-smn:publishMessageService?serviceKeys=#serviceKeys&operation=publishAsTemplatedMessage""
+                            + ""&projectId="" + testConfiguration.getProperty(""projectId"") + ""&region=""
+                            + testConfiguration.getProperty(""region"") + ""&ignoreSslVerification=true"")
+                        .log(""templated notification sent"")
+                        .to(""mock:publish_templated_message_result"");
+            }
+        };
+    }
+
+    private void setupSimpleNotificationsUtilsMock() {
+        try {
+            Mockito.mockStatic(SimpleNotificationUtils.class);
+            Mockito.when(SimpleNotificationUtils.resolveSmnServiceEndpoint(""unit-test""))
+                    .thenReturn(""http://localhost:"" + wiremockServerPort);
+        } catch (MockitoException e) {
+            LOGGER.info(""Mock already registered. Using existing registration"");
+        }
+    }
+
+    @Test
+    public void testTemplatedNotificationSend() throws Exception {
+        boolean isMockedServerTest = testConfiguration.getProperty(""region"").equals(""unit-test"");
+        if (isMockedServerTest) {
+            LOGGER.info(""region is unit-test. Starting up wiremock stubs"");
+            initWireMock();
+            setupSimpleNotificationsUtilsMock();
+        }
+
+        MockEndpoint mock = getMockEndpoint(""mock:publish_templated_message_result"");
+        mock.expectedMinimumMessageCount(1);
+        template.sendBody(""direct:publish_templated_message"", null);
+        Exchange responseExchange = mock.getExchanges().get(0);
+
+        mock.assertIsSatisfied();
+
+        Assert.assertNotNull(responseExchange.getProperty(""CamelSmnMesssageId""));
+        Assert.assertNotNull(responseExchange.getProperty(""CamelSmnRequestId""));
+        Assert.assertTrue(responseExchange.getProperty(""CamelSmnMesssageId"").toString().length() > 0);
+        Assert.assertTrue(responseExchange.getProperty(""CamelSmnRequestId"").toString().length() > 0);
+
+        if (isMockedServerTest) {
+            Assert.assertEquals(""bf94b63a5dfb475994d3ac34664e24f2"", responseExchange.getProperty(""CamelSmnMesssageId""));
+            Assert.assertEquals(""6a63a18b8bab40ffb71ebd9cb80d0085"", responseExchange.getProperty(""CamelSmnRequestId""));
+
+            LoggedRequest loggedRequest = TestUtils.retrieveTemplatedNotificationRequest(getAllServeEvents());
+            LOGGER.info(""Verifying wiremock request"");
+            Assert.assertEquals(
+                    ""http://localhost:8080/v2/9071a38e7f6a4ba7b7bcbeb7d4ea6efc/notifications/topics/urn:smn:unit-test:9071a38e7f6a4ba7b7bcbeb7d4ea6efc:reji-test/publish"",
+                    loggedRequest.getAbsoluteUrl());
+            Assert.assertEquals(
+                    ""eyJzdWJqZWN0IjoiVGhpcyBpcyBteSBzdWJqZWN0bGluZSIsIm1lc3NhZ2VfdGVtcGxhdGVfbmFtZSI6ImhlbGxvLXRlbXBsYXRlIiwidGFncyI6eyJwaG9uZSI6IjEyMzQ1Njc4OTAiLCJuYW1lIjoicmVqaSJ9LCJ0aW1lX3RvX2xpdmUiOiI2MCJ9"",
+                    loggedRequest.getBodyAsBase64());
+            Assert.assertEquals(
+                    ""{\""subject\"":\""This is my subjectline\"",\""message_template_name\"":\""hello-template\"",\""tags\"":{\""phone\"":\""1234567890\"",\""name\"":\""reji\""},\""time_to_live\"":\""60\""}"",
+                    loggedRequest.getBodyAsString());
+        }
+    }
+
+    private void initWireMock() throws Exception {
+        try {
+            wireMockServer = new WireMockServer(wiremockServerPort);
+            wireMockServer.start();
+        } catch (Exception e) {
+            LOGGER.info(""wiremock server already registered in test context. using the same"");","[{'comment': 'We should throw the exception beside printing a log.', 'commenter': 'WillemJiang'}]"
4900,components/camel-huaweicloud-smn/src/test/java/org/apache/camel/component/huaweicloud/smn/PublishTemplatedMessageTest.java,"@@ -0,0 +1,129 @@
+package org.apache.camel.component.huaweicloud.smn;
+
+import java.nio.file.Files;
+import java.nio.file.Paths;
+import java.util.HashMap;
+import java.util.Map;
+
+import com.github.tomakehurst.wiremock.WireMockServer;
+import com.github.tomakehurst.wiremock.verification.LoggedRequest;
+import org.apache.camel.BindToRegistry;
+import org.apache.camel.Exchange;
+import org.apache.camel.builder.RouteBuilder;
+import org.apache.camel.component.huaweicloud.smn.models.ServiceKeys;
+import org.apache.camel.component.mock.MockEndpoint;
+import org.apache.camel.test.junit4.CamelTestSupport;
+import org.junit.Assert;
+import org.junit.Test;
+import org.mockito.Mockito;
+import org.mockito.exceptions.base.MockitoException;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import static com.github.tomakehurst.wiremock.client.WireMock.*;
+
+public class PublishTemplatedMessageTest extends CamelTestSupport {
+
+    private static final Logger LOGGER = LoggerFactory.getLogger(PublishTemplatedMessageTest.class.getName());
+    private static int wiremockServerPort = 8080;
+
+    TestConfiguration testConfiguration = new TestConfiguration();
+
+    WireMockServer wireMockServer;
+
+    @BindToRegistry(""serviceKeys"")
+    ServiceKeys serviceKeys
+            = new ServiceKeys(testConfiguration.getProperty(""authKey""), testConfiguration.getProperty(""secretKey""));
+
+    protected RouteBuilder createRouteBuilder() throws Exception {
+
+        // populating tag values. user has to adjust the map entries according to the structure of their respective templates
+        Map<String, String> tags = new HashMap<>();
+        tags.put(""name"", ""reji"");
+        tags.put(""phone"", ""1234567890"");
+
+        return new RouteBuilder() {
+            public void configure() {
+                from(""direct:publish_templated_message"")
+                        .setProperty(""CamelHwCloudSmnSubject"", constant(""This is my subjectline""))
+                        .setProperty(""CamelHwCloudSmnTopic"", constant(testConfiguration.getProperty(""topic"")))
+                        .setProperty(""CamelHwCloudSmnMessageTtl"", constant(60))
+                        .setProperty(""CamelHwCloudSmnTemplateTags"", constant(tags))
+                        .setProperty(""CamelHwCloudSmnTemplateName"", constant(""hello-template""))
+                        //.to(""hwcloud-smn:publishMessageService?serviceKeys=#serviceKeys&operation=publishAsTemplatedMessage""+""&projectId=""+testConfiguration.getProperty(""projectId"")+""&region=""+testConfiguration.getProperty(""region"")+""&proxyHost=localhost&proxyPort=3128&ignoreSslVerification=true"")
+                        .to(""hwcloud-smn:publishMessageService?serviceKeys=#serviceKeys&operation=publishAsTemplatedMessage""
+                            + ""&projectId="" + testConfiguration.getProperty(""projectId"") + ""&region=""
+                            + testConfiguration.getProperty(""region"") + ""&ignoreSslVerification=true"")
+                        .log(""templated notification sent"")
+                        .to(""mock:publish_templated_message_result"");
+            }
+        };
+    }
+
+    private void setupSimpleNotificationsUtilsMock() {
+        try {
+            Mockito.mockStatic(SimpleNotificationUtils.class);","[{'comment': ""It's not a good practice to mock the static utils method.\r\nAs we cannot verify the code of mocked static method in the unit test."", 'commenter': 'WillemJiang'}, {'comment': 'This is completely removed', 'commenter': 'mathewsreji'}]"
4900,components/camel-huaweicloud-smn/src/main/java/org/apache/camel/component/huaweicloud/smn/SimpleNotificationUtils.java,"@@ -0,0 +1,69 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.huaweicloud.smn;
+
+import com.huaweicloud.sdk.core.region.Region;
+import com.huaweicloud.sdk.smn.v2.region.SmnRegion;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * utility functions for the component
+ */
+public class SimpleNotificationUtils {
+    private static final Logger LOG = LoggerFactory.getLogger(SimpleNotificationUtils.class.getName());
+
+    /**
+     * resolves endpoint url for the given region
+     * 
+     * @param  region
+     * @return
+     */
+    public static String resolveSmnServiceEndpoint(String region) {
+        if (region == null) {
+            return null;
+        }
+
+        String result = null;
+
+        try {
+            String formattedEndpointKey = formatEndpointKey(region);","[{'comment': ""I'm not sure if we can still use reflection in Camel 3.0 to support camel-quarkus.\r\nPlease double check it with the community."", 'commenter': 'WillemJiang'}, {'comment': 'No, we should avoid it.', 'commenter': 'oscerd'}]"
4900,components/camel-huaweicloud-smn/src/test/java/org/apache/camel/component/huaweicloud/smn/PublishTemplatedMessageTest.java,"@@ -0,0 +1,129 @@
+package org.apache.camel.component.huaweicloud.smn;
+
+import java.nio.file.Files;
+import java.nio.file.Paths;
+import java.util.HashMap;
+import java.util.Map;
+
+import com.github.tomakehurst.wiremock.WireMockServer;
+import com.github.tomakehurst.wiremock.verification.LoggedRequest;
+import org.apache.camel.BindToRegistry;
+import org.apache.camel.Exchange;
+import org.apache.camel.builder.RouteBuilder;
+import org.apache.camel.component.huaweicloud.smn.models.ServiceKeys;
+import org.apache.camel.component.mock.MockEndpoint;
+import org.apache.camel.test.junit4.CamelTestSupport;
+import org.junit.Assert;
+import org.junit.Test;
+import org.mockito.Mockito;
+import org.mockito.exceptions.base.MockitoException;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import static com.github.tomakehurst.wiremock.client.WireMock.*;
+
+public class PublishTemplatedMessageTest extends CamelTestSupport {","[{'comment': 'we can consider to reuse the WireMock setup code across PublishTemplatedMessageTest and PublishTextMessageTest.', 'commenter': 'WillemJiang'}, {'comment': 'Removed wiremocks (as it can potentially cause port conflicts in worst case). Referred testing strategy of aws-s3 camel component by mocking SmnClient ', 'commenter': 'mathewsreji'}]"
4900,components/camel-huaweicloud-smn/src/main/java/org/apache/camel/component/huaweicloud/smn/SimpleNotificationProducer.java,"@@ -0,0 +1,366 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.huaweicloud.smn;
+
+import java.util.HashMap;
+
+import com.huaweicloud.sdk.core.auth.BasicCredentials;
+import com.huaweicloud.sdk.core.http.HttpConfig;
+import com.huaweicloud.sdk.smn.v2.SmnClient;
+import com.huaweicloud.sdk.smn.v2.model.PublishMessageRequest;
+import com.huaweicloud.sdk.smn.v2.model.PublishMessageRequestBody;
+import com.huaweicloud.sdk.smn.v2.model.PublishMessageResponse;
+import org.apache.camel.Exchange;
+import org.apache.camel.component.huaweicloud.smn.constants.SmnConstants;
+import org.apache.camel.component.huaweicloud.smn.constants.SmnOperations;
+import org.apache.camel.component.huaweicloud.smn.constants.SmnServices;
+import org.apache.camel.component.huaweicloud.smn.models.ClientConfigurations;
+import org.apache.camel.support.DefaultProducer;
+import org.apache.camel.util.ObjectHelper;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class SimpleNotificationProducer extends DefaultProducer {
+    private static final Logger LOG = LoggerFactory.getLogger(SimpleNotificationProducer.class);
+    private SimpleNotificationEndpoint simpleNotificationEndpoint;
+    private SmnClient smnClient;
+    private ClientConfigurations clientConfigurations;
+
+    public SimpleNotificationProducer(SimpleNotificationEndpoint endpoint) {
+        super(endpoint);
+        this.simpleNotificationEndpoint = endpoint;","[{'comment': ""this is redundant, since the super class's constructor takes the endpoint. Hence, you can add a method `getEndpoint` that casts your endpoint implementation, e.g: `(SimpleNotificationEndpoint) super.getEndpoint()`"", 'commenter': 'omarsmak'}, {'comment': 'Redundancy removed from the code', 'commenter': 'mathewsreji'}]"
4900,components/camel-huaweicloud-smn/src/main/java/org/apache/camel/component/huaweicloud/smn/SimpleNotificationProducer.java,"@@ -0,0 +1,366 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.huaweicloud.smn;
+
+import java.util.HashMap;
+
+import com.huaweicloud.sdk.core.auth.BasicCredentials;
+import com.huaweicloud.sdk.core.http.HttpConfig;
+import com.huaweicloud.sdk.smn.v2.SmnClient;
+import com.huaweicloud.sdk.smn.v2.model.PublishMessageRequest;
+import com.huaweicloud.sdk.smn.v2.model.PublishMessageRequestBody;
+import com.huaweicloud.sdk.smn.v2.model.PublishMessageResponse;
+import org.apache.camel.Exchange;
+import org.apache.camel.component.huaweicloud.smn.constants.SmnConstants;
+import org.apache.camel.component.huaweicloud.smn.constants.SmnOperations;
+import org.apache.camel.component.huaweicloud.smn.constants.SmnServices;
+import org.apache.camel.component.huaweicloud.smn.models.ClientConfigurations;
+import org.apache.camel.support.DefaultProducer;
+import org.apache.camel.util.ObjectHelper;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class SimpleNotificationProducer extends DefaultProducer {
+    private static final Logger LOG = LoggerFactory.getLogger(SimpleNotificationProducer.class);
+    private SimpleNotificationEndpoint simpleNotificationEndpoint;
+    private SmnClient smnClient;
+    private ClientConfigurations clientConfigurations;
+
+    public SimpleNotificationProducer(SimpleNotificationEndpoint endpoint) {
+        super(endpoint);
+        this.simpleNotificationEndpoint = endpoint;
+    }
+
+    public void process(Exchange exchange) throws Exception {
+
+        /**
+         * the produce method is invoked when a message arrives at producer endpoint (lazy init of SmnClient on first
+         * message)
+         */
+        if (this.smnClient == null) {","[{'comment': 'any reason why the `smsClient` has to be lazily initialized and not on the `start` method?', 'commenter': 'omarsmak'}, {'comment': 'lazy initialization has been removed. instead moved the routine call inside constructor', 'commenter': 'mathewsreji'}]"
4900,components/camel-huaweicloud-smn/src/main/java/org/apache/camel/component/huaweicloud/smn/SimpleNotificationProducer.java,"@@ -0,0 +1,366 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.huaweicloud.smn;
+
+import java.util.HashMap;
+
+import com.huaweicloud.sdk.core.auth.BasicCredentials;
+import com.huaweicloud.sdk.core.http.HttpConfig;
+import com.huaweicloud.sdk.smn.v2.SmnClient;
+import com.huaweicloud.sdk.smn.v2.model.PublishMessageRequest;
+import com.huaweicloud.sdk.smn.v2.model.PublishMessageRequestBody;
+import com.huaweicloud.sdk.smn.v2.model.PublishMessageResponse;
+import org.apache.camel.Exchange;
+import org.apache.camel.component.huaweicloud.smn.constants.SmnConstants;
+import org.apache.camel.component.huaweicloud.smn.constants.SmnOperations;
+import org.apache.camel.component.huaweicloud.smn.constants.SmnServices;
+import org.apache.camel.component.huaweicloud.smn.models.ClientConfigurations;
+import org.apache.camel.support.DefaultProducer;
+import org.apache.camel.util.ObjectHelper;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class SimpleNotificationProducer extends DefaultProducer {
+    private static final Logger LOG = LoggerFactory.getLogger(SimpleNotificationProducer.class);
+    private SimpleNotificationEndpoint simpleNotificationEndpoint;
+    private SmnClient smnClient;
+    private ClientConfigurations clientConfigurations;
+
+    public SimpleNotificationProducer(SimpleNotificationEndpoint endpoint) {
+        super(endpoint);
+        this.simpleNotificationEndpoint = endpoint;
+    }
+
+    public void process(Exchange exchange) throws Exception {
+
+        /**
+         * the produce method is invoked when a message arrives at producer endpoint (lazy init of SmnClient on first
+         * message)
+         */
+        if (this.smnClient == null) {
+            if (LOG.isDebugEnabled()) {
+                LOG.debug(""Initializing the SmnClient"");
+            }
+            validateAndInitializeSmnClient(simpleNotificationEndpoint);
+        }
+
+        String service = simpleNotificationEndpoint.getSmnService();
+
+        if (!ObjectHelper.isEmpty(service)) {
+            switch (service) {
+                case SmnServices.PUBLISH_MESSAGE:
+                    if (LOG.isDebugEnabled()) {
+                        LOG.debug(""Using message publishing service"");
+                    }
+                    performPublishMessageServiceOperations(simpleNotificationEndpoint, exchange);
+                    if (LOG.isDebugEnabled()) {
+                        LOG.debug(""Completed publishing message"");
+                    }
+                    break;
+                default:
+                    if (LOG.isErrorEnabled()) {
+                        LOG.error(""Unsupported service name {}"", service);
+                    }
+                    throw new UnsupportedOperationException(String.format(""service %s is not a supported service"", service));
+            }
+        } else {
+            if (LOG.isErrorEnabled()) {
+                LOG.error(""Service name is null/empty"");
+            }
+            throw new IllegalStateException(""service name cannot be null/empty"");","[{'comment': 'out of curiosity, do you think it just makes sense to have a default service instead of throwing an error? especially that there is currently one service implemented ', 'commenter': 'omarsmak'}, {'comment': 'It was just a personal choice. I have removed the lazy initialization to class init time ', 'commenter': 'mathewsreji'}]"
4900,components/camel-huaweicloud-smn/src/main/java/org/apache/camel/component/huaweicloud/smn/SimpleNotificationProducer.java,"@@ -0,0 +1,366 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.huaweicloud.smn;
+
+import java.util.HashMap;
+
+import com.huaweicloud.sdk.core.auth.BasicCredentials;
+import com.huaweicloud.sdk.core.http.HttpConfig;
+import com.huaweicloud.sdk.smn.v2.SmnClient;
+import com.huaweicloud.sdk.smn.v2.model.PublishMessageRequest;
+import com.huaweicloud.sdk.smn.v2.model.PublishMessageRequestBody;
+import com.huaweicloud.sdk.smn.v2.model.PublishMessageResponse;
+import org.apache.camel.Exchange;
+import org.apache.camel.component.huaweicloud.smn.constants.SmnConstants;
+import org.apache.camel.component.huaweicloud.smn.constants.SmnOperations;
+import org.apache.camel.component.huaweicloud.smn.constants.SmnServices;
+import org.apache.camel.component.huaweicloud.smn.models.ClientConfigurations;
+import org.apache.camel.support.DefaultProducer;
+import org.apache.camel.util.ObjectHelper;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class SimpleNotificationProducer extends DefaultProducer {
+    private static final Logger LOG = LoggerFactory.getLogger(SimpleNotificationProducer.class);
+    private SimpleNotificationEndpoint simpleNotificationEndpoint;
+    private SmnClient smnClient;
+    private ClientConfigurations clientConfigurations;
+
+    public SimpleNotificationProducer(SimpleNotificationEndpoint endpoint) {
+        super(endpoint);
+        this.simpleNotificationEndpoint = endpoint;
+    }
+
+    public void process(Exchange exchange) throws Exception {
+
+        /**
+         * the produce method is invoked when a message arrives at producer endpoint (lazy init of SmnClient on first
+         * message)
+         */
+        if (this.smnClient == null) {
+            if (LOG.isDebugEnabled()) {
+                LOG.debug(""Initializing the SmnClient"");
+            }
+            validateAndInitializeSmnClient(simpleNotificationEndpoint);
+        }
+
+        String service = simpleNotificationEndpoint.getSmnService();
+
+        if (!ObjectHelper.isEmpty(service)) {
+            switch (service) {
+                case SmnServices.PUBLISH_MESSAGE:
+                    if (LOG.isDebugEnabled()) {
+                        LOG.debug(""Using message publishing service"");
+                    }
+                    performPublishMessageServiceOperations(simpleNotificationEndpoint, exchange);
+                    if (LOG.isDebugEnabled()) {
+                        LOG.debug(""Completed publishing message"");
+                    }
+                    break;
+                default:
+                    if (LOG.isErrorEnabled()) {
+                        LOG.error(""Unsupported service name {}"", service);
+                    }
+                    throw new UnsupportedOperationException(String.format(""service %s is not a supported service"", service));
+            }
+        } else {
+            if (LOG.isErrorEnabled()) {
+                LOG.error(""Service name is null/empty"");
+            }
+            throw new IllegalStateException(""service name cannot be null/empty"");
+        }
+    }
+
+    /**
+     * Publish message service operations
+     *
+     * @param endpoint
+     * @param exchange
+     */
+    private void performPublishMessageServiceOperations(SimpleNotificationEndpoint endpoint, Exchange exchange) {
+        PublishMessageResponse response;
+
+        PublishMessageRequestBody apiBody;
+        this.clientConfigurations = validateServiceConfigurations(endpoint, exchange);
+
+        if (LOG.isDebugEnabled()) {
+            LOG.debug(""Checking operation name"");
+        }
+        switch (clientConfigurations.getOperation()) {
+
+            case SmnOperations.PUBLISH_AS_TEXT_MESSAGE:
+                if (LOG.isDebugEnabled()) {
+                    LOG.debug(""Publishing as text message"");
+                }
+                apiBody = new PublishMessageRequestBody()
+                        .withMessage(exchange.getMessage().getBody(String.class))
+                        .withSubject(clientConfigurations.getSubject())
+                        .withTimeToLive(String.valueOf(clientConfigurations.getMessageTtl()));
+
+                response = smnClient.publishMessage(new PublishMessageRequest()
+                        .withBody(apiBody)
+                        .withTopicUrn(clientConfigurations.getTopicUrn()));
+                break;
+
+            case SmnOperations.PUBLISH_AS_TEMPLATED_MESSAGE:
+                if (LOG.isDebugEnabled()) {
+                    LOG.debug(""Publishing as templated message"");
+                }
+                apiBody = new PublishMessageRequestBody()
+                        .withMessage(exchange.getMessage().getBody(String.class))
+                        .withSubject(clientConfigurations.getSubject())
+                        .withTimeToLive(String.valueOf(clientConfigurations.getMessageTtl()))
+                        .withMessageTemplateName((String) exchange.getProperty(""CamelHwCloudSmnTemplateName""))
+                        .withTags((HashMap<String, String>) exchange.getProperty(""CamelHwCloudSmnTemplateTags""))
+                        .withTimeToLive(String.valueOf(clientConfigurations.getMessageTtl()));
+
+                response = smnClient.publishMessage(new PublishMessageRequest()
+                        .withBody(apiBody)
+                        .withTopicUrn(clientConfigurations.getTopicUrn()));
+                break;
+
+            default:
+                throw new UnsupportedOperationException(","[{'comment': 'also here a default operation instead of throwing an error', 'commenter': 'omarsmak'}, {'comment': ""I think defaulting to publishAsTextMessage is good idea. i'll check it out  "", 'commenter': 'mathewsreji'}]"
4900,components/camel-huaweicloud-smn/src/main/java/org/apache/camel/component/huaweicloud/smn/SimpleNotificationProducer.java,"@@ -0,0 +1,366 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.huaweicloud.smn;
+
+import java.util.HashMap;
+
+import com.huaweicloud.sdk.core.auth.BasicCredentials;
+import com.huaweicloud.sdk.core.http.HttpConfig;
+import com.huaweicloud.sdk.smn.v2.SmnClient;
+import com.huaweicloud.sdk.smn.v2.model.PublishMessageRequest;
+import com.huaweicloud.sdk.smn.v2.model.PublishMessageRequestBody;
+import com.huaweicloud.sdk.smn.v2.model.PublishMessageResponse;
+import org.apache.camel.Exchange;
+import org.apache.camel.component.huaweicloud.smn.constants.SmnConstants;
+import org.apache.camel.component.huaweicloud.smn.constants.SmnOperations;
+import org.apache.camel.component.huaweicloud.smn.constants.SmnServices;
+import org.apache.camel.component.huaweicloud.smn.models.ClientConfigurations;
+import org.apache.camel.support.DefaultProducer;
+import org.apache.camel.util.ObjectHelper;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class SimpleNotificationProducer extends DefaultProducer {
+    private static final Logger LOG = LoggerFactory.getLogger(SimpleNotificationProducer.class);
+    private SimpleNotificationEndpoint simpleNotificationEndpoint;
+    private SmnClient smnClient;
+    private ClientConfigurations clientConfigurations;
+
+    public SimpleNotificationProducer(SimpleNotificationEndpoint endpoint) {
+        super(endpoint);
+        this.simpleNotificationEndpoint = endpoint;
+    }
+
+    public void process(Exchange exchange) throws Exception {
+
+        /**
+         * the produce method is invoked when a message arrives at producer endpoint (lazy init of SmnClient on first
+         * message)
+         */
+        if (this.smnClient == null) {
+            if (LOG.isDebugEnabled()) {
+                LOG.debug(""Initializing the SmnClient"");
+            }
+            validateAndInitializeSmnClient(simpleNotificationEndpoint);
+        }
+
+        String service = simpleNotificationEndpoint.getSmnService();
+
+        if (!ObjectHelper.isEmpty(service)) {
+            switch (service) {
+                case SmnServices.PUBLISH_MESSAGE:
+                    if (LOG.isDebugEnabled()) {
+                        LOG.debug(""Using message publishing service"");
+                    }
+                    performPublishMessageServiceOperations(simpleNotificationEndpoint, exchange);
+                    if (LOG.isDebugEnabled()) {
+                        LOG.debug(""Completed publishing message"");
+                    }
+                    break;
+                default:
+                    if (LOG.isErrorEnabled()) {
+                        LOG.error(""Unsupported service name {}"", service);
+                    }
+                    throw new UnsupportedOperationException(String.format(""service %s is not a supported service"", service));
+            }
+        } else {
+            if (LOG.isErrorEnabled()) {
+                LOG.error(""Service name is null/empty"");
+            }
+            throw new IllegalStateException(""service name cannot be null/empty"");
+        }
+    }
+
+    /**
+     * Publish message service operations
+     *
+     * @param endpoint
+     * @param exchange
+     */
+    private void performPublishMessageServiceOperations(SimpleNotificationEndpoint endpoint, Exchange exchange) {
+        PublishMessageResponse response;
+
+        PublishMessageRequestBody apiBody;
+        this.clientConfigurations = validateServiceConfigurations(endpoint, exchange);
+
+        if (LOG.isDebugEnabled()) {
+            LOG.debug(""Checking operation name"");
+        }
+        switch (clientConfigurations.getOperation()) {
+
+            case SmnOperations.PUBLISH_AS_TEXT_MESSAGE:
+                if (LOG.isDebugEnabled()) {
+                    LOG.debug(""Publishing as text message"");
+                }
+                apiBody = new PublishMessageRequestBody()
+                        .withMessage(exchange.getMessage().getBody(String.class))
+                        .withSubject(clientConfigurations.getSubject())
+                        .withTimeToLive(String.valueOf(clientConfigurations.getMessageTtl()));
+
+                response = smnClient.publishMessage(new PublishMessageRequest()
+                        .withBody(apiBody)
+                        .withTopicUrn(clientConfigurations.getTopicUrn()));
+                break;
+
+            case SmnOperations.PUBLISH_AS_TEMPLATED_MESSAGE:
+                if (LOG.isDebugEnabled()) {
+                    LOG.debug(""Publishing as templated message"");
+                }
+                apiBody = new PublishMessageRequestBody()
+                        .withMessage(exchange.getMessage().getBody(String.class))
+                        .withSubject(clientConfigurations.getSubject())
+                        .withTimeToLive(String.valueOf(clientConfigurations.getMessageTtl()))
+                        .withMessageTemplateName((String) exchange.getProperty(""CamelHwCloudSmnTemplateName""))
+                        .withTags((HashMap<String, String>) exchange.getProperty(""CamelHwCloudSmnTemplateTags""))
+                        .withTimeToLive(String.valueOf(clientConfigurations.getMessageTtl()));
+
+                response = smnClient.publishMessage(new PublishMessageRequest()
+                        .withBody(apiBody)
+                        .withTopicUrn(clientConfigurations.getTopicUrn()));
+                break;
+
+            default:
+                throw new UnsupportedOperationException(
+                        String.format(""operation %s not supported in publishMessage service"",
+                                clientConfigurations.getOperation()));
+        }
+        setResponseParameters(exchange, response);
+    }
+
+    /**
+     * maps api response parameters as exchange property
+     * 
+     * @param exchange
+     * @param response
+     */
+    private void setResponseParameters(Exchange exchange, PublishMessageResponse response) {
+        if (response == null) {
+            return; // mapping is not required if response object is null
+        }
+        if (!ObjectHelper.isEmpty(response.getMessageId())) {
+            exchange.setProperty(""CamelSmnMesssageId"", response.getMessageId());","[{'comment': 'I would prefer to separate the headers properties and exchange properties into a separate constant class, e.g: `SimpleNotificationConstants`. You can take a look at other components for reference', 'commenter': 'omarsmak'}, {'comment': 'Done. Moved all constants to SmnProperties class', 'commenter': 'mathewsreji'}]"
4900,components/camel-huaweicloud-smn/src/main/java/org/apache/camel/component/huaweicloud/smn/SimpleNotificationProducer.java,"@@ -0,0 +1,366 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.huaweicloud.smn;
+
+import java.util.HashMap;
+
+import com.huaweicloud.sdk.core.auth.BasicCredentials;
+import com.huaweicloud.sdk.core.http.HttpConfig;
+import com.huaweicloud.sdk.smn.v2.SmnClient;
+import com.huaweicloud.sdk.smn.v2.model.PublishMessageRequest;
+import com.huaweicloud.sdk.smn.v2.model.PublishMessageRequestBody;
+import com.huaweicloud.sdk.smn.v2.model.PublishMessageResponse;
+import org.apache.camel.Exchange;
+import org.apache.camel.component.huaweicloud.smn.constants.SmnConstants;
+import org.apache.camel.component.huaweicloud.smn.constants.SmnOperations;
+import org.apache.camel.component.huaweicloud.smn.constants.SmnServices;
+import org.apache.camel.component.huaweicloud.smn.models.ClientConfigurations;
+import org.apache.camel.support.DefaultProducer;
+import org.apache.camel.util.ObjectHelper;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class SimpleNotificationProducer extends DefaultProducer {
+    private static final Logger LOG = LoggerFactory.getLogger(SimpleNotificationProducer.class);
+    private SimpleNotificationEndpoint simpleNotificationEndpoint;
+    private SmnClient smnClient;
+    private ClientConfigurations clientConfigurations;
+
+    public SimpleNotificationProducer(SimpleNotificationEndpoint endpoint) {
+        super(endpoint);
+        this.simpleNotificationEndpoint = endpoint;
+    }
+
+    public void process(Exchange exchange) throws Exception {
+
+        /**
+         * the produce method is invoked when a message arrives at producer endpoint (lazy init of SmnClient on first
+         * message)
+         */
+        if (this.smnClient == null) {
+            if (LOG.isDebugEnabled()) {
+                LOG.debug(""Initializing the SmnClient"");
+            }
+            validateAndInitializeSmnClient(simpleNotificationEndpoint);
+        }
+
+        String service = simpleNotificationEndpoint.getSmnService();
+
+        if (!ObjectHelper.isEmpty(service)) {
+            switch (service) {
+                case SmnServices.PUBLISH_MESSAGE:
+                    if (LOG.isDebugEnabled()) {
+                        LOG.debug(""Using message publishing service"");
+                    }
+                    performPublishMessageServiceOperations(simpleNotificationEndpoint, exchange);
+                    if (LOG.isDebugEnabled()) {
+                        LOG.debug(""Completed publishing message"");
+                    }
+                    break;
+                default:
+                    if (LOG.isErrorEnabled()) {
+                        LOG.error(""Unsupported service name {}"", service);
+                    }
+                    throw new UnsupportedOperationException(String.format(""service %s is not a supported service"", service));
+            }
+        } else {
+            if (LOG.isErrorEnabled()) {
+                LOG.error(""Service name is null/empty"");
+            }
+            throw new IllegalStateException(""service name cannot be null/empty"");
+        }
+    }
+
+    /**
+     * Publish message service operations
+     *
+     * @param endpoint
+     * @param exchange
+     */
+    private void performPublishMessageServiceOperations(SimpleNotificationEndpoint endpoint, Exchange exchange) {
+        PublishMessageResponse response;
+
+        PublishMessageRequestBody apiBody;
+        this.clientConfigurations = validateServiceConfigurations(endpoint, exchange);
+
+        if (LOG.isDebugEnabled()) {
+            LOG.debug(""Checking operation name"");
+        }
+        switch (clientConfigurations.getOperation()) {
+
+            case SmnOperations.PUBLISH_AS_TEXT_MESSAGE:
+                if (LOG.isDebugEnabled()) {
+                    LOG.debug(""Publishing as text message"");
+                }
+                apiBody = new PublishMessageRequestBody()
+                        .withMessage(exchange.getMessage().getBody(String.class))
+                        .withSubject(clientConfigurations.getSubject())
+                        .withTimeToLive(String.valueOf(clientConfigurations.getMessageTtl()));
+
+                response = smnClient.publishMessage(new PublishMessageRequest()
+                        .withBody(apiBody)
+                        .withTopicUrn(clientConfigurations.getTopicUrn()));
+                break;
+
+            case SmnOperations.PUBLISH_AS_TEMPLATED_MESSAGE:
+                if (LOG.isDebugEnabled()) {
+                    LOG.debug(""Publishing as templated message"");
+                }
+                apiBody = new PublishMessageRequestBody()
+                        .withMessage(exchange.getMessage().getBody(String.class))
+                        .withSubject(clientConfigurations.getSubject())
+                        .withTimeToLive(String.valueOf(clientConfigurations.getMessageTtl()))
+                        .withMessageTemplateName((String) exchange.getProperty(""CamelHwCloudSmnTemplateName""))
+                        .withTags((HashMap<String, String>) exchange.getProperty(""CamelHwCloudSmnTemplateTags""))
+                        .withTimeToLive(String.valueOf(clientConfigurations.getMessageTtl()));
+
+                response = smnClient.publishMessage(new PublishMessageRequest()
+                        .withBody(apiBody)
+                        .withTopicUrn(clientConfigurations.getTopicUrn()));
+                break;
+
+            default:
+                throw new UnsupportedOperationException(
+                        String.format(""operation %s not supported in publishMessage service"",
+                                clientConfigurations.getOperation()));
+        }
+        setResponseParameters(exchange, response);
+    }
+
+    /**
+     * maps api response parameters as exchange property
+     * 
+     * @param exchange
+     * @param response
+     */
+    private void setResponseParameters(Exchange exchange, PublishMessageResponse response) {
+        if (response == null) {
+            return; // mapping is not required if response object is null
+        }
+        if (!ObjectHelper.isEmpty(response.getMessageId())) {
+            exchange.setProperty(""CamelSmnMesssageId"", response.getMessageId());
+        }
+        if (!ObjectHelper.isEmpty(response.getRequestId())) {
+            exchange.setProperty(""CamelSmnRequestId"", response.getRequestId());
+        }
+    }
+
+    /**
+     * validation and initialization of SmnClient object
+     *
+     * @param simpleNotificationEndpoint
+     */
+    private void validateAndInitializeSmnClient(SimpleNotificationEndpoint simpleNotificationEndpoint) {
+        this.clientConfigurations = new ClientConfigurations();
+
+        //checking for cloud SK (secret key)
+        if (ObjectHelper.isEmpty(simpleNotificationEndpoint.getSecretKey()) &&
+                ObjectHelper.isEmpty(simpleNotificationEndpoint.getServiceKeys())) {
+            if (LOG.isErrorEnabled()) {
+                LOG.error(""secret key (SK) not found"");
+            }
+            throw new IllegalArgumentException(""authentication parameter 'secret key (SK)' not found"");
+        } else {
+            clientConfigurations.setSecretKey(simpleNotificationEndpoint.getSecretKey() != null
+                    ? simpleNotificationEndpoint.getSecretKey() : simpleNotificationEndpoint.getServiceKeys().getSecretKey());
+        }
+
+        //checking for cloud AK (auth key)
+        if (ObjectHelper.isEmpty(simpleNotificationEndpoint.getAuthKey()) &&
+                ObjectHelper.isEmpty(simpleNotificationEndpoint.getServiceKeys())) {
+            if (LOG.isErrorEnabled()) {
+                LOG.error(""authentication key (AK) not found"");
+            }
+            throw new IllegalArgumentException(""authentication parameter 'authentication key (AK)' not found"");
+        } else {
+            clientConfigurations.setAuthenticationkey(simpleNotificationEndpoint.getAuthKey() != null
+                    ? simpleNotificationEndpoint.getAuthKey()
+                    : simpleNotificationEndpoint.getServiceKeys().getAuthenticationKey());
+        }
+
+        //checking for project ID
+        if (ObjectHelper.isEmpty(simpleNotificationEndpoint.getProjectId())) {
+            if (LOG.isErrorEnabled()) {
+                LOG.error(""Project ID not found"");
+            }
+            throw new IllegalArgumentException(""project ID not found"");
+        } else {
+            clientConfigurations.setProjectId(simpleNotificationEndpoint.getProjectId());
+        }
+
+        //checking for region
+        String endpointUrl = SimpleNotificationUtils.resolveSmnServiceEndpoint(simpleNotificationEndpoint.getRegion());
+        if (endpointUrl == null) {
+            if (LOG.isErrorEnabled()) {
+                LOG.error(""Valid region not found"");
+            }
+            throw new IllegalArgumentException(""enter a valid region"");
+        } else {
+            clientConfigurations.setServiceEndpoint(endpointUrl);
+        }
+
+        //checking for ignore ssl verification
+        boolean ignoreSslVerification = simpleNotificationEndpoint.isIgnoreSslVerification();
+        if (ignoreSslVerification) {
+            if (LOG.isWarnEnabled()) {
+                LOG.error(""SSL verification is ignored. This is unsafe in production environment"");
+            }
+            clientConfigurations.setIgnoreSslVerification(ignoreSslVerification);
+        }
+
+        //checking if http proxy authentication is used
+        if (simpleNotificationEndpoint.getProxyHost() != null) {
+            if (LOG.isDebugEnabled()) {
+                LOG.debug(""Reading http proxy configurations"");
+            }
+            clientConfigurations.setProxyHost(simpleNotificationEndpoint.getProxyHost());
+            clientConfigurations.setProxyPort(simpleNotificationEndpoint.getProxyPort());
+            clientConfigurations.setProxyUser(simpleNotificationEndpoint.getProxyUser());
+            clientConfigurations.setProxyPassword(simpleNotificationEndpoint.getProxyPassword());
+        }
+
+        this.smnClient = initializeClient(clientConfigurations);
+    }
+
+    /**
+     * initialization of smn client. this is lazily initialized on the first message
+     * 
+     * @param  clientConfigurations
+     * @return
+     */
+    private SmnClient initializeClient(ClientConfigurations clientConfigurations) {
+        if (LOG.isDebugEnabled()) {
+            LOG.debug(""Initializing Smn client"");
+        }
+        HttpConfig httpConfig = null;
+
+        if (clientConfigurations.getProxyHost() != null) {
+            httpConfig = HttpConfig.getDefaultHttpConfig();
+            httpConfig.withProxyHost(clientConfigurations.getProxyHost())
+                    .withProxyPort(clientConfigurations.getProxyPort())
+                    .setIgnoreSSLVerification(clientConfigurations.isIgnoreSslVerification());
+
+            if (clientConfigurations.getProxyUser() != null) {
+                httpConfig.withProxyUsername(clientConfigurations.getProxyUser());
+                httpConfig.withProxyPassword(clientConfigurations.getProxyPassword());
+            }
+        }
+
+        BasicCredentials credentials = new BasicCredentials()
+                .withAk(clientConfigurations.getAuthenticationkey())
+                .withSk(clientConfigurations.getSecretKey())
+                .withProjectId(clientConfigurations.getProjectId());
+
+        if (LOG.isDebugEnabled()) {
+            LOG.debug(""Building Smn client"");
+        }
+
+        // building smn client object
+        SmnClient smnClient = SmnClient.newBuilder()
+                .withCredential(credentials)
+                .withHttpConfig(httpConfig)
+                .withEndpoint(clientConfigurations.getServiceEndpoint())
+                .build();
+
+        if (LOG.isDebugEnabled()) {
+            LOG.debug(""Successfully initialized Smn client"");
+        }
+        return smnClient;
+    }
+
+    /**
+     * validation of all user inputs before attempting to invoke a service operation
+     *
+     * @param  simpleNotificationEndpoint
+     * @param  exchange
+     * @return
+     */
+    private ClientConfigurations validateServiceConfigurations(
+            SimpleNotificationEndpoint simpleNotificationEndpoint, Exchange exchange) {
+
+        if (LOG.isDebugEnabled()) {
+            LOG.debug(""Inspecting exchange body"");
+        }
+        // verifying if exchange has valid body content. this is mandatory for 'publish as text' operation
+        if (ObjectHelper.isEmpty(exchange.getMessage().getBody())) {
+            if (simpleNotificationEndpoint.getOperation().equals(""publishAsTextMessage"")) {
+                if (LOG.isErrorEnabled()) {
+                    LOG.error(""Found null/empty body. Cannot perform publish as text operation"");
+                }
+                throw new IllegalArgumentException(""exchange body cannot be null / empty"");
+            }
+        }
+
+        // checking for mandatory field 'operation name'
+        if (LOG.isDebugEnabled()) {
+            LOG.debug(""Inspecting operation name"");
+        }
+        if (ObjectHelper.isEmpty(exchange.getProperty(""CamelHwCloudOperation""))
+                && ObjectHelper.isEmpty(simpleNotificationEndpoint.getOperation())) {
+            if (LOG.isErrorEnabled()) {
+                LOG.error(""Found null/empty operation name. Cannot proceed with Smn operations"");
+            }
+            throw new IllegalArgumentException(""operation name not found"");
+        } else {
+            clientConfigurations.setOperation(exchange.getProperty(""CamelHwCloudOperation"") != null","[{'comment': 'same here for the exchange properties constants ', 'commenter': 'omarsmak'}, {'comment': 'Moved to SmnProperties class', 'commenter': 'mathewsreji'}]"
4900,components/camel-huaweicloud-smn/src/main/java/org/apache/camel/component/huaweicloud/smn/constants/SmnConstants.java,"@@ -0,0 +1,22 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.huaweicloud.smn.constants;
+
+public class SmnConstants {","[{'comment': 'constant class means private constructor ', 'commenter': 'omarsmak'}, {'comment': 'Added private constructor', 'commenter': 'mathewsreji'}]"
4900,components/camel-huaweicloud-smn/src/main/java/org/apache/camel/component/huaweicloud/smn/SimpleNotificationUtils.java,"@@ -0,0 +1,69 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.huaweicloud.smn;
+
+import com.huaweicloud.sdk.core.region.Region;
+import com.huaweicloud.sdk.smn.v2.region.SmnRegion;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * utility functions for the component
+ */
+public class SimpleNotificationUtils {","[{'comment': 'private constructor here is missing for the utility class', 'commenter': 'omarsmak'}, {'comment': 'Added private constructor', 'commenter': 'mathewsreji'}]"
4900,components/camel-huaweicloud-smn/src/test/java/org/apache/camel/component/huaweicloud/smn/PublishTemplatedMessageTest.java,"@@ -0,0 +1,129 @@
+package org.apache.camel.component.huaweicloud.smn;
+
+import java.nio.file.Files;
+import java.nio.file.Paths;
+import java.util.HashMap;
+import java.util.Map;
+
+import com.github.tomakehurst.wiremock.WireMockServer;
+import com.github.tomakehurst.wiremock.verification.LoggedRequest;
+import org.apache.camel.BindToRegistry;
+import org.apache.camel.Exchange;
+import org.apache.camel.builder.RouteBuilder;
+import org.apache.camel.component.huaweicloud.smn.models.ServiceKeys;
+import org.apache.camel.component.mock.MockEndpoint;
+import org.apache.camel.test.junit4.CamelTestSupport;
+import org.junit.Assert;
+import org.junit.Test;
+import org.mockito.Mockito;
+import org.mockito.exceptions.base.MockitoException;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import static com.github.tomakehurst.wiremock.client.WireMock.*;","[{'comment': ""In general, I would like us to avoid the external mocking as much as possible. Did you consider to mock `SmnClient` instead? Meaning that, create a test SmnClient client that overrides the functionality of  `SmnClient` with your mocked functionality instead. And then add the ability in the endpoint to set the client explicitly. With that you won't need wiremock, your service is mocked by yourself, e.g: https://github.com/apache/camel/blob/master/components/camel-aws-s3/src/test/java/org/apache/camel/component/aws/s3/AmazonS3ClientMock.java and then you can see that in the other tests, the mocked client was supplied"", 'commenter': 'omarsmak'}, {'comment': 'Sounds like a better idea. I will get the wiremock removed and instead have a mocked client. Thanks', 'commenter': 'mathewsreji'}, {'comment': 'Suggestion has been incorporated into the code. Main codebase has been re-visited to  make it  more testable with above suggestion', 'commenter': 'mathewsreji'}]"
4909,components/camel-milo/src/main/java/org/apache/camel/component/milo/client/MiloClientProducer.java,"@@ -53,7 +57,15 @@ public boolean process(Exchange exchange, AsyncCallback async) {
 
         final CompletableFuture<?> future;
 
-        if (this.methodId == null) {
+        if (msg.getHeaders().containsKey(HEADER_NODE_IDS)) {","[{'comment': ""You're changing the default behavior here, so it would be better if you add more documentation under src/main/docs of the project"", 'commenter': 'oscerd'}, {'comment': 'done.', 'commenter': 'attrobit'}]"
4909,components/camel-milo/src/test/java/org/apache/camel/component/milo/ReadValuesClientTest.java,"@@ -0,0 +1,66 @@
+package org.apache.camel.component.milo;","[{'comment': 'Please add the ASF license header', 'commenter': 'oscerd'}, {'comment': 'done.', 'commenter': 'attrobit'}]"
4909,components/camel-milo/src/main/java/org/apache/camel/component/milo/client/MiloClientProducer.java,"@@ -35,6 +37,8 @@
 
     private final boolean defaultAwaitWrites;
 
+    private static final String HEADER_NODE_IDS = ""opcua.nodeIds"";","[{'comment': 'Why is the header key with this value? - what is opcua', 'commenter': 'davsclaus'}, {'comment': 'opcua is the protocol underneath. But i will remove the prefix. The existing headers has also no prefix.', 'commenter': 'attrobit'}, {'comment': 'changed it to CamelMilo.nodeIds', 'commenter': 'attrobit'}]"
4909,catalog/camel-catalog/src/generated/resources/org/apache/camel/catalog/docs/milo-client-component.adoc,"@@ -228,6 +229,24 @@ Input parameters are taken from the body:
 * If the body is a `Variant`, then it will be wrapped in a `Variant[]` array
 * Otherwise the body will be converted into a `Variant` and wrapped in an array of `Variant[]`
 
+=== Read Values from Nodes
+
+The component provide a producer to read values from multiple opc-ua nodes. The Node-IDs will be defined in the header `CamelMilo.nodeIds` as list of strings. (see <<nodeid, Node-ID>> for the ID format).
+
+Example:
+```java
+from(""direct:start"")
+    .setHeader(""CamelMilo.nodeIds"", constant(Arrays.asList(""nsu=urn:org:apache:camel;s=myitem1"")))","[{'comment': 'The header key in this doc was not updated', 'commenter': 'davsclaus'}, {'comment': 'The header key in this doc was not updated', 'commenter': 'davsclaus'}, {'comment': 'omg. Sorry for that. I fixed it.', 'commenter': 'attrobit'}, {'comment': 'fixed.', 'commenter': 'attrobit'}]"
4913,catalog/camel-catalog/src/generated/resources/org/apache/camel/catalog/components.properties,"@@ -175,7 +175,6 @@ ignite-queue
 ignite-set
 imap
 imaps
-infinispan","[{'comment': 'I think we need a special case for infinispan in the catalog generation', 'commenter': 'oscerd'}, {'comment': 'Yeah if you have a sub folder, like camel-salesforce etc then you need to do some code changes in the tooling, you can do a git grep salesforce and find where it does some special.\r\n\r\nOver time we may want to improve the tooling so it can ""handle this"". For example if we move all the AWS components into sub folder.', 'commenter': 'davsclaus'}]"
4913,components/camel-infinispan/camel-infinispan-common/src/main/java/org/apache/camel/component/infinispan/InfinispanConsumer.java,"@@ -0,0 +1,84 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.infinispan;
+
+import java.util.function.Consumer;
+
+import org.apache.camel.Exchange;
+import org.apache.camel.Processor;
+import org.apache.camel.support.DefaultConsumer;
+import org.infinispan.commons.api.BasicCache;
+import org.infinispan.commons.api.BasicCacheContainer;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public abstract class InfinispanConsumer<
+        ContainerType extends BasicCacheContainer,
+        ManagerType extends InfinispanManager<ContainerType>,
+        ConfigurationType extends InfinispanConfiguration>
+        extends DefaultConsumer
+        implements InfinispanEventProcessor {
+
+    private static final Logger LOG = LoggerFactory.getLogger(InfinispanProducer.class);
+
+    protected final ConfigurationType configuration;
+    protected final ManagerType manager;
+    protected final String cacheName;
+
+    protected InfinispanConsumer(InfinispanEndpoint endpoint, Processor processor, String cacheName, ManagerType manager,
+                                 ConfigurationType configuration) {
+        super(endpoint, processor);
+        this.cacheName = cacheName;
+        this.configuration = configuration;
+        this.manager = manager;
+    }
+
+    @Override
+    public void processEvent(String eventType, String cacheName, Object key, Object eventData, Consumer<Exchange> consumer) {
+        Exchange exchange = getEndpoint().createExchange();
+        exchange.getMessage().setHeader(InfinispanConstants.EVENT_TYPE, eventType);
+        exchange.getMessage().setHeader(InfinispanConstants.CACHE_NAME, cacheName);
+
+        if (key != null) {
+            exchange.getMessage().setHeader(InfinispanConstants.KEY, key);
+        }
+        if (eventData != null) {
+            exchange.getMessage().setHeader(InfinispanConstants.EVENT_DATA, eventData);
+        }
+        if (consumer != null) {
+            consumer.accept(exchange);
+        }
+
+        try {
+            getProcessor().process(exchange);
+        } catch (Exception e) {
+            LOG.error(""Error processing event "", e);","[{'comment': 'Use getExceptionHandler().handleException instead of LOG', 'commenter': 'davsclaus'}]"
4913,components/camel-infinispan/camel-infinispan-common/src/main/java/org/apache/camel/component/infinispan/InfinispanRoutePolicy.java,"@@ -0,0 +1,246 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.infinispan;
+
+import java.util.HashSet;
+import java.util.Set;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicBoolean;
+
+import org.apache.camel.CamelContext;
+import org.apache.camel.CamelContextAware;
+import org.apache.camel.Route;
+import org.apache.camel.RuntimeCamelException;
+import org.apache.camel.Service;
+import org.apache.camel.api.management.ManagedAttribute;
+import org.apache.camel.support.RoutePolicySupport;
+import org.apache.camel.util.ObjectHelper;
+import org.apache.camel.util.ReferenceCount;
+import org.apache.camel.util.StringHelper;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public abstract class InfinispanRoutePolicy extends RoutePolicySupport implements CamelContextAware {","[{'comment': 'Just a thought I wonder didnt we have some SPI interface in camel-cluster to do clustered routes?', 'commenter': 'davsclaus'}, {'comment': 'yes we have it and I have plan to migrate it but as next step ', 'commenter': 'lburgazzoli'}]"
4916,components/camel-vertx-kafka/camel-vertx-kafka-component/src/test/java/org/apache/camel/component/vertx/kafka/operations/VertxKafkaProducerOperationsTest.java,"@@ -586,7 +586,7 @@ public void configure(Map<String, ?> configs, boolean isKey) {
 
         @Override
         public byte[] serialize(String topic, Object data) {
-            return stringSerializer.serialize(topic, data.toString());
+            return stringSerializer.serialize(topic, data != null ? data.toString() : null);","[{'comment': 'Tests were failing before my changes with a `NullReferenceException`. Seems like `data` was `null` in some tests, causing the issue with the serializer', 'commenter': 'javierholguera'}]"
4916,components/camel-vertx-kafka/camel-vertx-kafka-component/src/main/java/org/apache/camel/component/vertx/kafka/DefaultVertxKafkaClientFactory.java,"@@ -0,0 +1,24 @@
+package org.apache.camel.component.vertx.kafka;","[{'comment': 'Please add the ASF license ', 'commenter': 'oscerd'}]"
4916,components/camel-vertx-kafka/camel-vertx-kafka-component/src/main/java/org/apache/camel/component/vertx/kafka/VertxKafkaClientFactory.java,"@@ -0,0 +1,17 @@
+package org.apache.camel.component.vertx.kafka;","[{'comment': 'Same', 'commenter': 'oscerd'}]"
4916,components/camel-vertx-kafka/camel-vertx-kafka-component/src/main/java/org/apache/camel/component/vertx/kafka/configuration/BaseVertxKafkaConfiguration.java,"@@ -26,6 +28,9 @@
     @UriParam(label = ""common"")
     private HeaderFilterStrategy headerFilterStrategy = new VertxKafkaHeaderFilterStrategy();
 
+    @UriParam(label = ""common"")","[{'comment': 'Can we mark this option as advanced (as it would be seldom in use)', 'commenter': 'davsclaus'}]"
4936,components/camel-stitch/src/main/java/org/apache/camel/component/stitch/StitchConfiguration.java,"@@ -0,0 +1,163 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.stitch;
+
+import java.util.Collection;
+import java.util.HashSet;
+
+import org.apache.camel.RuntimeCamelException;
+import org.apache.camel.component.stitch.client.StitchClient;
+import org.apache.camel.component.stitch.client.StitchRegion;
+import org.apache.camel.component.stitch.client.models.StitchSchema;
+import org.apache.camel.spi.Metadata;
+import org.apache.camel.spi.UriParam;
+import org.apache.camel.spi.UriParams;
+import org.apache.camel.spi.UriPath;
+import reactor.netty.http.client.HttpClient;
+import reactor.netty.resources.ConnectionProvider;
+
+@UriParams
+public class StitchConfiguration implements Cloneable {
+
+    @UriPath
+    private String tableName;
+    @UriParam(label = ""security"", secret = true)
+    @Metadata(required = true)
+    private String token;
+    @UriParam(label = ""producer"", defaultValue = ""europe"")
+    private StitchRegion region = StitchRegion.EUROPE;
+    @UriParam(label = ""producer"")
+    @Metadata(autowired = true)
+    private StitchSchema stitchSchema;
+    @UriParam(label = ""producer"")
+    private Collection<String> keyNames = new HashSet<>();
+    @UriParam(label = ""producer,advance"")","[{'comment': 'advanced', 'commenter': 'davsclaus'}]"
4936,components/camel-stitch/src/main/java/org/apache/camel/component/stitch/StitchConfiguration.java,"@@ -0,0 +1,163 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.stitch;
+
+import java.util.Collection;
+import java.util.HashSet;
+
+import org.apache.camel.RuntimeCamelException;
+import org.apache.camel.component.stitch.client.StitchClient;
+import org.apache.camel.component.stitch.client.StitchRegion;
+import org.apache.camel.component.stitch.client.models.StitchSchema;
+import org.apache.camel.spi.Metadata;
+import org.apache.camel.spi.UriParam;
+import org.apache.camel.spi.UriParams;
+import org.apache.camel.spi.UriPath;
+import reactor.netty.http.client.HttpClient;
+import reactor.netty.resources.ConnectionProvider;
+
+@UriParams
+public class StitchConfiguration implements Cloneable {
+
+    @UriPath
+    private String tableName;
+    @UriParam(label = ""security"", secret = true)
+    @Metadata(required = true)
+    private String token;
+    @UriParam(label = ""producer"", defaultValue = ""europe"")
+    private StitchRegion region = StitchRegion.EUROPE;
+    @UriParam(label = ""producer"")
+    @Metadata(autowired = true)
+    private StitchSchema stitchSchema;
+    @UriParam(label = ""producer"")
+    private Collection<String> keyNames = new HashSet<>();","[{'comment': 'It would be good to also allow to set keyNames as a string value, where they keys are seperated with comma, then its easier to configure in endpoint uri. Some components offer that.', 'commenter': 'davsclaus'}]"
4936,components/camel-stitch/src/main/java/org/apache/camel/component/stitch/StitchEndpoint.java,"@@ -0,0 +1,102 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.stitch;
+
+import org.apache.camel.Category;
+import org.apache.camel.Component;
+import org.apache.camel.Consumer;
+import org.apache.camel.Processor;
+import org.apache.camel.Producer;
+import org.apache.camel.component.stitch.client.StitchClient;
+import org.apache.camel.component.stitch.client.StitchClientBuilder;
+import org.apache.camel.spi.UriEndpoint;
+import org.apache.camel.spi.UriParam;
+import org.apache.camel.support.DefaultEndpoint;
+
+/**
+ * Stitch is a cloud ETL service, developer-focused platform for rapidly moving and replicates data from more than 90","[{'comment': 'All this becomes a too long description. Can you make a shorter one sentence in the top and end it with a dot. Then the tooling with grab the first sentence and use as description summary in the metadata. \r\n\r\nToo long makes the component table looks bad etc.', 'commenter': 'davsclaus'}]"
4936,components/camel-stitch/src/main/java/org/apache/camel/component/stitch/StitchEndpoint.java,"@@ -0,0 +1,102 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.stitch;
+
+import org.apache.camel.Category;
+import org.apache.camel.Component;
+import org.apache.camel.Consumer;
+import org.apache.camel.Processor;
+import org.apache.camel.Producer;
+import org.apache.camel.component.stitch.client.StitchClient;
+import org.apache.camel.component.stitch.client.StitchClientBuilder;
+import org.apache.camel.spi.UriEndpoint;
+import org.apache.camel.spi.UriParam;
+import org.apache.camel.support.DefaultEndpoint;
+
+/**
+ * Stitch is a cloud ETL service, developer-focused platform for rapidly moving and replicates data from more than 90
+ * applications and databases. It integrates various data sources into a central data warehouse. Stitch has integrations
+ * for many enterprise software data sources, and can receive data via WebHooks and an API (Stitch Import API) which
+ * Camel Stitch Component uses to produce the data to Stitch ETL.
+ */
+@UriEndpoint(firstVersion = ""3.8.0"", scheme = ""stitch"", title = ""Stitch"",
+             syntax = ""stitch:tableName"", producerOnly = true, category = {
+                     Category.CLOUD, Category.API, Category.COMPUTE, Category.BIGDATA })
+public class StitchEndpoint extends DefaultEndpoint {
+
+    @UriParam
+    private StitchConfiguration configuration = new StitchConfiguration();
+
+    private StitchClient stitchClient;
+
+    public StitchEndpoint() {
+    }
+
+    public StitchEndpoint(final String uri, final Component component, final StitchConfiguration configuration) {
+        super(uri, component);
+        this.configuration = configuration;
+    }
+
+    @Override
+    protected void doStart() throws Exception {
+        super.doStart();
+
+        // since HttpClient.create() will create a pooled a connection when is called, hence placed in doStart
+        if (stitchClient == null) {","[{'comment': 'should this stitch client not be stopped at some point?', 'commenter': 'davsclaus'}, {'comment': ""I guess only when is not provided as configuration option, when it's created by the endpoint it should be stopped, like we did in aws"", 'commenter': 'oscerd'}]"
4952,components/camel-aws-s3/src/main/java/org/apache/camel/component/aws/s3/S3Consumer.java,"@@ -16,19 +16,11 @@
  */
 package org.apache.camel.component.aws.s3;
 
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.LinkedList;
-import java.util.List;
-import java.util.Queue;
+import java.util.*;","[{'comment': 'Please avoid * imports', 'commenter': 'oscerd'}, {'comment': 'Yeah, fixed, thanks.', 'commenter': 'vilmosnagy'}]"
4952,components/camel-aws-s3/src/main/java/org/apache/camel/component/aws/s3/S3Consumer.java,"@@ -16,19 +16,11 @@
  */
 package org.apache.camel.component.aws.s3;
 
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.LinkedList;
-import java.util.List;
-import java.util.Queue;
+import java.util.*;
 
 import com.amazonaws.AmazonClientException;
 import com.amazonaws.services.s3.AmazonS3;
-import com.amazonaws.services.s3.model.GetObjectRequest;
-import com.amazonaws.services.s3.model.ListObjectsRequest;
-import com.amazonaws.services.s3.model.ObjectListing;
-import com.amazonaws.services.s3.model.S3Object;
-import com.amazonaws.services.s3.model.S3ObjectSummary;
+import com.amazonaws.services.s3.model.*;","[{'comment': 'Same', 'commenter': 'oscerd'}, {'comment': 'Yeah, fixed, thanks.', 'commenter': 'vilmosnagy'}]"
4952,components/camel-aws-s3/src/main/java/org/apache/camel/component/aws/s3/S3Consumer.java,"@@ -66,9 +67,12 @@ protected int poll() throws Exception {
 
         String fileName = getConfiguration().getFileName();
         String bucketName = getConfiguration().getBucketName();
+        String doneFileName = getConfiguration().getDoneFileName();
         Queue<Exchange> exchanges;
 
-        if (fileName != null) {
+        if (shouldSkipCauseDoneFileIsConfiguredButMissing(bucketName, doneFileName)) {","[{'comment': 'Naming is hard but this name is really long :-D', 'commenter': 'oscerd'}, {'comment': ""What do you think about the following:\r\n\r\n```java\r\nif (!doneFileCheckPasses(bucketName, doneFileName)) {\r\n```\r\n\r\nOr I was thinking about something like:\r\n\r\n```java\r\nif (doneFileCheckPasses(bucketName, doneFileName)) {\r\n    // keep everything that was here beforehand\r\n} else {\r\n    exchanges = new LinkedList<>();\r\n}\r\n```\r\n\r\n\r\nbut that would mean a lot of whitespace changes and I don't want to create unnecessary changes."", 'commenter': 'vilmosnagy'}]"
4990,components/camel-slack/src/main/java/org/apache/camel/component/slack/SlackConsumer.java,"@@ -48,10 +48,12 @@
     private SlackEndpoint slackEndpoint;
     private String timestamp;
     private String channelId;
+    private HttpClient client;
 
     public SlackConsumer(SlackEndpoint endpoint, Processor processor) throws IOException, DeserializationException {
         super(endpoint, processor);
         this.slackEndpoint = endpoint;
+        this.client = HttpClientBuilder.create().useSystemProperties().build();","[{'comment': 'Do not create the client in the constructor, but in doStart', 'commenter': 'davsclaus'}]"
4990,components/camel-slack/src/main/java/org/apache/camel/component/slack/SlackProducer.java,"@@ -32,21 +32,23 @@
 import org.apache.http.client.methods.HttpPost;
 import org.apache.http.entity.StringEntity;
 import org.apache.http.impl.client.HttpClientBuilder;
+import org.apache.http.util.EntityUtils;
 
 public class SlackProducer extends DefaultProducer {
 
-    private SlackEndpoint slackEndpoint;
+    private final SlackEndpoint slackEndpoint;
+    private final HttpClient client;
 
     public SlackProducer(SlackEndpoint endpoint) {
         super(endpoint);
         this.slackEndpoint = endpoint;
+        this.client = HttpClientBuilder.create().useSystemProperties().build();","[{'comment': 'Same as consumer', 'commenter': 'davsclaus'}]"
4990,components/camel-slack/pom.xml,"@@ -62,6 +62,10 @@
             <groupId>org.apache.httpcomponents</groupId>","[{'comment': 'Can the old client be removed?', 'commenter': 'davsclaus'}, {'comment': 'It is still used by consumer', 'commenter': 'perttuk'}]"
4990,components/camel-slack/src/main/java/org/apache/camel/component/slack/SlackProducer.java,"@@ -59,7 +61,7 @@ protected void doStop() throws Exception {
     }
 ","[{'comment': 'And you have a doStop method where you stop/close the client?', 'commenter': 'davsclaus'}, {'comment': 'I added that in previous commit (https://github.com/apache/camel/pull/4990/commits/424273684ce44708461b0188cc90832517aae26b)', 'commenter': 'perttuk'}]"
5034,components/camel-nats/src/main/java/org/apache/camel/component/nats/NatsProducer.java,"@@ -42,21 +47,42 @@ public NatsEndpoint getEndpoint() {
     }
 
     @Override
-    public void process(Exchange exchange) throws Exception {
+    public void process(Exchange exchange) {","[{'comment': 'The throws exception should be there', 'commenter': 'davsclaus'}, {'comment': 'added Exception back', 'commenter': 'jameshilliard'}]"
5034,components/camel-nats/src/main/java/org/apache/camel/component/nats/NatsProducer.java,"@@ -42,21 +47,42 @@ public NatsEndpoint getEndpoint() {
     }
 
     @Override
-    public void process(Exchange exchange) throws Exception {
+    public void process(Exchange exchange) {
         NatsConfiguration config = getEndpoint().getConfiguration();
         byte[] body = exchange.getIn().getBody(byte[].class);
         if (body == null) {
-            // fallback to use string
-            body = exchange.getIn().getMandatoryBody(String.class).getBytes();
+            try {
+                // fallback to use string
+                body = exchange.getIn().getMandatoryBody(String.class).getBytes();
+            } catch (InvalidPayloadException e) {
+                exchange.setException(e);","[{'comment': 'dont catch the exception by let it fail as before as this is the synchronous process method', 'commenter': 'davsclaus'}, {'comment': 'reverted', 'commenter': 'jameshilliard'}, {'comment': 'I switched to async callback and added this back, is that the correct approach?', 'commenter': 'jameshilliard'}, {'comment': 'yes but it would actually maybe be better to convert to byte[] directly instead of via string as that is double encoding.', 'commenter': 'davsclaus'}, {'comment': 'But that is how the old code was, so it may be something for another PR', 'commenter': 'davsclaus'}, {'comment': ""Isn't the string conversion only a fallback codepath used when `exchange.getIn().getBody(byte[].class)` returns `null`?"", 'commenter': 'jameshilliard'}]"
5034,components/camel-nats/src/main/java/org/apache/camel/component/nats/NatsProducer.java,"@@ -42,21 +47,42 @@ public NatsEndpoint getEndpoint() {
     }
 
     @Override
-    public void process(Exchange exchange) throws Exception {
+    public void process(Exchange exchange) {
         NatsConfiguration config = getEndpoint().getConfiguration();
         byte[] body = exchange.getIn().getBody(byte[].class);
         if (body == null) {
-            // fallback to use string
-            body = exchange.getIn().getMandatoryBody(String.class).getBytes();
+            try {
+                // fallback to use string
+                body = exchange.getIn().getMandatoryBody(String.class).getBytes();
+            } catch (InvalidPayloadException e) {
+                exchange.setException(e);
+            }
         }
 
-        LOG.debug(""Publishing to topic: {}"", config.getTopic());
+        if (exchange.getPattern().isOutCapable()) {
+            LOG.debug(""Requesting to topic: {}"", config.getTopic());
 
-        if (ObjectHelper.isNotEmpty(config.getReplySubject())) {
-            String replySubject = config.getReplySubject();
-            connection.publish(config.getTopic(), replySubject, body);
+            CompletableFuture<io.nats.client.Message> future = connection.request(config.getTopic(), body);","[{'comment': ""Here is an opportunity to use correct asynchronous by switching over to Camel's process(exchange, callback) where we can the continue the callback when the completable future has a response"", 'commenter': 'davsclaus'}, {'comment': 'btw does `connection.request` automatic use some sort of temporary request/reply mechanism?', 'commenter': 'davsclaus'}, {'comment': ""> Here is an opportunity to use correct asynchronous by switching over to Camel's process(exchange, callback) where we can the continue the callback when the completable future has a response\r\n\r\nI wasn't exactly sure how I should style that, is there another implementation I should try and model it after?\r\n\r\n> btw does `connection.request` automatic use some sort of temporary request/reply mechanism?\r\n\r\nYeah, the nats library handles it internally with a sort of temporary single use reply subscription from my understanding."", 'commenter': 'jameshilliard'}, {'comment': 'I got the implementation switched over to use `process(exchange, callback)`, hopefully did it correctly.', 'commenter': 'jameshilliard'}]"
5034,components/camel-nats/src/main/java/org/apache/camel/component/nats/NatsProducer.java,"@@ -42,21 +47,42 @@ public NatsEndpoint getEndpoint() {
     }
 
     @Override
-    public void process(Exchange exchange) throws Exception {
+    public void process(Exchange exchange) {
         NatsConfiguration config = getEndpoint().getConfiguration();
         byte[] body = exchange.getIn().getBody(byte[].class);
         if (body == null) {
-            // fallback to use string
-            body = exchange.getIn().getMandatoryBody(String.class).getBytes();
+            try {
+                // fallback to use string
+                body = exchange.getIn().getMandatoryBody(String.class).getBytes();
+            } catch (InvalidPayloadException e) {
+                exchange.setException(e);
+            }
         }
 
-        LOG.debug(""Publishing to topic: {}"", config.getTopic());
+        if (exchange.getPattern().isOutCapable()) {
+            LOG.debug(""Requesting to topic: {}"", config.getTopic());
 
-        if (ObjectHelper.isNotEmpty(config.getReplySubject())) {
-            String replySubject = config.getReplySubject();
-            connection.publish(config.getTopic(), replySubject, body);
+            CompletableFuture<io.nats.client.Message> future = connection.request(config.getTopic(), body);
+            try {
+                io.nats.client.Message msg = future.get(config.getRequestCleanupInterval(), TimeUnit.MILLISECONDS);","[{'comment': 'the future get will block the current thread which is not ideal', 'commenter': 'davsclaus'}, {'comment': ""Yeah, I wasn't sure how to make the timeout work without blocking the thread."", 'commenter': 'jameshilliard'}, {'comment': 'I think I managed to fix this.', 'commenter': 'jameshilliard'}, {'comment': 'Seems to work, added a timeout test which passes at least.', 'commenter': 'jameshilliard'}]"
5034,components/camel-nats/src/test/java/org/apache/camel/component/nats/NatsProducerReplyToTimeoutTest.java,"@@ -0,0 +1,59 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.nats;
+
+import org.apache.camel.CamelExecutionException;
+import org.apache.camel.ExchangeTimedOutException;
+import org.apache.camel.builder.RouteBuilder;
+import org.junit.jupiter.api.Test;
+
+import static org.apache.camel.test.junit5.TestSupport.assertIsInstanceOf;
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.fail;
+
+public class NatsProducerReplyToTimeoutTest extends NatsTestSupport {
+
+    protected String startUri = ""direct:start"";
+    protected String middleUri = ""nats:foo.middle?requestCleanupInterval=50"";","[{'comment': 'I think we should use `requestTimeout` that is what the other messaging component uses. And it has a default timeout of 20 seconds. So this means adding a new option to use that. As that option is some sort of internal job by nats to cleanup stale jobs.', 'commenter': 'davsclaus'}, {'comment': 'Added `requestTimeout` with default timeout of 20 seconds.', 'commenter': 'jameshilliard'}]"
5034,components/camel-nats/src/main/java/org/apache/camel/component/nats/NatsProducer.java,"@@ -17,19 +17,29 @@
 package org.apache.camel.component.nats;
 
 import java.time.Duration;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.Executors;
+import java.util.concurrent.ScheduledExecutorService;
+import java.util.concurrent.TimeUnit;
 
 import io.nats.client.Connection;
 import io.nats.client.Connection.Status;
+import io.nats.client.Message;
+import org.apache.camel.AsyncCallback;
 import org.apache.camel.Exchange;
-import org.apache.camel.support.DefaultProducer;
+import org.apache.camel.ExchangeTimedOutException;
+import org.apache.camel.InvalidPayloadException;
+import org.apache.camel.support.DefaultAsyncProducer;
 import org.apache.camel.util.ObjectHelper;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-public class NatsProducer extends DefaultProducer {
+public class NatsProducer extends DefaultAsyncProducer {
 
     private static final Logger LOG = LoggerFactory.getLogger(NatsProducer.class);
 
+    private final ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);","[{'comment': ""We should use Camle's ExecutorStrategy to get a thread pool so its properly started/stopped etc. Also it may be desiredable to allow to configure a higher pool size, in case there is a lot of timed out messages. Otherwise the tasks is piling up as its the timeout future thread that will be used for continued routing."", 'commenter': 'davsclaus'}, {'comment': 'Also we could consider having a shared thread pool on the component level, as otherwise this is a private pool per producer, so that can mean if you have many producers you have many idle thread pools.', 'commenter': 'davsclaus'}, {'comment': ""I'm using camel's `ExecutorServiceManager` now, does that look correct?"", 'commenter': 'jameshilliard'}]"
5068,core/camel-support/src/main/java/org/apache/camel/converter/stream/CipherPair.java,"@@ -61,7 +60,18 @@ public Cipher getEncryptor() {
         return enccipher;
     }
 
-    public Cipher getDecryptor() {
-        return deccipher;
+    /**
+     * Create the decryptor every time because the decryptor is not thead safe. For example, if you reuse the decryptor
+     * instance in the Multi-cast case then you will get errors.
+     */
+    public Cipher createDecryptor() {
+        try {
+            Cipher deccipher = Cipher.getInstance(transformation);
+            deccipher.init(Cipher.DECRYPT_MODE, key, ivp == null ? null : new IvParameterSpec(ivp));
+            return deccipher;
+        } catch (GeneralSecurityException e) {
+            // should not happen
+            throw new IllegalStateException(""Could not instanciate decryptor, e"");","[{'comment': 'It should be \r\n\r\nthrow new IllegalStateException(""Could not instanciate decryptor"", e);\r\n', 'commenter': 'oscerd'}, {'comment': 'Same problem as the master PR', 'commenter': 'davsclaus'}, {'comment': 'I have corrected this in a separate error commit', 'commenter': 'forsthofer'}, {'comment': 'I have corrected this in a further commit', 'commenter': 'forsthofer'}]"
5069,camel-core/src/main/java/org/apache/camel/converter/stream/CipherPair.java,"@@ -61,7 +60,18 @@ public Cipher getEncryptor() {
         return enccipher;
     }
     
+    /**
+     * Create the decryptor every time because the decryptor is not thead safe. For example, if you reuse the decryptor
+     * instance in the Multi-cast case then you will get errors.
+     */
     public Cipher getDecryptor() {
-        return deccipher;
+        try {
+            Cipher deccipher = Cipher.getInstance(transformation);
+            deccipher.init(Cipher.DECRYPT_MODE, key, ivp == null ? null : new IvParameterSpec(ivp));
+            return deccipher;
+        } catch (GeneralSecurityException e) {
+            // should not happen
+            throw new IllegalStateException(""Could not instanciate decryptor, e"");","[{'comment': 'It should be\r\n\r\nthrow new IllegalStateException(""Could not instanciate decryptor"", e);', 'commenter': 'oscerd'}, {'comment': 'I have corrected this in a separate commit', 'commenter': 'forsthofer'}]"
5069,camel-core/src/test/java/org/apache/camel/processor/MultiCastParallelAndStreamCachingWithEncryptionTest.java,"@@ -0,0 +1,113 @@
+/*","[{'comment': 'I think in Camel 2.x the license header may have 2 x stars in the beginning.\r\n\r\nCan you run checkstyle\r\n\r\nmvn compile -P sourcecheck\r\n\r\nAnd verify', 'commenter': 'davsclaus'}, {'comment': 'I added the extra star', 'commenter': 'forsthofer'}]"
5085,components/camel-google-storage/pom.xml,"@@ -0,0 +1,126 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one or more
+    contributor license agreements.  See the NOTICE file distributed with
+    this work for additional information regarding copyright ownership.
+    The ASF licenses this file to You under the Apache License, Version 2.0
+    (the ""License""); you may not use this file except in compliance with
+    the License.  You may obtain a copy of the License at
+
+         http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an ""AS IS"" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+
+-->
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>org.apache.camel</groupId>
+    <artifactId>components</artifactId>
+    <version>3.9.0-SNAPSHOT</version>
+  </parent>
+
+  <artifactId>camel-google-storage</artifactId>
+  <packaging>jar</packaging>
+  <name>Camel :: Google Storage</name>
+  <description>Camel Component for Google Cloud Platform Storage</description>
+
+  <properties>
+    <firstVersion>3.8.0</firstVersion>","[{'comment': 'This should be 3.9.0', 'commenter': 'oscerd'}]"
5085,components/camel-google-storage/src/generated/resources/google-storage.json,"@@ -0,0 +1,14 @@
+{
+  ""other"": {
+    ""kind"": ""other"",
+    ""name"": ""google-storage"",
+    ""title"": ""Google Storage"",
+    ""description"": ""Camel Component for Google Cloud Platform Storage"",
+    ""deprecated"": false,
+    ""firstVersion"": ""3.8.0"",","[{'comment': 'This will be re-generated again once firstVersion will be 3.9.0', 'commenter': 'oscerd'}, {'comment': 'done', 'commenter': 'marcelloraffaele'}]"
5085,components/camel-google-storage/src/main/java/org/apache/camel/component/google/storage/GoogleCloudStorageComponentConfiguration.java,"@@ -0,0 +1,239 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.google.storage;
+
+import com.google.cloud.storage.Storage;
+import com.google.cloud.storage.StorageClass;
+import org.apache.camel.RuntimeCamelException;
+import org.apache.camel.spi.Metadata;
+import org.apache.camel.spi.UriParam;
+import org.apache.camel.spi.UriParams;
+import org.apache.camel.spi.UriPath;
+
+@UriParams
+public class GoogleCloudStorageComponentConfiguration implements Cloneable {
+
+    @UriPath(label = ""common"", description = ""Bucket name or ARN"")
+    @Metadata(required = true)
+    private String bucketName;
+
+    @UriParam(label = ""common"", description = ""Service account key to authenticate an application as a service account"")
+    private String serviceAccountKey;
+
+    @UriParam(label = ""producer"",
+              enums = ""copyObject,listObjects,deleteObject,deleteBucket,listBuckets,getObject,createDownloadLink"")
+    private GoogleCloudStorageComponentOperations operation;
+
+    @UriParam(label = ""producer"", description = ""The Object name inside the bucket"")
+    private String objectName;
+
+    @UriParam(label = ""common"", defaultValue = ""US-EAST1"",
+              description = ""The Cloud Storage location to use when creating the new buckets"")
+    private String storageLocation = ""US-EAST1"";
+
+    @UriParam(label = ""common"", defaultValue = ""STANDARD"",
+              description = ""The Cloud Storage class to use when creating the new buckets"")
+    private StorageClass storageClass = StorageClass.STANDARD;
+
+    @UriParam(label = ""common"", defaultValue = ""true"")
+    private boolean autoCreateBucket = true;
+
+    @UriParam(label = ""consumer"")
+    private boolean moveAfterRead;
+
+    @UriParam(label = ""consumer"")
+    private String destinationBucket;
+
+    @UriParam(label = ""consumer"", defaultValue = ""true"")
+    private boolean deleteAfterRead = true;
+
+    @UriParam(label = ""consumer"", defaultValue = ""true"")
+    private boolean includeBody = true;
+
+    @UriParam(label = ""consumer"", defaultValue = ""true"")
+    private boolean includeFolders = true;
+
+    @UriParam
+    private Storage storageClient;","[{'comment': 'This should be autowired (one of the possible metadata of uriparam), in this way if we have a storage client instance in the registry it will be used ootb.', 'commenter': 'oscerd'}, {'comment': 'done', 'commenter': 'marcelloraffaele'}]"
5085,components/camel-google-storage/src/main/java/org/apache/camel/component/google/storage/GoogleCloudStorageConsumer.java,"@@ -0,0 +1,260 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.google.storage;
+
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Queue;
+
+import com.google.cloud.storage.Blob;
+import com.google.cloud.storage.BlobId;
+import com.google.cloud.storage.Bucket;
+import com.google.cloud.storage.CopyWriter;
+import com.google.cloud.storage.Storage;
+import com.google.cloud.storage.Storage.CopyRequest;
+import org.apache.camel.AsyncCallback;
+import org.apache.camel.Exchange;
+import org.apache.camel.ExtendedExchange;
+import org.apache.camel.Processor;
+import org.apache.camel.spi.Synchronization;
+import org.apache.camel.support.ScheduledBatchPollingConsumer;
+import org.apache.camel.util.CastUtils;
+import org.apache.camel.util.ObjectHelper;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class GoogleCloudStorageConsumer extends ScheduledBatchPollingConsumer {
+
+    private static final Logger LOG = LoggerFactory.getLogger(GoogleCloudStorageConsumer.class);
+
+    //private String marker;","[{'comment': 'can this be removed?  ', 'commenter': 'omarsmak'}]"
5085,components/camel-google-storage/src/main/java/org/apache/camel/component/google/storage/GoogleCloudStorageConsumer.java,"@@ -0,0 +1,260 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.google.storage;
+
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Queue;
+
+import com.google.cloud.storage.Blob;
+import com.google.cloud.storage.BlobId;
+import com.google.cloud.storage.Bucket;
+import com.google.cloud.storage.CopyWriter;
+import com.google.cloud.storage.Storage;
+import com.google.cloud.storage.Storage.CopyRequest;
+import org.apache.camel.AsyncCallback;
+import org.apache.camel.Exchange;
+import org.apache.camel.ExtendedExchange;
+import org.apache.camel.Processor;
+import org.apache.camel.spi.Synchronization;
+import org.apache.camel.support.ScheduledBatchPollingConsumer;
+import org.apache.camel.util.CastUtils;
+import org.apache.camel.util.ObjectHelper;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class GoogleCloudStorageConsumer extends ScheduledBatchPollingConsumer {
+
+    private static final Logger LOG = LoggerFactory.getLogger(GoogleCloudStorageConsumer.class);
+
+    //private String marker;
+    //private transient String consumerToString;
+
+    public GoogleCloudStorageConsumer(GoogleCloudStorageEndpoint endpoint, Processor processor) {
+        super(endpoint, processor);
+    }
+
+    @Override
+    protected void doStart() throws Exception {
+        super.doStart();
+
+        if (getConfiguration().isMoveAfterRead()) {
+
+            Bucket bucket = getStorageClient().get(getConfiguration().getDestinationBucket());
+            if (bucket != null) {
+                LOG.trace(""Bucket [{}] already exists"", bucket.getName());
+                return;
+            } else {
+                LOG.trace(""Destination Bucket [{}] doesn't exist yet"", getConfiguration().getDestinationBucket());
+                if (getConfiguration().isAutoCreateBucket()) {
+                    // creates the new bucket because it doesn't exist yet
+                    GoogleCloudStorageEndpoint.createNewBucket(getConfiguration().getDestinationBucket(), getConfiguration(),
+                            getStorageClient());
+                }
+            }
+
+        }
+    }
+
+    @Override
+    protected int poll() throws Exception {
+        // must reset for each poll
+        shutdownRunningTask = null;
+        pendingExchanges = 0;
+
+        String fileName = getConfiguration().getObjectName();
+        String bucketName = getConfiguration().getBucketName();
+        Queue<Exchange> exchanges = new LinkedList<>();
+
+        if (fileName != null) {
+            LOG.trace(""Getting object in bucket [{}] with file name [{}]..."", bucketName, fileName);
+
+            Blob blob = getStorageClient().get(bucketName, fileName);
+
+            exchanges = createExchanges(blob, fileName);
+        } else {
+            LOG.trace(""Queueing objects in bucket [{}]..."", bucketName);
+
+            List<Blob> bloblist = new LinkedList<>();
+            for (Blob blob : getStorageClient().list(bucketName).iterateAll()) {
+                bloblist.add(blob);
+            }
+
+            if (LOG.isTraceEnabled()) {
+                LOG.trace(""Found {} objects in bucket [{}]..."", bloblist.size(), bucketName);
+            }
+
+            exchanges = createExchanges(bloblist);
+        }
+
+        return processBatch(CastUtils.cast(exchanges));
+    }
+
+    protected Queue<Exchange> createExchanges(Blob blob, String key) {
+        Queue<Exchange> answer = new LinkedList<>();
+        Exchange exchange = getEndpoint().createExchange(blob, key);
+        answer.add(exchange);
+        return answer;
+    }
+
+    protected Queue<Exchange> createExchanges(List<Blob> blobList) {
+        if (LOG.isTraceEnabled()) {
+            LOG.trace(""Received {} messages in this poll"", blobList.size());
+        }
+
+        Queue<Exchange> answer = new LinkedList<>();
+        try {
+            for (Blob blob : blobList) {
+
+                if (includeObject(blob)) {
+                    Exchange exchange = getEndpoint().createExchange(blob, blob.getBlobId().getName());
+                    answer.add(exchange);
+                }
+
+            }
+        } catch (Exception e) {
+            LOG.warn(""Error getting object due: {}"", e.getMessage(), e);
+            throw e;
+        }
+
+        return answer;
+    }
+
+    /**
+     * Decide whether to include the Objects in the results
+     *
+     * @param  Object
+     * @return        true to include, false to exclude
+     */
+    protected boolean includeObject(Blob blob) {
+
+        if (getConfiguration().isIncludeFolders()) {
+            return true;
+        }
+        // Config says to ignore folders/directories
+        return blob.getName().endsWith(""/"");
+    }
+
+    @Override
+    public int processBatch(Queue<Object> exchanges) throws Exception {
+        int total = exchanges.size();
+
+        for (int index = 0; index < total && isBatchAllowed(); index++) {
+            // only loop if we are started (allowed to run)
+            final Exchange exchange = ObjectHelper.cast(Exchange.class, exchanges.poll());
+            // add current index and total as properties
+            exchange.setProperty(Exchange.BATCH_INDEX, index);
+            exchange.setProperty(Exchange.BATCH_SIZE, total);
+            exchange.setProperty(Exchange.BATCH_COMPLETE, index == total - 1);
+
+            // update pending number of exchanges
+            pendingExchanges = total - index - 1;
+
+            // add on completion to handle after work when the exchange is done
+            exchange.adapt(ExtendedExchange.class).addOnCompletion(new Synchronization() {
+                public void onComplete(Exchange exchange) {
+                    processCommit(exchange);
+                }
+
+                public void onFailure(Exchange exchange) {
+                    processRollback(exchange);
+                }
+
+                @Override
+                public String toString() {
+                    return ""ConsumerOnCompletion"";
+                }
+            });
+
+            LOG.trace(""Processing exchange [{}]..."", exchange);
+            getAsyncProcessor().process(exchange, new AsyncCallback() {
+                @Override
+                public void done(boolean doneSync) {
+                    LOG.trace(""Processing exchange [{}] done."", exchange);
+                }
+            });
+        }
+
+        return total;
+    }
+
+    /**
+     * Strategy to delete the message after being processed.
+     *
+     * @param exchange the exchange
+     */
+    protected void processCommit(Exchange exchange) {
+        //LOG.info(""processCommit"");","[{'comment': 'unused comment', 'commenter': 'omarsmak'}]"
5121,components/camel-slack/src/main/java/org/apache/camel/component/slack/SlackComponentVerifierExtension.java,"@@ -118,23 +101,12 @@ private void verifyCredentials(ResultBuilder builder, Map<String, Object> parame
             String token = (String) parameters.get(""token"");
 
             try {
-                HttpClient client = HttpClientBuilder.create().useSystemProperties().build();
-                HttpPost httpPost = new HttpPost(parameters.get(""serverUrl"") + ""/api/conversations.list"");
-
-                List<BasicNameValuePair> params = new ArrayList<>();
-                params.add(new BasicNameValuePair(""token"", token));
-                httpPost.setEntity(new UrlEncodedFormEntity(params));
+                ConversationsListResponse response = Slack.getInstance(new CustomSlackHttpClient()).methods(token)
+                        .conversationsList(req -> req
+                                .types(Collections.singletonList(ConversationType.PUBLIC_CHANNEL))","[{'comment': 'If we only have private channels, does still return `200`?', 'commenter': 'omarsmak'}, {'comment': 'Very good question, I created an empty Slack workspace and for now it\'s impossible to remove all public channel. You can\'t delete the general one. \r\n\r\nSo I tried with the opposite side, asked to list all private channels without having any and it replies 200 with this : \r\n```\r\n{\r\n    ""ok"": true,\r\n    ""channels"": [],\r\n    ""response_metadata"": {\r\n        ""next_cursor"": """"\r\n    }\r\n}\r\n```', 'commenter': 'Kinae'}, {'comment': ""so I guess, it doesn't really makes difference since we just want to check if the token is valid "", 'commenter': 'omarsmak'}]"
5121,components/camel-slack/src/main/java/org/apache/camel/component/slack/SlackConstants.java,"@@ -16,6 +16,7 @@
  */
 package org.apache.camel.component.slack;
 
+@Deprecated","[{'comment': ""These constants before used to build the Json request to Slack APIs, isn't? Is there any reason to deprecate them instead of removing this class entirely?  "", 'commenter': 'omarsmak'}, {'comment': 'Yes but the class is public instead of package only so I was not sure about removing it. Maybe some used them in their code to do something. ', 'commenter': 'Kinae'}, {'comment': 'okay we can keep it for one version and then remove it', 'commenter': 'omarsmak'}]"
5121,components/camel-slack/src/main/java/org/apache/camel/component/slack/SlackConsumer.java,"@@ -17,102 +17,90 @@
 package org.apache.camel.component.slack;
 
 import java.io.IOException;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.Iterator;
+import java.util.Collections;
 import java.util.LinkedList;
 import java.util.List;
 import java.util.Queue;
 
+import com.slack.api.Slack;
+import com.slack.api.methods.SlackApiException;
+import com.slack.api.methods.response.conversations.ConversationsHistoryResponse;
+import com.slack.api.methods.response.conversations.ConversationsListResponse;
+import com.slack.api.model.Conversation;
+import com.slack.api.model.Message;
 import org.apache.camel.Exchange;
-import org.apache.camel.Message;
 import org.apache.camel.Processor;
 import org.apache.camel.RuntimeCamelException;
-import org.apache.camel.component.slack.helper.SlackMessage;
 import org.apache.camel.support.ScheduledBatchPollingConsumer;
 import org.apache.camel.util.CastUtils;
 import org.apache.camel.util.ObjectHelper;
-import org.apache.camel.util.json.DeserializationException;
-import org.apache.camel.util.json.JsonArray;
-import org.apache.camel.util.json.JsonObject;
-import org.apache.camel.util.json.Jsoner;
-import org.apache.http.HttpResponse;
-import org.apache.http.client.entity.UrlEncodedFormEntity;
-import org.apache.http.client.methods.HttpPost;
-import org.apache.http.impl.client.CloseableHttpClient;
-import org.apache.http.impl.client.HttpClientBuilder;
-import org.apache.http.message.BasicNameValuePair;
-
-import static org.apache.camel.component.slack.utils.SlackUtils.readResponse;
 
 public class SlackConsumer extends ScheduledBatchPollingConsumer {
 
-    private SlackEndpoint slackEndpoint;
+    private final SlackEndpoint slackEndpoint;
+    private Slack slack;
     private String timestamp;
     private String channelId;
-    private CloseableHttpClient client;
 
-    public SlackConsumer(SlackEndpoint endpoint, Processor processor) throws IOException, DeserializationException {
+    public SlackConsumer(SlackEndpoint endpoint, Processor processor) {
         super(endpoint, processor);
         this.slackEndpoint = endpoint;
     }
 
     @Override
     protected void doStart() throws Exception {
-        this.client = HttpClientBuilder.create().useSystemProperties().build();
+        this.slack = Slack.getInstance();","[{'comment': 'This instance of the client, differs from the one that was used in the verifier whereby the `CustomSlackHttpClient`, is this intentional?\r\n', 'commenter': 'omarsmak'}, {'comment': 'Mistake, thank you !', 'commenter': 'Kinae'}]"
5121,components/camel-slack/src/main/java/org/apache/camel/component/slack/SlackConsumer.java,"@@ -141,68 +129,40 @@ public int processBatch(Queue<Object> exchanges) throws Exception {
         return total;
     }
 
-    private String getChannelId(String channel) throws IOException, DeserializationException {
-        HttpPost httpPost = new HttpPost(slackEndpoint.getServerUrl() + ""/api/conversations.list"");
-
-        List<BasicNameValuePair> params = new ArrayList<>();
-        params.add(new BasicNameValuePair(""token"", slackEndpoint.getToken()));
-        httpPost.setEntity(new UrlEncodedFormEntity(params));
-
-        HttpResponse response = client.execute(httpPost);
-
-        String jsonString = readResponse(response);
-        JsonObject c = (JsonObject) Jsoner.deserialize(jsonString);
-
-        checkSlackReply(c);
-
-        Collection<JsonObject> channels = c.getCollection(""channels"");
-        if (channels == null) {
-            throw new RuntimeCamelException(""The response was successful but no channel list was provided"");
-        }
-
-        for (JsonObject singleChannel : channels) {
-            if (singleChannel.get(""name"") != null) {
-                if (singleChannel.get(""name"").equals(channel)) {
-                    if (singleChannel.get(""id"") != null) {
-                        return (String) singleChannel.get(""id"");
-                    }
-                }
+    private String getChannelId(final String channel, final String cursor) {
+        try {
+            // Maximum limit is 1000. Slack recommends no more than 200 results at a time.
+            // https://api.slack.com/methods/conversations.list
+            ConversationsListResponse response = slack.methods(slackEndpoint.getToken()).conversationsList(req -> req
+                    .types(Collections.singletonList(slackEndpoint.getConversationType()))
+                    .cursor(cursor)
+                    .limit(200));","[{'comment': ""Can we move the limit number into a constant somewhere? Let's say this class"", 'commenter': 'omarsmak'}, {'comment': 'done', 'commenter': 'Kinae'}]"
5121,components/camel-slack/src/main/java/org/apache/camel/component/slack/SlackConsumer.java,"@@ -141,68 +129,40 @@ public int processBatch(Queue<Object> exchanges) throws Exception {
         return total;
     }
 
-    private String getChannelId(String channel) throws IOException, DeserializationException {
-        HttpPost httpPost = new HttpPost(slackEndpoint.getServerUrl() + ""/api/conversations.list"");
-
-        List<BasicNameValuePair> params = new ArrayList<>();
-        params.add(new BasicNameValuePair(""token"", slackEndpoint.getToken()));
-        httpPost.setEntity(new UrlEncodedFormEntity(params));
-
-        HttpResponse response = client.execute(httpPost);
-
-        String jsonString = readResponse(response);
-        JsonObject c = (JsonObject) Jsoner.deserialize(jsonString);
-
-        checkSlackReply(c);
-
-        Collection<JsonObject> channels = c.getCollection(""channels"");
-        if (channels == null) {
-            throw new RuntimeCamelException(""The response was successful but no channel list was provided"");
-        }
-
-        for (JsonObject singleChannel : channels) {
-            if (singleChannel.get(""name"") != null) {
-                if (singleChannel.get(""name"").equals(channel)) {
-                    if (singleChannel.get(""id"") != null) {
-                        return (String) singleChannel.get(""id"");
-                    }
-                }
+    private String getChannelId(final String channel, final String cursor) {
+        try {
+            // Maximum limit is 1000. Slack recommends no more than 200 results at a time.
+            // https://api.slack.com/methods/conversations.list
+            ConversationsListResponse response = slack.methods(slackEndpoint.getToken()).conversationsList(req -> req
+                    .types(Collections.singletonList(slackEndpoint.getConversationType()))
+                    .cursor(cursor)
+                    .limit(200));
+
+            if (!response.isOk()) {
+                throw new RuntimeCamelException(""API request conversations.list to Slack failed: "" + response);
             }
-        }
 
-        return jsonString;
+            return response.getChannels().stream()
+                    .filter(it -> it.getName().equals(channel))
+                    .map(Conversation::getId)
+                    .findFirst().orElseGet(() -> {
+                        if (isNullOrEmpty(response.getResponseMetadata().getNextCursor())) {
+                            throw new RuntimeCamelException(String.format(""Channel %s not found"", channel));
+                        }
+                        return getChannelId(channel, response.getResponseMetadata().getNextCursor());
+                    });
+        } catch (IOException | SlackApiException e) {
+            throw new RuntimeCamelException(""API request conversations.list to Slack failed"", e);
+        }
     }
 
-    private void checkSlackReply(JsonObject c) {
-        boolean okStatus = c.getBoolean(""ok"");
-
-        if (!okStatus) {
-            String errorMessage = c.getString(""error"");
-
-            if (errorMessage == null || errorMessage.isEmpty()) {
-                errorMessage = ""the slack server did not provide error details"";
-            }
-
-            throw new RuntimeCamelException(String.format(""API request to Slack failed: %s"", errorMessage));
-        }
+    private static boolean isNullOrEmpty(String str) {
+        return str == null || str.isEmpty();","[{'comment': 'You can use `ObjectHelper.isNotEmpty()` in `org.apache.camel.util` to check for empty strings as well nulls', 'commenter': 'omarsmak'}, {'comment': 'Yes ! thank you', 'commenter': 'Kinae'}]"
5121,catalog/camel-catalog/src/generated/resources/org/apache/camel/catalog/docs/slack-component.adoc,"@@ -164,6 +168,35 @@ A CamelContext with Blueprint could be as:
 </blueprint>
 ---------------------------------------------------------------------------------------------------------------------------
 
+== Producer
+
+*Since Camel 3.9.0* +","[{'comment': 'The since is not needed here. The documentation will be only for latest, so just remove the since, because the documentation is versioned', 'commenter': 'oscerd'}, {'comment': 'Remove the since here, the other part will be re-generated', 'commenter': 'oscerd'}]"
5121,components/camel-slack/src/main/docs/slack-component.adoc,"@@ -180,6 +213,15 @@ You'll need to create a Slack app and use it on your workspace.
 
 Use the 'Bot User OAuth Access Token' as token for the consumer endpoint.
 
-IMPORTANT: Add the `channels:history` and `channels:read` user token scope to your app to grant it permission to view messages in the user's public channels.
+IMPORTANT: Add the corresponding history (`channels:history` or `groups:history` or `mpim:history` or `im:history`) and
+read (`channels:read` or `groups:read` or `mpim:read` or `im:read`) user token scope to your app to grant it permission to
+view messages in the corresponding channel. You will need to use the conversationType option to set it up too (`PUBLIC_CHANNEL`, `PRIVATE_CHANNEL`, `MPIM`, `IM`)
+
+*Since Camel 3.9.0* +","[{'comment': 'Same', 'commenter': 'oscerd'}]"
5177,components/camel-mongodb/src/main/java/org/apache/camel/component/mongodb/converters/MongoDbBasicConverters.java,"@@ -119,6 +119,9 @@ private static boolean isBson(byte[] input) {
 
     @Converter","[{'comment': 'We need to make @Converter(allowNull = true) as the converter can return null as a valid response', 'commenter': 'davsclaus'}, {'comment': 'In this case it should be considered be a _miss_. According the [documentation](https://camel.apache.org/manual/latest/type-converter.html#TypeConverter-Returningnullvalues), this would be the way to handle.', 'commenter': 'squakez'}, {'comment': 'Yes can you add that fix', 'commenter': 'davsclaus'}, {'comment': ""I did not explain myself properly, sorry. I was meaning that according the documentation, when the converted value is expected to be a _miss_ then `null` should be returned. If `null` is allowed to be a valid response, then, we should include the annotation as you said. In this case, `null` won't be a valid response, but just a _miss_, so I understand that the annotation is not needed. At least, this is what I understood from the doc, or am I misunderstanding something?"", 'commenter': 'squakez'}, {'comment': 'Yes you misunderstod. A miss is regarded as a from -> to combo that should not be attempted anymore in the future (miss). ', 'commenter': 'davsclaus'}, {'comment': ""Thanks for clarifying. I've just pushed the change."", 'commenter': 'squakez'}]"
5205,components/camel-google/camel-google-functions/pom.xml,"@@ -0,0 +1,144 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one or more
+    contributor license agreements.  See the NOTICE file distributed with
+    this work for additional information regarding copyright ownership.
+    The ASF licenses this file to You under the Apache License, Version 2.0
+    (the ""License""); you may not use this file except in compliance with
+    the License.  You may obtain a copy of the License at
+
+         http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an ""AS IS"" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+
+-->
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>org.apache.camel</groupId>
+    <artifactId>camel-google-parent</artifactId>
+    <version>3.9.0-SNAPSHOT</version>
+  </parent>
+
+  <artifactId>camel-google-functions</artifactId>
+  <packaging>jar</packaging>
+  <name>Camel :: Google Functions</name>
+  <description>Camel Component for Google Cloud Platform Functions</description>
+
+  <properties>
+    <firstVersion>3.9.0</firstVersion>
+    <google-cloud-functions-version>1.0.8</google-cloud-functions-version>","[{'comment': 'This should move to the parent pom', 'commenter': 'omarsmak'}, {'comment': 'Wonder if we can do like some of the other Google components and import the `libraries-bom`? E.g like here:\r\n\r\nhttps://github.com/apache/camel/blob/master/components/camel-google/camel-google-pubsub/pom.xml#L49-L55', 'commenter': 'jamesnetherton'}]"
5205,components/camel-google/camel-google-functions/pom.xml,"@@ -0,0 +1,144 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one or more
+    contributor license agreements.  See the NOTICE file distributed with
+    this work for additional information regarding copyright ownership.
+    The ASF licenses this file to You under the Apache License, Version 2.0
+    (the ""License""); you may not use this file except in compliance with
+    the License.  You may obtain a copy of the License at
+
+         http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an ""AS IS"" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+
+-->
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>org.apache.camel</groupId>
+    <artifactId>camel-google-parent</artifactId>
+    <version>3.9.0-SNAPSHOT</version>
+  </parent>
+
+  <artifactId>camel-google-functions</artifactId>
+  <packaging>jar</packaging>
+  <name>Camel :: Google Functions</name>
+  <description>Camel Component for Google Cloud Platform Functions</description>
+
+  <properties>
+    <firstVersion>3.9.0</firstVersion>
+    <google-cloud-functions-version>1.0.8</google-cloud-functions-version>
+  </properties>
+
+  <dependencyManagement>
+    <dependencies>
+      <!-- Override the android JDK 7 guava in libraries-bom -->
+      <dependency>
+        <groupId>com.google.guava</groupId>
+        <artifactId>guava</artifactId>
+        <version>${google-cloud-guava-version}</version>
+      </dependency>
+      <dependency>
+        <groupId>com.google.cloud</groupId>
+        <artifactId>google-cloud-functions-bom</artifactId>
+        <version>${google-cloud-functions-version}</version>
+        <type>pom</type>
+        <scope>import</scope>
+      </dependency>
+    </dependencies>
+  
+  </dependencyManagement>
+
+  <dependencies>
+    <dependency>
+      <groupId>org.apache.camel</groupId>
+      <artifactId>camel-support</artifactId>
+    </dependency>
+    
+    <dependency>
+      <groupId>com.google.guava</groupId>
+      <artifactId>guava</artifactId>
+    </dependency>
+    <dependency>
+      <groupId>com.google.cloud</groupId>
+      <artifactId>google-cloud-functions</artifactId>
+    </dependency>
+    <dependency>
+      <groupId>com.google.api.grpc</groupId>
+      <artifactId>grpc-google-cloud-functions-v1</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>com.google.api</groupId>
+      <artifactId>gax-grpc</artifactId>
+      <classifier>testlib</classifier>
+      <version>1.62.0</version>","[{'comment': 'this version as well should move to the parent pom', 'commenter': 'omarsmak'}]"
5205,components/camel-google/camel-google-functions/src/main/java/org/apache/camel/component/google/functions/GoogleCloudFunctionsComponent.java,"@@ -0,0 +1,57 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.google.functions;
+
+import java.util.Map;
+
+import org.apache.camel.CamelContext;
+import org.apache.camel.Endpoint;
+import org.apache.camel.spi.Metadata;
+import org.apache.camel.spi.annotations.Component;
+import org.apache.camel.support.DefaultComponent;
+
+@Component(""google-functions"")
+public class GoogleCloudFunctionsComponent extends DefaultComponent {
+
+    @Metadata
+    private GoogleCloudFunctionsConfiguration configuration = new GoogleCloudFunctionsConfiguration();
+
+    public GoogleCloudFunctionsComponent() {
+        super(null);","[{'comment': 'is not needed, you can just remove `super(null)`', 'commenter': 'omarsmak'}, {'comment': 'Ok, I remove it and leave only the default empty constructor', 'commenter': 'marcelloraffaele'}]"
5205,components/camel-google/camel-google-functions/src/main/java/org/apache/camel/component/google/functions/GoogleCloudFunctionsEndpoint.java,"@@ -0,0 +1,113 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.google.functions;
+
+import java.io.FileInputStream;
+
+import com.google.api.client.util.Strings;
+import com.google.api.gax.core.FixedCredentialsProvider;
+import com.google.auth.Credentials;
+import com.google.auth.oauth2.ServiceAccountCredentials;
+import com.google.cloud.functions.v1.CloudFunctionsServiceClient;
+import com.google.cloud.functions.v1.CloudFunctionsServiceSettings;
+import org.apache.camel.Category;
+import org.apache.camel.Consumer;
+import org.apache.camel.Processor;
+import org.apache.camel.Producer;
+import org.apache.camel.spi.UriEndpoint;
+import org.apache.camel.spi.UriParam;
+import org.apache.camel.support.DefaultEndpoint;
+
+/**
+ * Store and retrieve objects from Google Cloud Functions Service using the google-cloud-storage library.
+ * 
+ * Google Functions Endpoint definition represents a function within the GCP and contains configuration to customize the
+ * behavior of Producer.
+ */
+@UriEndpoint(firstVersion = ""3.9.0"", scheme = ""google-functions"", title = ""GoogleCloudFunctions"",
+             syntax = ""google-functions:functionName"", category = {
+                     Category.CLOUD },
+             producerOnly = true)
+public class GoogleCloudFunctionsEndpoint extends DefaultEndpoint {
+
+    @UriParam
+    private GoogleCloudFunctionsConfiguration configuration;
+
+    private CloudFunctionsServiceClient cloudFunctionsClient;
+
+    public GoogleCloudFunctionsEndpoint(String uri, GoogleCloudFunctionsComponent component,
+                                        GoogleCloudFunctionsConfiguration configuration) {
+        super(uri, component);
+        this.configuration = configuration;
+    }
+
+    public Producer createProducer() throws Exception {
+        return new GoogleCloudFunctionsProducer(this);
+    }
+
+    public Consumer createConsumer(Processor processor) throws Exception {
+        throw new UnsupportedOperationException(
+                ""Cannot consume from the google-functions endpoint: "" + getEndpointUri());
+    }
+
+    public GoogleCloudFunctionsConfiguration getConfiguration() {
+        return configuration;
+    }
+
+    /**
+     * Setup configuration
+     */
+    public void setConfiguration(GoogleCloudFunctionsConfiguration configuration) {
+        this.configuration = configuration;
+    }
+
+    @Override
+    protected void doStart() throws Exception {
+        super.doStart();
+        if (configuration.getClient() != null) {
+            cloudFunctionsClient = configuration.getClient();
+        } else {
+            if (!Strings.isNullOrEmpty(configuration.getServiceAccountKey())) {","[{'comment': 'Can we move the chunk that creates the client into a factory or function?', 'commenter': 'omarsmak'}]"
5205,components/camel-google/camel-google-functions/src/main/java/org/apache/camel/component/google/functions/GoogleCloudFunctionsEndpoint.java,"@@ -0,0 +1,113 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.google.functions;
+
+import java.io.FileInputStream;
+
+import com.google.api.client.util.Strings;
+import com.google.api.gax.core.FixedCredentialsProvider;
+import com.google.auth.Credentials;
+import com.google.auth.oauth2.ServiceAccountCredentials;
+import com.google.cloud.functions.v1.CloudFunctionsServiceClient;
+import com.google.cloud.functions.v1.CloudFunctionsServiceSettings;
+import org.apache.camel.Category;
+import org.apache.camel.Consumer;
+import org.apache.camel.Processor;
+import org.apache.camel.Producer;
+import org.apache.camel.spi.UriEndpoint;
+import org.apache.camel.spi.UriParam;
+import org.apache.camel.support.DefaultEndpoint;
+
+/**
+ * Store and retrieve objects from Google Cloud Functions Service using the google-cloud-storage library.
+ * 
+ * Google Functions Endpoint definition represents a function within the GCP and contains configuration to customize the
+ * behavior of Producer.
+ */
+@UriEndpoint(firstVersion = ""3.9.0"", scheme = ""google-functions"", title = ""GoogleCloudFunctions"",
+             syntax = ""google-functions:functionName"", category = {
+                     Category.CLOUD },
+             producerOnly = true)
+public class GoogleCloudFunctionsEndpoint extends DefaultEndpoint {
+
+    @UriParam
+    private GoogleCloudFunctionsConfiguration configuration;
+
+    private CloudFunctionsServiceClient cloudFunctionsClient;
+
+    public GoogleCloudFunctionsEndpoint(String uri, GoogleCloudFunctionsComponent component,
+                                        GoogleCloudFunctionsConfiguration configuration) {
+        super(uri, component);
+        this.configuration = configuration;
+    }
+
+    public Producer createProducer() throws Exception {
+        return new GoogleCloudFunctionsProducer(this);
+    }
+
+    public Consumer createConsumer(Processor processor) throws Exception {
+        throw new UnsupportedOperationException(
+                ""Cannot consume from the google-functions endpoint: "" + getEndpointUri());
+    }
+
+    public GoogleCloudFunctionsConfiguration getConfiguration() {
+        return configuration;
+    }
+
+    /**
+     * Setup configuration
+     */
+    public void setConfiguration(GoogleCloudFunctionsConfiguration configuration) {
+        this.configuration = configuration;
+    }
+
+    @Override
+    protected void doStart() throws Exception {
+        super.doStart();
+        if (configuration.getClient() != null) {
+            cloudFunctionsClient = configuration.getClient();
+        } else {
+            if (!Strings.isNullOrEmpty(configuration.getServiceAccountKey())) {
+                Credentials myCredentials = ServiceAccountCredentials
+                        .fromStream(new FileInputStream(configuration.getServiceAccountKey()));
+                CloudFunctionsServiceSettings settings = CloudFunctionsServiceSettings.newBuilder()
+                        .setCredentialsProvider(FixedCredentialsProvider.create(myCredentials)).build();
+                cloudFunctionsClient = CloudFunctionsServiceClient.create(settings);
+            } else {
+                //it needs to define the  environment variable GOOGLE_APPLICATION_CREDENTIALS with the service account file
+                //more info at https://cloud.google.com/docs/authentication/production
+                CloudFunctionsServiceSettings settings = CloudFunctionsServiceSettings.newBuilder().build();
+                cloudFunctionsClient = CloudFunctionsServiceClient.create(settings);
+            }
+        }
+    }
+
+    @Override
+    protected void doStop() throws Exception {
+        super.doStop();
+        if (configuration.getClient() == null) {","[{'comment': '```suggestion\r\n        if (configuration.getClient() == null && cloudFunctionsClient != null) {\r\n```', 'commenter': 'omarsmak'}]"
5205,components/camel-google/camel-google-functions/src/main/java/org/apache/camel/component/google/functions/GoogleCloudFunctionsProducer.java,"@@ -0,0 +1,330 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.google.functions;
+
+import java.util.List;
+import java.util.concurrent.ExecutionException;
+
+import com.google.api.client.util.Lists;
+import com.google.api.gax.rpc.ApiException;
+import com.google.cloud.functions.v1.CallFunctionRequest;
+import com.google.cloud.functions.v1.CallFunctionResponse;
+import com.google.cloud.functions.v1.CloudFunction;
+import com.google.cloud.functions.v1.CloudFunctionName;
+import com.google.cloud.functions.v1.CloudFunctionsServiceClient;
+import com.google.cloud.functions.v1.CloudFunctionsServiceClient.ListFunctionsPagedResponse;
+import com.google.cloud.functions.v1.CreateFunctionRequest;
+import com.google.cloud.functions.v1.DeleteFunctionRequest;
+import com.google.cloud.functions.v1.GenerateDownloadUrlRequest;
+import com.google.cloud.functions.v1.GenerateDownloadUrlResponse;
+import com.google.cloud.functions.v1.GenerateUploadUrlRequest;
+import com.google.cloud.functions.v1.GenerateUploadUrlResponse;
+import com.google.cloud.functions.v1.HttpsTrigger;
+import com.google.cloud.functions.v1.ListFunctionsRequest;
+import com.google.cloud.functions.v1.LocationName;
+import com.google.cloud.functions.v1.UpdateFunctionRequest;
+import com.google.protobuf.Empty;
+import org.apache.camel.Exchange;
+import org.apache.camel.InvalidPayloadException;
+import org.apache.camel.Message;
+import org.apache.camel.support.DefaultProducer;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * The GoogleCloudFunctions producer.
+ */
+public class GoogleCloudFunctionsProducer extends DefaultProducer {
+    private static final Logger LOG = LoggerFactory.getLogger(GoogleCloudFunctionsProducer.class);
+
+    private GoogleCloudFunctionsEndpoint endpoint;
+
+    public GoogleCloudFunctionsProducer(GoogleCloudFunctionsEndpoint endpoint) {
+        super(endpoint);
+        this.endpoint = endpoint;
+    }
+
+    @Override
+    public void process(final Exchange exchange) throws Exception {
+        switch (determineOperation(exchange)) {
+            case listFunctions:
+                listFunctions(endpoint.getClient(), exchange);
+                break;
+            case getFunction:
+                getFunction(endpoint.getClient(), exchange);
+                break;
+            case callFunction:
+                callFunction(endpoint.getClient(), exchange);
+                break;
+            case generateDownloadUrl:
+                generateDownloadUrl(endpoint.getClient(), exchange);
+                break;
+            case generateUploadUrl:
+                generateUploadUrl(endpoint.getClient(), exchange);
+                break;
+            case createFunction:
+                createFunction(endpoint.getClient(), exchange);
+                break;
+            case updateFunction:
+                updateFunction(endpoint.getClient(), exchange);
+                break;
+            case deleteFunction:
+                deleteFunction(endpoint.getClient(), exchange);
+                break;
+
+            default:
+                throw new IllegalArgumentException(""Unsupported operation"");
+        }
+    }
+
+    private void listFunctions(CloudFunctionsServiceClient client, Exchange exchange) throws InvalidPayloadException {
+        if (getConfiguration().isPojoRequest()) {
+            Object payload = exchange.getIn().getMandatoryBody();
+            if (payload instanceof ListFunctionsRequest) {
+                ListFunctionsPagedResponse pagedListResponse;
+                try {
+                    pagedListResponse = client.listFunctions((ListFunctionsRequest) payload);
+                    List<CloudFunction> response = Lists.newArrayList(pagedListResponse.iterateAll());
+                    Message message = getMessageForResponse(exchange);
+                    message.setBody(response);
+                } catch (ApiException ae) {
+                    LOG.trace(""listFunctions command returned the error code {}"", ae.getStatusCode());
+                    throw ae;
+                }
+            }
+        } else {
+            ListFunctionsRequest request = ListFunctionsRequest.newBuilder()
+                    .setParent(LocationName.of(getConfiguration().getProject(), getConfiguration().getLocation())
+                            .toString())
+                    .setPageSize(883849137) // TODO check it","[{'comment': 'Can we move put this number into a constant?', 'commenter': 'omarsmak'}, {'comment': '@marcelloraffaele can you please put this into a constant?', 'commenter': 'omarsmak'}]"
5205,components/camel-google/camel-google-functions/src/main/java/org/apache/camel/component/google/functions/GoogleCloudFunctionsProducer.java,"@@ -0,0 +1,330 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.google.functions;
+
+import java.util.List;
+import java.util.concurrent.ExecutionException;
+
+import com.google.api.client.util.Lists;
+import com.google.api.gax.rpc.ApiException;
+import com.google.cloud.functions.v1.CallFunctionRequest;
+import com.google.cloud.functions.v1.CallFunctionResponse;
+import com.google.cloud.functions.v1.CloudFunction;
+import com.google.cloud.functions.v1.CloudFunctionName;
+import com.google.cloud.functions.v1.CloudFunctionsServiceClient;
+import com.google.cloud.functions.v1.CloudFunctionsServiceClient.ListFunctionsPagedResponse;
+import com.google.cloud.functions.v1.CreateFunctionRequest;
+import com.google.cloud.functions.v1.DeleteFunctionRequest;
+import com.google.cloud.functions.v1.GenerateDownloadUrlRequest;
+import com.google.cloud.functions.v1.GenerateDownloadUrlResponse;
+import com.google.cloud.functions.v1.GenerateUploadUrlRequest;
+import com.google.cloud.functions.v1.GenerateUploadUrlResponse;
+import com.google.cloud.functions.v1.HttpsTrigger;
+import com.google.cloud.functions.v1.ListFunctionsRequest;
+import com.google.cloud.functions.v1.LocationName;
+import com.google.cloud.functions.v1.UpdateFunctionRequest;
+import com.google.protobuf.Empty;
+import org.apache.camel.Exchange;
+import org.apache.camel.InvalidPayloadException;
+import org.apache.camel.Message;
+import org.apache.camel.support.DefaultProducer;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * The GoogleCloudFunctions producer.
+ */
+public class GoogleCloudFunctionsProducer extends DefaultProducer {
+    private static final Logger LOG = LoggerFactory.getLogger(GoogleCloudFunctionsProducer.class);
+
+    private GoogleCloudFunctionsEndpoint endpoint;
+
+    public GoogleCloudFunctionsProducer(GoogleCloudFunctionsEndpoint endpoint) {
+        super(endpoint);
+        this.endpoint = endpoint;
+    }
+
+    @Override
+    public void process(final Exchange exchange) throws Exception {
+        switch (determineOperation(exchange)) {
+            case listFunctions:
+                listFunctions(endpoint.getClient(), exchange);
+                break;
+            case getFunction:
+                getFunction(endpoint.getClient(), exchange);
+                break;
+            case callFunction:
+                callFunction(endpoint.getClient(), exchange);
+                break;
+            case generateDownloadUrl:
+                generateDownloadUrl(endpoint.getClient(), exchange);
+                break;
+            case generateUploadUrl:
+                generateUploadUrl(endpoint.getClient(), exchange);
+                break;
+            case createFunction:
+                createFunction(endpoint.getClient(), exchange);
+                break;
+            case updateFunction:
+                updateFunction(endpoint.getClient(), exchange);
+                break;
+            case deleteFunction:
+                deleteFunction(endpoint.getClient(), exchange);
+                break;
+
+            default:
+                throw new IllegalArgumentException(""Unsupported operation"");
+        }
+    }
+
+    private void listFunctions(CloudFunctionsServiceClient client, Exchange exchange) throws InvalidPayloadException {
+        if (getConfiguration().isPojoRequest()) {
+            Object payload = exchange.getIn().getMandatoryBody();
+            if (payload instanceof ListFunctionsRequest) {
+                ListFunctionsPagedResponse pagedListResponse;
+                try {
+                    pagedListResponse = client.listFunctions((ListFunctionsRequest) payload);
+                    List<CloudFunction> response = Lists.newArrayList(pagedListResponse.iterateAll());
+                    Message message = getMessageForResponse(exchange);
+                    message.setBody(response);
+                } catch (ApiException ae) {
+                    LOG.trace(""listFunctions command returned the error code {}"", ae.getStatusCode());
+                    throw ae;
+                }
+            }
+        } else {
+            ListFunctionsRequest request = ListFunctionsRequest.newBuilder()
+                    .setParent(LocationName.of(getConfiguration().getProject(), getConfiguration().getLocation())
+                            .toString())
+                    .setPageSize(883849137) // TODO check it
+                    .setPageToken(""pageToken873572522"").build();","[{'comment': 'is this page token fixed?', 'commenter': 'omarsmak'}, {'comment': 'It can be also random, is only a way to receive all the functions in the same list withoud pagination.', 'commenter': 'marcelloraffaele'}, {'comment': ""ah I see, then if you need to set this explicitly, let's just move it into constant  "", 'commenter': 'omarsmak'}, {'comment': '@marcelloraffaele this as well here', 'commenter': 'omarsmak'}]"
5205,components/camel-google/camel-google-functions/src/main/java/org/apache/camel/component/google/functions/GoogleCloudFunctionsProducer.java,"@@ -0,0 +1,330 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.google.functions;
+
+import java.util.List;
+import java.util.concurrent.ExecutionException;
+
+import com.google.api.client.util.Lists;
+import com.google.api.gax.rpc.ApiException;
+import com.google.cloud.functions.v1.CallFunctionRequest;
+import com.google.cloud.functions.v1.CallFunctionResponse;
+import com.google.cloud.functions.v1.CloudFunction;
+import com.google.cloud.functions.v1.CloudFunctionName;
+import com.google.cloud.functions.v1.CloudFunctionsServiceClient;
+import com.google.cloud.functions.v1.CloudFunctionsServiceClient.ListFunctionsPagedResponse;
+import com.google.cloud.functions.v1.CreateFunctionRequest;
+import com.google.cloud.functions.v1.DeleteFunctionRequest;
+import com.google.cloud.functions.v1.GenerateDownloadUrlRequest;
+import com.google.cloud.functions.v1.GenerateDownloadUrlResponse;
+import com.google.cloud.functions.v1.GenerateUploadUrlRequest;
+import com.google.cloud.functions.v1.GenerateUploadUrlResponse;
+import com.google.cloud.functions.v1.HttpsTrigger;
+import com.google.cloud.functions.v1.ListFunctionsRequest;
+import com.google.cloud.functions.v1.LocationName;
+import com.google.cloud.functions.v1.UpdateFunctionRequest;
+import com.google.protobuf.Empty;
+import org.apache.camel.Exchange;
+import org.apache.camel.InvalidPayloadException;
+import org.apache.camel.Message;
+import org.apache.camel.support.DefaultProducer;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * The GoogleCloudFunctions producer.
+ */
+public class GoogleCloudFunctionsProducer extends DefaultProducer {
+    private static final Logger LOG = LoggerFactory.getLogger(GoogleCloudFunctionsProducer.class);
+
+    private GoogleCloudFunctionsEndpoint endpoint;
+
+    public GoogleCloudFunctionsProducer(GoogleCloudFunctionsEndpoint endpoint) {
+        super(endpoint);
+        this.endpoint = endpoint;
+    }
+
+    @Override
+    public void process(final Exchange exchange) throws Exception {
+        switch (determineOperation(exchange)) {
+            case listFunctions:
+                listFunctions(endpoint.getClient(), exchange);
+                break;
+            case getFunction:
+                getFunction(endpoint.getClient(), exchange);
+                break;
+            case callFunction:
+                callFunction(endpoint.getClient(), exchange);
+                break;
+            case generateDownloadUrl:
+                generateDownloadUrl(endpoint.getClient(), exchange);
+                break;
+            case generateUploadUrl:
+                generateUploadUrl(endpoint.getClient(), exchange);
+                break;
+            case createFunction:
+                createFunction(endpoint.getClient(), exchange);
+                break;
+            case updateFunction:
+                updateFunction(endpoint.getClient(), exchange);
+                break;
+            case deleteFunction:
+                deleteFunction(endpoint.getClient(), exchange);
+                break;
+
+            default:
+                throw new IllegalArgumentException(""Unsupported operation"");
+        }
+    }
+
+    private void listFunctions(CloudFunctionsServiceClient client, Exchange exchange) throws InvalidPayloadException {
+        if (getConfiguration().isPojoRequest()) {
+            Object payload = exchange.getIn().getMandatoryBody();
+            if (payload instanceof ListFunctionsRequest) {
+                ListFunctionsPagedResponse pagedListResponse;
+                try {
+                    pagedListResponse = client.listFunctions((ListFunctionsRequest) payload);
+                    List<CloudFunction> response = Lists.newArrayList(pagedListResponse.iterateAll());
+                    Message message = getMessageForResponse(exchange);
+                    message.setBody(response);
+                } catch (ApiException ae) {
+                    LOG.trace(""listFunctions command returned the error code {}"", ae.getStatusCode());
+                    throw ae;
+                }
+            }
+        } else {
+            ListFunctionsRequest request = ListFunctionsRequest.newBuilder()
+                    .setParent(LocationName.of(getConfiguration().getProject(), getConfiguration().getLocation())
+                            .toString())
+                    .setPageSize(883849137) // TODO check it
+                    .setPageToken(""pageToken873572522"").build();
+            ListFunctionsPagedResponse pagedListResponse = client.listFunctions(request);
+            List<CloudFunction> response = Lists.newArrayList(pagedListResponse.iterateAll());
+            Message message = getMessageForResponse(exchange);
+            message.setBody(response);
+        }
+    }
+
+    private void getFunction(CloudFunctionsServiceClient client, Exchange exchange) throws InvalidPayloadException {
+        if (getConfiguration().isPojoRequest()) {","[{'comment': 'I see in almost every function, duplicated code to get the response from the client, one with POJO and one from the configurations, since both are the same, can you please refactor these functions to remove the duplication code in order to reduce the maintenance overhead?', 'commenter': 'omarsmak'}, {'comment': ""This is equal to what we are doing in AWS components, so we need to refactor there too. I'll take care of that."", 'commenter': 'oscerd'}, {'comment': 'Yes I replicated the AWS Lambda function code...', 'commenter': 'marcelloraffaele'}, {'comment': 'then we can refactor this now and then refactor AWS Lambda function code :) ', 'commenter': 'omarsmak'}]"
5205,components/camel-google/camel-google-functions/src/main/java/org/apache/camel/component/google/functions/GoogleCloudFunctionsProducer.java,"@@ -0,0 +1,330 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.google.functions;
+
+import java.util.List;
+import java.util.concurrent.ExecutionException;
+
+import com.google.api.client.util.Lists;
+import com.google.api.gax.rpc.ApiException;
+import com.google.cloud.functions.v1.CallFunctionRequest;
+import com.google.cloud.functions.v1.CallFunctionResponse;
+import com.google.cloud.functions.v1.CloudFunction;
+import com.google.cloud.functions.v1.CloudFunctionName;
+import com.google.cloud.functions.v1.CloudFunctionsServiceClient;
+import com.google.cloud.functions.v1.CloudFunctionsServiceClient.ListFunctionsPagedResponse;
+import com.google.cloud.functions.v1.CreateFunctionRequest;
+import com.google.cloud.functions.v1.DeleteFunctionRequest;
+import com.google.cloud.functions.v1.GenerateDownloadUrlRequest;
+import com.google.cloud.functions.v1.GenerateDownloadUrlResponse;
+import com.google.cloud.functions.v1.GenerateUploadUrlRequest;
+import com.google.cloud.functions.v1.GenerateUploadUrlResponse;
+import com.google.cloud.functions.v1.HttpsTrigger;
+import com.google.cloud.functions.v1.ListFunctionsRequest;
+import com.google.cloud.functions.v1.LocationName;
+import com.google.cloud.functions.v1.UpdateFunctionRequest;
+import com.google.protobuf.Empty;
+import org.apache.camel.Exchange;
+import org.apache.camel.InvalidPayloadException;
+import org.apache.camel.Message;
+import org.apache.camel.support.DefaultProducer;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * The GoogleCloudFunctions producer.
+ */
+public class GoogleCloudFunctionsProducer extends DefaultProducer {
+    private static final Logger LOG = LoggerFactory.getLogger(GoogleCloudFunctionsProducer.class);
+
+    private GoogleCloudFunctionsEndpoint endpoint;
+
+    public GoogleCloudFunctionsProducer(GoogleCloudFunctionsEndpoint endpoint) {
+        super(endpoint);
+        this.endpoint = endpoint;
+    }
+
+    @Override
+    public void process(final Exchange exchange) throws Exception {
+        switch (determineOperation(exchange)) {
+            case listFunctions:
+                listFunctions(endpoint.getClient(), exchange);
+                break;
+            case getFunction:
+                getFunction(endpoint.getClient(), exchange);
+                break;
+            case callFunction:
+                callFunction(endpoint.getClient(), exchange);
+                break;
+            case generateDownloadUrl:
+                generateDownloadUrl(endpoint.getClient(), exchange);
+                break;
+            case generateUploadUrl:
+                generateUploadUrl(endpoint.getClient(), exchange);
+                break;
+            case createFunction:
+                createFunction(endpoint.getClient(), exchange);
+                break;
+            case updateFunction:
+                updateFunction(endpoint.getClient(), exchange);
+                break;
+            case deleteFunction:
+                deleteFunction(endpoint.getClient(), exchange);
+                break;
+
+            default:
+                throw new IllegalArgumentException(""Unsupported operation"");
+        }
+    }
+
+    private void listFunctions(CloudFunctionsServiceClient client, Exchange exchange) throws InvalidPayloadException {
+        if (getConfiguration().isPojoRequest()) {
+            Object payload = exchange.getIn().getMandatoryBody();
+            if (payload instanceof ListFunctionsRequest) {
+                ListFunctionsPagedResponse pagedListResponse;
+                try {
+                    pagedListResponse = client.listFunctions((ListFunctionsRequest) payload);
+                    List<CloudFunction> response = Lists.newArrayList(pagedListResponse.iterateAll());
+                    Message message = getMessageForResponse(exchange);
+                    message.setBody(response);
+                } catch (ApiException ae) {
+                    LOG.trace(""listFunctions command returned the error code {}"", ae.getStatusCode());
+                    throw ae;
+                }
+            }
+        } else {
+            ListFunctionsRequest request = ListFunctionsRequest.newBuilder()
+                    .setParent(LocationName.of(getConfiguration().getProject(), getConfiguration().getLocation())
+                            .toString())
+                    .setPageSize(883849137) // TODO check it
+                    .setPageToken(""pageToken873572522"").build();
+            ListFunctionsPagedResponse pagedListResponse = client.listFunctions(request);
+            List<CloudFunction> response = Lists.newArrayList(pagedListResponse.iterateAll());
+            Message message = getMessageForResponse(exchange);
+            message.setBody(response);
+        }
+    }
+
+    private void getFunction(CloudFunctionsServiceClient client, Exchange exchange) throws InvalidPayloadException {
+        if (getConfiguration().isPojoRequest()) {
+            Object payload = exchange.getIn().getMandatoryBody();
+            if (payload instanceof CloudFunctionName) {
+                CloudFunction response;
+                try {
+                    response = client.getFunction((CloudFunctionName) payload);
+                } catch (ApiException ae) {
+                    LOG.trace(""getFunction command returned the error code {}"", ae.getStatusCode());
+                    throw ae;
+                }
+                Message message = getMessageForResponse(exchange);
+                message.setBody(response);
+            }
+        } else {
+            CloudFunctionName cfName = CloudFunctionName.of(getConfiguration().getProject(),
+                    getConfiguration().getLocation(), getConfiguration().getFunctionName());
+            CloudFunction response = client.getFunction(cfName);
+            Message message = getMessageForResponse(exchange);
+            message.setBody(response);
+        }
+    }
+
+    private void callFunction(CloudFunctionsServiceClient client, Exchange exchange) throws InvalidPayloadException {
+        if (getConfiguration().isPojoRequest()) {
+            Object payload = exchange.getIn().getMandatoryBody();
+            if (payload instanceof CallFunctionRequest) {
+                CallFunctionResponse response;
+                try {
+                    response = client.callFunction((CallFunctionRequest) payload);
+                    Message message = getMessageForResponse(exchange);
+                    message.setHeader(GoogleCloudFunctionsConstants.RESPONSE_OBJECT, response);
+                    message.setBody(response.getResult());
+                } catch (ApiException ae) {","[{'comment': ""These exceptions that you log in every function, also the same function will be thrown in other duplicated code (e.g: https://github.com/apache/camel/pull/5205/files#diff-0cab0789896e74525b9f46a8445b841a9a8b2f108b6300c7a5edd970d9c47550R166), you don't need to log that? "", 'commenter': 'omarsmak'}]"
5205,components/camel-google/camel-google-functions/src/main/java/org/apache/camel/component/google/functions/GoogleCloudFunctionsProducer.java,"@@ -0,0 +1,330 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.google.functions;
+
+import java.util.List;
+import java.util.concurrent.ExecutionException;
+
+import com.google.api.client.util.Lists;
+import com.google.api.gax.rpc.ApiException;
+import com.google.cloud.functions.v1.CallFunctionRequest;
+import com.google.cloud.functions.v1.CallFunctionResponse;
+import com.google.cloud.functions.v1.CloudFunction;
+import com.google.cloud.functions.v1.CloudFunctionName;
+import com.google.cloud.functions.v1.CloudFunctionsServiceClient;
+import com.google.cloud.functions.v1.CloudFunctionsServiceClient.ListFunctionsPagedResponse;
+import com.google.cloud.functions.v1.CreateFunctionRequest;
+import com.google.cloud.functions.v1.DeleteFunctionRequest;
+import com.google.cloud.functions.v1.GenerateDownloadUrlRequest;
+import com.google.cloud.functions.v1.GenerateDownloadUrlResponse;
+import com.google.cloud.functions.v1.GenerateUploadUrlRequest;
+import com.google.cloud.functions.v1.GenerateUploadUrlResponse;
+import com.google.cloud.functions.v1.HttpsTrigger;
+import com.google.cloud.functions.v1.ListFunctionsRequest;
+import com.google.cloud.functions.v1.LocationName;
+import com.google.cloud.functions.v1.UpdateFunctionRequest;
+import com.google.protobuf.Empty;
+import org.apache.camel.Exchange;
+import org.apache.camel.InvalidPayloadException;
+import org.apache.camel.Message;
+import org.apache.camel.support.DefaultProducer;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * The GoogleCloudFunctions producer.
+ */
+public class GoogleCloudFunctionsProducer extends DefaultProducer {
+    private static final Logger LOG = LoggerFactory.getLogger(GoogleCloudFunctionsProducer.class);
+
+    private GoogleCloudFunctionsEndpoint endpoint;
+
+    public GoogleCloudFunctionsProducer(GoogleCloudFunctionsEndpoint endpoint) {
+        super(endpoint);
+        this.endpoint = endpoint;
+    }
+
+    @Override
+    public void process(final Exchange exchange) throws Exception {
+        switch (determineOperation(exchange)) {
+            case listFunctions:
+                listFunctions(endpoint.getClient(), exchange);
+                break;
+            case getFunction:
+                getFunction(endpoint.getClient(), exchange);
+                break;
+            case callFunction:
+                callFunction(endpoint.getClient(), exchange);
+                break;
+            case generateDownloadUrl:
+                generateDownloadUrl(endpoint.getClient(), exchange);
+                break;
+            case generateUploadUrl:
+                generateUploadUrl(endpoint.getClient(), exchange);
+                break;
+            case createFunction:
+                createFunction(endpoint.getClient(), exchange);
+                break;
+            case updateFunction:
+                updateFunction(endpoint.getClient(), exchange);
+                break;
+            case deleteFunction:
+                deleteFunction(endpoint.getClient(), exchange);
+                break;
+
+            default:
+                throw new IllegalArgumentException(""Unsupported operation"");
+        }
+    }
+
+    private void listFunctions(CloudFunctionsServiceClient client, Exchange exchange) throws InvalidPayloadException {
+        if (getConfiguration().isPojoRequest()) {
+            Object payload = exchange.getIn().getMandatoryBody();
+            if (payload instanceof ListFunctionsRequest) {
+                ListFunctionsPagedResponse pagedListResponse;
+                try {
+                    pagedListResponse = client.listFunctions((ListFunctionsRequest) payload);
+                    List<CloudFunction> response = Lists.newArrayList(pagedListResponse.iterateAll());
+                    Message message = getMessageForResponse(exchange);
+                    message.setBody(response);
+                } catch (ApiException ae) {
+                    LOG.trace(""listFunctions command returned the error code {}"", ae.getStatusCode());
+                    throw ae;
+                }
+            }
+        } else {
+            ListFunctionsRequest request = ListFunctionsRequest.newBuilder()
+                    .setParent(LocationName.of(getConfiguration().getProject(), getConfiguration().getLocation())
+                            .toString())
+                    .setPageSize(883849137) // TODO check it
+                    .setPageToken(""pageToken873572522"").build();
+            ListFunctionsPagedResponse pagedListResponse = client.listFunctions(request);
+            List<CloudFunction> response = Lists.newArrayList(pagedListResponse.iterateAll());
+            Message message = getMessageForResponse(exchange);
+            message.setBody(response);
+        }
+    }
+
+    private void getFunction(CloudFunctionsServiceClient client, Exchange exchange) throws InvalidPayloadException {
+        if (getConfiguration().isPojoRequest()) {
+            Object payload = exchange.getIn().getMandatoryBody();","[{'comment': 'You can do something like this `CloudFunctionName payload = exchange.getIn().getBody(CloudFunctionName.class);`', 'commenter': 'omarsmak'}, {'comment': 'Yes, but if pojoRequest is true, then the body is mandatory', 'commenter': 'oscerd'}, {'comment': 'ah true, then `exchange.getIn().getMandatoryBody(CloudFunctionName.class);`', 'commenter': 'omarsmak'}]"
5299,components/camel-jsonpath/src/main/java/org/apache/camel/jsonpath/JsonPathEngine.java,"@@ -182,14 +182,30 @@ private Object doRead(String path, Exchange exchange) throws IOException, CamelE
             return JsonPath.using(configuration).parse(list).read(path);
         } else {
             // can we find an adapter which can read the message body/header
-            Object answer = readWithAdapter(path, exchange);
+            Object answer = null;","[{'comment': 'I would like to see if we can find a solution without catching a runtime exception and then try again with stream mode. \r\n\r\nInstead we should probably check the exchange body and find the right read method to use from the start.\r\n\r\nAny processing that causes an exception to be swallowed is a bad smell and also a performance overhead.', 'commenter': 'davsclaus'}, {'comment': ""@davsclaus It makes sense, I'll rework it to decide correctly before an exception is thrown. Thanks for the suggestion."", 'commenter': 'JiriOndrusek'}, {'comment': '@davsclaus I reworked fix to detect `ertx.Buffer` to convert buffer to `InputStream` and handle as an `InputStream.`.\r\n\r\nThe other option I see is to detect `vertx.Buffer` and use method with InputStream, which uses automatic conversion - which works too. \r\n\r\nBut current solution would avoid automatic types convertion and should have a sligfhtly better performance. \r\n\r\nWDYT?', 'commenter': 'JiriOndrusek'}, {'comment': ""The only possible problem could be addition of  dependency `<artifactId>camel-vertx-common</artifactId>`. But I don't see another option how to detect `vertx.Buffer` without it. (so it would be present in both options)\r\n\r\nI haven't checked karaf feature yet, it could require a fix too (because of a new dependency)."", 'commenter': 'JiriOndrusek'}, {'comment': 'We cannot make camel-jsonpath dependent on vert.x. Instead the automatic type converters via Camel is fine to use, to convert the payload to inputstream and use that. ', 'commenter': 'davsclaus'}, {'comment': ""ok, thanks for explaining. I'll use automatic conversion."", 'commenter': 'JiriOndrusek'}, {'comment': '@davsclaus \r\nThere is no way, how to detect that adapter conversion fails in such case (`vertx.Buffer` in this case). Unfortunately default adapter in case of `vertx.Buffer` does not return `null` (which means - can not convert), but return map{""bytes"": ... ""bytesBuff"": ...}, which seems to be a valid conversion with TRACE message.\r\n> JacksonJsonAdapter converted object from: {} to: java.util.Map""\r\n\r\nExecution of jsonpath fails afterwards, but without an option to detect why.\r\n\r\nThe only way of detecting ""unknown"" content (`vertx.Buffer` in this case) is to try to convert content into `InputStream`. If conversion is successful, we can go with the read method for the input stream.\r\n\r\nBut there is a small **back-compatibility issue**.\r\n\r\nLet say, that there is an adapter, which maps  InputStream into String ""InputStream:...text..."". \r\nCurrent state (before this PR) would return ""InpuStream:...text...""\r\nFix with automatic conversion would change result to ""...text..."", because automatic conversion would end successfully and would be used before the adapter.\r\n\r\nI agree that catching exception is a wrong way, which could cause more problems, then I originally thought of.\r\n\r\nSo my opinion is:\r\n 1 - try conversion of exchange into inputStream\r\n 2 - if it succeeds, use  inputStream for jsonpath\r\n 3 - if not, use adapter approach as a fallback\r\nThis solution brings a slight change in behavior (described above), nevertheless  I think that this should be the correct approach and the difference could be mentioned in upgrade doc. \r\n\r\nIf user really needs to use older order (adpter and fallback to inputStream), there are 2 options:\r\n1 - user could remove converter from registry\r\n2 - we can provide a property, which could return component to older behavior\r\nWDYT?', 'commenter': 'JiriOndrusek'}, {'comment': 'Your option is fine. The ""problem with the adapter"" is that not only introduced more recently with the switch to jackson as json library. The adapter was only something added to make it easier to switch to use jackson instead of that json-smart that it was using as default. But since jackson is now the default, then the adapter is not really to be used.\r\n\r\nJust add a note in the 3.10 upgrade guide in the docs about this potential change.\r\n\r\nAnd yes IMHO reading as InputStream first is the best choice - InputStream is used by many components.', 'commenter': 'davsclaus'}, {'comment': 'done', 'commenter': 'JiriOndrusek'}]"
5301,components/camel-sql/src/main/java/org/apache/camel/component/sql/stored/SqlStoredEndpoint.java,"@@ -59,6 +59,9 @@
     @UriParam(description = ""Whether this call is for a function."")
     private boolean function;
 
+    @UriParam(label = ""template"")","[{'comment': 'the label in the uriParam is related to generic camel labels, template is not one of them', 'commenter': 'oscerd'}, {'comment': 'Okay , I thought since this option would be set on template, i preassumed it should be a template. Let me correct it,', 'commenter': 'vgaur'}]"
5301,components/camel-sql/src/main/java/org/apache/camel/component/sql/stored/SqlStoredEndpoint.java,"@@ -163,4 +166,16 @@ public void setFunction(boolean function) {
         this.function = function;
     }
 
+    public int getQueryTimeout() {
+        return queryTimeout;
+    }
+
+    /**
+     * Sets the query timeout property on statements used for query processing. This will be overridden by the remaining","[{'comment': 'Please add the description as field of the annotation like the other options.', 'commenter': 'oscerd'}]"
5301,components/camel-sql/src/main/docs/sql-stored-component.adoc,"@@ -122,6 +122,7 @@ with the following path and query parameters:
 | *noop* (producer) | If set, will ignore the results of the template and use the existing IN message as the OUT message for the continuation of processing | false | boolean
 | *outputHeader* (producer) | Store the template result in a header instead of the message body. By default, outputHeader == null and the template result is stored in the message body, any existing content in the message body is discarded. If outputHeader is set, the value is used as the name of the header to store the template result and the original message body is preserved. |  | String
 | *useMessageBodyForTemplate* (producer) | Whether to use the message body as the template and then headers for parameters. If this option is enabled then the template in the uri is not used. | false | boolean
+| *queryTimeout* (producer) | Sets the query timeout property on statements used for query processing. This will be overridden by the remaining transaction timeout when executing within a transaction that has a timeout specified at the transaction level. | -1 | int","[{'comment': 'You should remove this', 'commenter': 'oscerd'}]"
5311,core/camel-core-engine/src/main/docs/modules/eips/pages/choice-eip.adoc,"@@ -40,14 +40,49 @@ RouteBuilder builder = new RouteBuilder() {
             .choice()
                 .when(simple(""${header.foo} == 'bar'""))
                     .to(""direct:b"")
+                .endChoice()
                 .when(simple(""${header.foo} == 'cheese'""))
                     .to(""direct:c"")
+                .endChoice()","[{'comment': 'Can you restore this example back to what it was before - this is 99% of the normal use-cases.\r\n\r\nAnd then below it would be good to add a header section about endChoice and then you can use the multicast example as its example.', 'commenter': 'davsclaus'}, {'comment': ""Hi Dave,\r\nSure Dave, I have made changes. Let me know if they are correct. I am happy to make any additional changes that you can share. :+1:\r\n\r\nI have done some minor reordering of documentation, let me know if that's okay. (TIP is moved from being in between dsl and xml to end of doc)\r\n"", 'commenter': 'swapy'}, {'comment': 'Thanks for your patience and helping with the project. You are much welcome to keep contributing, thanks.', 'commenter': 'davsclaus'}]"
5312,components/camel-kafka/src/main/java/org/apache/camel/component/kafka/KafkaProducer.java,"@@ -223,6 +231,12 @@ public boolean hasNext() {
                             }
                         }
 
+                        if (innerMmessage.getHeader(KafkaConstants.OVERRIDE_TIMESTAMP) != null) {
+                            if (innerMmessage.getHeader(KafkaConstants.OVERRIDE_TIMESTAMP) instanceof Long) {
+                                innerTimestamp = ((Long) overrideTimeStamp).longValue();","[{'comment': 'innerMmessage.getHeader(KafkaConstants.OVERRIDE_TIMESTAMP)  will be lost', 'commenter': 'vgaur'}, {'comment': 'why it will be lost?', 'commenter': 'oscerd'}, {'comment': 'Probably I am getting it wrong but should the innerTimestamp be set with value of innerMmessage.getHeader(KafkaConstants.OVERRIDE_TIMESTAMP) instead of  overrideTimeStamp. \r\n', 'commenter': 'vgaur'}, {'comment': 'yes @vgaur , the `innerTimestamp` should get `innerMmessage.removeHeader(KafkaConstants.OVERRIDE_TIMESTAMP)` since now we are dealing here with inner messages', 'commenter': 'omarsmak'}]"
5312,components/camel-kafka/src/test/java/org/apache/camel/component/kafka/KafkaProducerTest.java,"@@ -302,6 +306,21 @@ public void processSendsMessageWithMessageKeyHeader() throws Exception {
         assertRecordMetadataExists();
     }
 
+    @Test
+    public void processSendsMessageWithMessageTimestampHeader() throws Exception {","[{'comment': 'If possible, would be nice to add one more test to test nested `OVERRIDE_TIMESTAMP` in nested messages, it is related to the observation here: https://github.com/apache/camel/pull/5312/files#r609685918', 'commenter': 'omarsmak'}]"
5312,components/camel-kafka/src/main/java/org/apache/camel/component/kafka/KafkaProducer.java,"@@ -189,6 +196,7 @@ public boolean hasNext() {
                     String innerTopic = msgTopic;
                     Object innerKey = null;
                     Integer innerPartitionKey = null;
+                    Long innerTimestamp = null;","[{'comment': ""Should this be initialized with timeStamp? If the inner message doesn't override it use the outer message override value."", 'commenter': 'vgaur'}, {'comment': 'if timestamp is provided innerTimestamp assigned with the provided timestamp else it will be null.\r\n\r\ndo you want even there is no timestamp provided it should be assigned with current timestamp? ', 'commenter': 'ramu11'}, {'comment': 'yeah I would also say the same, if it was explicitly provided in the inner messages, it would make sense to set it otherwise I would keep it as `null` ', 'commenter': 'omarsmak'}, {'comment': ""In case of OVERRIDE_TOPIC , if inner message doesn't have override topic , we use the override topic from outer exchange.\r\nI assumed we will follow the same, if overide time is not present in inner message , use the override time from outer exchange and if the override time is not set even on outer exchange, then set it as null. "", 'commenter': 'vgaur'}, {'comment': ""I have a mix feeling of altering this behavior, in case of topic, it would make sense to fallback to the outer topic since you need to specify a topic. However, in case of the timestamp, this is not mandatory per say to specify and thus it would be fine to have it as `null`. Also, altering the timestamp for these messages, IMHO would alter the semantics of in case you deliberately don't want to specify timestamp for some of these inner messages. "", 'commenter': 'omarsmak'}, {'comment': 'Make sense !!! ', 'commenter': 'vgaur'}]"
5319,components/camel-huaweicloud-smn/src/main/java/org/apache/camel/component/huaweicloud/smn/SimpleNotificationProducer.java,"@@ -204,15 +205,20 @@ private void validateAndInitializeSmnClient(SimpleNotificationEndpoint simpleNot
             clientConfigurations.setProjectId(simpleNotificationEndpoint.getProjectId());
         }
 
-        //checking for region
-        String endpointUrl = SimpleNotificationUtils.resolveSmnServiceEndpoint(simpleNotificationEndpoint.getRegion());
-        if (endpointUrl == null) {
-            if (LOG.isErrorEnabled()) {
-                LOG.error(""Valid region not found"");
-            }
-            throw new IllegalArgumentException(""enter a valid region"");
+        //checking for endpoint
+        if (StringUtils.isNotEmpty(simpleNotificationEndpoint.getEndpoint())) {
+            clientConfigurations.setServiceEndpoint(simpleNotificationEndpoint.getEndpoint());
         } else {
-            clientConfigurations.setServiceEndpoint(endpointUrl);
+            //checking for region
+            String endpointUrl = SimpleNotificationUtils.resolveSmnServiceEndpoint(simpleNotificationEndpoint.getRegion());","[{'comment': ""Here you're changing the basic behavior. So I think we need a note on the migration guide about endpoint with precedence on region. "", 'commenter': 'oscerd'}]"
5319,components/camel-huaweicloud-smn/src/main/docs/hwcloud-smn-component.adoc,"@@ -71,13 +71,15 @@ with the following path and query parameters:
 |===
 
 
-=== Query Parameters (13 parameters):
+=== Query Parameters (14 parameters):
 
 
 [width=""100%"",cols=""2,5,^1,2"",options=""header""]
 |===
 | Name | Description | Default | Type
 | *authKey* (producer) | *Required* Authentication key for the cloud user |  | String
+| *endpoint* (producer) | Fully qualified smn service url. Carries higher precedence than region parameter based client initialization|  | String","[{'comment': 'This is autogenerated, you need to update the description on the option, not change the table directly, once you build the module, it will be updated.', 'commenter': 'oscerd'}, {'comment': '@oscerd - oh i see. let me autogenerated again and update it on the option. ', 'commenter': 'hokutor'}, {'comment': 'Thanks @oscerd for the tip. Have checked in as per guidelines. We loved the entire documentation framework :) ', 'commenter': 'hokutor'}]"
5319,core/camel-endpointdsl/src/generated/java/org/apache/camel/builder/endpoint/EndpointBuilderFactory.java,"@@ -28,14 +28,12 @@
 @Generated(""org.apache.camel.maven.packaging.EndpointDslMojo"")
 public interface EndpointBuilderFactory
         extends
-            org.apache.camel.builder.endpoint.dsl.AMQPEndpointBuilderFactory.AMQPBuilders,
-            org.apache.camel.builder.endpoint.dsl.AS2EndpointBuilderFactory.AS2Builders,
-            org.apache.camel.builder.endpoint.dsl.AWS2EC2EndpointBuilderFactory.AWS2EC2Builders,
-            org.apache.camel.builder.endpoint.dsl.AWS2S3EndpointBuilderFactory.AWS2S3Builders,
             org.apache.camel.builder.endpoint.dsl.ActiveMQEndpointBuilderFactory.ActiveMQBuilders,
             org.apache.camel.builder.endpoint.dsl.AhcEndpointBuilderFactory.AhcBuilders,
+            org.apache.camel.builder.endpoint.dsl.AMQPEndpointBuilderFactory.AMQPBuilders,","[{'comment': 'Here I guess you have a mix of empty folders or a git tree not clean.', 'commenter': 'oscerd'}, {'comment': 'Strange. I cleaned up my local branches and reverted the changes on EndpointBuilderFactory and EndpointBuilders file. Let me do a check-in with reverted state. ', 'commenter': 'hokutor'}, {'comment': '> Here I guess you have a mix of empty folders or a git tree not clean.\r\n\r\nI did a revert, complete cleanup and applied changes and did  a mvn build. I see the same set of changes again. Could it be extensions getting re-ordered inside the same file? I see ```org.apache.camel.builder.endpoint.dsl.AMQPEndpointBuilderFactory.AMQPBuilders``` removed from upper portion of the file and moved down ?\r\n\r\n![image](https://user-images.githubusercontent.com/81697586/114240094-f7e1b900-9954-11eb-9185-a9abe2f18af4.png)\r\n\r\n @oscerd ', 'commenter': 'hokutor'}, {'comment': 'It could be. The important point is not losing builders', 'commenter': 'oscerd'}]"
5370,core/camel-support/src/main/java/org/apache/camel/support/AbstractExchange.java,"@@ -189,7 +189,15 @@ public Exchange copy() {
 
     @SuppressWarnings(""unchecked"")
     private void safeCopyProperties(Map<String, Object> source, Map<String, Object> target) {
-        target.putAll(source);
+        source.entrySet().stream().forEach(entry -> {","[{'comment': 'Sorry we do not want this kind in the core. Can you maybe try to come up with a different solution.', 'commenter': 'davsclaus'}, {'comment': '@davsclaus Are you suggesting to totally avoid changes in core, or avoid these specific changes in core? I initially did come up with another approach for camel-zipkin but it is far more complicated and honestly does not address the real problem.  \r\n\r\nThe span problem I am pretty sure exists in camel opentracing and opentelemetry as well because both of them use camel-tracing and if you look at [ActiveSpanManager](https://github.com/apache/camel/blob/master/components/camel-tracing/src/main/java/org/apache/camel/tracing/ActiveSpanManager.java) it also uses Exchange property mechanism to set  ACTIVE_SPAN_PROPERTY which would get corrupted when using parallelProcessing with multicast. \r\n\r\nMy suggested approach would easily fix issues in opentracing and opentelemetry as well.', 'commenter': 'samratdhillon'}, {'comment': 'Yes we do not want core comprimised with this due to zipkin storing state like that. The core should be lean and fast.', 'commenter': 'davsclaus'}, {'comment': 'Instead of doing this expensive check always, then find out some way for zipkin et all to turn on a flag on the exchange (via ExtendedExchange) to tell it that it should do deep clone safe copy mode, then this is only in use when you use these special zipkin components.\r\n\r\nOr instead of storing the zipkin state as exchange property, store it on some zipkin bean, that handles this and stores the data per exchange id or something.', 'commenter': 'davsclaus'}, {'comment': '@davsclaus Thanks for the advice. I think setting the flag via ExtendedExchange would be the best option.\r\n\r\n', 'commenter': 'samratdhillon'}, {'comment': 'I have incorporated your feedback and also an alternate approach and IMHO cleaner one has been implemented in another PR https://github.com/apache/camel/pull/5373', 'commenter': 'samratdhillon'}, {'comment': 'Oh that is great work that you implemented two different solutions. I agree with you that the alternative is the better choice, so lets close this PR', 'commenter': 'davsclaus'}]"
5409,core/camel-support/src/main/java/org/apache/camel/support/CamelCopySafeProperty.java,"@@ -0,0 +1,32 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.support;
+
+/**
+ *
+ * @author     Samrat.Dhillon","[{'comment': 'Remove author tag', 'commenter': 'davsclaus'}, {'comment': '@davsclaus pushed changes matching master. I see changes in master trigger a build. Is it possible to verify changes in maintenance branch.', 'commenter': 'samratdhillon'}, {'comment': 'There CI just do a build and code format testing - no full test run. That is only for code merged.', 'commenter': 'davsclaus'}, {'comment': 'And this is the danger of doing changes in core in a LTS release - eg we prefer not to. But this fixes a real bug for distributed tracing that is hard to ""notice"" due thread concurrency issues etc. \r\n\r\n', 'commenter': 'davsclaus'}, {'comment': ""@davsclaus Then please don't merge it yet. Let me rethink an easier way for LTS."", 'commenter': 'samratdhillon'}, {'comment': 'Closing this in lieu of PR#5435', 'commenter': 'samratdhillon'}]"
5504,components/camel-splunk-hec/src/main/java/org/apache/camel/component/splunkhec/SplunkHECProducer.java,"@@ -128,5 +131,25 @@ private void buildPayload(Map<String, Object> payload) {
         if (endpoint.getConfiguration().getHost() != null) {
             payload.put(""host"", endpoint.getConfiguration().getHost());
         }
+
+        Object timeInput = message.getHeader(SplunkHECComponent.INDEX_TIME, endpoint.getConfiguration().getTime());","[{'comment': ""You should use Camel's type converter, and use getHeader where you can specify the returned time as Long so Camel deal with type conversions. Then all the code below can be removed"", 'commenter': 'davsclaus'}, {'comment': 'Done', 'commenter': 'iridian-ks'}]"
5519,components/camel-aws/camel-aws2-sns/src/main/java/org/apache/camel/component/aws2/sns/Sns2Component.java,"@@ -58,25 +58,29 @@ protected Endpoint createEndpoint(String uri, String remaining, Map<String, Obje
             setProperties(getCamelContext(), this, transientParameters);
         }
 
-        configuration = this.configuration != null ? this.configuration : new Sns2Configuration();
-        Sns2Endpoint endpoint = new Sns2Endpoint(uri, this, configuration);
-
         Map<String, Object> nonTransientParameters = getNonTransientParameters(parameters);
 
-        setProperties(endpoint, nonTransientParameters);
+        Sns2Configuration epConfiguration = this.configuration != null ? this.configuration.copy() : new Sns2Configuration();
 
         if (remaining.startsWith(""arn:"")) {
-            parseRemaining(remaining);
+            parseRemaining(epConfiguration, remaining);
         } else {
-            configuration.setTopicName(remaining);
-            LOG.debug(""Created the endpoint with topic {}"", configuration.getTopicName());
+            epConfiguration.setTopicName(remaining);
+            LOG.debug(""Created the endpoint with topic {}"", epConfiguration.getTopicName());
         }
 
-        if (!configuration.isUseDefaultCredentialsProvider() && configuration.getAmazonSNSClient() == null
-                && (configuration.getAccessKey() == null || configuration.getSecretKey() == null)) {
+        Sns2Endpoint endpoint = new Sns2Endpoint(uri, this, epConfiguration);
+        setProperties(endpoint, nonTransientParameters);
+
+        if (!epConfiguration.isUseDefaultCredentialsProvider() && epConfiguration.getAmazonSNSClient() == null
+                && (epConfiguration.getAccessKey() == null || epConfiguration.getSecretKey() == null)) {
             throw new IllegalArgumentException(""AmazonSNSClient or accessKey and secretKey must be specified"");
         }
 
+        if (this.configuration == null) {
+            setConfiguration(epConfiguration);","[{'comment': 'Ah this seems wrong, if you set this on the component level. That should not happen.\r\nCan you try with removing this.', 'commenter': 'davsclaus'}, {'comment': 'Thanks! I removed these lines and ran a test. It seems to be fine without it.', 'commenter': 'orpiske'}]"
5529,components/camel-openstack/src/main/java/org/apache/camel/component/openstack/swift/producer/ObjectProducer.java,"@@ -93,7 +94,17 @@ private void doGetAll(Exchange exchange) {
         final String name = msg.getHeader(SwiftConstants.CONTAINER_NAME, msg.getHeader(OpenstackConstants.NAME, String.class),
                 String.class);
         StringHelper.notEmpty(name, ""Container name"");
-        final List<? extends SwiftObject> out = os.objectStorage().objects().list(name);
+        final String path = msg.getHeader(SwiftConstants.PATH, String.class);
+
+        List<? extends SwiftObject> out;
+        if (path != null) {","[{'comment': 'Here you could use ObjectHelper and check for emptiness', 'commenter': 'oscerd'}]"
5588,test-infra/camel-test-infra-openldap/pom.xml,"@@ -0,0 +1,40 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>","[{'comment': 'License is missing', 'commenter': 'oscerd'}]"
5588,test-infra/camel-test-infra-openldap/src/test/java/org/apache/camel/test/infra/openldap/services/OpenldapLocalContainerService.java,"@@ -0,0 +1,117 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.test.infra.openldap.services;
+
+import org.apache.camel.test.infra.common.services.ContainerService;
+import org.apache.camel.test.infra.openldap.common.OpenldapProperties;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import org.testcontainers.containers.FixedHostPortGenericContainer;
+import org.testcontainers.containers.GenericContainer;
+
+public class OpenldapLocalContainerService implements OpenldapService, ContainerService<GenericContainer> {
+    public static final String CONTAINER_IMAGE = ""osixia/openldap:1.5.0"";
+    public static final String CONTAINER_NAME = ""openldap"";
+    public static final int CONTAINER_PORT_389 = 389;
+    public static final int CONTAINER_PORT_636 = 636;","[{'comment': 'Maybe use `CONTAINER_PORT_LDAP` and `CONTAINER_PORT_LDAP_OVER_SSL` for clarity? Not necessarily these, but a descriptive name would be better.', 'commenter': 'orpiske'}]"
5588,test-infra/camel-test-infra-openldap/src/test/java/org/apache/camel/test/infra/openldap/common/OpenldapProperties.java,"@@ -0,0 +1,29 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.camel.test.infra.openldap.common;
+
+public final class OpenldapProperties {
+    public static final String HOST = ""openldap.host"";
+    public static final String PORT_389 = ""openldap.port.389"";
+    public static final String PORT_636 = ""openldap.port.636"";","[{'comment': 'For clarity, maybe use `PORT_LDAP` and `PORT_LDAP_OVER_SSL` along with `openldap.port.ldap` and `openldap.port.ldap.ssl` respectively? I had to google what these ports are ... so, it would make it easier to figure it out in the future.', 'commenter': 'orpiske'}, {'comment': 'you are right, when I started I had to google it too, but forgot to change there, will do', 'commenter': 'Croway'}]"
5612,components/camel-huaweicloud-functiongraph/pom.xml,"@@ -0,0 +1,141 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+
+  <modelVersion>4.0.0</modelVersion>
+
+  <groupId>org.apache.camel</groupId>
+  <artifactId>camel-huaweicloud-functiongraph</artifactId>
+  <packaging>jar</packaging>
+  <version>3.11.0-SNAPSHOT</version>
+
+  <name>Camel FunctionGraph Component</name>
+
+  <properties>
+    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
+    <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
+  </properties>
+
+  <dependencyManagement>","[{'comment': 'BOM is not needed here. You need to use the components pom as parent\r\n```\r\n\r\n    <parent>\r\n        <groupId>org.apache.camel</groupId>\r\n        <artifactId>camel-azure-parent</artifactId>\r\n        <version>3.11.0-SNAPSHOT</version>\r\n    </parent>\r\n```', 'commenter': 'oscerd'}, {'comment': 'Done. Using components parent pom. created a module entry in components pom for functiongraph.', 'commenter': 'hokutor'}]"
5612,components/camel-huaweicloud-functiongraph/pom.xml,"@@ -0,0 +1,141 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+
+  <modelVersion>4.0.0</modelVersion>
+
+  <groupId>org.apache.camel</groupId>
+  <artifactId>camel-huaweicloud-functiongraph</artifactId>
+  <packaging>jar</packaging>
+  <version>3.11.0-SNAPSHOT</version>
+
+  <name>Camel FunctionGraph Component</name>
+
+  <properties>
+    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
+    <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
+  </properties>
+
+  <dependencyManagement>
+    <dependencies>
+      <!-- Camel BOM -->
+      <dependency>
+        <groupId>org.apache.camel</groupId>
+        <artifactId>camel-bom</artifactId>
+        <version>3.9.0</version>
+        <scope>import</scope>
+        <type>pom</type>
+      </dependency>
+    </dependencies>
+  </dependencyManagement>
+
+  <dependencies>
+
+    <!-- camel -->
+    <dependency>
+      <groupId>org.apache.camel</groupId>
+      <artifactId>camel-support</artifactId>
+    </dependency>
+
+    <!-- HuaweiCloud SDK v3 -->
+    <dependency>
+      <groupId>com.huaweicloud.sdk</groupId>
+      <artifactId>huaweicloud-sdk-functiongraph</artifactId>
+      <version>3.0.43-rc</version>","[{'comment': 'Use the version from parent pom.', 'commenter': 'oscerd'}, {'comment': 'Done', 'commenter': 'hokutor'}]"
5612,components/camel-huaweicloud-functiongraph/pom.xml,"@@ -0,0 +1,141 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+
+  <modelVersion>4.0.0</modelVersion>
+
+  <groupId>org.apache.camel</groupId>
+  <artifactId>camel-huaweicloud-functiongraph</artifactId>
+  <packaging>jar</packaging>
+  <version>3.11.0-SNAPSHOT</version>
+
+  <name>Camel FunctionGraph Component</name>
+
+  <properties>
+    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
+    <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
+  </properties>
+
+  <dependencyManagement>
+    <dependencies>
+      <!-- Camel BOM -->
+      <dependency>
+        <groupId>org.apache.camel</groupId>
+        <artifactId>camel-bom</artifactId>
+        <version>3.9.0</version>
+        <scope>import</scope>
+        <type>pom</type>
+      </dependency>
+    </dependencies>
+  </dependencyManagement>
+
+  <dependencies>
+
+    <!-- camel -->
+    <dependency>
+      <groupId>org.apache.camel</groupId>
+      <artifactId>camel-support</artifactId>
+    </dependency>
+
+    <!-- HuaweiCloud SDK v3 -->
+    <dependency>
+      <groupId>com.huaweicloud.sdk</groupId>
+      <artifactId>huaweicloud-sdk-functiongraph</artifactId>
+      <version>3.0.43-rc</version>
+    </dependency>
+
+    <dependency>
+      <groupId>com.google.code.gson</groupId>
+      <artifactId>gson</artifactId>
+      <version>2.8.6</version>","[{'comment': 'Same', 'commenter': 'oscerd'}, {'comment': 'Done', 'commenter': 'hokutor'}]"
5612,components/camel-huaweicloud-functiongraph/pom.xml,"@@ -0,0 +1,141 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+
+  <modelVersion>4.0.0</modelVersion>
+
+  <groupId>org.apache.camel</groupId>
+  <artifactId>camel-huaweicloud-functiongraph</artifactId>
+  <packaging>jar</packaging>
+  <version>3.11.0-SNAPSHOT</version>
+
+  <name>Camel FunctionGraph Component</name>
+
+  <properties>
+    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
+    <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
+  </properties>
+
+  <dependencyManagement>
+    <dependencies>
+      <!-- Camel BOM -->
+      <dependency>
+        <groupId>org.apache.camel</groupId>
+        <artifactId>camel-bom</artifactId>
+        <version>3.9.0</version>
+        <scope>import</scope>
+        <type>pom</type>
+      </dependency>
+    </dependencies>
+  </dependencyManagement>
+
+  <dependencies>
+
+    <!-- camel -->
+    <dependency>
+      <groupId>org.apache.camel</groupId>
+      <artifactId>camel-support</artifactId>
+    </dependency>
+
+    <!-- HuaweiCloud SDK v3 -->
+    <dependency>
+      <groupId>com.huaweicloud.sdk</groupId>
+      <artifactId>huaweicloud-sdk-functiongraph</artifactId>
+      <version>3.0.43-rc</version>
+    </dependency>
+
+    <dependency>
+      <groupId>com.google.code.gson</groupId>
+      <artifactId>gson</artifactId>
+      <version>2.8.6</version>
+    </dependency>
+
+    <!-- logging -->
+    <dependency>
+      <groupId>org.apache.logging.log4j</groupId>
+      <artifactId>log4j-slf4j-impl</artifactId>
+      <version>2.13.3</version>","[{'comment': 'Same', 'commenter': 'oscerd'}, {'comment': 'Done', 'commenter': 'hokutor'}]"
5612,components/camel-huaweicloud-functiongraph/pom.xml,"@@ -0,0 +1,141 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+
+  <modelVersion>4.0.0</modelVersion>
+
+  <groupId>org.apache.camel</groupId>
+  <artifactId>camel-huaweicloud-functiongraph</artifactId>
+  <packaging>jar</packaging>
+  <version>3.11.0-SNAPSHOT</version>
+
+  <name>Camel FunctionGraph Component</name>
+
+  <properties>
+    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
+    <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
+  </properties>
+
+  <dependencyManagement>
+    <dependencies>
+      <!-- Camel BOM -->
+      <dependency>
+        <groupId>org.apache.camel</groupId>
+        <artifactId>camel-bom</artifactId>
+        <version>3.9.0</version>
+        <scope>import</scope>
+        <type>pom</type>
+      </dependency>
+    </dependencies>
+  </dependencyManagement>
+
+  <dependencies>
+
+    <!-- camel -->
+    <dependency>
+      <groupId>org.apache.camel</groupId>
+      <artifactId>camel-support</artifactId>
+    </dependency>
+
+    <!-- HuaweiCloud SDK v3 -->
+    <dependency>
+      <groupId>com.huaweicloud.sdk</groupId>
+      <artifactId>huaweicloud-sdk-functiongraph</artifactId>
+      <version>3.0.43-rc</version>
+    </dependency>
+
+    <dependency>
+      <groupId>com.google.code.gson</groupId>
+      <artifactId>gson</artifactId>
+      <version>2.8.6</version>
+    </dependency>
+
+    <!-- logging -->
+    <dependency>
+      <groupId>org.apache.logging.log4j</groupId>
+      <artifactId>log4j-slf4j-impl</artifactId>
+      <version>2.13.3</version>
+      <scope>test</scope>
+    </dependency>
+
+    <!-- testing -->
+    <dependency>
+      <groupId>org.junit.jupiter</groupId>
+      <artifactId>junit-jupiter-api</artifactId>
+      <version>5.7.0</version>","[{'comment': 'Same', 'commenter': 'oscerd'}, {'comment': 'Done', 'commenter': 'hokutor'}]"
5612,components/camel-huaweicloud-functiongraph/pom.xml,"@@ -0,0 +1,141 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+
+  <modelVersion>4.0.0</modelVersion>
+
+  <groupId>org.apache.camel</groupId>
+  <artifactId>camel-huaweicloud-functiongraph</artifactId>
+  <packaging>jar</packaging>
+  <version>3.11.0-SNAPSHOT</version>
+
+  <name>Camel FunctionGraph Component</name>
+
+  <properties>
+    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
+    <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
+  </properties>
+
+  <dependencyManagement>
+    <dependencies>
+      <!-- Camel BOM -->
+      <dependency>
+        <groupId>org.apache.camel</groupId>
+        <artifactId>camel-bom</artifactId>
+        <version>3.9.0</version>
+        <scope>import</scope>
+        <type>pom</type>
+      </dependency>
+    </dependencies>
+  </dependencyManagement>
+
+  <dependencies>
+
+    <!-- camel -->
+    <dependency>
+      <groupId>org.apache.camel</groupId>
+      <artifactId>camel-support</artifactId>
+    </dependency>
+
+    <!-- HuaweiCloud SDK v3 -->
+    <dependency>
+      <groupId>com.huaweicloud.sdk</groupId>
+      <artifactId>huaweicloud-sdk-functiongraph</artifactId>
+      <version>3.0.43-rc</version>
+    </dependency>
+
+    <dependency>
+      <groupId>com.google.code.gson</groupId>
+      <artifactId>gson</artifactId>
+      <version>2.8.6</version>
+    </dependency>
+
+    <!-- logging -->
+    <dependency>
+      <groupId>org.apache.logging.log4j</groupId>
+      <artifactId>log4j-slf4j-impl</artifactId>
+      <version>2.13.3</version>
+      <scope>test</scope>
+    </dependency>
+
+    <!-- testing -->
+    <dependency>
+      <groupId>org.junit.jupiter</groupId>
+      <artifactId>junit-jupiter-api</artifactId>
+      <version>5.7.0</version>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.apache.camel</groupId>
+      <artifactId>camel-test</artifactId>
+      <scope>test</scope>
+    </dependency>
+  </dependencies>
+
+  <build>
+    <defaultGoal>install</defaultGoal>
+
+    <plugins>
+      
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-compiler-plugin</artifactId>
+        <version>3.8.1</version>","[{'comment': 'Take as example the other components, all of this stuff will be inherited from components pom and parent pom and camel pom.', 'commenter': 'oscerd'}, {'comment': 'Done', 'commenter': 'hokutor'}]"
5612,components/camel-huaweicloud-functiongraph/src/main/java/org/apache/camel/FunctionGraphEndpoint.java,"@@ -0,0 +1,244 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel;
+
+import com.huaweicloud.sdk.functiongraph.v2.FunctionGraphClient;
+import org.apache.camel.Category;
+import org.apache.camel.Consumer;
+import org.apache.camel.Processor;
+import org.apache.camel.Producer;
+import org.apache.camel.models.ServiceKeys;
+import org.apache.camel.support.DefaultEndpoint;
+import org.apache.camel.spi.Metadata;
+import org.apache.camel.spi.UriEndpoint;
+import org.apache.camel.spi.UriParam;
+import org.apache.camel.spi.UriPath;
+
+import java.util.concurrent.ExecutorService;
+
+/**
+ * Huawei Cloud component to integrate with FunctionGraph services
+ */
+@UriEndpoint(firstVersion = ""3.11.0-SNAPSHOT"", scheme = ""hwcloud-functiongraph"", title = ""FunctionGraph"", syntax=""hwcloud-functiongraph:operation"",
+             category = {Category.CLOUD, Category.SERVERLESS}, producerOnly = true)
+public class FunctionGraphEndpoint extends DefaultEndpoint {
+
+    @UriPath(description = ""Operation to be performed"", displayName = ""Operation"", label = ""producer"", secret = false)
+    @Metadata(required = true)
+    private String operation;
+
+    @UriParam(description = ""FunctionGraph service region. This is lower precedence than endpoint based configuration"",
+            displayName = ""Service region"", secret = false)
+    @Metadata(required = true)
+    private String region;
+
+    @UriParam(description = ""Cloud project ID"", displayName = ""Project ID"", secret = false)
+    @Metadata(required = true)
+    private String projectId;
+
+    @UriParam(description = ""Functions that can be logically grouped together"",
+            displayName = ""Function package"", secret = false)
+    @Metadata(required = false)
+    private String functionPackage;
+
+    @UriParam(description = ""Name of the function to invoke"",
+            displayName = ""Function name"", secret = false)
+    @Metadata(required = false)
+    private String functionName;
+
+    @UriParam(description = ""Proxy server ip/hostname"", displayName = ""Proxy server host"", secret = false)
+    @Metadata(required = false)
+    private String proxyHost;
+
+    @UriParam(description = ""Proxy server port"", displayName = ""Proxy server port"", secret = false)
+    @Metadata(required = false)
+    private int proxyPort;
+
+    @UriParam(description = ""Proxy authentication user"", displayName = ""Proxy user"", secret = true)
+    @Metadata(required = false)
+    private String proxyUser;
+
+    @UriParam(description = ""Proxy authentication password"", displayName = ""Proxy password"", secret = true)
+    @Metadata(required = false)
+    private String proxyPassword;
+
+    @UriParam(description = ""Ignore SSL verification"", displayName = ""SSL Verification Ignored"", secret = false,
+            defaultValue = ""false"")
+    @Metadata(required = false)
+    private boolean ignoreSslVerification;
+
+    @UriParam(description = ""FunctionGraph url. Carries higher precedence than region parameter based client initialization"",
+            displayName = ""Service endpoint"", secret = false)
+    @Metadata(required = false)
+    private String endpoint;
+
+    @UriParam(description = ""Configuration object for cloud service authentication"", displayName = ""Service Configuration"",
+            secret = true)
+    @Metadata(required = false)
+    private ServiceKeys serviceKeys;
+
+    @UriParam(description = ""Authentication key for the cloud user"", displayName = ""API authentication key (AK)"", secret = true)
+    @Metadata(required = true)
+    private String authenticationKey;
+
+    @UriParam(description = ""Secret key for the cloud user"", displayName = ""API secret key (SK)"", secret = true)
+    @Metadata(required = true)
+    private String secretKey;
+
+    private FunctionGraphClient functionGraphClient;
+
+    public FunctionGraphEndpoint() {
+    }
+
+    public FunctionGraphEndpoint(String uri, String operation, FunctionGraphComponent component) {
+        super(uri, component);
+        this.operation = operation;
+    }
+
+    public Producer createProducer() throws Exception {
+        return new FunctionGraphProducer(this);
+    }
+
+    public Consumer createConsumer(Processor processor) throws Exception {
+        throw new UnsupportedOperationException(""You cannot receive messages from this endpoint"");
+    }
+
+    public String getRegion() {
+        return region;
+    }
+
+    public void setRegion(String region) {
+        this.region = region;
+    }
+
+    public String getProjectId() {
+        return projectId;
+    }
+
+    public void setProjectId(String projectId) {
+        this.projectId = projectId;
+    }
+
+    public String getFunctionPackage() {
+        return functionPackage;
+    }
+
+    public void setFunctionPackage(String functionPackage) {
+        this.functionPackage = functionPackage;
+    }
+
+    public String getFunctionName() {
+        return functionName;
+    }
+
+    public void setFunctionName(String functionName) {
+        this.functionName = functionName;
+    }
+
+    public String getOperation() {
+        return operation;
+    }
+
+    public void setOperation(String operation) {
+        this.operation = operation;
+    }
+
+    public String getProxyHost() {
+        return proxyHost;
+    }
+
+    public void setProxyHost(String proxyHost) {
+        this.proxyHost = proxyHost;
+    }
+
+    public int getProxyPort() {
+        return proxyPort;
+    }
+
+    public void setProxyPort(int proxyPort) {
+        this.proxyPort = proxyPort;
+    }
+
+    public String getProxyUser() {
+        return proxyUser;
+    }
+
+    public void setProxyUser(String proxyUser) {
+        this.proxyUser = proxyUser;
+    }
+
+    public String getProxyPassword() {
+        return proxyPassword;
+    }
+
+    public void setProxyPassword(String proxyPassword) {
+        this.proxyPassword = proxyPassword;
+    }
+
+    public boolean isIgnoreSslVerification() {
+        return ignoreSslVerification;
+    }
+
+    public void setIgnoreSslVerification(boolean ignoreSslVerification) {
+        this.ignoreSslVerification = ignoreSslVerification;
+    }
+
+    public String getEndpoint() {
+        return endpoint;
+    }
+
+    public void setEndpoint(String endpoint) {
+        this.endpoint = endpoint;
+    }
+
+    public ServiceKeys getServiceKeys() {
+        return serviceKeys;
+    }
+
+    public void setServiceKeys(ServiceKeys serviceKeys) {
+        this.serviceKeys = serviceKeys;
+    }
+
+    public String getAuthenticationKey() {
+        return authenticationKey;
+    }
+
+    public void setAuthenticationKey(String authenticationKey) {
+        this.authenticationKey = authenticationKey;
+    }
+
+    public String getSecretKey() {
+        return secretKey;
+    }
+
+    public void setSecretKey(String secretKey) {
+        this.secretKey = secretKey;
+    }
+
+    public FunctionGraphClient getFunctionGraphClient() {
+        return functionGraphClient;
+    }
+
+    public void setFunctionGraphClient(FunctionGraphClient functionGraphClient) {
+        this.functionGraphClient = functionGraphClient;
+    }
+
+    public ExecutorService createExecutor() {
+        // TODO: Delete me when you implemented your custom component","[{'comment': 'Fix or remove the TODO', 'commenter': 'oscerd'}, {'comment': 'Done', 'commenter': 'hokutor'}]"
5612,components/camel-huaweicloud-functiongraph/src/main/java/org/apache/camel/FunctionGraphProducer.java,"@@ -0,0 +1,246 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel;
+
+import com.fasterxml.jackson.core.JsonProcessingException;
+import com.fasterxml.jackson.databind.ObjectMapper;
+import com.huaweicloud.sdk.core.auth.BasicCredentials;
+import com.huaweicloud.sdk.core.http.HttpConfig;
+import com.huaweicloud.sdk.functiongraph.v2.FunctionGraphClient;
+import com.huaweicloud.sdk.functiongraph.v2.model.InvokeFunctionRequest;
+import com.huaweicloud.sdk.functiongraph.v2.model.InvokeFunctionResponse;
+import com.huaweicloud.sdk.functiongraph.v2.region.FunctionGraphRegion;
+import org.apache.camel.constants.FunctionGraphConstants;
+import org.apache.camel.constants.FunctionGraphOperations;
+import org.apache.camel.constants.FunctionGraphProperties;
+import org.apache.camel.models.ClientConfigurations;
+import org.apache.camel.support.DefaultProducer;
+import org.apache.camel.util.ObjectHelper;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.util.HashMap;
+import java.util.Map;
+
+public class FunctionGraphProducer extends DefaultProducer {
+    private static final Logger LOG = LoggerFactory.getLogger(FunctionGraphProducer.class);
+    private FunctionGraphEndpoint endpoint;
+    private ClientConfigurations clientConfigurations;
+    private FunctionGraphClient functionGraphClient;
+    private BasicCredentials auth;
+    private HttpConfig httpConfig;
+
+    @Override
+    protected void doStart() throws Exception {
+        super.doStart();
+        this.clientConfigurations = new ClientConfigurations(this.endpoint);
+        initClient();
+    }
+
+    public FunctionGraphProducer(FunctionGraphEndpoint endpoint) {
+        super(endpoint);
+        this.endpoint = endpoint;
+    }
+
+    public void process(Exchange exchange) throws Exception {
+        updateClientConfigs(exchange);
+
+        switch (clientConfigurations.getOperation()) {
+            case FunctionGraphOperations.INVOKE_FUNCTION:","[{'comment': 'Are there plan to implement more operations? Otherwise there is not the need to the switch.', 'commenter': 'oscerd'}, {'comment': 'We will be supporting more operations soon', 'commenter': 'hokutor'}]"
5612,components/camel-huaweicloud-functiongraph/src/main/java/org/apache/camel/FunctionGraphProducer.java,"@@ -0,0 +1,246 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel;
+
+import com.fasterxml.jackson.core.JsonProcessingException;
+import com.fasterxml.jackson.databind.ObjectMapper;
+import com.huaweicloud.sdk.core.auth.BasicCredentials;
+import com.huaweicloud.sdk.core.http.HttpConfig;
+import com.huaweicloud.sdk.functiongraph.v2.FunctionGraphClient;
+import com.huaweicloud.sdk.functiongraph.v2.model.InvokeFunctionRequest;
+import com.huaweicloud.sdk.functiongraph.v2.model.InvokeFunctionResponse;
+import com.huaweicloud.sdk.functiongraph.v2.region.FunctionGraphRegion;
+import org.apache.camel.constants.FunctionGraphConstants;
+import org.apache.camel.constants.FunctionGraphOperations;
+import org.apache.camel.constants.FunctionGraphProperties;
+import org.apache.camel.models.ClientConfigurations;
+import org.apache.camel.support.DefaultProducer;
+import org.apache.camel.util.ObjectHelper;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.util.HashMap;
+import java.util.Map;
+
+public class FunctionGraphProducer extends DefaultProducer {
+    private static final Logger LOG = LoggerFactory.getLogger(FunctionGraphProducer.class);
+    private FunctionGraphEndpoint endpoint;
+    private ClientConfigurations clientConfigurations;
+    private FunctionGraphClient functionGraphClient;
+    private BasicCredentials auth;
+    private HttpConfig httpConfig;
+
+    @Override
+    protected void doStart() throws Exception {
+        super.doStart();
+        this.clientConfigurations = new ClientConfigurations(this.endpoint);
+        initClient();
+    }
+
+    public FunctionGraphProducer(FunctionGraphEndpoint endpoint) {
+        super(endpoint);
+        this.endpoint = endpoint;
+    }
+
+    public void process(Exchange exchange) throws Exception {
+        updateClientConfigs(exchange);
+
+        switch (clientConfigurations.getOperation()) {
+            case FunctionGraphOperations.INVOKE_FUNCTION:
+                invokeFunction(exchange);
+                break;
+            default:
+                throw new UnsupportedOperationException(String.format(""%s is not a supported operation"", clientConfigurations.getOperation()));
+        }
+    }
+
+    private void invokeFunction(Exchange exchange) {
+
+        // convert exchange body to Map object
+        Object body = exchange.getMessage().getBody();
+        Map request;
+        if (body == null) {
+            if (LOG.isErrorEnabled()) {
+                LOG.error(""Exchange body is null"");
+            }
+            throw new IllegalArgumentException(""Exchange body is mandatory and should be a valid Map or JSON string"");
+        } else if (body instanceof Map) {
+            request = exchange.getMessage().getBody(Map.class);
+        } else {
+            String strBody = exchange.getMessage().getBody(String.class);
+            try {
+                request = new ObjectMapper().readValue(strBody, HashMap.class);
+            } catch (JsonProcessingException e) {
+                if (LOG.isErrorEnabled()) {
+                    LOG.error(""Invalid response body given"");
+                }
+                throw new IllegalArgumentException(""Request body must be a JSON or a HashMap"");
+            }
+        }
+
+        // checking for function name and function package
+        if (ObjectHelper.isEmpty(clientConfigurations.getFunctionName())) {
+            if (LOG.isErrorEnabled()) {
+                LOG.error(""Function name not found."");
+            }
+            throw new IllegalArgumentException(""Function name is mandatory for invokeFunction."");
+        }
+        if (ObjectHelper.isEmpty(exchange.getProperty(FunctionGraphProperties.FUNCTION_PACKAGE))
+                && ObjectHelper.isEmpty(endpoint.getFunctionPackage())) {
+            if (LOG.isWarnEnabled()) {
+                LOG.warn(""Function package not found. Continuing to invoke function with 'default' function package"");
+            }
+        }
+
+        // invoke the function
+        InvokeFunctionRequest invokeFunctionRequest = new InvokeFunctionRequest()
+                .withBody(request)
+                .withFunctionUrn(FunctionGraphUtils.composeUrn(FunctionGraphConstants.URN_FORMAT, clientConfigurations))
+                .withXCFFRequestVersion(FunctionGraphConstants.REQUEST_VERSION);
+
+        if (ObjectHelper.isNotEmpty(clientConfigurations.getXCffLogType())) {
+            invokeFunctionRequest.withXCffLogType(clientConfigurations.getXCffLogType());
+        }
+
+        InvokeFunctionResponse response = functionGraphClient.invokeFunction(invokeFunctionRequest);
+        String responseBody = FunctionGraphUtils.extractJsonFieldAsString(response.getResult(), FunctionGraphConstants.RESPONSE_BODY);
+        exchange.getMessage().setBody(responseBody);
+        if (ObjectHelper.isNotEmpty(clientConfigurations.getXCffLogType())) {
+            exchange.setProperty(FunctionGraphProperties.XCFFLOGS, response.getLog());
+        }
+        LOG.info(""Invoke Function results: "" + response);
+    }
+
+    /**
+     * Initialize the client
+     */
+    private void initClient() {","[{'comment': ""This should be done in the endpoint. I don't think you'll change the client options many times. So it makes sense to do this just one time in endpoint and use client instance in producer."", 'commenter': 'oscerd'}, {'comment': 'Done', 'commenter': 'hokutor'}]"
5612,components/camel-huaweicloud-functiongraph/src/main/java/org/apache/camel/FunctionGraphProducer.java,"@@ -0,0 +1,246 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel;
+
+import com.fasterxml.jackson.core.JsonProcessingException;
+import com.fasterxml.jackson.databind.ObjectMapper;
+import com.huaweicloud.sdk.core.auth.BasicCredentials;
+import com.huaweicloud.sdk.core.http.HttpConfig;
+import com.huaweicloud.sdk.functiongraph.v2.FunctionGraphClient;
+import com.huaweicloud.sdk.functiongraph.v2.model.InvokeFunctionRequest;
+import com.huaweicloud.sdk.functiongraph.v2.model.InvokeFunctionResponse;
+import com.huaweicloud.sdk.functiongraph.v2.region.FunctionGraphRegion;
+import org.apache.camel.constants.FunctionGraphConstants;
+import org.apache.camel.constants.FunctionGraphOperations;
+import org.apache.camel.constants.FunctionGraphProperties;
+import org.apache.camel.models.ClientConfigurations;
+import org.apache.camel.support.DefaultProducer;
+import org.apache.camel.util.ObjectHelper;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.util.HashMap;
+import java.util.Map;
+
+public class FunctionGraphProducer extends DefaultProducer {
+    private static final Logger LOG = LoggerFactory.getLogger(FunctionGraphProducer.class);
+    private FunctionGraphEndpoint endpoint;
+    private ClientConfigurations clientConfigurations;
+    private FunctionGraphClient functionGraphClient;
+    private BasicCredentials auth;
+    private HttpConfig httpConfig;
+
+    @Override
+    protected void doStart() throws Exception {
+        super.doStart();
+        this.clientConfigurations = new ClientConfigurations(this.endpoint);
+        initClient();
+    }
+
+    public FunctionGraphProducer(FunctionGraphEndpoint endpoint) {
+        super(endpoint);
+        this.endpoint = endpoint;
+    }
+
+    public void process(Exchange exchange) throws Exception {
+        updateClientConfigs(exchange);
+
+        switch (clientConfigurations.getOperation()) {
+            case FunctionGraphOperations.INVOKE_FUNCTION:
+                invokeFunction(exchange);
+                break;
+            default:
+                throw new UnsupportedOperationException(String.format(""%s is not a supported operation"", clientConfigurations.getOperation()));
+        }
+    }
+
+    private void invokeFunction(Exchange exchange) {
+
+        // convert exchange body to Map object
+        Object body = exchange.getMessage().getBody();
+        Map request;
+        if (body == null) {
+            if (LOG.isErrorEnabled()) {
+                LOG.error(""Exchange body is null"");
+            }
+            throw new IllegalArgumentException(""Exchange body is mandatory and should be a valid Map or JSON string"");
+        } else if (body instanceof Map) {
+            request = exchange.getMessage().getBody(Map.class);
+        } else {
+            String strBody = exchange.getMessage().getBody(String.class);","[{'comment': 'Here you may face the case where the body is not a `String` nor `Map`', 'commenter': 'omarsmak'}, {'comment': 'Handled', 'commenter': 'hokutor'}]"
5613,components/camel-solr/src/main/java/org/apache/camel/component/solr/SolrComponent.java,"@@ -86,38 +113,105 @@ public SolrComponent() {
 
     @Override
     protected Endpoint createEndpoint(String uri, String remaining, Map<String, Object> parameters) throws Exception {
-        Endpoint endpoint = new SolrEndpoint(uri, this, remaining);
+        SolrConfiguration configuration = new SolrConfiguration(uri, remaining);
+        Endpoint endpoint = new SolrEndpoint(uri, this, configuration);
         setProperties(endpoint, parameters);
         return endpoint;
     }
 
+    public SolrClient getSolrClient(SolrProducer solrProducer, SolrConfiguration solrConfiguration) throws Exception {
+        String signature = solrConfiguration.getSignature();
+        SolrClientReference solrClientReference;
+        if (!solrClientMap.containsKey(signature)) {
+            solrClientReference = new SolrClientReference(solrConfiguration.initSolrClient());
+            solrClientMap.put(signature, solrClientReference);
+            // backward compatibility
+            addSolrClientToSolrServerReference(solrConfiguration, solrClientReference.getSolrClient());
+        } else {
+            solrClientReference = solrClientMap.get(signature);
+        }
+        // register producer against solrClient (for later close of client)
+        solrClientReference.registerSolrProducer(solrProducer);
+        return solrClientReference.getSolrClient();
+    }
+
+    private void addSolrClientToSolrServerReference(SolrConfiguration solrConfiguration, SolrClient solrClient) {
+        SolrEndpoint solrEndpoint = solrConfiguration.getSolrEndpoint();
+        if (solrEndpoint != null) {
+            SolrServerReference solrServerReference = servers.get(solrEndpoint);
+            if (solrServerReference == null) {
+                solrServerReference = new SolrServerReference();
+                servers.put(solrEndpoint, solrServerReference);
+            }
+            if (solrClient instanceof CloudSolrClient) {
+                solrServerReference.setCloudSolrServer((CloudSolrClient) solrClient);
+            }
+            if (solrClient instanceof ConcurrentUpdateSolrClient) {
+                solrServerReference.setUpdateSolrServer((ConcurrentUpdateSolrClient) solrClient);
+            }
+            if (solrClient instanceof HttpSolrClient) {
+                solrServerReference.setSolrServer((HttpSolrClient) solrClient);
+            }
+        }
+    }
+
+    public void closeSolrClient(SolrProducer solrProducer) {
+        // close when generated for endpoint
+        List<String> signatureToRemoveList = new ArrayList<>();
+        for (Map.Entry<String, SolrClientReference> entry : solrClientMap.entrySet()) {
+            SolrClientReference solrClientReference = entry.getValue();
+            if (solrClientReference.unRegisterSolrProducer(solrProducer) == 0) {
+                signatureToRemoveList.add(entry.getKey());
+            }
+        }
+        removeFromSolrClientMap(signatureToRemoveList);
+    }
+
+    private void removeFromSolrClientMap(Collection<String> signatureToRemoveList) {
+        for (String signature : signatureToRemoveList) {
+            SolrClientReference solrClientReference = solrClientMap.get(signature);
+            solrClientMap.remove(signature);
+            try {
+                solrClientReference.getSolrClient().close();
+            } catch (IOException e) {
+                LOG.warn(""Error shutting down solr client. This exception is ignored."", e);
+            }
+        }
+    }
+
+    @Deprecated
     public SolrServerReference getSolrServers(SolrEndpoint endpoint) {
         return servers.get(endpoint);
     }
 
+    @Deprecated
     public void addSolrServers(SolrEndpoint endpoint, SolrServerReference servers) {
         this.servers.put(endpoint, servers);
     }
 
     @Override
     protected void doShutdown() throws Exception {
+        removeFromSolrClientMap(solrClientMap.keySet());
         for (SolrServerReference server : servers.values()) {
             shutdownServers(server);
         }
         servers.clear();
     }
 
+    @Deprecated","[{'comment': 'If those methods are not used anymore, you can safely remove them. We are going to release an LTS release with 3.11.0, so we are under heavy developments, so you can remove methods like these.', 'commenter': 'oscerd'}, {'comment': 'ok, thanks', 'commenter': 'Paul-Blanchaert'}]"
5613,components/camel-solr/src/main/java/org/apache/camel/component/solr/SolrConfiguration.java,"@@ -0,0 +1,532 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.solr;
+
+import java.net.MalformedURLException;
+import java.net.URL;
+import java.util.Arrays;
+import java.util.List;
+import java.util.Optional;
+import java.util.stream.Collectors;
+
+import org.apache.camel.spi.Metadata;
+import org.apache.camel.spi.UriParam;
+import org.apache.camel.spi.UriParams;
+import org.apache.camel.spi.UriPath;
+import org.apache.camel.util.StringHelper;
+import org.apache.http.client.HttpClient;
+import org.apache.solr.client.solrj.SolrClient;
+import org.apache.solr.client.solrj.impl.CloudSolrClient;
+import org.apache.solr.client.solrj.impl.ConcurrentUpdateSolrClient;
+import org.apache.solr.client.solrj.impl.HttpSolrClient;
+import org.apache.solr.client.solrj.impl.LBHttpSolrClient;
+
+@UriParams
+public class SolrConfiguration implements Cloneable {
+
+    private final SolrScheme solrScheme;
+
+    private boolean useConcurrentUpdateSolrClient;
+    private SolrEndpoint solrEndpoint;
+
+    @UriPath(description = ""Hostname and port for the Solr server(s). "" +
+                           ""Multiple hosts can be specified, separated with a comma. "" +
+                           ""See the solrClient parameter for more information on the SolrClient used to connect to Solr."")
+    @Metadata(required = true)
+    private String url;
+    @UriParam(defaultValue = """" + SolrConstants.DEFUALT_STREAMING_QUEUE_SIZE)
+    private int streamingQueueSize = SolrConstants.DEFUALT_STREAMING_QUEUE_SIZE;
+    @UriParam(defaultValue = """" + SolrConstants.DEFAULT_STREAMING_THREAD_COUNT)
+    private int streamingThreadCount = SolrConstants.DEFAULT_STREAMING_THREAD_COUNT;
+    @UriParam
+    private Integer soTimeout;
+    @UriParam
+    private Integer connectionTimeout;
+    @UriParam(label = ""HttpSolrClient"")
+    private Boolean followRedirects;
+    @UriParam(label = ""HttpSolrClient"")
+    private Boolean allowCompression;
+    @UriParam(label = ""CloudSolrClient"")
+    private String zkHost;
+    @UriParam(label = ""CloudSolrClient"")
+    private String zkChroot;
+    @UriParam(label = ""CloudSolrClient"")
+    private String collection;
+    @UriParam
+    private SolrClient solrClient;
+    @UriParam
+    private HttpClient httpClient;
+    @UriParam
+    private String requestHandler;
+    @UriParam(label = ""security"", secret = true)
+    private String username;
+    @UriParam(label = ""security"", secret = true)
+    private String password;
+    @UriParam(defaultValue = ""false"")
+    private boolean autoCommit;
+    @Deprecated
+    @UriParam
+    private Integer maxRetries;
+    @Deprecated
+    @UriParam
+    private Integer defaultMaxConnectionsPerHost;
+    @Deprecated
+    @UriParam
+    private Integer maxTotalConnections;
+
+    public SolrConfiguration(String endpointUri, String remaining) throws Exception {
+        solrScheme = SolrScheme.SOLR.getFrom(endpointUri);
+        Optional<String> chroot = getChrootFromPath(remaining);
+        if (chroot.isPresent()) {
+            zkChroot = chroot.get();
+        }
+        url = parseHostsFromUrl(remaining, chroot);
+        // validate url
+        getUrlListFrom(url);
+    }
+
+    public SolrScheme getSolrScheme() {
+        return solrScheme;
+    }
+
+    public int getStreamingQueueSize() {
+        return streamingQueueSize;
+    }
+
+    /**
+     * Sets the queue size for the ConcurrentUpdateSolrClient
+     */
+    public void setStreamingQueueSize(int streamingQueueSize) {
+        this.streamingQueueSize = streamingQueueSize;
+    }
+
+    public int getStreamingThreadCount() {
+        return streamingThreadCount;
+    }
+
+    /**
+     * Sets the number of threads for the ConcurrentUpdateSolrClient
+     */
+    public void setStreamingThreadCount(int streamingThreadCount) {
+        this.streamingThreadCount = streamingThreadCount;
+    }
+
+    public Integer getMaxRetries() {
+        return maxRetries;
+    }
+
+    /**
+     * Maximum number of retries to attempt in the event of transient errors
+     */
+    public void setMaxRetries(Integer maxRetries) {
+        this.maxRetries = maxRetries;
+    }
+
+    public Integer getSoTimeout() {
+        return soTimeout;
+    }
+
+    /**
+     * Sets the socket timeout on the SolrClient
+     */
+    public void setSoTimeout(Integer soTimeout) {
+        this.soTimeout = soTimeout;
+    }
+
+    public Integer getConnectionTimeout() {
+        return connectionTimeout;
+    }
+
+    /**
+     * Sets the connection timeout on the SolrClient
+     */
+    public void setConnectionTimeout(Integer connectionTimeout) {
+        this.connectionTimeout = connectionTimeout;
+    }
+
+    public Integer getDefaultMaxConnectionsPerHost() {
+        return defaultMaxConnectionsPerHost;
+    }
+
+    /**
+     * maxConnectionsPerHost on the underlying HttpConnectionManager
+     */
+    public void setDefaultMaxConnectionsPerHost(Integer defaultMaxConnectionsPerHost) {
+        this.defaultMaxConnectionsPerHost = defaultMaxConnectionsPerHost;
+    }
+
+    public Integer getMaxTotalConnections() {
+        return maxTotalConnections;
+    }
+
+    /**
+     * maxTotalConnection on the underlying HttpConnectionManager
+     */
+    public void setMaxTotalConnections(Integer maxTotalConnections) {
+        this.maxTotalConnections = maxTotalConnections;
+    }
+
+    public Boolean getFollowRedirects() {
+        return followRedirects;
+    }
+
+    /**
+     * Indicates whether redirects are used to get to the Solr server
+     */
+    public void setFollowRedirects(Boolean followRedirects) {
+        this.followRedirects = followRedirects;
+    }
+
+    public Boolean getAllowCompression() {
+        return allowCompression;
+    }
+
+    /**
+     * Server side must support gzip or deflate for this to have any effect
+     */
+    public void setAllowCompression(Boolean allowCompression) {
+        this.allowCompression = allowCompression;
+    }
+
+    public String getZkHost() {
+        return zkHost;
+    }
+
+    /**
+     * Set the ZooKeeper host(s) urls which the CloudSolrClient uses, e.g. ""zkHost=localhost:8123,localhost:8124"".
+     * Optionally add the chroot, e.g. ""zkHost=localhost:8123,localhost:8124/rootformysolr"". In case the first part of
+     * the chroot path in the zkHost parameter is set to 'solr' (e.g. 'localhost:8123/solr' or
+     * 'localhost:8123/solr/..'), then that path is not considered as zookeeper chroot for backward compatibility
+     * reasons (this behaviour can be overridden via zkChroot parameter).
+     */
+    public void setZkHost(String zkHost) {
+        Optional<String> chroot = getChrootFromPath(zkHost);
+        if (chroot.isPresent()) {
+            this.zkChroot = chroot.get();
+        }
+        this.zkHost = parseHostsFromUrl(zkHost, chroot);
+    }
+
+    public String getZkChroot() {
+        return zkChroot;
+    }
+
+    /**
+     * Set the chroot of the zookeeper connection (include the leading slash; e.g. '/mychroot')
+     */
+    public void setZkChroot(String zkChroot) {
+        this.zkChroot = zkChroot;
+    }
+
+    public String getCollection() {
+        return collection;
+    }
+
+    /**
+     * Set the default collection for SolrCloud
+     */
+    public void setCollection(String collection) {
+        this.collection = collection;
+    }
+
+    public String getRequestHandler() {
+        return requestHandler;
+    }
+
+    /**
+     * Set the request handler to be used
+     */
+    public void setRequestHandler(String requestHandler) {
+        this.requestHandler = requestHandler;
+    }
+
+    public String getUsername() {
+        return username;
+    }
+
+    /**
+     * Sets username for basic auth plugin enabled servers
+     */
+    public void setUsername(String username) {
+        this.username = username;
+    }
+
+    public String getPassword() {
+        return password;
+    }
+
+    /**
+     * Sets password for basic auth plugin enabled servers
+     */
+    public void setPassword(String password) {
+        this.password = password;
+    }
+
+    public boolean isAutoCommit() {
+        return autoCommit;
+    }
+
+    /**
+     * If true, each producer operation will be automatically followed by a commit
+     */
+    public void setAutoCommit(boolean autoCommit) {
+        this.autoCommit = autoCommit;
+    }
+
+    public SolrClient getSolrClient() {
+        return solrClient;
+    }
+
+    /**
+     * Uses the provided solr client to connect to solr. When this parameter is not specified, camel applies the
+     * following rules to determine the SolrClient. A CloudSolrClient should point to a zookeeper endpoint. Other
+     * clients point to a Solr endpoint. 1) when zkHost or zkChroot (=zookeeper root) parameter is set, then the
+     * CloudSolrClient is used. 2) when multiple hosts are specified in the uri (separated with a comma), then the
+     * CloudSolrClient (uri scheme is 'solrCloud') or the LBHttpSolrClient (uri scheme is not 'solrCloud') is used. 3)
+     * when the solr operation is INSERT_STREAMING, then the ConcurrentUpdateSolrClient is used. 4) otherwise, the
+     * HttpSolrClient is used.
+     */
+    public void setSolrClient(SolrClient solrClient) {
+        this.solrClient = solrClient;
+    }
+
+    public HttpClient getHttpClient() {
+        return httpClient;
+    }
+
+    /**
+     * Sets the http client to be used by the solrClient
+     */
+    public void setHttpClient(HttpClient httpClient) {
+        this.httpClient = httpClient;
+    }
+
+    public Boolean getUseConcurrentUpdateSolrClient() {
+        return useConcurrentUpdateSolrClient;
+    }
+
+    void setUseConcurrentUpdateSolrClient(boolean useConcurrentUpdateSolrClient) {
+        this.useConcurrentUpdateSolrClient = useConcurrentUpdateSolrClient;
+    }
+
+    public SolrEndpoint getSolrEndpoint() {
+        return solrEndpoint;
+    }
+
+    void setSolrEndpoint(SolrEndpoint solrEndpoint) {
+        this.solrEndpoint = solrEndpoint;
+    }
+
+    private String getFirstUrlFrom(String url) throws Exception {
+        return getUrlListFrom(url).get(0);
+    }
+
+    private List<String> getUrlListFrom(String url) throws Exception {
+        // add scheme when required
+        List<String> urlList = Arrays
+                .asList(url.split("",""))
+                .stream()
+                .map(s -> solrScheme.getScheme().concat(s))
+                .collect(Collectors.toList());
+        // validate url syntax via parsing in URL instance
+        for (String s : urlList) {
+            try {
+                // solrCloud requires addition of HTTP scheme to be able to consider it as a valid URL scheme
+                new URL(
+                        SolrScheme.SOLRCLOUD.equals(solrScheme) ? SolrScheme.SOLR.getScheme().concat(s) : s);
+            } catch (MalformedURLException e) {
+                throw new IllegalArgumentException(
+                        String.format(
+                                ""Url '%s' not valid for endpoint with uri=%s"",
+                                s,
+                                solrScheme.getUri()));
+            }
+        }
+        return urlList;
+    }
+
+    /**
+     * signature defines parameters deciding whether or not to share the solrClient - sharing allowed: same signature -
+     * sharing not allowed: different signature
+     */
+    public String getSignature() {","[{'comment': 'These seems utility methods. I think they should be in a separated class instead that the configuration class.', 'commenter': 'oscerd'}]"
5613,components/camel-solr/src/main/java/org/apache/camel/component/solr/SolrComponent.java,"@@ -17,8 +17,7 @@
 package org.apache.camel.component.solr;
 
 import java.io.IOException;
-import java.util.HashMap;
-import java.util.Map;
+import java.util.*;","[{'comment': 'Please remove the wildcard import', 'commenter': 'omarsmak'}, {'comment': 'ok, done', 'commenter': 'Paul-Blanchaert'}]"
5613,test-infra/camel-test-infra-solr/pom.xml,"@@ -0,0 +1,60 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one or more
+    contributor license agreements.  See the NOTICE file distributed with
+    this work for additional information regarding copyright ownership.
+    The ASF licenses this file to You under the Apache License, Version 2.0
+    (the ""License""); you may not use this file except in compliance with
+    the License.  You may obtain a copy of the License at
+
+         http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an ""AS IS"" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+
+-->
+<project xmlns=""http://maven.apache.org/POM/4.0.0""
+         xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
+         xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"">
+    <parent>
+        <artifactId>camel-test-infra-parent</artifactId>
+        <groupId>org.apache.camel</groupId>
+        <relativePath>../camel-test-infra-parent/pom.xml</relativePath>
+        <version>3.10.0-SNAPSHOT</version>","[{'comment': 'We released 3.10.0, so this needs to be moved to 3.11.0-SNAPSHOT and the PR needs to be aligned. Thanks!', 'commenter': 'oscerd'}, {'comment': 'ok, done', 'commenter': 'Paul-Blanchaert'}]"
5621,components/camel-jbpm/src/main/java/org/apache/camel/component/jbpm/JBPMOperation.java,"@@ -0,0 +1,49 @@
+package org.apache.camel.component.jbpm;","[{'comment': 'This needs to have the license header ', 'commenter': 'oscerd'}, {'comment': 'added', 'commenter': 'elguardian'}]"
5657,components/camel-zipkin/src/main/java/org/apache/camel/zipkin/ZipkinServerResponseAdapter.java,"@@ -45,7 +45,7 @@ void onResponse(Exchange exchange, SpanCustomizer span) {
         span.tag(""camel.server.exchange.id"", id);
         span.tag(""camel.server.exchange.pattern"", mep);
 
-        if (exchange.getException() != null) {
+        if (exchange.getException() != null && exchange.getException().getMessage() != null) {","[{'comment': 'There is still a failure, so you should instead if the message is null, create a empty message, or use the exception classname as the message.', 'commenter': 'davsclaus'}, {'comment': ""So I'll roll back that if statement and if _message_ is null (or blank???) I will change it to exception classname, is that right? "", 'commenter': 'p-8-z'}, {'comment': 'Yes correct, then we always ensure that if an exception occurred then zipkin gets that as a failure event', 'commenter': 'davsclaus'}, {'comment': 'Change request done. ', 'commenter': 'p-8-z'}]"
5657,components/camel-zipkin/pom.xml,"@@ -45,6 +45,12 @@
             <artifactId>camel-support</artifactId>
         </dependency>
 
+        <dependency>","[{'comment': ""Please do not add a new dependency just for checking if a string is empty/black.\r\n\r\nYou can use Camel's own \r\n\r\norg/apache/camel/util/ObjectHelper.isEmpty"", 'commenter': 'davsclaus'}, {'comment': 'Change request done.\r\n\r\n', 'commenter': 'p-8-z'}]"
5753,components/camel-huawei/camel-huaweicloud-obs/src/main/java/org/apache/camel/component/huaweicloud/obs/OBSEndpoint.java,"@@ -0,0 +1,278 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.huaweicloud.obs;
+
+import com.obs.services.HttpProxyConfiguration;
+import com.obs.services.ObsClient;
+import com.obs.services.ObsConfiguration;
+import org.apache.camel.Category;
+import org.apache.camel.Consumer;
+import org.apache.camel.Processor;
+import org.apache.camel.Producer;
+import org.apache.camel.component.huaweicloud.obs.models.OBSRegion;
+import org.apache.camel.component.huaweicloud.obs.models.ServiceKeys;
+import org.apache.camel.spi.Metadata;
+import org.apache.camel.spi.UriEndpoint;
+import org.apache.camel.spi.UriParam;
+import org.apache.camel.spi.UriPath;
+import org.apache.camel.support.DefaultEndpoint;
+import org.apache.camel.util.ObjectHelper;
+
+/**
+ * To provide stable, secure, efficient, and easy-to-use cloud storage service on Huawei Cloud
+ */
+@UriEndpoint(firstVersion = ""3.11.0"", scheme = ""hwcloud-obs"", title = ""Huawei Cloud Object Storage Service (OBS)"",","[{'comment': 'I guess this will be targeting 3.12 since 3.11 has been released?', 'commenter': 'omarsmak'}, {'comment': 'Done. Changed firstVersion to 3.12.0 and pom version to 3.12.0-SNAPSHOT', 'commenter': 'hokutor'}]"
5753,components/camel-huawei/camel-huaweicloud-obs/src/main/java/org/apache/camel/component/huaweicloud/obs/OBSEndpoint.java,"@@ -0,0 +1,278 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.huaweicloud.obs;
+
+import com.obs.services.HttpProxyConfiguration;
+import com.obs.services.ObsClient;
+import com.obs.services.ObsConfiguration;
+import org.apache.camel.Category;
+import org.apache.camel.Consumer;
+import org.apache.camel.Processor;
+import org.apache.camel.Producer;
+import org.apache.camel.component.huaweicloud.obs.models.OBSRegion;
+import org.apache.camel.component.huaweicloud.obs.models.ServiceKeys;
+import org.apache.camel.spi.Metadata;
+import org.apache.camel.spi.UriEndpoint;
+import org.apache.camel.spi.UriParam;
+import org.apache.camel.spi.UriPath;
+import org.apache.camel.support.DefaultEndpoint;
+import org.apache.camel.util.ObjectHelper;
+
+/**
+ * To provide stable, secure, efficient, and easy-to-use cloud storage service on Huawei Cloud
+ */
+@UriEndpoint(firstVersion = ""3.11.0"", scheme = ""hwcloud-obs"", title = ""Huawei Cloud Object Storage Service (OBS)"",
+             syntax = ""hwcloud-obs:operation"",
+             category = { Category.CLOUD })
+public class OBSEndpoint extends DefaultEndpoint {
+
+    @UriPath(description = ""Operation to be performed"", displayName = ""Operation"", label = ""producer"", secret = false)","[{'comment': 'no need to add `secret=false`, it is by default `false`', 'commenter': 'omarsmak'}, {'comment': 'Done. Removed secret = false from all parameters with it', 'commenter': 'hokutor'}]"
5753,components/camel-huawei/camel-huaweicloud-obs/src/main/java/org/apache/camel/component/huaweicloud/obs/OBSProducer.java,"@@ -0,0 +1,225 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.huaweicloud.obs;
+
+import com.fasterxml.jackson.core.JsonProcessingException;
+import com.fasterxml.jackson.databind.ObjectMapper;
+import com.google.gson.Gson;
+import com.obs.services.ObsClient;
+import com.obs.services.exception.ObsException;
+import com.obs.services.model.CreateBucketRequest;
+import com.obs.services.model.HeaderResponse;
+import com.obs.services.model.ListBucketsRequest;
+import com.obs.services.model.ListBucketsResult;
+import com.obs.services.model.ObsBucket;
+import org.apache.camel.Exchange;
+import org.apache.camel.component.huaweicloud.obs.constants.OBSConstants;
+import org.apache.camel.component.huaweicloud.obs.constants.OBSOperations;
+import org.apache.camel.component.huaweicloud.obs.constants.OBSProperties;
+import org.apache.camel.component.huaweicloud.obs.models.ClientConfigurations;
+import org.apache.camel.component.huaweicloud.obs.models.OBSRegion;
+import org.apache.camel.support.DefaultProducer;
+import org.apache.camel.util.ObjectHelper;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class OBSProducer extends DefaultProducer {
+    private static final Logger LOG = LoggerFactory.getLogger(OBSProducer.class);
+    private OBSEndpoint endpoint;
+    private ClientConfigurations clientConfigurations;
+    private ObsClient obsClient;
+    private Gson gson;
+
+    public OBSProducer(OBSEndpoint endpoint) {
+        super(endpoint);
+        this.endpoint = endpoint;
+    }
+
+    @Override
+    protected void doStart() throws Exception {
+        super.doStart();
+        this.clientConfigurations = new ClientConfigurations();","[{'comment': 'I think initializing new objects could be moved to `doInit`', 'commenter': 'omarsmak'}, {'comment': 'Done. Initializing objects now done in doInit instead of doStart', 'commenter': 'hokutor'}]"
5753,components/camel-huawei/camel-huaweicloud-obs/src/main/java/org/apache/camel/component/huaweicloud/obs/OBSProducer.java,"@@ -0,0 +1,225 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.huaweicloud.obs;
+
+import com.fasterxml.jackson.core.JsonProcessingException;
+import com.fasterxml.jackson.databind.ObjectMapper;
+import com.google.gson.Gson;
+import com.obs.services.ObsClient;
+import com.obs.services.exception.ObsException;
+import com.obs.services.model.CreateBucketRequest;
+import com.obs.services.model.HeaderResponse;
+import com.obs.services.model.ListBucketsRequest;
+import com.obs.services.model.ListBucketsResult;
+import com.obs.services.model.ObsBucket;
+import org.apache.camel.Exchange;
+import org.apache.camel.component.huaweicloud.obs.constants.OBSConstants;
+import org.apache.camel.component.huaweicloud.obs.constants.OBSOperations;
+import org.apache.camel.component.huaweicloud.obs.constants.OBSProperties;
+import org.apache.camel.component.huaweicloud.obs.models.ClientConfigurations;
+import org.apache.camel.component.huaweicloud.obs.models.OBSRegion;
+import org.apache.camel.support.DefaultProducer;
+import org.apache.camel.util.ObjectHelper;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class OBSProducer extends DefaultProducer {
+    private static final Logger LOG = LoggerFactory.getLogger(OBSProducer.class);
+    private OBSEndpoint endpoint;
+    private ClientConfigurations clientConfigurations;
+    private ObsClient obsClient;
+    private Gson gson;
+
+    public OBSProducer(OBSEndpoint endpoint) {
+        super(endpoint);
+        this.endpoint = endpoint;
+    }
+
+    @Override
+    protected void doStart() throws Exception {
+        super.doStart();
+        this.clientConfigurations = new ClientConfigurations();
+        this.obsClient = this.endpoint.initClient();
+        this.gson = new Gson();","[{'comment': 'same here', 'commenter': 'omarsmak'}]"
5753,components/camel-huawei/camel-huaweicloud-obs/src/main/java/org/apache/camel/component/huaweicloud/obs/OBSProducer.java,"@@ -0,0 +1,225 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.huaweicloud.obs;
+
+import com.fasterxml.jackson.core.JsonProcessingException;
+import com.fasterxml.jackson.databind.ObjectMapper;
+import com.google.gson.Gson;
+import com.obs.services.ObsClient;
+import com.obs.services.exception.ObsException;
+import com.obs.services.model.CreateBucketRequest;
+import com.obs.services.model.HeaderResponse;
+import com.obs.services.model.ListBucketsRequest;
+import com.obs.services.model.ListBucketsResult;
+import com.obs.services.model.ObsBucket;
+import org.apache.camel.Exchange;
+import org.apache.camel.component.huaweicloud.obs.constants.OBSConstants;
+import org.apache.camel.component.huaweicloud.obs.constants.OBSOperations;
+import org.apache.camel.component.huaweicloud.obs.constants.OBSProperties;
+import org.apache.camel.component.huaweicloud.obs.models.ClientConfigurations;
+import org.apache.camel.component.huaweicloud.obs.models.OBSRegion;
+import org.apache.camel.support.DefaultProducer;
+import org.apache.camel.util.ObjectHelper;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class OBSProducer extends DefaultProducer {
+    private static final Logger LOG = LoggerFactory.getLogger(OBSProducer.class);
+    private OBSEndpoint endpoint;
+    private ClientConfigurations clientConfigurations;
+    private ObsClient obsClient;
+    private Gson gson;
+
+    public OBSProducer(OBSEndpoint endpoint) {
+        super(endpoint);
+        this.endpoint = endpoint;
+    }
+
+    @Override
+    protected void doInit() throws Exception {
+        super.doInit();
+        this.clientConfigurations = new ClientConfigurations();
+        this.obsClient = this.endpoint.initClient();
+        this.gson = new Gson();
+    }
+
+    public void process(Exchange exchange) throws Exception {
+        updateClientConfigs(exchange);
+
+        try {
+            switch (clientConfigurations.getOperation()) {
+                case OBSOperations.LIST_BUCKETS:
+                    listBuckets(exchange);
+                    break;
+                case OBSOperations.CREATE_BUCKET:
+                    createBucket(exchange);
+                    break;
+                case OBSOperations.DELETE_BUCKET:
+                    deleteBucket(exchange);
+                    break;
+                default:
+                    throw new UnsupportedOperationException(
+                            String.format(""%s is not a supported operation"", clientConfigurations.getOperation()));
+            }
+        } catch (ObsException e) {
+            if (LOG.isErrorEnabled()) {","[{'comment': 'Do not LOG and re-throw. Remove this!', 'commenter': 'davsclaus'}, {'comment': 'Done. Try-catch block removed', 'commenter': 'hokutor'}]"
5753,components/camel-huawei/camel-huaweicloud-obs/src/main/java/org/apache/camel/component/huaweicloud/obs/OBSProducer.java,"@@ -0,0 +1,225 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.huaweicloud.obs;
+
+import com.fasterxml.jackson.core.JsonProcessingException;
+import com.fasterxml.jackson.databind.ObjectMapper;
+import com.google.gson.Gson;
+import com.obs.services.ObsClient;
+import com.obs.services.exception.ObsException;
+import com.obs.services.model.CreateBucketRequest;
+import com.obs.services.model.HeaderResponse;
+import com.obs.services.model.ListBucketsRequest;
+import com.obs.services.model.ListBucketsResult;
+import com.obs.services.model.ObsBucket;
+import org.apache.camel.Exchange;
+import org.apache.camel.component.huaweicloud.obs.constants.OBSConstants;
+import org.apache.camel.component.huaweicloud.obs.constants.OBSOperations;
+import org.apache.camel.component.huaweicloud.obs.constants.OBSProperties;
+import org.apache.camel.component.huaweicloud.obs.models.ClientConfigurations;
+import org.apache.camel.component.huaweicloud.obs.models.OBSRegion;
+import org.apache.camel.support.DefaultProducer;
+import org.apache.camel.util.ObjectHelper;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class OBSProducer extends DefaultProducer {
+    private static final Logger LOG = LoggerFactory.getLogger(OBSProducer.class);
+    private OBSEndpoint endpoint;
+    private ClientConfigurations clientConfigurations;
+    private ObsClient obsClient;
+    private Gson gson;
+
+    public OBSProducer(OBSEndpoint endpoint) {
+        super(endpoint);
+        this.endpoint = endpoint;
+    }
+
+    @Override
+    protected void doInit() throws Exception {
+        super.doInit();
+        this.clientConfigurations = new ClientConfigurations();
+        this.obsClient = this.endpoint.initClient();
+        this.gson = new Gson();
+    }
+
+    public void process(Exchange exchange) throws Exception {
+        updateClientConfigs(exchange);
+
+        try {
+            switch (clientConfigurations.getOperation()) {
+                case OBSOperations.LIST_BUCKETS:
+                    listBuckets(exchange);
+                    break;
+                case OBSOperations.CREATE_BUCKET:
+                    createBucket(exchange);
+                    break;
+                case OBSOperations.DELETE_BUCKET:
+                    deleteBucket(exchange);
+                    break;
+                default:
+                    throw new UnsupportedOperationException(
+                            String.format(""%s is not a supported operation"", clientConfigurations.getOperation()));
+            }
+        } catch (ObsException e) {
+            if (LOG.isErrorEnabled()) {
+                LOG.error(""Failed to perform operation"");
+                LOG.error(""HTTP Code: "" + e.getResponseCode());
+                LOG.error(""Error Code: "" + e.getErrorCode());
+                LOG.error(""Error Message: "" + e.getErrorMessage());
+                LOG.error(""Request ID: "" + e.getErrorRequestId());
+                LOG.error(""Host ID: "" + e.getErrorHostId());
+            }
+            throw e;
+        }
+    }
+
+    /**
+     * Perform list buckets operation
+     *
+     * @param exchange
+     */
+    private void listBuckets(Exchange exchange) throws ObsException {
+        // invoke list buckets method and map response object to exchange body
+        ListBucketsRequest request = new ListBucketsRequest();
+        ListBucketsResult response = obsClient.listBucketsV2(request);
+        exchange.getMessage().setBody(gson.toJson(response.getBuckets()));
+    }
+
+    /**
+     * Perform create bucket operation
+     *
+     * @param exchange
+     */
+    private void createBucket(Exchange exchange) throws ObsException {
+        CreateBucketRequest request = null;
+
+        // checking if user inputted exchange body containing bucket information. Body must be a CreateBucketRequest or a valid JSON string (Advanced users)
+        Object exchangeBody = exchange.getMessage().getBody();
+        if (exchangeBody instanceof CreateBucketRequest) {
+            request = (CreateBucketRequest) exchangeBody;
+        } else if (exchangeBody instanceof String) {
+            String strBody = (String) exchangeBody;
+            try {
+                request = new ObjectMapper().readValue(strBody, CreateBucketRequest.class);
+            } catch (JsonProcessingException e) {
+                if (LOG.isWarnEnabled()) {
+                    LOG.warn(
+                            ""String request body must be a valid JSON representation of a CreateBucketRequest. Attempting to create a bucket from endpoint parameters"");
+                }
+            }
+        }
+
+        // if no CreateBucketRequest was found in the exchange body, then create one from endpoint parameters (Basic users)
+        if (request == null) {
+            // check for bucket name, which is mandatory to create a new bucket
+            if (ObjectHelper.isEmpty(clientConfigurations.getBucketName())) {
+                if (LOG.isErrorEnabled()) {","[{'comment': 'Remove this', 'commenter': 'davsclaus'}, {'comment': 'Done. Removed LOG error/warn checks', 'commenter': 'hokutor'}]"
5753,components/camel-huawei/camel-huaweicloud-obs/src/main/java/org/apache/camel/component/huaweicloud/obs/OBSProducer.java,"@@ -0,0 +1,225 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.huaweicloud.obs;
+
+import com.fasterxml.jackson.core.JsonProcessingException;
+import com.fasterxml.jackson.databind.ObjectMapper;
+import com.google.gson.Gson;
+import com.obs.services.ObsClient;
+import com.obs.services.exception.ObsException;
+import com.obs.services.model.CreateBucketRequest;
+import com.obs.services.model.HeaderResponse;
+import com.obs.services.model.ListBucketsRequest;
+import com.obs.services.model.ListBucketsResult;
+import com.obs.services.model.ObsBucket;
+import org.apache.camel.Exchange;
+import org.apache.camel.component.huaweicloud.obs.constants.OBSConstants;
+import org.apache.camel.component.huaweicloud.obs.constants.OBSOperations;
+import org.apache.camel.component.huaweicloud.obs.constants.OBSProperties;
+import org.apache.camel.component.huaweicloud.obs.models.ClientConfigurations;
+import org.apache.camel.component.huaweicloud.obs.models.OBSRegion;
+import org.apache.camel.support.DefaultProducer;
+import org.apache.camel.util.ObjectHelper;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class OBSProducer extends DefaultProducer {
+    private static final Logger LOG = LoggerFactory.getLogger(OBSProducer.class);
+    private OBSEndpoint endpoint;
+    private ClientConfigurations clientConfigurations;
+    private ObsClient obsClient;
+    private Gson gson;
+
+    public OBSProducer(OBSEndpoint endpoint) {
+        super(endpoint);
+        this.endpoint = endpoint;
+    }
+
+    @Override
+    protected void doInit() throws Exception {
+        super.doInit();
+        this.clientConfigurations = new ClientConfigurations();
+        this.obsClient = this.endpoint.initClient();
+        this.gson = new Gson();
+    }
+
+    public void process(Exchange exchange) throws Exception {
+        updateClientConfigs(exchange);
+
+        try {
+            switch (clientConfigurations.getOperation()) {
+                case OBSOperations.LIST_BUCKETS:
+                    listBuckets(exchange);
+                    break;
+                case OBSOperations.CREATE_BUCKET:
+                    createBucket(exchange);
+                    break;
+                case OBSOperations.DELETE_BUCKET:
+                    deleteBucket(exchange);
+                    break;
+                default:
+                    throw new UnsupportedOperationException(
+                            String.format(""%s is not a supported operation"", clientConfigurations.getOperation()));
+            }
+        } catch (ObsException e) {
+            if (LOG.isErrorEnabled()) {
+                LOG.error(""Failed to perform operation"");
+                LOG.error(""HTTP Code: "" + e.getResponseCode());
+                LOG.error(""Error Code: "" + e.getErrorCode());
+                LOG.error(""Error Message: "" + e.getErrorMessage());
+                LOG.error(""Request ID: "" + e.getErrorRequestId());
+                LOG.error(""Host ID: "" + e.getErrorHostId());
+            }
+            throw e;
+        }
+    }
+
+    /**
+     * Perform list buckets operation
+     *
+     * @param exchange
+     */
+    private void listBuckets(Exchange exchange) throws ObsException {
+        // invoke list buckets method and map response object to exchange body
+        ListBucketsRequest request = new ListBucketsRequest();
+        ListBucketsResult response = obsClient.listBucketsV2(request);
+        exchange.getMessage().setBody(gson.toJson(response.getBuckets()));
+    }
+
+    /**
+     * Perform create bucket operation
+     *
+     * @param exchange
+     */
+    private void createBucket(Exchange exchange) throws ObsException {
+        CreateBucketRequest request = null;
+
+        // checking if user inputted exchange body containing bucket information. Body must be a CreateBucketRequest or a valid JSON string (Advanced users)
+        Object exchangeBody = exchange.getMessage().getBody();
+        if (exchangeBody instanceof CreateBucketRequest) {
+            request = (CreateBucketRequest) exchangeBody;
+        } else if (exchangeBody instanceof String) {
+            String strBody = (String) exchangeBody;
+            try {
+                request = new ObjectMapper().readValue(strBody, CreateBucketRequest.class);
+            } catch (JsonProcessingException e) {
+                if (LOG.isWarnEnabled()) {
+                    LOG.warn(
+                            ""String request body must be a valid JSON representation of a CreateBucketRequest. Attempting to create a bucket from endpoint parameters"");
+                }
+            }
+        }
+
+        // if no CreateBucketRequest was found in the exchange body, then create one from endpoint parameters (Basic users)
+        if (request == null) {
+            // check for bucket name, which is mandatory to create a new bucket
+            if (ObjectHelper.isEmpty(clientConfigurations.getBucketName())) {
+                if (LOG.isErrorEnabled()) {
+                    LOG.error(""No bucket name given"");
+                }
+                throw new IllegalArgumentException(""Bucket name is mandatory to create bucket"");
+            }
+
+            // check for bucket location, which is optional to create a new bucket
+            if (ObjectHelper.isEmpty(clientConfigurations.getBucketLocation())) {
+                if (LOG.isWarnEnabled()) {","[{'comment': 'Remove this as you have WARN logging for every requrest', 'commenter': 'davsclaus'}]"
5753,components/camel-huawei/camel-huaweicloud-obs/src/main/java/org/apache/camel/component/huaweicloud/obs/OBSProducer.java,"@@ -0,0 +1,225 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.huaweicloud.obs;
+
+import com.fasterxml.jackson.core.JsonProcessingException;
+import com.fasterxml.jackson.databind.ObjectMapper;
+import com.google.gson.Gson;
+import com.obs.services.ObsClient;
+import com.obs.services.exception.ObsException;
+import com.obs.services.model.CreateBucketRequest;
+import com.obs.services.model.HeaderResponse;
+import com.obs.services.model.ListBucketsRequest;
+import com.obs.services.model.ListBucketsResult;
+import com.obs.services.model.ObsBucket;
+import org.apache.camel.Exchange;
+import org.apache.camel.component.huaweicloud.obs.constants.OBSConstants;
+import org.apache.camel.component.huaweicloud.obs.constants.OBSOperations;
+import org.apache.camel.component.huaweicloud.obs.constants.OBSProperties;
+import org.apache.camel.component.huaweicloud.obs.models.ClientConfigurations;
+import org.apache.camel.component.huaweicloud.obs.models.OBSRegion;
+import org.apache.camel.support.DefaultProducer;
+import org.apache.camel.util.ObjectHelper;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class OBSProducer extends DefaultProducer {
+    private static final Logger LOG = LoggerFactory.getLogger(OBSProducer.class);
+    private OBSEndpoint endpoint;
+    private ClientConfigurations clientConfigurations;
+    private ObsClient obsClient;
+    private Gson gson;
+
+    public OBSProducer(OBSEndpoint endpoint) {
+        super(endpoint);
+        this.endpoint = endpoint;
+    }
+
+    @Override
+    protected void doInit() throws Exception {
+        super.doInit();
+        this.clientConfigurations = new ClientConfigurations();
+        this.obsClient = this.endpoint.initClient();
+        this.gson = new Gson();
+    }
+
+    public void process(Exchange exchange) throws Exception {
+        updateClientConfigs(exchange);
+
+        try {
+            switch (clientConfigurations.getOperation()) {
+                case OBSOperations.LIST_BUCKETS:
+                    listBuckets(exchange);
+                    break;
+                case OBSOperations.CREATE_BUCKET:
+                    createBucket(exchange);
+                    break;
+                case OBSOperations.DELETE_BUCKET:
+                    deleteBucket(exchange);
+                    break;
+                default:
+                    throw new UnsupportedOperationException(
+                            String.format(""%s is not a supported operation"", clientConfigurations.getOperation()));
+            }
+        } catch (ObsException e) {
+            if (LOG.isErrorEnabled()) {
+                LOG.error(""Failed to perform operation"");
+                LOG.error(""HTTP Code: "" + e.getResponseCode());
+                LOG.error(""Error Code: "" + e.getErrorCode());
+                LOG.error(""Error Message: "" + e.getErrorMessage());
+                LOG.error(""Request ID: "" + e.getErrorRequestId());
+                LOG.error(""Host ID: "" + e.getErrorHostId());
+            }
+            throw e;
+        }
+    }
+
+    /**
+     * Perform list buckets operation
+     *
+     * @param exchange
+     */
+    private void listBuckets(Exchange exchange) throws ObsException {
+        // invoke list buckets method and map response object to exchange body
+        ListBucketsRequest request = new ListBucketsRequest();
+        ListBucketsResult response = obsClient.listBucketsV2(request);
+        exchange.getMessage().setBody(gson.toJson(response.getBuckets()));
+    }
+
+    /**
+     * Perform create bucket operation
+     *
+     * @param exchange
+     */
+    private void createBucket(Exchange exchange) throws ObsException {
+        CreateBucketRequest request = null;
+
+        // checking if user inputted exchange body containing bucket information. Body must be a CreateBucketRequest or a valid JSON string (Advanced users)
+        Object exchangeBody = exchange.getMessage().getBody();
+        if (exchangeBody instanceof CreateBucketRequest) {
+            request = (CreateBucketRequest) exchangeBody;
+        } else if (exchangeBody instanceof String) {
+            String strBody = (String) exchangeBody;
+            try {
+                request = new ObjectMapper().readValue(strBody, CreateBucketRequest.class);
+            } catch (JsonProcessingException e) {
+                if (LOG.isWarnEnabled()) {
+                    LOG.warn(
+                            ""String request body must be a valid JSON representation of a CreateBucketRequest. Attempting to create a bucket from endpoint parameters"");
+                }
+            }
+        }
+
+        // if no CreateBucketRequest was found in the exchange body, then create one from endpoint parameters (Basic users)
+        if (request == null) {
+            // check for bucket name, which is mandatory to create a new bucket
+            if (ObjectHelper.isEmpty(clientConfigurations.getBucketName())) {
+                if (LOG.isErrorEnabled()) {
+                    LOG.error(""No bucket name given"");
+                }
+                throw new IllegalArgumentException(""Bucket name is mandatory to create bucket"");
+            }
+
+            // check for bucket location, which is optional to create a new bucket
+            if (ObjectHelper.isEmpty(clientConfigurations.getBucketLocation())) {
+                if (LOG.isWarnEnabled()) {
+                    LOG.warn(""No bucket location given, defaulting to '"" + OBSConstants.DEFAULT_LOCATION + ""'"");
+                }
+                clientConfigurations.setBucketLocation(OBSConstants.DEFAULT_LOCATION);
+            }
+            // verify valid bucket location
+            OBSRegion.checkValidRegion(clientConfigurations.getBucketLocation());
+
+            request = new CreateBucketRequest(clientConfigurations.getBucketName(), clientConfigurations.getBucketLocation());
+        }
+
+        // invoke create bucket method and map response object to exchange body
+        ObsBucket response = obsClient.createBucket(request);
+        exchange.getMessage().setBody(gson.toJson(response));
+    }
+
+    /**
+     * Perform delete bucket operation
+     *
+     * @param exchange
+     */
+    private void deleteBucket(Exchange exchange) throws ObsException {
+        // check for bucket name, which is mandatory to delete a bucket
+        if (ObjectHelper.isEmpty(clientConfigurations.getBucketName())) {
+            if (LOG.isErrorEnabled()) {","[{'comment': 'Remove this', 'commenter': 'davsclaus'}]"
5753,components/camel-huawei/camel-huaweicloud-obs/src/main/java/org/apache/camel/component/huaweicloud/obs/OBSProducer.java,"@@ -0,0 +1,225 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.huaweicloud.obs;
+
+import com.fasterxml.jackson.core.JsonProcessingException;
+import com.fasterxml.jackson.databind.ObjectMapper;
+import com.google.gson.Gson;
+import com.obs.services.ObsClient;
+import com.obs.services.exception.ObsException;
+import com.obs.services.model.CreateBucketRequest;
+import com.obs.services.model.HeaderResponse;
+import com.obs.services.model.ListBucketsRequest;
+import com.obs.services.model.ListBucketsResult;
+import com.obs.services.model.ObsBucket;
+import org.apache.camel.Exchange;
+import org.apache.camel.component.huaweicloud.obs.constants.OBSConstants;
+import org.apache.camel.component.huaweicloud.obs.constants.OBSOperations;
+import org.apache.camel.component.huaweicloud.obs.constants.OBSProperties;
+import org.apache.camel.component.huaweicloud.obs.models.ClientConfigurations;
+import org.apache.camel.component.huaweicloud.obs.models.OBSRegion;
+import org.apache.camel.support.DefaultProducer;
+import org.apache.camel.util.ObjectHelper;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class OBSProducer extends DefaultProducer {
+    private static final Logger LOG = LoggerFactory.getLogger(OBSProducer.class);
+    private OBSEndpoint endpoint;
+    private ClientConfigurations clientConfigurations;
+    private ObsClient obsClient;
+    private Gson gson;
+
+    public OBSProducer(OBSEndpoint endpoint) {
+        super(endpoint);
+        this.endpoint = endpoint;
+    }
+
+    @Override
+    protected void doInit() throws Exception {
+        super.doInit();
+        this.clientConfigurations = new ClientConfigurations();
+        this.obsClient = this.endpoint.initClient();
+        this.gson = new Gson();
+    }
+
+    public void process(Exchange exchange) throws Exception {
+        updateClientConfigs(exchange);
+
+        try {
+            switch (clientConfigurations.getOperation()) {
+                case OBSOperations.LIST_BUCKETS:
+                    listBuckets(exchange);
+                    break;
+                case OBSOperations.CREATE_BUCKET:
+                    createBucket(exchange);
+                    break;
+                case OBSOperations.DELETE_BUCKET:
+                    deleteBucket(exchange);
+                    break;
+                default:
+                    throw new UnsupportedOperationException(
+                            String.format(""%s is not a supported operation"", clientConfigurations.getOperation()));
+            }
+        } catch (ObsException e) {
+            if (LOG.isErrorEnabled()) {
+                LOG.error(""Failed to perform operation"");
+                LOG.error(""HTTP Code: "" + e.getResponseCode());
+                LOG.error(""Error Code: "" + e.getErrorCode());
+                LOG.error(""Error Message: "" + e.getErrorMessage());
+                LOG.error(""Request ID: "" + e.getErrorRequestId());
+                LOG.error(""Host ID: "" + e.getErrorHostId());
+            }
+            throw e;
+        }
+    }
+
+    /**
+     * Perform list buckets operation
+     *
+     * @param exchange
+     */
+    private void listBuckets(Exchange exchange) throws ObsException {
+        // invoke list buckets method and map response object to exchange body
+        ListBucketsRequest request = new ListBucketsRequest();
+        ListBucketsResult response = obsClient.listBucketsV2(request);
+        exchange.getMessage().setBody(gson.toJson(response.getBuckets()));
+    }
+
+    /**
+     * Perform create bucket operation
+     *
+     * @param exchange
+     */
+    private void createBucket(Exchange exchange) throws ObsException {
+        CreateBucketRequest request = null;
+
+        // checking if user inputted exchange body containing bucket information. Body must be a CreateBucketRequest or a valid JSON string (Advanced users)
+        Object exchangeBody = exchange.getMessage().getBody();
+        if (exchangeBody instanceof CreateBucketRequest) {
+            request = (CreateBucketRequest) exchangeBody;
+        } else if (exchangeBody instanceof String) {
+            String strBody = (String) exchangeBody;
+            try {
+                request = new ObjectMapper().readValue(strBody, CreateBucketRequest.class);
+            } catch (JsonProcessingException e) {
+                if (LOG.isWarnEnabled()) {
+                    LOG.warn(
+                            ""String request body must be a valid JSON representation of a CreateBucketRequest. Attempting to create a bucket from endpoint parameters"");
+                }
+            }
+        }
+
+        // if no CreateBucketRequest was found in the exchange body, then create one from endpoint parameters (Basic users)
+        if (request == null) {
+            // check for bucket name, which is mandatory to create a new bucket
+            if (ObjectHelper.isEmpty(clientConfigurations.getBucketName())) {
+                if (LOG.isErrorEnabled()) {
+                    LOG.error(""No bucket name given"");
+                }
+                throw new IllegalArgumentException(""Bucket name is mandatory to create bucket"");
+            }
+
+            // check for bucket location, which is optional to create a new bucket
+            if (ObjectHelper.isEmpty(clientConfigurations.getBucketLocation())) {
+                if (LOG.isWarnEnabled()) {
+                    LOG.warn(""No bucket location given, defaulting to '"" + OBSConstants.DEFAULT_LOCATION + ""'"");
+                }
+                clientConfigurations.setBucketLocation(OBSConstants.DEFAULT_LOCATION);
+            }
+            // verify valid bucket location
+            OBSRegion.checkValidRegion(clientConfigurations.getBucketLocation());
+
+            request = new CreateBucketRequest(clientConfigurations.getBucketName(), clientConfigurations.getBucketLocation());
+        }
+
+        // invoke create bucket method and map response object to exchange body
+        ObsBucket response = obsClient.createBucket(request);
+        exchange.getMessage().setBody(gson.toJson(response));
+    }
+
+    /**
+     * Perform delete bucket operation
+     *
+     * @param exchange
+     */
+    private void deleteBucket(Exchange exchange) throws ObsException {
+        // check for bucket name, which is mandatory to delete a bucket
+        if (ObjectHelper.isEmpty(clientConfigurations.getBucketName())) {
+            if (LOG.isErrorEnabled()) {
+                LOG.error(""No bucket name given"");
+            }
+            throw new IllegalArgumentException(""Bucket name is mandatory to delete bucket"");
+        }
+
+        // invoke delete bucket method and map response object to exchange body
+        HeaderResponse response = obsClient.deleteBucket(clientConfigurations.getBucketName());
+        exchange.getMessage().setBody(gson.toJson(response.getResponseHeaders()));
+    }
+
+    /**
+     * Update dynamic client configurations. Some endpoint parameters (operation, and bucket name and location) can also
+     * be passed via exchange properties, so they can be updated between each transaction. Since they can change, we
+     * must clear the previous transaction and update these parameters with their new values
+     *
+     * @param exchange
+     */
+    private void updateClientConfigs(Exchange exchange) {
+        resetDynamicConfigs();
+
+        // checking for required operation (exchange overrides endpoint operation if both are provided)
+        if (ObjectHelper.isEmpty(exchange.getProperty(OBSProperties.OPERATION))
+                && ObjectHelper.isEmpty(endpoint.getOperation())) {
+            if (LOG.isErrorEnabled()) {","[{'comment': 'Remove this', 'commenter': 'davsclaus'}]"
5753,components/camel-huawei/camel-huaweicloud-obs/src/main/java/org/apache/camel/component/huaweicloud/obs/models/ClientConfigurations.java,"@@ -0,0 +1,58 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.huaweicloud.obs.models;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * Class to combine parameters which can be passed through exchange properties and endpoint parameters to avoid checking
+ * both each time they are used
+ */
+public class ClientConfigurations {
+    private static final Logger LOG = LoggerFactory.getLogger(ClientConfigurations.class.getName());","[{'comment': 'Remove not used logger', 'commenter': 'davsclaus'}, {'comment': 'Removed unused logger in ClientConfigurations class', 'commenter': 'hokutor'}]"
5753,components/camel-huawei/camel-huaweicloud-obs/src/main/java/org/apache/camel/component/huaweicloud/obs/models/OBSRegion.java,"@@ -0,0 +1,88 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.huaweicloud.obs.models;
+
+import java.util.HashMap;
+import java.util.Map;
+
+import org.apache.camel.util.ObjectHelper;
+
+/**
+ * Class containing Huawei Cloud OBS regions and endpoints
+ */
+public final class OBSRegion {","[{'comment': ""Is an ENUM not a better class for this? Then you can also use Camel's enum support with automatic type conversion and avoid any mixed case problems, eg CN-NORTH-1 vs cn-north-1"", 'commenter': 'davsclaus'}, {'comment': 'Thanks @davsclaus for the suggestion. For OBS alone, we use [a different cloud SDK](https://github.com/huaweicloud/huaweicloud-sdk-java-obs) whereas for other huawei cloud components, we have used [huaweicloud-sdk-java-v3](https://github.com/huaweicloud/huaweicloud-sdk-java-v3) . To be consistent with the [v3 sdk style of maintaining endpoints](https://github.com/huaweicloud/huaweicloud-sdk-java-v3/blob/master/services/functiongraph/src/main/java/com/huaweicloud/sdk/functiongraph/v2/region/FunctionGraphRegion.java), we decided to keep the similar pattern until v3 team comes up with support for OBS.\r\n\r\nConsidering the potential mixed case problem, I have made it case insensitive to shield against different user behaviors in [this commit](https://github.com/apache/camel/pull/5753/commits/238b61819f1e86978b8abf5851b54b20a24b2883) and https://github.com/apache/camel/pull/5753/commits/6c471100cc2fc3a4827e3b6a24425f21e9926fa8\r\n\r\nLet me know what you feel about this change.\r\n', 'commenter': 'hokutor'}]"
5753,parent/pom.xml,"@@ -239,6 +239,7 @@
         <httpcore4-version>4.4.14</httpcore4-version>
         <httpclient4-version>4.5.13</httpclient4-version>
         <httpasyncclient-version>4.1.4</httpasyncclient-version>
+		<huaweicloud-obs-version>3.21.4.1</huaweicloud-obs-version>","[{'comment': 'Use same indent as the other lines', 'commenter': 'davsclaus'}, {'comment': 'Removed extra indentation', 'commenter': 'hokutor'}]"
5787,core/camel-base-engine/src/main/java/org/apache/camel/impl/engine/FileStateRepository.java,"@@ -207,7 +207,10 @@ protected void loadStore() throws IOException {
             LOG.debug(""Creating filestore: {}"", fileStore);
             File parent = fileStore.getParentFile();
             if (parent != null) {
-                parent.mkdirs();
+                boolean mkdirsResult = parent.mkdirs();
+                if (!mkdirsResult) {
+                    LOG.error(""mkdirs() failed for "" + parent);","[{'comment': 'My .2 cents: I think it would be better to have a more descriptive log message here since this is in the core of Camel and also using log markers. I\'d suggest something like `LOG.error(""""Couldn\'t create the filestore at {} because creating the directory has failed"", parent);`. Alternatively, we could also explore whether [Files.createDirectories](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#createDirectories-java.nio.file.Path-java.nio.file.attribute.FileAttribute...-) could fulfill this gap as, I believe, it provides better error descriptions.', 'commenter': 'orpiske'}]"
5787,core/camel-support/src/main/java/org/apache/camel/support/processor/idempotent/FileIdempotentRepository.java,"@@ -462,7 +462,10 @@ protected void loadStore() throws IOException {
             LOG.debug(""Creating filestore: {}"", fileStore);
             File parent = fileStore.getParentFile();
             if (parent != null) {
-                parent.mkdirs();
+                boolean mkdirsResult = parent.mkdirs();
+                if (!mkdirsResult) {
+                    LOG.error(""mkdirs() failed for "" + parent);","[{'comment': 'My .2 cents: for the log message on this part as well. ', 'commenter': 'orpiske'}]"
5787,core/camel-xml-jaxp/src/main/java/org/apache/camel/converter/jaxp/StaxConverter.java,"@@ -316,7 +319,10 @@ private XMLOutputFactory getXMLOutputFactory() {
 
     private void returnXMLOutputFactory(XMLOutputFactory factory) {
         if (factory != outputFactory) {
-            OUTPUT_FACTORY_POOL.offer(factory);
+            boolean resultOfOffer = OUTPUT_FACTORY_POOL.offer(factory);
+            if (!resultOfOffer) {
+                LOG.error(""factory wasn't added into OUTPUT_FACTORY_POOL"");","[{'comment': 'After updating to Camel `3.12.0` we started to see these errors in our logs (not sure if it is this change or the one above, maybe both).\r\n\r\nAre you sure this is an error? I believe it happens when multiple threads concurrently create more factories that the maximum pool capacity. Or am I missing something?', 'commenter': 'PascalSchumacher'}, {'comment': 'We should trust static analysis tool', 'commenter': 'oscerd'}, {'comment': 'The static analyis tool found that a return value is ignored. This can of be a problem, but the static analysis tool does not know the context of it happening. If this was logged at debug or info level it would be the same for the static analyisis tool.', 'commenter': 'PascalSchumacher'}, {'comment': 'Fixed by @davsclaus in https://github.com/apache/camel/commit/fb67852b8f5fbb525d7b2ecff71f78d18754080c and https://github.com/apache/camel/commit/fb67852b8f5fbb525d7b2ecff71f78d18754080c Thanks!', 'commenter': 'PascalSchumacher'}]"
5841,components/camel-huawei/camel-huaweicloud-obs/pom.xml,"@@ -53,6 +53,12 @@
       <version>${gson-version}</version>
     </dependency>
 
+    <dependency>
+      <groupId>org.apache.camel</groupId>","[{'comment': ""I don't think you need to declare camel-base"", 'commenter': 'oscerd'}, {'comment': 'Removed camel-base dependency. There was a method from the IOConversion class in camel-base that was being used, which is why the dependency was included. Since we only used one method, we have moved it to a utility class to avoid importing the entire package.', 'commenter': 'hokutor'}]"
5841,components/camel-huawei/camel-huaweicloud-obs/src/main/java/org/apache/camel/component/huaweicloud/obs/OBSConsumer.java,"@@ -0,0 +1,300 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.huaweicloud.obs;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Queue;
+
+import com.obs.services.ObsClient;
+import com.obs.services.exception.ObsException;
+import com.obs.services.model.BucketMetadataInfoRequest;
+import com.obs.services.model.BucketMetadataInfoResult;
+import com.obs.services.model.CopyObjectResult;
+import com.obs.services.model.DeleteObjectResult;
+import com.obs.services.model.ListObjectsRequest;
+import com.obs.services.model.ObjectListing;
+import com.obs.services.model.ObsObject;
+import org.apache.camel.AsyncCallback;
+import org.apache.camel.Exchange;
+import org.apache.camel.ExchangePropertyKey;
+import org.apache.camel.ExtendedExchange;
+import org.apache.camel.Message;
+import org.apache.camel.Processor;
+import org.apache.camel.RuntimeCamelException;
+import org.apache.camel.component.huaweicloud.obs.constants.OBSConstants;
+import org.apache.camel.component.huaweicloud.obs.constants.OBSHeaders;
+import org.apache.camel.spi.Synchronization;
+import org.apache.camel.support.ScheduledBatchPollingConsumer;
+import org.apache.camel.util.CastUtils;
+import org.apache.camel.util.ObjectHelper;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class OBSConsumer extends ScheduledBatchPollingConsumer {
+    private static final Logger LOG = LoggerFactory.getLogger(OBSConsumer.class.getName());
+
+    private final OBSEndpoint endpoint;
+    private ObsClient obsClient;
+    private String marker;
+    private boolean destinationBucketCreated;
+
+    public OBSConsumer(OBSEndpoint endpoint, Processor processor) {
+        super(endpoint, processor);
+        this.endpoint = endpoint;
+        this.destinationBucketCreated = false;
+    }
+
+    @Override
+    protected void doStart() throws Exception {
+        super.doStart();
+
+        this.obsClient = this.endpoint.initClient();
+
+        if (ObjectHelper.isEmpty(endpoint.getBucketName())) {
+            LOG.error(""No bucket name given"");","[{'comment': 'Do NOT log and throw exception, remove the LOG', 'commenter': 'davsclaus'}, {'comment': 'Removed logs before throwing exception', 'commenter': 'hokutor'}]"
5841,components/camel-huawei/camel-huaweicloud-obs/src/main/java/org/apache/camel/component/huaweicloud/obs/OBSConsumer.java,"@@ -0,0 +1,300 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.huaweicloud.obs;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Queue;
+
+import com.obs.services.ObsClient;
+import com.obs.services.exception.ObsException;
+import com.obs.services.model.BucketMetadataInfoRequest;
+import com.obs.services.model.BucketMetadataInfoResult;
+import com.obs.services.model.CopyObjectResult;
+import com.obs.services.model.DeleteObjectResult;
+import com.obs.services.model.ListObjectsRequest;
+import com.obs.services.model.ObjectListing;
+import com.obs.services.model.ObsObject;
+import org.apache.camel.AsyncCallback;
+import org.apache.camel.Exchange;
+import org.apache.camel.ExchangePropertyKey;
+import org.apache.camel.ExtendedExchange;
+import org.apache.camel.Message;
+import org.apache.camel.Processor;
+import org.apache.camel.RuntimeCamelException;
+import org.apache.camel.component.huaweicloud.obs.constants.OBSConstants;
+import org.apache.camel.component.huaweicloud.obs.constants.OBSHeaders;
+import org.apache.camel.spi.Synchronization;
+import org.apache.camel.support.ScheduledBatchPollingConsumer;
+import org.apache.camel.util.CastUtils;
+import org.apache.camel.util.ObjectHelper;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class OBSConsumer extends ScheduledBatchPollingConsumer {
+    private static final Logger LOG = LoggerFactory.getLogger(OBSConsumer.class.getName());
+
+    private final OBSEndpoint endpoint;
+    private ObsClient obsClient;
+    private String marker;
+    private boolean destinationBucketCreated;
+
+    public OBSConsumer(OBSEndpoint endpoint, Processor processor) {
+        super(endpoint, processor);
+        this.endpoint = endpoint;
+        this.destinationBucketCreated = false;
+    }
+
+    @Override
+    protected void doStart() throws Exception {
+        super.doStart();
+
+        this.obsClient = this.endpoint.initClient();
+
+        if (ObjectHelper.isEmpty(endpoint.getBucketName())) {
+            LOG.error(""No bucket name given"");
+            throw new IllegalArgumentException(""Bucket name is mandatory to download objects"");
+        }
+
+        if (endpoint.isMoveAfterRead()) {
+            // check if destination bucket is set in the endpoint, which is mandatory when moveAfterRead = true
+            if (ObjectHelper.isEmpty(endpoint.getDestinationBucket())) {
+                LOG.error(""No destination bucket name given"");","[{'comment': 'Same here', 'commenter': 'davsclaus'}]"
5841,components/camel-huawei/camel-huaweicloud-obs/src/main/java/org/apache/camel/component/huaweicloud/obs/constants/OBSHeaders.java,"@@ -0,0 +1,34 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.huaweicloud.obs.constants;
+
+/**
+ * Constants for the exchange headers when consuming objects
+ */
+public final class OBSHeaders {
+    public static final String BUCKET_NAME = ""bucketName"";","[{'comment': 'Camel component used a prefix for their own headers, eg CamelOBSBucketName - otherwise they can clash with other components.', 'commenter': 'davsclaus'}, {'comment': 'Updated header names to include CamelHwCloudObs prefix.', 'commenter': 'hokutor'}]"
5841,components/camel-huawei/camel-huaweicloud-obs/src/main/java/org/apache/camel/component/huaweicloud/obs/constants/OBSHeaders.java,"@@ -0,0 +1,34 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.huaweicloud.obs.constants;
+
+/**
+ * Constants for the exchange headers when consuming objects
+ */
+public final class OBSHeaders {
+    public static final String BUCKET_NAME = ""bucketName"";
+    public static final String OBJECT_KEY = ""objectKey"";
+    public static final String LAST_MODIFIED = ""lastModified"";
+    public static final String CONTENT_LENGTH = ""contentLength"";","[{'comment': 'However there are standard headers for Content-Type and Content-Length, see the Exchange class', 'commenter': 'davsclaus'}, {'comment': 'Done. Changed to use Content-Type and Content-Length constants in the Exchange class', 'commenter': 'hokutor'}]"
5842,components/camel-aws/camel-aws2-s3/src/main/java/org/apache/camel/component/aws2/s3/AWS2S3Producer.java,"@@ -214,7 +214,10 @@ public void processMultiPart(final Exchange exchange) throws Exception {
 
                 LOG.trace(""Uploading part [{}] for {}"", part, keyName);
                 try (InputStream fileInputStream = new FileInputStream(filePayload)) {
-                    fileInputStream.skip(filePosition);
+                    long skipped = fileInputStream.skip(filePosition);
+                    if (skipped == 0) {
+                        LOG.warn(""0 bytes skipped"");","[{'comment': ""I'd probably use a more descriptive log message here."", 'commenter': 'orpiske'}, {'comment': 'please elaborate on your requirement', 'commenter': 'dk2k'}, {'comment': 'I mean something along the lines of: `LOG.warn(""While trying to upload the file {} file, 0 bytes were skipped"", keyName);`. \r\n\r\nYou have to consider that the previous log message at line 215 is at a trace level. As such, the user would only have this on the logs: `0 bytes skipped`  which is not sufficient for a user to understand what happened with what resource under what condition.', 'commenter': 'orpiske'}, {'comment': 'thanks, got it!', 'commenter': 'dk2k'}]"
5842,components/camel-coap/src/main/java/org/apache/camel/coap/CamelCoapResource.java,"@@ -141,10 +146,14 @@ public void handleRequest(Exchange exchange) {
         } catch (Exception e) {
             cexchange.respond(ResponseCode.INTERNAL_SERVER_ERROR, e.getMessage());
         } finally {
-            if (camelExchange != null) {
-                consumer.doneUoW(camelExchange);
+            if (consumer != null) {
+                if (camelExchange != null) {
+                    consumer.doneUoW(camelExchange);
+                }
+                consumer.releaseExchange(camelExchange, false);
+            } else {
+                LOG.error(""null in consumer"");","[{'comment': ""I'd probably use a more descriptive log message here."", 'commenter': 'orpiske'}, {'comment': 'What can be added to this message?', 'commenter': 'dk2k'}, {'comment': 'Same comment as above: what does `""null in consumer""` tells the user about the conditions or causes that lead to the situation? So, I think that describing the failure as well as the condition provides a better understanding for the user. \r\n\r\nTherefore, something like: `LOG.warn(""Skipping releasing the consumer exchange because the consumer is null. It may have been closed/released/etc earlier while trying to do something"");` ', 'commenter': 'orpiske'}, {'comment': 'To be clear `It may have been closed/released/etc earlier while trying to do something` should be replaced to the actual conditions that could have nullified it previously.', 'commenter': 'orpiske'}]"
5842,components/camel-ftp/src/main/java/org/apache/camel/component/file/remote/FtpOperations.java,"@@ -524,7 +524,10 @@ private boolean retrieveFileToFileInLocalWorkDirectory(String name, Exchange exc
             local = new File(local, relativeName);
 
             // create directory to local work file
-            local.mkdirs();
+            boolean result = local.mkdirs();
+            if (!result) {
+                log.error(""mkdirs() failed for "" + local);","[{'comment': ""I'd probably use log markers here with a more descriptive error message."", 'commenter': 'orpiske'}, {'comment': 'where can I find example of log markers?', 'commenter': 'dk2k'}, {'comment': 'By using log markers, I mean using `{}` instead of concatenating the log messages. As such, I am suggesting using something like: \r\n\r\n`log.warn(""Failed to create local directory {} while retrieving file in local work directory. Directory may already exist or have been created externally"", local);`.\r\n\r\n\r\n', 'commenter': 'orpiske'}, {'comment': 'Thanks again!', 'commenter': 'dk2k'}]"
5842,components/camel-hdfs/src/main/java/org/apache/camel/component/hdfs/HdfsNormalFileHandler.java,"@@ -152,7 +155,10 @@ private File getHdfsFileToTmpFile(String hdfsPath, HdfsConfiguration configurati
             }
 
             if (outputDest.exists()) {
-                outputDest.delete();
+                boolean result = outputDest.delete();
+                if (!result) {
+                    LOG.error(""failed to delete "" + outputDest);","[{'comment': ""I'd probably use log markers here with a more descriptive error message."", 'commenter': 'orpiske'}]"
5842,components/camel-jetty-common/src/main/java/org/apache/camel/component/jetty/CamelFilterWrapper.java,"@@ -62,7 +66,10 @@ public void init(FilterConfig config) throws ServletException {
             //go ahead and set it to the default tmp dir on the system.
             try {
                 File file = Files.createTempFile(""camel"", """").toFile();
-                file.delete();
+                boolean result = file.delete();
+                if (!result) {
+                    LOG.error(""failed to delete "" + file);","[{'comment': ""I'd probably use log markers here."", 'commenter': 'orpiske'}]"
5842,components/camel-jetty-common/src/main/java/org/apache/camel/component/jetty/JettyHttpComponent.java,"@@ -1171,7 +1173,10 @@ protected CamelServlet createServletForConnector(
         context.addServlet(holder, ""/*"");
 
         File file = File.createTempFile(""camel"", """");
-        file.delete();
+        boolean result = file.delete();
+        if (!result) {
+            LOG.error(""failed to delete "" + file);","[{'comment': ""I'd probably use log markers here."", 'commenter': 'orpiske'}]"
5842,components/camel-lucene/src/main/java/org/apache/camel/component/lucene/LuceneIndexer.java,"@@ -51,7 +51,10 @@
     public LuceneIndexer(File sourceDirectory, File indexDirectory, Analyzer analyzer) throws Exception {
         if (indexDirectory != null) {
             if (!indexDirectory.exists()) {
-                indexDirectory.mkdir();
+                boolean result = indexDirectory.mkdir();
+                if (!result) {
+                    LOG.error(""mkdir failed for "" + indexDirectory);","[{'comment': ""I'd probably use log markers here."", 'commenter': 'orpiske'}]"
5842,components/camel-jbpm/src/main/java/org/apache/camel/component/jbpm/JBPMConsumer.java,"@@ -188,8 +188,12 @@ protected void configureConsumer(String eventListenerType, InternalRuntimeManage
             return;
         }
 
-        LOGGER.debug(""Adding consumer {} on {}"", consumer, consumerAware);
-        consumerAware.addConsumer(consumer);
+        if (consumerAware != null) {
+            LOGGER.debug(""Adding consumer {} on {}"", consumer, consumerAware);
+            consumerAware.addConsumer(consumer);
+        } else {
+            LOGGER.error(""null in consumerAware"");","[{'comment': ""I'd probably use a more descriptive error message."", 'commenter': 'orpiske'}, {'comment': 'Please tell me how to make it more descriptive', 'commenter': 'dk2k'}, {'comment': 'Explained above. I think you use the same approach here.', 'commenter': 'orpiske'}]"
5842,components/camel-jetty-common/src/main/java/org/apache/camel/component/jetty/CamelFilterWrapper.java,"@@ -62,7 +66,10 @@ public void init(FilterConfig config) throws ServletException {
             //go ahead and set it to the default tmp dir on the system.
             try {
                 File file = Files.createTempFile(""camel"", """").toFile();
-                file.delete();
+                boolean result = file.delete();
+                if (!result) {
+                    LOG.error(""failed to delete {}"" + file);","[{'comment': 'Almost. This should be `LOG.error(""failed to delete {}"", file);` ', 'commenter': 'orpiske'}]"
5842,components/camel-lucene/src/main/java/org/apache/camel/component/lucene/LuceneIndexer.java,"@@ -51,7 +51,10 @@
     public LuceneIndexer(File sourceDirectory, File indexDirectory, Analyzer analyzer) throws Exception {
         if (indexDirectory != null) {
             if (!indexDirectory.exists()) {
-                indexDirectory.mkdir();
+                boolean result = indexDirectory.mkdir();
+                if (!result) {
+                    LOG.error(""mkdir failed for {}. Maybe this folder was created externally"" + indexDirectory);","[{'comment': 'This should be: \r\n\r\n```\r\nLOG.error(""mkdir failed for {}. Maybe this folder was created externally"", indexDirectory);\r\n```', 'commenter': 'orpiske'}]"
5842,components/camel-hdfs/src/main/java/org/apache/camel/component/hdfs/HdfsNormalFileHandler.java,"@@ -152,7 +155,10 @@ private File getHdfsFileToTmpFile(String hdfsPath, HdfsConfiguration configurati
             }
 
             if (outputDest.exists()) {
-                outputDest.delete();
+                boolean result = outputDest.delete();
+                if (!result) {
+                    LOG.error(""failed to delete {}"" + outputDest);","[{'comment': 'Should\'ve been: \r\n\r\n```\r\nLOG.error(""Failed to delete output destination {}"", outputDest);\r\n```\r\n', 'commenter': 'orpiske'}, {'comment': 'sorry, too hot for my brain. Will fix', 'commenter': 'dk2k'}]"
5842,components/camel-jetty-common/src/main/java/org/apache/camel/component/jetty/JettyHttpComponent.java,"@@ -236,10 +237,11 @@ protected Endpoint createEndpoint(String uri, String remaining, Map<String, Obje
             endpoint.setBinding(binding);
         }
         // prefer to use endpoint configured over component configured
-        if (jettyBinding == null) {
+        // unused
+        /*if (jettyBinding == null) {","[{'comment': ""I think we can remove this block of code if it's unused. It would make it easier for us when/if bisecting the code in case of problems."", 'commenter': 'orpiske'}]"
5872,components/camel-pulsar/src/main/java/org/apache/camel/component/pulsar/PulsarConsumer.java,"@@ -76,4 +90,31 @@ protected void doResume() throws Exception {
         return strategy.create(endpoint);
     }
 
+    private Collection<ExecutorService> subscribeWithThreadPool(Collection<Consumer<byte[]>> consumers, PulsarEndpoint endpoint)
+            throws Exception {
+        int numThreads = endpoint.getPulsarConfiguration().getNumberOfConsumerThreads();
+        return consumers.stream().map(consumer -> {
+            ExecutorService executor = Executors.newFixedThreadPool(numThreads);","[{'comment': ""Use Camel's executor service API for this, see getExecutorServiceManager on CamelContext"", 'commenter': 'davsclaus'}]"
5872,components/camel-pulsar/src/main/java/org/apache/camel/component/pulsar/PulsarConsumer.java,"@@ -76,4 +90,31 @@ protected void doResume() throws Exception {
         return strategy.create(endpoint);
     }
 
+    private Collection<ExecutorService> subscribeWithThreadPool(Collection<Consumer<byte[]>> consumers, PulsarEndpoint endpoint)
+            throws Exception {
+        int numThreads = endpoint.getPulsarConfiguration().getNumberOfConsumerThreads();
+        return consumers.stream().map(consumer -> {
+            ExecutorService executor = Executors.newFixedThreadPool(numThreads);
+            for (int i = 0; i < numThreads; i++) {
+                executor.submit(() -> {
+                    PulsarMessageListener listener = new PulsarMessageListener(endpoint, this);
+                    while (true) {
+                        try {
+                            Message<byte[]> msg = consumer.receive();
+                            listener.received(consumer, msg);
+                        } catch (PulsarClientException e) {
+                            if (e.getCause() instanceof InterruptedException) {
+                                // propagate interrupt
+                                LOGGER.info(""Received shutdown signal, exiting"");
+                                break;
+                            }
+                            LOGGER.error(""Encountered exception while receiving message"", e);","[{'comment': 'Use getExceptionHandler to handle this exception.\r\n\r\nAlso you would need to catch Exception to have a general catch and handle to keep the thread up and running.', 'commenter': 'davsclaus'}]"
5872,components/camel-pulsar/src/main/java/org/apache/camel/component/pulsar/PulsarConsumer.java,"@@ -76,4 +90,31 @@ protected void doResume() throws Exception {
         return strategy.create(endpoint);
     }
 
+    private Collection<ExecutorService> subscribeWithThreadPool(Collection<Consumer<byte[]>> consumers, PulsarEndpoint endpoint)
+            throws Exception {
+        int numThreads = endpoint.getPulsarConfiguration().getNumberOfConsumerThreads();
+        return consumers.stream().map(consumer -> {
+            ExecutorService executor = Executors.newFixedThreadPool(numThreads);
+            for (int i = 0; i < numThreads; i++) {
+                executor.submit(() -> {","[{'comment': 'Also it may be worth to move this into its own private inner class so it has a class name that makes stacktraces and logging/debugging easier.', 'commenter': 'davsclaus'}]"
5872,components/camel-pulsar/src/main/java/org/apache/camel/component/pulsar/utils/PulsarUtils.java,"@@ -31,6 +33,20 @@
     private PulsarUtils() {
     }
 
+    public static Queue<ExecutorService> stopExecutors(final Queue<ExecutorService> executors) {
+        for (ExecutorService executor : executors) {","[{'comment': ""Use Camel's ExecutorServiceManager which has API for stopping thread pools"", 'commenter': 'davsclaus'}]"
5940,docs/components/modules/ROOT/pages/hwcloud-iam-component.adoc,"@@ -1,7 +1,7 @@
 [[hwcloud-iam-component]]
 = Huawei Identity and Access Management (IAM) Component
 //THIS FILE IS COPIED: EDIT THE SOURCE FILE:
-:page-source: components/camel-huawei/camel-huaweicloud-iam/src/main/docs/hwcloud-iam-component.adoc
+:page-source: componentscamel-huaweicamel-huaweicloud-iamsrcmaindocshwcloud-iam-component.adoc","[{'comment': ""This is wrong, because you're on Windows I guess"", 'commenter': 'oscerd'}, {'comment': 'Have run the mvn routines from a mac/linux platform. Should look good  now', 'commenter': 'hokutor'}]"
5973,components/camel-json-patch/pom.xml,"@@ -0,0 +1,132 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+
+  <modelVersion>4.0.0</modelVersion>
+
+
+  <parent>
+    <artifactId>components</artifactId>
+    <groupId>org.apache.camel</groupId>
+    <version>3.11.0</version>","[{'comment': 'It should be 3.12.0-SNAPSHOT and it should be like the other components', 'commenter': 'oscerd'}]"
5973,components/camel-json-patch/pom.xml,"@@ -0,0 +1,132 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+
+  <modelVersion>4.0.0</modelVersion>
+
+
+  <parent>
+    <artifactId>components</artifactId>
+    <groupId>org.apache.camel</groupId>
+    <version>3.11.0</version>
+  </parent>
+
+  <artifactId>camel-json-patch</artifactId>
+  <packaging>jar</packaging>
+
+  <name>Camel JsonPatch Component</name>
+
+  <properties>
+    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
+    <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
+  </properties>
+
+  <dependencyManagement>","[{'comment': 'This is not needed if you follow the same structure as the other components.', 'commenter': 'oscerd'}]"
5973,components/camel-json-patch/pom.xml,"@@ -0,0 +1,132 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+
+  <modelVersion>4.0.0</modelVersion>
+
+
+  <parent>
+    <artifactId>components</artifactId>
+    <groupId>org.apache.camel</groupId>
+    <version>3.11.0</version>
+  </parent>
+
+  <artifactId>camel-json-patch</artifactId>
+  <packaging>jar</packaging>
+
+  <name>Camel JsonPatch Component</name>
+
+  <properties>
+    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
+    <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
+  </properties>
+
+  <dependencyManagement>
+    <dependencies>
+      <!-- Camel BOM -->
+      <dependency>
+        <groupId>org.apache.camel</groupId>
+        <artifactId>camel-bom</artifactId>
+        <version>3.11.0</version>
+        <scope>import</scope>
+        <type>pom</type>
+      </dependency>
+    </dependencies>
+  </dependencyManagement>
+
+  <dependencies>
+    <dependency>
+      <groupId>com.github.java-json-tools</groupId>
+      <artifactId>json-patch</artifactId>
+      <version>1.13</version>
+    </dependency>
+    
+    <!-- camel -->
+    <dependency>
+      <groupId>org.apache.camel</groupId>
+      <artifactId>camel-support</artifactId>
+    </dependency>
+    
+    <!-- logging -->
+    <dependency>
+      <groupId>org.apache.logging.log4j</groupId>
+      <artifactId>log4j-slf4j-impl</artifactId>
+      <version>2.13.3</version>
+      <scope>test</scope>
+    </dependency>
+
+    <!-- testing -->
+    <dependency>
+      <groupId>org.apache.camel</groupId>
+      <artifactId>camel-test</artifactId>
+      <scope>test</scope>
+    </dependency>
+  </dependencies>
+
+  <build>","[{'comment': 'All the build section is not needed if you use the same structure as the other components', 'commenter': 'oscerd'}]"
5973,components/camel-json-patch/src/main/java/org/apache/camel/component/jsonpatch/JsonPatchEndpoint.java,"@@ -0,0 +1,57 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.jsonpatch;
+
+import org.apache.camel.Category;
+import org.apache.camel.Consumer;
+import org.apache.camel.ExchangePattern;
+import org.apache.camel.Processor;
+import org.apache.camel.Producer;
+import org.apache.camel.component.ResourceEndpoint;
+import org.apache.camel.spi.UriEndpoint;
+
+/**
+ * JsonPatch component which transform JSON using JSON patch (RFC 6902).
+ */
+@UriEndpoint(firstVersion = ""1.0-SNAPSHOT"", scheme = ""json-patch"", title = ""JsonPatch"", syntax = ""json-patch:resourceUri"",","[{'comment': 'The firstVersion is 3.12.0-SNAPSHOT', 'commenter': 'oscerd'}]"
6008,components/camel-pulsar/src/main/java/org/apache/camel/component/pulsar/utils/message/PulsarMessageHeaders.java,"@@ -31,4 +31,5 @@
     String KEY_OUT = ""CamelPulsarProducerMessageKey"";
     String PROPERTIES_OUT = ""CamelPulsarProducerMessageProperties"";
     String EVENT_TIME_OUT = ""CamelPulsarProducerMessageEventTime"";
+    String PULSAR_REDELIVERY_COUNT = ""pulsar_redelivery_count"";","[{'comment': 'Please use the same Camel naming approach for the headers. Like for example CamelPulsarRedeliveryCount', 'commenter': 'oscerd'}]"
6054,components/camel-aws/camel-aws2-sqs/src/test/java/org/apache/camel/component/aws2/sqs/SqsProducerDeleteQueueTest.java,"@@ -0,0 +1,51 @@
+package org.apache.camel.component.aws2.sqs;","[{'comment': 'Please add the license header', 'commenter': 'oscerd'}, {'comment': 'Done. Thank you for pointing it out.', 'commenter': 'VratislavHais'}]"
6107,components/camel-huawei/camel-huaweicloud-imagerecognition/pom.xml,"@@ -0,0 +1,63 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>","[{'comment': 'Missing license', 'commenter': 'oscerd'}, {'comment': 'done', 'commenter': 'hokutor'}]"
6107,components/camel-huawei/camel-huaweicloud-imagerecognition/src/main/java/org/apache/camel/component/huaweicloud/image/ImageRecognitionEndpoint.java,"@@ -0,0 +1,292 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.huaweicloud.image;
+
+import com.huaweicloud.sdk.image.v2.ImageClient;
+import org.apache.camel.Category;
+import org.apache.camel.Consumer;
+import org.apache.camel.Processor;
+import org.apache.camel.Producer;
+import org.apache.camel.component.huaweicloud.common.models.ServiceKeys;
+import org.apache.camel.component.huaweicloud.image.constants.ImageRecognitionConstants;
+import org.apache.camel.spi.Metadata;
+import org.apache.camel.spi.UriEndpoint;
+import org.apache.camel.spi.UriParam;
+import org.apache.camel.spi.UriPath;
+import org.apache.camel.support.DefaultEndpoint;
+
+/**
+ * component to connect to image recognition service
+ */
+@UriEndpoint(firstVersion = ""3.12.0-SNAPSHOT"", scheme = ""hwcloud-image"", title = ""Huawei Cloud Image Recognition"",","[{'comment': 'Do not use SNAPSHOT here', 'commenter': 'davsclaus'}, {'comment': 'done', 'commenter': 'hokutor'}, {'comment': 'done', 'commenter': 'hokutor'}]"
6107,components/camel-huawei/camel-huaweicloud-imagerecognition/src/main/java/org/apache/camel/component/huaweicloud/image/ImageRecognitionEndpoint.java,"@@ -0,0 +1,292 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.huaweicloud.image;
+
+import com.huaweicloud.sdk.image.v2.ImageClient;
+import org.apache.camel.Category;
+import org.apache.camel.Consumer;
+import org.apache.camel.Processor;
+import org.apache.camel.Producer;
+import org.apache.camel.component.huaweicloud.common.models.ServiceKeys;
+import org.apache.camel.component.huaweicloud.image.constants.ImageRecognitionConstants;
+import org.apache.camel.spi.Metadata;
+import org.apache.camel.spi.UriEndpoint;
+import org.apache.camel.spi.UriParam;
+import org.apache.camel.spi.UriPath;
+import org.apache.camel.support.DefaultEndpoint;
+
+/**
+ * component to connect to image recognition service
+ */
+@UriEndpoint(firstVersion = ""3.12.0-SNAPSHOT"", scheme = ""hwcloud-image"", title = ""Huawei Cloud Image Recognition"",
+             syntax = ""hwcloud-image:operation"",
+             category = { Category.CLOUD, Category.MESSAGING }, producerOnly = true)
+public class ImageRecognitionEndpoint extends DefaultEndpoint {
+    @UriPath(
+             description = ""Name of Image Recognition operation to perform, including celebrityRecognition and tagRecognition"",
+             displayName = ""Operation name"", label = ""producer"")
+    @Metadata(required = true)
+    private String operation;
+
+    @UriParam(description = ""Configuration object for cloud service authentication"",
+              displayName = ""Service Configuration"", secret = true)
+    @Metadata(required = false)
+    private ServiceKeys serviceKeys;
+
+    @UriParam(description = ""Access key for the cloud user"", displayName = ""Account access key (AK)"", secret = true)
+    @Metadata(required = true)
+    private String accessKey;
+
+    @UriParam(description = ""Secret key for the cloud user"", displayName = ""Account secret key (SK)"", secret = true)
+    @Metadata(required = true)
+    private String secretKey;
+
+    @UriParam(description = ""Cloud project ID"", displayName = ""Project ID"", secret = false)","[{'comment': 'Remove all the secret = false as that is the default and just clutter up the code', 'commenter': 'davsclaus'}, {'comment': 'fixed', 'commenter': 'hokutor'}]"
6107,components/camel-huawei/camel-huaweicloud-imagerecognition/src/main/java/org/apache/camel/component/huaweicloud/image/ImageRecognitionEndpoint.java,"@@ -0,0 +1,292 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.huaweicloud.image;
+
+import com.huaweicloud.sdk.image.v2.ImageClient;
+import org.apache.camel.Category;
+import org.apache.camel.Consumer;
+import org.apache.camel.Processor;
+import org.apache.camel.Producer;
+import org.apache.camel.component.huaweicloud.common.models.ServiceKeys;
+import org.apache.camel.component.huaweicloud.image.constants.ImageRecognitionConstants;
+import org.apache.camel.spi.Metadata;
+import org.apache.camel.spi.UriEndpoint;
+import org.apache.camel.spi.UriParam;
+import org.apache.camel.spi.UriPath;
+import org.apache.camel.support.DefaultEndpoint;
+
+/**
+ * component to connect to image recognition service
+ */
+@UriEndpoint(firstVersion = ""3.12.0-SNAPSHOT"", scheme = ""hwcloud-image"", title = ""Huawei Cloud Image Recognition"",
+             syntax = ""hwcloud-image:operation"",
+             category = { Category.CLOUD, Category.MESSAGING }, producerOnly = true)
+public class ImageRecognitionEndpoint extends DefaultEndpoint {
+    @UriPath(
+             description = ""Name of Image Recognition operation to perform, including celebrityRecognition and tagRecognition"",
+             displayName = ""Operation name"", label = ""producer"")
+    @Metadata(required = true)
+    private String operation;
+
+    @UriParam(description = ""Configuration object for cloud service authentication"",
+              displayName = ""Service Configuration"", secret = true)
+    @Metadata(required = false)
+    private ServiceKeys serviceKeys;
+
+    @UriParam(description = ""Access key for the cloud user"", displayName = ""Account access key (AK)"", secret = true)
+    @Metadata(required = true)
+    private String accessKey;
+
+    @UriParam(description = ""Secret key for the cloud user"", displayName = ""Account secret key (SK)"", secret = true)
+    @Metadata(required = true)
+    private String secretKey;
+
+    @UriParam(description = ""Cloud project ID"", displayName = ""Project ID"", secret = false)
+    @Metadata(required = true)
+    private String projectId;
+
+    @UriParam(description = ""Proxy server ip/hostname"", displayName = ""Proxy server host"", secret = false)
+    @Metadata(required = false)
+    private String proxyHost;
+
+    @UriParam(description = ""Proxy server port"", displayName = ""Proxy server port"", secret = false)
+    @Metadata(required = false)
+    private int proxyPort;
+
+    @UriParam(description = ""Proxy authentication user"", displayName = ""Proxy user"", secret = true)
+    @Metadata(required = false)
+    private String proxyUser;
+
+    @UriParam(description = ""Proxy authentication password"", displayName = ""Proxy password"", secret = true)
+    @Metadata(required = false)
+    private String proxyPassword;
+
+    @UriParam(description = ""Ignore SSL verification"", displayName = ""SSL Verification Ignored"", secret = false,
+              defaultValue = ""false"", label = ""security"")
+    @Metadata(required = false)
+    private boolean ignoreSslVerification;
+
+    @UriParam(
+              description = ""Image Recognition service region. Currently only cn-north-1 and cn-north-4 are supported. This is lower precedence than endpoint based configuration."",
+              displayName = ""Service region"", secret = false)
+    @Metadata(required = true)
+    private String region;
+
+    @UriParam(
+              description = ""Fully qualified Image Recognition service url. Carries higher precedence than region based configuration."",
+              displayName = ""Service endpoint"", secret = false)
+    @Metadata(required = false)
+    private String endpoint;
+
+    @UriParam(
+              description = ""Indicates the Base64 character string converted from the image. The size cannot exceed 10 MB. The image resolution of the narrow sides must be greater than 15 pixels, and that of the wide sides cannot exceed 4096 pixels.""
+                            + ""The supported image formats include JPG, PNG, and BMP. \n""
+                            + ""Configure either this parameter or imageUrl, and this one carries higher precedence than imageUrl."",
+              displayName = ""imageContent"", secret = false)
+    @Metadata(required = false)","[{'comment': 'Remove all metadata with required false as that is the default', 'commenter': 'davsclaus'}, {'comment': 'fixed', 'commenter': 'hokutor'}, {'comment': ""@davsclaus  What I'm concerned is the default value of metadata maybe change in the future,  or no default value. So at this point, it's necessary to declare required=false explicitly."", 'commenter': 'lyndomiao'}, {'comment': ""There is no point in having required set to false. If it's not true, it is already enough"", 'commenter': 'oscerd'}]"
6107,components/camel-huawei/camel-huaweicloud-imagerecognition/src/main/java/org/apache/camel/component/huaweicloud/image/ImageRecognitionProducer.java,"@@ -0,0 +1,327 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.huaweicloud.image;
+
+import com.huaweicloud.sdk.core.auth.BasicCredentials;
+import com.huaweicloud.sdk.core.http.HttpConfig;
+import com.huaweicloud.sdk.core.utils.StringUtils;
+import com.huaweicloud.sdk.image.v2.ImageClient;
+import com.huaweicloud.sdk.image.v2.model.CelebrityRecognitionReq;
+import com.huaweicloud.sdk.image.v2.model.ImageTaggingReq;
+import com.huaweicloud.sdk.image.v2.model.RunCelebrityRecognitionRequest;
+import com.huaweicloud.sdk.image.v2.model.RunCelebrityRecognitionResponse;
+import com.huaweicloud.sdk.image.v2.model.RunImageTaggingRequest;
+import com.huaweicloud.sdk.image.v2.model.RunImageTaggingResponse;
+import com.huaweicloud.sdk.image.v2.region.ImageRegion;
+import org.apache.camel.Exchange;
+import org.apache.camel.component.huaweicloud.image.constants.ImageRecognitionConstants;
+import org.apache.camel.component.huaweicloud.image.constants.ImageRecognitionProperties;
+import org.apache.camel.component.huaweicloud.image.models.ClientConfigurations;
+import org.apache.camel.support.DefaultProducer;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class ImageRecognitionProducer extends DefaultProducer {
+    private static final Logger LOG = LoggerFactory.getLogger(ImageRecognitionProducer.class);
+
+    private ImageClient imageClient;
+
+    private ClientConfigurations clientConfigurations;
+
+    private ImageRecognitionEndpoint endpoint;
+
+    public ImageRecognitionProducer(ImageRecognitionEndpoint endpoint) {
+        super(endpoint);
+        this.endpoint = endpoint;
+    }
+
+    @Override
+    protected void doStart() throws Exception {
+        super.doStart();
+        this.clientConfigurations = initializeConfigurations(this.endpoint);
+        this.imageClient = initializeClient(this.endpoint);
+    }
+
+    /**
+     * initialize ClientConfigurations
+     *
+     * @param  endpoint ImageRecognitionEndpoint
+     * @return          ClientConfigurations
+     */
+    private ClientConfigurations initializeConfigurations(ImageRecognitionEndpoint endpoint) {
+        ClientConfigurations clientConfigurations = new ClientConfigurations();
+
+        clientConfigurations.setAccessKey(getAccessKey(endpoint));
+        clientConfigurations.setSecretKey(getSecretKey(endpoint));
+        clientConfigurations.setProjectId(getProjectId(endpoint));
+        clientConfigurations.setEndpoint(getEndpoint(endpoint));
+
+        if (StringUtils.isEmpty(endpoint.getImageContent()) && StringUtils.isEmpty(endpoint.getImageUrl())) {
+            if (StringUtils.isEmpty(endpoint.getRegion())) {
+                LOG.error(""image and url not found"");","[{'comment': 'Remove LOG error as you throw an exception', 'commenter': 'davsclaus'}, {'comment': 'done', 'commenter': 'hokutor'}]"
6107,components/camel-huawei/camel-huaweicloud-imagerecognition/src/main/java/org/apache/camel/component/huaweicloud/image/ImageRecognitionProducer.java,"@@ -0,0 +1,327 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.huaweicloud.image;
+
+import com.huaweicloud.sdk.core.auth.BasicCredentials;
+import com.huaweicloud.sdk.core.http.HttpConfig;
+import com.huaweicloud.sdk.core.utils.StringUtils;
+import com.huaweicloud.sdk.image.v2.ImageClient;
+import com.huaweicloud.sdk.image.v2.model.CelebrityRecognitionReq;
+import com.huaweicloud.sdk.image.v2.model.ImageTaggingReq;
+import com.huaweicloud.sdk.image.v2.model.RunCelebrityRecognitionRequest;
+import com.huaweicloud.sdk.image.v2.model.RunCelebrityRecognitionResponse;
+import com.huaweicloud.sdk.image.v2.model.RunImageTaggingRequest;
+import com.huaweicloud.sdk.image.v2.model.RunImageTaggingResponse;
+import com.huaweicloud.sdk.image.v2.region.ImageRegion;
+import org.apache.camel.Exchange;
+import org.apache.camel.component.huaweicloud.image.constants.ImageRecognitionConstants;
+import org.apache.camel.component.huaweicloud.image.constants.ImageRecognitionProperties;
+import org.apache.camel.component.huaweicloud.image.models.ClientConfigurations;
+import org.apache.camel.support.DefaultProducer;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class ImageRecognitionProducer extends DefaultProducer {
+    private static final Logger LOG = LoggerFactory.getLogger(ImageRecognitionProducer.class);
+
+    private ImageClient imageClient;
+
+    private ClientConfigurations clientConfigurations;
+
+    private ImageRecognitionEndpoint endpoint;
+
+    public ImageRecognitionProducer(ImageRecognitionEndpoint endpoint) {
+        super(endpoint);
+        this.endpoint = endpoint;
+    }
+
+    @Override
+    protected void doStart() throws Exception {
+        super.doStart();
+        this.clientConfigurations = initializeConfigurations(this.endpoint);
+        this.imageClient = initializeClient(this.endpoint);
+    }
+
+    /**
+     * initialize ClientConfigurations
+     *
+     * @param  endpoint ImageRecognitionEndpoint
+     * @return          ClientConfigurations
+     */
+    private ClientConfigurations initializeConfigurations(ImageRecognitionEndpoint endpoint) {
+        ClientConfigurations clientConfigurations = new ClientConfigurations();
+
+        clientConfigurations.setAccessKey(getAccessKey(endpoint));
+        clientConfigurations.setSecretKey(getSecretKey(endpoint));
+        clientConfigurations.setProjectId(getProjectId(endpoint));
+        clientConfigurations.setEndpoint(getEndpoint(endpoint));
+
+        if (StringUtils.isEmpty(endpoint.getImageContent()) && StringUtils.isEmpty(endpoint.getImageUrl())) {
+            if (StringUtils.isEmpty(endpoint.getRegion())) {
+                LOG.error(""image and url not found"");
+                throw new IllegalArgumentException(""either image or url should be set"");
+            }
+        }
+        clientConfigurations.setIgnoreSslVerification(endpoint.isIgnoreSslVerification());
+        if (clientConfigurations.isIgnoreSslVerification()) {
+            LOG.warn(""SSL verification is ignored. This is unsafe in production environment"");
+        }
+        if (!StringUtils.isEmpty(endpoint.getProxyHost())) {
+            clientConfigurations.setProxyHost(endpoint.getProxyHost());
+            clientConfigurations.setProxyPort(endpoint.getProxyPort());
+            clientConfigurations.setProxyUser(endpoint.getProxyUser());
+            clientConfigurations.setProxyPassword(endpoint.getProxyPassword());
+        }
+        return clientConfigurations;
+    }
+
+    /**
+     * initialize image client. this is lazily initialized on the first message
+     *
+     * @param  endpoint ImageRecognitionEndpoint
+     * @return          ImageClient
+     */
+    private ImageClient initializeClient(ImageRecognitionEndpoint endpoint) {
+        if (endpoint.getImageClient() != null) {
+            LOG.warn(","[{'comment': 'Why is the is WARN? An end user may think something is not good. ', 'commenter': 'davsclaus'}]"
6107,components/camel-huawei/camel-huaweicloud-imagerecognition/src/main/java/org/apache/camel/component/huaweicloud/image/ImageRecognitionProducer.java,"@@ -0,0 +1,327 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.huaweicloud.image;
+
+import com.huaweicloud.sdk.core.auth.BasicCredentials;
+import com.huaweicloud.sdk.core.http.HttpConfig;
+import com.huaweicloud.sdk.core.utils.StringUtils;
+import com.huaweicloud.sdk.image.v2.ImageClient;
+import com.huaweicloud.sdk.image.v2.model.CelebrityRecognitionReq;
+import com.huaweicloud.sdk.image.v2.model.ImageTaggingReq;
+import com.huaweicloud.sdk.image.v2.model.RunCelebrityRecognitionRequest;
+import com.huaweicloud.sdk.image.v2.model.RunCelebrityRecognitionResponse;
+import com.huaweicloud.sdk.image.v2.model.RunImageTaggingRequest;
+import com.huaweicloud.sdk.image.v2.model.RunImageTaggingResponse;
+import com.huaweicloud.sdk.image.v2.region.ImageRegion;
+import org.apache.camel.Exchange;
+import org.apache.camel.component.huaweicloud.image.constants.ImageRecognitionConstants;
+import org.apache.camel.component.huaweicloud.image.constants.ImageRecognitionProperties;
+import org.apache.camel.component.huaweicloud.image.models.ClientConfigurations;
+import org.apache.camel.support.DefaultProducer;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class ImageRecognitionProducer extends DefaultProducer {
+    private static final Logger LOG = LoggerFactory.getLogger(ImageRecognitionProducer.class);
+
+    private ImageClient imageClient;
+
+    private ClientConfigurations clientConfigurations;
+
+    private ImageRecognitionEndpoint endpoint;
+
+    public ImageRecognitionProducer(ImageRecognitionEndpoint endpoint) {
+        super(endpoint);
+        this.endpoint = endpoint;
+    }
+
+    @Override
+    protected void doStart() throws Exception {
+        super.doStart();
+        this.clientConfigurations = initializeConfigurations(this.endpoint);
+        this.imageClient = initializeClient(this.endpoint);
+    }
+
+    /**
+     * initialize ClientConfigurations
+     *
+     * @param  endpoint ImageRecognitionEndpoint
+     * @return          ClientConfigurations
+     */
+    private ClientConfigurations initializeConfigurations(ImageRecognitionEndpoint endpoint) {
+        ClientConfigurations clientConfigurations = new ClientConfigurations();
+
+        clientConfigurations.setAccessKey(getAccessKey(endpoint));
+        clientConfigurations.setSecretKey(getSecretKey(endpoint));
+        clientConfigurations.setProjectId(getProjectId(endpoint));
+        clientConfigurations.setEndpoint(getEndpoint(endpoint));
+
+        if (StringUtils.isEmpty(endpoint.getImageContent()) && StringUtils.isEmpty(endpoint.getImageUrl())) {
+            if (StringUtils.isEmpty(endpoint.getRegion())) {
+                LOG.error(""image and url not found"");
+                throw new IllegalArgumentException(""either image or url should be set"");
+            }
+        }
+        clientConfigurations.setIgnoreSslVerification(endpoint.isIgnoreSslVerification());
+        if (clientConfigurations.isIgnoreSslVerification()) {
+            LOG.warn(""SSL verification is ignored. This is unsafe in production environment"");
+        }
+        if (!StringUtils.isEmpty(endpoint.getProxyHost())) {
+            clientConfigurations.setProxyHost(endpoint.getProxyHost());
+            clientConfigurations.setProxyPort(endpoint.getProxyPort());
+            clientConfigurations.setProxyUser(endpoint.getProxyUser());
+            clientConfigurations.setProxyPassword(endpoint.getProxyPassword());
+        }
+        return clientConfigurations;
+    }
+
+    /**
+     * initialize image client. this is lazily initialized on the first message
+     *
+     * @param  endpoint ImageRecognitionEndpoint
+     * @return          ImageClient
+     */
+    private ImageClient initializeClient(ImageRecognitionEndpoint endpoint) {
+        if (endpoint.getImageClient() != null) {
+            LOG.warn(
+                    ""Instance of ImageClient was set on the endpoint. Skipping creation of ImageClient from endpoint parameters"");
+            return endpoint.getImageClient();
+        }
+        HttpConfig httpConfig = null;
+        if (clientConfigurations.getProxyHost() != null) {
+            httpConfig = HttpConfig.getDefaultHttpConfig()
+                    .withProxyHost(clientConfigurations.getProxyHost())
+                    .withProxyPort(clientConfigurations.getProxyPort())
+                    .withIgnoreSSLVerification(clientConfigurations.isIgnoreSslVerification());
+
+            if (clientConfigurations.getProxyUser() != null) {
+                httpConfig.setProxyUsername(clientConfigurations.getProxyUser());
+                httpConfig.setProxyPassword(clientConfigurations.getProxyPassword());
+            }
+        }
+
+        BasicCredentials credentials = new BasicCredentials().withAk(clientConfigurations.getAccessKey())
+                .withSk(clientConfigurations.getSecretKey())
+                .withProjectId(clientConfigurations.getProjectId());
+
+        ImageClient client = ImageClient.newBuilder()
+                .withCredential(credentials)
+                .withHttpConfig(httpConfig)
+                .withEndpoint(clientConfigurations.getEndpoint())
+                .build();
+
+        if (LOG.isDebugEnabled()) {
+            LOG.debug(""Successfully initialized Image client"");
+        }
+        return client;
+    }
+
+    public void process(Exchange exchange) {
+        String operation = ((ImageRecognitionEndpoint) super.getEndpoint()).getOperation();
+        if (StringUtils.isEmpty(operation)) {
+            LOG.error(""Operation is empty"");","[{'comment': 'Do not log and throw exception', 'commenter': 'davsclaus'}]"
6107,components/camel-huawei/camel-huaweicloud-imagerecognition/src/main/java/org/apache/camel/component/huaweicloud/image/ImageRecognitionProducer.java,"@@ -0,0 +1,327 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.huaweicloud.image;
+
+import com.huaweicloud.sdk.core.auth.BasicCredentials;
+import com.huaweicloud.sdk.core.http.HttpConfig;
+import com.huaweicloud.sdk.core.utils.StringUtils;
+import com.huaweicloud.sdk.image.v2.ImageClient;
+import com.huaweicloud.sdk.image.v2.model.CelebrityRecognitionReq;
+import com.huaweicloud.sdk.image.v2.model.ImageTaggingReq;
+import com.huaweicloud.sdk.image.v2.model.RunCelebrityRecognitionRequest;
+import com.huaweicloud.sdk.image.v2.model.RunCelebrityRecognitionResponse;
+import com.huaweicloud.sdk.image.v2.model.RunImageTaggingRequest;
+import com.huaweicloud.sdk.image.v2.model.RunImageTaggingResponse;
+import com.huaweicloud.sdk.image.v2.region.ImageRegion;
+import org.apache.camel.Exchange;
+import org.apache.camel.component.huaweicloud.image.constants.ImageRecognitionConstants;
+import org.apache.camel.component.huaweicloud.image.constants.ImageRecognitionProperties;
+import org.apache.camel.component.huaweicloud.image.models.ClientConfigurations;
+import org.apache.camel.support.DefaultProducer;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class ImageRecognitionProducer extends DefaultProducer {
+    private static final Logger LOG = LoggerFactory.getLogger(ImageRecognitionProducer.class);
+
+    private ImageClient imageClient;
+
+    private ClientConfigurations clientConfigurations;
+
+    private ImageRecognitionEndpoint endpoint;
+
+    public ImageRecognitionProducer(ImageRecognitionEndpoint endpoint) {
+        super(endpoint);
+        this.endpoint = endpoint;
+    }
+
+    @Override
+    protected void doStart() throws Exception {
+        super.doStart();
+        this.clientConfigurations = initializeConfigurations(this.endpoint);
+        this.imageClient = initializeClient(this.endpoint);
+    }
+
+    /**
+     * initialize ClientConfigurations
+     *
+     * @param  endpoint ImageRecognitionEndpoint
+     * @return          ClientConfigurations
+     */
+    private ClientConfigurations initializeConfigurations(ImageRecognitionEndpoint endpoint) {
+        ClientConfigurations clientConfigurations = new ClientConfigurations();
+
+        clientConfigurations.setAccessKey(getAccessKey(endpoint));
+        clientConfigurations.setSecretKey(getSecretKey(endpoint));
+        clientConfigurations.setProjectId(getProjectId(endpoint));
+        clientConfigurations.setEndpoint(getEndpoint(endpoint));
+
+        if (StringUtils.isEmpty(endpoint.getImageContent()) && StringUtils.isEmpty(endpoint.getImageUrl())) {
+            if (StringUtils.isEmpty(endpoint.getRegion())) {
+                LOG.error(""image and url not found"");
+                throw new IllegalArgumentException(""either image or url should be set"");
+            }
+        }
+        clientConfigurations.setIgnoreSslVerification(endpoint.isIgnoreSslVerification());
+        if (clientConfigurations.isIgnoreSslVerification()) {
+            LOG.warn(""SSL verification is ignored. This is unsafe in production environment"");
+        }
+        if (!StringUtils.isEmpty(endpoint.getProxyHost())) {
+            clientConfigurations.setProxyHost(endpoint.getProxyHost());
+            clientConfigurations.setProxyPort(endpoint.getProxyPort());
+            clientConfigurations.setProxyUser(endpoint.getProxyUser());
+            clientConfigurations.setProxyPassword(endpoint.getProxyPassword());
+        }
+        return clientConfigurations;
+    }
+
+    /**
+     * initialize image client. this is lazily initialized on the first message
+     *
+     * @param  endpoint ImageRecognitionEndpoint
+     * @return          ImageClient
+     */
+    private ImageClient initializeClient(ImageRecognitionEndpoint endpoint) {
+        if (endpoint.getImageClient() != null) {
+            LOG.warn(
+                    ""Instance of ImageClient was set on the endpoint. Skipping creation of ImageClient from endpoint parameters"");
+            return endpoint.getImageClient();
+        }
+        HttpConfig httpConfig = null;
+        if (clientConfigurations.getProxyHost() != null) {
+            httpConfig = HttpConfig.getDefaultHttpConfig()
+                    .withProxyHost(clientConfigurations.getProxyHost())
+                    .withProxyPort(clientConfigurations.getProxyPort())
+                    .withIgnoreSSLVerification(clientConfigurations.isIgnoreSslVerification());
+
+            if (clientConfigurations.getProxyUser() != null) {
+                httpConfig.setProxyUsername(clientConfigurations.getProxyUser());
+                httpConfig.setProxyPassword(clientConfigurations.getProxyPassword());
+            }
+        }
+
+        BasicCredentials credentials = new BasicCredentials().withAk(clientConfigurations.getAccessKey())
+                .withSk(clientConfigurations.getSecretKey())
+                .withProjectId(clientConfigurations.getProjectId());
+
+        ImageClient client = ImageClient.newBuilder()
+                .withCredential(credentials)
+                .withHttpConfig(httpConfig)
+                .withEndpoint(clientConfigurations.getEndpoint())
+                .build();
+
+        if (LOG.isDebugEnabled()) {
+            LOG.debug(""Successfully initialized Image client"");
+        }
+        return client;
+    }
+
+    public void process(Exchange exchange) {
+        String operation = ((ImageRecognitionEndpoint) super.getEndpoint()).getOperation();
+        if (StringUtils.isEmpty(operation)) {
+            LOG.error(""Operation is empty"");
+            throw new IllegalStateException(""operation name cannot be empty"");
+        }
+        switch (operation) {
+            case ImageRecognitionConstants.OPERATION_CELEBRITY_RECOGNITION:
+                if (LOG.isDebugEnabled()) {
+                    LOG.debug(""Performing celebrity recognition"");
+                }
+                performCelebrityRecognitionOperation(exchange);
+                break;
+            case ImageRecognitionConstants.OPERATION_TAG_RECOGNITION:
+                if (LOG.isDebugEnabled()) {
+                    LOG.debug(""Performing tag recognition"");
+                }
+                performTagRecognitionOperation(exchange);
+                break;
+            default:
+                LOG.error(""Unsupported operation: {}"", operation);","[{'comment': 'Same here', 'commenter': 'davsclaus'}]"
6107,components/camel-huawei/camel-huaweicloud-imagerecognition/src/main/java/org/apache/camel/component/huaweicloud/image/ImageRecognitionProducer.java,"@@ -0,0 +1,327 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.huaweicloud.image;
+
+import com.huaweicloud.sdk.core.auth.BasicCredentials;
+import com.huaweicloud.sdk.core.http.HttpConfig;
+import com.huaweicloud.sdk.core.utils.StringUtils;
+import com.huaweicloud.sdk.image.v2.ImageClient;
+import com.huaweicloud.sdk.image.v2.model.CelebrityRecognitionReq;
+import com.huaweicloud.sdk.image.v2.model.ImageTaggingReq;
+import com.huaweicloud.sdk.image.v2.model.RunCelebrityRecognitionRequest;
+import com.huaweicloud.sdk.image.v2.model.RunCelebrityRecognitionResponse;
+import com.huaweicloud.sdk.image.v2.model.RunImageTaggingRequest;
+import com.huaweicloud.sdk.image.v2.model.RunImageTaggingResponse;
+import com.huaweicloud.sdk.image.v2.region.ImageRegion;
+import org.apache.camel.Exchange;
+import org.apache.camel.component.huaweicloud.image.constants.ImageRecognitionConstants;
+import org.apache.camel.component.huaweicloud.image.constants.ImageRecognitionProperties;
+import org.apache.camel.component.huaweicloud.image.models.ClientConfigurations;
+import org.apache.camel.support.DefaultProducer;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class ImageRecognitionProducer extends DefaultProducer {
+    private static final Logger LOG = LoggerFactory.getLogger(ImageRecognitionProducer.class);
+
+    private ImageClient imageClient;
+
+    private ClientConfigurations clientConfigurations;
+
+    private ImageRecognitionEndpoint endpoint;
+
+    public ImageRecognitionProducer(ImageRecognitionEndpoint endpoint) {
+        super(endpoint);
+        this.endpoint = endpoint;
+    }
+
+    @Override
+    protected void doStart() throws Exception {
+        super.doStart();
+        this.clientConfigurations = initializeConfigurations(this.endpoint);
+        this.imageClient = initializeClient(this.endpoint);
+    }
+
+    /**
+     * initialize ClientConfigurations
+     *
+     * @param  endpoint ImageRecognitionEndpoint
+     * @return          ClientConfigurations
+     */
+    private ClientConfigurations initializeConfigurations(ImageRecognitionEndpoint endpoint) {
+        ClientConfigurations clientConfigurations = new ClientConfigurations();
+
+        clientConfigurations.setAccessKey(getAccessKey(endpoint));
+        clientConfigurations.setSecretKey(getSecretKey(endpoint));
+        clientConfigurations.setProjectId(getProjectId(endpoint));
+        clientConfigurations.setEndpoint(getEndpoint(endpoint));
+
+        if (StringUtils.isEmpty(endpoint.getImageContent()) && StringUtils.isEmpty(endpoint.getImageUrl())) {
+            if (StringUtils.isEmpty(endpoint.getRegion())) {
+                LOG.error(""image and url not found"");
+                throw new IllegalArgumentException(""either image or url should be set"");
+            }
+        }
+        clientConfigurations.setIgnoreSslVerification(endpoint.isIgnoreSslVerification());
+        if (clientConfigurations.isIgnoreSslVerification()) {
+            LOG.warn(""SSL verification is ignored. This is unsafe in production environment"");
+        }
+        if (!StringUtils.isEmpty(endpoint.getProxyHost())) {
+            clientConfigurations.setProxyHost(endpoint.getProxyHost());
+            clientConfigurations.setProxyPort(endpoint.getProxyPort());
+            clientConfigurations.setProxyUser(endpoint.getProxyUser());
+            clientConfigurations.setProxyPassword(endpoint.getProxyPassword());
+        }
+        return clientConfigurations;
+    }
+
+    /**
+     * initialize image client. this is lazily initialized on the first message
+     *
+     * @param  endpoint ImageRecognitionEndpoint
+     * @return          ImageClient
+     */
+    private ImageClient initializeClient(ImageRecognitionEndpoint endpoint) {
+        if (endpoint.getImageClient() != null) {
+            LOG.warn(
+                    ""Instance of ImageClient was set on the endpoint. Skipping creation of ImageClient from endpoint parameters"");
+            return endpoint.getImageClient();
+        }
+        HttpConfig httpConfig = null;
+        if (clientConfigurations.getProxyHost() != null) {
+            httpConfig = HttpConfig.getDefaultHttpConfig()
+                    .withProxyHost(clientConfigurations.getProxyHost())
+                    .withProxyPort(clientConfigurations.getProxyPort())
+                    .withIgnoreSSLVerification(clientConfigurations.isIgnoreSslVerification());
+
+            if (clientConfigurations.getProxyUser() != null) {
+                httpConfig.setProxyUsername(clientConfigurations.getProxyUser());
+                httpConfig.setProxyPassword(clientConfigurations.getProxyPassword());
+            }
+        }
+
+        BasicCredentials credentials = new BasicCredentials().withAk(clientConfigurations.getAccessKey())
+                .withSk(clientConfigurations.getSecretKey())
+                .withProjectId(clientConfigurations.getProjectId());
+
+        ImageClient client = ImageClient.newBuilder()
+                .withCredential(credentials)
+                .withHttpConfig(httpConfig)
+                .withEndpoint(clientConfigurations.getEndpoint())
+                .build();
+
+        if (LOG.isDebugEnabled()) {
+            LOG.debug(""Successfully initialized Image client"");
+        }
+        return client;
+    }
+
+    public void process(Exchange exchange) {
+        String operation = ((ImageRecognitionEndpoint) super.getEndpoint()).getOperation();
+        if (StringUtils.isEmpty(operation)) {
+            LOG.error(""Operation is empty"");
+            throw new IllegalStateException(""operation name cannot be empty"");
+        }
+        switch (operation) {
+            case ImageRecognitionConstants.OPERATION_CELEBRITY_RECOGNITION:
+                if (LOG.isDebugEnabled()) {
+                    LOG.debug(""Performing celebrity recognition"");
+                }
+                performCelebrityRecognitionOperation(exchange);
+                break;
+            case ImageRecognitionConstants.OPERATION_TAG_RECOGNITION:
+                if (LOG.isDebugEnabled()) {
+                    LOG.debug(""Performing tag recognition"");
+                }
+                performTagRecognitionOperation(exchange);
+                break;
+            default:
+                LOG.error(""Unsupported operation: {}"", operation);
+                throw new UnsupportedOperationException(
+                        ""operation can only be either tagRecognition or celebrityRecognition"");","[{'comment': 'Use upper case O in Operation', 'commenter': 'davsclaus'}]"
6107,components/camel-huawei/camel-huaweicloud-imagerecognition/src/main/java/org/apache/camel/component/huaweicloud/image/ImageRecognitionProducer.java,"@@ -0,0 +1,327 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.huaweicloud.image;
+
+import com.huaweicloud.sdk.core.auth.BasicCredentials;
+import com.huaweicloud.sdk.core.http.HttpConfig;
+import com.huaweicloud.sdk.core.utils.StringUtils;
+import com.huaweicloud.sdk.image.v2.ImageClient;
+import com.huaweicloud.sdk.image.v2.model.CelebrityRecognitionReq;
+import com.huaweicloud.sdk.image.v2.model.ImageTaggingReq;
+import com.huaweicloud.sdk.image.v2.model.RunCelebrityRecognitionRequest;
+import com.huaweicloud.sdk.image.v2.model.RunCelebrityRecognitionResponse;
+import com.huaweicloud.sdk.image.v2.model.RunImageTaggingRequest;
+import com.huaweicloud.sdk.image.v2.model.RunImageTaggingResponse;
+import com.huaweicloud.sdk.image.v2.region.ImageRegion;
+import org.apache.camel.Exchange;
+import org.apache.camel.component.huaweicloud.image.constants.ImageRecognitionConstants;
+import org.apache.camel.component.huaweicloud.image.constants.ImageRecognitionProperties;
+import org.apache.camel.component.huaweicloud.image.models.ClientConfigurations;
+import org.apache.camel.support.DefaultProducer;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class ImageRecognitionProducer extends DefaultProducer {
+    private static final Logger LOG = LoggerFactory.getLogger(ImageRecognitionProducer.class);
+
+    private ImageClient imageClient;
+
+    private ClientConfigurations clientConfigurations;
+
+    private ImageRecognitionEndpoint endpoint;
+
+    public ImageRecognitionProducer(ImageRecognitionEndpoint endpoint) {
+        super(endpoint);
+        this.endpoint = endpoint;
+    }
+
+    @Override
+    protected void doStart() throws Exception {
+        super.doStart();
+        this.clientConfigurations = initializeConfigurations(this.endpoint);
+        this.imageClient = initializeClient(this.endpoint);
+    }
+
+    /**
+     * initialize ClientConfigurations
+     *
+     * @param  endpoint ImageRecognitionEndpoint
+     * @return          ClientConfigurations
+     */
+    private ClientConfigurations initializeConfigurations(ImageRecognitionEndpoint endpoint) {
+        ClientConfigurations clientConfigurations = new ClientConfigurations();
+
+        clientConfigurations.setAccessKey(getAccessKey(endpoint));
+        clientConfigurations.setSecretKey(getSecretKey(endpoint));
+        clientConfigurations.setProjectId(getProjectId(endpoint));
+        clientConfigurations.setEndpoint(getEndpoint(endpoint));
+
+        if (StringUtils.isEmpty(endpoint.getImageContent()) && StringUtils.isEmpty(endpoint.getImageUrl())) {
+            if (StringUtils.isEmpty(endpoint.getRegion())) {
+                LOG.error(""image and url not found"");
+                throw new IllegalArgumentException(""either image or url should be set"");
+            }
+        }
+        clientConfigurations.setIgnoreSslVerification(endpoint.isIgnoreSslVerification());
+        if (clientConfigurations.isIgnoreSslVerification()) {
+            LOG.warn(""SSL verification is ignored. This is unsafe in production environment"");
+        }
+        if (!StringUtils.isEmpty(endpoint.getProxyHost())) {
+            clientConfigurations.setProxyHost(endpoint.getProxyHost());
+            clientConfigurations.setProxyPort(endpoint.getProxyPort());
+            clientConfigurations.setProxyUser(endpoint.getProxyUser());
+            clientConfigurations.setProxyPassword(endpoint.getProxyPassword());
+        }
+        return clientConfigurations;
+    }
+
+    /**
+     * initialize image client. this is lazily initialized on the first message
+     *
+     * @param  endpoint ImageRecognitionEndpoint
+     * @return          ImageClient
+     */
+    private ImageClient initializeClient(ImageRecognitionEndpoint endpoint) {
+        if (endpoint.getImageClient() != null) {
+            LOG.warn(
+                    ""Instance of ImageClient was set on the endpoint. Skipping creation of ImageClient from endpoint parameters"");
+            return endpoint.getImageClient();
+        }
+        HttpConfig httpConfig = null;
+        if (clientConfigurations.getProxyHost() != null) {
+            httpConfig = HttpConfig.getDefaultHttpConfig()
+                    .withProxyHost(clientConfigurations.getProxyHost())
+                    .withProxyPort(clientConfigurations.getProxyPort())
+                    .withIgnoreSSLVerification(clientConfigurations.isIgnoreSslVerification());
+
+            if (clientConfigurations.getProxyUser() != null) {
+                httpConfig.setProxyUsername(clientConfigurations.getProxyUser());
+                httpConfig.setProxyPassword(clientConfigurations.getProxyPassword());
+            }
+        }
+
+        BasicCredentials credentials = new BasicCredentials().withAk(clientConfigurations.getAccessKey())
+                .withSk(clientConfigurations.getSecretKey())
+                .withProjectId(clientConfigurations.getProjectId());
+
+        ImageClient client = ImageClient.newBuilder()
+                .withCredential(credentials)
+                .withHttpConfig(httpConfig)
+                .withEndpoint(clientConfigurations.getEndpoint())
+                .build();
+
+        if (LOG.isDebugEnabled()) {
+            LOG.debug(""Successfully initialized Image client"");
+        }
+        return client;
+    }
+
+    public void process(Exchange exchange) {
+        String operation = ((ImageRecognitionEndpoint) super.getEndpoint()).getOperation();
+        if (StringUtils.isEmpty(operation)) {
+            LOG.error(""Operation is empty"");
+            throw new IllegalStateException(""operation name cannot be empty"");
+        }
+        switch (operation) {
+            case ImageRecognitionConstants.OPERATION_CELEBRITY_RECOGNITION:
+                if (LOG.isDebugEnabled()) {
+                    LOG.debug(""Performing celebrity recognition"");
+                }
+                performCelebrityRecognitionOperation(exchange);
+                break;
+            case ImageRecognitionConstants.OPERATION_TAG_RECOGNITION:
+                if (LOG.isDebugEnabled()) {
+                    LOG.debug(""Performing tag recognition"");
+                }
+                performTagRecognitionOperation(exchange);
+                break;
+            default:
+                LOG.error(""Unsupported operation: {}"", operation);
+                throw new UnsupportedOperationException(
+                        ""operation can only be either tagRecognition or celebrityRecognition"");
+        }
+    }
+
+    /**
+     * perform celebrity recognition
+     *
+     * @param exchange camel exchange
+     */
+    private void performCelebrityRecognitionOperation(Exchange exchange) {
+        updateClientConfigurations(exchange);
+
+        CelebrityRecognitionReq reqBody = new CelebrityRecognitionReq().withImage(this.clientConfigurations.getImageContent())
+                .withUrl(this.clientConfigurations.getImageUrl())
+                .withThreshold(this.clientConfigurations.getThreshold());
+
+        RunCelebrityRecognitionResponse response
+                = this.imageClient.runCelebrityRecognition(new RunCelebrityRecognitionRequest().withBody(reqBody));
+
+        exchange.getMessage().setBody(response.getResult());
+    }
+
+    /**
+     * perform tag recognition
+     *
+     * @param exchange camel exchange
+     */
+    private void performTagRecognitionOperation(Exchange exchange) {
+        updateClientConfigurations(exchange);
+
+        ImageTaggingReq reqBody = new ImageTaggingReq().withImage(this.clientConfigurations.getImageContent())
+                .withUrl(this.clientConfigurations.getImageUrl())
+                .withThreshold(this.clientConfigurations.getThreshold())
+                .withLanguage(this.clientConfigurations.getTagLanguage())
+                .withLimit(this.clientConfigurations.getTagLimit());
+
+        RunImageTaggingResponse response = this.imageClient.runImageTagging(new RunImageTaggingRequest().withBody(reqBody));
+
+        exchange.getMessage().setBody(response.getResult());
+    }
+
+    /**
+     * Update dynamic client configurations. Some endpoint parameters (imageContent, imageUrl, tagLanguage, tagLimit and
+     * threshold) can also be passed via exchange properties, so they can be updated between each transaction. Since
+     * they can change, we must clear the previous transaction and update these parameters with their new values
+     *
+     * @param exchange camel exchange
+     */
+    private void updateClientConfigurations(Exchange exchange) {
+        resetDynamicConfigurations();","[{'comment': 'This is not thread safe! you can have concurrent exchanges with different configurations that then both alter this shared configuration', 'commenter': 'davsclaus'}, {'comment': 'working on this', 'commenter': 'hokutor'}, {'comment': 'done', 'commenter': 'hokutor'}, {'comment': '> This is not thread safe! you can have concurrent exchanges with different configurations that then both alter this shared configuration\r\n\r\n@davsclaus - thanks for pointing this out. The issue persists in other huawei cloud components as well. Raised a JIRA for fix pack in those components too. Raised a JIRA https://issues.apache.org/jira/browse/CAMEL-16991 . I will work on that shortly', 'commenter': 'hokutor'}]"
6107,components/camel-huawei/camel-huaweicloud-imagerecognition/src/main/java/org/apache/camel/component/huaweicloud/image/ImageRecognitionProducer.java,"@@ -0,0 +1,327 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.huaweicloud.image;
+
+import com.huaweicloud.sdk.core.auth.BasicCredentials;
+import com.huaweicloud.sdk.core.http.HttpConfig;
+import com.huaweicloud.sdk.core.utils.StringUtils;
+import com.huaweicloud.sdk.image.v2.ImageClient;
+import com.huaweicloud.sdk.image.v2.model.CelebrityRecognitionReq;
+import com.huaweicloud.sdk.image.v2.model.ImageTaggingReq;
+import com.huaweicloud.sdk.image.v2.model.RunCelebrityRecognitionRequest;
+import com.huaweicloud.sdk.image.v2.model.RunCelebrityRecognitionResponse;
+import com.huaweicloud.sdk.image.v2.model.RunImageTaggingRequest;
+import com.huaweicloud.sdk.image.v2.model.RunImageTaggingResponse;
+import com.huaweicloud.sdk.image.v2.region.ImageRegion;
+import org.apache.camel.Exchange;
+import org.apache.camel.component.huaweicloud.image.constants.ImageRecognitionConstants;
+import org.apache.camel.component.huaweicloud.image.constants.ImageRecognitionProperties;
+import org.apache.camel.component.huaweicloud.image.models.ClientConfigurations;
+import org.apache.camel.support.DefaultProducer;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class ImageRecognitionProducer extends DefaultProducer {
+    private static final Logger LOG = LoggerFactory.getLogger(ImageRecognitionProducer.class);
+
+    private ImageClient imageClient;
+
+    private ClientConfigurations clientConfigurations;
+
+    private ImageRecognitionEndpoint endpoint;
+
+    public ImageRecognitionProducer(ImageRecognitionEndpoint endpoint) {
+        super(endpoint);
+        this.endpoint = endpoint;
+    }
+
+    @Override
+    protected void doStart() throws Exception {
+        super.doStart();
+        this.clientConfigurations = initializeConfigurations(this.endpoint);
+        this.imageClient = initializeClient(this.endpoint);
+    }
+
+    /**
+     * initialize ClientConfigurations
+     *
+     * @param  endpoint ImageRecognitionEndpoint
+     * @return          ClientConfigurations
+     */
+    private ClientConfigurations initializeConfigurations(ImageRecognitionEndpoint endpoint) {
+        ClientConfigurations clientConfigurations = new ClientConfigurations();
+
+        clientConfigurations.setAccessKey(getAccessKey(endpoint));
+        clientConfigurations.setSecretKey(getSecretKey(endpoint));
+        clientConfigurations.setProjectId(getProjectId(endpoint));
+        clientConfigurations.setEndpoint(getEndpoint(endpoint));
+
+        if (StringUtils.isEmpty(endpoint.getImageContent()) && StringUtils.isEmpty(endpoint.getImageUrl())) {
+            if (StringUtils.isEmpty(endpoint.getRegion())) {
+                LOG.error(""image and url not found"");
+                throw new IllegalArgumentException(""either image or url should be set"");
+            }
+        }
+        clientConfigurations.setIgnoreSslVerification(endpoint.isIgnoreSslVerification());
+        if (clientConfigurations.isIgnoreSslVerification()) {
+            LOG.warn(""SSL verification is ignored. This is unsafe in production environment"");
+        }
+        if (!StringUtils.isEmpty(endpoint.getProxyHost())) {
+            clientConfigurations.setProxyHost(endpoint.getProxyHost());
+            clientConfigurations.setProxyPort(endpoint.getProxyPort());
+            clientConfigurations.setProxyUser(endpoint.getProxyUser());
+            clientConfigurations.setProxyPassword(endpoint.getProxyPassword());
+        }
+        return clientConfigurations;
+    }
+
+    /**
+     * initialize image client. this is lazily initialized on the first message
+     *
+     * @param  endpoint ImageRecognitionEndpoint
+     * @return          ImageClient
+     */
+    private ImageClient initializeClient(ImageRecognitionEndpoint endpoint) {
+        if (endpoint.getImageClient() != null) {
+            LOG.warn(
+                    ""Instance of ImageClient was set on the endpoint. Skipping creation of ImageClient from endpoint parameters"");
+            return endpoint.getImageClient();
+        }
+        HttpConfig httpConfig = null;
+        if (clientConfigurations.getProxyHost() != null) {
+            httpConfig = HttpConfig.getDefaultHttpConfig()
+                    .withProxyHost(clientConfigurations.getProxyHost())
+                    .withProxyPort(clientConfigurations.getProxyPort())
+                    .withIgnoreSSLVerification(clientConfigurations.isIgnoreSslVerification());
+
+            if (clientConfigurations.getProxyUser() != null) {
+                httpConfig.setProxyUsername(clientConfigurations.getProxyUser());
+                httpConfig.setProxyPassword(clientConfigurations.getProxyPassword());
+            }
+        }
+
+        BasicCredentials credentials = new BasicCredentials().withAk(clientConfigurations.getAccessKey())
+                .withSk(clientConfigurations.getSecretKey())
+                .withProjectId(clientConfigurations.getProjectId());
+
+        ImageClient client = ImageClient.newBuilder()
+                .withCredential(credentials)
+                .withHttpConfig(httpConfig)
+                .withEndpoint(clientConfigurations.getEndpoint())
+                .build();
+
+        if (LOG.isDebugEnabled()) {
+            LOG.debug(""Successfully initialized Image client"");
+        }
+        return client;
+    }
+
+    public void process(Exchange exchange) {
+        String operation = ((ImageRecognitionEndpoint) super.getEndpoint()).getOperation();
+        if (StringUtils.isEmpty(operation)) {
+            LOG.error(""Operation is empty"");
+            throw new IllegalStateException(""operation name cannot be empty"");
+        }
+        switch (operation) {
+            case ImageRecognitionConstants.OPERATION_CELEBRITY_RECOGNITION:
+                if (LOG.isDebugEnabled()) {
+                    LOG.debug(""Performing celebrity recognition"");
+                }
+                performCelebrityRecognitionOperation(exchange);
+                break;
+            case ImageRecognitionConstants.OPERATION_TAG_RECOGNITION:
+                if (LOG.isDebugEnabled()) {
+                    LOG.debug(""Performing tag recognition"");
+                }
+                performTagRecognitionOperation(exchange);
+                break;
+            default:
+                LOG.error(""Unsupported operation: {}"", operation);
+                throw new UnsupportedOperationException(
+                        ""operation can only be either tagRecognition or celebrityRecognition"");
+        }
+    }
+
+    /**
+     * perform celebrity recognition
+     *
+     * @param exchange camel exchange
+     */
+    private void performCelebrityRecognitionOperation(Exchange exchange) {
+        updateClientConfigurations(exchange);
+
+        CelebrityRecognitionReq reqBody = new CelebrityRecognitionReq().withImage(this.clientConfigurations.getImageContent())
+                .withUrl(this.clientConfigurations.getImageUrl())
+                .withThreshold(this.clientConfigurations.getThreshold());
+
+        RunCelebrityRecognitionResponse response
+                = this.imageClient.runCelebrityRecognition(new RunCelebrityRecognitionRequest().withBody(reqBody));
+
+        exchange.getMessage().setBody(response.getResult());
+    }
+
+    /**
+     * perform tag recognition
+     *
+     * @param exchange camel exchange
+     */
+    private void performTagRecognitionOperation(Exchange exchange) {
+        updateClientConfigurations(exchange);
+
+        ImageTaggingReq reqBody = new ImageTaggingReq().withImage(this.clientConfigurations.getImageContent())
+                .withUrl(this.clientConfigurations.getImageUrl())
+                .withThreshold(this.clientConfigurations.getThreshold())
+                .withLanguage(this.clientConfigurations.getTagLanguage())
+                .withLimit(this.clientConfigurations.getTagLimit());
+
+        RunImageTaggingResponse response = this.imageClient.runImageTagging(new RunImageTaggingRequest().withBody(reqBody));
+
+        exchange.getMessage().setBody(response.getResult());
+    }
+
+    /**
+     * Update dynamic client configurations. Some endpoint parameters (imageContent, imageUrl, tagLanguage, tagLimit and
+     * threshold) can also be passed via exchange properties, so they can be updated between each transaction. Since
+     * they can change, we must clear the previous transaction and update these parameters with their new values
+     *
+     * @param exchange camel exchange
+     */
+    private void updateClientConfigurations(Exchange exchange) {
+        resetDynamicConfigurations();
+
+        boolean isImageContentSet = true;
+        boolean isImageUrlSet = true;
+
+        String imageContent = exchange.getProperty(ImageRecognitionProperties.IMAGE_CONTENT, String.class);
+        if (!StringUtils.isEmpty(imageContent)) {
+            clientConfigurations.setImageContent(imageContent);
+        } else if (!StringUtils.isEmpty(this.endpoint.getImageContent())) {
+            clientConfigurations.setImageContent(this.endpoint.getImageContent());
+        } else {
+            isImageContentSet = false;
+        }
+
+        String imageUrl = exchange.getProperty(ImageRecognitionProperties.IMAGE_URL, String.class);
+        if (!StringUtils.isEmpty(imageUrl)) {
+            clientConfigurations.setImageUrl(imageUrl);
+        } else if (!StringUtils.isEmpty(this.endpoint.getImageUrl())) {
+            clientConfigurations.setImageUrl(this.endpoint.getImageUrl());
+        } else {
+            isImageUrlSet = false;
+        }
+        if (!isImageContentSet && !isImageUrlSet) {
+            LOG.error(""Image content and url are not set"");
+            throw new IllegalArgumentException(""either image content or image url should be set"");
+        }
+
+        String tagLanguageProperty = exchange.getProperty(ImageRecognitionProperties.TAG_LANGUAGE, String.class);
+        clientConfigurations.setTagLanguage(
+                StringUtils.isEmpty(tagLanguageProperty) ? this.endpoint.getTagLanguage() : tagLanguageProperty);
+        if (!ImageRecognitionConstants.TAG_LANGUAGE_ZH.equals(clientConfigurations.getTagLanguage())
+                && !ImageRecognitionConstants.TAG_LANGUAGE_EN.equals(clientConfigurations.getTagLanguage())) {
+            LOG.error(""Tag language is invalid: {}"", clientConfigurations.getTagLanguage());
+            throw new IllegalArgumentException(""tag language can only be 'zh' or 'en'"");
+        }
+
+        Integer tagLimitProperty = exchange.getProperty(ImageRecognitionProperties.TAG_LIMIT, Integer.class);
+        clientConfigurations.setTagLimit(tagLimitProperty == null ? endpoint.getTagLimit() : tagLimitProperty);
+
+        Float thresholdProperty = exchange.getProperty(ImageRecognitionProperties.THRESHOLD, Float.class);
+        clientConfigurations.setThreshold(thresholdProperty == null ? endpoint.getThreshold() : thresholdProperty);
+
+        if (clientConfigurations.getThreshold() == -1) {
+            clientConfigurations
+                    .setThreshold(ImageRecognitionConstants.OPERATION_TAG_RECOGNITION.equals(endpoint.getOperation())
+                            ? ImageRecognitionConstants.DEFAULT_TAG_RECOGNITION_THRESHOLD
+                            : ImageRecognitionConstants.DEFAULT_CELEBRITY_RECOGNITION_THRESHOLD);
+        }
+        validateThresholdValue(clientConfigurations.getThreshold(), endpoint.getOperation());
+    }
+
+    /**
+     * validate threshold value. for tagRecognition, threshold should be at 0~100. for celebrityRecognition, threshold
+     * should be at 0~1.
+     *
+     * @param threshold threshold value
+     * @param operation operation
+     */
+    private void validateThresholdValue(float threshold, String operation) {
+        if (ImageRecognitionConstants.OPERATION_TAG_RECOGNITION.equals(operation)) {
+            if (threshold < 0 || threshold > ImageRecognitionConstants.TAG_RECOGNITION_THRESHOLD_MAX) {
+                LOG.error(""Tag threshold is invalid: {}"", threshold);","[{'comment': 'Same thing dont log and throw exception', 'commenter': 'davsclaus'}, {'comment': 'done', 'commenter': 'hokutor'}]"
6107,components/camel-huawei/camel-huaweicloud-imagerecognition/src/main/java/org/apache/camel/component/huaweicloud/image/ImageRecognitionProducer.java,"@@ -0,0 +1,327 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.huaweicloud.image;
+
+import com.huaweicloud.sdk.core.auth.BasicCredentials;
+import com.huaweicloud.sdk.core.http.HttpConfig;
+import com.huaweicloud.sdk.core.utils.StringUtils;
+import com.huaweicloud.sdk.image.v2.ImageClient;
+import com.huaweicloud.sdk.image.v2.model.CelebrityRecognitionReq;
+import com.huaweicloud.sdk.image.v2.model.ImageTaggingReq;
+import com.huaweicloud.sdk.image.v2.model.RunCelebrityRecognitionRequest;
+import com.huaweicloud.sdk.image.v2.model.RunCelebrityRecognitionResponse;
+import com.huaweicloud.sdk.image.v2.model.RunImageTaggingRequest;
+import com.huaweicloud.sdk.image.v2.model.RunImageTaggingResponse;
+import com.huaweicloud.sdk.image.v2.region.ImageRegion;
+import org.apache.camel.Exchange;
+import org.apache.camel.component.huaweicloud.image.constants.ImageRecognitionConstants;
+import org.apache.camel.component.huaweicloud.image.constants.ImageRecognitionProperties;
+import org.apache.camel.component.huaweicloud.image.models.ClientConfigurations;
+import org.apache.camel.support.DefaultProducer;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class ImageRecognitionProducer extends DefaultProducer {
+    private static final Logger LOG = LoggerFactory.getLogger(ImageRecognitionProducer.class);
+
+    private ImageClient imageClient;
+
+    private ClientConfigurations clientConfigurations;
+
+    private ImageRecognitionEndpoint endpoint;
+
+    public ImageRecognitionProducer(ImageRecognitionEndpoint endpoint) {
+        super(endpoint);
+        this.endpoint = endpoint;
+    }
+
+    @Override
+    protected void doStart() throws Exception {
+        super.doStart();
+        this.clientConfigurations = initializeConfigurations(this.endpoint);
+        this.imageClient = initializeClient(this.endpoint);
+    }
+
+    /**
+     * initialize ClientConfigurations
+     *
+     * @param  endpoint ImageRecognitionEndpoint
+     * @return          ClientConfigurations
+     */
+    private ClientConfigurations initializeConfigurations(ImageRecognitionEndpoint endpoint) {
+        ClientConfigurations clientConfigurations = new ClientConfigurations();
+
+        clientConfigurations.setAccessKey(getAccessKey(endpoint));
+        clientConfigurations.setSecretKey(getSecretKey(endpoint));
+        clientConfigurations.setProjectId(getProjectId(endpoint));
+        clientConfigurations.setEndpoint(getEndpoint(endpoint));
+
+        if (StringUtils.isEmpty(endpoint.getImageContent()) && StringUtils.isEmpty(endpoint.getImageUrl())) {
+            if (StringUtils.isEmpty(endpoint.getRegion())) {
+                LOG.error(""image and url not found"");
+                throw new IllegalArgumentException(""either image or url should be set"");
+            }
+        }
+        clientConfigurations.setIgnoreSslVerification(endpoint.isIgnoreSslVerification());
+        if (clientConfigurations.isIgnoreSslVerification()) {
+            LOG.warn(""SSL verification is ignored. This is unsafe in production environment"");
+        }
+        if (!StringUtils.isEmpty(endpoint.getProxyHost())) {
+            clientConfigurations.setProxyHost(endpoint.getProxyHost());
+            clientConfigurations.setProxyPort(endpoint.getProxyPort());
+            clientConfigurations.setProxyUser(endpoint.getProxyUser());
+            clientConfigurations.setProxyPassword(endpoint.getProxyPassword());
+        }
+        return clientConfigurations;
+    }
+
+    /**
+     * initialize image client. this is lazily initialized on the first message
+     *
+     * @param  endpoint ImageRecognitionEndpoint
+     * @return          ImageClient
+     */
+    private ImageClient initializeClient(ImageRecognitionEndpoint endpoint) {
+        if (endpoint.getImageClient() != null) {
+            LOG.warn(
+                    ""Instance of ImageClient was set on the endpoint. Skipping creation of ImageClient from endpoint parameters"");
+            return endpoint.getImageClient();
+        }
+        HttpConfig httpConfig = null;
+        if (clientConfigurations.getProxyHost() != null) {
+            httpConfig = HttpConfig.getDefaultHttpConfig()
+                    .withProxyHost(clientConfigurations.getProxyHost())
+                    .withProxyPort(clientConfigurations.getProxyPort())
+                    .withIgnoreSSLVerification(clientConfigurations.isIgnoreSslVerification());
+
+            if (clientConfigurations.getProxyUser() != null) {
+                httpConfig.setProxyUsername(clientConfigurations.getProxyUser());
+                httpConfig.setProxyPassword(clientConfigurations.getProxyPassword());
+            }
+        }
+
+        BasicCredentials credentials = new BasicCredentials().withAk(clientConfigurations.getAccessKey())
+                .withSk(clientConfigurations.getSecretKey())
+                .withProjectId(clientConfigurations.getProjectId());
+
+        ImageClient client = ImageClient.newBuilder()
+                .withCredential(credentials)
+                .withHttpConfig(httpConfig)
+                .withEndpoint(clientConfigurations.getEndpoint())
+                .build();
+
+        if (LOG.isDebugEnabled()) {
+            LOG.debug(""Successfully initialized Image client"");
+        }
+        return client;
+    }
+
+    public void process(Exchange exchange) {
+        String operation = ((ImageRecognitionEndpoint) super.getEndpoint()).getOperation();
+        if (StringUtils.isEmpty(operation)) {
+            LOG.error(""Operation is empty"");
+            throw new IllegalStateException(""operation name cannot be empty"");
+        }
+        switch (operation) {
+            case ImageRecognitionConstants.OPERATION_CELEBRITY_RECOGNITION:
+                if (LOG.isDebugEnabled()) {
+                    LOG.debug(""Performing celebrity recognition"");
+                }
+                performCelebrityRecognitionOperation(exchange);
+                break;
+            case ImageRecognitionConstants.OPERATION_TAG_RECOGNITION:
+                if (LOG.isDebugEnabled()) {
+                    LOG.debug(""Performing tag recognition"");
+                }
+                performTagRecognitionOperation(exchange);
+                break;
+            default:
+                LOG.error(""Unsupported operation: {}"", operation);
+                throw new UnsupportedOperationException(
+                        ""operation can only be either tagRecognition or celebrityRecognition"");
+        }
+    }
+
+    /**
+     * perform celebrity recognition
+     *
+     * @param exchange camel exchange
+     */
+    private void performCelebrityRecognitionOperation(Exchange exchange) {
+        updateClientConfigurations(exchange);
+
+        CelebrityRecognitionReq reqBody = new CelebrityRecognitionReq().withImage(this.clientConfigurations.getImageContent())
+                .withUrl(this.clientConfigurations.getImageUrl())
+                .withThreshold(this.clientConfigurations.getThreshold());
+
+        RunCelebrityRecognitionResponse response
+                = this.imageClient.runCelebrityRecognition(new RunCelebrityRecognitionRequest().withBody(reqBody));
+
+        exchange.getMessage().setBody(response.getResult());
+    }
+
+    /**
+     * perform tag recognition
+     *
+     * @param exchange camel exchange
+     */
+    private void performTagRecognitionOperation(Exchange exchange) {
+        updateClientConfigurations(exchange);
+
+        ImageTaggingReq reqBody = new ImageTaggingReq().withImage(this.clientConfigurations.getImageContent())
+                .withUrl(this.clientConfigurations.getImageUrl())
+                .withThreshold(this.clientConfigurations.getThreshold())
+                .withLanguage(this.clientConfigurations.getTagLanguage())
+                .withLimit(this.clientConfigurations.getTagLimit());
+
+        RunImageTaggingResponse response = this.imageClient.runImageTagging(new RunImageTaggingRequest().withBody(reqBody));
+
+        exchange.getMessage().setBody(response.getResult());
+    }
+
+    /**
+     * Update dynamic client configurations. Some endpoint parameters (imageContent, imageUrl, tagLanguage, tagLimit and
+     * threshold) can also be passed via exchange properties, so they can be updated between each transaction. Since
+     * they can change, we must clear the previous transaction and update these parameters with their new values
+     *
+     * @param exchange camel exchange
+     */
+    private void updateClientConfigurations(Exchange exchange) {
+        resetDynamicConfigurations();
+
+        boolean isImageContentSet = true;
+        boolean isImageUrlSet = true;
+
+        String imageContent = exchange.getProperty(ImageRecognitionProperties.IMAGE_CONTENT, String.class);
+        if (!StringUtils.isEmpty(imageContent)) {
+            clientConfigurations.setImageContent(imageContent);
+        } else if (!StringUtils.isEmpty(this.endpoint.getImageContent())) {
+            clientConfigurations.setImageContent(this.endpoint.getImageContent());
+        } else {
+            isImageContentSet = false;
+        }
+
+        String imageUrl = exchange.getProperty(ImageRecognitionProperties.IMAGE_URL, String.class);
+        if (!StringUtils.isEmpty(imageUrl)) {
+            clientConfigurations.setImageUrl(imageUrl);
+        } else if (!StringUtils.isEmpty(this.endpoint.getImageUrl())) {
+            clientConfigurations.setImageUrl(this.endpoint.getImageUrl());
+        } else {
+            isImageUrlSet = false;
+        }
+        if (!isImageContentSet && !isImageUrlSet) {
+            LOG.error(""Image content and url are not set"");
+            throw new IllegalArgumentException(""either image content or image url should be set"");
+        }
+
+        String tagLanguageProperty = exchange.getProperty(ImageRecognitionProperties.TAG_LANGUAGE, String.class);
+        clientConfigurations.setTagLanguage(
+                StringUtils.isEmpty(tagLanguageProperty) ? this.endpoint.getTagLanguage() : tagLanguageProperty);
+        if (!ImageRecognitionConstants.TAG_LANGUAGE_ZH.equals(clientConfigurations.getTagLanguage())
+                && !ImageRecognitionConstants.TAG_LANGUAGE_EN.equals(clientConfigurations.getTagLanguage())) {
+            LOG.error(""Tag language is invalid: {}"", clientConfigurations.getTagLanguage());
+            throw new IllegalArgumentException(""tag language can only be 'zh' or 'en'"");
+        }
+
+        Integer tagLimitProperty = exchange.getProperty(ImageRecognitionProperties.TAG_LIMIT, Integer.class);
+        clientConfigurations.setTagLimit(tagLimitProperty == null ? endpoint.getTagLimit() : tagLimitProperty);
+
+        Float thresholdProperty = exchange.getProperty(ImageRecognitionProperties.THRESHOLD, Float.class);
+        clientConfigurations.setThreshold(thresholdProperty == null ? endpoint.getThreshold() : thresholdProperty);
+
+        if (clientConfigurations.getThreshold() == -1) {
+            clientConfigurations
+                    .setThreshold(ImageRecognitionConstants.OPERATION_TAG_RECOGNITION.equals(endpoint.getOperation())
+                            ? ImageRecognitionConstants.DEFAULT_TAG_RECOGNITION_THRESHOLD
+                            : ImageRecognitionConstants.DEFAULT_CELEBRITY_RECOGNITION_THRESHOLD);
+        }
+        validateThresholdValue(clientConfigurations.getThreshold(), endpoint.getOperation());
+    }
+
+    /**
+     * validate threshold value. for tagRecognition, threshold should be at 0~100. for celebrityRecognition, threshold
+     * should be at 0~1.
+     *
+     * @param threshold threshold value
+     * @param operation operation
+     */
+    private void validateThresholdValue(float threshold, String operation) {
+        if (ImageRecognitionConstants.OPERATION_TAG_RECOGNITION.equals(operation)) {
+            if (threshold < 0 || threshold > ImageRecognitionConstants.TAG_RECOGNITION_THRESHOLD_MAX) {
+                LOG.error(""Tag threshold is invalid: {}"", threshold);
+                throw new IllegalArgumentException(""tag recognition threshold should be at 0~100"");
+            }
+        } else {
+            if (threshold < 0 || threshold > ImageRecognitionConstants.CELEBRITY_RECOGNITION_THRESHOLD_MAX) {
+                LOG.error(""Celebrity recognition threshold is invalid: {}"", threshold);","[{'comment': 'Same thing dont log and throw exception', 'commenter': 'davsclaus'}, {'comment': 'done', 'commenter': 'hokutor'}]"
6107,components/camel-huawei/camel-huaweicloud-imagerecognition/src/test/resources/log4j2.properties,"@@ -0,0 +1,28 @@
+## ---------------------------------------------------------------------------
+## Licensed to the Apache Software Foundation (ASF) under one or more
+## contributor license agreements.  See the NOTICE file distributed with
+## this work for additional information regarding copyright ownership.
+## The ASF licenses this file to You under the Apache License, Version 2.0
+## (the ""License""); you may not use this file except in compliance with
+## the License.  You may obtain a copy of the License at
+##
+##      http://www.apache.org/licenses/LICENSE-2.0
+##
+## Unless required by applicable law or agreed to in writing, software
+## distributed under the License is distributed on an ""AS IS"" BASIS,
+## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+## See the License for the specific language governing permissions and
+## limitations under the License.
+## ---------------------------------------------------------------------------
+
+appender.file.type = File
+appender.file.name = file
+appender.file.fileName = target/camel-huaweicloud-iam-test.log","[{'comment': 'Wrong file name', 'commenter': 'davsclaus'}, {'comment': 'done', 'commenter': 'hokutor'}]"
6107,components/camel-huawei/camel-huaweicloud-imagerecognition/pom.xml,"@@ -0,0 +1,81 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one or more
+    contributor license agreements.  See the NOTICE file distributed with
+    this work for additional information regarding copyright ownership.
+    The ASF licenses this file to You under the Apache License, Version 2.0
+    (the ""License""); you may not use this file except in compliance with
+    the License.  You may obtain a copy of the License at
+
+         http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an ""AS IS"" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+
+-->
+<project xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xmlns=""http://maven.apache.org/POM/4.0.0""
+         xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+
+    <modelVersion>4.0.0</modelVersion>
+
+    <parent>
+        <groupId>org.apache.camel</groupId>
+        <artifactId>camel-huawei-parent</artifactId>
+        <version>3.12.0-SNAPSHOT</version>
+    </parent>
+
+    <artifactId>camel-huaweicloud-imagerecognition</artifactId>
+    <packaging>jar</packaging>
+    <name>Camel :: Huawei Cloud :: ImageRecognition Component</name>
+    <description>A Camel Huawei Image Recognition component</description>
+
+    <properties>
+        <firstVersion>3.12.0</firstVersion>
+    </properties>
+
+
+    <dependencies>
+        <dependency>
+            <groupId>org.apache.camel</groupId>
+            <artifactId>camel-huaweicloud-common</artifactId>
+            <version>3.12.0-SNAPSHOT</version>","[{'comment': 'Remove version or use ${project.version}', 'commenter': 'davsclaus'}, {'comment': 'done', 'commenter': 'hokutor'}]"
6191,core/camel-support/src/main/java/org/apache/camel/support/EventHelper.java,"@@ -44,6 +44,7 @@
     // be left as-is.
 
     private static final Logger LOG = LoggerFactory.getLogger(EventHelper.class);
+    private static volatile boolean started = true;","[{'comment': 'should be false by default', 'commenter': 'davsclaus'}]"
6191,core/camel-support/src/main/java/org/apache/camel/support/EventHelper.java,"@@ -1300,7 +1301,7 @@ public static boolean notifyStepFailed(CamelContext context, Exchange exchange,
 
     private static boolean doNotifyEvent(EventNotifier notifier, CamelEvent event) {
         // only notify if notifier is started
-        boolean started = true;
+        started = true;
         if (notifier instanceof StatefulService) {","[{'comment': 'if (!started && notifier ....)', 'commenter': 'davsclaus'}]"
6191,core/camel-support/src/main/java/org/apache/camel/support/EventHelper.java,"@@ -1300,7 +1301,7 @@ public static boolean notifyStepFailed(CamelContext context, Exchange exchange,
 
     private static boolean doNotifyEvent(EventNotifier notifier, CamelEvent event) {
         // only notify if notifier is started
-        boolean started = true;
+        started = true;","[{'comment': 'remove started = true as we need to check the notifier instance.\r\n\r\nAnd if its NOT a stateful service then we can regard it as started ', 'commenter': 'davsclaus'}]"
6228,components/camel-file/src/main/java/org/apache/camel/component/file/FileConsumer.java,"@@ -177,6 +150,56 @@ protected boolean pollDirectory(String fileName, List<GenericFile<File>> fileLis
         return true;
     }
 
+    private List<File> listFiles(File directory) {
+        final File[] dirFiles = directory.listFiles();
+
+        if (dirFiles == null || dirFiles.length == 0) {
+            // no files in this directory to poll
+            if (LOG.isTraceEnabled()) {
+                LOG.trace(""No files found in directory: {}"", directory.getPath());
+            }
+            return Collections.emptyList();
+        } else {
+            // we found some files
+            if (LOG.isTraceEnabled()) {
+                LOG.trace(""Found {} in directory: {}"", dirFiles.length, directory.getPath());
+            }
+        }
+
+        FileResumeInfo resumeInfo = new FileResumeInfo(Arrays.asList(dirFiles));","[{'comment': 'We should only do this if a resume strategy is set - eg that noop strategy should be removed. The reason is that this code creates a large array (eg if there are 10.000 files) that are not needed when you do noop.\r\n\r\nYou could also consider resume strategy to be generic typed so its a File[], so you can pass in the File[] directly without having to create a List array.', 'commenter': 'davsclaus'}, {'comment': 'Thanks Claus. I think we can go with with the File array. I was leaving the optimizations for later, but it makes sense not to pessimize it in the first place. \n\nI will adjust it.', 'commenter': 'orpiske'}]"
6228,components/camel-file/src/main/java/org/apache/camel/component/file/consumer/FileResumeInfo.java,"@@ -0,0 +1,45 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.camel.component.file.consumer;
+
+import java.io.File;
+import java.util.Collections;
+import java.util.List;
+import java.util.Objects;
+
+public final class FileResumeInfo {
+    private final List<File> inputFiles;
+    private List<File> outputFiles;
+
+    public FileResumeInfo(List<File> inputFiles) {","[{'comment': 'Ah here you can use File[] so the list is not needed to be created', 'commenter': 'davsclaus'}]"
6228,components/camel-file/src/main/java/org/apache/camel/component/file/FileConsumer.java,"@@ -83,25 +88,18 @@ protected boolean pollDirectory(String fileName, List<GenericFile<File>> fileLis
         if (LOG.isTraceEnabled()) {
             LOG.trace(""Polling directory: {}, absolute path: {}"", directory.getPath(), directory.getAbsolutePath());
         }
-        File[] dirFiles = directory.listFiles();
-        if (dirFiles == null || dirFiles.length == 0) {
-            // no files in this directory to poll
-            if (LOG.isTraceEnabled()) {
-                LOG.trace(""No files found in directory: {}"", directory.getPath());
-            }
+        File[] files = listFiles(directory);
+        if (files != null && files.length == 0) {
             return true;
-        } else {
-            // we found some files
-            if (LOG.isTraceEnabled()) {
-                LOG.trace(""Found {} in directory: {}"", dirFiles.length, directory.getPath());
-            }
         }
-        List<File> files = Arrays.asList(dirFiles);
+
         if (getEndpoint().isPreSort()) {
-            files.sort(Comparator.comparing(File::getAbsoluteFile));
+            Arrays.sort(files, Comparator.comparing(File::getAbsoluteFile));
         }
 
-        for (File file : dirFiles) {
+        List<File> filesArray = Arrays.asList(files);","[{'comment': 'This still creates a List which means you have that memory problem if there are 100.000 files etc. Can we avoid the List and just use the array that the JDK returned in its listFiles API.', 'commenter': 'davsclaus'}, {'comment': ""Thanks. \r\n\r\nAbsolutely and I can definitely clean it up. \r\n\r\nObs.: just to clarify why it's here ... this is how the [code is doing right now](https://github.com/apache/camel/blob/22c7af563c067fc34c141da3de1338d7e37c3525/components/camel-file/src/main/java/org/apache/camel/component/file/FileConsumer.java#L99). So, I was leaving getting rid of these Lists after the initial code was in because fully removing them will require changes to camel-ftp as well. "", 'commenter': 'orpiske'}, {'comment': 'Ah okay, then you can look at this later if this is easier. It would be a good optimization to do', 'commenter': 'davsclaus'}, {'comment': ""Agreed, thanks. Later I'll optimize and benchmark this one :)"", 'commenter': 'orpiske'}]"
6232,components/camel-nats/src/main/java/org/apache/camel/component/nats/NatsConsumer.java,"@@ -153,31 +158,35 @@ public void run() {
             @Override
             public void onMessage(Message msg) throws InterruptedException {
                 LOG.debug(""Received Message: {}"", msg);
-                Exchange exchange = createExchange(false);
+                final Exchange exchange = NatsConsumer.this.createExchange(false);
                 try {
                     exchange.getIn().setBody(msg.getData());
                     exchange.getIn().setHeader(NatsConstants.NATS_REPLY_TO, msg.getReplyTo());
                     exchange.getIn().setHeader(NatsConstants.NATS_SID, msg.getSID());
                     exchange.getIn().setHeader(NatsConstants.NATS_SUBJECT, msg.getSubject());
                     exchange.getIn().setHeader(NatsConstants.NATS_QUEUE_NAME, msg.getSubscription().getQueueName());
                     exchange.getIn().setHeader(NatsConstants.NATS_MESSAGE_TIMESTAMP, System.currentTimeMillis());
-
-                    processor.process(exchange);
+                    if (msg.getHeaders() != null) {","[{'comment': 'you need to use the header filter strategy here to filter and only include valid headers', 'commenter': 'davsclaus'}, {'comment': 'updated', 'commenter': 'OpenGuidou'}]"
6232,components/camel-nats/src/main/java/org/apache/camel/component/nats/NatsProducer.java,"@@ -99,20 +108,42 @@ public boolean process(Exchange exchange, AsyncCallback callback) {
         } else {
             LOG.debug(""Publishing to topic: {}"", config.getTopic());
 
+            final NatsMessage.Builder builder = NatsMessage.builder()
+                    .data(body)
+                    .subject(config.getTopic())
+                    .headers(this.buildHeaders(exchange.getIn().getHeaders()));
+
             if (ObjectHelper.isNotEmpty(config.getReplySubject())) {
-                String replySubject = config.getReplySubject();
-                connection.publish(config.getTopic(), replySubject, body);
-            } else {
-                connection.publish(config.getTopic(), body);
+                final String replySubject = config.getReplySubject();
+                builder.replyTo(replySubject);
             }
+            this.connection.publish(builder.build());
             callback.done(true);
             return true;
         }
     }
 
+    private Headers buildHeaders(Map<String, Object> headersMap) {","[{'comment': 'The same header, filter only wanted headers via the strategy', 'commenter': 'davsclaus'}, {'comment': 'updated', 'commenter': 'OpenGuidou'}]"
6292,components/camel-kafka/src/main/java/org/apache/camel/component/kafka/DefaultKafkaManualCommit.java,"@@ -70,6 +83,26 @@ protected void commitOffset(StateRepository<String, String> offsetRepository, To
         }
     }
 
+    protected void commitAsyncOffset(
+            StateRepository<String, String> offsetRepository, TopicPartition partition, long recordOffset) {
+        if (recordOffset != -1) {
+            if (offsetRepository != null) {
+                offsetRepository.setState(serializeOffsetKey(partition), serializeOffsetValue(recordOffset));
+            } else {
+                LOG.debug(""CommitAsync {} from topic {} with offset: {}"", threadId, topicName, recordOffset);
+                consumer.commitAsync(Collections.singletonMap(partition, new OffsetAndMetadata(recordOffset + 1)),
+                        (offsets, exception) -> {
+                            if (exception != null) {
+                                LOG.error(""Error during async commit: "", exception);
+                            } else {
+                                LOG.info(""CommitAsync done for {} from topic {} with offset: {}"", threadId, topicName,","[{'comment': 'Reduce logging noise as INFO is too verbose, use DEBUG or TRACE', 'commenter': 'davsclaus'}]"
6292,components/camel-kafka/src/main/java/org/apache/camel/component/kafka/DefaultKafkaManualCommit.java,"@@ -70,6 +83,26 @@ protected void commitOffset(StateRepository<String, String> offsetRepository, To
         }
     }
 
+    protected void commitAsyncOffset(
+            StateRepository<String, String> offsetRepository, TopicPartition partition, long recordOffset) {
+        if (recordOffset != -1) {
+            if (offsetRepository != null) {
+                offsetRepository.setState(serializeOffsetKey(partition), serializeOffsetValue(recordOffset));
+            } else {
+                LOG.debug(""CommitAsync {} from topic {} with offset: {}"", threadId, topicName, recordOffset);
+                consumer.commitAsync(Collections.singletonMap(partition, new OffsetAndMetadata(recordOffset + 1)),
+                        (offsets, exception) -> {
+                            if (exception != null) {
+                                LOG.error(""Error during async commit: "", exception);","[{'comment': 'You can maybe add more details to this error message about topic, offset etc', 'commenter': 'davsclaus'}]"
6292,components/camel-kafka/src/main/java/org/apache/camel/component/kafka/DefaultKafkaManualCommit.java,"@@ -70,6 +83,26 @@ protected void commitOffset(StateRepository<String, String> offsetRepository, To
         }
     }
 
+    protected void commitAsyncOffset(
+            StateRepository<String, String> offsetRepository, TopicPartition partition, long recordOffset) {
+        if (recordOffset != -1) {","[{'comment': ""You could probably use `KafkaRecordProcessor.START_OFFSET` here instead of -1.\r\n\r\nObs.: I know we are using -1 on other parts of this code, but it's on my cleanup TODO to fix it."", 'commenter': 'orpiske'}]"
6292,components/camel-kafka/src/test/java/org/apache/camel/component/kafka/integration/KafkaConsumerAsyncManualCommitIT.java,"@@ -0,0 +1,142 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.kafka.integration;
+
+import java.util.Collections;
+import java.util.Properties;
+
+import org.apache.camel.Endpoint;
+import org.apache.camel.EndpointInject;
+import org.apache.camel.Exchange;
+import org.apache.camel.builder.AggregationStrategies;
+import org.apache.camel.builder.RouteBuilder;
+import org.apache.camel.component.kafka.KafkaConstants;
+import org.apache.camel.component.kafka.KafkaManualCommit;
+import org.apache.camel.component.mock.MockEndpoint;
+import org.apache.kafka.clients.producer.ProducerRecord;
+import org.junit.jupiter.api.AfterEach;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.RepeatedTest;
+
+import static org.junit.jupiter.api.Assertions.assertNotNull;
+
+public class KafkaConsumerAsyncManualCommitIT extends BaseEmbeddedKafkaTestSupport {
+
+    public static final String TOPIC = ""testManualCommitTest"";
+
+    @EndpointInject(""kafka:"" + TOPIC
+                    + ""?groupId=group1&sessionTimeoutMs=30000&autoCommitEnable=false""
+                    + ""&allowManualCommit=true&autoOffsetReset=earliest"")
+    private Endpoint from;
+
+    @EndpointInject(""mock:result"")
+    private MockEndpoint to;
+
+    @EndpointInject(""mock:resultBar"")
+    private MockEndpoint toBar;
+
+    private org.apache.kafka.clients.producer.KafkaProducer<String, String> producer;
+
+    @BeforeEach
+    public void before() {
+        Properties props = getDefaultProperties();
+        producer = new org.apache.kafka.clients.producer.KafkaProducer<>(props);
+    }
+
+    @AfterEach
+    public void after() {
+        if (producer != null) {
+            producer.close();
+        }
+        // clean all test topics
+        kafkaAdminClient.deleteTopics(Collections.singletonList(TOPIC));
+    }
+
+    @Override
+    protected RouteBuilder createRouteBuilder() throws Exception {
+        return new RouteBuilder() {
+
+            @Override
+            public void configure() throws Exception {
+                from(from).routeId(""foo"").to(""direct:aggregate"");
+                // With sync manual commit, this would throw a concurrent modification exception
+                // It can be usesd in aggregator with completion timeout/interval for instance
+                // WARN: records from one partition must be processed by one unique thread
+                from(""direct:aggregate"").routeId(""aggregate"").to(to)
+                        .aggregate()
+                        .constant(true)
+                        .completionTimeout(1)
+                        .aggregationStrategy(AggregationStrategies.groupedExchange())
+                        .split().body()
+                        .process(e -> {
+                            KafkaManualCommit manual = e.getMessage().getBody(Exchange.class)
+                                    .getMessage().getHeader(KafkaConstants.MANUAL_COMMIT, KafkaManualCommit.class);
+                            assertNotNull(manual);
+                            if (e.getMessage().getBody(String.class).equals(""message-0"")) {
+                                // Delay the commit of the first message
+                                Thread.sleep(2000);","[{'comment': 'I think it would be better to avoid the `Thread.sleep` call. My .2 cents is to try to use one of the Java concurrent facilities or awaitility if necessary. ', 'commenter': 'orpiske'}]"
6323,components/camel-mllp/src/main/java/org/apache/camel/component/mllp/internal/IdleTimeoutStrategy.java,"@@ -0,0 +1,50 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.camel.component.mllp.internal;
+
+import java.util.HashMap;
+import java.util.Map;
+
+public enum IdleTimeoutStrategy {","[{'comment': 'This is overkill will lookup map etc when there are 2 values. Keep it just as simple enum', 'commenter': 'davsclaus'}]"
6323,components/camel-mllp/src/main/java/org/apache/camel/component/mllp/MllpEndpoint.java,"@@ -287,6 +288,17 @@ public void setMaxConcurrentConsumers(int maxConcurrentConsumers) {
         configuration.setMaxConcurrentConsumers(maxConcurrentConsumers);
     }
 
+    public void setIdleTimeoutStrategy(String strategy) {","[{'comment': 'Camel has automatic conversion to enums, so this is not needed. ', 'commenter': 'davsclaus'}]"
6323,components/camel-mllp/src/main/java/org/apache/camel/component/mllp/internal/IdleTimeoutStrategy.java,"@@ -0,0 +1,50 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.camel.component.mllp.internal;","[{'comment': 'Can we move this out of an internal package as it should be a public api.', 'commenter': 'davsclaus'}]"
6323,components/camel-mllp/src/test/java/org/apache/camel/component/mllp/internal/MllpIdleTimeoutStrategyTest.java,"@@ -0,0 +1,198 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.camel.component.mllp.internal;
+
+import java.lang.reflect.Field;
+import java.util.concurrent.TimeUnit;
+
+import org.apache.camel.CamelContext;
+import org.apache.camel.Endpoint;
+import org.apache.camel.EndpointInject;
+import org.apache.camel.LoggingLevel;
+import org.apache.camel.ProducerTemplate;
+import org.apache.camel.RoutesBuilder;
+import org.apache.camel.builder.RouteBuilder;
+import org.apache.camel.component.mllp.MllpComponent;
+import org.apache.camel.component.mllp.MllpEndpoint;
+import org.apache.camel.component.mllp.MllpTcpClientProducer;
+import org.apache.camel.component.mock.MockEndpoint;
+import org.apache.camel.test.AvailablePortFinder;
+import org.apache.camel.test.junit.rule.mllp.MllpServerResource;
+import org.apache.camel.test.junit5.CamelTestSupport;
+import org.apache.camel.test.mllp.Hl7TestMessageGenerator;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.extension.RegisterExtension;
+import org.mockito.Mockito;
+
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+public class MllpIdleTimeoutStrategyTest extends CamelTestSupport {
+
+    static final int IDLE_TIMEOUT = 500;
+
+    @RegisterExtension
+    public MllpServerResource mllpServer = new MllpServerResource(""localhost"", AvailablePortFinder.getNextAvailable());
+
+    @EndpointInject(""direct://sourcedefault"")
+    ProducerTemplate defaultStrategySource;
+
+    @EndpointInject(""direct://sourcereset"")
+    ProducerTemplate resetStrategySource;
+
+    @EndpointInject(""direct://sourceclose"")
+    ProducerTemplate closeStrategySource;
+
+    @EndpointInject(""mock://target"")
+    MockEndpoint target;
+
+    private MllpEndpoint defaultStrategyEndpoint;
+
+    private MllpEndpoint resetStrategyEndpoint;
+
+    private MllpEndpoint closeStrategyEndpoint;
+
+    private MllpSocketBuffer defaultStrategyMllpSocketBuffer;
+
+    private MllpSocketBuffer resetStrategyMllpSocketBuffer;
+
+    private MllpSocketBuffer closeStrategyMllpSocketBuffer;
+
+    private MllpTcpClientProducer defaultStrategyProducer;
+
+    private MllpTcpClientProducer resetStrategyProducer;
+
+    private MllpTcpClientProducer closeStrategyProducer;
+
+    @Override
+    protected CamelContext createCamelContext() throws Exception {
+        if (context != null) {
+            return context;
+        }
+        return super.createCamelContext();
+    }
+
+    @Override
+    protected void doPreSetup() throws Exception {
+        MllpComponent mllpComponent = new MllpComponent(createCamelContext());","[{'comment': 'You should not create it via new, but use camelContext.getComponent(""mllp"", MllpComponent.class) so its created by Camel to be correctly initialized', 'commenter': 'davsclaus'}]"
6323,components/camel-mllp/src/main/java/org/apache/camel/component/mllp/MllpConfiguration.java,"@@ -106,6 +107,9 @@
     @UriParam(label = ""codec"")
     String charsetName;
 
+    @UriParam(label = ""advanced,producer,tcp"", defaultValue = ""RESET"")","[{'comment': 'Remove tcp as its not a label category we use, and we should limit this to 2', 'commenter': 'davsclaus'}]"
6413,components/camel-google/camel-google-pubsub/src/main/java/org/apache/camel/component/google/pubsub/GooglePubsubComponent.java,"@@ -87,6 +91,11 @@
               description = ""How many milliseconds should a producer be allowed to terminate."")
     private int publisherTerminationTimeout = 60000;
 
+    @Metadata(
+              label = ""consumer"",
+              description = ""Additional retryable error codes for synchronous pull. By default the PubSub client library retries ABORTED, UNAVAILABLE, UNKNOWN"")
+    private StatusCode.Code[] synchronousPullRetryableCodes = new StatusCode.Code[0];","[{'comment': ""I wouldn't use internals classes for Camel option. It makes more sense to set them as Strings and then convert when it's time to use them. If we start going down this path, it will be a mess in all components. So please use a different approach. Thanks."", 'commenter': 'oscerd'}, {'comment': 'What would be the appropriate Camel exception to throw in case the provided strings cannot be converted to the Enum?\r\nSince the default error codes and the custom codes are both known at start-up, does it make sense to generate the list of retryable codes at component initialization time? Possibly in the init() method?', 'commenter': 'vpaturet'}, {'comment': 'It makes sense to me, but I would wait for @davsclaus feedback on this, because we are focusing a lot of performance/memory footprint and allocation, so maybe we could find a better way', 'commenter': 'oscerd'}, {'comment': 'We use a String value in other components where we separate the values by comma - this is the most friendly for tooling , spring-boot auto configuration, etc.\r\n\r\nThen you can say \r\n\r\ncamel.component.google-pubsub.synchronousPullRetryableCodes = DEADLINE_EXCEEDED,RESOURCE_EXHAUSTED', 'commenter': 'davsclaus'}, {'comment': 'Thanks for the feedback, I have updated the PR accordingly. There was another question about where the logic that parses the option should be. In getSubscriberStub() as it is now, or earlier in the component initialization process?', 'commenter': 'vpaturet'}]"
6419,core/camel-support/src/main/java/org/apache/camel/support/task/BackgroundTask.java,"@@ -155,7 +155,7 @@ private boolean waitForTaskCompletion(CountDownLatch latch, ScheduledExecutorSer
                 if (!latch.await(budget.maxDuration(), TimeUnit.MILLISECONDS)) {
                     LOG.debug(""Timeout out waiting for the completion of the task"");
                 } else {
-                    LOG.info(""The task is complete after iterations and the code is ready to continue"");
+                    LOG.info(""The task has finished the execution is ready to continue"");","[{'comment': 'Use DEBUG logging level as we should not be noisy during processing exchanges in Camel', 'commenter': 'davsclaus'}, {'comment': 'Sure thing!', 'commenter': 'orpiske'}, {'comment': 'Done, marking as resolved, thanks!', 'commenter': 'orpiske'}]"
6526,components/camel-milo/src/main/java/org/apache/camel/component/milo/browse/MiloBrowseEndpoint.java,"@@ -0,0 +1,294 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.milo.browse;
+
+import java.util.Objects;
+
+import org.apache.camel.Category;
+import org.apache.camel.Consumer;
+import org.apache.camel.Processor;
+import org.apache.camel.Producer;
+import org.apache.camel.component.milo.client.MiloClientConfiguration;
+import org.apache.camel.component.milo.client.MiloClientConnection;
+import org.apache.camel.component.milo.client.MiloClientConnectionManager;
+import org.apache.camel.spi.Metadata;
+import org.apache.camel.spi.UriEndpoint;
+import org.apache.camel.spi.UriParam;
+import org.apache.camel.spi.UriPath;
+import org.apache.camel.support.DefaultEndpoint;
+import org.eclipse.milo.opcua.stack.core.Identifiers;
+import org.eclipse.milo.opcua.stack.core.types.builtin.NodeId;
+import org.eclipse.milo.opcua.stack.core.types.enumerated.BrowseDirection;
+import org.eclipse.milo.opcua.stack.core.types.enumerated.NodeClass;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * Connect to OPC UA servers using the binary protocol for browsing the node tree.
+ */
+@UriEndpoint(firstVersion = ""3.13.0"", scheme = ""milo-browse"", syntax = ""milo-browse:endpointUri"", title = ""OPC UA Browser"",
+             category = { Category.IOT })
+public class MiloBrowseEndpoint extends DefaultEndpoint {
+
+    private static final Logger LOG = LoggerFactory.getLogger(MiloBrowseEndpoint.class);
+
+    private final MiloClientConnectionManager connectionManager;
+
+    /**
+     * The OPC UA server endpoint
+     */
+    @UriPath
+    @Metadata(required = true)
+    private final String endpointUri;
+
+    /**
+     * The node definition (see Node ID)
+     */
+    @UriParam(defaultValue = ""ns=0;id=84"", defaultValueNote = ""Root folder as per OPC-UA spec"")
+    private String node = Identifiers.RootFolder.toParseableString();
+
+    /**
+     * The direction to browse (forward, inverse, ...)
+     */
+    @UriParam(defaultValue = ""Forward"",
+              defaultValueNote = ""The direction to browse; See org.eclipse.milo.opcua.stack.core.types.enumerated.BrowseDirection"")
+    private BrowseDirection direction = BrowseDirection.Forward;
+
+    /**
+     * Whether to include sub-types for browsing; only applicable for non-recursive browsing
+     */
+    @UriParam(defaultValue = ""true"")
+    private boolean includeSubTypes = true;
+
+    /**
+     * The mask indicating the node classes of interest in browsing
+     */
+    @UriParam(defaultValue = ""Variable,Object,DataType"",
+              defaultValueNote = ""Comma-separated node class list; see org.eclipse.milo.opcua.stack.core.types.enumerated.NodeClass"")
+    private String nodeClasses = NodeClass.Variable + "","" + NodeClass.Object + "","" + NodeClass.DataType;
+
+    private int nodeClassMask = NodeClass.Variable.getValue() | NodeClass.Object.getValue() | NodeClass.DataType.getValue();
+
+    /**
+     * Whether to browse recursively into sub-types, ignores includeSubTypes setting as it's implied to be set to true
+     */
+    @UriParam(defaultValue = ""false"",
+              defaultValueNote = ""Whether to recursively browse sub-types: true|false"")
+    private boolean recursive;
+
+    /**
+     * When browsing recursively into sub-types, what's the maximum search depth for diving into the tree
+     */
+    @UriParam(defaultValue = ""3"", defaultValueNote = ""Maximum depth for browsing recursively (only if recursive = true)"")
+    private int depth = 3;
+
+    /**
+     * Filter out node ids to limit browsing
+     */
+    @UriParam(defaultValue = ""None"", defaultValueNote = ""Regular filter expression matching node ids"")
+    private String filter;
+
+    /**
+     * The maximum number node ids requested per server call
+     */
+    @UriParam(defaultValue = ""10"",
+              defaultValueNote = ""Maximum number of node ids requested per browse call (applies to browsing sub-types only; only if recursive = true)"")
+    private int maxNodeIdsPerRequest = 10;
+
+    /**
+     * The client configuration
+     */
+    @UriParam
+    private MiloClientConfiguration configuration;
+
+    /**
+     * Default ""await"" setting for writes
+     */
+    @UriParam
+    private boolean defaultAwaitWrites;
+
+    public MiloBrowseEndpoint(final String uri, final MiloBrowseComponent component, final String endpointUri,
+                              final MiloClientConnectionManager connectionManager) {
+        super(uri, component);
+
+        Objects.requireNonNull(component);
+        Objects.requireNonNull(endpointUri);
+        Objects.requireNonNull(connectionManager);
+
+        this.endpointUri = endpointUri;
+        this.connectionManager = connectionManager;
+    }
+
+    public void setConfiguration(MiloClientConfiguration configuration) {
+        this.configuration = configuration;
+    }
+
+    public MiloClientConfiguration getConfiguration() {
+        return configuration;
+    }
+
+    @Override
+    public Producer createProducer() throws Exception {
+        return new MiloBrowseProducer(this, defaultAwaitWrites);
+    }
+
+    @Override
+    public Consumer createConsumer(final Processor processor) throws Exception {
+        throw new UnsupportedOperationException(MiloBrowseEndpoint.class.getName() + "" doesn't support a consumer"");
+    }
+
+    public MiloClientConnection createConnection() {
+        return this.connectionManager.createConnection(configuration, null);
+    }
+
+    public void releaseConnection(MiloClientConnection connection) {
+        this.connectionManager.releaseConnection(connection);
+    }
+
+    public void setNode(final String node) {
+        this.node = node;
+    }
+
+    public String getNode() {
+        return node;
+    }
+
+    NodeId getNodeId() {
+        return getNodeId(this.node);
+    }
+
+    NodeId getNodeId(String nodeId) {
+        if (nodeId != null) {
+            return NodeId.parse(nodeId);
+        } else {
+            return null;
+        }
+    }
+
+    public BrowseDirection getDirection() {
+        return direction;
+    }
+
+    public void setDirection(String direction) {","[{'comment': 'The getter/setter type should be the same - Camel knows how to convert string to enum', 'commenter': 'davsclaus'}, {'comment': 'Ok, thanks - changed it accordingly', 'commenter': 'ank19'}]"
6526,components/camel-milo/src/main/java/org/apache/camel/component/milo/browse/MiloBrowseEndpoint.java,"@@ -0,0 +1,294 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.milo.browse;
+
+import java.util.Objects;
+
+import org.apache.camel.Category;
+import org.apache.camel.Consumer;
+import org.apache.camel.Processor;
+import org.apache.camel.Producer;
+import org.apache.camel.component.milo.client.MiloClientConfiguration;
+import org.apache.camel.component.milo.client.MiloClientConnection;
+import org.apache.camel.component.milo.client.MiloClientConnectionManager;
+import org.apache.camel.spi.Metadata;
+import org.apache.camel.spi.UriEndpoint;
+import org.apache.camel.spi.UriParam;
+import org.apache.camel.spi.UriPath;
+import org.apache.camel.support.DefaultEndpoint;
+import org.eclipse.milo.opcua.stack.core.Identifiers;
+import org.eclipse.milo.opcua.stack.core.types.builtin.NodeId;
+import org.eclipse.milo.opcua.stack.core.types.enumerated.BrowseDirection;
+import org.eclipse.milo.opcua.stack.core.types.enumerated.NodeClass;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * Connect to OPC UA servers using the binary protocol for browsing the node tree.
+ */
+@UriEndpoint(firstVersion = ""3.13.0"", scheme = ""milo-browse"", syntax = ""milo-browse:endpointUri"", title = ""OPC UA Browser"",
+             category = { Category.IOT })
+public class MiloBrowseEndpoint extends DefaultEndpoint {
+
+    private static final Logger LOG = LoggerFactory.getLogger(MiloBrowseEndpoint.class);
+
+    private final MiloClientConnectionManager connectionManager;
+
+    /**
+     * The OPC UA server endpoint
+     */
+    @UriPath
+    @Metadata(required = true)
+    private final String endpointUri;
+
+    /**
+     * The node definition (see Node ID)
+     */
+    @UriParam(defaultValue = ""ns=0;id=84"", defaultValueNote = ""Root folder as per OPC-UA spec"")
+    private String node = Identifiers.RootFolder.toParseableString();
+
+    /**
+     * The direction to browse (forward, inverse, ...)
+     */
+    @UriParam(defaultValue = ""Forward"",
+              defaultValueNote = ""The direction to browse; See org.eclipse.milo.opcua.stack.core.types.enumerated.BrowseDirection"")
+    private BrowseDirection direction = BrowseDirection.Forward;
+
+    /**
+     * Whether to include sub-types for browsing; only applicable for non-recursive browsing
+     */
+    @UriParam(defaultValue = ""true"")
+    private boolean includeSubTypes = true;
+
+    /**
+     * The mask indicating the node classes of interest in browsing
+     */
+    @UriParam(defaultValue = ""Variable,Object,DataType"",
+              defaultValueNote = ""Comma-separated node class list; see org.eclipse.milo.opcua.stack.core.types.enumerated.NodeClass"")
+    private String nodeClasses = NodeClass.Variable + "","" + NodeClass.Object + "","" + NodeClass.DataType;
+
+    private int nodeClassMask = NodeClass.Variable.getValue() | NodeClass.Object.getValue() | NodeClass.DataType.getValue();
+
+    /**
+     * Whether to browse recursively into sub-types, ignores includeSubTypes setting as it's implied to be set to true
+     */
+    @UriParam(defaultValue = ""false"",
+              defaultValueNote = ""Whether to recursively browse sub-types: true|false"")
+    private boolean recursive;
+
+    /**
+     * When browsing recursively into sub-types, what's the maximum search depth for diving into the tree
+     */
+    @UriParam(defaultValue = ""3"", defaultValueNote = ""Maximum depth for browsing recursively (only if recursive = true)"")
+    private int depth = 3;
+
+    /**
+     * Filter out node ids to limit browsing
+     */
+    @UriParam(defaultValue = ""None"", defaultValueNote = ""Regular filter expression matching node ids"")
+    private String filter;
+
+    /**
+     * The maximum number node ids requested per server call
+     */
+    @UriParam(defaultValue = ""10"",
+              defaultValueNote = ""Maximum number of node ids requested per browse call (applies to browsing sub-types only; only if recursive = true)"")
+    private int maxNodeIdsPerRequest = 10;
+
+    /**
+     * The client configuration
+     */
+    @UriParam
+    private MiloClientConfiguration configuration;
+
+    /**
+     * Default ""await"" setting for writes
+     */
+    @UriParam
+    private boolean defaultAwaitWrites;
+
+    public MiloBrowseEndpoint(final String uri, final MiloBrowseComponent component, final String endpointUri,
+                              final MiloClientConnectionManager connectionManager) {
+        super(uri, component);
+
+        Objects.requireNonNull(component);
+        Objects.requireNonNull(endpointUri);
+        Objects.requireNonNull(connectionManager);
+
+        this.endpointUri = endpointUri;
+        this.connectionManager = connectionManager;
+    }
+
+    public void setConfiguration(MiloClientConfiguration configuration) {
+        this.configuration = configuration;
+    }
+
+    public MiloClientConfiguration getConfiguration() {
+        return configuration;
+    }
+
+    @Override
+    public Producer createProducer() throws Exception {
+        return new MiloBrowseProducer(this, defaultAwaitWrites);
+    }
+
+    @Override
+    public Consumer createConsumer(final Processor processor) throws Exception {
+        throw new UnsupportedOperationException(MiloBrowseEndpoint.class.getName() + "" doesn't support a consumer"");
+    }
+
+    public MiloClientConnection createConnection() {
+        return this.connectionManager.createConnection(configuration, null);
+    }
+
+    public void releaseConnection(MiloClientConnection connection) {
+        this.connectionManager.releaseConnection(connection);
+    }
+
+    public void setNode(final String node) {
+        this.node = node;
+    }
+
+    public String getNode() {
+        return node;
+    }
+
+    NodeId getNodeId() {
+        return getNodeId(this.node);
+    }
+
+    NodeId getNodeId(String nodeId) {
+        if (nodeId != null) {
+            return NodeId.parse(nodeId);
+        } else {
+            return null;
+        }
+    }
+
+    public BrowseDirection getDirection() {
+        return direction;
+    }
+
+    public void setDirection(String direction) {
+        try {
+            this.direction = BrowseDirection.valueOf(direction);
+        } catch (IllegalArgumentException e) {
+            throw new IllegalArgumentException(""Browsing direction '"" + direction + ""' not supported"", e);
+        }
+    }
+
+    public boolean isIncludeSubTypes() {
+        return includeSubTypes;
+    }
+
+    public void setIncludeSubTypes(boolean includeSubTypes) {
+        this.includeSubTypes = includeSubTypes;
+    }
+
+    public String getNodeClasses() {
+        return nodeClasses;
+    }
+
+    public void setNodeClasses(String nodeClasses) {
+        this.nodeClasses = nodeClasses;
+        final String[] nodeClassArray = nodeClasses.split("","");
+        int mask = 0;
+        try {
+            for (String nodeClass : nodeClassArray) {
+                mask |= NodeClass.valueOf(nodeClass).getValue();
+            }
+        } catch (IllegalArgumentException e) {
+            throw new IllegalArgumentException(""Invalid node class specified: "" + nodeClasses, e);
+        }
+        LOG.debug(""Node class list conversion {} -> {}"", nodeClasses, mask);
+        nodeClassMask = mask;
+    }
+
+    public int getNodeClassMask() {
+        return nodeClassMask;
+    }
+
+    public void setDirection(BrowseDirection direction) {
+        this.direction = direction;
+    }
+
+    public boolean isDefaultAwaitWrites() {
+        return defaultAwaitWrites;
+    }
+
+    public void setDefaultAwaitWrites(boolean defaultAwaitWrites) {
+        this.defaultAwaitWrites = defaultAwaitWrites;
+    }
+
+    public boolean isRecursive() {
+        return recursive;
+    }
+
+    public void setRecursive(boolean recursive) {
+        this.recursive = recursive;
+    }
+
+    public int getDepth() {
+        return depth;
+    }
+
+    public void setDepth(int depth) {
+        this.depth = depth;
+    }
+
+    public String getFilter() {
+        return filter;
+    }
+
+    public void setFilter(String filter) {
+        this.filter = filter;
+    }
+
+    public int getMaxNodeIdsPerRequest() {
+        return maxNodeIdsPerRequest;
+    }
+
+    public void setMaxNodeIdsPerRequest(int maxNodeIdsPerRequest) {
+        this.maxNodeIdsPerRequest = maxNodeIdsPerRequest;
+    }
+
+    @Override
+    public boolean equals(Object o) {","[{'comment': 'Remove equals', 'commenter': 'davsclaus'}, {'comment': 'Ok, done', 'commenter': 'ank19'}]"
6526,components/camel-milo/src/main/java/org/apache/camel/component/milo/browse/MiloBrowseEndpoint.java,"@@ -0,0 +1,294 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.milo.browse;
+
+import java.util.Objects;
+
+import org.apache.camel.Category;
+import org.apache.camel.Consumer;
+import org.apache.camel.Processor;
+import org.apache.camel.Producer;
+import org.apache.camel.component.milo.client.MiloClientConfiguration;
+import org.apache.camel.component.milo.client.MiloClientConnection;
+import org.apache.camel.component.milo.client.MiloClientConnectionManager;
+import org.apache.camel.spi.Metadata;
+import org.apache.camel.spi.UriEndpoint;
+import org.apache.camel.spi.UriParam;
+import org.apache.camel.spi.UriPath;
+import org.apache.camel.support.DefaultEndpoint;
+import org.eclipse.milo.opcua.stack.core.Identifiers;
+import org.eclipse.milo.opcua.stack.core.types.builtin.NodeId;
+import org.eclipse.milo.opcua.stack.core.types.enumerated.BrowseDirection;
+import org.eclipse.milo.opcua.stack.core.types.enumerated.NodeClass;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * Connect to OPC UA servers using the binary protocol for browsing the node tree.
+ */
+@UriEndpoint(firstVersion = ""3.13.0"", scheme = ""milo-browse"", syntax = ""milo-browse:endpointUri"", title = ""OPC UA Browser"",
+             category = { Category.IOT })
+public class MiloBrowseEndpoint extends DefaultEndpoint {
+
+    private static final Logger LOG = LoggerFactory.getLogger(MiloBrowseEndpoint.class);
+
+    private final MiloClientConnectionManager connectionManager;
+
+    /**
+     * The OPC UA server endpoint
+     */
+    @UriPath
+    @Metadata(required = true)
+    private final String endpointUri;
+
+    /**
+     * The node definition (see Node ID)
+     */
+    @UriParam(defaultValue = ""ns=0;id=84"", defaultValueNote = ""Root folder as per OPC-UA spec"")
+    private String node = Identifiers.RootFolder.toParseableString();
+
+    /**
+     * The direction to browse (forward, inverse, ...)
+     */
+    @UriParam(defaultValue = ""Forward"",
+              defaultValueNote = ""The direction to browse; See org.eclipse.milo.opcua.stack.core.types.enumerated.BrowseDirection"")
+    private BrowseDirection direction = BrowseDirection.Forward;
+
+    /**
+     * Whether to include sub-types for browsing; only applicable for non-recursive browsing
+     */
+    @UriParam(defaultValue = ""true"")
+    private boolean includeSubTypes = true;
+
+    /**
+     * The mask indicating the node classes of interest in browsing
+     */
+    @UriParam(defaultValue = ""Variable,Object,DataType"",
+              defaultValueNote = ""Comma-separated node class list; see org.eclipse.milo.opcua.stack.core.types.enumerated.NodeClass"")
+    private String nodeClasses = NodeClass.Variable + "","" + NodeClass.Object + "","" + NodeClass.DataType;
+
+    private int nodeClassMask = NodeClass.Variable.getValue() | NodeClass.Object.getValue() | NodeClass.DataType.getValue();
+
+    /**
+     * Whether to browse recursively into sub-types, ignores includeSubTypes setting as it's implied to be set to true
+     */
+    @UriParam(defaultValue = ""false"",
+              defaultValueNote = ""Whether to recursively browse sub-types: true|false"")
+    private boolean recursive;
+
+    /**
+     * When browsing recursively into sub-types, what's the maximum search depth for diving into the tree
+     */
+    @UriParam(defaultValue = ""3"", defaultValueNote = ""Maximum depth for browsing recursively (only if recursive = true)"")
+    private int depth = 3;
+
+    /**
+     * Filter out node ids to limit browsing
+     */
+    @UriParam(defaultValue = ""None"", defaultValueNote = ""Regular filter expression matching node ids"")
+    private String filter;
+
+    /**
+     * The maximum number node ids requested per server call
+     */
+    @UriParam(defaultValue = ""10"",
+              defaultValueNote = ""Maximum number of node ids requested per browse call (applies to browsing sub-types only; only if recursive = true)"")
+    private int maxNodeIdsPerRequest = 10;
+
+    /**
+     * The client configuration
+     */
+    @UriParam
+    private MiloClientConfiguration configuration;
+
+    /**
+     * Default ""await"" setting for writes
+     */
+    @UriParam
+    private boolean defaultAwaitWrites;
+
+    public MiloBrowseEndpoint(final String uri, final MiloBrowseComponent component, final String endpointUri,
+                              final MiloClientConnectionManager connectionManager) {
+        super(uri, component);
+
+        Objects.requireNonNull(component);
+        Objects.requireNonNull(endpointUri);
+        Objects.requireNonNull(connectionManager);
+
+        this.endpointUri = endpointUri;
+        this.connectionManager = connectionManager;
+    }
+
+    public void setConfiguration(MiloClientConfiguration configuration) {
+        this.configuration = configuration;
+    }
+
+    public MiloClientConfiguration getConfiguration() {
+        return configuration;
+    }
+
+    @Override
+    public Producer createProducer() throws Exception {
+        return new MiloBrowseProducer(this, defaultAwaitWrites);
+    }
+
+    @Override
+    public Consumer createConsumer(final Processor processor) throws Exception {
+        throw new UnsupportedOperationException(MiloBrowseEndpoint.class.getName() + "" doesn't support a consumer"");
+    }
+
+    public MiloClientConnection createConnection() {
+        return this.connectionManager.createConnection(configuration, null);
+    }
+
+    public void releaseConnection(MiloClientConnection connection) {
+        this.connectionManager.releaseConnection(connection);
+    }
+
+    public void setNode(final String node) {
+        this.node = node;
+    }
+
+    public String getNode() {
+        return node;
+    }
+
+    NodeId getNodeId() {
+        return getNodeId(this.node);
+    }
+
+    NodeId getNodeId(String nodeId) {
+        if (nodeId != null) {
+            return NodeId.parse(nodeId);
+        } else {
+            return null;
+        }
+    }
+
+    public BrowseDirection getDirection() {
+        return direction;
+    }
+
+    public void setDirection(String direction) {
+        try {
+            this.direction = BrowseDirection.valueOf(direction);
+        } catch (IllegalArgumentException e) {
+            throw new IllegalArgumentException(""Browsing direction '"" + direction + ""' not supported"", e);
+        }
+    }
+
+    public boolean isIncludeSubTypes() {
+        return includeSubTypes;
+    }
+
+    public void setIncludeSubTypes(boolean includeSubTypes) {
+        this.includeSubTypes = includeSubTypes;
+    }
+
+    public String getNodeClasses() {
+        return nodeClasses;
+    }
+
+    public void setNodeClasses(String nodeClasses) {
+        this.nodeClasses = nodeClasses;
+        final String[] nodeClassArray = nodeClasses.split("","");
+        int mask = 0;
+        try {
+            for (String nodeClass : nodeClassArray) {
+                mask |= NodeClass.valueOf(nodeClass).getValue();
+            }
+        } catch (IllegalArgumentException e) {
+            throw new IllegalArgumentException(""Invalid node class specified: "" + nodeClasses, e);
+        }
+        LOG.debug(""Node class list conversion {} -> {}"", nodeClasses, mask);
+        nodeClassMask = mask;
+    }
+
+    public int getNodeClassMask() {
+        return nodeClassMask;
+    }
+
+    public void setDirection(BrowseDirection direction) {
+        this.direction = direction;
+    }
+
+    public boolean isDefaultAwaitWrites() {
+        return defaultAwaitWrites;
+    }
+
+    public void setDefaultAwaitWrites(boolean defaultAwaitWrites) {
+        this.defaultAwaitWrites = defaultAwaitWrites;
+    }
+
+    public boolean isRecursive() {
+        return recursive;
+    }
+
+    public void setRecursive(boolean recursive) {
+        this.recursive = recursive;
+    }
+
+    public int getDepth() {
+        return depth;
+    }
+
+    public void setDepth(int depth) {
+        this.depth = depth;
+    }
+
+    public String getFilter() {
+        return filter;
+    }
+
+    public void setFilter(String filter) {
+        this.filter = filter;
+    }
+
+    public int getMaxNodeIdsPerRequest() {
+        return maxNodeIdsPerRequest;
+    }
+
+    public void setMaxNodeIdsPerRequest(int maxNodeIdsPerRequest) {
+        this.maxNodeIdsPerRequest = maxNodeIdsPerRequest;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) {
+            return true;
+        }
+        if (o == null || getClass() != o.getClass()) {
+            return false;
+        }
+        if (!super.equals(o)) {
+            return false;
+        }
+        MiloBrowseEndpoint that = (MiloBrowseEndpoint) o;
+        boolean nodeClassEquality = nodeClassMask == that.nodeClassMask && Objects.equals(nodeClasses, that.nodeClasses);
+        return includeSubTypes == that.includeSubTypes && recursive == that.recursive
+                && depth == that.depth && maxNodeIdsPerRequest == that.maxNodeIdsPerRequest
+                && defaultAwaitWrites == that.defaultAwaitWrites && Objects.equals(endpointUri, that.endpointUri)
+                && Objects.equals(node, that.node) && direction == that.direction && nodeClassEquality
+                && Objects.equals(filter, that.filter);
+    }
+
+    @Override
+    public int hashCode() {","[{'comment': 'Remove', 'commenter': 'davsclaus'}, {'comment': 'Ok, done', 'commenter': 'ank19'}]"
6526,components/camel-milo/src/main/java/org/apache/camel/component/milo/browse/MiloBrowseProducer.java,"@@ -0,0 +1,138 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.milo.browse;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import java.util.Optional;
+import java.util.concurrent.CompletableFuture;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+import org.apache.camel.AsyncCallback;
+import org.apache.camel.Exchange;
+import org.apache.camel.Message;
+import org.apache.camel.component.milo.client.MiloClientConnection;
+import org.apache.camel.support.DefaultAsyncProducer;
+import org.eclipse.milo.opcua.stack.core.types.builtin.ExpandedNodeId;
+import org.eclipse.milo.opcua.stack.core.types.builtin.NodeId;
+import org.eclipse.milo.opcua.stack.core.types.structured.BrowseResult;
+import org.eclipse.milo.opcua.stack.core.types.structured.ReferenceDescription;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import static java.lang.Boolean.TRUE;
+import static org.apache.camel.component.milo.NodeIds.HEADER_NODE_IDS;
+
+public class MiloBrowseProducer extends DefaultAsyncProducer {
+
+    private static final Logger LOG = LoggerFactory.getLogger(MiloBrowseProducer.class);
+
+    private MiloClientConnection connection;
+
+    private final boolean defaultAwaitWrites;
+
+    public MiloBrowseProducer(final MiloBrowseEndpoint endpoint, final boolean defaultAwaitWrites) {
+        super(endpoint);
+
+        this.defaultAwaitWrites = defaultAwaitWrites;
+    }
+
+    @Override
+    public MiloBrowseEndpoint getEndpoint() {
+        return (MiloBrowseEndpoint) super.getEndpoint();
+    }
+
+    @Override
+    protected void doStart() throws Exception {
+        super.doStart();
+        this.connection = getEndpoint().createConnection();
+    }
+
+    @Override
+    protected void doStop() throws Exception {
+        if (null != this.connection) {
+            getEndpoint().releaseConnection(connection);
+        }
+        super.doStop();
+    }
+
+    private ExpandedNodeId tryParse(String nodeString) {
+        final Optional<NodeId> nodeId = NodeId.parseSafe(nodeString);
+        return nodeId.map(NodeId::expanded).orElseGet(() -> ExpandedNodeId.parse(nodeString));
+    }
+
+    @Override
+    public boolean process(Exchange exchange, AsyncCallback async) {
+
+        final Message message = exchange.getMessage();
+        final List<ExpandedNodeId> expandedNodeIds = new ArrayList<>();
+
+        if (message.getHeaders().containsKey(HEADER_NODE_IDS)) {
+
+            final List<?> nodes
+                    = message.getHeader(HEADER_NODE_IDS, Collections.singletonList(getEndpoint().getNode()), List.class);
+            message.removeHeader(HEADER_NODE_IDS);
+            if (null == nodes) {
+
+                return false;","[{'comment': 'this is wrong, you should\r\n\r\nasync.done(true)\r\nreturn true', 'commenter': 'davsclaus'}, {'comment': 'Ah, ok - I think I got it now. Hopefully, :-) I changed that.', 'commenter': 'ank19'}]"
6526,components/camel-milo/src/main/java/org/apache/camel/component/milo/browse/MiloBrowseProducer.java,"@@ -0,0 +1,138 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.milo.browse;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import java.util.Optional;
+import java.util.concurrent.CompletableFuture;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+import org.apache.camel.AsyncCallback;
+import org.apache.camel.Exchange;
+import org.apache.camel.Message;
+import org.apache.camel.component.milo.client.MiloClientConnection;
+import org.apache.camel.support.DefaultAsyncProducer;
+import org.eclipse.milo.opcua.stack.core.types.builtin.ExpandedNodeId;
+import org.eclipse.milo.opcua.stack.core.types.builtin.NodeId;
+import org.eclipse.milo.opcua.stack.core.types.structured.BrowseResult;
+import org.eclipse.milo.opcua.stack.core.types.structured.ReferenceDescription;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import static java.lang.Boolean.TRUE;
+import static org.apache.camel.component.milo.NodeIds.HEADER_NODE_IDS;
+
+public class MiloBrowseProducer extends DefaultAsyncProducer {
+
+    private static final Logger LOG = LoggerFactory.getLogger(MiloBrowseProducer.class);
+
+    private MiloClientConnection connection;
+
+    private final boolean defaultAwaitWrites;
+
+    public MiloBrowseProducer(final MiloBrowseEndpoint endpoint, final boolean defaultAwaitWrites) {
+        super(endpoint);
+
+        this.defaultAwaitWrites = defaultAwaitWrites;
+    }
+
+    @Override
+    public MiloBrowseEndpoint getEndpoint() {
+        return (MiloBrowseEndpoint) super.getEndpoint();
+    }
+
+    @Override
+    protected void doStart() throws Exception {
+        super.doStart();
+        this.connection = getEndpoint().createConnection();
+    }
+
+    @Override
+    protected void doStop() throws Exception {
+        if (null != this.connection) {
+            getEndpoint().releaseConnection(connection);
+        }
+        super.doStop();
+    }
+
+    private ExpandedNodeId tryParse(String nodeString) {
+        final Optional<NodeId> nodeId = NodeId.parseSafe(nodeString);
+        return nodeId.map(NodeId::expanded).orElseGet(() -> ExpandedNodeId.parse(nodeString));
+    }
+
+    @Override
+    public boolean process(Exchange exchange, AsyncCallback async) {
+
+        final Message message = exchange.getMessage();
+        final List<ExpandedNodeId> expandedNodeIds = new ArrayList<>();
+
+        if (message.getHeaders().containsKey(HEADER_NODE_IDS)) {
+
+            final List<?> nodes
+                    = message.getHeader(HEADER_NODE_IDS, Collections.singletonList(getEndpoint().getNode()), List.class);
+            message.removeHeader(HEADER_NODE_IDS);
+            if (null == nodes) {
+
+                return false;
+            }
+
+            for (final Object node : nodes) {
+                expandedNodeIds.add(tryParse(node.toString()));
+            }
+        } else {
+
+            expandedNodeIds.add(tryParse(this.getEndpoint().getNode()));
+        }
+
+        final MiloBrowseEndpoint endpoint = this.getEndpoint();
+        final int depth = endpoint.isRecursive() ? endpoint.getDepth() : -1;
+        final boolean subTypes = endpoint.isIncludeSubTypes() || endpoint.isRecursive();
+
+        final CompletableFuture<?> future = this.connection
+                .browse(expandedNodeIds, endpoint.getDirection(), endpoint.getNodeClassMask(), depth, endpoint.getFilter(),
+                        subTypes, endpoint.getMaxNodeIdsPerRequest())
+                .thenApply(browseResults -> {
+
+                    final List<String> expandedNodes = browseResults.values().stream()
+                            .map(BrowseResult::getReferences)
+                            .flatMap(Stream::of)
+                            .map(ReferenceDescription::getNodeId)
+                            .map(ExpandedNodeId::toParseableString)
+                            .collect(Collectors.toList());
+
+                    // For convenience, to be used with the milo-client producer
+                    exchange.getMessage().setHeader(HEADER_NODE_IDS, expandedNodes);
+
+                    exchange.getMessage().setBody(browseResults);
+
+                    return browseResults;
+                });
+
+        final Boolean await = message.getHeader(""await"", this.defaultAwaitWrites, Boolean.class);
+
+        if (TRUE.equals(await)) {
+            future.whenComplete((v, ex) -> async.done(false));
+            return false;
+        } else {
+            return true;","[{'comment': 'async.done(true)\r\nreturn true', 'commenter': 'davsclaus'}, {'comment': ""I changed that, too. The thing is that I copied that code part from the existing milo-client component (admittedly without thinking enough). By the way, the test cases for the existing milo-client didn't seem to work, running the whole camel build indicated that the tests run into a timeout situation, which did not fail the overall build. I created an additional commit to change that in milo-client, too, alongside with some outdated surefire settings, apparently. Applying your proposed changes to milo-client, too, seems to fix the test cases. Or do you need another issue/ pull request for that?"", 'commenter': 'ank19'}]"
6526,components/camel-milo/src/main/java/org/apache/camel/component/milo/browse/MiloBrowseProducer.java,"@@ -0,0 +1,138 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.milo.browse;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import java.util.Optional;
+import java.util.concurrent.CompletableFuture;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+import org.apache.camel.AsyncCallback;
+import org.apache.camel.Exchange;
+import org.apache.camel.Message;
+import org.apache.camel.component.milo.client.MiloClientConnection;
+import org.apache.camel.support.DefaultAsyncProducer;
+import org.eclipse.milo.opcua.stack.core.types.builtin.ExpandedNodeId;
+import org.eclipse.milo.opcua.stack.core.types.builtin.NodeId;
+import org.eclipse.milo.opcua.stack.core.types.structured.BrowseResult;
+import org.eclipse.milo.opcua.stack.core.types.structured.ReferenceDescription;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import static java.lang.Boolean.TRUE;
+import static org.apache.camel.component.milo.NodeIds.HEADER_NODE_IDS;
+
+public class MiloBrowseProducer extends DefaultAsyncProducer {
+
+    private static final Logger LOG = LoggerFactory.getLogger(MiloBrowseProducer.class);
+
+    private MiloClientConnection connection;
+
+    private final boolean defaultAwaitWrites;
+
+    public MiloBrowseProducer(final MiloBrowseEndpoint endpoint, final boolean defaultAwaitWrites) {
+        super(endpoint);
+
+        this.defaultAwaitWrites = defaultAwaitWrites;
+    }
+
+    @Override
+    public MiloBrowseEndpoint getEndpoint() {
+        return (MiloBrowseEndpoint) super.getEndpoint();
+    }
+
+    @Override
+    protected void doStart() throws Exception {
+        super.doStart();
+        this.connection = getEndpoint().createConnection();
+    }
+
+    @Override
+    protected void doStop() throws Exception {
+        if (null != this.connection) {
+            getEndpoint().releaseConnection(connection);
+        }
+        super.doStop();
+    }
+
+    private ExpandedNodeId tryParse(String nodeString) {
+        final Optional<NodeId> nodeId = NodeId.parseSafe(nodeString);
+        return nodeId.map(NodeId::expanded).orElseGet(() -> ExpandedNodeId.parse(nodeString));
+    }
+
+    @Override
+    public boolean process(Exchange exchange, AsyncCallback async) {
+
+        final Message message = exchange.getMessage();
+        final List<ExpandedNodeId> expandedNodeIds = new ArrayList<>();
+
+        if (message.getHeaders().containsKey(HEADER_NODE_IDS)) {
+
+            final List<?> nodes
+                    = message.getHeader(HEADER_NODE_IDS, Collections.singletonList(getEndpoint().getNode()), List.class);
+            message.removeHeader(HEADER_NODE_IDS);
+            if (null == nodes) {
+
+                return false;
+            }
+
+            for (final Object node : nodes) {
+                expandedNodeIds.add(tryParse(node.toString()));
+            }
+        } else {
+
+            expandedNodeIds.add(tryParse(this.getEndpoint().getNode()));
+        }
+
+        final MiloBrowseEndpoint endpoint = this.getEndpoint();
+        final int depth = endpoint.isRecursive() ? endpoint.getDepth() : -1;
+        final boolean subTypes = endpoint.isIncludeSubTypes() || endpoint.isRecursive();
+
+        final CompletableFuture<?> future = this.connection
+                .browse(expandedNodeIds, endpoint.getDirection(), endpoint.getNodeClassMask(), depth, endpoint.getFilter(),
+                        subTypes, endpoint.getMaxNodeIdsPerRequest())
+                .thenApply(browseResults -> {
+
+                    final List<String> expandedNodes = browseResults.values().stream()
+                            .map(BrowseResult::getReferences)
+                            .flatMap(Stream::of)
+                            .map(ReferenceDescription::getNodeId)
+                            .map(ExpandedNodeId::toParseableString)
+                            .collect(Collectors.toList());
+
+                    // For convenience, to be used with the milo-client producer
+                    exchange.getMessage().setHeader(HEADER_NODE_IDS, expandedNodes);
+
+                    exchange.getMessage().setBody(browseResults);
+
+                    return browseResults;
+                });
+
+        final Boolean await = message.getHeader(""await"", this.defaultAwaitWrites, Boolean.class);","[{'comment': 'This seems wrong that a header determines to wait for the future - what is the special use-case. We do not do this in other components, so please remove.', 'commenter': 'davsclaus'}, {'comment': ""Sorry, that's another left-over from the milo-client component, which I used as a template for the milo-browse component. I removed that in milo-browse, as that indeed doesn't make sense in case of the browsing functionality. I guess the intention of the original author of the milo-client might be to fake synchronous execution for writes, even though they are in fact executed asynchrously (in case of defaultAwaitWrites=false). Just my two cents..."", 'commenter': 'ank19'}]"
6526,components/camel-milo/src/main/java/org/apache/camel/component/milo/client/internal/SubscriptionManager.java,"@@ -368,6 +379,197 @@ public void dispose() {
                 return this.client.readValues(0, TimestampsToReturn.Server, nodeIds);
             });
         }
+
+        private BrowseResult filter(final BrowseResult browseResult, final Pattern pattern) {
+
+            final ReferenceDescription[] references = browseResult.getReferences();
+
+            if (null == references || null == pattern) {
+                return browseResult;
+            }
+
+            final List<ReferenceDescription> filteredReferences = new ArrayList<>();
+            for (final ReferenceDescription reference : references) {
+                final String id = reference.getNodeId().toParseableString();
+                if (!(pattern.matcher(id).matches())) {
+                    LOG.trace(""Node {} excluded by filter"", id);
+                    continue;
+                }
+                filteredReferences.add(reference);
+            }
+
+            return new BrowseResult(
+                    browseResult.getStatusCode(), browseResult.getContinuationPoint(),
+                    filteredReferences.toArray(new ReferenceDescription[0]));
+        }
+
+        private CompletableFuture<Map<ExpandedNodeId, BrowseResult>> flatten(
+                List<CompletableFuture<Map<ExpandedNodeId, BrowseResult>>> browseResults) {
+            return CompletableFuture.allOf(browseResults.toArray(new CompletableFuture[0]))
+                    .thenApply(__ -> browseResults
+                            .stream()
+                            .map(CompletableFuture::join)
+                            .map(Map::entrySet)
+                            .flatMap(Set::stream)
+                            .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue, (e1, e2) -> e2)));
+        }
+
+        // Browse at continuation point if any
+        public CompletableFuture<BrowseResult> browse(BrowseResult previousBrowseResult) {
+
+            final ByteString continuationPoint = previousBrowseResult.getContinuationPoint();
+
+            if (previousBrowseResult.getStatusCode().isGood() && continuationPoint.isNotNull()) {
+
+                return this.client.browseNext(false, continuationPoint)
+
+                        .thenCompose(browseResult -> {
+
+                            final ReferenceDescription[] previousReferences = previousBrowseResult.getReferences();
+                            final ReferenceDescription[] references = browseResult.getReferences();
+
+                            if (null == references) {
+
+                                LOG.info(""Browse continuation point -> no references"");
+                                return completedFuture(previousBrowseResult);
+                            } else if (null == previousReferences) {
+
+                                LOG.info(""Browse continuation point -> previous references not obtained"");
+                                return completedFuture(browseResult);
+                            }
+
+                            final ReferenceDescription[] combined
+                                    = Arrays.copyOf(previousReferences, previousReferences.length + references.length);
+                            System.arraycopy(references, 0, combined, previousReferences.length, references.length);
+
+                            LOG.debug(""Browse continuation point -> {}: {} reference(s); total: {} reference(s)"",
+                                    browseResult.getStatusCode(), references.length, combined.length);
+
+                            return browse(new BrowseResult(
+                                    browseResult.getStatusCode(), browseResult.getContinuationPoint(), combined));
+                        });
+
+            } else {
+
+                return completedFuture(previousBrowseResult);
+            }
+        }
+
+        // Browse a single node, retrieve additional results, filter node ids and eventually browse deeper into the tree
+        public CompletableFuture<Map<ExpandedNodeId, BrowseResult>> browse(
+                BrowseDescription browseDescription, BrowseResult browseResult, int depth, int maxDepth, Pattern pattern,
+                int maxNodesPerRequest) {
+
+            return browse(browseResult)
+
+                    .thenCompose(preliminary -> completedFuture(filter(preliminary, pattern)))
+
+                    .thenCompose(filtered -> {
+
+                        final ExpandedNodeId expandedNodeId = browseDescription.getNodeId().expanded();
+                        final Map<ExpandedNodeId, BrowseResult> root = Collections.singletonMap(expandedNodeId, filtered);
+                        final CompletableFuture<Map<ExpandedNodeId, BrowseResult>> finalFuture = completedFuture(root);
+                        final ReferenceDescription[] references = filtered.getReferences();
+
+                        if (depth >= maxDepth || null == references) {
+                            return finalFuture;
+                        }
+
+                        final List<CompletableFuture<Map<ExpandedNodeId, BrowseResult>>> futures = new ArrayList<>();
+
+                        // Save current node
+                        futures.add(finalFuture);
+
+                        final List<ExpandedNodeId> nodeIds = Stream.of(references)
+                                .map(ReferenceDescription::getNodeId).collect(Collectors.toList());
+
+                        final List<List<ExpandedNodeId>> lists = Lists.partition(nodeIds, maxNodesPerRequest);
+                        for (final List<ExpandedNodeId> list : lists) {
+                            futures.add(browse(list, browseDescription.getBrowseDirection(),
+                                    browseDescription.getNodeClassMask().intValue(), depth + 1, maxDepth, pattern,
+                                    browseDescription.getIncludeSubtypes(), maxNodesPerRequest));
+                        }
+
+                        return flatten(futures);
+                    });
+        }
+
+        // Browse according to a list of browse descriptions
+        public CompletableFuture<Map<ExpandedNodeId, BrowseResult>> browse(
+                List<BrowseDescription> browseDescriptions,
+                int depth, int maxDepth, Pattern pattern, int maxNodesPerRequest) {
+
+            return this.client.browse(browseDescriptions)
+
+                    .thenCompose(partials -> {
+
+                        // Fail a bit more gracefully in case of missing results
+                        if (partials.size() != browseDescriptions.size()) {
+
+                            // @TODO: Replace with Java 9 functionality","[{'comment': 'Camel 3.15 will drop java 8, so when we are ready then do this', 'commenter': 'davsclaus'}, {'comment': 'Added the Java 9 code as a comment as prep.', 'commenter': 'ank19'}]"
6526,components/camel-milo/src/main/java/org/apache/camel/component/milo/client/internal/SubscriptionManager.java,"@@ -368,6 +379,197 @@ public void dispose() {
                 return this.client.readValues(0, TimestampsToReturn.Server, nodeIds);
             });
         }
+
+        private BrowseResult filter(final BrowseResult browseResult, final Pattern pattern) {
+
+            final ReferenceDescription[] references = browseResult.getReferences();
+
+            if (null == references || null == pattern) {
+                return browseResult;
+            }
+
+            final List<ReferenceDescription> filteredReferences = new ArrayList<>();
+            for (final ReferenceDescription reference : references) {
+                final String id = reference.getNodeId().toParseableString();
+                if (!(pattern.matcher(id).matches())) {
+                    LOG.trace(""Node {} excluded by filter"", id);
+                    continue;
+                }
+                filteredReferences.add(reference);
+            }
+
+            return new BrowseResult(
+                    browseResult.getStatusCode(), browseResult.getContinuationPoint(),
+                    filteredReferences.toArray(new ReferenceDescription[0]));
+        }
+
+        private CompletableFuture<Map<ExpandedNodeId, BrowseResult>> flatten(
+                List<CompletableFuture<Map<ExpandedNodeId, BrowseResult>>> browseResults) {
+            return CompletableFuture.allOf(browseResults.toArray(new CompletableFuture[0]))
+                    .thenApply(__ -> browseResults
+                            .stream()
+                            .map(CompletableFuture::join)
+                            .map(Map::entrySet)
+                            .flatMap(Set::stream)
+                            .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue, (e1, e2) -> e2)));
+        }
+
+        // Browse at continuation point if any
+        public CompletableFuture<BrowseResult> browse(BrowseResult previousBrowseResult) {
+
+            final ByteString continuationPoint = previousBrowseResult.getContinuationPoint();
+
+            if (previousBrowseResult.getStatusCode().isGood() && continuationPoint.isNotNull()) {
+
+                return this.client.browseNext(false, continuationPoint)
+
+                        .thenCompose(browseResult -> {
+
+                            final ReferenceDescription[] previousReferences = previousBrowseResult.getReferences();
+                            final ReferenceDescription[] references = browseResult.getReferences();
+
+                            if (null == references) {
+
+                                LOG.info(""Browse continuation point -> no references"");
+                                return completedFuture(previousBrowseResult);
+                            } else if (null == previousReferences) {
+
+                                LOG.info(""Browse continuation point -> previous references not obtained"");
+                                return completedFuture(browseResult);
+                            }
+
+                            final ReferenceDescription[] combined
+                                    = Arrays.copyOf(previousReferences, previousReferences.length + references.length);
+                            System.arraycopy(references, 0, combined, previousReferences.length, references.length);
+
+                            LOG.debug(""Browse continuation point -> {}: {} reference(s); total: {} reference(s)"",
+                                    browseResult.getStatusCode(), references.length, combined.length);
+
+                            return browse(new BrowseResult(
+                                    browseResult.getStatusCode(), browseResult.getContinuationPoint(), combined));
+                        });
+
+            } else {
+
+                return completedFuture(previousBrowseResult);
+            }
+        }
+
+        // Browse a single node, retrieve additional results, filter node ids and eventually browse deeper into the tree
+        public CompletableFuture<Map<ExpandedNodeId, BrowseResult>> browse(
+                BrowseDescription browseDescription, BrowseResult browseResult, int depth, int maxDepth, Pattern pattern,
+                int maxNodesPerRequest) {
+
+            return browse(browseResult)
+
+                    .thenCompose(preliminary -> completedFuture(filter(preliminary, pattern)))
+
+                    .thenCompose(filtered -> {
+
+                        final ExpandedNodeId expandedNodeId = browseDescription.getNodeId().expanded();
+                        final Map<ExpandedNodeId, BrowseResult> root = Collections.singletonMap(expandedNodeId, filtered);
+                        final CompletableFuture<Map<ExpandedNodeId, BrowseResult>> finalFuture = completedFuture(root);
+                        final ReferenceDescription[] references = filtered.getReferences();
+
+                        if (depth >= maxDepth || null == references) {
+                            return finalFuture;
+                        }
+
+                        final List<CompletableFuture<Map<ExpandedNodeId, BrowseResult>>> futures = new ArrayList<>();
+
+                        // Save current node
+                        futures.add(finalFuture);
+
+                        final List<ExpandedNodeId> nodeIds = Stream.of(references)
+                                .map(ReferenceDescription::getNodeId).collect(Collectors.toList());
+
+                        final List<List<ExpandedNodeId>> lists = Lists.partition(nodeIds, maxNodesPerRequest);
+                        for (final List<ExpandedNodeId> list : lists) {
+                            futures.add(browse(list, browseDescription.getBrowseDirection(),
+                                    browseDescription.getNodeClassMask().intValue(), depth + 1, maxDepth, pattern,
+                                    browseDescription.getIncludeSubtypes(), maxNodesPerRequest));
+                        }
+
+                        return flatten(futures);
+                    });
+        }
+
+        // Browse according to a list of browse descriptions
+        public CompletableFuture<Map<ExpandedNodeId, BrowseResult>> browse(
+                List<BrowseDescription> browseDescriptions,
+                int depth, int maxDepth, Pattern pattern, int maxNodesPerRequest) {
+
+            return this.client.browse(browseDescriptions)
+
+                    .thenCompose(partials -> {
+
+                        // Fail a bit more gracefully in case of missing results
+                        if (partials.size() != browseDescriptions.size()) {
+
+                            // @TODO: Replace with Java 9 functionality
+                            final CompletableFuture<Map<ExpandedNodeId, BrowseResult>> failedFuture = new CompletableFuture<>();
+                            failedFuture.completeExceptionally(new IllegalArgumentException(
+                                    format(
+                                            ""Invalid number of browse results: %s, expected %s"", partials.size(),
+                                            browseDescriptions.size())));
+                            return failedFuture;
+                        }
+
+                        final List<CompletableFuture<Map<ExpandedNodeId, BrowseResult>>> futures = new ArrayList<>();
+
+                        for (int i = 0; i < partials.size(); i++) {
+
+                            futures.add(browse(browseDescriptions.get(i), partials.get(i), depth, maxDepth, pattern,
+                                    maxNodesPerRequest));
+                        }
+
+                        return flatten(futures);
+                    });
+        }
+
+        // Wrapper for looking up nodes and instantiating initial browse descriptions according to the configuration provided
+        @SuppressWarnings(""unchecked"")
+        public CompletableFuture<Map<ExpandedNodeId, BrowseResult>> browse(
+                List<ExpandedNodeId> expandedNodeIds, BrowseDirection direction, int nodeClasses, int depth, int maxDepth,
+                Pattern pattern, boolean includeSubTypes, int maxNodesPerRequest) {
+
+            final CompletableFuture<NodeId>[] futures = expandedNodeIds.stream().map(this::lookupNamespace)
+                    .toArray(CompletableFuture[]::new);
+
+            return CompletableFuture.allOf(futures)
+
+                    .thenCompose(__ -> {
+
+                        List<NodeId> nodeIds = Stream.of(futures).map(CompletableFuture::join)
+                                .collect(Collectors.toList());
+
+                        return completedFuture(nodeIds.stream().map(nodeId -> new BrowseDescription(
+                                nodeId, direction, Identifiers.References, includeSubTypes, uint(nodeClasses),
+                                uint(BrowseResultMask.All.getValue()))).collect(Collectors.toList()));
+                    })
+
+                    .thenCompose(descriptions -> browse(descriptions, depth, maxDepth, pattern, maxNodesPerRequest))
+
+                    .whenComplete((actual, error) -> {
+
+                        if (!LOG.isErrorEnabled()) {
+
+                            return;
+                        }
+
+                        final String expandedNodeIdsString = expandedNodeIds.stream()
+                                .map(ExpandedNodeId::toParseableString)
+                                .collect(Collectors.joining("", ""));
+
+                        if (actual != null) {
+                            LOG.debug(""Browse node(s) {} -> {} result(s)"", expandedNodeIdsString, actual.size());
+
+                        } else {
+                            LOG.error(""Browse node(s) {} -> failed: {}"", expandedNodeIdsString, error);","[{'comment': 'Can we do something else than just log an error? Set an exception on the exchange as a result that this failed', 'commenter': 'davsclaus'}, {'comment': 'Yes, makes sense, of course. I changed that - moved it to the producer, that reduces the complexity in the SubscriptionManager class, too.', 'commenter': 'ank19'}]"
6526,components/camel-milo/src/test/java/org/apache/camel/component/milo/AbstractMiloServerTest.java,"@@ -153,4 +156,18 @@ boolean isJavaVersionSatisfied(int requiredVersion) {
         return false;
     }
 
+    protected Predicate assertPredicate(Consumer<Exchange> consumer) {
+
+        return exchange -> {
+            try {
+                consumer.accept(exchange);
+                return true;
+            } catch (AssertionFailedError error) {
+                System.err.println(""Assertion error: "" + error.getMessage());
+                error.printStackTrace(System.err);","[{'comment': 'use logger instead of system out', 'commenter': 'davsclaus'}, {'comment': 'Done', 'commenter': 'ank19'}]"
6535,core/camel-management/pom.xml,"@@ -85,6 +85,13 @@
             <artifactId>log4j-slf4j-impl</artifactId>
             <scope>test</scope>
         </dependency>
+        <dependency>","[{'comment': 'We do NOT want this dependency', 'commenter': 'davsclaus'}, {'comment': 'I need this dependency to test if the result is Serializable. I understand your point about debugger being used by many different tools, perhaps we need another method which evaluates an expression and converts it to String?\r\n', 'commenter': 'javaduke'}, {'comment': 'We cannot use 3rd party dependency in the core, you need to remove it.\r\n\r\nI sugget you make this into more PRs where you first work on this that can be accepted, and then later the seriization stuff.\r\n\r\n', 'commenter': 'davsclaus'}, {'comment': ""No problem, I actually figured out how to check if the object is serializable without using third party library, it's gone now."", 'commenter': 'javaduke'}]"
6535,core/camel-management-api/pom.xml,"@@ -43,7 +43,10 @@
             <groupId>org.slf4j</groupId>
             <artifactId>slf4j-api</artifactId>
         </dependency>
-
+        <dependency>","[{'comment': 'Remove this added dependency', 'commenter': 'davsclaus'}, {'comment': 'Sorry, looks like it was added automatically by IntelliJ. I removed it.', 'commenter': 'javaduke'}]"
6535,core/camel-management/src/main/java/org/apache/camel/management/mbean/ManagedBacklogDebugger.java,"@@ -274,4 +283,77 @@ public long getFallbackTimeout() {
     public void setFallbackTimeout(long fallbackTimeout) {
         backlogDebugger.setFallbackTimeout(fallbackTimeout);
     }
+
+    @Override
+    public String dumpExchangePropertiesAsXml(String id) {
+        StringBuilder sb = new StringBuilder();
+        sb.append(""<properties>"");
+        Exchange suspendedExchange = backlogDebugger.getSuspendedExchange(id);
+        if (suspendedExchange != null) {
+            Map<String, Object> properties = suspendedExchange.getAllProperties();
+            properties.forEach((propertyName, propertyValue) -> {
+                String type = ObjectHelper.classCanonicalName(propertyValue);
+                sb.append(""<property name=\"""").append(propertyName).append(""\"""");
+                if (type != null) {
+                    sb.append("" type=\"""").append(type).append(""\"""");
+                }
+                sb.append("">"");
+                // dump property value as XML, use Camel type converter to convert
+                // to String
+                if (propertyValue != null) {
+                    try {
+                        String xml = suspendedExchange.getContext().getTypeConverter().tryConvertTo(String.class,
+                                suspendedExchange, propertyValue);
+                        if (xml != null) {
+                            // must always xml encode
+                            sb.append(StringHelper.xmlEncode(xml));
+                        }
+                    } catch (Throwable e) {
+                        // ignore as the body is for logging purpose
+                    }
+                }
+                sb.append(""</property>\n"");
+            });
+        }
+        sb.append(""</properties>"");
+        return sb.toString();
+    }
+
+    @Override
+    public String evaluateExpressionAtBreakpoint(String id, String language, String expression) {
+        return evaluateExpressionAtBreakpoint(id, language, expression, ""java.lang.String"").toString();
+    }
+
+    @Override
+    public Object evaluateExpressionAtBreakpoint(String id, String language, String expression, String resultType) {
+        Exchange suspendedExchange = null;
+        try {
+            Language lan = camelContext.resolveLanguage(language);
+            suspendedExchange = backlogDebugger.getSuspendedExchange(id);
+            if (suspendedExchange != null) {
+                Object result = null;
+                Class resultClass = Class.forName(resultType);","[{'comment': 'You cannot use this class loading, Camel has a ClassResolver API via CamelContext that must be used.\r\nhttps://github.com/apache/camel/blob/main/core/camel-api/src/main/java/org/apache/camel/spi/ClassResolver.java', 'commenter': 'davsclaus'}, {'comment': 'thanks, fixed!', 'commenter': 'javaduke'}]"
6583,dsl/camel-jbang/camel-jbang-core/src/main/java/org/apache/camel/dsl/jbang/core/commands/CreateProject.java,"@@ -0,0 +1,100 @@
+package org.apache.camel.dsl.jbang.core.commands;","[{'comment': 'Missing license', 'commenter': 'oscerd'}]"
6583,dsl/camel-jbang/camel-jbang-core/src/main/java/org/apache/camel/dsl/jbang/core/generator/CamelJbangGenerator.java,"@@ -0,0 +1,10 @@
+package org.apache.camel.dsl.jbang.core.generator;","[{'comment': 'License', 'commenter': 'oscerd'}]"
6583,dsl/camel-jbang/camel-jbang-core/src/main/java/org/apache/camel/dsl/jbang/core/generator/QuarkusGenerator.java,"@@ -0,0 +1,22 @@
+package org.apache.camel.dsl.jbang.core.generator;","[{'comment': 'License', 'commenter': 'oscerd'}]"
6583,dsl/camel-jbang/camel-jbang-core/src/main/resources/generator/quarkus-pom.ftl,"@@ -0,0 +1,270 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--
+    Licensed to the Apache Software Foundation (ASF) under one or more
+    contributor license agreements.  See the NOTICE file distributed with
+    this work for additional information regarding copyright ownership.
+    The ASF licenses this file to You under the Apache License, Version 2.0
+    (the ""License""); you may not use this file except in compliance with
+    the License.  You may obtain a copy of the License at
+         http://www.apache.org/licenses/LICENSE-2.0
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an ""AS IS"" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"">
+	<modelVersion>4.0.0</modelVersion>
+
+	<artifactId>${name}</artifactId>
+	<groupId>org.apache.camel.jbang</groupId>","[{'comment': 'I think you should be able to configure the groupId also', 'commenter': 'davsclaus'}]"
6583,dsl/camel-jbang/camel-jbang-core/src/main/resources/generator/quarkus-pom.ftl,"@@ -0,0 +1,270 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--","[{'comment': 'We should not include ASF license in the generated project code, as end users can use this for their own projects that is not ASF licensed', 'commenter': 'davsclaus'}]"
6583,dsl/camel-jbang/camel-jbang-core/src/main/java/org/apache/camel/dsl/jbang/core/commands/CreateProject.java,"@@ -0,0 +1,152 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.dsl.jbang.core.commands;
+
+import java.io.File;
+import java.io.FileWriter;
+import java.io.IOException;
+import java.io.Writer;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.Paths;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Objects;
+import java.util.concurrent.Callable;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+import freemarker.template.Configuration;
+import freemarker.template.Template;
+import freemarker.template.TemplateException;
+import freemarker.template.TemplateExceptionHandler;
+import org.apache.camel.dsl.jbang.core.generator.CamelJbangGenerator;
+import org.apache.camel.dsl.jbang.core.generator.QuarkusGenerator;
+import picocli.CommandLine;
+
+@CommandLine.Command(name = ""create-project"", description = ""Creates Camel-Quarkus project"")
+public class CreateProject implements Callable<Integer> {
+
+    private static final String PACKAGE_REGEX = ""package\\s+([a-zA_Z_][\\.\\w]*);"";
+    private static final Pattern PACKAGE_PATTERN = Pattern.compile(PACKAGE_REGEX);
+    //CHECKSTYLE:ON
+    @CommandLine.Parameters(description = ""The Camel file(s) to run"", arity = ""1"")","[{'comment': 'to run -> to include in the created project', 'commenter': 'davsclaus'}]"
6583,dsl/camel-jbang/camel-jbang-core/src/main/java/org/apache/camel/dsl/jbang/core/commands/CamelJBangMain.java,"@@ -29,6 +29,7 @@
     public static void run(String... args) {
         commandLine = new CommandLine(new CamelJBangMain())
                 .addSubcommand(""run"", new Run())
+                .addSubcommand(""create-project"", new CreateProject())","[{'comment': 'I think it would be better to use two sub-commands so that we maintain the same pattern. I mean, it would be better to use `create project`. Look at how we do for the `init kamelet` feature.', 'commenter': 'orpiske'}, {'comment': 'Thanks for the review, I made the requested changes and the project can be created with\r\n```\r\njbang -Dcamel.jbang.version=3.15.0-SNAPSHOT CamelJBang@apache/camel create project TimerRoute.java test.yaml --quarkus-dependency=camel-quarkus-timer,camel-quarkus-log,camel-quarkus-yaml-dsl,camel-quarkus-http --name=TestProject\r\n```\r\nhelp output from create command is\r\n```\r\n➜ jbang -Dcamel.jbang.version=3.15.0-SNAPSHOT CamelJBang@apache/camel create -h\r\n[jbang] Building jar...\r\nUsage: CamelJBang create [-h] [COMMAND]\r\nCreates Maven Project (use --help)\r\n  -h, --help   Display the help and sub-commands\r\nCommands:\r\n  project  Creates Camel-Quarkus project\r\n  ```', 'commenter': 'Croway'}]"
6583,dsl/camel-jbang/camel-jbang-core/src/main/java/org/apache/camel/dsl/jbang/core/commands/Project.java,"@@ -0,0 +1,160 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.dsl.jbang.core.commands;
+
+import java.io.File;
+import java.io.FileWriter;
+import java.io.IOException;
+import java.io.Writer;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.Paths;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Objects;
+import java.util.concurrent.Callable;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+import freemarker.template.Configuration;
+import freemarker.template.Template;
+import freemarker.template.TemplateException;
+import freemarker.template.TemplateExceptionHandler;
+import org.apache.camel.dsl.jbang.core.generator.CamelJbangGenerator;
+import org.apache.camel.dsl.jbang.core.generator.QuarkusGenerator;
+import picocli.CommandLine;
+
+@CommandLine.Command(name = ""create-project"", description = ""Creates Camel-Quarkus project"")
+public class Project implements Callable<Integer> {
+
+    private static final String PACKAGE_REGEX = ""package\\s+([a-zA_Z_][\\.\\w]*);"";
+    private static final Pattern PACKAGE_PATTERN = Pattern.compile(PACKAGE_REGEX);
+    @CommandLine.Parameters(description = ""The Camel file(s) to include in the created project"", arity = ""1"")
+    private String[] files;
+    @CommandLine.Option(names = { ""-h"", ""--help"" }, usageHelp = true, description = ""Display the help and sub-commands"")
+    private boolean helpRequested;
+    @CommandLine.Option(names = { ""-n"", ""--name"" }, description = ""The name of the Camel application"",
+                        defaultValue = ""CamelJBang"")
+    private String name;
+    @CommandLine.Option(names = { ""-g"", ""--group-id"" }, description = ""The group ID of the maven project"",
+                        defaultValue = ""org.apache.camel.jbang"")
+    private String groupId;
+    @CommandLine.Option(names = { ""-d"", ""--directory"" }, description = ""Directory where the project will be created"",
+                        defaultValue = ""."")
+    private String baseDirectory;
+    @CommandLine.Option(names = ""--quarkus-dependency"", description = ""Comma separated list of camel-quarkus dependencies"",
+                        defaultValue = ""camel-quarkus-timer,camel-quarkus-log,camel-quarkus-yaml-dsl,camel-quarkus-kamelet,org.apache.camel.kamelets:camel-kamelets-catalog:0.5.0"")
+    private String quarkusDependencies;
+    @CommandLine.Option(names = ""--quarkus-bom-version"", description = ""Override quarkus bom version in pom.xml"",
+                        defaultValue = ""2.5.0.Final"")","[{'comment': 'Use 2.6.0.Final', 'commenter': 'davsclaus'}]"
6583,dsl/camel-jbang/camel-jbang-core/src/main/java/org/apache/camel/dsl/jbang/core/commands/Project.java,"@@ -0,0 +1,160 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.dsl.jbang.core.commands;
+
+import java.io.File;
+import java.io.FileWriter;
+import java.io.IOException;
+import java.io.Writer;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.Paths;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Objects;
+import java.util.concurrent.Callable;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+import freemarker.template.Configuration;
+import freemarker.template.Template;
+import freemarker.template.TemplateException;
+import freemarker.template.TemplateExceptionHandler;
+import org.apache.camel.dsl.jbang.core.generator.CamelJbangGenerator;
+import org.apache.camel.dsl.jbang.core.generator.QuarkusGenerator;
+import picocli.CommandLine;
+
+@CommandLine.Command(name = ""create-project"", description = ""Creates Camel-Quarkus project"")
+public class Project implements Callable<Integer> {
+
+    private static final String PACKAGE_REGEX = ""package\\s+([a-zA_Z_][\\.\\w]*);"";
+    private static final Pattern PACKAGE_PATTERN = Pattern.compile(PACKAGE_REGEX);
+    @CommandLine.Parameters(description = ""The Camel file(s) to include in the created project"", arity = ""1"")
+    private String[] files;
+    @CommandLine.Option(names = { ""-h"", ""--help"" }, usageHelp = true, description = ""Display the help and sub-commands"")
+    private boolean helpRequested;
+    @CommandLine.Option(names = { ""-n"", ""--name"" }, description = ""The name of the Camel application"",
+                        defaultValue = ""CamelJBang"")
+    private String name;
+    @CommandLine.Option(names = { ""-g"", ""--group-id"" }, description = ""The group ID of the maven project"",
+                        defaultValue = ""org.apache.camel.jbang"")
+    private String groupId;
+    @CommandLine.Option(names = { ""-d"", ""--directory"" }, description = ""Directory where the project will be created"",
+                        defaultValue = ""."")
+    private String baseDirectory;
+    @CommandLine.Option(names = ""--quarkus-dependency"", description = ""Comma separated list of camel-quarkus dependencies"",
+                        defaultValue = ""camel-quarkus-timer,camel-quarkus-log,camel-quarkus-yaml-dsl,camel-quarkus-kamelet,org.apache.camel.kamelets:camel-kamelets-catalog:0.5.0"")","[{'comment': 'We upgraded to kamelet 0.6.0', 'commenter': 'davsclaus'}]"
6705,components/camel-cdi-jta/src/main/java/org/apache/camel/cdi/transaction/TransactionalJtaTransactionPolicy.java,"@@ -47,6 +52,13 @@
             ""java:pm/TransactionManager"",
             ""java:/TransactionManager""
     };
+    private static final String[] METHODS = new String[] {
+            ""org.openejb.OpenEJB.getTransactionManager"",
+            ""com.arjuna.jta.JTA_TransactionManager.transactionManager"",","[{'comment': 'It should be ""com.arjuna.ats.jta.TransactionManager.transactionManager"" for narayana.', 'commenter': 'zhfeng'}, {'comment': 'Fixed', 'commenter': 'rmannibucau'}]"
6705,components/camel-cdi-jta/src/main/java/org/apache/camel/cdi/transaction/TransactionalJtaTransactionPolicy.java,"@@ -81,6 +94,30 @@ private TransactionManager lookupTransactionManager() {
                 LOG.debug(""No JTA TransactionManager found at JNDI location [{}]"", jndiName, ex);
             }
         }
+        var loaders = Stream.of(Thread.currentThread().getContextClassLoader(), getClass().getClassLoader())
+                .filter(Objects::nonNull)
+                .distinct()
+                .collect(toList());
+        for (String method : METHODS) {
+            final int sep = method.lastIndexOf('.');
+            try {
+                Class<?> clazz = null;
+                for (final var loader : loaders) {
+                    try {
+                        clazz = loader.loadClass(method.substring(0, sep));
+                    } catch (final NoClassDefFoundError | ClassNotFoundException cnfe) {
+                        // continue
+                    }
+                }
+                if (clazz != null) {
+                    final var getter = clazz.getDeclaredMethod(method.substring(sep + 1));
+                    getter.setAccessible(true);
+                    return (TransactionManager) getter.invoke(null);","[{'comment': 'It could be better to check the result is not **null**.', 'commenter': 'zhfeng'}]"
6705,components/camel-cdi-jta/src/main/java/org/apache/camel/cdi/transaction/TransactionalJtaTransactionPolicy.java,"@@ -81,6 +94,33 @@ private TransactionManager lookupTransactionManager() {
                 LOG.debug(""No JTA TransactionManager found at JNDI location [{}]"", jndiName, ex);
             }
         }
+        var loaders = Stream.of(Thread.currentThread().getContextClassLoader(), getClass().getClassLoader())
+                .filter(Objects::nonNull)
+                .distinct()
+                .collect(toList());
+        for (String method : METHODS) {
+            final int sep = method.lastIndexOf('.');
+            try {
+                Class<?> clazz = null;
+                for (final var loader : loaders) {
+                    try {
+                        clazz = loader.loadClass(method.substring(0, sep));
+                    } catch (final NoClassDefFoundError | ClassNotFoundException cnfe) {
+                        // continue
+                    }
+                }
+                if (clazz != null) {
+                    final var getter = clazz.getDeclaredMethod(method.substring(sep + 1));
+                    getter.setAccessible(true);
+                    final var txMgr = (TransactionManager) getter.invoke(null);
+                    if (txMgr != null) {
+                        return txMgr;
+                    }
+                }
+            } catch (final Throwable t) {","[{'comment': ""I'd probably avoid caching Throwable, as it can catch serious JVM-raised errors like OutOfMemoryError and StackOverFlowError. "", 'commenter': 'orpiske'}]"
6705,components/camel-cdi-jta/src/main/java/org/apache/camel/cdi/transaction/TransactionalJtaTransactionPolicy.java,"@@ -47,6 +52,13 @@
             ""java:pm/TransactionManager"",
             ""java:/TransactionManager""
     };
+    private static final String[] METHODS = new String[] {
+            ""org.openejb.OpenEJB.getTransactionManager"",
+            ""com.arjuna.jta.TransactionManager.transactionManager"",","[{'comment': 'It should be ```com.arjuna.ats.jta.TransactionManager.transactionManager```\r\n', 'commenter': 'zhfeng'}]"
6726,components/camel-google/camel-google-mail/pom.xml,"@@ -83,6 +85,11 @@
             <artifactId>google-api-services-gmail</artifactId>
             <version>${google-api-services-mail-version}</version>
         </dependency>
+        <dependency>","[{'comment': 'What is using guava?', 'commenter': 'davsclaus'}, {'comment': 'com.google.http-client:google-api-client:1.39.2 (his [pom.xml](https://github.com/googleapis/google-http-java-client/blob/v1.39.2/google-http-client/pom.xml#L135))\r\nWith guava ver. 19.0 we have an error\r\n<summary>Caused by: java.lang.NoSuchMethodError: com.google.common.io.ByteStreams.exhaust(Ljava/io/InputStream;)J</summary>\r\n<details>\r\nCaused by: java.lang.NoSuchMethodError: com.google.common.io.ByteStreams.exhaust(Ljava/io/InputStream;)J\r\n        at com.google.api.client.http.ConsumingInputStream.close(ConsumingInputStream.java:40)\r\n        at java.base/java.util.zip.InflaterInputStream.close(InflaterInputStream.java:232)\r\n        at java.base/java.util.zip.GZIPInputStream.close(GZIPInputStream.java:137)\r\n        at java.base/sun.nio.cs.StreamDecoder.implClose(StreamDecoder.java:378)\r\n        at java.base/sun.nio.cs.StreamDecoder.close(StreamDecoder.java:193)\r\n        at java.base/java.io.InputStreamReader.close(InputStreamReader.java:200)\r\n        at com.google.gson.stream.JsonReader.close(JsonReader.java:1220)\r\n        at com.google.api.client.json.gson.GsonParser.close(GsonParser.java:53)\r\n        at com.google.api.client.json.JsonParser.parse(JsonParser.java:363)\r\n        at com.google.api.client.json.JsonParser.parse(JsonParser.java:335)\r\n        at com.google.api.client.json.JsonObjectParser.parseAndClose(JsonObjectParser.java:79)\r\n        at com.google.api.client.json.JsonObjectParser.parseAndClose(JsonObjectParser.java:73)\r\n        at com.google.api.client.http.HttpResponse.parseAs(HttpResponse.java:456)\r\n        at com.google.api.client.auth.oauth2.TokenRequest.execute(TokenRequest.java:324)\r\n        at com.google.api.client.googleapis.auth.oauth2.GoogleCredential.executeRefreshToken(GoogleCredential.java:384)\r\n        at com.google.api.client.auth.oauth2.Credential.refreshToken(Credential.java:470)\r\n        at org.apache.camel.component.google.mail.BatchGoogleMailClientFactory.authorizeServiceAccount(BatchGoogleMailClientFactory.java:89)\r\n        at org.apache.camel.component.google.mail.BatchGoogleMailClientFactory.makeClient(BatchGoogleMailClientFactory.java:76)\r\n        at org.apache.camel.component.google.mail.GoogleMailComponent.getClient(GoogleMailComponent.java:62)\r\n        at org.apache.camel.component.google.mail.GoogleMailEndpoint.getClient(GoogleMailEndpoint.java:117)\r\n        at org.apache.camel.component.google.mail.GoogleMailEndpoint.afterConfigureProperties(GoogleMailEndpoint.java:103)\r\n        at org.apache.camel.support.component.AbstractApiEndpoint.configureProperties(AbstractApiEndpoint.java:138)\r\n        at org.apache.camel.support.DefaultComponent.setProperties(DefaultComponent.java:425)\r\n        at org.apache.camel.support.component.AbstractApiComponent.createEndpoint(AbstractApiComponent.java:90)\r\n        at org.apache.camel.support.DefaultComponent.createEndpoint(DefaultComponent.java:171)\r\n        at org.apache.camel.impl.engine.AbstractCamelContext.doGetEndpoint(AbstractCamelContext.java:934)\r\n        at org.apache.camel.impl.engine.AbstractCamelContext.getEndpoint(AbstractCamelContext.java:850)\r\n</details>', 'commenter': 'bvfalcon'}, {'comment': 'Ah okay there is a \r\n\r\ngoogle-mail-guava-version in parent/pom.xml that was previously in use. Can you update that to 20, and use this placeholder', 'commenter': 'davsclaus'}, {'comment': '+1', 'commenter': 'oscerd'}]"
6726,components/camel-google/camel-google-mail/pom.xml,"@@ -38,6 +38,8 @@
         <componentPackage>org.apache.camel.component.google.mail</componentPackage>
         <outPackage>org.apache.camel.component.google.mail.internal</outPackage>
         <camel.osgi.private.pkg>org.apache.camel.component.google.mail.internal</camel.osgi.private.pkg>
+        <google-api-client-version>1.32.1</google-api-client-version>","[{'comment': 'This needs to be parent/pom', 'commenter': 'oscerd'}]"
6726,components/camel-google/camel-google-mail/pom.xml,"@@ -38,6 +38,8 @@
         <componentPackage>org.apache.camel.component.google.mail</componentPackage>
         <outPackage>org.apache.camel.component.google.mail.internal</outPackage>
         <camel.osgi.private.pkg>org.apache.camel.component.google.mail.internal</camel.osgi.private.pkg>
+        <google-api-client-version>1.32.1</google-api-client-version>
+        <google-api-services-mail-version>v1-rev20211108-1.32.1</google-api-services-mail-version>","[{'comment': 'This needs to be parent/pom', 'commenter': 'oscerd'}]"
6726,components/camel-google/camel-google-mail/src/main/java/org/apache/camel/component/google/mail/GoogleMailConfiguration.java,"@@ -124,4 +133,38 @@ public void setApplicationName(String applicationName) {
         this.applicationName = applicationName;
     }
 
+    public String getFilename() {
+        return filename;
+    }
+
+    /**
+     * Filename ""*.json"" with credentials for Service account
+     */
+    public void setFilename(String filename) {","[{'comment': 'This filename option should use the usual approach we have in other component so it should be resolved from classpath, file, http etc. You have multiple examples in the codebase', 'commenter': 'oscerd'}, {'comment': 'Yes, really.\r\nReplaced ""filename"" parameter with ""keyResource"". As example I use ""certResource"" in [SSH Component](https://camel.apache.org/components/next/ssh-component.html).', 'commenter': 'bvfalcon'}, {'comment': ""The keyResource needs to be read through resourceHelper while passing the variable to the makeClient, it should something like https://github.com/apache/camel/blob/main/components/camel-google/camel-google-functions/src/main/java/org/apache/camel/component/google/functions/GoogleCloudFunctionsClientFactory.java#L43\r\n\r\nor something like resourceUri in https://camel.apache.org/components/3.14.x/mustache-component.html or any other templating component. I don't know what the makeClient expect, but I suppose this would be a much more complete a flexible approach than passing a string."", 'commenter': 'oscerd'}, {'comment': '> what the makeClient expect\r\n\r\nmakeClient , exactly _com.google.api.client.googleapis.auth.oauth2.GoogleCredential.fromStream(InputStream)_ makes good job with InputStream: he parses it and [**closes** it](https://github.com/googleapis/google-api-java-client/blob/main/google-api-client/src/main/java/com/google/api/client/googleapis/auth/oauth2/GoogleCredential.java#L231). This is the reason, why we transform String into InputStream jst here: in another place we must close/cutch errors self.\r\nI would prefer stay InputStream processing as it is now, but of course if you think it is not a strong argument, I make it the way you proposed', 'commenter': 'bvfalcon'}, {'comment': ""I didn't notice the makeClient implementation in the batch client. It is absolutely correct."", 'commenter': 'oscerd'}]"
6726,components/camel-google/camel-google-mail/src/main/java/org/apache/camel/component/google/mail/BatchGoogleMailClientFactory.java,"@@ -1,65 +1,99 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the ""License""); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.camel.component.google.mail;
-
-import com.google.api.client.auth.oauth2.Credential;
-import com.google.api.client.googleapis.auth.oauth2.GoogleCredential;
-import com.google.api.client.http.javanet.NetHttpTransport;
-import com.google.api.client.json.jackson2.JacksonFactory;
-import com.google.api.services.gmail.Gmail;
-import org.apache.camel.RuntimeCamelException;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-public class BatchGoogleMailClientFactory implements GoogleMailClientFactory {
-    private static final Logger LOG = LoggerFactory.getLogger(BatchGoogleMailClientFactory.class);
-    private NetHttpTransport transport;
-    private JacksonFactory jsonFactory;
-
-    public BatchGoogleMailClientFactory() {
-        this.transport = new NetHttpTransport();
-        this.jsonFactory = new JacksonFactory();
-    }
-
-    @Override
-    public Gmail makeClient(
-            String clientId, String clientSecret, String applicationName, String refreshToken, String accessToken) {
-        if (clientId == null || clientSecret == null) {
-            throw new IllegalArgumentException(""clientId and clientSecret are required to create Gmail client."");
-        }
-        try {
-            Credential credential = authorize(clientId, clientSecret);
-
-            if (refreshToken != null && !"""".equals(refreshToken)) {
-                credential.setRefreshToken(refreshToken);
-            }
-            if (accessToken != null && !"""".equals(accessToken)) {
-                credential.setAccessToken(accessToken);
-            }
-            return new Gmail.Builder(transport, jsonFactory, credential).setApplicationName(applicationName).build();
-        } catch (Exception e) {
-            throw new RuntimeCamelException(""Could not create Gmail client."", e);
-        }
-    }
-
-    // Authorizes the installed application to access user's protected data.
-    private Credential authorize(String clientId, String clientSecret) {
-        // authorize
-        return new GoogleCredential.Builder().setJsonFactory(jsonFactory).setTransport(transport)
-                .setClientSecrets(clientId, clientSecret).build();
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.google.mail;
+
+import java.io.IOException;
+import java.util.List;
+
+import com.google.api.client.auth.oauth2.Credential;
+import com.google.api.client.googleapis.auth.oauth2.GoogleCredential;
+import com.google.api.client.http.javanet.NetHttpTransport;
+import com.google.api.client.json.jackson2.JacksonFactory;
+import com.google.api.services.gmail.Gmail;
+import org.apache.camel.CamelContext;
+import org.apache.camel.RuntimeCamelException;
+import org.apache.camel.support.ResourceHelper;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class BatchGoogleMailClientFactory implements GoogleMailClientFactory {
+    private static final Logger LOG = LoggerFactory.getLogger(BatchGoogleMailClientFactory.class);
+    private NetHttpTransport transport;
+    private JacksonFactory jsonFactory;
+
+    public BatchGoogleMailClientFactory() {
+        this.transport = new NetHttpTransport();
+        this.jsonFactory = new JacksonFactory();
+    }
+
+    @Override
+    public Gmail makeClient(
+            String clientId, String clientSecret, String applicationName, String refreshToken, String accessToken) {
+        if (clientId == null || clientSecret == null) {
+            throw new IllegalArgumentException(""clientId and clientSecret are required to create Gmail client."");
+        }
+        try {
+            Credential credential = authorize(clientId, clientSecret);
+
+            if (refreshToken != null && !"""".equals(refreshToken)) {
+                credential.setRefreshToken(refreshToken);
+            }
+            if (accessToken != null && !"""".equals(accessToken)) {
+                credential.setAccessToken(accessToken);
+            }
+            return new Gmail.Builder(transport, jsonFactory, credential).setApplicationName(applicationName).build();
+        } catch (Exception e) {
+            throw new RuntimeCamelException(""Could not create Gmail client."", e);
+        }
+    }
+
+    // Authorizes the installed application to access user's protected data.
+    private Credential authorize(String clientId, String clientSecret) {
+        // authorize
+        return new GoogleCredential.Builder().setJsonFactory(jsonFactory).setTransport(transport)
+                .setClientSecrets(clientId, clientSecret).build();
+    }
+
+    @Override
+    public Gmail makeClient(
+            CamelContext camelContext, String keyResource, String applicationName, String delegate, List<String> gmailScopes) {
+        if (keyResource == null) {
+            throw new IllegalArgumentException(""keyResource is required to create Gmail client."");
+        }
+        try {
+            Credential credential = authorizeServiceAccount(camelContext, keyResource, delegate, gmailScopes);
+            return new Gmail.Builder(transport, jsonFactory, credential).setApplicationName(applicationName).build();
+        } catch (Exception e) {
+            throw new RuntimeCamelException(""Could not create Gmail client."", e);
+        }
+    }
+
+    private Credential authorizeServiceAccount(
+            CamelContext camelContext, String keyResource, String delegate, List<String> gmailScopes) {
+        // authorize
+        try {
+            GoogleCredential cred = GoogleCredential
+                    .fromStream(ResourceHelper.resolveMandatoryResourceAsInputStream(camelContext, keyResource))","[{'comment': ""My fault, I didn't notice you were doing the manipulation here. Looks good then. Thanks a bunch."", 'commenter': 'oscerd'}]"
6728,components/camel-caffeine/src/main/docs/caffeine-cache-component.adoc,"@@ -83,5 +83,13 @@ CaffeineConstants.ACTION_HAS_RESULT
 CaffeineConstants.ACTION_SUCCEEDED
 ------------------------------------------------------------
 
+== Cache invalidation
+
+Please note that before Camel 3.15 the invalidate all action (CaffeineConstants.ACTION_INVALIDATE_ALL) does not
+delete anything in case that CaffeineConstants.KEYS header is either missing or contains an empty set.
+
+Starting vom Camel 3.15 the invalidate all action does not delete anything in case the CaffeineConstants.KEYS header","[{'comment': 'vom -> from', 'commenter': 'davsclaus'}, {'comment': 'I think we should move this section to the migration guide, since we are producing docs for each of the active branches', 'commenter': 'oscerd'}, {'comment': 'Ah yeah that is better as if you use camel 3.14 or older then you read the docs for that version which does not have this change. So yeah this should be moved to the 3.15 upgrade guide in the root/docs folder', 'commenter': 'davsclaus'}]"
6728,components/camel-caffeine/src/main/docs/caffeine-loadcache-component.adoc,"@@ -54,5 +54,13 @@ include::partial$component-endpoint-options.adoc[]
 // endpoint options: END
 
 
+== Cache invalidation
+
+Please note that before Camel 3.15 the invalidate all action (CaffeineConstants.ACTION_INVALIDATE_ALL) does not
+delete anything in case that CaffeineConstants.KEYS header is either missing or contains an empty set.
+
+Starting vom Camel 3.15 the invalidate all action does not delete anything in case the CaffeineConstants.KEYS header","[{'comment': 'same here', 'commenter': 'davsclaus'}]"
6728,components/camel-caffeine/src/main/java/org/apache/camel/component/caffeine/cache/CaffeineCacheEndpoint.java,"@@ -64,27 +64,37 @@ public Producer createProducer() throws Exception {
 
     @Override
     protected void doStart() throws Exception {
-        cache = CamelContextHelper.lookup(getCamelContext(), cacheName, Cache.class);
-        if (cache == null) {
-            Caffeine<?, ?> builder = Caffeine.newBuilder();
-            if (configuration.getEvictionType() == EvictionType.SIZE_BASED) {
-                builder.initialCapacity(configuration.getInitialCapacity());
-                builder.maximumSize(configuration.getMaximumSize());
-            } else if (configuration.getEvictionType() == EvictionType.TIME_BASED) {
-                builder.expireAfterAccess(configuration.getExpireAfterAccessTime(), TimeUnit.SECONDS);
-                builder.expireAfterWrite(configuration.getExpireAfterWriteTime(), TimeUnit.SECONDS);
-            }
-            if (configuration.isStatsEnabled()) {
-                if (ObjectHelper.isEmpty(configuration.getStatsCounter())) {
-                    builder.recordStats();
+
+        synchronized (this) {","[{'comment': 'Is there a reason for using sync block here? A given endpoint instance is started only once and not concurrently', 'commenter': 'davsclaus'}, {'comment': '+1, no need for sync ', 'commenter': 'oscerd'}]"
6728,components/camel-caffeine/src/main/java/org/apache/camel/component/caffeine/cache/CaffeineCacheEndpoint.java,"@@ -64,27 +64,37 @@ public Producer createProducer() throws Exception {
 
     @Override
     protected void doStart() throws Exception {
-        cache = CamelContextHelper.lookup(getCamelContext(), cacheName, Cache.class);
-        if (cache == null) {
-            Caffeine<?, ?> builder = Caffeine.newBuilder();
-            if (configuration.getEvictionType() == EvictionType.SIZE_BASED) {
-                builder.initialCapacity(configuration.getInitialCapacity());
-                builder.maximumSize(configuration.getMaximumSize());
-            } else if (configuration.getEvictionType() == EvictionType.TIME_BASED) {
-                builder.expireAfterAccess(configuration.getExpireAfterAccessTime(), TimeUnit.SECONDS);
-                builder.expireAfterWrite(configuration.getExpireAfterWriteTime(), TimeUnit.SECONDS);
-            }
-            if (configuration.isStatsEnabled()) {
-                if (ObjectHelper.isEmpty(configuration.getStatsCounter())) {
-                    builder.recordStats();
+
+        synchronized (this) {
+            cache = CamelContextHelper.lookup(getCamelContext(), cacheName, Cache.class);
+            if (cache == null) {
+                if (configuration.isCreateCacheIfNotExist()) {
+                    Caffeine<?, ?> builder = Caffeine.newBuilder();
+                    if (configuration.getEvictionType() == EvictionType.SIZE_BASED) {
+                        builder.initialCapacity(configuration.getInitialCapacity());
+                        builder.maximumSize(configuration.getMaximumSize());
+                    } else if (configuration.getEvictionType() == EvictionType.TIME_BASED) {
+                        builder.expireAfterAccess(configuration.getExpireAfterAccessTime(), TimeUnit.SECONDS);
+                        builder.expireAfterWrite(configuration.getExpireAfterWriteTime(), TimeUnit.SECONDS);
+                    }
+                    if (configuration.isStatsEnabled()) {
+                        if (ObjectHelper.isEmpty(configuration.getStatsCounter())) {
+                            builder.recordStats();
+                        } else {
+                            builder.recordStats(configuration::getStatsCounter);
+                        }
+                    }
+                    if (ObjectHelper.isNotEmpty(configuration.getRemovalListener())) {
+                        builder.removalListener(configuration.getRemovalListener());
+                    }
+                    cache = builder.build();
+                    getCamelContext().getRegistry().bind(cacheName, Cache.class, cache);","[{'comment': ""If you don't set the cache in the registry before the endpoint has been started, there is no mean of doing this after you create it in the doStart. If you don't set the cache instance in the registry, you'll use the cache created in the doStart for the lifecycle of the endpoint. \r\n\r\nThe toF examples are an attempt to explain that if you use a pure to without a cache in the registry you'll get just a cache created in the lifecycle of the endpoint, this means you won't be able to reuse it in a different endpoint. Binding the cache to the registry in the doStart is wrong in my opinion. "", 'commenter': 'oscerd'}, {'comment': 'Ah, ok - I think I got your point. However, might it be that the documentation is misleading and the associated test case is wrong? As it just works with .toF() without prior initialization? The problem with the test case is IMHO that if the GET command returns null, the body is not set, as there\'s a null check in that action. That in turn means that the body value from the PUT action before is still set and therefore the test succeeds, but not because the same cache is used.\r\n\r\nBasically\r\n\r\n```\r\n\t    camelContext.getRegistry().bind(""cache"", Caffeine.newBuilder().build());\r\n\r\n            from(""direct://start"")\r\n\r\n                .to(""caffeine-cache://cache?action=PUT&key=1"")\r\n\t\t.setBody(constant("""")) // test case fix to illustrate the issue\r\n                .to(""caffeine-cache://cache?key=1&action=GET"")\r\n                .log(""Test! ${body}"")\r\n                .to(""mock:result"");\r\n\r\n```\r\ninstead of \r\n\r\n```\r\n            from(""direct://start"")\r\n\r\n                .to(""caffeine-cache://cache?action=PUT&key=1"")\r\n                .to(""caffeine-cache://cache?key=1&action=GET"")\r\n                .log(""Test! ${body}"")\r\n                .to(""mock:result"");\r\n```\r\n\r\nI don\'t dare to say whether or not binding a cache to the registry within the endpoint fits to the Camel concept, but it doesn\'t, the synchronization indeed doesn\'t make sense at all, of course. Otherwise a synchronization would be required I guess, but according to my tests it has to be something like synchronized (getCamelContext().getRegistry()) instead of a synchronized(this), which is probably a very expensive lock and would have to be mitigated by double-check idiom or so. Thinking of it, I guess the binding looks somehow complicated - you\'re right and the cache has to be created before using it. Can you confirm? Then I try to update the pull request asap.', 'commenter': 'ank19'}, {'comment': ""Essentialy the cache needs to be created ahead of the enbpoint instantiation and start, so it should be in the registry before. You're, by the way, welcome to test and improve the component :-) Thanks a lot!"", 'commenter': 'oscerd'}, {'comment': 'I have to say thanks for the valuable comments! Took me a while to grasp it, but hopefully I got it now, :-) I removed the binding/sync part and I added\r\n```\r\n@BindToRegistry(""cache"")\r\nCache cache = Caffeine.newBuilder().recordStats().build();\r\n``` \r\nto the documentation to illustrate it, hope that\'s fine - I guess that was my missing link in understanding.', 'commenter': 'ank19'}]"
6728,components/camel-caffeine/src/main/java/org/apache/camel/component/caffeine/load/CaffeineLoadCacheEndpoint.java,"@@ -64,27 +65,36 @@ public Producer createProducer() throws Exception {
 
     @Override
     protected void doStart() throws Exception {
-        cache = CamelContextHelper.lookup(getCamelContext(), cacheName, LoadingCache.class);
-        if (cache == null) {
-            Caffeine<Object, Object> builder = Caffeine.newBuilder();
-            if (configuration.getEvictionType() == EvictionType.SIZE_BASED) {
-                builder.initialCapacity(configuration.getInitialCapacity());
-                builder.maximumSize(configuration.getMaximumSize());
-            } else if (configuration.getEvictionType() == EvictionType.TIME_BASED) {
-                builder.expireAfterAccess(configuration.getExpireAfterAccessTime(), TimeUnit.SECONDS);
-                builder.expireAfterWrite(configuration.getExpireAfterWriteTime(), TimeUnit.SECONDS);
-            }
-            if (configuration.isStatsEnabled()) {
-                if (ObjectHelper.isEmpty(configuration.getStatsCounter())) {
-                    builder.recordStats();
+
+        synchronized (this) {","[{'comment': 'No need for sync', 'commenter': 'oscerd'}]"
6872,components/camel-mail/src/main/java/org/apache/camel/component/mail/MailBinding.java,"@@ -368,13 +368,18 @@ protected void extractAttachmentsFromMultipart(Multipart mp, Map<String, Attachm
                         }
                         map.put(fileName, camelAttachment);
                     } else {
-                        LOG.warn(""Cannot extract duplicate file attachment: {}."", fileName);
+                        handleDuplicateAttachmentFilename(fileName);
                     }
                 }
             }
         }
     }
 
+    protected void handleDuplicateAttachmentFilename(String fileName) throws MessagingException {
+        LOG.error(""Cannot extract duplicate file attachment: {}."", fileName);","[{'comment': 'Do not log an throw exception, only throw exception', 'commenter': 'davsclaus'}]"
6872,components/camel-mail/src/main/java/org/apache/camel/component/mail/MailBinding.java,"@@ -368,13 +368,18 @@ protected void extractAttachmentsFromMultipart(Multipart mp, Map<String, Attachm
                         }
                         map.put(fileName, camelAttachment);
                     } else {
-                        LOG.warn(""Cannot extract duplicate file attachment: {}."", fileName);
+                        handleDuplicateAttachmentFilename(fileName);","[{'comment': 'I would avoid creating a method for one line exception throw', 'commenter': 'oscerd'}, {'comment': 'The idea was, that custom bindings could override the error handling, i.e. only log an error.', 'commenter': 'mash-sap'}]"
6892,core/camel-core-engine/src/main/docs/antora.yml,"@@ -18,4 +18,4 @@
 # A distributed part of main camel ""docs/components"" 'components' component descriptor:
 
 name: components
-version: next
+version: 3.15.0","[{'comment': 'should be 3.15.x', 'commenter': 'djencks'}]"
6892,docs/components/antora.yml,"@@ -21,9 +21,8 @@
 
 name: components
 title: Camel Components
-version: next
-prerelease: true
-display-version: Next (Pre-release)
+version: 3.15.0","[{'comment': 'This is what shows up in the doc url, so to match everything else it should be 3.15.x.  \r\nThe display-version is not needed as it is the same: we only need it for next and LTS releases.\r\n\r\nThere should be similar changes in the camel-spring-boot and camel-karaf antora.yml files.', 'commenter': 'djencks'}]"
6892,docs/source-map.yml,"@@ -21,5 +21,5 @@
         - url: 'https://github.com/apache/camel.git'
           mapped_url: './../camel'
           branches:
-            - branch: main
+            - branch: 3.15.x","[{'comment': 'This is the git branch name, and is correct (for this subproject: most others have more complicated naming schemes such as `release-3.15.x`).', 'commenter': 'djencks'}]"
6897,components/camel-aws/camel-aws2-ses/src/main/java/org/apache/camel/component/aws2/ses/Ses2Producer.java,"@@ -148,15 +148,39 @@ private String determineReturnPath(Exchange exchange) {
         return returnPath;
     }
 
-    private Destination determineTo(Exchange exchange) {
-        String to = exchange.getIn().getHeader(Ses2Constants.TO, String.class);
-        if (to == null) {
-            to = getConfiguration().getTo();
+    private Destination determineDestination(Exchange exchange) {
+        List<String> to = determineRawTo(exchange);
+        List<String> cc = determineRawCc(exchange);
+        List<String> bcc = determineRawBcc(exchange);
+        return Destination.builder().toAddresses(to).ccAddresses(cc).bccAddresses(bcc).build();
+    }
+
+    private List<String> determineRawCc(Exchange exchange) {
+        String cc = exchange.getIn().getHeader(Ses2Constants.CC, String.class);
+        if (cc == null) {","[{'comment': 'Please use ObjectHelper to check for null', 'commenter': 'oscerd'}]"
6897,components/camel-aws/camel-aws2-ses/src/main/java/org/apache/camel/component/aws2/ses/Ses2Producer.java,"@@ -148,15 +148,39 @@ private String determineReturnPath(Exchange exchange) {
         return returnPath;
     }
 
-    private Destination determineTo(Exchange exchange) {
-        String to = exchange.getIn().getHeader(Ses2Constants.TO, String.class);
-        if (to == null) {
-            to = getConfiguration().getTo();
+    private Destination determineDestination(Exchange exchange) {
+        List<String> to = determineRawTo(exchange);
+        List<String> cc = determineRawCc(exchange);
+        List<String> bcc = determineRawBcc(exchange);
+        return Destination.builder().toAddresses(to).ccAddresses(cc).bccAddresses(bcc).build();
+    }
+
+    private List<String> determineRawCc(Exchange exchange) {
+        String cc = exchange.getIn().getHeader(Ses2Constants.CC, String.class);
+        if (cc == null) {
+            cc = getConfiguration().getCc();
+        }
+        if (ObjectHelper.isNotEmpty(cc)) {
+            return Stream.of(cc.split("",""))
+                    .map(String::trim)
+                    .collect(Collectors.toList());
+        } else {
+            return Collections.emptyList();
+        }
+    }
+
+    private List<String> determineRawBcc(Exchange exchange) {
+        String bcc = exchange.getIn().getHeader(Ses2Constants.BCC, String.class);
+        if (bcc == null) {","[{'comment': 'same', 'commenter': 'oscerd'}]"
6937,.github/actions/install-mvnd/action.yml,"@@ -0,0 +1,21 @@
+name: 'install-mvnd'
+description: 'Install the maven daemon'
+inputs:
+  version:
+    description: 'The version of the maven daemon to install'
+    required: true
+    default: '0.7.1'
+outputs:
+  mvnd-dir:
+    description: ""The directory where the command mvnd is located""
+    value: ${{ steps.mvnd-location.outputs.mvnd-dir }}
+runs:
+  using: ""composite""
+  steps:
+    - run: curl -fsSL -o mvnd.zip https://github.com/apache/maven-mvnd/releases/download/${{ inputs.version }}/mvnd-${{ inputs.version }}-linux-amd64.zip
+      shell: bash","[{'comment': 'I am not entirely sure if we are allowed to download and run code freely on the GH actions (any idea @oscerd?), but I think that we need to include the following here:\r\n1. Cache the hash sum and verify it before running. ', 'commenter': 'orpiske'}, {'comment': 'You mean that you would like to add a checksum to guarantee the consistency of the file?', 'commenter': 'essobedo'}, {'comment': ""Yes. Unfortunately it's not signed, so it's the best we can do. "", 'commenter': 'orpiske'}, {'comment': '@orpiske checker added, hoping that it was what you had in mind', 'commenter': 'essobedo'}]"
6940,components/camel-mail/src/test/java/org/apache/camel/dataformat/mime/multipart/MimeMultipartDataFormatTest.java,"@@ -146,6 +146,62 @@ public void roundtripWithTextAttachmentsAndSpecialCharacters() throws IOExceptio
         assertEquals(attText, new String(os.toByteArray()));
     }
 
+    @Test
+    public void roundtripWithMultipleTextAttachmentsButDifferentCharsets() throws IOException {
+        String att1ContentType = ""text/plain; charset=ISO-8859-1"";
+        String att1Text = new String(""empfänger1"".getBytes(""ISO-8859-1""), ""ISO-8859-1"");
+        String att1FileName = ""empfänger1"";
+        String att2ContentType = ""text/plain; charset=ISO-8859-15"";
+        String att2Text = new String(""empfänger15"".getBytes(""ISO-8859-15""), ""ISO-8859-15"");
+        String att2FileName = ""empfänger15"";","[{'comment': 'When you have string text that uses non-ascii then you should unicode escape those, eg ""aaa\\u1234\\u5555""', 'commenter': 'davsclaus'}, {'comment': ""Thanks! fixed\r\n\r\nBTW I have same situation in my job which damages German characters. I though it's Camel issue. So I wrote this test. But I realized it's my fault. I MUST NOT convert body to string after `.marshal().mimemultipart()` where there're multiple different charsets in body and attachments. I MUST keep it as byte array when I push it into JMS. Then on other side when I read it as a byte array then Camel can unmarshal it correctly.\r\n\r\nSo I just wanted to not throw away this test. Please feel free to use or close it :)"", 'commenter': 'yasserzamani'}, {'comment': 'Thanks for the test, we can surely use this', 'commenter': 'davsclaus'}]"
6944,components/camel-aws/camel-aws2-ddb/src/main/docs/aws2-ddb-component.adoc,"@@ -266,8 +266,29 @@ URI:
 
 [source,java]
 ----------------------------------------------------
-from(""direct:start"")
-.to(""aws2-ddb://domainName?amazonDDBClient=#client"");
+public class MyRouteBuilder extends RouteBuilder {
+
+    private String accessKey = ""myaccessKey"";
+    private String secretKey = ""secretKey"";
+
+    @Override
+    public void setCamelContext(CamelContext camelContext) {","[{'comment': 'It is not good practice to do code in a setter - keep setter as plain getter/setter.\r\n\r\nInstead you can create a method with this logic, and call this method from configure()', 'commenter': 'davsclaus'}, {'comment': 'Thanks for the advice. \r\nI changed it to register the aws client in the configure()\r\n\r\n` getCamelContext().getRegistry().bind(""client"", client);`', 'commenter': 'neoxu9999'}]"
7019,components/camel-opentelemetry/src/main/docs/opentelemetry.adoc,"@@ -33,7 +33,7 @@ Dashes need for instances to be encoded for JMS property keys.
 |=======================================================================
 
 
-=== Configuration
+=== Explicit","[{'comment': ""I don't think this should be explicit. It's configuration."", 'commenter': 'oscerd'}, {'comment': 'Thanks. I have changed it to Configuration in https://github.com/apache/camel/pull/7019/commits/be9f710fec4653ddd9b95bbf6869d80f518d0f89 commit.', 'commenter': 'stn1slv'}]"
7073,core/camel-api/src/main/java/org/apache/camel/spi/DataFormat.java,"@@ -54,4 +54,13 @@
      * @throws Exception can be thrown
      */
     Object unmarshal(Exchange exchange, InputStream stream) throws Exception;
+
+    /**
+     * Indicates whether {@code null} is allowed as value of a body to unmarshall.
+     *
+     * @return {@code true} if {@code null} is allowed, {@code false} otherwise.
+     */
+    default boolean allowNullBody() {","[{'comment': ""Is this correct? It should be specific to Jackson and not generic to data format.\r\n\r\nI'm from mobile so I might losing something "", 'commenter': 'oscerd'}, {'comment': ""That's a good remark, actually, the failure doesn't happen in the Jackson `DataFormat` itself but in the `UnmarshalProcessor`.  Indeed, The failure is due to the fact that it cannot find a converter to convert a `null` value into an `InputStream` which occurs when calling `in.getMandatoryBody(InputStream.class)`. That is why I had to manage it at a higher level, moreover @davsclaus proposed in the same ticket to eventually have it for all the existing DataFormat which could give more sense to this approach. Do you see a better/simpler approach? If I need to apply the same logic to the other DataFormats, I had better to have the best approach."", 'commenter': 'essobedo'}, {'comment': ""Well, I didn't read the suggestion from @davsclaus, in that case it makes completely sense as a basic step to then provide the feature on all the dataformat. So fine with me. Thanks for the explanation."", 'commenter': 'oscerd'}, {'comment': ""Yeah I can't think of a better way as there is no common DataFormatConfiguration class that they all extend etc where we could have common options. \r\n\r\nBut this is really a useful feature to let the data format not fail on null bodies.\r\n\r\nEspecially for use-cases with json where we would often use jackson.\r\n"", 'commenter': 'davsclaus'}]"
7073,core/camel-support/src/main/java/org/apache/camel/support/processor/UnmarshalProcessor.java,"@@ -55,13 +55,16 @@ public boolean process(Exchange exchange, AsyncCallback callback) {
         InputStream stream = null;
         Object result = null;
         try {
-            stream = exchange.getIn().getMandatoryBody(InputStream.class);
+            final Message in = exchange.getIn();
+            final Message out = exchange.getOut();","[{'comment': 'Do not call getOut() to early as it will create an empty message, and cause the exchange to have this empty message as the response, even if the message body is null and allow null enabled. So move this out to later where its first in use', 'commenter': 'davsclaus'}]"
7105,core/camel-core-model/src/main/java/org/apache/camel/model/rest/RestDefinition.java,"@@ -606,6 +619,10 @@ public RestDefinition security(String key, String scopes) {
         return this;
     }
 
+    public Collection<SecurityDefinition> securityRequirements() {","[{'comment': 'What is this method for?', 'commenter': 'davsclaus'}, {'comment': 'This comes from https://github.com/apache/camel/blob/main/core/camel-core-model/src/main/java/org/apache/camel/model/rest/SecurityRequirementsDefinition.java#L76-L78', 'commenter': 'essobedo'}]"
7105,core/camel-core-model/src/main/java/org/apache/camel/model/rest/RestDefinition.java,"@@ -80,11 +84,13 @@
     @XmlElement(name = ""securityDefinitions"") // use the name Swagger/OpenAPI uses
     @Metadata(label = ""security"")
     private RestSecuritiesDefinition securityDefinitions;
-    @XmlElement(name = ""securityRequirements"") // use the name Swagger/OpenAPI uses
+    @XmlElement
     @Metadata(label = ""security"")
-    private SecurityRequirementsDefinition securityRequirements;
+    private List<SecurityDefinition> securityRequirements = new ArrayList<>();
     @XmlElementRef
     private List<VerbDefinition> verbs = new ArrayList<>();
+    @XmlTransient
+    private Map<String, SecurityDefinition> itemsMap = new HashMap<>();","[{'comment': 'Can we avoid this internal special map as this is not common practice in the model classes, so can you try to find another way.', 'commenter': 'davsclaus'}, {'comment': 'This comes from https://github.com/apache/camel/blob/main/core/camel-core-model/src/main/java/org/apache/camel/model/rest/SecurityRequirementsDefinition.java#L46-L47', 'commenter': 'essobedo'}]"
7105,core/camel-core-model/src/main/java/org/apache/camel/model/rest/RestDefinition.java,"@@ -170,15 +176,17 @@ public void setSecurityDefinitions(RestSecuritiesDefinition securityDefinitions)
         this.securityDefinitions = securityDefinitions;
     }
 
-    public SecurityRequirementsDefinition getSecurityRequirements() {
+    public List<SecurityDefinition> getSecurityRequirements() {
         return securityRequirements;
     }
 
     /**
      * Sets the security requirement(s) for all endpoints.
      */
-    public void setSecurityRequirements(SecurityRequirementsDefinition securityRequirements) {
-        this.securityRequirements = securityRequirements;
+    public void setSecurityRequirements(Collection<SecurityDefinition> securityRequirements) {","[{'comment': 'The getter/setter should be same type, eg List', 'commenter': 'davsclaus'}, {'comment': 'This comes from https://github.com/apache/camel/blob/main/core/camel-core-model/src/main/java/org/apache/camel/model/rest/SecurityRequirementsDefinition.java#L87-L91', 'commenter': 'essobedo'}]"
7213,components/camel-mail/src/main/java/org/apache/camel/component/mail/MailConsumer.java,"@@ -388,63 +387,57 @@ private SearchTerm computeSearchTerm() {
         return null;
     }
 
-    protected Queue<Exchange> createExchanges(List<KeyValueHolder<String, Message>> messages) throws MessagingException {
-        Queue<Exchange> answer = new LinkedList<>();
-
-        for (int i = 0; i < messages.size(); i++) {
-            try {
-                KeyValueHolder<String, Message> holder = messages.get(i);
-                String key = holder.getKey();
-                Message message = holder.getValue();
+    protected Exchange createExchange(KeyValueHolder<String, Message> holder) throws MessagingException {
+        try {
+            String key = holder.getKey();
+            Message message = holder.getValue();
 
-                if (LOG.isTraceEnabled()) {
-                    LOG.trace(""Mail #{} is of type: {} - {}"", i, ObjectHelper.classCanonicalName(message), message);
-                }
+            if (LOG.isTraceEnabled()) {
+                LOG.trace(""Mail is of type: {} - {}"", ObjectHelper.classCanonicalName(message), message);
+            }
 
-                if (!message.getFlags().contains(Flags.Flag.DELETED)) {
-                    Exchange exchange = createExchange(message);
-                    if (getEndpoint().getConfiguration().isMapMailMessage()) {
-                        // ensure the mail message is mapped, which can be ensured by touching the body/header/attachment
-                        LOG.trace(""Mapping #{} from javax.mail.Message to Camel MailMessage"", i);
-                        exchange.getIn().getBody();
-                        exchange.getIn().getHeaders();
-                        // must also map attachments
-                        try {
-                            Map<String, Attachment> att = new HashMap<>();
-                            getEndpoint().getBinding().extractAttachmentsFromMail(message, att);
-                            if (!att.isEmpty()) {
-                                exchange.getIn(AttachmentMessage.class).setAttachmentObjects(att);
-                            }
-                        } catch (MessagingException | IOException e) {
-                            // must release exchange before throwing exception
-                            releaseExchange(exchange, true);
-                            throw new RuntimeCamelException(""Error accessing attachments due to: "" + e.getMessage(), e);
+            if (!message.getFlags().contains(Flags.Flag.DELETED)) {
+                Exchange exchange = createExchange(message);
+                if (getEndpoint().getConfiguration().isMapMailMessage()) {
+                    // ensure the mail message is mapped, which can be ensured by touching the body/header/attachment
+                    LOG.trace(""Mapping from javax.mail.Message to Camel MailMessage"");
+                    exchange.getIn().getBody();
+                    exchange.getIn().getHeaders();
+                    // must also map attachments
+                    try {
+                        Map<String, Attachment> att = new HashMap<>();
+                        getEndpoint().getBinding().extractAttachmentsFromMail(message, att);
+                        if (!att.isEmpty()) {
+                            exchange.getIn(AttachmentMessage.class).setAttachmentObjects(att);
                         }
+                    } catch (MessagingException | IOException e) {
+                        // must release exchange before throwing exception
+                        releaseExchange(exchange, true);
+                        throw new RuntimeCamelException(""Error accessing attachments due to: "" + e.getMessage(), e);
                     }
+                }
 
-                    // If the protocol is POP3 we need to remember the uid on the exchange
-                    // so we can find the mail message again later to be able to delete it
-                    // we also need to remember the UUID for idempotent repository
-                    exchange.setProperty(MAIL_MESSAGE_UID, key);
+                // If the protocol is POP3 we need to remember the uid on the exchange
+                // so we can find the mail message again later to be able to delete it
+                // we also need to remember the UUID for idempotent repository
+                exchange.setProperty(MAIL_MESSAGE_UID, key);
 
-                    answer.add(exchange);
-                } else {
-                    if (LOG.isDebugEnabled()) {
-                        LOG.debug(""Skipping message as it was flagged as deleted: {}"", MailUtils.dumpMessage(message));
-                    }
-                }
-            } catch (Exception e) {
-                if (skipFailedMessage) {
-                    LOG.debug(""Skipping failed message at index {} due {}"", i, e.getMessage(), e);
-                } else if (handleFailedMessage) {
-                    handleException(e);
-                } else {
-                    throw e;
+                return exchange;
+            } else {
+                if (LOG.isDebugEnabled()) {
+                    LOG.debug(""Skipping message as it was flagged as deleted: {}"", MailUtils.dumpMessage(message));
                 }
             }
+        } catch (Exception e) {
+            if (skipFailedMessage) {
+                LOG.debug(""Skipping failed message at index due {}"", e.getMessage(), e);","[{'comment': 'There is no longer an index so this log message should be updated', 'commenter': 'davsclaus'}, {'comment': 'Done', 'commenter': 'mash-sap'}]"
7263,components/camel-azure/camel-azure-eventhubs/src/main/java/org/apache/camel/component/azure/eventhubs/EventHubsConsumer.java,"@@ -30,15 +33,25 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import static org.apache.camel.component.azure.eventhubs.EventHubsConstants.*;","[{'comment': ""Please don't import with * operator, use explicit imports."", 'commenter': 'oscerd'}, {'comment': 'done', 'commenter': 'kevinlacire'}]"
7279,components/camel-azure/camel-azure-servicebus/src/main/java/org/apache/camel/component/azure/servicebus/ServiceBusConsumer.java,"@@ -30,31 +30,34 @@
 import org.apache.camel.component.azure.servicebus.client.ServiceBusClientFactory;
 import org.apache.camel.component.azure.servicebus.client.ServiceBusReceiverAsyncClientWrapper;
 import org.apache.camel.component.azure.servicebus.operations.ServiceBusReceiverOperations;
+import org.apache.camel.spi.ExceptionHandler;
 import org.apache.camel.spi.Synchronization;
 import org.apache.camel.support.DefaultConsumer;
 import org.apache.camel.support.SynchronizationAdapter;
 import org.apache.camel.util.ObjectHelper;
 
 public class ServiceBusConsumer extends DefaultConsumer {
 
+    private static final String SERVICE_BUS_RECEIVED_MESSAGE = ""ServiceBusReceivedMessage"";","[{'comment': 'I think this should go in the ServiceBusConstants class', 'commenter': 'oscerd'}, {'comment': 'The header doc/metadata stuff that @essobedo did, does it also understand that a key can be for an exchange property and not as a header?\r\n\r\nBut yeah its better anyway to move it there, as an end user may want for some special reason to get hold of that raw message.', 'commenter': 'davsclaus'}, {'comment': '@davsclaus for now, if it is a constant (public static final field) defined in the constant class (class defined as the value of the element `headersClass` of the annotation `UriEndpoint`) annotated with `@Metadata`, it will be considered as an header. If we need to improve it more please let me know. ', 'commenter': 'essobedo'}, {'comment': ""As far as I understand, in this case, I guess it will not be annotated and potentially not public but private package so it won't be a problem"", 'commenter': 'essobedo'}, {'comment': 'Thanks', 'commenter': 'davsclaus'}]"
7392,core/camel-core-model/src/main/java/org/apache/camel/model/ResumableDefinition.java,"@@ -40,6 +41,13 @@
     @Metadata(required = true, javaType = ""org.apache.camel.ResumeStrategy"")
     private String resumeStrategy;
 
+    @XmlTransient
+    private LoggingLevel loggingLevel = LoggingLevel.WARN;","[{'comment': 'See hos we do this in LogDefinition with just a String type (not a Ref name)\r\n\r\norg.apache.camel.model.LogDefinition', 'commenter': 'davsclaus'}, {'comment': 'I had a mistake too ;)\r\nhttps://github.com/apache/camel/commit/55bc0f2430fa2df1569a8c70b853e0d9e2c5acd3', 'commenter': 'davsclaus'}, {'comment': ':D Nice, thanks for the tip and I am glad you found an issue! ', 'commenter': 'orpiske'}]"
7392,core/camel-core-model/src/main/java/org/apache/camel/model/ResumableDefinition.java,"@@ -40,6 +40,11 @@
     @Metadata(required = true, javaType = ""org.apache.camel.ResumeStrategy"")
     private String resumeStrategy;
 
+    @XmlAttribute(required = true)","[{'comment': 'I do not think this should be required = true, as the default value is ERROR\r\n\r\n(PS later you use WARN as the default in the resolveLogger)', 'commenter': 'davsclaus'}]"
7392,core/camel-core-processor/src/main/java/org/apache/camel/processor/resume/ResumableCompletion.java,"@@ -70,6 +73,29 @@ public void onComplete(Exchange exchange) {
 
     @Override
     public void onFailure(Exchange exchange) {
-        LOG.warn(""Skipping offset update for due to failure in processing"");
+        Exception e = exchange.getException();
+        Object offset = exchange.getMessage().getHeader(Exchange.OFFSET);
+
+        if (offset instanceof Resumable) {
+            Resumable<?, ?> resumable = (Resumable<?, ?>) offset;
+
+            if (loggingLevel == LoggingLevel.DEBUG && LOG.isDebugEnabled()) {","[{'comment': 'This would only make logging level work for DEBUG and any other value will log is hardcoded to log at WARN in the else block.\r\n\r\nTake a look at CamelLogger class which can log at configured level automatic, so you can use call its log method.', 'commenter': 'davsclaus'}, {'comment': 'Thanks!\r\n\r\nSo, what I want here is for the logger to log the exception only if the API log level is `debug` or lower. Because, then, it makes it easier to figure out what caused the update to not happen.\r\n\r\nDo I understand correctly that you are suggesting me to do something like the code below?\r\n\r\n```\r\nif (LOG.isDebugEnabled()) {\r\n      CamelLogger.log(LOG, ""Skipping offset update with address \'{}\' and offset value \'{}\' due to failure in processing: {}"",\r\n              resumable.getAddressable(), resumable.getLastOffset().offset(), e.getMessage(), e);\r\n  } else {\r\n      CamelLogger.log(LOG, ""Skipping offset update with address \'{}\' and offset value \'{}\' due to failure in processing: {}"",\r\n              resumable.getAddressable(), resumable.getLastOffset().offset(), e.getMessage());\r\n  }\r\n```\r\n\r\n', 'commenter': 'orpiske'}, {'comment': 'Ah yeah that makes sense to have hardcoded DEBUG then with the stacktrace included. \r\n\r\nWe sometimes add `(stacktrace in DEBUG logging level)` to the ""other"" message so users can know how to get the stacktrace.', 'commenter': 'davsclaus'}]"
7392,core/camel-core-reifier/src/main/java/org/apache/camel/reifier/ResumableReifier.java,"@@ -47,6 +49,17 @@ protected ResumeStrategy resolveResumeStrategy() {
             String ref = parseString(definition.getResumeStrategy());
             strategy = mandatoryLookup(ref, ResumeStrategy.class);
         }
+
         return strategy;
     }
+
+    protected LoggingLevel resolveLoggingLevel() {
+        LoggingLevel loggingLevel = parse(LoggingLevel.class, definition.getLoggingLevel());
+
+        if (loggingLevel == null) {
+            loggingLevel = LoggingLevel.WARN;","[{'comment': 'Here default value is WARN but in the model it is ERROR.\r\n', 'commenter': 'davsclaus'}, {'comment': 'Ahh, good catch. I think we can default to ERROR. ', 'commenter': 'orpiske'}]"
7392,core/camel-core-processor/src/main/java/org/apache/camel/processor/resume/ResumableCompletion.java,"@@ -70,6 +74,34 @@ public void onComplete(Exchange exchange) {
 
     @Override
     public void onFailure(Exchange exchange) {
-        LOG.warn(""Skipping offset update for due to failure in processing"");
+        Exception e = exchange.getException();
+        Object offset = exchange.getMessage().getHeader(Exchange.OFFSET);
+
+        if (offset instanceof Resumable) {
+            Resumable<?, ?> resumable = (Resumable<?, ?>) offset;
+
+            String logMessage = String.format(
+                    ""Skipping offset update with address '%s' and offset value '%s' due to failure in processing: %s"",
+                    resumable.getAddressable(), resumable.getLastOffset().offset(), e.getMessage());
+
+            if (LOG.isDebugEnabled()) {
+                CamelLogger.log(LOG, loggingLevel, logMessage, e);","[{'comment': 'We would actually have 2 logging levels\r\n\r\n- LOG instance that are controlled by log4j properties\r\n- loggingLevel which is EIP option\r\n\r\nSo I think you need to log with stacktraces if one of them is DEBUG, and hence you need to test both.\r\n\r\nAnd then the `loggingLevel` you pass in to CamelLogger should be hardcoded to DEBUG so its always logged at that level.', 'commenter': 'davsclaus'}, {'comment': 'So, I if I understand it correctly. I should do something like:\r\n\r\n```\r\nif (LOG.isDebugEnabled() || CamelLogger.shouldLog(LoggingLevel.DEBUG)) {\r\n```', 'commenter': 'orpiske'}, {'comment': 'Yes', 'commenter': 'davsclaus'}, {'comment': ""Great, thanks for confirming. I'll adjust. "", 'commenter': 'orpiske'}]"
7418,.github/workflows/master-pr-build.yml,"@@ -71,14 +71,14 @@ jobs:
           distribution: 'temurin'
           java-version: ${{ matrix.java }}
           cache: 'maven'
-      - name: maven build
-        run: ${{ steps.install-mvnd.outputs.mvnd-dir }}/mvnd -l build.log -Dmvnd.threads=2 -V -Dhttp.keepAlive=false -Dmaven.wagon.http.pool=false -Dmaven.wagon.httpconnectionManager.ttlSeconds=120 --no-transfer-progress -Pfastinstall -Dcheckstyle.skip=true -DskipTests install
-      - name: archive logs
-        uses: actions/upload-artifact@v3
-        if: always()
-        with:
-          name: build.log
-          path: build.log
+#      - name: maven build
+#        run: ${{ steps.install-mvnd.outputs.mvnd-dir }}/mvnd -l build.log -Dmvnd.threads=2 -V -Dhttp.keepAlive=false -Dmaven.wagon.http.pool=false -Dmaven.wagon.httpconnectionManager.ttlSeconds=120 --no-transfer-progress -Pfastinstall -Dcheckstyle.skip=true -DskipTests install
+#      - name: archive logs
+#        uses: actions/upload-artifact@v3
+#        if: always()
+#        with:
+#          name: build.log
+#          path: build.log","[{'comment': 'This is preventing the build logs from being uploaded. ', 'commenter': 'orpiske'}, {'comment': 'I know, it is only to get a quick feedback (avoid waiting for the maven build) as the commit message states. I will of course remove this commit once the quick test will pass, sorry for the noise', 'commenter': 'essobedo'}, {'comment': 'No worries, thanks for the heads up. ', 'commenter': 'orpiske'}]"
7454,components/camel-kafka/src/test/java/org/apache/camel/component/kafka/integration/KafkaProducerFullIT.java,"@@ -58,6 +60,7 @@
 import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.junit.jupiter.api.Assertions.assertNotNull;
 import static org.junit.jupiter.api.Assertions.assertTrue;
+import static org.junit.jupiter.api.Assertions.fail;
 
 public class KafkaProducerFullIT extends BaseEmbeddedKafkaTestSupport {","[{'comment': ""Not a deal breaker, but I am wondering if wouldn't be better to have the test in a different class. This test class is starting to get fairly big IMHO."", 'commenter': 'orpiske'}, {'comment': ""yeah, sure. I'd like to refact to move all transaction related tests to ```KafkaProducerTransactionIT```."", 'commenter': 'zhfeng'}, {'comment': 'Done', 'commenter': 'zhfeng'}]"
7454,components/camel-kafka/src/test/java/org/apache/camel/component/kafka/integration/KafkaProducerFullIT.java,"@@ -155,10 +175,60 @@ public void configure() {
                 from(""direct:propagatedHeaders"").to(toPropagatedHeaders).to(mockEndpoint);
 
                 from(""direct:noRecordSpecificHeaders"").to(toNoRecordSpecificHeaders).to(mockEndpoint);
+
+                from(""direct:startTransaction"").transacted(""kafkaTransaction"")
+                        .to(toTransaction).process(new Processor() {
+                            @Override
+                            public void process(Exchange exchange) throws Exception {
+                                String body = exchange.getIn().getBody(String.class);
+                                if (body.contains(""fail"")) {
+                                    throw new RuntimeException(""fail process message "" + body);
+                                }
+                            }
+                        }).to(mockEndpoint);
             }
         };
     }
 
+    @Test
+    public void producedTransactionMassageIsReceivedByKafka() throws InterruptedException {
+        int messageInTopic = 10;
+        int messageInOtherTopic = 5;
+
+        CountDownLatch messagesLatch = new CountDownLatch(messageInTopic + messageInOtherTopic);
+
+        sendMessagesInRoute(messageInTopic, testTransaction, ""IT test transaction message"", KafkaConstants.PARTITION_KEY, ""0"");
+        try {
+            sendMessagesInRoute(messageInTopic, testTransaction, ""IT test transaction fail message"",
+                    KafkaConstants.PARTITION_KEY,
+                    ""0"");
+            fail(""Should fail in transaction"");
+        } catch (Exception e) {
+        }","[{'comment': 'Please use `assertThrows` or `assertDoesNotThrow` depending on what you expect the code to do.', 'commenter': 'orpiske'}, {'comment': 'good catch!', 'commenter': 'zhfeng'}, {'comment': 'Done', 'commenter': 'zhfeng'}]"
7454,components/camel-kafka/src/main/java/org/apache/camel/component/kafka/KafkaProducer.java,"@@ -492,4 +509,40 @@ private void doSend(Object key, ProducerRecord<Object, Object> record, KafkaProd
             kafkaProducer.send(record, cb);
         }
     }
+
+    private void startKafkaTransaction(Exchange exchange) {
+        exchange.getUnitOfWork().beginTransactedBy(transactionId);
+        kafkaProducer.beginTransaction();
+        exchange.getUnitOfWork().addSynchronization(new KafkaTransactionSynchronization(transactionId, kafkaProducer));
+    }
+}
+
+class KafkaTransactionSynchronization extends SynchronizationAdapter {
+    private static final Logger LOG = LoggerFactory.getLogger(KafkaTransactionSynchronization.class);
+    private String transactionId;
+    private Producer kafkaProducer;
+
+    public KafkaTransactionSynchronization(String transacionId, Producer kafkaProducer) {
+        this.transactionId = transacionId;
+        this.kafkaProducer = kafkaProducer;
+    }
+
+    @Override
+    public void onDone(Exchange exchange) {
+        try {
+            if (exchange.getException() != null || exchange.isRollbackOnly()) {","[{'comment': 'What kind of exceptions could it catch there?  I mean, if beginTransactions() causes something unexpected for example if producer closed, so the synchronization block can handle?', 'commenter': 'alexkazan87'}, {'comment': ""Good catch! We should handle such kafka exception, and in such cases, it don't need to call ```kafkaProducer.abortTransaction()```, is it right?"", 'commenter': 'zhfeng'}, {'comment': 'I think ```exchange.getException()``` could catch the exception during the routing.', 'commenter': 'zhfeng'}, {'comment': 'It seems ```ProducerFencedException``` should be concerned\r\n>This fatal exception indicates that another producer with the same <code>transactional.id</code> has been\r\n started. It is only possible to have one producer instance with a <code>transactional.id</code> at any\r\n given time, and the latest one to be started ""fences"" the previous instances so that they can no longer\r\n make transactional requests. When you encounter this exception, you must close the producer instance.\r\n\r\nI\'m not familiar with kafka. So @alexkazan87 can you check it?', 'commenter': 'zhfeng'}, {'comment': 'Correct! Generally, I would catch all the exceptions because ""tomorrow"" Kafka client could throw a different exception and throw it as a specific camel Kafka exception. So, you can handle and avoid the abort operation.', 'commenter': 'alexkazan87'}, {'comment': 'I make some changes to abort a transaction only when the exception is not ```KafkaException```.', 'commenter': 'zhfeng'}]"
7615,components/camel-azure/camel-azure-storage-blob/src/main/java/org/apache/camel/component/azure/storage/blob/BlobComponent.java,"@@ -27,6 +27,8 @@
 import org.apache.camel.spi.annotations.Component;
 import org.apache.camel.support.DefaultComponent;
 
+import static org.apache.camel.component.azure.storage.blob.CredentialType.*;","[{'comment': 'Please avoid the * import.', 'commenter': 'oscerd'}, {'comment': 'Fixed', 'commenter': 'yuhusolutions'}]"
7615,components/camel-azure/camel-azure-storage-blob/src/main/java/org/apache/camel/component/azure/storage/blob/CredentialType.java,"@@ -0,0 +1,39 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.azure.storage.blob;
+
+public enum CredentialType {
+    /**
+     * Shared key credential
+     * @see com.azure.storage.common.StorageSharedKeyCredential
+     */
+    shared_key_credential,","[{'comment': 'I think we should follow the constants convention and naming in uppercase', 'commenter': 'oscerd'}, {'comment': 'Yeah enums tend to be either in UPPER_CASE or CamelCase style', 'commenter': 'davsclaus'}, {'comment': ""I will fix the new one I created; However note that other enums in the Azure component (created outside of this PR) don't follow the convention.\r\nIt may be worth opening a separate ticket to tidy-up the component to make it consistent.\r\n"", 'commenter': 'yuhusolutions'}, {'comment': 'Fixed', 'commenter': 'yuhusolutions'}, {'comment': 'Please open an issue for this.', 'commenter': 'oscerd'}]"
7615,components/camel-azure/camel-azure-storage-blob/src/main/java/org/apache/camel/component/azure/storage/blob/CredentialType.java,"@@ -0,0 +1,39 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.azure.storage.blob;
+
+public enum CredentialType {
+    /**
+     * Shared key credential
+     * @see com.azure.storage.common.StorageSharedKeyCredential
+     */
+    shared_key_credential,
+    /**
+     * storage shared account key
+     */
+    shared_account_key,","[{'comment': 'Same', 'commenter': 'oscerd'}]"
7615,components/camel-azure/camel-azure-storage-blob/src/main/java/org/apache/camel/component/azure/storage/blob/CredentialType.java,"@@ -0,0 +1,39 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.azure.storage.blob;
+
+public enum CredentialType {
+    /**
+     * Shared key credential
+     * @see com.azure.storage.common.StorageSharedKeyCredential
+     */
+    shared_key_credential,
+    /**
+     * storage shared account key
+     */
+    shared_account_key,
+    /**
+     * Includes:
+     * <uL>
+     *     <li>Service principal with secret</li>
+     *     <li>Service principal with certificate</li>
+     *     <li>username and password</li>
+     * </uL>
+     * @see com.azure.identity.DefaultAzureCredentialBuilder
+     */
+    azure_identity","[{'comment': 'Same', 'commenter': 'oscerd'}]"
7683,components/camel-whatsapp/src/main/java/org/apache/camel/component/whatsapp/service/WhatsAppServiceRestAPIAdapter.java,"@@ -0,0 +1,285 @@
+package org.apache.camel.component.whatsapp.service;
+
+import static org.asynchttpclient.util.HttpUtils.extractContentTypeCharsetAttribute;
+import static org.asynchttpclient.util.MiscUtils.withDefault;
+
+import org.apache.camel.AsyncCallback;
+import org.apache.camel.Exchange;
+import org.apache.camel.RuntimeCamelException;
+import org.apache.camel.component.whatsapp.WhatsAppService;
+import org.apache.camel.component.whatsapp.model.BaseMessage;
+import org.apache.camel.component.whatsapp.model.ContactMessageRequest;
+import org.apache.camel.component.whatsapp.model.InteractiveMessageRequest;
+import org.apache.camel.component.whatsapp.model.LocationMessageRequest;
+import org.apache.camel.component.whatsapp.model.MediaMessageRequest;
+import org.apache.camel.component.whatsapp.model.MessageResponse;
+import org.apache.camel.component.whatsapp.model.TextMessageRequest;
+import org.apache.camel.component.whatsapp.model.UploadMediaRequest;
+import org.apache.camel.support.GZIPHelper;
+import org.apache.camel.util.IOHelper;
+
+import org.asynchttpclient.AsyncHandler;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.HttpResponseBodyPart;
+import org.asynchttpclient.HttpResponseStatus;
+import org.asynchttpclient.RequestBuilder;
+import org.asynchttpclient.request.body.multipart.ByteArrayPart;
+import org.asynchttpclient.request.body.multipart.FilePart;
+import org.asynchttpclient.request.body.multipart.MultipartUtils;
+import org.asynchttpclient.request.body.multipart.StringPart;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import com.fasterxml.jackson.annotation.JsonInclude;
+import com.fasterxml.jackson.core.JsonProcessingException;
+import com.fasterxml.jackson.databind.ObjectMapper;
+import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;
+
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.Reader;
+import java.nio.charset.Charset;
+import java.nio.charset.StandardCharsets;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import io.netty.handler.codec.http.HttpHeaders;
+
+public class WhatsAppServiceRestAPIAdapter implements WhatsAppService {
+	private static final Logger LOG = LoggerFactory.getLogger(WhatsAppServiceRestAPIAdapter.class);
+
+	private final Map<Class<?>, WhatsAppServiceRestAPIAdapter.OutgoingMessageHandler<?>> handlers;
+	private final AsyncHttpClient asyncHttpClient;
+	private final ObjectMapper mapper;
+	private final String baseUri;
+	private final String authorizationToken;
+
+	public WhatsAppServiceRestAPIAdapter(AsyncHttpClient client, String baseUri, String apiVersion, String phoneNumberId, String authorizationToken) {
+		this.asyncHttpClient = client;
+		this.baseUri = baseUri + ""/"" + apiVersion + ""/"" + phoneNumberId;
+		this.mapper = new ObjectMapper().registerModule(new JavaTimeModule());
+		this.mapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);
+		this.authorizationToken = authorizationToken;
+
+		int bufferSize = 4 * 1024;
+
+		final Map<Class<?>, WhatsAppServiceRestAPIAdapter.OutgoingMessageHandler<?>> m = new HashMap<>();
+		m.put(TextMessageRequest.class, new OutgoingPlainMessageHandler(client, bufferSize, mapper, this.baseUri + ""/messages""));","[{'comment': 'Maybe use a constant for the `/messages` endpoint? ', 'commenter': 'orpiske'}]"
7683,components/camel-whatsapp/src/main/java/org/apache/camel/component/whatsapp/service/WhatsAppServiceRestAPIAdapter.java,"@@ -0,0 +1,285 @@
+package org.apache.camel.component.whatsapp.service;
+
+import static org.asynchttpclient.util.HttpUtils.extractContentTypeCharsetAttribute;
+import static org.asynchttpclient.util.MiscUtils.withDefault;
+
+import org.apache.camel.AsyncCallback;
+import org.apache.camel.Exchange;
+import org.apache.camel.RuntimeCamelException;
+import org.apache.camel.component.whatsapp.WhatsAppService;
+import org.apache.camel.component.whatsapp.model.BaseMessage;
+import org.apache.camel.component.whatsapp.model.ContactMessageRequest;
+import org.apache.camel.component.whatsapp.model.InteractiveMessageRequest;
+import org.apache.camel.component.whatsapp.model.LocationMessageRequest;
+import org.apache.camel.component.whatsapp.model.MediaMessageRequest;
+import org.apache.camel.component.whatsapp.model.MessageResponse;
+import org.apache.camel.component.whatsapp.model.TextMessageRequest;
+import org.apache.camel.component.whatsapp.model.UploadMediaRequest;
+import org.apache.camel.support.GZIPHelper;
+import org.apache.camel.util.IOHelper;
+
+import org.asynchttpclient.AsyncHandler;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.HttpResponseBodyPart;
+import org.asynchttpclient.HttpResponseStatus;
+import org.asynchttpclient.RequestBuilder;
+import org.asynchttpclient.request.body.multipart.ByteArrayPart;
+import org.asynchttpclient.request.body.multipart.FilePart;
+import org.asynchttpclient.request.body.multipart.MultipartUtils;
+import org.asynchttpclient.request.body.multipart.StringPart;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import com.fasterxml.jackson.annotation.JsonInclude;
+import com.fasterxml.jackson.core.JsonProcessingException;
+import com.fasterxml.jackson.databind.ObjectMapper;
+import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;
+
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.Reader;
+import java.nio.charset.Charset;
+import java.nio.charset.StandardCharsets;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import io.netty.handler.codec.http.HttpHeaders;
+
+public class WhatsAppServiceRestAPIAdapter implements WhatsAppService {
+	private static final Logger LOG = LoggerFactory.getLogger(WhatsAppServiceRestAPIAdapter.class);
+
+	private final Map<Class<?>, WhatsAppServiceRestAPIAdapter.OutgoingMessageHandler<?>> handlers;
+	private final AsyncHttpClient asyncHttpClient;
+	private final ObjectMapper mapper;
+	private final String baseUri;
+	private final String authorizationToken;
+
+	public WhatsAppServiceRestAPIAdapter(AsyncHttpClient client, String baseUri, String apiVersion, String phoneNumberId, String authorizationToken) {
+		this.asyncHttpClient = client;
+		this.baseUri = baseUri + ""/"" + apiVersion + ""/"" + phoneNumberId;
+		this.mapper = new ObjectMapper().registerModule(new JavaTimeModule());
+		this.mapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);
+		this.authorizationToken = authorizationToken;
+
+		int bufferSize = 4 * 1024;
+
+		final Map<Class<?>, WhatsAppServiceRestAPIAdapter.OutgoingMessageHandler<?>> m = new HashMap<>();
+		m.put(TextMessageRequest.class, new OutgoingPlainMessageHandler(client, bufferSize, mapper, this.baseUri + ""/messages""));
+		m.put(MediaMessageRequest.class, new OutgoingPlainMessageHandler(client, bufferSize, mapper, this.baseUri + ""/messages""));
+		m.put(LocationMessageRequest.class, new OutgoingPlainMessageHandler(client, bufferSize, mapper, this.baseUri + ""/messages""));
+		m.put(ContactMessageRequest.class, new OutgoingPlainMessageHandler(client, bufferSize, mapper, this.baseUri + ""/messages""));
+		m.put(InteractiveMessageRequest.class, new OutgoingPlainMessageHandler(client, bufferSize, mapper, this.baseUri + ""/messages""));
+		m.put(UploadMediaRequest.class, new OutgoingMediaMessageHandler(client, bufferSize, mapper, this.baseUri + ""/media""));
+
+		this.handlers = m;
+	}
+
+	@Override
+	public void sendMessage(Exchange exchange, AsyncCallback callback, BaseMessage message) {
+		final WhatsAppServiceRestAPIAdapter.OutgoingMessageHandler<BaseMessage> handler =
+				(WhatsAppServiceRestAPIAdapter.OutgoingMessageHandler<BaseMessage>) handlers.get(message.getClass());
+		if (handler == null) {
+			throw new IllegalArgumentException(
+					""Unsupported message type "" + (message.getClass().getName()));
+		}","[{'comment': 'You can use `ObjectHelper.notNull` here.', 'commenter': 'orpiske'}]"
7683,components/camel-whatsapp/src/main/java/org/apache/camel/component/whatsapp/service/WhatsAppServiceRestAPIAdapter.java,"@@ -0,0 +1,285 @@
+package org.apache.camel.component.whatsapp.service;
+
+import static org.asynchttpclient.util.HttpUtils.extractContentTypeCharsetAttribute;
+import static org.asynchttpclient.util.MiscUtils.withDefault;
+
+import org.apache.camel.AsyncCallback;
+import org.apache.camel.Exchange;
+import org.apache.camel.RuntimeCamelException;
+import org.apache.camel.component.whatsapp.WhatsAppService;
+import org.apache.camel.component.whatsapp.model.BaseMessage;
+import org.apache.camel.component.whatsapp.model.ContactMessageRequest;
+import org.apache.camel.component.whatsapp.model.InteractiveMessageRequest;
+import org.apache.camel.component.whatsapp.model.LocationMessageRequest;
+import org.apache.camel.component.whatsapp.model.MediaMessageRequest;
+import org.apache.camel.component.whatsapp.model.MessageResponse;
+import org.apache.camel.component.whatsapp.model.TextMessageRequest;
+import org.apache.camel.component.whatsapp.model.UploadMediaRequest;
+import org.apache.camel.support.GZIPHelper;
+import org.apache.camel.util.IOHelper;
+
+import org.asynchttpclient.AsyncHandler;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.HttpResponseBodyPart;
+import org.asynchttpclient.HttpResponseStatus;
+import org.asynchttpclient.RequestBuilder;
+import org.asynchttpclient.request.body.multipart.ByteArrayPart;
+import org.asynchttpclient.request.body.multipart.FilePart;
+import org.asynchttpclient.request.body.multipart.MultipartUtils;
+import org.asynchttpclient.request.body.multipart.StringPart;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import com.fasterxml.jackson.annotation.JsonInclude;
+import com.fasterxml.jackson.core.JsonProcessingException;
+import com.fasterxml.jackson.databind.ObjectMapper;
+import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;
+
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.Reader;
+import java.nio.charset.Charset;
+import java.nio.charset.StandardCharsets;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import io.netty.handler.codec.http.HttpHeaders;
+
+public class WhatsAppServiceRestAPIAdapter implements WhatsAppService {
+	private static final Logger LOG = LoggerFactory.getLogger(WhatsAppServiceRestAPIAdapter.class);
+
+	private final Map<Class<?>, WhatsAppServiceRestAPIAdapter.OutgoingMessageHandler<?>> handlers;
+	private final AsyncHttpClient asyncHttpClient;
+	private final ObjectMapper mapper;
+	private final String baseUri;
+	private final String authorizationToken;
+
+	public WhatsAppServiceRestAPIAdapter(AsyncHttpClient client, String baseUri, String apiVersion, String phoneNumberId, String authorizationToken) {
+		this.asyncHttpClient = client;
+		this.baseUri = baseUri + ""/"" + apiVersion + ""/"" + phoneNumberId;
+		this.mapper = new ObjectMapper().registerModule(new JavaTimeModule());
+		this.mapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);
+		this.authorizationToken = authorizationToken;
+
+		int bufferSize = 4 * 1024;
+
+		final Map<Class<?>, WhatsAppServiceRestAPIAdapter.OutgoingMessageHandler<?>> m = new HashMap<>();
+		m.put(TextMessageRequest.class, new OutgoingPlainMessageHandler(client, bufferSize, mapper, this.baseUri + ""/messages""));
+		m.put(MediaMessageRequest.class, new OutgoingPlainMessageHandler(client, bufferSize, mapper, this.baseUri + ""/messages""));
+		m.put(LocationMessageRequest.class, new OutgoingPlainMessageHandler(client, bufferSize, mapper, this.baseUri + ""/messages""));
+		m.put(ContactMessageRequest.class, new OutgoingPlainMessageHandler(client, bufferSize, mapper, this.baseUri + ""/messages""));
+		m.put(InteractiveMessageRequest.class, new OutgoingPlainMessageHandler(client, bufferSize, mapper, this.baseUri + ""/messages""));
+		m.put(UploadMediaRequest.class, new OutgoingMediaMessageHandler(client, bufferSize, mapper, this.baseUri + ""/media""));
+
+		this.handlers = m;
+	}
+
+	@Override
+	public void sendMessage(Exchange exchange, AsyncCallback callback, BaseMessage message) {
+		final WhatsAppServiceRestAPIAdapter.OutgoingMessageHandler<BaseMessage> handler =
+				(WhatsAppServiceRestAPIAdapter.OutgoingMessageHandler<BaseMessage>) handlers.get(message.getClass());
+		if (handler == null) {
+			throw new IllegalArgumentException(
+					""Unsupported message type "" + (message.getClass().getName()));
+		}
+		handler.sendMessage(exchange, callback, message, authorizationToken);
+	}
+
+	static class OutgoingMediaMessageHandler extends WhatsAppServiceRestAPIAdapter.OutgoingMessageHandler<UploadMediaRequest> {
+
+		public OutgoingMediaMessageHandler(AsyncHttpClient asyncHttpClient, int bufferSize, ObjectMapper mapper,
+				String uri, Class<? extends MessageResponse> returnType) {
+			super(asyncHttpClient, bufferSize, mapper, uri, ""multipart/form-data"", returnType);
+		}
+
+		public OutgoingMediaMessageHandler(AsyncHttpClient asyncHttpClient, int bufferSize, ObjectMapper mapper,
+				String uri) {
+			this(asyncHttpClient, bufferSize, mapper, uri, MessageResponse.class);
+		}
+
+		@Override
+		protected void addBody(RequestBuilder builder, UploadMediaRequest message) {
+			FilePart filePart = new FilePart(""file"", message.getUploadMedia().getFile(), message.getUploadMedia().getContentType());
+			builder.setBodyParts(List.of(
+					filePart,
+					new StringPart(""messaging_product"", ""whatsapp"")
+			));
+		}
+
+	}
+
+	static class OutgoingPlainMessageHandler extends WhatsAppServiceRestAPIAdapter.OutgoingMessageHandler<BaseMessage> {
+
+		public OutgoingPlainMessageHandler(AsyncHttpClient asyncHttpClient, int bufferSize, ObjectMapper mapper,
+				String uri, Class<? extends MessageResponse> returnType) {
+			super(asyncHttpClient, bufferSize, mapper, uri, ""application/json"", returnType);
+		}
+
+		public OutgoingPlainMessageHandler(AsyncHttpClient asyncHttpClient, int bufferSize, ObjectMapper mapper,
+				String uri) {
+			this(asyncHttpClient, bufferSize, mapper, uri, MessageResponse.class);
+		}
+
+		@Override
+		protected void addBody(RequestBuilder builder, BaseMessage message) {
+			try {
+				final String body = mapper.writeValueAsString(message);
+				builder.setBody(body);
+			} catch (JsonProcessingException e) {
+				throw new RuntimeCamelException(""Could not serialize "" + message, e);
+			}
+		}
+
+	}
+
+	abstract static class OutgoingMessageHandler<T extends BaseMessage> {
+		protected final ObjectMapper mapper;
+		private final AsyncHttpClient asyncHttpClient;
+		private final int bufferSize;
+		private final String contentType;
+		private final String uri;
+		private final Class<? extends MessageResponse> resultClass;
+
+		public OutgoingMessageHandler(AsyncHttpClient asyncHttpClient, int bufferSize, ObjectMapper mapper, String uri,
+				String contentType, Class<? extends MessageResponse> resultClass) {
+			this.resultClass = resultClass;
+			this.asyncHttpClient = asyncHttpClient;
+			this.bufferSize = bufferSize;
+			this.mapper = mapper;
+			this.uri = uri;
+			this.contentType = contentType;
+		}
+
+		public void sendMessage(Exchange exchange, AsyncCallback callback, T message, String authorizationToken) {
+			final RequestBuilder builder = new RequestBuilder(""POST"")
+					.setUrl(uri);
+			if (contentType != null) {
+				builder.setHeader(""Content-Type"", contentType);
+			}
+			builder.setHeader(""Authorization"", ""Bearer "" + authorizationToken);
+			builder.setHeader(""Accept"", ""application/json"");","[{'comment': 'Header constants, if they are available in one of the libraries in use, can make the code easier to read/maintain.', 'commenter': 'orpiske'}]"
7683,components/camel-whatsapp/src/test/java/org/apache/camel/component/whatsapp/WhatsAppApiConfig.java,"@@ -0,0 +1,72 @@
+/*
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ */
+
+package org.apache.camel.component.whatsapp;
+
+public class WhatsAppApiConfig {
+
+	private final String authorizationToken;
+	private final int port;
+	private final String baseUri;
+	private final String phoneNumberId;
+	private final String apiVersion;
+	private final String recipientPhoneNumber;
+
+	public WhatsAppApiConfig(String baseUri, int port, String authorizationToken, String phoneNumberId, String apiVersion, String recipientPhoneNumber) {
+		this.baseUri = baseUri;
+		this.port = port;
+		this.authorizationToken = authorizationToken;
+		this.phoneNumberId = phoneNumberId;
+		this.apiVersion = apiVersion;
+		this.recipientPhoneNumber = recipientPhoneNumber;
+	}
+
+	public static WhatsAppApiConfig fromEnv() {
+		final String authorizationToken = System.getenv(""WHATSAPP_AUTHORIZATION_TOKEN"");
+		final String phoneNumberId = System.getenv(""WHATSAPP_PHONE_NUMBER_ID"");
+		final String recipientPhoneNumber = System.getenv(""WHATSAPP_RECIPIENT_PHONE_NUMBER"");
+		return new WhatsAppApiConfig(WhatsAppComponent.API_DEFAULT_URL, 443, authorizationToken, phoneNumberId, WhatsAppComponent.API_DEFAULT_VERSION, recipientPhoneNumber);","[{'comment': 'If possible, try not to use a fixed port as it breaks the tests on some CIs if the port is used (and, also, 443 is a privileged port that would require root access). Take a look at the `AvailablePortFinder` class for this.', 'commenter': 'orpiske'}, {'comment': ""I'm using 443 here because this method is used for real integration tests against `https://graph.facebook.com` I will create another configuration that will be used for mocked test with `AvailablePortFinder`, thank you for the hint!"", 'commenter': 'Croway'}]"
7683,components/camel-whatsapp/src/main/java/org/apache/camel/component/whatsapp/WhatsAppProducer.java,"@@ -0,0 +1,65 @@
+/*
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ */
+
+package org.apache.camel.component.whatsapp;
+
+import org.apache.camel.AsyncCallback;
+import org.apache.camel.Exchange;
+import org.apache.camel.component.whatsapp.model.BaseMessage;
+import org.apache.camel.component.whatsapp.model.TextMessageRequest;
+import org.apache.camel.support.DefaultAsyncProducer;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class WhatsAppProducer extends DefaultAsyncProducer {
+	private static final Logger LOG = LoggerFactory.getLogger(WhatsAppProducer.class);
+
+	private WhatsAppEndpoint endpoint;
+
+	public WhatsAppProducer(WhatsAppEndpoint endpoint) {
+		super(endpoint);
+		this.endpoint = endpoint;
+	}
+
+	@Override
+	public boolean process(Exchange exchange, AsyncCallback callback) {
+		if (exchange.getIn().getBody() == null) {
+			// fail fast
+			LOG.debug(""Received exchange with empty body, skipping"");
+			callback.done(true);
+			return true;
+		}
+
+		WhatsAppConfiguration config = endpoint.getConfiguration();
+
+		// Tries to get a message in its OutgoingMessage format
+		// Automatic conversion applies here
+		BaseMessage message = exchange.getIn().getBody(BaseMessage.class);
+		if (message == null) {
+			throw new IllegalArgumentException(""Cannot convert the content to a WhatsApp MessageRequest"");
+		}","[{'comment': 'I think you can use `ObjectHelper.notNull` here. ', 'commenter': 'orpiske'}]"
7683,components/camel-whatsapp/src/main/java/org/apache/camel/component/whatsapp/WhatsAppProducer.java,"@@ -0,0 +1,65 @@
+/*
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ */
+
+package org.apache.camel.component.whatsapp;
+
+import org.apache.camel.AsyncCallback;
+import org.apache.camel.Exchange;
+import org.apache.camel.component.whatsapp.model.BaseMessage;
+import org.apache.camel.component.whatsapp.model.TextMessageRequest;
+import org.apache.camel.support.DefaultAsyncProducer;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class WhatsAppProducer extends DefaultAsyncProducer {
+	private static final Logger LOG = LoggerFactory.getLogger(WhatsAppProducer.class);
+
+	private WhatsAppEndpoint endpoint;
+
+	public WhatsAppProducer(WhatsAppEndpoint endpoint) {
+		super(endpoint);
+		this.endpoint = endpoint;
+	}
+
+	@Override
+	public boolean process(Exchange exchange, AsyncCallback callback) {
+		if (exchange.getIn().getBody() == null) {
+			// fail fast
+			LOG.debug(""Received exchange with empty body, skipping"");
+			callback.done(true);
+			return true;
+		}
+
+		WhatsAppConfiguration config = endpoint.getConfiguration();
+
+		// Tries to get a message in its OutgoingMessage format
+		// Automatic conversion applies here
+		BaseMessage message = exchange.getIn().getBody(BaseMessage.class);
+		if (message == null) {
+			throw new IllegalArgumentException(""Cannot convert the content to a WhatsApp MessageRequest"");
+		}
+
+		final WhatsAppService service = endpoint.getWhatsappService();
+
+		LOG.debug(""Message being sent is: {}"", message);
+		LOG.debug(""Headers of message being sent are: {}"", exchange.getIn().getHeaders());
+
+		service.sendMessage(exchange, callback, message);","[{'comment': 'Is there a change of `service` being `null` here? It does not look like the case, so ... just double checking.', 'commenter': 'orpiske'}, {'comment': 'an implementation is always provided in `WhatsAppEndpoint.doStart()`', 'commenter': 'Croway'}]"
7683,components/camel-whatsapp/src/main/java/org/apache/camel/component/whatsapp/service/WhatsAppServiceRestAPIAdapter.java,"@@ -0,0 +1,285 @@
+package org.apache.camel.component.whatsapp.service;
+
+import static org.asynchttpclient.util.HttpUtils.extractContentTypeCharsetAttribute;
+import static org.asynchttpclient.util.MiscUtils.withDefault;
+
+import org.apache.camel.AsyncCallback;
+import org.apache.camel.Exchange;
+import org.apache.camel.RuntimeCamelException;
+import org.apache.camel.component.whatsapp.WhatsAppService;
+import org.apache.camel.component.whatsapp.model.BaseMessage;
+import org.apache.camel.component.whatsapp.model.ContactMessageRequest;
+import org.apache.camel.component.whatsapp.model.InteractiveMessageRequest;
+import org.apache.camel.component.whatsapp.model.LocationMessageRequest;
+import org.apache.camel.component.whatsapp.model.MediaMessageRequest;
+import org.apache.camel.component.whatsapp.model.MessageResponse;
+import org.apache.camel.component.whatsapp.model.TextMessageRequest;
+import org.apache.camel.component.whatsapp.model.UploadMediaRequest;
+import org.apache.camel.support.GZIPHelper;
+import org.apache.camel.util.IOHelper;
+
+import org.asynchttpclient.AsyncHandler;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.HttpResponseBodyPart;
+import org.asynchttpclient.HttpResponseStatus;
+import org.asynchttpclient.RequestBuilder;
+import org.asynchttpclient.request.body.multipart.ByteArrayPart;
+import org.asynchttpclient.request.body.multipart.FilePart;
+import org.asynchttpclient.request.body.multipart.MultipartUtils;
+import org.asynchttpclient.request.body.multipart.StringPart;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import com.fasterxml.jackson.annotation.JsonInclude;
+import com.fasterxml.jackson.core.JsonProcessingException;
+import com.fasterxml.jackson.databind.ObjectMapper;
+import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;
+
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.Reader;
+import java.nio.charset.Charset;
+import java.nio.charset.StandardCharsets;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import io.netty.handler.codec.http.HttpHeaders;
+
+public class WhatsAppServiceRestAPIAdapter implements WhatsAppService {
+	private static final Logger LOG = LoggerFactory.getLogger(WhatsAppServiceRestAPIAdapter.class);
+
+	private final Map<Class<?>, WhatsAppServiceRestAPIAdapter.OutgoingMessageHandler<?>> handlers;
+	private final AsyncHttpClient asyncHttpClient;
+	private final ObjectMapper mapper;
+	private final String baseUri;
+	private final String authorizationToken;
+
+	public WhatsAppServiceRestAPIAdapter(AsyncHttpClient client, String baseUri, String apiVersion, String phoneNumberId, String authorizationToken) {
+		this.asyncHttpClient = client;
+		this.baseUri = baseUri + ""/"" + apiVersion + ""/"" + phoneNumberId;
+		this.mapper = new ObjectMapper().registerModule(new JavaTimeModule());
+		this.mapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);
+		this.authorizationToken = authorizationToken;
+
+		int bufferSize = 4 * 1024;","[{'comment': 'Any particular reason for this specific buffer size?', 'commenter': 'orpiske'}, {'comment': ""I don't think so, I removed it, moreover I'll try to use java11 http client in order to implement this service"", 'commenter': 'Croway'}]"
7683,components/camel-whatsapp/src/main/java/org/apache/camel/component/whatsapp/WhatsAppComponent.java,"@@ -0,0 +1,125 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.whatsapp;
+
+import java.util.Map;
+
+import org.apache.camel.Endpoint;
+import org.apache.camel.spi.Metadata;
+import org.apache.camel.spi.annotations.Component;
+import org.apache.camel.support.DefaultComponent;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+
+@Component(""whatsapp"")
+public class WhatsAppComponent extends DefaultComponent {
+
+    public static final String API_DEFAULT_URL = ""https://graph.facebook.com"";
+    public static final String API_DEFAULT_VERSION = ""v13.0"";
+
+    @Metadata(required = true, description = ""TODO"")
+    private String phoneNumberId;
+    @Metadata(label = ""security"", secret = true, required = true, description = ""TODO"")
+    private String authorizationToken;
+
+    @Metadata(label = ""advanced"", description = ""TODO"")
+    private AsyncHttpClient client;
+    @Metadata(label = ""advanced"", description = ""TODO"")
+    private AsyncHttpClientConfig clientConfig;
+    @Metadata(label = ""advanced"", defaultValue = API_DEFAULT_URL,
+              description = ""Can be used to set an alternative base URI, e.g. when you want to test the component against a mock WhatsApp API"")
+    private String baseUri = API_DEFAULT_URL;
+    @Metadata(label = ""advanced"", defaultValue = API_DEFAULT_VERSION, description = ""TODO"")","[{'comment': 'Please remove the TODO here.', 'commenter': 'oscerd'}]"
7683,components/camel-whatsapp/src/main/java/org/apache/camel/component/whatsapp/WhatsAppConstants.java,"@@ -0,0 +1,31 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.whatsapp;
+
+import org.apache.camel.spi.Metadata;
+
+public final class WhatsAppConstants {
+
+    @Metadata(label = ""producer"", description = ""TODO"", javaType = ""Object"")","[{'comment': 'Remove todo', 'commenter': 'oscerd'}]"
7683,components/camel-whatsapp/src/main/java/org/apache/camel/component/whatsapp/WhatsAppConstants.java,"@@ -0,0 +1,31 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.whatsapp;
+
+import org.apache.camel.spi.Metadata;
+
+public final class WhatsAppConstants {
+
+    @Metadata(label = ""producer"", description = ""TODO"", javaType = ""Object"")
+    public static final String WHATSAPP_PHONE_NUMBER_ID = ""CamelWhatsAppPhoneNumberId"";
+
+    @Metadata(label = ""producer"", description = ""TODO"", javaType = ""Object"")","[{'comment': 'Remove todo', 'commenter': 'oscerd'}]"
7683,components/camel-whatsapp/src/main/java/org/apache/camel/component/whatsapp/WhatsAppEndpoint.java,"@@ -0,0 +1,159 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.whatsapp;
+
+import java.net.http.HttpClient;
+import java.time.Duration;
+
+import org.apache.camel.Category;
+import org.apache.camel.Component;
+import org.apache.camel.Consumer;
+import org.apache.camel.Processor;
+import org.apache.camel.Producer;
+import org.apache.camel.component.whatsapp.service.WhatsAppServiceRestAPIJDKAdapter;
+import org.apache.camel.spi.UriEndpoint;
+import org.apache.camel.spi.UriParam;
+import org.apache.camel.support.ScheduledPollEndpoint;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.DefaultAsyncHttpClient;
+import org.asynchttpclient.DefaultAsyncHttpClientConfig;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * Send and receive messages.
+ */
+@UriEndpoint(firstVersion = ""2.18.0"", scheme = ""whatsapp"", title = ""WhatsApp"", syntax = ""whatsapp:type"",
+             category = {
+                     Category.CLOUD, Category.API,
+                     Category.CHAT },
+             headersClass = WhatsAppConstants.class)
+public class WhatsAppEndpoint extends ScheduledPollEndpoint {
+    private static final Logger LOG = LoggerFactory.getLogger(WhatsAppEndpoint.class);
+
+    @UriParam
+    private WhatsAppConfiguration configuration;
+    @UriParam(label = ""advanced"", description = ""TODO"")","[{'comment': 'Please remove the todo', 'commenter': 'oscerd'}]"
7683,components/camel-whatsapp/src/main/java/org/apache/camel/component/whatsapp/WhatsAppEndpoint.java,"@@ -0,0 +1,159 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.whatsapp;
+
+import java.net.http.HttpClient;
+import java.time.Duration;
+
+import org.apache.camel.Category;
+import org.apache.camel.Component;
+import org.apache.camel.Consumer;
+import org.apache.camel.Processor;
+import org.apache.camel.Producer;
+import org.apache.camel.component.whatsapp.service.WhatsAppServiceRestAPIJDKAdapter;
+import org.apache.camel.spi.UriEndpoint;
+import org.apache.camel.spi.UriParam;
+import org.apache.camel.support.ScheduledPollEndpoint;
+import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClientConfig;
+import org.asynchttpclient.DefaultAsyncHttpClient;
+import org.asynchttpclient.DefaultAsyncHttpClientConfig;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * Send and receive messages.
+ */
+@UriEndpoint(firstVersion = ""2.18.0"", scheme = ""whatsapp"", title = ""WhatsApp"", syntax = ""whatsapp:type"",","[{'comment': 'First version is 3.18.0', 'commenter': 'oscerd'}]"
7683,components/camel-whatsapp/src/main/java/org/apache/camel/component/whatsapp/service/WhatsAppServiceRestAPIJDKAdapter.java,"@@ -0,0 +1,244 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.whatsapp.service;
+
+import java.io.IOException;
+import java.math.BigInteger;
+import java.net.URI;
+import java.net.http.HttpClient;
+import java.net.http.HttpRequest;
+import java.net.http.HttpRequest.BodyPublisher;
+import java.net.http.HttpRequest.BodyPublishers;
+import java.net.http.HttpRequest.Builder;
+import java.net.http.HttpResponse;
+import java.nio.charset.StandardCharsets;
+import java.nio.file.Files;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Random;
+import java.util.concurrent.CompletableFuture;
+
+import com.fasterxml.jackson.annotation.JsonInclude;
+import com.fasterxml.jackson.core.JsonProcessingException;
+import com.fasterxml.jackson.databind.ObjectMapper;
+import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;
+import org.apache.camel.AsyncCallback;
+import org.apache.camel.Exchange;
+import org.apache.camel.RuntimeCamelException;
+import org.apache.camel.component.whatsapp.WhatsAppService;
+import org.apache.camel.component.whatsapp.model.BaseMessage;
+import org.apache.camel.component.whatsapp.model.ContactMessageRequest;
+import org.apache.camel.component.whatsapp.model.InteractiveMessageRequest;
+import org.apache.camel.component.whatsapp.model.LocationMessageRequest;
+import org.apache.camel.component.whatsapp.model.MediaMessageRequest;
+import org.apache.camel.component.whatsapp.model.MessageResponse;
+import org.apache.camel.component.whatsapp.model.TemplateMessageRequest;
+import org.apache.camel.component.whatsapp.model.TextMessageRequest;
+import org.apache.camel.component.whatsapp.model.UploadMedia;
+import org.apache.camel.component.whatsapp.model.UploadMediaRequest;
+import org.apache.camel.util.ObjectHelper;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * Java11 Http Client implementation
+ */
+public class WhatsAppServiceRestAPIJDKAdapter implements WhatsAppService {
+    private static final Logger LOG = LoggerFactory.getLogger(WhatsAppServiceRestAPIJDKAdapter.class);
+
+    private static final String MESSAGES_ENDPOINT = ""/messages"";
+    private static final String MEDIA_ENDPOINT = ""/media"";
+
+    private final Map<Class<?>, WhatsAppServiceRestAPIJDKAdapter.OutgoingMessageHandler<?>> handlers;
+    private final ObjectMapper mapper;
+    private final String baseUri;
+    private final String authorizationToken;
+
+    public WhatsAppServiceRestAPIJDKAdapter(HttpClient client, String baseUri, String apiVersion, String phoneNumberId,
+                                            String authorizationToken) {
+        this.baseUri = baseUri + ""/"" + apiVersion + ""/"" + phoneNumberId;
+        this.mapper = new ObjectMapper().registerModule(new JavaTimeModule());
+        this.mapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);
+        this.authorizationToken = authorizationToken;
+
+        final Map<Class<?>, WhatsAppServiceRestAPIJDKAdapter.OutgoingMessageHandler<?>> m = new HashMap<>();
+        m.put(TextMessageRequest.class, new OutgoingPlainMessageHandler(client, mapper, this.baseUri + MESSAGES_ENDPOINT));
+        m.put(MediaMessageRequest.class, new OutgoingPlainMessageHandler(client, mapper, this.baseUri + MESSAGES_ENDPOINT));
+        m.put(LocationMessageRequest.class, new OutgoingPlainMessageHandler(client, mapper, this.baseUri + MESSAGES_ENDPOINT));
+        m.put(ContactMessageRequest.class, new OutgoingPlainMessageHandler(client, mapper, this.baseUri + MESSAGES_ENDPOINT));
+        m.put(InteractiveMessageRequest.class,
+                new OutgoingPlainMessageHandler(client, mapper, this.baseUri + MESSAGES_ENDPOINT));
+        m.put(UploadMediaRequest.class, new OutgoingMediaMessageHandler(client, mapper, this.baseUri + MEDIA_ENDPOINT));
+        m.put(TemplateMessageRequest.class, new OutgoingPlainMessageHandler(client, mapper, this.baseUri + MESSAGES_ENDPOINT));
+
+        this.handlers = m;
+    }
+
+    @Override
+    public void sendMessage(Exchange exchange, AsyncCallback callback, BaseMessage message) {
+        @SuppressWarnings(""unchecked"")
+        final WhatsAppServiceRestAPIJDKAdapter.OutgoingMessageHandler<BaseMessage> handler
+                = (WhatsAppServiceRestAPIJDKAdapter.OutgoingMessageHandler<BaseMessage>) handlers
+                        .get(message.getClass());
+
+        ObjectHelper.notNull(handler, ""handler"");
+
+        try {
+            handler.sendMessage(exchange, callback, message, authorizationToken);
+        } catch (IOException | InterruptedException e) {
+            throw new RuntimeCamelException(""Could not send message "" + message, e);
+        }
+    }
+
+    static class OutgoingMediaMessageHandler
+            extends WhatsAppServiceRestAPIJDKAdapter.OutgoingMessageHandler<UploadMediaRequest> {
+
+        public OutgoingMediaMessageHandler(HttpClient httpClient, ObjectMapper mapper, String uri,
+                                           Class<? extends MessageResponse> resultClass) {
+            super(httpClient, mapper, uri, null, resultClass);
+        }
+
+        public OutgoingMediaMessageHandler(HttpClient httpClient, ObjectMapper mapper, String uri) {
+            this(httpClient, mapper, uri, MessageResponse.class);
+        }
+
+        @Override
+        protected void addBody(Builder builder, UploadMediaRequest message) {
+            Map<Object, Object> formData = new HashMap<>();
+            formData.put(""messaging_product"", ""whatsapp"");
+            formData.put(""file"", message.getUploadMedia());
+
+            String boundary = new BigInteger(256, new Random()).toString();
+            try {
+                builder.POST(ofMimeMultipartData(formData, boundary));
+            } catch (IOException e) {
+                throw new RuntimeCamelException(""Could not serialize "" + message, e);
+            }
+
+            builder.header(""content-type"", ""multipart/form-data; boundary="" + boundary);
+        }
+
+        public static BodyPublisher ofMimeMultipartData(Map<Object, Object> data, String boundary) throws IOException {
+            var byteArrays = new ArrayList<byte[]>();
+            byte[] separator = (""--"" + boundary + ""\r\nContent-Disposition: form-data; name="").getBytes(StandardCharsets.UTF_8);
+            for (Map.Entry<Object, Object> entry : data.entrySet()) {
+                byteArrays.add(separator);
+
+                if (entry.getValue() instanceof UploadMedia) {
+                    UploadMedia uploadMedia = (UploadMedia) entry.getValue();
+                    byteArrays.add((""\"""" + entry.getKey() + ""\""; filename=\"""" + uploadMedia.getFile().toPath().getFileName()
+                                    + ""\""\r\nContent-Type: "" + uploadMedia.getContentType()
+                                    + ""\r\n\r\n"").getBytes(StandardCharsets.UTF_8));
+                    byteArrays.add(Files.readAllBytes(uploadMedia.getFile().toPath()));
+                    byteArrays.add(""\r\n"".getBytes(StandardCharsets.UTF_8));
+                } else {
+                    byteArrays.add((""\"""" + entry.getKey() + ""\""\r\n\r\n"" + entry.getValue() + ""\r\n"")
+                            .getBytes(StandardCharsets.UTF_8));
+                }
+            }
+            byteArrays.add((""--"" + boundary + ""--\r\n"").getBytes(StandardCharsets.UTF_8));
+            return BodyPublishers.ofByteArrays(byteArrays);","[{'comment': ""I'd avoid working directly with bytes here. Instead, I think you can make this code much simpler by using a `ByteBuffer` and then using it to generate the `byte[]` passed to the `BodyPublishers`.\r\n\r\nAmong other things, it can also help avoiding the long chains of string concatenation (which could be problematic if this part of the code is in the hot path).\r\n\r\n"", 'commenter': 'orpiske'}]"
7683,components/camel-whatsapp/src/main/java/org/apache/camel/component/whatsapp/WhatsAppComponent.java,"@@ -0,0 +1,132 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.whatsapp;
+
+import java.net.http.HttpClient;
+import java.util.Map;
+
+import org.apache.camel.Endpoint;
+import org.apache.camel.spi.Metadata;
+import org.apache.camel.spi.annotations.Component;
+import org.apache.camel.support.DefaultComponent;
+
+@Component(""whatsapp"")
+public class WhatsAppComponent extends DefaultComponent {
+
+    public static final String API_DEFAULT_URL = ""https://graph.facebook.com"";
+    public static final String API_DEFAULT_VERSION = ""v13.0"";
+
+    @Metadata(required = true, description = ""Phone Number ID taken from WhatsApp Meta for Developers Dashboard"")
+    private String phoneNumberId;
+    @Metadata(label = ""security"", secret = true, required = true,
+              description = ""Authorization Token taken from WhatsApp Meta for Developers Dashboard"")
+    private String authorizationToken;
+
+    @Metadata(label = ""advanced"", description = ""Java 11 HttpClient implementation"")
+    private HttpClient client;
+    @Metadata(label = ""advanced"", defaultValue = API_DEFAULT_URL,
+              description = ""Can be used to set an alternative base URI, e.g. when you want to test the component against a mock WhatsApp API"")
+    private String baseUri = API_DEFAULT_URL;
+    @Metadata(label = ""advanced"", defaultValue = API_DEFAULT_VERSION, description = ""WhatsApp Cloud API version"")
+    private String apiVersion = API_DEFAULT_VERSION;
+    @Metadata(description = ""Webhook verify token"", label = ""advanced"", secret = true)
+    private String webhookVerifyToken;
+
+    public WhatsAppComponent() {
+    }
+
+    @Override
+    protected Endpoint createEndpoint(String uri, String remaining, Map<String, Object> parameters) throws Exception {
+        WhatsAppConfiguration configuration = new WhatsAppConfiguration();
+
+        if (configuration.getBaseUri() == null) {
+            configuration.setBaseUri(baseUri);
+        }
+        if (configuration.getApiVersion() == null) {
+            configuration.setApiVersion(apiVersion);
+        }
+        if (configuration.getWebhookVerifyToken() == null) {
+            configuration.setWebhookVerifyToken(webhookVerifyToken);
+        }
+
+        configuration.setAuthorizationToken(authorizationToken);
+
+        if (remaining.endsWith(""/"")) {
+            remaining = remaining.substring(0, remaining.length() - 1);
+        }
+        configuration.setPhoneNumberId(remaining);
+
+        WhatsAppEndpoint endpoint = new WhatsAppEndpoint(uri, this, configuration, client);
+
+        setProperties(endpoint, parameters);
+
+        if (endpoint.getConfiguration().getAuthorizationToken() == null) {","[{'comment': 'Maybe use `ObjectHelper.isEmpty` here', 'commenter': 'orpiske'}]"
7683,components/camel-whatsapp/src/main/java/org/apache/camel/component/whatsapp/WhatsAppEndpoint.java,"@@ -0,0 +1,149 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.whatsapp;
+
+import java.net.http.HttpClient;
+import java.time.Duration;
+import java.util.List;
+
+import org.apache.camel.Category;
+import org.apache.camel.Component;
+import org.apache.camel.Consumer;
+import org.apache.camel.Processor;
+import org.apache.camel.Producer;
+import org.apache.camel.component.webhook.WebhookCapableEndpoint;
+import org.apache.camel.component.webhook.WebhookConfiguration;
+import org.apache.camel.component.whatsapp.service.WhatsAppServiceRestAPIAdapter;
+import org.apache.camel.spi.UriEndpoint;
+import org.apache.camel.spi.UriParam;
+import org.apache.camel.support.ScheduledPollEndpoint;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * Send messages.
+ */
+@UriEndpoint(firstVersion = ""3.18.0"", scheme = ""whatsapp"", title = ""WhatsApp"", syntax = ""whatsapp:type"",
+             category = {
+                     Category.CLOUD, Category.API,
+                     Category.CHAT },
+             headersClass = WhatsAppConstants.class)
+public class WhatsAppEndpoint extends ScheduledPollEndpoint implements WebhookCapableEndpoint {
+    private static final Logger LOG = LoggerFactory.getLogger(WhatsAppEndpoint.class);
+
+    @UriParam
+    private WhatsAppConfiguration configuration;
+
+    @UriParam(label = ""advanced"", description = ""HttpClient implementation"")
+    private HttpClient httpClient;
+    @UriParam(label = ""advanced"", description = ""WhatsApp service implementation"")
+    private WhatsAppService whatsappService;
+
+    private WebhookConfiguration webhookConfiguration;
+
+    public WhatsAppEndpoint(String endpointUri, Component component, WhatsAppConfiguration configuration, HttpClient client) {
+        super(endpointUri, component);
+        this.configuration = configuration;
+        this.httpClient = client;
+    }
+
+    @Override
+    protected void doStart() throws Exception {
+        super.doStart();
+        if (httpClient == null) {
+            httpClient
+                    = HttpClient.newBuilder().version(HttpClient.Version.HTTP_2).connectTimeout(Duration.ofSeconds(10)).build();
+        }
+        if (whatsappService == null) {
+            whatsappService = new WhatsAppServiceRestAPIAdapter(
+                    httpClient, configuration.getBaseUri(), configuration.getApiVersion(), configuration.getPhoneNumberId(),
+                    configuration.getAuthorizationToken());
+        }
+        LOG.debug(""client {}"" + httpClient);
+        LOG.debug(""whatsappService {}"" + whatsappService);","[{'comment': 'The logging is incorrect on these 2 lines. It should be:\r\n\r\n```\r\nLOG.debug(""client {}"", httpClient);\r\nLOG.debug(""whatsappService {}"", whatsappService);\r\n```', 'commenter': 'orpiske'}, {'comment': ""OMG, I'm bad.."", 'commenter': 'Croway'}]"
7683,components/camel-whatsapp/src/main/java/org/apache/camel/component/whatsapp/model/UploadMedia.java,"@@ -0,0 +1,68 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.whatsapp.model;
+
+import java.io.File;
+import java.io.InputStream;
+import java.util.Objects;
+
+import org.apache.camel.RuntimeCamelException;
+
+public class UploadMedia {
+
+    private File file;
+    private String contentType;
+    private String name;
+    private InputStream fileStream;
+
+    public UploadMedia(File file, String contentType) {
+        Objects.nonNull(file);
+        Objects.nonNull(contentType);","[{'comment': ""I am not sure if that's what you intend here. The method `Objects.nonNull` returns a boolean ... maybe you want you to use `this.file = Objects.requireNonNull(file)`? Alternatively ... if this class is intended to be used only internally and both `file` and `contentType` are (almost) guaranteed to be non-null, an `assert file != null` can do the trick as well."", 'commenter': 'orpiske'}, {'comment': 'This is exactly what I wanted', 'commenter': 'Croway'}]"
7683,components/camel-whatsapp/src/main/java/org/apache/camel/component/whatsapp/model/UploadMedia.java,"@@ -0,0 +1,68 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.whatsapp.model;
+
+import java.io.File;
+import java.io.InputStream;
+import java.util.Objects;
+
+import org.apache.camel.RuntimeCamelException;
+
+public class UploadMedia {
+
+    private File file;
+    private String contentType;
+    private String name;
+    private InputStream fileStream;
+
+    public UploadMedia(File file, String contentType) {
+        Objects.nonNull(file);
+        Objects.nonNull(contentType);
+        if (!file.exists()) {
+            throw new RuntimeCamelException(""The file provided does not exists"");
+        }
+
+        this.file = file;
+        this.contentType = contentType;
+    }
+
+    public UploadMedia(String name, InputStream fileStream, String contentType) {
+        Objects.nonNull(name);
+        Objects.nonNull(fileStream);
+        Objects.nonNull(contentType);","[{'comment': 'Please see my comment about `Objects.nonNull` above.', 'commenter': 'orpiske'}]"
7683,components/camel-whatsapp/src/test/resources/log4j2.properties,"@@ -0,0 +1,32 @@
+## ---------------------------------------------------------------------------
+## Licensed to the Apache Software Foundation (ASF) under one or more
+## contributor license agreements.  See the NOTICE file distributed with
+## this work for additional information regarding copyright ownership.
+## The ASF licenses this file to You under the Apache License, Version 2.0
+## (the ""License""); you may not use this file except in compliance with
+## the License.  You may obtain a copy of the License at
+##
+##      http://www.apache.org/licenses/LICENSE-2.0
+##
+## Unless required by applicable law or agreed to in writing, software
+## distributed under the License is distributed on an ""AS IS"" BASIS,
+## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+## See the License for the specific language governing permissions and
+## limitations under the License.
+## ---------------------------------------------------------------------------
+
+appender.file.type = File
+appender.file.name = file
+appender.file.fileName = target/camel-whatsapp.log
+appender.file.layout.type = PatternLayout
+appender.file.layout.pattern = %d %-5p %c{1} - %m %n
+appender.console.type = Console
+appender.console.name = console
+appender.console.layout.type = PatternLayout
+appender.console.layout.pattern = %d{yyyy-MM-dd HH:mm:ss} %-5p %c{1}:%L - %m%n
+logger.whatsapp.name = org.apache.camel.component.whatsapp
+logger.whatsapp.level = DEBUG
+rootLogger.level = INFO
+
+rootLogger.appenderRef.file.ref = file
+#rootLogger.appenderRef.console.ref = console","[{'comment': 'You can remove this line.', 'commenter': 'orpiske'}]"
7720,components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java,"@@ -68,6 +69,7 @@ public class MinioConsumer extends ScheduledBatchPollingConsumer {
 
     public MinioConsumer(MinioEndpoint endpoint, Processor processor) {
         super(endpoint, processor);
+        LOG.info(""Minio consumer custom: v1"");","[{'comment': 'Can you remove this', 'commenter': 'davsclaus'}, {'comment': 'Can you remove this', 'commenter': 'davsclaus'}, {'comment': 'done, it is an error.', 'commenter': 'jbordeau'}]"
7720,components/camel-minio/src/test/resources/log4j2.properties,"@@ -24,4 +24,5 @@ appender.out.name=out
 appender.out.layout.type=PatternLayout
 appender.out.layout.pattern=%d [%-15.15t] %-5p %-30.30c{1} - %m%n
 rootLogger.level=INFO
-rootLogger.appenderRef.file.ref=file
+rootLogger.appenderRef.out.ref=out","[{'comment': 'Can you revert this', 'commenter': 'davsclaus'}, {'comment': 'Can you revert this', 'commenter': 'davsclaus'}, {'comment': 'done', 'commenter': 'jbordeau'}, {'comment': 'done', 'commenter': 'jbordeau'}]"
7720,components/camel-minio/src/test/java/org/apache/camel/component/minio/MinioTestUtils.java,"@@ -37,17 +37,4 @@ public static Properties loadMinioPropertiesFile() throws IOException {
 
         return properties;
     }
-
-    static Properties loadMinioAccessFromJvmEnv() throws Exception {","[{'comment': 'Is there a specific reason to remove this?', 'commenter': 'oscerd'}, {'comment': 'it is not used. Do you want keep it ?', 'commenter': 'jbordeau'}]"
7721,components/camel-dropbox/src/main/java/org/apache/camel/component/dropbox/validator/DropboxConfigurationValidator.java,"@@ -33,6 +33,18 @@ public static void validateCommonProperties(DropboxConfiguration configuration)
         if (configuration.getAccessToken() == null || configuration.getAccessToken().equals("""")) {
             throw new DropboxException(""option <accessToken> is not present or not valid!"");
         }
+        if (configuration.getExpireIn() == null || configuration.getExpireIn() <= 0) {
+            throw new DropboxException(""option <expireIn> is not present or not valid!"");
+        }
+        if (configuration.getRefreshToken() == null || configuration.getRefreshToken().equals("""")) {","[{'comment': 'I think you can use `ObjectHelper.isEmpty` here.', 'commenter': 'orpiske'}]"
7721,components/camel-dropbox/src/main/java/org/apache/camel/component/dropbox/validator/DropboxConfigurationValidator.java,"@@ -33,6 +33,18 @@ public static void validateCommonProperties(DropboxConfiguration configuration)
         if (configuration.getAccessToken() == null || configuration.getAccessToken().equals("""")) {
             throw new DropboxException(""option <accessToken> is not present or not valid!"");
         }
+        if (configuration.getExpireIn() == null || configuration.getExpireIn() <= 0) {
+            throw new DropboxException(""option <expireIn> is not present or not valid!"");
+        }
+        if (configuration.getRefreshToken() == null || configuration.getRefreshToken().equals("""")) {
+            throw new DropboxException(""option <refreshToken> is not present or not valid!"");
+        }
+        if (configuration.getApiKey() == null || configuration.getApiKey().equals("""")) {","[{'comment': 'I think you can use `ObjectHelper.isEmpty` here and in the others with the same logic.', 'commenter': 'orpiske'}]"
7761,components/camel-file/src/main/java/org/apache/camel/component/file/FileOperations.java,"@@ -423,38 +423,38 @@ private void keepLastModified(Exchange exchange, File file) {
                 last = exchange.getIn().getHeader(Exchange.FILE_LAST_MODIFIED, Long.class);
             }
             if (last != null) {
-                boolean result = file.setLastModified(last);
+                boolean result = file.toFile().setLastModified(last);
                 if (LOG.isTraceEnabled()) {
                     LOG.trace(""Keeping last modified timestamp: {} on file: {} with result: {}"", last, file, result);
                 }
             }
         }
     }
 
-    private boolean writeFileByLocalWorkPath(File source, File file) throws IOException {
+    private boolean writeFileByLocalWorkPath(Path source, Path file) throws IOException {
         LOG.trace(""writeFileByFile using local work file being renamed from: {} to: {}"", source, file);
         return FileUtil.renameFile(source, file, endpoint.isCopyAndDeleteOnRenameFail());
     }
 
-    private void writeFileByFile(File source, File target, Exchange exchange) throws IOException {
+    private void writeFileByFile(Path source, Path target, Exchange exchange) throws IOException {
         // in case we are using file locks as read-locks then we need to use
         // file channels for copying to support this
-        String path = source.getAbsolutePath();
+        String path = source.toAbsolutePath().toString();
         FileChannel channel
                 = exchange.getProperty(asExclusiveReadLockKey(path, Exchange.FILE_LOCK_CHANNEL_FILE), FileChannel.class);
         if (channel != null) {
-            try (FileChannel out = new FileOutputStream(target).getChannel()) {
+            try (FileChannel out = new FileOutputStream(target.toFile()).getChannel()) {","[{'comment': '`FileChannel.open(target)`?', 'commenter': 'bmarcj'}, {'comment': ""I've updated the code. Thanks!"", 'commenter': 'rnetuka'}]"
7792,components/camel-sjms/src/main/java/org/apache/camel/component/sjms/SjmsComponent.java,"@@ -71,6 +72,10 @@ public class SjmsComponent extends HeaderFilterStrategyComponent {
               description = ""Specifies the maximum number of concurrent consumers for continue routing when timeout occurred when using request/reply over JMS."")
     private int replyToOnTimeoutMaxConcurrentConsumers = 1;
 
+    @Metadata(label = ""exceptionListener"",","[{'comment': 'label = ""advanced""', 'commenter': 'davsclaus'}, {'comment': 'Fixed', 'commenter': 'uklance'}]"
7855,components/camel-jira/src/main/java/org/apache/camel/component/jira/producer/AddIssueProducer.java,"@@ -25,6 +27,7 @@
 import com.atlassian.jira.rest.client.api.domain.IssueType;
 import com.atlassian.jira.rest.client.api.domain.Priority;
 import com.atlassian.jira.rest.client.api.domain.input.IssueInputBuilder;
+import com.google.common.base.Strings;","[{'comment': 'Do not use google/guava for this - Camel has API for checking if a string is empty, or since Camel is now Java 11 based, you can use blank() method on Strings from the JDK itself', 'commenter': 'davsclaus'}, {'comment': 'org.apache.camel.util.ObjectHelper isEmpty method\r\n\r\nAs we need to backport to 3.14.x then we cannot use Java 11 APIs as 3.14 supports JDK8', 'commenter': 'davsclaus'}, {'comment': 'Fixed that, thanks.', 'commenter': 'claudio4j'}]"
7919,components/camel-kafka/src/main/docs/kafka-component.adoc,"@@ -228,7 +228,7 @@ camelContext.addRoutes(new RouteBuilder() {
 The `camel-kafka` library provides a Kafka topic-based idempotent repository. This repository stores broadcasts all changes to idempotent state (add/remove) in a Kafka topic, and populates a local in-memory cache for each repository's process instance through event sourcing.
 The topic used must be unique per idempotent repository instance. The mechanism does not have any requirements about the number of topic partitions; as the repository consumes from all partitions at the same time. It also does not have any requirements about the replication factor of the topic.
 Each repository instance that uses the topic (e.g. typically on different machines running in parallel) controls its own consumer group, so in a cluster of 10 Camel processes using the same topic each will control its own offset.
-On startup, the instance subscribes to the topic and rewinds the offset to the beginning, rebuilding the cache to the latest state. The cache will not be considered warmed up until one poll of `pollDurationMs` in length returns 0 records. Startup will not be completed until either the cache has warmed up, or 30 seconds go by; if the latter happens the idempotent repository may be in an inconsistent state until its consumer catches up to the end of the topic.
+On startup, the instance subscribes to the topic, rewinds the offset to the beginning and rebuilding the cache to the latest state. The cache will not be considered warmed up until one poll of `pollDurationMs` in length returns 0 records. Startup will not be completed until either the cache has warmed up, or 30 seconds go by; if the latter happens the idempotent repository may be in an inconsistent state until its consumer catches up to the end of the topic.","[{'comment': 'I think this should be:\r\n\r\n```\r\nOn startup, the instance subscribes to the topic, rewinds the offset to the beginning and rebuilds the cache to the latest state.\r\n```', 'commenter': 'orpiske'}, {'comment': 'Fixed. Thanks, I missed that. ', 'commenter': 'mmajerni'}]"
7973,catalog/camel-catalog/src/generated/resources/org/apache/camel/catalog/components/hyperledger-aries.json,"@@ -0,0 +1,37 @@
+{
+  ""component"": {
+    ""kind"": ""component"",
+    ""name"": ""hyperledger-aries"",
+    ""title"": ""Aries"",
+    ""description"": ""Access market data and trade on Bitcoin and Altcoin exchanges."",
+    ""deprecated"": false,
+    ""firstVersion"": ""3.17.0"",","[{'comment': 'First version should be 3.19.0 I suppose, because 3.18.0 is on vote already', 'commenter': 'oscerd'}, {'comment': 'ok', 'commenter': 'tdiesler'}]"
7973,components/camel-hyperledger-aries/src/main/java/org/apache/camel/component/aries/Constants.java,"@@ -0,0 +1,44 @@
+/*-
+ * #%L","[{'comment': 'This section should be removed from the license header.', 'commenter': 'oscerd'}, {'comment': ""These headers are generated with the maven plugin. I suppose you don't manually maintain license headers across all files. I can remove all headers with plugin and perhaps then regenerate in the way you want it, but how would I do that?"", 'commenter': 'tdiesler'}]"
7973,components/camel-hyperledger-aries/src/main/java/org/apache/camel/component/aries/HyperledgerAriesComponent.java,"@@ -0,0 +1,152 @@
+/*-
+ * #%L","[{'comment': 'Same', 'commenter': 'oscerd'}]"
7973,components/camel-hyperledger-aries/src/main/java/org/apache/camel/component/aries/HyperledgerAriesConfiguration.java,"@@ -0,0 +1,101 @@
+/*-
+ * #%L","[{'comment': 'Same', 'commenter': 'oscerd'}, {'comment': 'Same', 'commenter': 'oscerd'}]"
7973,components/camel-hyperledger-aries/src/main/java/org/apache/camel/component/aries/HyperledgerAriesProducer.java,"@@ -0,0 +1,112 @@
+/*-","[{'comment': 'Same', 'commenter': 'oscerd'}]"
7986,core/camel-support/src/main/java/org/apache/camel/saga/InMemorySagaCoordinator.java,"@@ -229,4 +235,11 @@ private <T> List<T> reversed(List<T> list) {
         Collections.reverse(reversed);
         return reversed;
     }
+
+    private void copyTrace(Exchange exchange, Exchange previousExchange) {
+        SpanAdapter span = ActiveSpanManager.getSpan(previousExchange);","[{'comment': 'I belive that `SpanAdapter` and `ActiveSpanManager` are in `camel-tracing` which can not be used here.', 'commenter': 'zhfeng'}, {'comment': 'for this case, do you thing is just feasible if we just copy all the properties from old exchange to new exchange? ', 'commenter': 'chiochuan'}]"
7995,core/camel-core/src/test/java/org/apache/camel/model/RouteConfigurationOnExceptionTest.java,"@@ -0,0 +1,89 @@
+package org.apache.camel.model;
+
+import org.apache.camel.ContextTestSupport;
+import org.apache.camel.LoggingLevel;
+import org.apache.camel.builder.AdviceWith;
+import org.apache.camel.builder.RouteBuilder;
+import org.apache.camel.builder.RouteConfigurationBuilder;
+import org.apache.camel.builder.TemplatedRouteBuilder;
+import org.apache.camel.component.direct.DirectConsumerNotAvailableException;
+import org.apache.camel.component.mock.MockEndpoint;
+import org.junit.jupiter.api.Test;
+
+import java.net.ConnectException;
+
+public class RouteConfigurationOnExceptionTest extends ContextTestSupport {
+
+    @Override
+    public boolean isUseRouteBuilder() {
+        return false;
+    }
+
+    @Test
+    public void testGlobal() throws Exception {
+        context.addRoutes(new RouteConfigurationBuilder() {
+            @Override
+            public void configuration() throws Exception {
+                routeConfiguration(""my-error-handler"").onException(Exception.class)
+                        .handled(true)
+                        .log(LoggingLevel.ERROR, log, ""--> Exception: ${exception.message}, Delivery was NOT rolled back"");
+            }
+        });
+        context.addRoutes(new RouteBuilder() {
+            @Override
+            public void configure() throws Exception {
+                routeTemplate(""route-template-1"")
+                        .templateParameter(""route_url-1"")
+                        .templateParameter(""route_url-2"")
+                        .templateParameter(""route-id-param-id"")
+
+                        .from(""direct:{{route_url-1}}"")
+                        .routeConfigurationId(""my-error-handler"")
+                        .end()
+
+                        .log(LoggingLevel.INFO, log, ""--> Executing"")
+                        .to(""direct:{{route_url-2}}"")
+                        .id(""{{route-id-param-id}}"")
+                        .log(LoggingLevel.INFO, log, ""--> Executed!"");
+            }
+        });
+
+        context.addRoutes(new RouteBuilder() {
+            @Override
+            public void configure() throws Exception {
+
+                from(""direct:start2"")
+                        .to(""mock:result2"");
+            }
+        });
+
+        context.addRoutes(new RouteBuilder() {
+            @Override
+            public void configure() throws Exception {
+                final String routeId = TemplatedRouteBuilder.builder(context, ""route-template-1"")
+                        .routeId(""my-test-file-route"")
+                        .parameter(""route_url-1"", ""start"")
+                        .parameter(""route_url-2"", ""startWrong"")
+                        .parameter(""route-id-param-id"", ""my-internal-route-id"")
+                        .add();
+            }
+        });
+
+        MockEndpoint mockEndpoint = getMockEndpoint(""mock:endpointMock"");
+        AdviceWith.adviceWith(context, ""my-test-file-route"", routeBuilder -> {
+            routeBuilder.replaceFromWith(""direct:start"");
+            routeBuilder.weaveAddLast().to(mockEndpoint);
+            routeBuilder.setLogRouteAsXml(false);
+        });
+
+        context.start();
+
+        final String testMsg = ""{ test msg }"";
+
+        mockEndpoint.expectedMessageCount(0);
+        //mockEndpoint.expectedBodiesReceived(testMsg);","[{'comment': 'I guess this can be removed', 'commenter': 'essobedo'}, {'comment': 'Done!', 'commenter': 'rhuan080'}]"
7995,core/camel-core-engine/src/main/java/org/apache/camel/impl/DefaultModel.java,"@@ -96,6 +97,7 @@ public class DefaultModel implements Model {
     private final Map<String, Resilience4jConfigurationDefinition> resilience4jConfigurations = new ConcurrentHashMap<>();
     private final Map<String, FaultToleranceConfigurationDefinition> faultToleranceConfigurations = new ConcurrentHashMap<>();
     private Function<RouteDefinition, Boolean> routeFilter;
+    private RoutesDefinition routeCollection = new RoutesDefinition();","[{'comment': 'It is not meant to be shared, I rather prefer that you create a new instance at each call instead.', 'commenter': 'essobedo'}, {'comment': 'Done!', 'commenter': 'rhuan080'}]"
8023,components/camel-datasonnet/src/main/java/org/apache/camel/language/datasonnet/DatasonnetExpression.java,"@@ -114,7 +114,11 @@ private Document<?> doEvaluate(Exchange exchange) {
         }
 
         Document<?> body;
-        if (exchange.getMessage().getBody() instanceof Document) {
+
+        if (exchange.getMessage().getBody() == null || """".equals(MessageHelper.extractBodyAsString(exchange.getMessage()))) {","[{'comment': 'This logic should be moved last as extracting body as string would then always be performed and that is not good', 'commenter': 'davsclaus'}, {'comment': 'Oh, I see, but then how do I verify if the body is an empty string?', 'commenter': 'javaduke'}, {'comment': 'Ah yeah do you need to do this even if there is a Document object and its empty? Because if you convert that to a string you do an xml dump which would not be empty, it will have <xml ...> something as output.\r\n\r\nThe extractBody ... method deals with stream caching so that is good. It may not be as much overkill, just that the message body can be InputStream, byte[], XML Document and many other things, and in Java everything can be converted to a String via Object.toString so you would essentailly always get some output.\r\n', 'commenter': 'davsclaus'}, {'comment': ""No, if it's an empty Document, it's a different story (a Document cannot really be empty). Datasonnet doesn't like empty inputs, and I'm really just trying to deal with the situation where message body is not used in mapping but Datasonnet expects it anyway. If an input is an XML document and the mapping expects something else, there should be a legitimate error thrown.\r\nSo I really just need to make sure that if it's null or an empty string, we force the empty string with java object mime type, to avoid an error. "", 'commenter': 'javaduke'}, {'comment': ""OK, I changed the logic slightly, but I still need to ensure that if it's null or an empty string, I force APPLICATION_JAVA with empty string to DS."", 'commenter': 'javaduke'}]"
8023,components/camel-datasonnet/src/main/java/org/apache/camel/language/datasonnet/DatasonnetExpression.java,"@@ -114,14 +114,20 @@ private Document<?> doEvaluate(Exchange exchange) {
         }
 
         Document<?> body;
+
         if (exchange.getMessage().getBody() instanceof Document) {
             body = (Document<?>) exchange.getMessage().getBody();
+        } else if (exchange.getMessage().getBody() == null || """".equals(MessageHelper.extractBodyAsString(exchange.getMessage()))) {
+            //Empty body, force type to be application/java
+            body = new DefaultDocument<>("""", MediaTypes.APPLICATION_JAVA);
         } else if (MediaTypes.APPLICATION_JAVA.equalsTypeAndSubtype(bodyMT) || bodyMT == null) {
             body = new DefaultDocument<>(exchange.getMessage().getBody());
         } else {
             body = new DefaultDocument<>(MessageHelper.extractBodyAsString(exchange.getMessage()), bodyMT);","[{'comment': 'You would essentially call this method twice, first when checking for empty, and then afterwards here too. I think it would be good to do this only once', 'commenter': 'davsclaus'}, {'comment': 'Makes sense, I refactored it.', 'commenter': 'javaduke'}]"
8391,components/camel-kafka/src/main/java/org/apache/camel/component/kafka/KafkaFetchRecords.java,"@@ -16,22 +16,11 @@
  */
 package org.apache.camel.component.kafka;
 
-import java.time.Duration;
-import java.util.Arrays;
-import java.util.Properties;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.locks.ReentrantLock;
-import java.util.regex.Pattern;
-
 import org.apache.camel.component.kafka.consumer.CommitManager;
 import org.apache.camel.component.kafka.consumer.CommitManagers;
 import org.apache.camel.component.kafka.consumer.errorhandler.KafkaConsumerListener;
 import org.apache.camel.component.kafka.consumer.errorhandler.KafkaErrorStrategies;
-import org.apache.camel.component.kafka.consumer.support.KafkaConsumerResumeAdapter;
-import org.apache.camel.component.kafka.consumer.support.KafkaRecordProcessorFacade;
-import org.apache.camel.component.kafka.consumer.support.PartitionAssignmentListener;
-import org.apache.camel.component.kafka.consumer.support.ProcessingResult;
-import org.apache.camel.component.kafka.consumer.support.ResumeStrategyFactory;
+import org.apache.camel.component.kafka.consumer.support.*;","[{'comment': 'This causes a violation of the checkstyle. The imports need to be explicit. ', 'commenter': 'orpiske'}]"
8391,components/camel-kafka/src/main/java/org/apache/camel/component/kafka/KafkaFetchRecords.java,"@@ -421,7 +427,7 @@ private boolean isKafkaConsumerRunnable() {
     }
 
     private boolean isKafkaConsumerRunnableAndNotStopped() {
-        return kafkaConsumer.isRunAllowed() && !kafkaConsumer.isStoppingOrStopped();
+        return kafkaConsumer.""isRunAllowed() && !kafkaConsumer.isStoppingOrStopped();","[{'comment': 'This one is causing the compilation issue.', 'commenter': 'orpiske'}]"
8391,components/camel-kafka/src/main/java/org/apache/camel/component/kafka/KafkaFetchRecords.java,"@@ -507,7 +517,7 @@ private boolean isReady() {
         } catch (Exception e) {
             // ignore
             LOG.debug(""Cannot check hasReadyNodes on KafkaConsumer client (ConsumerNetworkClient) due to: ""
-                      + e.getMessage() + "". This exception is ignored."",
+                            + e.getMessage() + "". This exception is ignored."",","[{'comment': ""The format check may be complaining because of this line. If you look at it, you can see that it's different than the previous version."", 'commenter': 'orpiske'}]"
8391,components/camel-kafka/src/main/java/org/apache/camel/component/kafka/KafkaFetchRecords.java,"@@ -176,7 +178,7 @@ private void setupCreateConsumerException(ForegroundTask task, int max) {
         String time = TimeUtils.printDuration(task.elapsed(), true);
         String topic = getPrintableTopic();
         String msg = ""Gave up creating org.apache.kafka.clients.consumer.KafkaConsumer ""
-                     + threadId + "" to "" + topic + "" after "" + max + "" attempts (elapsed: "" + time + "")."";
+                + threadId + "" to "" + topic + "" after "" + max + "" attempts (elapsed: "" + time + "")."";","[{'comment': ""The format check may be complaining because of this line. If you look at it, you can see that it's different than the previous version."", 'commenter': 'orpiske'}]"
8391,components/camel-kafka/src/main/java/org/apache/camel/component/kafka/KafkaFetchRecords.java,"@@ -167,7 +169,7 @@ private void setupInitializeErrorException(ForegroundTask task, int max) {
         String time = TimeUtils.printDuration(task.elapsed(), true);
         String topic = getPrintableTopic();
         String msg = ""Gave up subscribing org.apache.kafka.clients.consumer.KafkaConsumer "" +
-                     threadId + "" to "" + topic + "" after "" + max + "" attempts (elapsed: "" + time + "")."";
+                threadId + "" to "" + topic + "" after "" + max + "" attempts (elapsed: "" + time + "")."";","[{'comment': ""The format check may be complaining because of this line. If you look at it, you can see that it's different than the previous version."", 'commenter': 'orpiske'}]"
8408,components/camel-kafka/src/main/java/org/apache/camel/component/kafka/producer/support/PropagatedHeadersProvider.java,"@@ -0,0 +1,71 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.kafka.producer.support;
+
+import java.util.List;
+
+import org.apache.camel.Exchange;
+import org.apache.camel.Message;
+import org.apache.camel.component.kafka.KafkaConfiguration;
+import org.apache.camel.component.kafka.KafkaProducer;
+import org.apache.kafka.common.header.Header;
+
+/**
+ * Used to provide individual kafka header values if feature ""batchWithIndividualHeaders"" is enabled.
+ *
+ * @author r.wiedmann@bitproquo.org","[{'comment': 'Remove author tag', 'commenter': 'davsclaus'}, {'comment': 'done / removed', 'commenter': 'rwiedmann'}]"
8492,components/camel-azure/camel-azure-eventhubs/src/test/java/org/apache/camel/component/azure/eventhubs/EventHubsCheckpointUpdaterTimerTaskTest.java,"@@ -0,0 +1,44 @@
+package org.apache.camel.component.azure.eventhubs;","[{'comment': 'Please add license header', 'commenter': 'oscerd'}]"
8492,components/camel-azure/camel-azure-eventhubs/src/main/java/org/apache/camel/component/azure/eventhubs/EventHubsConsumer.java,"@@ -173,7 +173,12 @@ private void processCommit(final Exchange exchange, final EventContext eventCont
         try {
             var completionCondition = processCheckpoint(exchange);
             if (completionCondition.equals(COMPLETED_BY_SIZE)) {
-                eventContext.updateCheckpoint();
+                eventContext.updateCheckpointAsync()
+                        .subscribe(unused -> LOG.debug(""Processed one event...""), error -> {
+                            LOG.debug(""Error when updating Checkpoint: {}"", error.getMessage());
+                            exchange.setException(error);","[{'comment': 'Since the callback is async then in case of an error, then storing that on the exchange does not make sense as the exchange would likely no longer be in use. Instead the error should be logged, or better yet processed by exception handler on the consumer - there should be a getExceptionHandler.handleException(...) ', 'commenter': 'davsclaus'}, {'comment': 'I decided to just log the error. Going deeper seems to be out of my experience level within this matter..', 'commenter': 'jylipaa'}]"
8499,components/camel-kafka/src/main/java/org/apache/camel/component/kafka/consumer/support/KafkaRecordProcessor.java,"@@ -131,8 +131,11 @@ private boolean processException(
                 LOG.warn(""Will seek consumer to offset {} and start polling again."", partitionLastOffset);
             }
 
-            // force commit, so we resume on next poll where we failed
-            commitManager.forceCommit(partition, partitionLastOffset);
+            // force commit, so we resume on next poll where we failed except when the failure happened
+            // at the first message in a poll
+            if(partitionLastOffset != -1) {","[{'comment': ""Please use `AbstractCommitManager.START_OFFSET` instead of -1, so it's easier to read. \r\n\r\n\r\nThanks!"", 'commenter': 'orpiske'}, {'comment': 'Also the code should be formatted, you can do that with `mvn compile -P format`', 'commenter': 'davsclaus'}]"
8513,components/camel-test/camel-test-junit5/src/main/java/org/apache/camel/test/junit5/CamelTestSupport.java,"@@ -982,6 +983,27 @@ protected Language assertResolveLanguage(String languageName) {
         return language;
     }
 
+    /**
+     * Asserts that all the expectations of the Mock endpoints are valid
+     *
+     * @see MockEndpoint#assertIsSatisfied(CamelContext)
+     */
+    protected void assertMockEndpointsSatisfied() throws InterruptedException {
+        MockEndpoint.assertIsSatisfied(context);
+    }
+
+    /**
+     * Asserts that all the expectations of the Mock endpoints are valid
+     *
+     * @see           MockEndpoint#assertIsSatisfied(CamelContext, long, TimeUnit)
+     *
+     * @param timeout
+     * @param unit","[{'comment': 'Please either document it or remove it ', 'commenter': 'essobedo'}]"
8571,components/camel-jsonpath/src/main/java/org/apache/camel/jsonpath/JsonPathLanguage.java,"@@ -134,8 +140,9 @@ public Expression createExpression(String expression, Object[] properties) {
         answer.setAllowSimple(property(boolean.class, properties, 2, allowSimple));
         answer.setAllowEasyPredicate(property(boolean.class, properties, 3, allowEasyPredicate));
         answer.setWriteAsString(property(boolean.class, properties, 4, writeAsString));
-        answer.setHeaderName(property(String.class, properties, 5, headerName));
-        String option = (String) properties[6];
+        answer.setWriteAsString(property(boolean.class, properties, 5, unpackArray));","[{'comment': 'setUnpackArray', 'commenter': 'davsclaus'}]"
8573,test-infra/camel-test-infra-kafka/src/test/java/org/apache/camel/test/infra/kafka/services/RedpandaTransactionsEnabledContainer.java,"@@ -0,0 +1,31 @@
+package org.apache.camel.test.infra.kafka.services;","[{'comment': 'License is missing', 'commenter': 'oscerd'}, {'comment': 'This file is missing the license header.', 'commenter': 'orpiske'}, {'comment': 'ops, thanks, force pushed', 'commenter': 'Croway'}]"
8573,test-infra/camel-test-infra-kafka/src/test/java/org/apache/camel/test/infra/kafka/services/RedpandaService.java,"@@ -0,0 +1,70 @@
+package org.apache.camel.test.infra.kafka.services;","[{'comment': 'License is  missing', 'commenter': 'oscerd'}, {'comment': 'This file is missing the license header.', 'commenter': 'orpiske'}]"
8593,components/camel-microprofile/camel-microprofile-health/src/test/java/org/apache/camel/microprofile/health/CamelMicroProfileHealthSupervisedRoutesMainTest.java,"@@ -16,55 +16,74 @@
  */
 package org.apache.camel.microprofile.health;
 
+import java.util.Map;
 import java.util.Optional;
 
 import javax.json.JsonArray;
 import javax.json.JsonObject;
 import javax.json.JsonValue;
 
-import io.smallrye.health.SmallRyeHealth;
-import io.smallrye.health.SmallRyeHealthReporter;
 import org.apache.camel.CamelContext;
+import org.apache.camel.Component;
+import org.apache.camel.Consumer;
+import org.apache.camel.Endpoint;
+import org.apache.camel.Exchange;
+import org.apache.camel.Processor;
+import org.apache.camel.Producer;
 import org.apache.camel.builder.RouteBuilder;
+import org.apache.camel.health.HealthCheckHelper;
 import org.apache.camel.health.HealthCheckRegistry;
+import org.apache.camel.health.HealthCheckResultBuilder;
 import org.apache.camel.impl.DefaultCamelContext;
+import org.apache.camel.impl.health.AbstractHealthCheck;
+import org.apache.camel.impl.health.ComponentsHealthCheckRepository;
 import org.apache.camel.main.SimpleMain;
+import org.apache.camel.support.DefaultComponent;
+import org.apache.camel.support.DefaultConsumer;
+import org.apache.camel.support.DefaultEndpoint;
+import org.apache.camel.support.DefaultProducer;
 import org.eclipse.microprofile.health.HealthCheckResponse.Status;
 import org.junit.jupiter.api.Test;
 
+import io.smallrye.health.SmallRyeHealth;
+import io.smallrye.health.SmallRyeHealthReporter;
+
 import static org.apache.camel.microprofile.health.CamelMicroProfileHealthTestHelper.getHealthJson;
 import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.junit.jupiter.api.Assertions.fail;
 
 public class CamelMicroProfileHealthSupervisedRoutesMainTest {
-    private SmallRyeHealthReporter reporter = new SmallRyeHealthReporter();
+    private final SmallRyeHealthReporter reporter = new SmallRyeHealthReporter();
 
     @Test
     public void testSupervisedRouteHealthChecks() throws Exception {","[{'comment': ""@jamesnetherton I amended only this test to include also components checks vs supervising controller, not sure if that's enough for the other cases"", 'commenter': 'lburgazzoli'}, {'comment': ""It's probably ok. Would be nice to cover the non-supervised scenario if possible. I'll leave it up to you whether you want to do that."", 'commenter': 'jamesnetherton'}, {'comment': 'Will do, do you have any preference about where this should be done ? ', 'commenter': 'lburgazzoli'}, {'comment': 'Might be enough to clone `CamelMicroProfileHealthConsumerTest` and modify it a bit.', 'commenter': 'jamesnetherton'}, {'comment': 'I ended up creating a new test as it impacted the current tests as they do assertion based on the number of checks', 'commenter': 'lburgazzoli'}]"
8593,components/camel-kafka/src/main/java/org/apache/camel/component/kafka/KafkaConsumer.java,"@@ -30,6 +30,7 @@
 import org.apache.camel.component.kafka.consumer.errorhandler.KafkaConsumerListener;
 import org.apache.camel.health.HealthCheckAware;
 import org.apache.camel.health.HealthCheckHelper;
+import org.apache.camel.impl.health.ComponentsHealthCheckRepository;","[{'comment': 'Avoid importing impl classes as they should not be used in the public', 'commenter': 'davsclaus'}, {'comment': 'this is because the ComponentsHealthCheckRepository has an add/remove health check methods: should we create a WritableHealthCheckRepository interface ? ', 'commenter': 'lburgazzoli'}, {'comment': 'Yeah or add add a default method on the existing interface', 'commenter': 'davsclaus'}, {'comment': 'Pushed a new version with an `WritableHealthCheckRepository` API.\r\nHowever I noticed that the Kafka Consumer/Producer HealthCheck  are also dependent on on an class from impl `org.apache.camel.impl.health.AbstractHealthCheck`', 'commenter': 'lburgazzoli'}, {'comment': 'yeah the entire classes in camel-health should be moved to another package - as org.apache.camel.impl is for the core routing engine and camel itself.', 'commenter': 'davsclaus'}, {'comment': 'The `impl` is also in camel-cluster / camel-cloud so its more general. Therefore in light of this then its okay in 3.x to import the impl - We can revisit this in 4.0', 'commenter': 'davsclaus'}]"
8593,components/camel-kafka/src/main/java/org/apache/camel/component/kafka/KafkaConsumer.java,"@@ -52,7 +53,7 @@ public class KafkaConsumer extends DefaultConsumer
     protected ExecutorService executor;
     private final KafkaEndpoint endpoint;
     private KafkaConsumerHealthCheck consumerHealthCheck;
-    private KafkaHealthCheckRepository healthCheckRepository;
+    private ComponentsHealthCheckRepository healthCheckRepository;","[{'comment': 'Can you use HealthCheckRepository API instead to avoid impl import', 'commenter': 'davsclaus'}]"
8593,components/camel-kafka/src/main/java/org/apache/camel/component/kafka/KafkaConsumer.java,"@@ -123,8 +124,11 @@ protected void doStart() throws Exception {
         super.doStart();
 
         // health-check is optional so discover and resolve
-        healthCheckRepository = HealthCheckHelper.getHealthCheckRepository(endpoint.getCamelContext(), ""camel-kafka"",
-                KafkaHealthCheckRepository.class);
+        healthCheckRepository = HealthCheckHelper.getHealthCheckRepository(","[{'comment': 'Lookup the repository without impl import', 'commenter': 'davsclaus'}]"
8593,components/camel-kafka/src/main/java/org/apache/camel/component/kafka/KafkaProducer.java,"@@ -38,6 +38,7 @@
 import org.apache.camel.component.kafka.producer.support.PropagatedHeadersProvider;
 import org.apache.camel.component.kafka.serde.KafkaHeaderSerializer;
 import org.apache.camel.health.HealthCheckHelper;
+import org.apache.camel.impl.health.ComponentsHealthCheckRepository;","[{'comment': 'Same here as in the consumer', 'commenter': 'davsclaus'}]"
8617,components/camel-casper/pom.xml,"@@ -0,0 +1,383 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+
+	<modelVersion>4.0.0</modelVersion>
+
+   <parent>
+        <groupId>org.apache.camel</groupId>
+        <artifactId>components</artifactId>
+        <version>3.20.0-SNAPSHOT</version>
+    </parent>
+
+
+<artifactId>camel-casper</artifactId>
+    <packaging>jar</packaging>
+
+    <name>Camel :: Casper</name>
+    <description>Camel Casper blockchaine component</description>
+	<url>https://casperlabs.io/</url>
+
+
+	<properties>
+		<compiler.source>1.8</compiler.source>
+		<compiler.target>1.8</compiler.target>
+		<maven-compiler-plugin.version>3.8.1</maven-compiler-plugin.version>
+		<maven-resources-plugin.version>3.2.0</maven-resources-plugin.version>
+		<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
+		<project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
+		<log4j2.version>2.13.3</log4j2.version>
+		<camel.version>3.14.2</camel.version>
+		<casper-java-sdk.version>0.3.0</casper-java-sdk.version>
+		<junit.version>4.13.2</junit.version>
+		<launchdarkly.version>2.3.2</launchdarkly.version>
+		<!-- SSE tests-->
+		<tomcat.version>9.0.54</tomcat.version>
+	</properties>
+
+	<licenses>
+		<license>
+			<name>MIT License</name>
+			<url>http://www.opensource.org/licenses/mit-license.php</url>
+		</license>
+	</licenses>","[{'comment': 'I think this is not correct/acceptable, though - in theory - it is a compatible license. \r\n\r\nWaiting for others to comment on this one ...', 'commenter': 'orpiske'}, {'comment': 'changed to apache licence', 'commenter': 'abahmanem'}]"
8617,components/camel-casper/pom.xml,"@@ -0,0 +1,383 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+
+	<modelVersion>4.0.0</modelVersion>
+
+   <parent>
+        <groupId>org.apache.camel</groupId>
+        <artifactId>components</artifactId>
+        <version>3.20.0-SNAPSHOT</version>
+    </parent>
+
+
+<artifactId>camel-casper</artifactId>
+    <packaging>jar</packaging>
+
+    <name>Camel :: Casper</name>
+    <description>Camel Casper blockchaine component</description>
+	<url>https://casperlabs.io/</url>
+
+
+	<properties>
+		<compiler.source>1.8</compiler.source>
+		<compiler.target>1.8</compiler.target>
+		<maven-compiler-plugin.version>3.8.1</maven-compiler-plugin.version>
+		<maven-resources-plugin.version>3.2.0</maven-resources-plugin.version>
+		<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
+		<project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
+		<log4j2.version>2.13.3</log4j2.version>
+		<camel.version>3.14.2</camel.version>
+		<casper-java-sdk.version>0.3.0</casper-java-sdk.version>
+		<junit.version>4.13.2</junit.version>
+		<launchdarkly.version>2.3.2</launchdarkly.version>
+		<!-- SSE tests-->
+		<tomcat.version>9.0.54</tomcat.version>
+	</properties>
+
+	<licenses>
+		<license>
+			<name>MIT License</name>
+			<url>http://www.opensource.org/licenses/mit-license.php</url>
+		</license>
+	</licenses>
+
+	<developers>
+		<developer>
+			<id>mabahma</id>
+			<name>mabahma</name>
+			<email>elmabahma@gmail.com</email>
+		</developer>
+		
+	</developers>
+	<scm>
+		<connection>scm:git:git@github.com:abahmanem/camel-casper.git</connection>
+		<developerConnection>scm:git:git@github.com:abahmanem/camel-casper.git</developerConnection>
+		<url>https://github.com/abahmanem/camel-casper</url>
+	</scm>","[{'comment': 'This is incorrect, as it is referring to an external project that is not Apache Camel.', 'commenter': 'orpiske'}, {'comment': 'deleted this section', 'commenter': 'abahmanem'}]"
8617,components/camel-casper/pom.xml,"@@ -0,0 +1,383 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+
+	<modelVersion>4.0.0</modelVersion>
+
+   <parent>
+        <groupId>org.apache.camel</groupId>
+        <artifactId>components</artifactId>
+        <version>3.20.0-SNAPSHOT</version>
+    </parent>
+
+
+<artifactId>camel-casper</artifactId>
+    <packaging>jar</packaging>
+
+    <name>Camel :: Casper</name>
+    <description>Camel Casper blockchaine component</description>
+	<url>https://casperlabs.io/</url>
+
+
+	<properties>
+		<compiler.source>1.8</compiler.source>
+		<compiler.target>1.8</compiler.target>
+		<maven-compiler-plugin.version>3.8.1</maven-compiler-plugin.version>
+		<maven-resources-plugin.version>3.2.0</maven-resources-plugin.version>
+		<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
+		<project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
+		<log4j2.version>2.13.3</log4j2.version>
+		<camel.version>3.14.2</camel.version>
+		<casper-java-sdk.version>0.3.0</casper-java-sdk.version>
+		<junit.version>4.13.2</junit.version>
+		<launchdarkly.version>2.3.2</launchdarkly.version>
+		<!-- SSE tests-->
+		<tomcat.version>9.0.54</tomcat.version>
+	</properties>
+
+	<licenses>
+		<license>
+			<name>MIT License</name>
+			<url>http://www.opensource.org/licenses/mit-license.php</url>
+		</license>
+	</licenses>
+
+	<developers>
+		<developer>
+			<id>mabahma</id>
+			<name>mabahma</name>
+			<email>elmabahma@gmail.com</email>
+		</developer>
+		
+	</developers>
+	<scm>
+		<connection>scm:git:git@github.com:abahmanem/camel-casper.git</connection>
+		<developerConnection>scm:git:git@github.com:abahmanem/camel-casper.git</developerConnection>
+		<url>https://github.com/abahmanem/camel-casper</url>
+	</scm>
+
+
+	<dependencyManagement>
+		<dependencies>
+			<dependency>
+				<groupId>org.apache.camel</groupId>
+				<artifactId>camel-bom</artifactId>
+				<version>${camel.version}</version>
+				<scope>import</scope>
+				<type>pom</type>
+			</dependency>
+		</dependencies>
+	</dependencyManagement>
+
+	<dependencies>
+
+		<!-- https://mvnrepository.com/artifact/org.apache.commons/commons-lang3 -->
+		<dependency>
+			<groupId>org.apache.commons</groupId>
+			<artifactId>commons-lang3</artifactId>
+			<version>3.11</version>","[{'comment': 'If possible / compatible should use `${commons-lang3-version}` to be aligned with the rest of the code base.', 'commenter': 'orpiske'}, {'comment': 'put all these in properties as versions', 'commenter': 'abahmanem'}]"
8617,components/camel-casper/pom.xml,"@@ -0,0 +1,383 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+
+	<modelVersion>4.0.0</modelVersion>
+
+   <parent>
+        <groupId>org.apache.camel</groupId>
+        <artifactId>components</artifactId>
+        <version>3.20.0-SNAPSHOT</version>
+    </parent>
+
+
+<artifactId>camel-casper</artifactId>
+    <packaging>jar</packaging>
+
+    <name>Camel :: Casper</name>
+    <description>Camel Casper blockchaine component</description>
+	<url>https://casperlabs.io/</url>
+
+
+	<properties>
+		<compiler.source>1.8</compiler.source>
+		<compiler.target>1.8</compiler.target>
+		<maven-compiler-plugin.version>3.8.1</maven-compiler-plugin.version>
+		<maven-resources-plugin.version>3.2.0</maven-resources-plugin.version>
+		<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
+		<project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
+		<log4j2.version>2.13.3</log4j2.version>
+		<camel.version>3.14.2</camel.version>
+		<casper-java-sdk.version>0.3.0</casper-java-sdk.version>
+		<junit.version>4.13.2</junit.version>
+		<launchdarkly.version>2.3.2</launchdarkly.version>
+		<!-- SSE tests-->
+		<tomcat.version>9.0.54</tomcat.version>
+	</properties>
+
+	<licenses>
+		<license>
+			<name>MIT License</name>
+			<url>http://www.opensource.org/licenses/mit-license.php</url>
+		</license>
+	</licenses>
+
+	<developers>
+		<developer>
+			<id>mabahma</id>
+			<name>mabahma</name>
+			<email>elmabahma@gmail.com</email>
+		</developer>
+		
+	</developers>
+	<scm>
+		<connection>scm:git:git@github.com:abahmanem/camel-casper.git</connection>
+		<developerConnection>scm:git:git@github.com:abahmanem/camel-casper.git</developerConnection>
+		<url>https://github.com/abahmanem/camel-casper</url>
+	</scm>
+
+
+	<dependencyManagement>
+		<dependencies>
+			<dependency>
+				<groupId>org.apache.camel</groupId>
+				<artifactId>camel-bom</artifactId>
+				<version>${camel.version}</version>
+				<scope>import</scope>
+				<type>pom</type>
+			</dependency>
+		</dependencies>
+	</dependencyManagement>
+
+	<dependencies>
+
+		<!-- https://mvnrepository.com/artifact/org.apache.commons/commons-lang3 -->
+		<dependency>
+			<groupId>org.apache.commons</groupId>
+			<artifactId>commons-lang3</artifactId>
+			<version>3.11</version>
+		</dependency>
+		<!-- https://mvnrepository.com/artifact/commons-cli/commons-cli -->
+		<dependency>
+			<groupId>commons-cli</groupId>
+			<artifactId>commons-cli</artifactId>
+			<version>1.4</version>","[{'comment': 'If possible / compatible should use `${commons-cli-version}` to be aligned with the rest of the code base.\r\n\r\n', 'commenter': 'orpiske'}, {'comment': 'fixed', 'commenter': 'abahmanem'}]"
8617,components/camel-casper/pom.xml,"@@ -0,0 +1,383 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+
+	<modelVersion>4.0.0</modelVersion>
+
+   <parent>
+        <groupId>org.apache.camel</groupId>
+        <artifactId>components</artifactId>
+        <version>3.20.0-SNAPSHOT</version>
+    </parent>
+
+
+<artifactId>camel-casper</artifactId>
+    <packaging>jar</packaging>
+
+    <name>Camel :: Casper</name>
+    <description>Camel Casper blockchaine component</description>
+	<url>https://casperlabs.io/</url>
+
+
+	<properties>
+		<compiler.source>1.8</compiler.source>
+		<compiler.target>1.8</compiler.target>
+		<maven-compiler-plugin.version>3.8.1</maven-compiler-plugin.version>
+		<maven-resources-plugin.version>3.2.0</maven-resources-plugin.version>
+		<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
+		<project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
+		<log4j2.version>2.13.3</log4j2.version>
+		<camel.version>3.14.2</camel.version>
+		<casper-java-sdk.version>0.3.0</casper-java-sdk.version>
+		<junit.version>4.13.2</junit.version>
+		<launchdarkly.version>2.3.2</launchdarkly.version>
+		<!-- SSE tests-->
+		<tomcat.version>9.0.54</tomcat.version>
+	</properties>
+
+	<licenses>
+		<license>
+			<name>MIT License</name>
+			<url>http://www.opensource.org/licenses/mit-license.php</url>
+		</license>
+	</licenses>
+
+	<developers>
+		<developer>
+			<id>mabahma</id>
+			<name>mabahma</name>
+			<email>elmabahma@gmail.com</email>
+		</developer>
+		
+	</developers>
+	<scm>
+		<connection>scm:git:git@github.com:abahmanem/camel-casper.git</connection>
+		<developerConnection>scm:git:git@github.com:abahmanem/camel-casper.git</developerConnection>
+		<url>https://github.com/abahmanem/camel-casper</url>
+	</scm>
+
+
+	<dependencyManagement>
+		<dependencies>
+			<dependency>
+				<groupId>org.apache.camel</groupId>
+				<artifactId>camel-bom</artifactId>
+				<version>${camel.version}</version>
+				<scope>import</scope>
+				<type>pom</type>
+			</dependency>
+		</dependencies>
+	</dependencyManagement>
+
+	<dependencies>
+
+		<!-- https://mvnrepository.com/artifact/org.apache.commons/commons-lang3 -->
+		<dependency>
+			<groupId>org.apache.commons</groupId>
+			<artifactId>commons-lang3</artifactId>
+			<version>3.11</version>
+		</dependency>
+		<!-- https://mvnrepository.com/artifact/commons-cli/commons-cli -->
+		<dependency>
+			<groupId>commons-cli</groupId>
+			<artifactId>commons-cli</artifactId>
+			<version>1.4</version>
+		</dependency>
+
+		<!--//////////////////////////////////// Camel dependencies //////////////////////////////////// -->
+
+		<dependency>
+			<groupId>org.apache.camel</groupId>
+			<artifactId>camel-jackson</artifactId>
+			<version>${camel.version}</version>
+
+		</dependency>
+		<dependency>
+			<groupId>org.apache.camel</groupId>
+			<artifactId>camel-core</artifactId>
+			<version>${camel.version}</version>
+		</dependency>
+		<dependency>
+			<groupId>org.apache.camel</groupId>
+			<artifactId>camel-main</artifactId>
+			<version>${camel.version}</version>
+		</dependency>
+
+		<dependency>
+			<groupId>org.apache.camel</groupId>
+			<artifactId>camel-jsonpath</artifactId>
+			<version>${camel.version}</version>
+		</dependency>
+
+
+		<dependency>
+			<groupId>org.json</groupId>
+			<artifactId>json</artifactId>
+			<version>20211205</version>","[{'comment': 'Versions should preferably be added to the parent and camel-dependencies pom for easier management on our side.', 'commenter': 'orpiske'}]"
8617,components/camel-casper/src/main/docs/casper-component.adoc,"@@ -0,0 +1,64 @@
+= Casper Camel Connector Component
+:doctitle: Casper Camel Connector
+:shortname: casper
+:artifactid: camel-casper
+:description: Camel casper endpoint : to interract with Casper nodes
+:since: 3.14.2","[{'comment': 'Should be 3.20.0.', 'commenter': 'orpiske'}, {'comment': 'fixed', 'commenter': 'abahmanem'}]"
8617,components/camel-casper/pom.xml,"@@ -0,0 +1,383 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>","[{'comment': 'Missing license header.', 'commenter': 'orpiske'}, {'comment': 'fixed', 'commenter': 'abahmanem'}]"
8617,components/camel-casper/src/main/java/org/apache/camel/component/casper/CasperComponent.java,"@@ -0,0 +1,44 @@
+package org.apache.camel.component.casper;","[{'comment': 'Missing license header.', 'commenter': 'orpiske'}, {'comment': 'fixed', 'commenter': 'abahmanem'}]"
8617,components/camel-casper/src/main/java/org/apache/camel/component/casper/CasperConsumer.java,"@@ -0,0 +1,78 @@
+package org.apache.camel.component.casper;
+
+import java.net.URI;
+import java.time.Duration;
+import java.util.concurrent.CountDownLatch;
+
+import org.apache.camel.Processor;
+import org.apache.camel.ShutdownRunningTask;
+import org.apache.camel.Suspendable;
+import org.apache.camel.spi.ShutdownAware;
+import org.apache.camel.support.DefaultConsumer;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import com.launchdarkly.eventsource.EventHandler;
+import com.launchdarkly.eventsource.EventSource;
+
+/**
+ * Camel CasperComsumer Component
+ * 
+ * @author mabahma
+ *
+ */
+
+public class CasperConsumer extends DefaultConsumer implements ShutdownAware, Suspendable {
+	public static final Logger logger = LoggerFactory.getLogger(CasperConsumer.class);","[{'comment': 'Checkstyle will catch this, but as a general comment: the `logger` variable needs to comply with the naming standards defined in our checkstyle rules. As such, I suggest naming it as `LOG`. ', 'commenter': 'orpiske'}, {'comment': 'fixed', 'commenter': 'abahmanem'}]"
8617,components/camel-casper/src/main/java/org/apache/camel/component/casper/CasperEventHandler.java,"@@ -0,0 +1,134 @@
+package org.apache.camel.component.casper;
+
+import org.apache.camel.Exchange;
+import org.json.JSONObject;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import com.launchdarkly.eventsource.EventHandler;
+import com.launchdarkly.eventsource.MessageEvent;
+
+/**
+ * Event handler for the consumer
+ * 
+ * @author mabahma
+ *
+ */
+public class CasperEventHandler implements EventHandler {
+
+	public static final Logger logger = LoggerFactory.getLogger(CasperEventHandler.class);
+	private final CasperConsumer consumer;
+	private final CasperEndPoint endpoint;
+
+	public CasperEventHandler(CasperConsumer consumer) {
+		super();
+		this.consumer = consumer;
+		this.endpoint = this.consumer.getEndpoint();
+	}
+
+	@Override
+	public void onOpen() throws Exception {
+		logger.info(""The event stream has been opened"");
+	}
+
+	@Override
+	public void onClosed() throws Exception {
+		logger.info(""The event stream has been closed"");
+	}
+
+	/**
+	 * 
+	 */
+	@Override
+	public void onMessage(String evt, MessageEvent messageEvent) throws Exception {
+		JSONObject json = new JSONObject(messageEvent.getData());
+		String firstJsonPropertyKey = """";
+
+		if (json.keys().hasNext())
+			firstJsonPropertyKey = json.keys().next();","[{'comment': 'Please use `{` and `}` for code blocks to comply with our coding standards defined in our checkstyle.', 'commenter': 'orpiske'}, {'comment': 'fixed', 'commenter': 'abahmanem'}]"
8617,components/camel-casper/src/main/java/org/apache/camel/component/casper/examples/CasperProcessor.java,"@@ -0,0 +1,27 @@
+package org.apache.camel.component.casper.examples;
+
+import java.util.Map;
+
+import org.apache.camel.Exchange;
+import org.apache.camel.Processor;
+
+/**
+ * Camel processor for Demo
+ * 
+ * @author p35862
+ *
+ */
+public class CasperProcessor implements Processor {
+
+	@Override
+	public void process(Exchange exchange) throws Exception {
+
+		Map<String, Object> map = exchange.getMessage().getHeaders();
+
+		for (String key : map.keySet()) {
+			System.out.println(key + "":"" + map.get(key));","[{'comment': 'This output should go to a logger. ', 'commenter': 'orpiske'}, {'comment': 'fixed', 'commenter': 'abahmanem'}]"
8617,components/camel-casper/src/test/java/org/apache/camel/component/casper/producer/CasperProducerWith_ACCOUNT_BALANCE_OperationTest.java,"@@ -0,0 +1,100 @@
+package org.apache.camel.component.casper.producer;
+
+import static org.junit.Assert.assertNotNull;
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertTrue;
+
+import java.math.BigInteger;
+
+import org.apache.camel.CamelExchangeException;
+import org.apache.camel.Exchange;
+import org.apache.camel.Produce;
+import org.apache.camel.ProducerTemplate;
+import org.apache.camel.builder.RouteBuilder;
+import org.apache.camel.component.casper.CasperConstants;
+import org.apache.camel.component.casper.CasperTestSupport;
+import org.apache.commons.cli.MissingArgumentException;
+import org.junit.jupiter.api.Test;
+
+import com.syntifi.casper.sdk.model.balance.BalanceData;
+
+class CasperProducerWith_ACCOUNT_BALANCE_OperationTest extends CasperTestSupport {
+	@Produce(""direct:start"")
+	protected ProducerTemplate template;
+
+	@Override
+	public boolean isUseAdviceWith() {
+		return false;
+	}
+
+
+	@Test
+	void testCallWith_STATE_ROOT_HASH_KEY_Parameters() throws Exception {
+
+		Exchange exchange = createExchangeWithBodyAndHeader(null, CasperConstants.OPERATION, CasperConstants.ACCOUNT_BALANCE);
+		exchange.getIn().setHeader(CasperConstants.STATE_ROOT_HASH,
+				""30cE5146268305AeeFdCC05a5f7bE7aa6dAF187937Eed9BB55Af90e1D49B7956"");
+		exchange.getIn().setHeader(CasperConstants.PURSE_UREF,
+				""uref-9cC68775d07c211e44068D5dCc2cC28A67Cb582C3e239E83Bb0c3d067C4D0363-007"");
+		template.send(exchange);
+		Object body = exchange.getIn().getBody();
+		// assert Object is a BalanceData
+		assertTrue(body instanceof BalanceData);
+		BalanceData balance = (BalanceData) body;
+		assertNotNull(balance);
+		//assert balance value
+		assertEquals(new BigInteger(""869077209920"") , balance.getValue());
+	}
+
+
+	@Test
+	 void testCallWithout_UREF_PURSE_KEY_Parameter() throws Exception {
+
+		Exchange exchange = createExchangeWithBodyAndHeader(null, CasperConstants.OPERATION, CasperConstants.ACCOUNT_BALANCE);
+		exchange.getIn().setHeader(CasperConstants.STATE_ROOT_HASH,
+				""30cE5146268305AeeFdCC05a5f7bE7aa6dAF187937Eed9BB55Af90e1D49B7956"");
+		template.send(exchange);
+		Exception exception = exchange.getException();
+		assertTrue(exception instanceof CamelExchangeException);
+		String expectedMessage = ""purseUref parameter is required   with endpoint operation "" + CasperConstants.ACCOUNT_BALANCE;
+		String actualMessage = exception.getMessage();
+
+		// assert Exception message
+		assertTrue(actualMessage.contains(expectedMessage));
+		// Cause
+		Object cause = exchange.getMessage().getHeader(CasperConstants.ERROR_CAUSE);
+		assertTrue(cause instanceof MissingArgumentException);
+	}
+
+
+	@Test
+	 void testCallWithout_STATE_ROOT_HASH_Parameter() throws Exception {
+
+		Exchange exchange = createExchangeWithBodyAndHeader(null, CasperConstants.OPERATION, CasperConstants.ACCOUNT_BALANCE);
+		exchange.getIn().setHeader(CasperConstants.PURSE_UREF,
+				""uref-9cC68775d07c211e44068D5dCc2cC28A67Cb582C3e239E83Bb0c3d067C4D0363-007"");
+
+		template.send(exchange);
+		Exception exception = exchange.getException();
+		assertTrue(exception instanceof CamelExchangeException);
+		String expectedMessage = ""stateRootHash parameter is required   with endpoint operation "" + CasperConstants.ACCOUNT_BALANCE;
+		String actualMessage = exception.getMessage();
+
+		// assert Exception message
+		System.err.println(actualMessage+  ""  ""+expectedMessage.toLowerCase());","[{'comment': 'Output in tests should also go to a logger.', 'commenter': 'orpiske'}, {'comment': 'fixed', 'commenter': 'abahmanem'}]"
8617,components/camel-casper/src/test/java/org/apache/camel/component/casper/producer/CasperProducerWith_BLOCK_TRANSFERS_OperationTest.java,"@@ -0,0 +1,70 @@
+package org.apache.camel.component.casper.producer;
+
+import static org.junit.jupiter.api.Assertions.assertTrue;
+
+import java.util.List;
+
+import org.apache.camel.Exchange;
+import org.apache.camel.Produce;
+import org.apache.camel.ProducerTemplate;
+import org.apache.camel.builder.RouteBuilder;
+import org.apache.camel.component.casper.CasperConstants;
+import org.apache.camel.component.casper.CasperTestSupport;
+import org.junit.jupiter.api.Test;
+
+import com.syntifi.casper.sdk.model.deploy.executabledeploy.Transfer;
+
+@SuppressWarnings(""unchecked"")
+class CasperProducerWith_BLOCK_TRANSFERS_OperationTest extends CasperTestSupport {
+	@Produce(""direct:start"")
+	protected ProducerTemplate template;
+
+	@Override
+	public boolean isUseAdviceWith() {
+		return false;
+	}
+
+	@Test
+	void testCallWithout_parameters() throws Exception {
+		Exchange exchange = createExchangeWithBodyAndHeader(null, CasperConstants.OPERATION, CasperConstants.BLOCK_TRANSFERS);
+		template.send(exchange);
+		Object body = exchange.getIn().getBody();
+		// assert Object is a List
+		assertTrue(body instanceof List);","[{'comment': 'I think you can use something like `assertIsInstance` (or a similar one) for this check. ', 'commenter': 'orpiske'}, {'comment': 'fixed', 'commenter': 'abahmanem'}]"
8617,components/camel-casper/src/test/java/org/apache/camel/component/casper/producer/CasperProducerWith_NETWORK_PEERS_OperationTest.java,"@@ -0,0 +1,50 @@
+package org.apache.camel.component.casper.producer;
+
+import static org.junit.jupiter.api.Assertions.assertTrue;
+import java.util.List;
+
+import org.apache.camel.Exchange;
+import org.apache.camel.Produce;
+import org.apache.camel.ProducerTemplate;
+import org.apache.camel.builder.RouteBuilder;
+import org.apache.camel.component.casper.CasperConstants;
+import org.apache.camel.component.casper.CasperTestSupport;
+import org.junit.jupiter.api.Test;
+
+import com.syntifi.casper.sdk.model.peer.PeerEntry;
+
+@SuppressWarnings(""unchecked"")
+class CasperProducerWith_NETWORK_PEERS_OperationTest extends CasperTestSupport {
+	@Produce(""direct:start"")
+	protected ProducerTemplate template;
+
+	@Override
+	public boolean isUseAdviceWith() {
+		return false;
+	}
+
+	@Test
+	void testCall() throws Exception {
+		Exchange exchange = createExchangeWithBodyAndHeader(null, CasperConstants.OPERATION, CasperConstants.NETWORK_PEERS);
+		template.send(exchange);
+		Object body = exchange.getIn().getBody();
+		// assert Object is a List
+		assertTrue(body instanceof List);
+		List<PeerEntry> peers = (List<PeerEntry>) (body);
+		assertTrue(!peers.isEmpty());
+		// assert our List contains our node
+		//URI ourTestNode = new URI(CasperConstants.TESTNET_NODE_URL);
+		// assertTrue(peers.stream().anyMatch(s ->
+		// s.getAddress().substring(s.getAddress().indexOf("":"")).equals(ourTestnode.getHost())));","[{'comment': 'Commented code should be removed. ', 'commenter': 'orpiske'}]"
8617,components/camel-casper/src/test/java/org/apache/camel/component/casper/consumer/sse/DataSetController.java,"@@ -0,0 +1,144 @@
+package org.apache.camel.component.casper.consumer.sse;
+
+import java.io.IOException;
+import java.util.List;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+
+import org.apache.camel.component.casper.consumer.sse.model.block.BlockData;
+import org.apache.camel.component.casper.consumer.sse.model.deploy.accepted.DeployAcceptedData;
+import org.apache.camel.component.casper.consumer.sse.model.deploy.expired.DeployExpiredData;
+import org.apache.camel.component.casper.consumer.sse.model.deploy.processed.DeployProcessedData;
+import org.apache.camel.component.casper.consumer.sse.model.fault.FaultData;
+import org.apache.camel.component.casper.consumer.sse.model.sig.FinalitySignatureData;
+import org.apache.camel.component.casper.consumer.sse.model.step.StepData;
+import org.springframework.web.bind.annotation.GetMapping;
+import org.springframework.web.bind.annotation.RestController;
+import org.springframework.web.servlet.mvc.method.annotation.SseEmitter;
+
+import com.fasterxml.jackson.databind.ObjectMapper;
+
+/**
+ * MVC Controler with casper sse channels
+ * 
+ * @author p35862
+ *
+ */
+@RestController
+public class DataSetController {
+
+	private final DataSetService dataSetService;
+	ObjectMapper objectMapper = new ObjectMapper();
+
+	public DataSetController(DataSetService dataSetService) {
+		this.dataSetService = dataSetService;
+	}
+
+	@GetMapping(""/events/main"")
+	public SseEmitter fetchmain() {
+		SseEmitter emitter = new SseEmitter(6000l);
+
+		ExecutorService executor = Executors.newSingleThreadExecutor();
+		executor.execute(() -> {
+			List<BlockData> dataSets = dataSetService.getBlocks();
+			try {
+
+				// emit added blocks events
+				for (BlockData dataSet : dataSets) {
+					randomDelay();
+					emitter.send(objectMapper.writeValueAsString(dataSet));
+				}
+
+				// emit processed deploys events
+				List<DeployProcessedData> datas = dataSetService.getProcessedDeploys();
+				for (DeployProcessedData dat : datas) {
+					randomDelay();
+					emitter.send(objectMapper.writeValueAsString(dat));
+
+				}
+
+				// emit steps events
+				List<StepData> steps = dataSetService.getSteps();
+				for (StepData step : steps) {
+					randomDelay();
+					emitter.send(objectMapper.writeValueAsString(step));
+				}
+
+				// emit fault events
+				List<FaultData> faults = dataSetService.getFaults();
+				for (FaultData fault : faults) {
+					randomDelay();
+					emitter.send(objectMapper.writeValueAsString(fault));
+				}
+
+				List<DeployExpiredData> expireds = dataSetService.getDeploysExpired();
+				// emit expired deploys events
+				for (DeployExpiredData exp : expireds) {
+					randomDelay();
+					emitter.send(objectMapper.writeValueAsString(exp));
+				}
+
+				emitter.complete();
+			} catch (IOException e) {
+				emitter.completeWithError(e);
+			}
+		});
+		executor.shutdown();
+		return emitter;
+	}
+
+	@GetMapping(""/events/deploys"")
+	public SseEmitter fetchdeploys() {
+		SseEmitter emitter = new SseEmitter(5000l);
+
+		ExecutorService executor = Executors.newSingleThreadExecutor();
+		executor.execute(() -> {
+			List<DeployAcceptedData> dataSets = dataSetService.getAcceptedDeploys();
+			try {
+
+				// emit accepetd deploys events
+				for (DeployAcceptedData dataSet : dataSets) {
+					randomDelay();
+					emitter.send(objectMapper.writeValueAsString(dataSet));
+				}
+
+				emitter.complete();
+			} catch (IOException e) {
+				emitter.completeWithError(e);
+			}
+		});
+		executor.shutdown();
+
+		return emitter;
+	}
+
+	@GetMapping(""/events/sigs"")
+	public SseEmitter fetchsigs() {
+		SseEmitter emitter = new SseEmitter(5000l);
+		// emit finality signatures events
+		ExecutorService executor = Executors.newSingleThreadExecutor();
+		executor.execute(() -> {
+			List<FinalitySignatureData> dataSets = dataSetService.getFinalitySignatures();
+			try {
+				for (FinalitySignatureData dataSet : dataSets) {
+					randomDelay();
+					emitter.send(dataSet);
+				}
+
+				emitter.complete();
+			} catch (IOException e) {
+				emitter.completeWithError(e);
+			}
+		});
+		executor.shutdown();
+		return emitter;
+	}
+
+	private void randomDelay() {
+		try {
+			Thread.sleep(0);","[{'comment': 'Please avoid using `Thread.sleep` as much as possible. Instead, please try to replace the code with Awaitility or, in case of synchronization / concurrency, latches and other concurrency handling mechanisms.', 'commenter': 'orpiske'}]"
8617,components/camel-casper/src/main/java/org/apache/camel/component/casper/examples/DemoApp.java,"@@ -0,0 +1,201 @@
+package org.apache.camel.component.casper.examples;
+
+import org.apache.camel.CamelContext;
+import org.apache.camel.Exchange;
+import org.apache.camel.Processor;
+import org.apache.camel.ProducerTemplate;
+import org.apache.camel.builder.RouteBuilder;
+import org.apache.camel.component.casper.CasperConstants;
+import org.apache.camel.component.jackson.JacksonDataFormat;
+import org.apache.camel.impl.DefaultCamelContext;
+
+import com.syntifi.casper.sdk.model.auction.AuctionState;
+import com.syntifi.casper.sdk.model.balance.BalanceData;
+import com.syntifi.casper.sdk.model.block.JsonBlock;
+import com.syntifi.casper.sdk.model.era.JsonEraValidators;
+import com.syntifi.casper.sdk.model.stateroothash.StateRootHashData;
+
+/**
+ * Demo Class loading Casper components example routes  
+ * @author p35862
+ *
+ */
+
+@SuppressWarnings(""deprecation"")
+public class DemoApp {
+
+	/**
+	 * loads route 1
+	 * @param cntxt : Camel context
+	 * @param temp : producerTemplate
+	 * @throws Exception : exception
+	 */
+	private static void loadroute1(CamelContext cntxt, ProducerTemplate temp) throws Exception {
+		cntxt.addRoutes(new RouteBuilder() {
+			public void configure() throws Exception {
+				from(""direct:"" + CasperConstants.STATE_ROOT_HASH).routeId(""STATE_ROOT_HASH"")
+						.to(""casper:http://65.21.227.180:7777/?operation="" + CasperConstants.STATE_ROOT_HASH)
+						.process(new Processor() {
+
+							@Override
+							public void process(Exchange exchange) throws Exception {
+								StateRootHashData state = (StateRootHashData) exchange.getIn().getBody();
+								System.err.println(""* Current STATE_ROOT_HASH is : "" + state.getStateRootHash());
+							}
+						});
+			}
+		});
+
+		cntxt.start();
+		temp.sendBody(""direct:"" + CasperConstants.STATE_ROOT_HASH, ""This is a test message"");
+		cntxt.stop();
+
+	}
+
+	/**
+	 * loads route 2
+	 * @param cntxt : Camel context
+	 * @param temp : producerTemplate
+	 * @throws Exception : exception
+	 */
+	private static void loadroute2(CamelContext cntxt, ProducerTemplate temp) throws Exception {
+		cntxt.addRoutes(new RouteBuilder() {
+			public void configure() throws Exception {
+				from(""file:src/main/resources/datas/?fileName=get_block.txt&charset=utf-8&noop=true"")
+						.convertBodyTo(String.class).routeId(CasperConstants.BLOCK).setHeader(""BLOCK_HASH"", body())
+						.to(""casper:http://65.21.227.180:7777/?operation="" + CasperConstants.BLOCK)
+
+						.process(new Processor() {
+
+							@Override
+							public void process(Exchange exchange) throws Exception {
+								JsonBlock block = (JsonBlock) exchange.getIn().getBody();
+								String blockHash = (String) exchange.getIn().getHeader(""BLOCK_HASH"");
+								System.err.println(""* getBlock was called with parameter block Hash = "" + blockHash);
+								System.err.println(""* getBlock retrieved a block that was minted at era =""
+										+ block.getHeader().getEraId() + "" and has as parent hash = ""
+										+ block.getHeader().getParentHash());
+
+							}
+						});
+
+			}
+
+		});
+
+		cntxt.start();
+		Thread.sleep(5000);","[{'comment': 'Please avoid using `Thread.sleep` as much as possible. Instead, please try to replace the code with Awaitility or, in case of synchronization / concurrency, latches and other concurrency handling mechanisms.', 'commenter': 'orpiske'}]"
8617,components/camel-casper/pom.xml,"@@ -0,0 +1,395 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+
+<!--
+    Licensed to the Apache Software Foundation (ASF) under one or more
+    contributor license agreements.  See the NOTICE file distributed with
+    this work for additional information regarding copyright ownership.
+    The ASF licenses this file to You under the Apache License, Version 2.0
+    (the ""License""); you may not use this file except in compliance with
+    the License.  You may obtain a copy of the License at
+         http://www.apache.org/licenses/LICENSE-2.0
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an ""AS IS"" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
+
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+
+	<modelVersion>4.0.0</modelVersion>
+
+	<parent>
+		<groupId>org.apache.camel</groupId>
+		<artifactId>components</artifactId>
+		<version>3.20.0-SNAPSHOT</version>
+	</parent>
+
+
+	<artifactId>camel-casper</artifactId>
+	<packaging>jar</packaging>
+
+	<name>Camel :: Casper</name>
+	<description>Camel Casper blockchaine component</description>","[{'comment': ""There's a typo in the description."", 'commenter': 'orpiske'}]"
8617,components/camel-casper/pom.xml,"@@ -0,0 +1,395 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+
+<!--
+    Licensed to the Apache Software Foundation (ASF) under one or more
+    contributor license agreements.  See the NOTICE file distributed with
+    this work for additional information regarding copyright ownership.
+    The ASF licenses this file to You under the Apache License, Version 2.0
+    (the ""License""); you may not use this file except in compliance with
+    the License.  You may obtain a copy of the License at
+         http://www.apache.org/licenses/LICENSE-2.0
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an ""AS IS"" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+
+
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+
+	<modelVersion>4.0.0</modelVersion>
+
+	<parent>
+		<groupId>org.apache.camel</groupId>
+		<artifactId>components</artifactId>
+		<version>3.20.0-SNAPSHOT</version>
+	</parent>
+
+
+	<artifactId>camel-casper</artifactId>
+	<packaging>jar</packaging>
+
+	<name>Camel :: Casper</name>
+	<description>Camel Casper blockchaine component</description>
+	<url>https://casperlabs.io/</url>
+
+
+	<properties>
+		<compiler.source>1.8</compiler.source>
+		<compiler.target>1.8</compiler.target>
+		<maven-compiler-plugin.version>3.8.1</maven-compiler-plugin.version>
+		<maven-resources-plugin.version>3.2.0</maven-resources-plugin.version>","[{'comment': 'Compilation and/or build parameters should try to reuse what is already defined in the parent pom(s). ', 'commenter': 'orpiske'}]"
8646,components/camel-milo/src/main/java/org/apache/camel/component/milo/client/MiloClientProducer.java,"@@ -91,7 +92,13 @@ public boolean process(Exchange exchange, AsyncCallback async) {
         final Boolean await = msg.getHeader(MiloConstants.HEADER_AWAIT, this.defaultAwaitWrites, Boolean.class);
 
         if (TRUE.equals(await)) {
-            future.whenComplete((v, ex) -> async.done(false));
+            future.whenComplete((o, throwable) -> {
+                        final DefaultMessage newMessage = new DefaultMessage(exchange);","[{'comment': 'I dont think you need to set a new message as this leads to loosing headers and whatnot.\r\n\r\nYou usually just set the result directly on the message, eg\r\n\r\nexchange.getMessage().setBody(...)\r\n', 'commenter': 'davsclaus'}]"
8646,components/camel-milo/src/main/java/org/apache/camel/component/milo/client/MiloClientProducer.java,"@@ -25,6 +25,7 @@
 import org.apache.camel.Message;
 import org.apache.camel.component.milo.MiloConstants;
 import org.apache.camel.support.DefaultAsyncProducer;
+import org.apache.camel.support.DefaultMessage;","[{'comment': 'Remove this unusued import', 'commenter': 'davsclaus'}]"
8646,components/camel-milo/src/main/java/org/apache/camel/component/milo/client/MiloClientProducer.java,"@@ -91,7 +92,11 @@ public boolean process(Exchange exchange, AsyncCallback async) {
         final Boolean await = msg.getHeader(MiloConstants.HEADER_AWAIT, this.defaultAwaitWrites, Boolean.class);
 
         if (TRUE.equals(await)) {
-            future.whenComplete((v, ex) -> async.done(false));
+            future.whenComplete((result, throwable) -> {
+                        msg.setBody(result);","[{'comment': 'Ah what if throwable != null, eg I assume there was an error, then its likely better to set response, on the exchange\r\n\r\nif (throwable != null) {\r\nmsg.getExchange().setException(throwable);\r\n} else {\r\n  msg.setBody(result);\r\n}\r\n', 'commenter': 'davsclaus'}, {'comment': 'Ok, I amended the commit where I added that and also removed an unnecessary import also.  ', 'commenter': 'rangoy'}]"
8661,components/camel-git/src/main/docs/git-component.adoc,"@@ -83,5 +83,17 @@ from(""git:///tmp/testRepo?type=commit"")
     .to(....)
 ---------------------------------------
 
+== Custom config file
+By default camel-git will load .gitconfig file from user home folder. You","[{'comment': 'Use quotes to force the formatting to recognize this as a file. For instance, to make it like this `.gitconfig`.', 'commenter': 'orpiske'}, {'comment': 'NP. I will do that.', 'commenter': 'gilvansfilho'}, {'comment': 'Done.', 'commenter': 'gilvansfilho'}]"
8661,components/camel-git/src/main/java/org/apache/camel/component/RepositoryFactory.java,"@@ -0,0 +1,76 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component;
+
+import java.io.File;
+import java.io.IOException;
+
+import org.apache.camel.component.git.GitEndpoint;
+import org.apache.camel.util.ObjectHelper;
+import org.eclipse.jgit.lib.Repository;
+import org.eclipse.jgit.storage.file.FileRepositoryBuilder;
+import org.eclipse.jgit.util.SystemReader;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public abstract class RepositoryFactory {
+
+    private static final Logger LOG = LoggerFactory.getLogger(RepositoryFactory.class);
+    private static final SystemReader DEFAULT_INSTANCE;
+
+    static {
+        DEFAULT_INSTANCE = SystemReader.getInstance();
+    }
+
+    private RepositoryFactory() {
+    }
+
+    public static Repository of(GitEndpoint endpoint) throws IOException {
+        if (ObjectHelper.isNotEmpty(endpoint.getGitConfigFile())) {
+            return fromPathToConfigFile(endpoint, endpoint.getGitConfigFile());
+        }
+        return getRepository(endpoint, DEFAULT_INSTANCE);
+    }
+
+    private static Repository fromPathToConfigFile(GitEndpoint endpoint, String pathToConfigFile) throws IOException {
+        if (ObjectHelper.isEmpty(pathToConfigFile)) {
+            throw new IllegalArgumentException(""Path to git config file must be supplied"");
+        }
+        File gitConfigFile;
+        if (pathToConfigFile.startsWith(""/"")) { //load from system","[{'comment': ""Wouldn't this break on Windows? "", 'commenter': 'orpiske'}, {'comment': 'Sure, this will. I will change.', 'commenter': 'gilvansfilho'}, {'comment': '@oscerd \r\n> Maybe we can also point a remote configfile through resource helper and copy locally in the git repository before using it.\r\n\r\nDo you think We do it using same config param (`gitConfigFile`) or other? like `remoteGitConfigFile`', 'commenter': 'gilvansfilho'}, {'comment': 'Probably with remoteGitConfigFile. With resource helper you could able to grab file content directly from classpath, filesystem, http etc.', 'commenter': 'oscerd'}, {'comment': 'Done.', 'commenter': 'gilvansfilho'}]"
8661,components/camel-git/src/main/java/org/apache/camel/component/RepositoryFactory.java,"@@ -0,0 +1,76 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component;
+
+import java.io.File;
+import java.io.IOException;
+
+import org.apache.camel.component.git.GitEndpoint;
+import org.apache.camel.util.ObjectHelper;
+import org.eclipse.jgit.lib.Repository;
+import org.eclipse.jgit.storage.file.FileRepositoryBuilder;
+import org.eclipse.jgit.util.SystemReader;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public abstract class RepositoryFactory {
+
+    private static final Logger LOG = LoggerFactory.getLogger(RepositoryFactory.class);
+    private static final SystemReader DEFAULT_INSTANCE;
+
+    static {
+        DEFAULT_INSTANCE = SystemReader.getInstance();
+    }
+
+    private RepositoryFactory() {
+    }
+
+    public static Repository of(GitEndpoint endpoint) throws IOException {
+        if (ObjectHelper.isNotEmpty(endpoint.getGitConfigFile())) {
+            return fromPathToConfigFile(endpoint, endpoint.getGitConfigFile());
+        }
+        return getRepository(endpoint, DEFAULT_INSTANCE);
+    }
+
+    private static Repository fromPathToConfigFile(GitEndpoint endpoint, String pathToConfigFile) throws IOException {
+        if (ObjectHelper.isEmpty(pathToConfigFile)) {
+            throw new IllegalArgumentException(""Path to git config file must be supplied"");
+        }
+        File gitConfigFile;
+        if (pathToConfigFile.startsWith(""/"")) { //load from system
+            gitConfigFile = new File(pathToConfigFile);
+        } else { //load from resources
+            gitConfigFile = new File(endpoint.getClass().getClassLoader().getResource(pathToConfigFile).getFile());
+        }
+        return getRepository(endpoint, new CustomConfigSystemReader(gitConfigFile));
+    }
+
+    private static Repository getRepository(GitEndpoint endpoint, SystemReader instance) throws IOException {
+        FileRepositoryBuilder builder = new FileRepositoryBuilder();
+        try {
+            SystemReader.setInstance(instance);
+            // scan environment GIT_* variables
+            return builder.setGitDir(new File(endpoint.getLocalPath(), "".git"")).readEnvironment()
+                    .findGitDir() // scan up the file system tree
+                    .build();
+        } catch (IOException e) {
+            LOG.error(""There was an error, cannot open {} repository"", endpoint.getLocalPath());
+            throw e;","[{'comment': 'Maybe describe the error that caused the problem. Something like: `LOG.error(""There was an error opening the {} repository: {}"", endpoint.getLocalPath(), e.getMessage);` \r\n\r\nOr ... just wrap the exception. ', 'commenter': 'orpiske'}, {'comment': '`LOG.error(""There was an error opening the {} repository: {}"", endpoint.getLocalPath(), e.getMessage);` This will create a sonar issue.\r\n\r\nSo wrap on wich exception?', 'commenter': 'gilvansfilho'}, {'comment': 'I think `RuntimeCamelException` should do the trick.', 'commenter': 'orpiske'}, {'comment': 'Done.', 'commenter': 'gilvansfilho'}]"
8661,components/camel-git/src/main/java/org/apache/camel/component/RepositoryFactory.java,"@@ -0,0 +1,111 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component;
+
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.net.URL;
+import java.nio.channels.Channels;
+import java.nio.channels.ReadableByteChannel;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.util.Arrays;
+import java.util.List;
+
+import org.apache.camel.RuntimeCamelException;
+import org.apache.camel.component.git.GitEndpoint;
+import org.apache.camel.support.ResourceHelper;
+import org.apache.camel.util.ObjectHelper;
+import org.eclipse.jgit.lib.Repository;
+import org.eclipse.jgit.storage.file.FileRepositoryBuilder;
+import org.eclipse.jgit.util.SystemReader;
+
+public abstract class RepositoryFactory {
+
+    private static final SystemReader DEFAULT_INSTANCE;
+    private static final List<String> VALID_SCHEMES = Arrays.asList(""classpath:"", ""file:"", ""http:"", ""https:"");
+
+    static {
+        DEFAULT_INSTANCE = SystemReader.getInstance();
+    }
+
+    private RepositoryFactory() {
+    }
+
+    public static Repository of(GitEndpoint endpoint) {
+        if (ObjectHelper.isNotEmpty(endpoint.getGitConfigFile())) {
+            return resolveConfigFile(endpoint, endpoint.getGitConfigFile());
+        }
+        return getRepository(endpoint, DEFAULT_INSTANCE);
+    }
+
+    private static Repository resolveConfigFile(GitEndpoint endpoint, String uri) {
+        if (ObjectHelper.isEmpty(uri)) {
+            throw new IllegalArgumentException(""URI to git config file must be supplied"");
+        }
+
+        if (!ResourceHelper.hasScheme(uri) || !VALID_SCHEMES.contains(ResourceHelper.getScheme(uri))) {
+            throw new IllegalArgumentException(
+                    ""URI to git config file must have scheme:path pattern where scheme could be classpath, file, http or https"");
+        }
+
+        String schema = ResourceHelper.getScheme(uri);
+        String path = uri.substring(schema.length());
+
+        File gitConfigFile;
+        if (ResourceHelper.isClasspathUri(uri)) {
+            gitConfigFile = new File(endpoint.getClass().getClassLoader().getResource(path).getFile());
+        } else if (ResourceHelper.isHttpUri(uri)) {
+            try {
+                gitConfigFile = getTempFileFromHttp(uri);
+            } catch (IOException e) {
+                throw new RuntimeCamelException(String.format(""Something goes wrong when loading: %s"", uri), e);","[{'comment': 'Just a minor grammatical nitpick: ""Something went wrong when loading"". ', 'commenter': 'orpiske'}]"
8661,components/camel-git/src/main/java/org/apache/camel/component/RepositoryFactory.java,"@@ -0,0 +1,111 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component;
+
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.net.URL;
+import java.nio.channels.Channels;
+import java.nio.channels.ReadableByteChannel;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.util.Arrays;
+import java.util.List;
+
+import org.apache.camel.RuntimeCamelException;
+import org.apache.camel.component.git.GitEndpoint;
+import org.apache.camel.support.ResourceHelper;
+import org.apache.camel.util.ObjectHelper;
+import org.eclipse.jgit.lib.Repository;
+import org.eclipse.jgit.storage.file.FileRepositoryBuilder;
+import org.eclipse.jgit.util.SystemReader;
+
+public abstract class RepositoryFactory {
+
+    private static final SystemReader DEFAULT_INSTANCE;
+    private static final List<String> VALID_SCHEMES = Arrays.asList(""classpath:"", ""file:"", ""http:"", ""https:"");
+
+    static {
+        DEFAULT_INSTANCE = SystemReader.getInstance();
+    }
+
+    private RepositoryFactory() {
+    }
+
+    public static Repository of(GitEndpoint endpoint) {
+        if (ObjectHelper.isNotEmpty(endpoint.getGitConfigFile())) {
+            return resolveConfigFile(endpoint, endpoint.getGitConfigFile());
+        }
+        return getRepository(endpoint, DEFAULT_INSTANCE);
+    }
+
+    private static Repository resolveConfigFile(GitEndpoint endpoint, String uri) {
+        if (ObjectHelper.isEmpty(uri)) {
+            throw new IllegalArgumentException(""URI to git config file must be supplied"");
+        }
+
+        if (!ResourceHelper.hasScheme(uri) || !VALID_SCHEMES.contains(ResourceHelper.getScheme(uri))) {
+            throw new IllegalArgumentException(
+                    ""URI to git config file must have scheme:path pattern where scheme could be classpath, file, http or https"");
+        }
+
+        String schema = ResourceHelper.getScheme(uri);
+        String path = uri.substring(schema.length());
+
+        File gitConfigFile;
+        if (ResourceHelper.isClasspathUri(uri)) {
+            gitConfigFile = new File(endpoint.getClass().getClassLoader().getResource(path).getFile());
+        } else if (ResourceHelper.isHttpUri(uri)) {
+            try {
+                gitConfigFile = getTempFileFromHttp(uri);
+            } catch (IOException e) {
+                throw new RuntimeCamelException(String.format(""Something goes wrong when loading: %s"", uri), e);
+            }
+        } else { //load from system
+            gitConfigFile = new File(path);
+            if (!gitConfigFile.exists() || gitConfigFile.isDirectory()) {","[{'comment': ""This fails to take into account access permissions for file. I'd recommend using [Files.isReadable](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/nio/file/Files.html#isReadable(java.nio.file.Path)) to ensure that the file is a regular file that exists and is also readable."", 'commenter': 'orpiske'}]"
8661,components/camel-git/src/main/java/org/apache/camel/component/RepositoryFactory.java,"@@ -0,0 +1,111 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component;
+
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.net.URL;
+import java.nio.channels.Channels;
+import java.nio.channels.ReadableByteChannel;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.util.Arrays;
+import java.util.List;
+
+import org.apache.camel.RuntimeCamelException;
+import org.apache.camel.component.git.GitEndpoint;
+import org.apache.camel.support.ResourceHelper;
+import org.apache.camel.util.ObjectHelper;
+import org.eclipse.jgit.lib.Repository;
+import org.eclipse.jgit.storage.file.FileRepositoryBuilder;
+import org.eclipse.jgit.util.SystemReader;
+
+public abstract class RepositoryFactory {
+
+    private static final SystemReader DEFAULT_INSTANCE;
+    private static final List<String> VALID_SCHEMES = Arrays.asList(""classpath:"", ""file:"", ""http:"", ""https:"");
+
+    static {
+        DEFAULT_INSTANCE = SystemReader.getInstance();
+    }
+
+    private RepositoryFactory() {
+    }
+
+    public static Repository of(GitEndpoint endpoint) {
+        if (ObjectHelper.isNotEmpty(endpoint.getGitConfigFile())) {
+            return resolveConfigFile(endpoint, endpoint.getGitConfigFile());
+        }
+        return getRepository(endpoint, DEFAULT_INSTANCE);
+    }
+
+    private static Repository resolveConfigFile(GitEndpoint endpoint, String uri) {
+        if (ObjectHelper.isEmpty(uri)) {
+            throw new IllegalArgumentException(""URI to git config file must be supplied"");
+        }
+
+        if (!ResourceHelper.hasScheme(uri) || !VALID_SCHEMES.contains(ResourceHelper.getScheme(uri))) {
+            throw new IllegalArgumentException(
+                    ""URI to git config file must have scheme:path pattern where scheme could be classpath, file, http or https"");
+        }
+
+        String schema = ResourceHelper.getScheme(uri);
+        String path = uri.substring(schema.length());
+
+        File gitConfigFile;
+        if (ResourceHelper.isClasspathUri(uri)) {
+            gitConfigFile = new File(endpoint.getClass().getClassLoader().getResource(path).getFile());
+        } else if (ResourceHelper.isHttpUri(uri)) {
+            try {
+                gitConfigFile = getTempFileFromHttp(uri);
+            } catch (IOException e) {
+                throw new RuntimeCamelException(String.format(""Something goes wrong when loading: %s"", uri), e);
+            }
+        } else { //load from system
+            gitConfigFile = new File(path);
+            if (!gitConfigFile.exists() || gitConfigFile.isDirectory()) {
+                throw new IllegalArgumentException(String.format(""Invalid file: %s"", path));","[{'comment': 'And based on the comment above, I\'d reword the exception message to: `""The configuration file at %s is unreadable (either missing, lacking proper access permission os is not a regular file"")`', 'commenter': 'orpiske'}]"
8661,components/camel-git/src/main/java/org/apache/camel/component/RepositoryFactory.java,"@@ -0,0 +1,111 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component;
+
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.net.URL;
+import java.nio.channels.Channels;
+import java.nio.channels.ReadableByteChannel;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.util.Arrays;
+import java.util.List;
+
+import org.apache.camel.RuntimeCamelException;
+import org.apache.camel.component.git.GitEndpoint;
+import org.apache.camel.support.ResourceHelper;
+import org.apache.camel.util.ObjectHelper;
+import org.eclipse.jgit.lib.Repository;
+import org.eclipse.jgit.storage.file.FileRepositoryBuilder;
+import org.eclipse.jgit.util.SystemReader;
+
+public abstract class RepositoryFactory {
+
+    private static final SystemReader DEFAULT_INSTANCE;
+    private static final List<String> VALID_SCHEMES = Arrays.asList(""classpath:"", ""file:"", ""http:"", ""https:"");
+
+    static {
+        DEFAULT_INSTANCE = SystemReader.getInstance();
+    }
+
+    private RepositoryFactory() {
+    }
+
+    public static Repository of(GitEndpoint endpoint) {
+        if (ObjectHelper.isNotEmpty(endpoint.getGitConfigFile())) {
+            return resolveConfigFile(endpoint, endpoint.getGitConfigFile());
+        }
+        return getRepository(endpoint, DEFAULT_INSTANCE);
+    }
+
+    private static Repository resolveConfigFile(GitEndpoint endpoint, String uri) {
+        if (ObjectHelper.isEmpty(uri)) {
+            throw new IllegalArgumentException(""URI to git config file must be supplied"");
+        }
+
+        if (!ResourceHelper.hasScheme(uri) || !VALID_SCHEMES.contains(ResourceHelper.getScheme(uri))) {
+            throw new IllegalArgumentException(
+                    ""URI to git config file must have scheme:path pattern where scheme could be classpath, file, http or https"");
+        }
+
+        String schema = ResourceHelper.getScheme(uri);
+        String path = uri.substring(schema.length());
+
+        File gitConfigFile;
+        if (ResourceHelper.isClasspathUri(uri)) {
+            gitConfigFile = new File(endpoint.getClass().getClassLoader().getResource(path).getFile());
+        } else if (ResourceHelper.isHttpUri(uri)) {
+            try {
+                gitConfigFile = getTempFileFromHttp(uri);
+            } catch (IOException e) {
+                throw new RuntimeCamelException(String.format(""Something goes wrong when loading: %s"", uri), e);
+            }
+        } else { //load from system
+            gitConfigFile = new File(path);
+            if (!gitConfigFile.exists() || gitConfigFile.isDirectory()) {
+                throw new IllegalArgumentException(String.format(""Invalid file: %s"", path));
+            }
+        }
+
+        return getRepository(endpoint, new CustomConfigSystemReader(gitConfigFile));
+    }
+
+    private static Repository getRepository(GitEndpoint endpoint, SystemReader instance) {
+        FileRepositoryBuilder builder = new FileRepositoryBuilder();
+        try {
+            SystemReader.setInstance(instance);
+            // scan environment GIT_* variables
+            return builder.setGitDir(new File(endpoint.getLocalPath(), "".git"")).readEnvironment()
+                    .findGitDir() // scan up the file system tree
+                    .build();
+        } catch (IOException e) {
+            throw new RuntimeCamelException(
+                    String.format(""There was an error, cannot open %s repository"", endpoint.getLocalPath()), e);","[{'comment': 'Nitpicking a bit: ""There was an error opening the repository at %s.""', 'commenter': 'orpiske'}]"
8661,components/camel-git/src/main/java/org/apache/camel/component/git/GitEndpoint.java,"@@ -77,6 +77,9 @@ public class GitEndpoint extends DefaultEndpoint {
               label = ""producer"")
     private String operation;
 
+    @UriParam(description = ""A String with path to a .gitconfig file"", label = ""producer,consumer,advanced"")","[{'comment': 'producer and consumer is default, so only use ""advanced""', 'commenter': 'davsclaus'}]"
8713,core/camel-api/src/main/java/org/apache/camel/AsyncCallback.java,"@@ -19,7 +19,7 @@
 /**
  * The callback interface for an {@link AsyncProcessor} so that it can notify you when an {@link Exchange} is done.
  * <p/>
- * For example a {@link AsyncProcessor} should invoke the done method when the {@link Exchange} is ready to be continued
+ * For example a {@link AsyzncProcessor} should invoke the done method when the {@link Exchange} is ready to be continued","[{'comment': 'I do think this is a typo', 'commenter': 'oscerd'}, {'comment': 'yes its a typo', 'commenter': 'davsclaus'}]"
8717,dsl/camel-jbang/camel-jbang-core/src/main/java/org/apache/camel/dsl/jbang/core/commands/Run.java,"@@ -342,6 +342,7 @@ private int run() throws Exception {
         if (dep == null) {
             dep = dependencies;
         } else if (dependencies != null && !dependencies.equals(dep)) {
+            dep = dep.substring(0, dep.lastIndexOf("",""));","[{'comment': 'What if there is no comma in dep, then indexOf returns -1 and substring will fail. I think we need to check if dep ends with comma we can avoid adding the comma', 'commenter': 'davsclaus'}]"
8749,dsl/camel-jbang/camel-jbang-core/src/main/java/org/apache/camel/dsl/jbang/core/common/RuntimeUtil.java,"@@ -83,4 +83,20 @@ public static void loadProperties(Properties properties, File file) throws IOExc
         }
     }
 
+    public static String getDependencies(Properties properties) {
+        String deps = properties.getProperty(""camel.jbang.dependencies"");","[{'comment': 'Warning `properties` could be null according to https://github.com/apache/camel/pull/8749/files#diff-b62a4b0acb50014174399c284b5540cf84016571e5c789a23edc8d843692721cL345', 'commenter': 'essobedo'}, {'comment': 'To be clear, if `properties` is `null`, calling `properties.getProperty(""camel.jbang.dependencies"")` will throw a `NullPointerException`', 'commenter': 'essobedo'}, {'comment': ""My understanding is that properties are expected to be not null, if that's not the case we can see NullPointerException at so many other places."", 'commenter': 'mrinalsharma'}, {'comment': ""If you check these lines https://github.com/apache/camel/blob/59c6450582fa662c168021360c42f1e78a4cc438/dsl/camel-jbang/camel-jbang-core/src/main/java/org/apache/camel/dsl/jbang/core/commands/Run.java#L266-L269, you will see that `profileProperties` is `null` if the file doesn't exist which can occur so I confirm that `properties` can be `null`"", 'commenter': 'essobedo'}, {'comment': 'Sure, I should have the fix soon.', 'commenter': 'mrinalsharma'}]"
8749,dsl/camel-jbang/camel-jbang-core/src/main/java/org/apache/camel/dsl/jbang/core/common/RuntimeUtil.java,"@@ -83,4 +83,20 @@ public static void loadProperties(Properties properties, File file) throws IOExc
         }
     }
 
+    public static String getDependencies(Properties properties) {
+        String deps = properties.getProperty(""camel.jbang.dependencies"");
+        if (deps != null) {
+            deps = deps.trim();
+            if (deps.length() > 0 && deps.charAt(0) == ',') {
+                deps = deps.substring(1);
+            }
+            if (deps.length() > 0 && deps.charAt(deps.length() - 1) == ',') {
+                deps = deps.substring(0, deps.lastIndexOf("",""));
+            }
+        } else {
+            deps = new String("""");","[{'comment': '```suggestion\r\n            deps = """";\r\n```', 'commenter': 'essobedo'}]"
8749,dsl/camel-jbang/camel-jbang-core/src/main/java/org/apache/camel/dsl/jbang/core/commands/Run.java,"@@ -342,15 +342,15 @@ private int run() throws Exception {
         writeSetting(main, profileProperties, ""camel.jbang.console"", console ? ""true"" : ""false"");
         writeSetting(main, profileProperties, ""camel.main.routesCompileDirectory"", WORK_DIR);
         // merge existing dependencies with --deps
-        String dep = profileProperties != null ? profileProperties.getProperty(""camel.jbang.dependencies"") : null;
-        if (dep == null) {
-            dep = dependencies;
-        } else if (dependencies != null && !dependencies.equals(dep)) {
-            dep += "","" + dependencies;
-        }
-        if (dep != null) {
-            main.addInitialProperty(""camel.jbang.dependencies"", dep);
-            writeSettings(""camel.jbang.dependencies"", dep);
+        String deps = RuntimeUtil.getDependencies(profileProperties);
+        if (deps.isBlank()) {
+            deps = dependencies;
+        } else if (dependencies != null && !dependencies.equals(deps)) {
+            deps += "","" + dependencies;
+        }
+        if (!deps.isBlank()) {","[{'comment': 'Warning `deps` could be `null` in case `deps.isBlank()` returns initially `true` and `dependencies` is `null`. In this case, we would end up with an NPE', 'commenter': 'essobedo'}, {'comment': 'Thanks for the clarification.', 'commenter': 'mrinalsharma'}]"
8774,components/camel-splunk-hec/src/main/java/org/apache/camel/component/splunkhec/SplunkHECConfiguration.java,"@@ -99,6 +101,20 @@ public void setHost(String host) {
         this.host = host;
     }
 
+    /**
+     * Splunk endpoint
+     *   Defaults to /services/collector/event
+     *   To write RAW data like JSON use /services/collector/raw
+     *   To extract timestamps in Splunk>8.0 /services/collector/event?auto_extract_timestamp=true
+     */
+    public void setEndpoint(String endpoint) {","[{'comment': 'Are there other endpoints? And endpoint can maybe confuse as Camel also has a concept of endpoint. So maybe we can come up with a different name?\r\n\r\nFor the last with the query parameter then that will not work as Camel think its another parameter.\r\n\r\nSo maybe come up\r\n\r\n1) a new name, with 3 enum values: default, raw, timestamp\r\n2) And then you can set the url based on the endpoint inside the camel component', 'commenter': 'davsclaus'}, {'comment': 'Hi Claus, thank you very much for your quick reply and check of the PR!\r\n\r\n- Thank you very mich for the hint with the name, okay to set it to ""SplunkRESTEndpoint""? Which would be a better naming. \r\n\r\n- If the url includes a question mark the user can utilize RAW{} https://camel.apache.org/manual/faq/how-do-i-configure-endpoints.html#HowdoIconfigureendpoints-Configuringparametervaluesusingrawvalues so it will work. Modules like azure-eventhub do make excessive use of it for connection strings, passwords, ... for example:\r\n\r\n`.from(azure-eventhubs:?connectionString=RAW({{camel.component.azure-eventhubs.connection-string}}) ...`\r\n\r\n- For the reason of extendability, enum does not sound like a good fit to me, since it requires changes to the software and different versions in place on every new Splunk version/endpoint. The ENUM may also suggest RESTEndpoints that are not available in older Splunk versions. So I suggest to stick with a strong default that does not introduce a breaking change, but full flexibility to adpot to new Splunk versions without changing the camel module. See: https://docs.splunk.com/Documentation/SplunkCloud/8.2.2203/Data/HECRESTendpoints\r\n\r\n- Naming in the module can be improved a lot, since hostAndIp are written aus SplunkURL where users normally expect an URL compliant to RFC1738 (https://datatracker.ietf.org/doc/html/rfc1738) including the REST endpoint including http or https (including RAW() for handling slashes). One possible way to improve and keep backwards compability would be introduction of a configuration parameter ""connectionString"" that has first priority if set and includes all information. But I guess that is better adressed in a second pull request.', 'commenter': 'kremers'}, {'comment': 'Thanks for the detailed feedback. Yeah components can surely be improved, you are welcome to send more PRs.', 'commenter': 'davsclaus'}]"
8774,components/camel-splunk-hec/src/main/java/org/apache/camel/component/splunkhec/SplunkHECConfiguration.java,"@@ -36,6 +36,8 @@ public class SplunkHECConfiguration {
     private String source = ""camel"";
     @UriParam
     private String host;
+    @UriParam(defaultValue = ""/services/collector/event"")
+    private String splunkRESTEndpoint = ""/services/collector/event"";","[{'comment': 'Cane we use `splunkEndpoint` instead as upper-case REST make it a bit more unusual and a bit harder to read.', 'commenter': 'davsclaus'}, {'comment': ""Yes, I'll change it."", 'commenter': 'kremers'}, {'comment': 'Thanks that was quick', 'commenter': 'davsclaus'}]"
8820,components/camel-rocketmq/src/main/java/org/apache/camel/component/rocketmq/RocketMQComponent.java,"@@ -0,0 +1,216 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.camel.component.rocketmq;
+
+import java.util.Map;
+
+import org.apache.camel.spi.Metadata;
+import org.apache.camel.spi.annotations.Component;
+import org.apache.camel.support.DefaultComponent;
+
+@Component(""rocketmq"")
+public class RocketMQComponent extends DefaultComponent {
+
+    @Metadata(label = ""producer"")
+    private String producerGroup;
+
+    @Metadata(label = ""consumer"")
+    private String consumerGroup;
+
+    @Metadata(label = ""consumer"", defaultValue = ""*"")
+    private String subscribeTags = ""*"";
+
+    @Metadata(label = ""common"")
+    private String sendTag = """";
+
+    @Metadata(label = ""common"", defaultValue = ""localhost:9876"")
+    private String namesrvAddr = ""localhost:9876"";
+
+    @Metadata(label = ""producer"")
+    private String replyToTopic;
+
+    @Metadata(label = ""producer"")
+    private String replyToConsumerGroup;
+
+    @Metadata(label = ""advance"", defaultValue = ""10000"")","[{'comment': 'advanced', 'commenter': 'davsclaus'}]"
8820,components/camel-rocketmq/src/main/java/org/apache/camel/component/rocketmq/RocketMQComponent.java,"@@ -0,0 +1,216 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.camel.component.rocketmq;
+
+import java.util.Map;
+
+import org.apache.camel.spi.Metadata;
+import org.apache.camel.spi.annotations.Component;
+import org.apache.camel.support.DefaultComponent;
+
+@Component(""rocketmq"")
+public class RocketMQComponent extends DefaultComponent {
+
+    @Metadata(label = ""producer"")
+    private String producerGroup;
+
+    @Metadata(label = ""consumer"")
+    private String consumerGroup;
+
+    @Metadata(label = ""consumer"", defaultValue = ""*"")
+    private String subscribeTags = ""*"";
+
+    @Metadata(label = ""common"")
+    private String sendTag = """";
+
+    @Metadata(label = ""common"", defaultValue = ""localhost:9876"")
+    private String namesrvAddr = ""localhost:9876"";
+
+    @Metadata(label = ""producer"")
+    private String replyToTopic;
+
+    @Metadata(label = ""producer"")
+    private String replyToConsumerGroup;
+
+    @Metadata(label = ""advance"", defaultValue = ""10000"")
+    private long requestTimeoutMillis = 10000L;
+
+    @Metadata(label = ""advance"", defaultValue = ""1000"")","[{'comment': 'advanced', 'commenter': 'davsclaus'}]"
8820,components/camel-rocketmq/src/main/java/org/apache/camel/component/rocketmq/RocketMQComponent.java,"@@ -0,0 +1,216 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.camel.component.rocketmq;
+
+import java.util.Map;
+
+import org.apache.camel.spi.Metadata;
+import org.apache.camel.spi.annotations.Component;
+import org.apache.camel.support.DefaultComponent;
+
+@Component(""rocketmq"")
+public class RocketMQComponent extends DefaultComponent {
+
+    @Metadata(label = ""producer"")
+    private String producerGroup;
+
+    @Metadata(label = ""consumer"")
+    private String consumerGroup;
+
+    @Metadata(label = ""consumer"", defaultValue = ""*"")
+    private String subscribeTags = ""*"";
+
+    @Metadata(label = ""common"")
+    private String sendTag = """";
+
+    @Metadata(label = ""common"", defaultValue = ""localhost:9876"")
+    private String namesrvAddr = ""localhost:9876"";
+
+    @Metadata(label = ""producer"")
+    private String replyToTopic;
+
+    @Metadata(label = ""producer"")
+    private String replyToConsumerGroup;
+
+    @Metadata(label = ""advance"", defaultValue = ""10000"")
+    private long requestTimeoutMillis = 10000L;
+
+    @Metadata(label = ""advance"", defaultValue = ""1000"")
+    private long requestTimeoutCheckerIntervalMillis = 1000L;
+
+    @Metadata(label = ""producer"", defaultValue = ""false"")
+    private boolean waitForSendResult;
+
+    @Metadata(label = ""accessKey"")","[{'comment': 'label = secret, secure = true', 'commenter': 'davsclaus'}]"
8820,components/camel-rocketmq/src/main/java/org/apache/camel/component/rocketmq/RocketMQComponent.java,"@@ -0,0 +1,216 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.camel.component.rocketmq;
+
+import java.util.Map;
+
+import org.apache.camel.spi.Metadata;
+import org.apache.camel.spi.annotations.Component;
+import org.apache.camel.support.DefaultComponent;
+
+@Component(""rocketmq"")
+public class RocketMQComponent extends DefaultComponent {
+
+    @Metadata(label = ""producer"")
+    private String producerGroup;
+
+    @Metadata(label = ""consumer"")
+    private String consumerGroup;
+
+    @Metadata(label = ""consumer"", defaultValue = ""*"")
+    private String subscribeTags = ""*"";
+
+    @Metadata(label = ""common"")
+    private String sendTag = """";
+
+    @Metadata(label = ""common"", defaultValue = ""localhost:9876"")
+    private String namesrvAddr = ""localhost:9876"";
+
+    @Metadata(label = ""producer"")
+    private String replyToTopic;
+
+    @Metadata(label = ""producer"")
+    private String replyToConsumerGroup;
+
+    @Metadata(label = ""advance"", defaultValue = ""10000"")
+    private long requestTimeoutMillis = 10000L;
+
+    @Metadata(label = ""advance"", defaultValue = ""1000"")
+    private long requestTimeoutCheckerIntervalMillis = 1000L;
+
+    @Metadata(label = ""producer"", defaultValue = ""false"")
+    private boolean waitForSendResult;
+
+    @Metadata(label = ""accessKey"")
+    private String accessKey;
+
+    @Metadata(label = ""secretKey"")","[{'comment': 'label = secret, secure = true', 'commenter': 'davsclaus'}]"
8820,components/camel-rocketmq/src/main/java/org/apache/camel/component/rocketmq/RocketMQConstants.java,"@@ -0,0 +1,73 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.camel.component.rocketmq;
+
+import org.apache.camel.spi.Metadata;
+
+public final class RocketMQConstants {","[{'comment': 'Are some of these headers ONLY used on consumer or producer, then we need to mark this as well. @essobedo can help with this', 'commenter': 'davsclaus'}, {'comment': ""I've added labels to annotations."", 'commenter': 'TeslaCN'}]"
8820,components/camel-rocketmq/src/main/java/org/apache/camel/component/rocketmq/RocketMQConsumer.java,"@@ -0,0 +1,102 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.camel.component.rocketmq;
+
+import org.apache.camel.Exchange;
+import org.apache.camel.Processor;
+import org.apache.camel.Suspendable;
+import org.apache.camel.support.DefaultConsumer;
+import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;
+import org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;
+import org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;
+import org.apache.rocketmq.client.exception.MQClientException;
+import org.apache.rocketmq.common.message.MessageExt;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class RocketMQConsumer extends DefaultConsumer implements Suspendable {
+
+    private static final Logger LOG = LoggerFactory.getLogger(RocketMQConsumer.class);
+
+    private final RocketMQEndpoint endpoint;
+
+    private DefaultMQPushConsumer mqPushConsumer;
+
+    public RocketMQConsumer(RocketMQEndpoint endpoint, Processor processor) {
+        super(endpoint, processor);
+        this.endpoint = endpoint;
+    }
+
+    private void startConsumer() throws MQClientException {
+        if (mqPushConsumer != null) {
+            LOG.warn(""Overriding RocketMQ Consumer! {}"", mqPushConsumer);","[{'comment': 'When will this happen? eg the state of a consumer should that it handles start/stop correctly', 'commenter': 'davsclaus'}, {'comment': 'I was overthinking before.', 'commenter': 'TeslaCN'}]"
8820,components/camel-rocketmq/src/main/java/org/apache/camel/component/rocketmq/RocketMQConsumer.java,"@@ -0,0 +1,102 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.camel.component.rocketmq;
+
+import org.apache.camel.Exchange;
+import org.apache.camel.Processor;
+import org.apache.camel.Suspendable;
+import org.apache.camel.support.DefaultConsumer;
+import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;
+import org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;
+import org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;
+import org.apache.rocketmq.client.exception.MQClientException;
+import org.apache.rocketmq.common.message.MessageExt;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class RocketMQConsumer extends DefaultConsumer implements Suspendable {
+
+    private static final Logger LOG = LoggerFactory.getLogger(RocketMQConsumer.class);
+
+    private final RocketMQEndpoint endpoint;
+
+    private DefaultMQPushConsumer mqPushConsumer;
+
+    public RocketMQConsumer(RocketMQEndpoint endpoint, Processor processor) {
+        super(endpoint, processor);
+        this.endpoint = endpoint;
+    }
+
+    private void startConsumer() throws MQClientException {
+        if (mqPushConsumer != null) {
+            LOG.warn(""Overriding RocketMQ Consumer! {}"", mqPushConsumer);
+        }
+        mqPushConsumer = new DefaultMQPushConsumer(
+                null, endpoint.getConsumerGroup(),
+                AclUtils.getAclRPCHook(getEndpoint().getAccessKey(), getEndpoint().getSecretKey()));
+        mqPushConsumer.setNamesrvAddr(endpoint.getNamesrvAddr());
+        mqPushConsumer.subscribe(endpoint.getTopicName(), endpoint.getSubscribeTags());
+        mqPushConsumer.registerMessageListener((MessageListenerConcurrently) (msgs, context) -> {
+            MessageExt messageExt = msgs.get(0);
+            Exchange exchange = endpoint.createRocketExchange(messageExt.getBody());
+            new RocketMQMessageConverter().setExchangeHeadersByMessageExt(exchange, messageExt);
+            try {
+                getProcessor().process(exchange);
+            } catch (Exception e) {
+                LOG.error(e.getLocalizedMessage());","[{'comment': 'The consumer has exception handler to deal with this instead of hardcoded LOG\r\nSomething ala: getExceptionHandler().handle\r\n\r\n', 'commenter': 'davsclaus'}]"
8820,components/camel-rocketmq/src/main/java/org/apache/camel/component/rocketmq/RocketMQConsumer.java,"@@ -0,0 +1,102 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.camel.component.rocketmq;
+
+import org.apache.camel.Exchange;
+import org.apache.camel.Processor;
+import org.apache.camel.Suspendable;
+import org.apache.camel.support.DefaultConsumer;
+import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;
+import org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;
+import org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;
+import org.apache.rocketmq.client.exception.MQClientException;
+import org.apache.rocketmq.common.message.MessageExt;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class RocketMQConsumer extends DefaultConsumer implements Suspendable {
+
+    private static final Logger LOG = LoggerFactory.getLogger(RocketMQConsumer.class);
+
+    private final RocketMQEndpoint endpoint;
+
+    private DefaultMQPushConsumer mqPushConsumer;
+
+    public RocketMQConsumer(RocketMQEndpoint endpoint, Processor processor) {
+        super(endpoint, processor);
+        this.endpoint = endpoint;
+    }
+
+    private void startConsumer() throws MQClientException {
+        if (mqPushConsumer != null) {
+            LOG.warn(""Overriding RocketMQ Consumer! {}"", mqPushConsumer);
+        }
+        mqPushConsumer = new DefaultMQPushConsumer(
+                null, endpoint.getConsumerGroup(),
+                AclUtils.getAclRPCHook(getEndpoint().getAccessKey(), getEndpoint().getSecretKey()));
+        mqPushConsumer.setNamesrvAddr(endpoint.getNamesrvAddr());
+        mqPushConsumer.subscribe(endpoint.getTopicName(), endpoint.getSubscribeTags());
+        mqPushConsumer.registerMessageListener((MessageListenerConcurrently) (msgs, context) -> {
+            MessageExt messageExt = msgs.get(0);
+            Exchange exchange = endpoint.createRocketExchange(messageExt.getBody());
+            new RocketMQMessageConverter().setExchangeHeadersByMessageExt(exchange, messageExt);","[{'comment': 'Do you really need to create a new instance per message of this converter?', 'commenter': 'davsclaus'}, {'comment': ""I've refactored methods of RocketMQMessageConverter to static. Before I created a new instance every time because I thought the JVM could allocate instance of this class on stack."", 'commenter': 'TeslaCN'}]"
8820,components/camel-rocketmq/src/main/java/org/apache/camel/component/rocketmq/RocketMQEndpoint.java,"@@ -0,0 +1,242 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.camel.component.rocketmq;
+
+import org.apache.camel.AsyncEndpoint;
+import org.apache.camel.Category;
+import org.apache.camel.Consumer;
+import org.apache.camel.Exchange;
+import org.apache.camel.Processor;
+import org.apache.camel.Producer;
+import org.apache.camel.spi.Metadata;
+import org.apache.camel.spi.UriEndpoint;
+import org.apache.camel.spi.UriParam;
+import org.apache.camel.spi.UriPath;
+import org.apache.camel.support.DefaultEndpoint;
+import org.apache.camel.support.DefaultMessage;
+
+/**
+ * Send and receive messages from <a href=""https://rocketmq.apache.org/"">RocketMQ</a> cluster.
+ */
+@UriEndpoint(firstVersion = ""3.20.0"", scheme = ""rocketmq"", syntax = ""rocketmq:topicName"", title = ""RocketMQ"",
+             category = Category.MESSAGING, headersClass = RocketMQConstants.class)
+public class RocketMQEndpoint extends DefaultEndpoint implements AsyncEndpoint {
+
+    @UriPath
+    @Metadata(required = true)
+    private String topicName;
+    @UriParam(label = ""producer"")
+    private String producerGroup;
+    @UriParam(label = ""consumer"")
+    private String consumerGroup;
+    @UriParam(label = ""consumer"", defaultValue = ""*"")
+    private String subscribeTags = ""*"";
+    @UriParam(label = ""producer"")
+    private String sendTag = """";
+    @UriParam(label = ""producer"")
+    private String replyToTopic;
+    @UriParam(label = ""producer"")
+    private String replyToConsumerGroup;
+    @UriParam(label = ""common"", defaultValue = ""localhost:9876"")
+    private String namesrvAddr = ""localhost:9876"";
+    @UriParam(label = ""advance"", defaultValue = ""10000"")
+    private long requestTimeoutMillis = 10000L;
+    @UriParam(label = ""advance"", defaultValue = ""1000"")","[{'comment': 'advanced', 'commenter': 'davsclaus'}]"
8820,components/camel-rocketmq/src/main/java/org/apache/camel/component/rocketmq/RocketMQEndpoint.java,"@@ -0,0 +1,242 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.camel.component.rocketmq;
+
+import org.apache.camel.AsyncEndpoint;
+import org.apache.camel.Category;
+import org.apache.camel.Consumer;
+import org.apache.camel.Exchange;
+import org.apache.camel.Processor;
+import org.apache.camel.Producer;
+import org.apache.camel.spi.Metadata;
+import org.apache.camel.spi.UriEndpoint;
+import org.apache.camel.spi.UriParam;
+import org.apache.camel.spi.UriPath;
+import org.apache.camel.support.DefaultEndpoint;
+import org.apache.camel.support.DefaultMessage;
+
+/**
+ * Send and receive messages from <a href=""https://rocketmq.apache.org/"">RocketMQ</a> cluster.
+ */
+@UriEndpoint(firstVersion = ""3.20.0"", scheme = ""rocketmq"", syntax = ""rocketmq:topicName"", title = ""RocketMQ"",
+             category = Category.MESSAGING, headersClass = RocketMQConstants.class)
+public class RocketMQEndpoint extends DefaultEndpoint implements AsyncEndpoint {
+
+    @UriPath
+    @Metadata(required = true)
+    private String topicName;
+    @UriParam(label = ""producer"")
+    private String producerGroup;
+    @UriParam(label = ""consumer"")
+    private String consumerGroup;
+    @UriParam(label = ""consumer"", defaultValue = ""*"")
+    private String subscribeTags = ""*"";
+    @UriParam(label = ""producer"")
+    private String sendTag = """";
+    @UriParam(label = ""producer"")
+    private String replyToTopic;
+    @UriParam(label = ""producer"")
+    private String replyToConsumerGroup;
+    @UriParam(label = ""common"", defaultValue = ""localhost:9876"")
+    private String namesrvAddr = ""localhost:9876"";
+    @UriParam(label = ""advance"", defaultValue = ""10000"")
+    private long requestTimeoutMillis = 10000L;
+    @UriParam(label = ""advance"", defaultValue = ""1000"")
+    private long requestTimeoutCheckerIntervalMillis = 1000L;
+    @UriParam(label = ""producer"", defaultValue = ""false"")
+    private boolean waitForSendResult;
+    @UriParam(label = ""accessKey"")","[{'comment': 'label = security, secret = true', 'commenter': 'davsclaus'}]"
8820,components/camel-rocketmq/src/main/java/org/apache/camel/component/rocketmq/RocketMQEndpoint.java,"@@ -0,0 +1,242 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.camel.component.rocketmq;
+
+import org.apache.camel.AsyncEndpoint;
+import org.apache.camel.Category;
+import org.apache.camel.Consumer;
+import org.apache.camel.Exchange;
+import org.apache.camel.Processor;
+import org.apache.camel.Producer;
+import org.apache.camel.spi.Metadata;
+import org.apache.camel.spi.UriEndpoint;
+import org.apache.camel.spi.UriParam;
+import org.apache.camel.spi.UriPath;
+import org.apache.camel.support.DefaultEndpoint;
+import org.apache.camel.support.DefaultMessage;
+
+/**
+ * Send and receive messages from <a href=""https://rocketmq.apache.org/"">RocketMQ</a> cluster.
+ */
+@UriEndpoint(firstVersion = ""3.20.0"", scheme = ""rocketmq"", syntax = ""rocketmq:topicName"", title = ""RocketMQ"",
+             category = Category.MESSAGING, headersClass = RocketMQConstants.class)
+public class RocketMQEndpoint extends DefaultEndpoint implements AsyncEndpoint {
+
+    @UriPath
+    @Metadata(required = true)
+    private String topicName;
+    @UriParam(label = ""producer"")
+    private String producerGroup;
+    @UriParam(label = ""consumer"")
+    private String consumerGroup;
+    @UriParam(label = ""consumer"", defaultValue = ""*"")
+    private String subscribeTags = ""*"";
+    @UriParam(label = ""producer"")
+    private String sendTag = """";
+    @UriParam(label = ""producer"")
+    private String replyToTopic;
+    @UriParam(label = ""producer"")
+    private String replyToConsumerGroup;
+    @UriParam(label = ""common"", defaultValue = ""localhost:9876"")
+    private String namesrvAddr = ""localhost:9876"";
+    @UriParam(label = ""advance"", defaultValue = ""10000"")
+    private long requestTimeoutMillis = 10000L;
+    @UriParam(label = ""advance"", defaultValue = ""1000"")
+    private long requestTimeoutCheckerIntervalMillis = 1000L;
+    @UriParam(label = ""producer"", defaultValue = ""false"")
+    private boolean waitForSendResult;
+    @UriParam(label = ""accessKey"")
+    private String accessKey;
+    @UriParam(label = ""secretKey"")","[{'comment': 'label = security, secret = true', 'commenter': 'davsclaus'}]"
8820,components/camel-rocketmq/src/main/java/org/apache/camel/component/rocketmq/RocketMQEndpoint.java,"@@ -0,0 +1,242 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.camel.component.rocketmq;
+
+import org.apache.camel.AsyncEndpoint;
+import org.apache.camel.Category;
+import org.apache.camel.Consumer;
+import org.apache.camel.Exchange;
+import org.apache.camel.Processor;
+import org.apache.camel.Producer;
+import org.apache.camel.spi.Metadata;
+import org.apache.camel.spi.UriEndpoint;
+import org.apache.camel.spi.UriParam;
+import org.apache.camel.spi.UriPath;
+import org.apache.camel.support.DefaultEndpoint;
+import org.apache.camel.support.DefaultMessage;
+
+/**
+ * Send and receive messages from <a href=""https://rocketmq.apache.org/"">RocketMQ</a> cluster.
+ */
+@UriEndpoint(firstVersion = ""3.20.0"", scheme = ""rocketmq"", syntax = ""rocketmq:topicName"", title = ""RocketMQ"",
+             category = Category.MESSAGING, headersClass = RocketMQConstants.class)
+public class RocketMQEndpoint extends DefaultEndpoint implements AsyncEndpoint {
+
+    @UriPath
+    @Metadata(required = true)
+    private String topicName;
+    @UriParam(label = ""producer"")
+    private String producerGroup;
+    @UriParam(label = ""consumer"")
+    private String consumerGroup;
+    @UriParam(label = ""consumer"", defaultValue = ""*"")
+    private String subscribeTags = ""*"";
+    @UriParam(label = ""producer"")
+    private String sendTag = """";
+    @UriParam(label = ""producer"")
+    private String replyToTopic;
+    @UriParam(label = ""producer"")
+    private String replyToConsumerGroup;
+    @UriParam(label = ""common"", defaultValue = ""localhost:9876"")
+    private String namesrvAddr = ""localhost:9876"";
+    @UriParam(label = ""advance"", defaultValue = ""10000"")
+    private long requestTimeoutMillis = 10000L;
+    @UriParam(label = ""advance"", defaultValue = ""1000"")
+    private long requestTimeoutCheckerIntervalMillis = 1000L;
+    @UriParam(label = ""producer"", defaultValue = ""false"")
+    private boolean waitForSendResult;
+    @UriParam(label = ""accessKey"")
+    private String accessKey;
+    @UriParam(label = ""secretKey"")
+    private String secretKey;
+
+    public RocketMQEndpoint() {
+    }
+
+    public RocketMQEndpoint(String endpointUri, RocketMQComponent component) {
+        super(endpointUri, component);
+    }
+
+    @Override
+    public Producer createProducer() {
+        return new RocketMQProducer(this);
+    }
+
+    @Override
+    public Consumer createConsumer(Processor processor) throws Exception {
+        RocketMQConsumer consumer = new RocketMQConsumer(this, processor);
+        configureConsumer(consumer);
+        return consumer;
+    }
+
+    @Override
+    public boolean isSingleton() {","[{'comment': 'This is default so can be removed', 'commenter': 'davsclaus'}]"
8820,components/camel-rocketmq/src/main/java/org/apache/camel/component/rocketmq/RocketMQProducer.java,"@@ -0,0 +1,231 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.camel.component.rocketmq;
+
+import java.util.Arrays;
+import java.util.Optional;
+import java.util.concurrent.RejectedExecutionException;
+import java.util.concurrent.ScheduledExecutorService;
+import java.util.concurrent.atomic.AtomicBoolean;
+
+import org.apache.camel.AsyncCallback;
+import org.apache.camel.Exchange;
+import org.apache.camel.FailedToCreateProducerException;
+import org.apache.camel.NoTypeConversionAvailableException;
+import org.apache.camel.RuntimeCamelException;
+import org.apache.camel.component.rocketmq.reply.ReplyManager;
+import org.apache.camel.component.rocketmq.reply.RocketMQReplyManagerSupport;
+import org.apache.camel.support.DefaultAsyncProducer;
+import org.apache.camel.support.service.ServiceHelper;
+import org.apache.rocketmq.client.exception.MQClientException;
+import org.apache.rocketmq.client.producer.DefaultMQProducer;
+import org.apache.rocketmq.client.producer.SendCallback;
+import org.apache.rocketmq.client.producer.SendResult;
+import org.apache.rocketmq.client.producer.SendStatus;
+import org.apache.rocketmq.common.message.Message;
+import org.apache.rocketmq.remoting.exception.RemotingException;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class RocketMQProducer extends DefaultAsyncProducer {
+
+    public static final String GENERATE_MESSAGE_KEY_PREFIX = ""camel-rocketmq-"";
+
+    private static final Logger LOG = LoggerFactory.getLogger(RocketMQProducer.class);
+
+    private final AtomicBoolean started = new AtomicBoolean(false);
+
+    private DefaultMQProducer mqProducer;
+
+    private ReplyManager replyManager;
+
+    public RocketMQProducer(RocketMQEndpoint endpoint) {
+        super(endpoint);
+    }
+
+    @Override
+    public RocketMQEndpoint getEndpoint() {
+        return (RocketMQEndpoint) super.getEndpoint();
+    }
+
+    @Override
+    public boolean process(Exchange exchange, AsyncCallback callback) {
+        if (!isRunAllowed()) {
+            if (exchange.getException() == null) {
+                exchange.setException(new RejectedExecutionException());
+            }
+            callback.done(true);
+            return true;
+        }
+        try {
+            LOG.trace(""Exchange Pattern {}"", exchange.getPattern());
+            if (exchange.getPattern().isOutCapable()) {
+                return processInOut(exchange, callback);
+            } else {
+                return processInOnly(exchange, callback);
+            }
+        } catch (Throwable e) {
+            exchange.setException(e);
+            callback.done(true);
+            return true;
+        }
+    }
+
+    protected boolean processInOut(final Exchange exchange, final AsyncCallback callback)
+            throws RemotingException, MQClientException, InterruptedException, NoTypeConversionAvailableException {
+        org.apache.camel.Message in = exchange.getIn();
+        Message message = new Message();
+        message.setTopic(in.getHeader(RocketMQConstants.OVERRIDE_TOPIC_NAME, () -> getEndpoint().getTopicName(), String.class));
+        message.setTags(in.getHeader(RocketMQConstants.OVERRIDE_TAG, () -> getEndpoint().getSendTag(), String.class));
+        message.setBody(exchange.getContext().getTypeConverter().mandatoryConvertTo(byte[].class, exchange, in.getBody()));
+        message.setKeys(in.getHeader(RocketMQConstants.OVERRIDE_MESSAGE_KEY, """", String.class));
+        initReplyManager();
+        String generateKey = GENERATE_MESSAGE_KEY_PREFIX + getEndpoint().getCamelContext().getUuidGenerator().generateUuid();
+        message.setKeys(Arrays.asList(Optional.ofNullable(message.getKeys()).orElse(""""), generateKey));
+        LOG.debug(""RocketMQ Producer sending {}"", message);
+        mqProducer.send(message, new SendCallback() {
+
+            @Override
+            public void onSuccess(SendResult sendResult) {
+                if (!SendStatus.SEND_OK.equals(sendResult.getSendStatus())) {
+                    exchange.setException(new SendFailedException(sendResult.toString()));
+                    callback.done(false);","[{'comment': 'return;', 'commenter': 'davsclaus'}]"
8820,components/camel-rocketmq/src/main/java/org/apache/camel/component/rocketmq/RocketMQProducer.java,"@@ -0,0 +1,231 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.camel.component.rocketmq;
+
+import java.util.Arrays;
+import java.util.Optional;
+import java.util.concurrent.RejectedExecutionException;
+import java.util.concurrent.ScheduledExecutorService;
+import java.util.concurrent.atomic.AtomicBoolean;
+
+import org.apache.camel.AsyncCallback;
+import org.apache.camel.Exchange;
+import org.apache.camel.FailedToCreateProducerException;
+import org.apache.camel.NoTypeConversionAvailableException;
+import org.apache.camel.RuntimeCamelException;
+import org.apache.camel.component.rocketmq.reply.ReplyManager;
+import org.apache.camel.component.rocketmq.reply.RocketMQReplyManagerSupport;
+import org.apache.camel.support.DefaultAsyncProducer;
+import org.apache.camel.support.service.ServiceHelper;
+import org.apache.rocketmq.client.exception.MQClientException;
+import org.apache.rocketmq.client.producer.DefaultMQProducer;
+import org.apache.rocketmq.client.producer.SendCallback;
+import org.apache.rocketmq.client.producer.SendResult;
+import org.apache.rocketmq.client.producer.SendStatus;
+import org.apache.rocketmq.common.message.Message;
+import org.apache.rocketmq.remoting.exception.RemotingException;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class RocketMQProducer extends DefaultAsyncProducer {
+
+    public static final String GENERATE_MESSAGE_KEY_PREFIX = ""camel-rocketmq-"";
+
+    private static final Logger LOG = LoggerFactory.getLogger(RocketMQProducer.class);
+
+    private final AtomicBoolean started = new AtomicBoolean(false);
+
+    private DefaultMQProducer mqProducer;
+
+    private ReplyManager replyManager;
+
+    public RocketMQProducer(RocketMQEndpoint endpoint) {
+        super(endpoint);
+    }
+
+    @Override
+    public RocketMQEndpoint getEndpoint() {
+        return (RocketMQEndpoint) super.getEndpoint();
+    }
+
+    @Override
+    public boolean process(Exchange exchange, AsyncCallback callback) {
+        if (!isRunAllowed()) {
+            if (exchange.getException() == null) {
+                exchange.setException(new RejectedExecutionException());
+            }
+            callback.done(true);
+            return true;
+        }
+        try {
+            LOG.trace(""Exchange Pattern {}"", exchange.getPattern());
+            if (exchange.getPattern().isOutCapable()) {
+                return processInOut(exchange, callback);
+            } else {
+                return processInOnly(exchange, callback);
+            }
+        } catch (Throwable e) {
+            exchange.setException(e);
+            callback.done(true);
+            return true;
+        }
+    }
+
+    protected boolean processInOut(final Exchange exchange, final AsyncCallback callback)
+            throws RemotingException, MQClientException, InterruptedException, NoTypeConversionAvailableException {
+        org.apache.camel.Message in = exchange.getIn();
+        Message message = new Message();
+        message.setTopic(in.getHeader(RocketMQConstants.OVERRIDE_TOPIC_NAME, () -> getEndpoint().getTopicName(), String.class));
+        message.setTags(in.getHeader(RocketMQConstants.OVERRIDE_TAG, () -> getEndpoint().getSendTag(), String.class));
+        message.setBody(exchange.getContext().getTypeConverter().mandatoryConvertTo(byte[].class, exchange, in.getBody()));
+        message.setKeys(in.getHeader(RocketMQConstants.OVERRIDE_MESSAGE_KEY, """", String.class));
+        initReplyManager();
+        String generateKey = GENERATE_MESSAGE_KEY_PREFIX + getEndpoint().getCamelContext().getUuidGenerator().generateUuid();
+        message.setKeys(Arrays.asList(Optional.ofNullable(message.getKeys()).orElse(""""), generateKey));
+        LOG.debug(""RocketMQ Producer sending {}"", message);
+        mqProducer.send(message, new SendCallback() {
+
+            @Override
+            public void onSuccess(SendResult sendResult) {
+                if (!SendStatus.SEND_OK.equals(sendResult.getSendStatus())) {
+                    exchange.setException(new SendFailedException(sendResult.toString()));
+                    callback.done(false);
+                }
+                if (replyManager == null) {
+                    LOG.warn(""replyToTopic not set! Will not wait for reply."");
+                    callback.done(false);
+                    return;
+                }
+                replyManager.registerReply(replyManager, exchange, callback, generateKey,
+                        getEndpoint().getRequestTimeoutMillis());
+            }
+
+            @Override
+            public void onException(Throwable e) {
+                replyManager.cancelMessageKey(generateKey);","[{'comment': 'maybe use try .. finally to ensure callback is called if replymanager for some strange reason throw exception as callback MUST be called', 'commenter': 'davsclaus'}]"
8820,components/camel-rocketmq/src/main/java/org/apache/camel/component/rocketmq/reply/ReplyTimeoutMap.java,"@@ -0,0 +1,66 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.camel.component.rocketmq.reply;
+
+import java.util.concurrent.ScheduledExecutorService;
+
+import org.apache.camel.support.DefaultTimeoutMap;
+
+public class ReplyTimeoutMap extends DefaultTimeoutMap<String, ReplyHandler> {
+
+    public ReplyTimeoutMap(ScheduledExecutorService executor, long requestMapPollTimeMillis) {
+        super(executor, requestMapPollTimeMillis);
+        addListener(this::listener);
+    }
+
+    private static long encode(long timeoutMillis) {
+        return timeoutMillis > 0 ? timeoutMillis : Integer.MAX_VALUE;
+    }
+
+    private void listener(Listener.Type type, String key, ReplyHandler handler) {
+        switch (type) {
+            case Put:
+                log.trace(""Add messageKey: {}"", key);
+                break;
+            case Remove:
+                log.trace(""Remove messageKey: {}"", key);
+                break;
+            case Evict:
+                try {
+                    handler.onTimeout(key);
+                } catch (Throwable e) {
+                    log.warn(""Error processing onTimeout for messageKey: "" + key + "" due: "" + e.getLocalizedMessage()
+                             + "". This exception is ignored."",
+                            e);","[{'comment': 'Please, can you use log markers here? ', 'commenter': 'orpiske'}, {'comment': ""I've added marker named `camel-rocketmq`."", 'commenter': 'TeslaCN'}, {'comment': 'I mean something like: \r\n\r\n```\r\nlog.warn(""Error processing onTimeout for messageKey: {} due: {}. This exception is ignored."", key, e.getLocalizedMessage(), e);\r\n```', 'commenter': 'orpiske'}, {'comment': ""Sorry that I misunderstood. I've updated it."", 'commenter': 'TeslaCN'}, {'comment': 'Thanks!', 'commenter': 'orpiske'}]"
8820,components/camel-rocketmq/src/main/java/org/apache/camel/component/rocketmq/reply/RocketMQReplyManagerSupport.java,"@@ -0,0 +1,194 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.camel.component.rocketmq.reply;
+
+import java.util.Arrays;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ScheduledExecutorService;
+
+import org.apache.camel.AsyncCallback;
+import org.apache.camel.CamelContext;
+import org.apache.camel.Exchange;
+import org.apache.camel.ExchangeTimedOutException;
+import org.apache.camel.component.rocketmq.RocketMQEndpoint;
+import org.apache.camel.component.rocketmq.RocketMQMessageConverter;
+import org.apache.camel.component.rocketmq.RocketMQProducer;
+import org.apache.camel.support.ExchangeHelper;
+import org.apache.camel.support.service.ServiceHelper;
+import org.apache.camel.support.service.ServiceSupport;
+import org.apache.camel.util.ObjectHelper;
+import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;
+import org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;
+import org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;
+import org.apache.rocketmq.client.exception.MQClientException;
+import org.apache.rocketmq.common.message.MessageConst;
+import org.apache.rocketmq.common.message.MessageExt;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class RocketMQReplyManagerSupport extends ServiceSupport implements ReplyManager {
+
+    private static final int CLOSE_TIMEOUT = 30 * 1000;
+
+    protected final Logger log = LoggerFactory.getLogger(RocketMQReplyManagerSupport.class);
+    protected final CamelContext camelContext;
+    protected final CountDownLatch replyToLatch = new CountDownLatch(1);
+    protected ScheduledExecutorService executorService;
+    protected RocketMQEndpoint endpoint;
+    protected String replyToTopic;
+    protected DefaultMQPushConsumer mqPushConsumer;
+    protected ReplyTimeoutMap timeoutMap;
+    private final RocketMQMessageConverter messageConverter = new RocketMQMessageConverter();
+
+    public RocketMQReplyManagerSupport(CamelContext camelContext) {
+        this.camelContext = camelContext;
+    }
+
+    @Override
+    protected void doStart() throws Exception {
+        ObjectHelper.notNull(executorService, ""executorService"", this);
+        ObjectHelper.notNull(endpoint, ""endpoint"", this);
+
+        log.debug(""Using timeout checker interval with {} millis"", endpoint.getRequestTimeoutCheckerIntervalMillis());
+        timeoutMap = new ReplyTimeoutMap(executorService, endpoint.getRequestTimeoutCheckerIntervalMillis());
+        ServiceHelper.startService(timeoutMap);
+
+        mqPushConsumer = createConsumer();
+        mqPushConsumer.start();
+
+        log.debug(""Using executor {}"", executorService);
+    }
+
+    protected DefaultMQPushConsumer createConsumer() throws MQClientException {
+        setReplyToTopic(endpoint.getReplyToTopic());
+        DefaultMQPushConsumer consumer = new DefaultMQPushConsumer();
+        consumer.setConsumerGroup(endpoint.getReplyToConsumerGroup());
+        consumer.setNamesrvAddr(endpoint.getNamesrvAddr());
+        consumer.subscribe(replyToTopic, ""*"");
+        consumer.registerMessageListener((MessageListenerConcurrently) (msgs, context) -> {
+            MessageExt messageExt = msgs.get(0);
+            onMessage(messageExt);
+            log.trace(""Consume message {}"", messageExt);
+            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;
+        });
+        return consumer;
+    }
+
+    public void onMessage(MessageExt messageExt) {
+        String messageKey = Arrays.stream(messageExt.getKeys().split(MessageConst.KEY_SEPARATOR))
+                .filter(s -> s.startsWith(RocketMQProducer.GENERATE_MESSAGE_KEY_PREFIX)).findFirst().orElse(null);
+        if (messageKey == null) {
+            log.warn(""Ignoreing message with no messageKey: {}"", messageExt);","[{'comment': 'Typo ... should be ""Ignoring"". ', 'commenter': 'orpiske'}]"
8820,components/camel-rocketmq/src/main/java/org/apache/camel/component/rocketmq/AclUtils.java,"@@ -0,0 +1,36 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.camel.component.rocketmq;
+
+import org.apache.commons.lang3.StringUtils;
+import org.apache.rocketmq.acl.common.AclClientRPCHook;
+import org.apache.rocketmq.acl.common.SessionCredentials;
+import org.apache.rocketmq.remoting.RPCHook;
+
+public final class AclUtils {
+
+    private AclUtils() {
+    }
+
+    public static RPCHook getAclRPCHook(String accessKey, String secretKey) {
+        if (StringUtils.isNotBlank(accessKey) && StringUtils.isNotBlank(secretKey)) {","[{'comment': ""Maybe replace this `StringUtils.isNotBlank` with Camel's `StringHelper.notBlank(String, String, String)` and prevent the NPE that could happen on ```RocketMQConsumer.startConsumer```? "", 'commenter': 'orpiske'}, {'comment': ""Actually I also want to avoid using null. But the constructors of RocketMQ classes accept null as default value. Passing null into RocketMQ's classes will not cause NPE."", 'commenter': 'TeslaCN'}, {'comment': 'Great, in this case it should be fine. Thanks!', 'commenter': 'orpiske'}]"
8824,components/camel-influxdb2/src/main/java/org/apache/camel/component/influxdb2/InfluxDb2Endpoint.java,"@@ -0,0 +1,228 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.influxdb2;
+
+import java.util.List;
+import java.util.concurrent.ExecutorService;
+
+import com.influxdb.client.BucketsQuery;
+import com.influxdb.client.InfluxDBClient;
+import com.influxdb.client.OrganizationsQuery;
+import com.influxdb.client.domain.Bucket;
+import com.influxdb.client.domain.Organization;
+import com.influxdb.client.domain.WritePrecision;
+import com.influxdb.exceptions.NotFoundException;
+import org.apache.camel.Category;
+import org.apache.camel.Consumer;
+import org.apache.camel.Processor;
+import org.apache.camel.Producer;
+import org.apache.camel.component.influxdb2.enums.Operation;
+import org.apache.camel.spi.Metadata;
+import org.apache.camel.spi.UriEndpoint;
+import org.apache.camel.spi.UriParam;
+import org.apache.camel.spi.UriPath;
+import org.apache.camel.support.DefaultEndpoint;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * Interact with <a href=""https://influxdata.com/time-series-platform/influxdb/"">InfluxDB</a>, a time series database.
+ */
+@UriEndpoint(firstVersion = ""3.19.0"", scheme = ""influxdb2"", title = ""Influxdb2"",","[{'comment': '3.20.0', 'commenter': 'davsclaus'}, {'comment': 'title = ""InfluxDB2""', 'commenter': 'davsclaus'}]"
8824,components/camel-influxdb2/src/main/java/org/apache/camel/component/influxdb2/InfluxDb2Constants.java,"@@ -0,0 +1,38 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.influxdb2;
+
+import org.apache.camel.spi.Metadata;
+
+public final class InfluxDb2Constants {
+
+    @Metadata(description = ""The name of measurement"", javaType = ""String"")
+    public static final String MEASUREMENT = ""camelInfluxDB.MeasurementName"";","[{'comment': 'Header Keys should be without DOT in Camel. This may be wrong on the v1 component.\r\n\r\nShould be like this:\r\nCamelInfluxDB2MeasurementName', 'commenter': 'davsclaus'}]"
8824,components/camel-influxdb2/src/main/java/org/apache/camel/component/influxdb2/InfluxDb2Constants.java,"@@ -0,0 +1,38 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.influxdb2;
+
+import org.apache.camel.spi.Metadata;
+
+public final class InfluxDb2Constants {
+
+    @Metadata(description = ""The name of measurement"", javaType = ""String"")
+    public static final String MEASUREMENT = ""camelInfluxDB.MeasurementName"";
+    @Metadata(description = ""The string that defines the retention policy to the data created by the endpoint"",
+              javaType = ""String"")
+    public static final String RETENTION_POLICY = ""camelInfluxDB.RetentionPolicy"";
+    @Metadata(description = ""The name of the database where the time series will be stored"", javaType = ""String"")
+    public static final String ORG = ""camelInfluxDB.org"";","[{'comment': 'Should ORG and BUCKET not have @Metadata also', 'commenter': 'davsclaus'}]"
8824,components/camel-influxdb2/src/main/java/org/apache/camel/component/influxdb2/InfluxDb2Endpoint.java,"@@ -0,0 +1,228 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.influxdb2;
+
+import java.util.List;
+import java.util.concurrent.ExecutorService;
+
+import com.influxdb.client.BucketsQuery;
+import com.influxdb.client.InfluxDBClient;
+import com.influxdb.client.OrganizationsQuery;
+import com.influxdb.client.domain.Bucket;
+import com.influxdb.client.domain.Organization;
+import com.influxdb.client.domain.WritePrecision;
+import com.influxdb.exceptions.NotFoundException;
+import org.apache.camel.Category;
+import org.apache.camel.Consumer;
+import org.apache.camel.Processor;
+import org.apache.camel.Producer;
+import org.apache.camel.component.influxdb2.enums.Operation;
+import org.apache.camel.spi.Metadata;
+import org.apache.camel.spi.UriEndpoint;
+import org.apache.camel.spi.UriParam;
+import org.apache.camel.spi.UriPath;
+import org.apache.camel.support.DefaultEndpoint;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * Interact with <a href=""https://influxdata.com/time-series-platform/influxdb/"">InfluxDB</a>, a time series database.
+ */
+@UriEndpoint(firstVersion = ""3.19.0"", scheme = ""influxdb2"", title = ""Influxdb2"",
+             syntax = ""influxdb2:connectionBean?org=<org name>&bucket=<bucket name>"", category = { Category.DATABASE },
+             producerOnly = true, headersClass = InfluxDb2Constants.class)
+public class InfluxDb2Endpoint extends DefaultEndpoint {
+    private static final Logger LOG = LoggerFactory.getLogger(InfluxDb2Endpoint.class);
+
+    private InfluxDBClient influxDBClient;
+
+    @UriPath
+    @Metadata(required = true, description = ""connectionBean"")","[{'comment': 'The description are to simple, they are for humans. So please improve these. Also should start with Upper case letter.', 'commenter': 'davsclaus'}]"
8824,components/camel-influxdb2/src/main/java/org/apache/camel/component/influxdb2/InfluxDb2Endpoint.java,"@@ -0,0 +1,228 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.influxdb2;
+
+import java.util.List;
+import java.util.concurrent.ExecutorService;
+
+import com.influxdb.client.BucketsQuery;
+import com.influxdb.client.InfluxDBClient;
+import com.influxdb.client.OrganizationsQuery;
+import com.influxdb.client.domain.Bucket;
+import com.influxdb.client.domain.Organization;
+import com.influxdb.client.domain.WritePrecision;
+import com.influxdb.exceptions.NotFoundException;
+import org.apache.camel.Category;
+import org.apache.camel.Consumer;
+import org.apache.camel.Processor;
+import org.apache.camel.Producer;
+import org.apache.camel.component.influxdb2.enums.Operation;
+import org.apache.camel.spi.Metadata;
+import org.apache.camel.spi.UriEndpoint;
+import org.apache.camel.spi.UriParam;
+import org.apache.camel.spi.UriPath;
+import org.apache.camel.support.DefaultEndpoint;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * Interact with <a href=""https://influxdata.com/time-series-platform/influxdb/"">InfluxDB</a>, a time series database.
+ */
+@UriEndpoint(firstVersion = ""3.19.0"", scheme = ""influxdb2"", title = ""Influxdb2"",
+             syntax = ""influxdb2:connectionBean?org=<org name>&bucket=<bucket name>"", category = { Category.DATABASE },
+             producerOnly = true, headersClass = InfluxDb2Constants.class)
+public class InfluxDb2Endpoint extends DefaultEndpoint {
+    private static final Logger LOG = LoggerFactory.getLogger(InfluxDb2Endpoint.class);
+
+    private InfluxDBClient influxDBClient;
+
+    @UriPath
+    @Metadata(required = true, description = ""connectionBean"")
+    private String connectionBean;
+    @UriParam
+    @Metadata(required = true, description = ""organization name"")
+    private String org;
+    @UriParam
+    @Metadata(required = true, description = ""bucket name"")
+    private String bucket;
+    @UriParam(defaultValue = ""default"", description = ""retention policy"")
+    private String retentionPolicy = ""default"";
+
+    @UriParam(defaultValue = ""INSERT"", description = ""operations"")
+    private Operation operation = Operation.INSERT;
+    @UriParam(defaultValue = ""true"", description = ""auto create organization"")
+    private boolean autoCreateOrg = true;
+
+    @UriParam(defaultValue = ""true"", description = ""auto create bucket"")
+    private boolean autoCreateBucket = true;
+
+    @UriParam(defaultValue = ""ms"", description = ""influxdb2 write precision"")
+    private WritePrecision writePrecision = WritePrecision.MS;
+    private String orgID;
+
+    public InfluxDb2Endpoint(String uri, InfluxDb2Component component) {
+        super(uri, component);
+    }
+
+    public InfluxDb2Endpoint() {
+    }
+
+    public InfluxDBClient getInfluxDBClient() {
+        return influxDBClient;
+    }
+
+    public void setInfluxDBClient(InfluxDBClient influxDBClient) {
+        this.influxDBClient = influxDBClient;
+    }
+
+    public String getConnectionBean() {
+        return connectionBean;
+    }
+
+    public void setConnectionBean(String connectionBean) {
+        this.connectionBean = connectionBean;
+    }
+
+    public String getOrg() {
+        return org;
+    }
+
+    public void setOrg(String org) {
+        this.org = org;
+    }
+
+    public String getBucket() {
+        return bucket;
+    }
+
+    public void setBucket(String bucket) {
+        this.bucket = bucket;
+    }
+
+    public String getRetentionPolicy() {
+        return retentionPolicy;
+    }
+
+    public void setRetentionPolicy(String retentionPolicy) {
+        this.retentionPolicy = retentionPolicy;
+    }
+
+    public Operation getOperation() {
+        return operation;
+    }
+
+    public void setOperation(Operation operation) {
+        this.operation = operation;
+    }
+
+    public boolean isAutoCreateOrg() {
+        return autoCreateOrg;
+    }
+
+    public void setAutoCreateOrg(boolean autoCreateOrg) {
+        this.autoCreateOrg = autoCreateOrg;
+    }
+
+    public boolean isAutoCreateBucket() {
+        return autoCreateBucket;
+    }
+
+    public void setAutoCreateBucket(boolean autoCreateBucket) {
+        this.autoCreateBucket = autoCreateBucket;
+    }
+
+    public String getOrgID() {
+        return orgID;
+    }
+
+    public void setOrgID(String orgID) {
+        this.orgID = orgID;
+    }
+
+    public WritePrecision getWritePrecision() {
+        return writePrecision;
+    }
+
+    public void setWritePrecision(WritePrecision writePrecision) {
+        this.writePrecision = writePrecision;
+    }
+
+    public Producer createProducer() throws Exception {
+        return new InfluxDb2Producer(this);
+    }
+
+    public Consumer createConsumer(Processor processor) throws Exception {
+        throw new UnsupportedOperationException(""You cannot receive messages from this endpoint"");
+    }
+
+    @Override
+    protected void doInit() throws Exception {
+        super.doInit();
+        ensureOrgExists();
+        ensureBucketExists();
+    }
+
+    public ExecutorService createExecutor() {
+        // TODO: Delete me when you implemented your custom component","[{'comment': 'TODO is here, this need to be resolved', 'commenter': 'davsclaus'}]"
8896,components/camel-as2/camel-as2-api/src/main/java/org/apache/camel/component/as2/api/AS2ClientConnection.java,"@@ -69,8 +73,16 @@ public AS2ClientConnection(String as2Version, String userAgent, String clientFqd
                 .add(new RequestExpectContinue(true)).build();
 
         // Create Socket
-        Socket socket = new Socket(targetHost.getHostName(), targetHost.getPort());
-
+        //Socket socket = new Socket(targetHost.getHostName(), targetHost.getPort());
+	
+	if (sslContext==null) {
+		socket = new Socket(targetHost.getHostName(), targetHost.getPort());
+	} else {
+		SSLSocketFactory factory = sslContext.getSocketFactory();
+		socket = (SSLSocket) factory.createSocket(targetHost.getHostName(), targetHost.getPort());
+		//socket.setEnabledProtocols(new String[]{""TLSv1.3""});","[{'comment': 'Why is it commented?', 'commenter': 'oscerd'}, {'comment': 'I was having some issues with setting up KeyStore/ TrustStore and got handshake failed error. So I tried changing allowed protocol to only TLSv1.3. \r\nDid not need it though, so I commented it at that time and forgot to remove this line.\r\n\r\nRemoved extra comments.', 'commenter': 'shikhar97gupta'}]"
8944,components/camel-as2/camel-as2-api/pom.xml,"@@ -96,6 +96,13 @@
             <artifactId>camel-test-junit5</artifactId>
             <scope>test</scope>
         </dependency>
+        <!-- added for binary content transfer encoding test because Camel AS2 client doesn't support binary currently -->
+        <dependency>
+            <groupId>com.helger.as2</groupId>
+            <artifactId>as2-lib</artifactId>
+            <version>4.11.0</version>
+            <scope>test</scope>","[{'comment': ""This should be in a property placeholder in parent pom. Don't use a static version inside the component pom"", 'commenter': 'oscerd'}, {'comment': 'Thanks! There were a lot to do and I forgot to do so while I was going to. Nice catch :+1: fixed', 'commenter': 'yasserzamani'}]"
9143,components/camel-as2/camel-as2-api/src/main/java/org/apache/camel/component/as2/api/AS2ClientConnection.java,"@@ -41,21 +55,30 @@
 
 public class AS2ClientConnection {
 
+    private static final int RETRIEVE_FROM_CONNECTION_POOL_TIMEOUT_SECONDS = 5;
+
     private HttpHost targetHost;
     private HttpProcessor httpProcessor;
-    private DefaultBHttpClientConnection httpConnection;
     private String as2Version;
     private String userAgent;
     private String clientFqdn;
+    private int connectionTimeoutMilliseconds;
+    private PoolingHttpClientConnectionManager connectionPoolManager;
+    private ConnectionKeepAliveStrategy connectionKeepAliveStrategy;
 
     public AS2ClientConnection(String as2Version, String userAgent, String clientFqdn, String targetHostName,
-                               Integer targetPortNumber) throws IOException {
+                               Integer targetPortNumber, Duration socketTimeout, Duration connectionTimeout,
+                               Integer connectionPoolMaxSize, Duration connectionPoolTtl) throws IOException {
 
         this.as2Version = Args.notNull(as2Version, ""as2Version"");
         this.userAgent = Args.notNull(userAgent, ""userAgent"");
         this.clientFqdn = Args.notNull(clientFqdn, ""clientFqdn"");
         this.targetHost = new HttpHost(
                 Args.notNull(targetHostName, ""targetHostName""), Args.notNull(targetPortNumber, ""targetPortNumber""));
+        Args.notNull(socketTimeout, ""socketTimeout"");","[{'comment': 'Use Camels ObjectHelper.notNull (in camel-util)', 'commenter': 'davsclaus'}]"
9154,dsl/camel-jbang/camel-jbang-core/src/main/java/org/apache/camel/dsl/jbang/core/commands/CodeRestGenerator.java,"@@ -80,4 +102,34 @@ private JsonNode readNodeFromYaml() throws FileNotFoundException {
         Map map = loader.load(new FileInputStream(Paths.get(input).toFile()));
         return mapper.convertValue(map, JsonNode.class);
     }
+
+    private void generateDto() throws IOException {
+        final String CODE = ""code"";
+        final String GENERATOR_NAME = ""quarkus"".equals(runtime) ? ""jaxrs-spec"" : ""java-camel"";
+        final String LIBRARY = ""quarkus"".equals(runtime) ? ""quarkus"" : ""spring-boot"";
+        File output = Files.createTempDirectory(""gendto"").toFile();
+
+        final CodegenConfigurator configurator = new CodegenConfigurator()
+                .setGeneratorName(GENERATOR_NAME)
+                .setLibrary(LIBRARY)
+                .setInputSpec(input)
+                .setModelPackage(packageName)
+                .setAdditionalProperties(
+                        Map.of(
+                                SERIALIZABLE_MODEL, ""false"",
+                                ""useJakartaEe"", ""true"",","[{'comment': 'this should be false as camel 3.x is not jakarta', 'commenter': 'davsclaus'}]"
9191,components/camel-zeebe/src/main/java/org/apache/camel/component/zeebe/ZeebeConsumer.java,"@@ -0,0 +1,122 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.camel.component.zeebe;
+
+import com.fasterxml.jackson.core.JsonProcessingException;
+import com.fasterxml.jackson.databind.ObjectMapper;
+import io.camunda.zeebe.client.api.response.ActivatedJob;
+import io.camunda.zeebe.client.api.worker.JobClient;
+import io.camunda.zeebe.client.api.worker.JobHandler;
+import io.camunda.zeebe.client.api.worker.JobWorker;
+import org.apache.camel.AsyncCallback;
+import org.apache.camel.CamelException;
+import org.apache.camel.Exchange;
+import org.apache.camel.Message;
+import org.apache.camel.Processor;
+import org.apache.camel.component.zeebe.internal.OperationName;
+import org.apache.camel.component.zeebe.model.JobWorkerMessage;
+import org.apache.camel.support.DefaultConsumer;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class ZeebeConsumer extends DefaultConsumer {
+    private static final Logger LOG = LoggerFactory.getLogger(ZeebeConsumer.class);
+
+    private final ZeebeEndpoint endpoint;
+
+    private JobWorker jobWorker;
+
+    private ObjectMapper objectMapper = new ObjectMapper();
+
+    public ZeebeConsumer(ZeebeEndpoint endpoint, Processor processor) throws CamelException {
+        super(endpoint, processor);
+        this.endpoint = endpoint;
+    }
+
+    @Override
+    protected void doStart() throws Exception {
+        super.doStart();
+
+        final OperationName operationName = getEndpoint().getOperationName();
+        switch (operationName) {
+            case REGISTER_JOB_WORKER:
+                if (getEndpoint().getJobKey() == null) {
+                    LOG.error(""Missing JobKey"");
+                    throw new CamelException(""Missing JobKey"");
+                }
+                jobWorker = getEndpoint().getZeebeService().registerJobHandler(new ConsumerJobHandler(),
+                        getEndpoint().getJobKey(), getEndpoint().getTimeout());
+                break;
+            default:
+                LOG.error(""Invalid Operation %s"", operationName.value());","[{'comment': 'I think this should be `LOG.error(""Invalid Operation {}"", operationName.value());`', 'commenter': 'orpiske'}, {'comment': 'Done', 'commenter': 'LoRez'}]"
9191,components/camel-zeebe/src/main/java/org/apache/camel/component/zeebe/ZeebeConsumer.java,"@@ -0,0 +1,122 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.camel.component.zeebe;
+
+import com.fasterxml.jackson.core.JsonProcessingException;
+import com.fasterxml.jackson.databind.ObjectMapper;
+import io.camunda.zeebe.client.api.response.ActivatedJob;
+import io.camunda.zeebe.client.api.worker.JobClient;
+import io.camunda.zeebe.client.api.worker.JobHandler;
+import io.camunda.zeebe.client.api.worker.JobWorker;
+import org.apache.camel.AsyncCallback;
+import org.apache.camel.CamelException;
+import org.apache.camel.Exchange;
+import org.apache.camel.Message;
+import org.apache.camel.Processor;
+import org.apache.camel.component.zeebe.internal.OperationName;
+import org.apache.camel.component.zeebe.model.JobWorkerMessage;
+import org.apache.camel.support.DefaultConsumer;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class ZeebeConsumer extends DefaultConsumer {
+    private static final Logger LOG = LoggerFactory.getLogger(ZeebeConsumer.class);
+
+    private final ZeebeEndpoint endpoint;
+
+    private JobWorker jobWorker;
+
+    private ObjectMapper objectMapper = new ObjectMapper();
+
+    public ZeebeConsumer(ZeebeEndpoint endpoint, Processor processor) throws CamelException {
+        super(endpoint, processor);
+        this.endpoint = endpoint;
+    }
+
+    @Override
+    protected void doStart() throws Exception {
+        super.doStart();
+
+        final OperationName operationName = getEndpoint().getOperationName();
+        switch (operationName) {
+            case REGISTER_JOB_WORKER:
+                if (getEndpoint().getJobKey() == null) {
+                    LOG.error(""Missing JobKey"");
+                    throw new CamelException(""Missing JobKey"");
+                }","[{'comment': ""I think `ObjectHelper.notNull` would do the trick here. That's what we normally use."", 'commenter': 'orpiske'}]"
9191,components/camel-zeebe/src/main/java/org/apache/camel/component/zeebe/ZeebeConsumer.java,"@@ -0,0 +1,122 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.camel.component.zeebe;
+
+import com.fasterxml.jackson.core.JsonProcessingException;
+import com.fasterxml.jackson.databind.ObjectMapper;
+import io.camunda.zeebe.client.api.response.ActivatedJob;
+import io.camunda.zeebe.client.api.worker.JobClient;
+import io.camunda.zeebe.client.api.worker.JobHandler;
+import io.camunda.zeebe.client.api.worker.JobWorker;
+import org.apache.camel.AsyncCallback;
+import org.apache.camel.CamelException;
+import org.apache.camel.Exchange;
+import org.apache.camel.Message;
+import org.apache.camel.Processor;
+import org.apache.camel.component.zeebe.internal.OperationName;
+import org.apache.camel.component.zeebe.model.JobWorkerMessage;
+import org.apache.camel.support.DefaultConsumer;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class ZeebeConsumer extends DefaultConsumer {
+    private static final Logger LOG = LoggerFactory.getLogger(ZeebeConsumer.class);
+
+    private final ZeebeEndpoint endpoint;
+
+    private JobWorker jobWorker;
+
+    private ObjectMapper objectMapper = new ObjectMapper();
+
+    public ZeebeConsumer(ZeebeEndpoint endpoint, Processor processor) throws CamelException {
+        super(endpoint, processor);
+        this.endpoint = endpoint;
+    }
+
+    @Override
+    protected void doStart() throws Exception {
+        super.doStart();
+
+        final OperationName operationName = getEndpoint().getOperationName();
+        switch (operationName) {
+            case REGISTER_JOB_WORKER:
+                if (getEndpoint().getJobKey() == null) {
+                    LOG.error(""Missing JobKey"");
+                    throw new CamelException(""Missing JobKey"");
+                }
+                jobWorker = getEndpoint().getZeebeService().registerJobHandler(new ConsumerJobHandler(),
+                        getEndpoint().getJobKey(), getEndpoint().getTimeout());
+                break;
+            default:
+                LOG.error(""Invalid Operation %s"", operationName.value());
+                throw new CamelException(String.format(""Invalid Operation for Consumer %s"", operationName.value()));
+        }
+    }
+
+    @Override
+    protected void doStop() throws Exception {
+        super.doStop();
+
+        if (jobWorker != null && jobWorker.isOpen()) {
+            jobWorker.close();
+        }
+    }
+
+    private class ConsumerJobHandler implements JobHandler {
+        @Override
+        public void handle(JobClient client, ActivatedJob job) throws Exception {
+            final Exchange exchange = createExchange(true);
+            final Message in = exchange.getIn();
+
+            JobWorkerMessage message = new JobWorkerMessage();
+            message.setKey(job.getKey());
+            message.setType(job.getType());
+            message.setCustomHeaders(job.getCustomHeaders());
+            message.setProcessInstanceKey(job.getProcessInstanceKey());
+            message.setBpmnProcessId(job.getBpmnProcessId());
+            message.setProcessDefinitionVersion(job.getProcessDefinitionVersion());
+            message.setProcessDefinitionKey(job.getProcessDefinitionKey());
+            message.setElementId(job.getElementId());
+            message.setElementInstanceKey(job.getElementInstanceKey());
+            message.setWorker(job.getWorker());
+            message.setRetries(job.getRetries());
+            message.setDeadline(job.getDeadline());
+            message.setVariables(job.getVariablesAsMap());
+
+            LOG.info(job.toJson());","[{'comment': 'A few things:\r\n\r\n1. Maybe add a message explaining what is being logged.\r\n2. Also, seems like it would be better to use a lower debug level (`debug`, maybe?).', 'commenter': 'orpiske'}]"
9191,components/camel-zeebe/src/main/java/org/apache/camel/component/zeebe/ZeebeEndpoint.java,"@@ -0,0 +1,142 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.camel.component.zeebe;
+
+import org.apache.camel.Category;
+import org.apache.camel.Consumer;
+import org.apache.camel.Processor;
+import org.apache.camel.Producer;
+import org.apache.camel.component.zeebe.internal.OperationName;
+import org.apache.camel.component.zeebe.internal.ZeebeService;
+import org.apache.camel.spi.Metadata;
+import org.apache.camel.spi.UriEndpoint;
+import org.apache.camel.spi.UriParam;
+import org.apache.camel.spi.UriPath;
+import org.apache.camel.support.DefaultEndpoint;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * Zeebe component which does bla bla.
+ *
+ * TODO: Update one line description above what the component does.
+ */
+@UriEndpoint(firstVersion = ""1.0-SNAPSHOT"", scheme = ""zeebe"", title = ""Zeebe"", syntax = ""zeebe:operationName"",
+             category = { Category.JAVA },
+             headersClass = ZeebeConstants.class)
+public class ZeebeEndpoint extends DefaultEndpoint {
+
+    private static final Logger LOG = LoggerFactory.getLogger(ZeebeEndpoint.class);
+
+    @UriPath(label = ""common"", description = ""The operation to use"", enums = ""startProcess,"" +
+                                                                             ""cancelProcess,publishMessage,completeJob,failJob,updateJobRetries,worker,throwError,deployResource"")
+    @Metadata(required = true)
+    private OperationName operationName;
+
+    @UriParam(defaultValue = ""false"")
+    @Metadata(description = ""Format the result in the body as JSON."")
+    private boolean formatJSON;
+
+    @UriParam
+    @Metadata(label = ""consumer"", description = ""JobKey for the job worker."", javaType = ""String"")
+    private String jobKey;
+
+    @UriParam(defaultValue = ""10"")
+    @Metadata(label = ""consumer"", description = ""Timeout for job worker."", javaType = ""int"")
+    private int timeout = 10;
+
+    public ZeebeEndpoint() {
+    }
+
+    public ZeebeEndpoint(String uri, ZeebeComponent component, OperationName operationName) {
+        super(uri, component);
+
+        this.operationName = operationName;
+    }
+
+    public Producer createProducer() throws Exception {
+        if (operationName == null) {
+            throw new IllegalArgumentException(String.format(""Invalid Operation""));","[{'comment': 'The `String.format` seems unnecessary here. Also, a bit more details about the state of `operationName` would be helpful (i.e.; ""Invalid operation: null operation name""); \r\n\r\nLastly, probably a better check w/ the `ObjectHelper.notNull`.', 'commenter': 'orpiske'}]"
9191,components/camel-zeebe/src/main/java/org/apache/camel/component/zeebe/ZeebeEndpoint.java,"@@ -0,0 +1,142 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.camel.component.zeebe;
+
+import org.apache.camel.Category;
+import org.apache.camel.Consumer;
+import org.apache.camel.Processor;
+import org.apache.camel.Producer;
+import org.apache.camel.component.zeebe.internal.OperationName;
+import org.apache.camel.component.zeebe.internal.ZeebeService;
+import org.apache.camel.spi.Metadata;
+import org.apache.camel.spi.UriEndpoint;
+import org.apache.camel.spi.UriParam;
+import org.apache.camel.spi.UriPath;
+import org.apache.camel.support.DefaultEndpoint;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * Zeebe component which does bla bla.
+ *
+ * TODO: Update one line description above what the component does.
+ */
+@UriEndpoint(firstVersion = ""1.0-SNAPSHOT"", scheme = ""zeebe"", title = ""Zeebe"", syntax = ""zeebe:operationName"",
+             category = { Category.JAVA },
+             headersClass = ZeebeConstants.class)
+public class ZeebeEndpoint extends DefaultEndpoint {
+
+    private static final Logger LOG = LoggerFactory.getLogger(ZeebeEndpoint.class);
+
+    @UriPath(label = ""common"", description = ""The operation to use"", enums = ""startProcess,"" +
+                                                                             ""cancelProcess,publishMessage,completeJob,failJob,updateJobRetries,worker,throwError,deployResource"")
+    @Metadata(required = true)
+    private OperationName operationName;
+
+    @UriParam(defaultValue = ""false"")
+    @Metadata(description = ""Format the result in the body as JSON."")
+    private boolean formatJSON;
+
+    @UriParam
+    @Metadata(label = ""consumer"", description = ""JobKey for the job worker."", javaType = ""String"")
+    private String jobKey;
+
+    @UriParam(defaultValue = ""10"")
+    @Metadata(label = ""consumer"", description = ""Timeout for job worker."", javaType = ""int"")
+    private int timeout = 10;
+
+    public ZeebeEndpoint() {
+    }
+
+    public ZeebeEndpoint(String uri, ZeebeComponent component, OperationName operationName) {
+        super(uri, component);
+
+        this.operationName = operationName;
+    }
+
+    public Producer createProducer() throws Exception {
+        if (operationName == null) {
+            throw new IllegalArgumentException(String.format(""Invalid Operation""));
+        }
+
+        return new ZeebeProducer(this);
+    }
+
+    public Consumer createConsumer(Processor processor) throws Exception {
+        if (operationName == null) {
+            throw new IllegalArgumentException(String.format(""Invalid Operation""));
+        }","[{'comment': 'Same as above.', 'commenter': 'orpiske'}]"
9191,components/camel-zeebe/src/test/java/org/apache/camel/component/zeebe/ResourceDeploymentIntegrationTest.java,"@@ -0,0 +1,161 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.camel.component.zeebe;
+
+import com.fasterxml.jackson.databind.ObjectMapper;
+import org.apache.camel.Exchange;
+import org.apache.camel.builder.RouteBuilder;
+import org.apache.camel.component.mock.MockEndpoint;
+import org.apache.camel.component.zeebe.model.DeploymentRequest;
+import org.apache.camel.component.zeebe.model.DeploymentResponse;
+import org.apache.camel.component.zeebe.model.ProcessDeploymentResponse;
+import org.apache.camel.test.junit5.CamelTestSupport;
+import org.junit.jupiter.api.Tag;
+import org.junit.jupiter.api.Test;
+
+import static org.junit.jupiter.api.Assertions.assertFalse;
+import static org.junit.jupiter.api.Assertions.assertTrue;
+
+@Tag(""standalone"")
+public class ResourceDeploymentIntegrationTest extends CamelTestSupport {
+
+    public static final String RESOURCE_PATH = ""data/"";
+    public static final String RESOURCE_NAME = ""test1_definition.bpmn"";
+
+    public static final String INVALID_RESOURCE_NAME = ""test1_definition.txt"";
+
+    protected ZeebeComponent component;
+
+    private final ObjectMapper objectMapper = new ObjectMapper();
+
+    @Test
+    void testUploadProcessDefinition() throws Exception {
+        MockEndpoint mock = getMockEndpoint(""mock:deployResource"");
+        mock.expectedMinimumMessageCount(1);
+        mock.expectedHeaderReceived(ZeebeConstants.IS_SUCCESS, true);
+        mock.expectedHeaderReceived(ZeebeConstants.RESOURCE_NAME, RESOURCE_NAME);
+
+        DeploymentRequest deploymentRequest = new DeploymentRequest();
+        deploymentRequest.setName(RESOURCE_NAME);
+        deploymentRequest
+                .setContent(this.getClass().getClassLoader().getResourceAsStream(RESOURCE_PATH + RESOURCE_NAME).readAllBytes());
+
+        template.sendBody(""direct:deployResource"", deploymentRequest);
+        MockEndpoint.assertIsSatisfied(context);
+        if (!mock.getExchanges().isEmpty()) {
+            Exchange exchange = mock.getExchanges().get(0);
+            Object body = exchange.getIn().getBody();
+            assertTrue(body instanceof ProcessDeploymentResponse);
+            assertTrue(((ProcessDeploymentResponse) body).isSuccess());
+            assertTrue(exchange.getIn().getHeaders().containsKey(ZeebeConstants.PROCESS_DEFINITION_KEY));
+            assertTrue(exchange.getIn().getHeaders().containsKey(ZeebeConstants.BPMN_PROCESS_ID));
+            assertTrue(exchange.getIn().getHeaders().containsKey(ZeebeConstants.VERSION));
+        }
+
+        // Deploy with resource name in header and resource as byte[] in body
+        template.sendBodyAndHeader(""direct:deployResource"",
+                this.getClass().getClassLoader().getResourceAsStream(RESOURCE_PATH + RESOURCE_NAME).readAllBytes(),
+                ZeebeConstants.RESOURCE_NAME, RESOURCE_NAME);
+        MockEndpoint.assertIsSatisfied(context);
+        if (!mock.getExchanges().isEmpty()) {
+            Exchange exchange = mock.getExchanges().get(0);
+            Object body = exchange.getIn().getBody();
+            assertTrue(body instanceof ProcessDeploymentResponse);
+            assertTrue(((ProcessDeploymentResponse) body).isSuccess());
+        }
+
+        // Deploy with resource name in header and resource as String in body
+        template.sendBodyAndHeader(""direct:deployResource"",
+                new String(this.getClass().getClassLoader().getResourceAsStream(RESOURCE_PATH + RESOURCE_NAME).readAllBytes()),
+                ZeebeConstants.RESOURCE_NAME, RESOURCE_NAME);
+        MockEndpoint.assertIsSatisfied(context);
+        if (!mock.getExchanges().isEmpty()) {
+            Exchange exchange = mock.getExchanges().get(0);
+            Object body = exchange.getIn().getBody();
+            assertTrue(body instanceof ProcessDeploymentResponse);
+            assertTrue(((ProcessDeploymentResponse) body).isSuccess());
+        }
+    }
+
+    @Test
+    void testUploadProcessDefinitionJSON() throws Exception {
+        MockEndpoint mock = getMockEndpoint(""mock:deployResource_JSON"");
+        mock.expectedMinimumMessageCount(1);
+
+        DeploymentRequest deploymentRequest = new DeploymentRequest();
+        deploymentRequest.setName(RESOURCE_NAME);
+        deploymentRequest
+                .setContent(this.getClass().getClassLoader().getResourceAsStream(""data/test1_definition.bpmn"").readAllBytes());
+
+        template.sendBody(""direct:deployResource_JSON"", objectMapper.writeValueAsString(deploymentRequest));
+        MockEndpoint.assertIsSatisfied(context);
+        if (!mock.getExchanges().isEmpty()) {
+            Exchange exchange = mock.getExchanges().get(0);
+            String body = exchange.getIn().getBody(String.class);
+            ProcessDeploymentResponse response = objectMapper.readValue(body, ProcessDeploymentResponse.class);
+            assertTrue(response.isSuccess());
+        }
+    }
+
+    @Test
+    void testInvalidUploadProcessDefinition() throws Exception {
+        MockEndpoint mock = getMockEndpoint(""mock:deployResource"");
+        mock.expectedMinimumMessageCount(1);
+        mock.expectedHeaderReceived(ZeebeConstants.IS_SUCCESS, false);
+
+        DeploymentRequest deploymentRequest = new DeploymentRequest();
+        deploymentRequest.setName(INVALID_RESOURCE_NAME);
+        deploymentRequest
+                .setContent(this.getClass().getClassLoader().getResourceAsStream(RESOURCE_PATH + RESOURCE_NAME).readAllBytes());
+
+        template.sendBody(""direct:deployResource"", deploymentRequest);
+        MockEndpoint.assertIsSatisfied(context);
+        if (!mock.getExchanges().isEmpty()) {
+            Exchange exchange = mock.getExchanges().get(0);
+            Object body = exchange.getIn().getBody();
+            assertTrue(body instanceof DeploymentResponse);","[{'comment': ""IIRC, there's an assert specific to check for the type. "", 'commenter': 'orpiske'}, {'comment': 'assertObjectIsClass does not exist in JUnit5. It seems it was removed. Stackoverflow recommends instances', 'commenter': 'LoRez'}, {'comment': 'Thanks for the changes so far. Try `import static org.junit.jupiter.api.Assertions.assertInstanceOf;` ', 'commenter': 'orpiske'}]"
9191,components/camel-zeebe/src/test/java/org/apache/camel/component/zeebe/ZeebeConsumerIntegrationTest.java,"@@ -0,0 +1,184 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.camel.component.zeebe;
+
+import java.util.List;
+import java.util.concurrent.TimeUnit;
+
+import com.fasterxml.jackson.databind.ObjectMapper;
+import org.apache.camel.CamelContext;
+import org.apache.camel.Exchange;
+import org.apache.camel.builder.RouteBuilder;
+import org.apache.camel.component.mock.MockEndpoint;
+import org.apache.camel.component.zeebe.model.DeploymentRequest;
+import org.apache.camel.component.zeebe.model.DeploymentResponse;
+import org.apache.camel.component.zeebe.model.JobRequest;
+import org.apache.camel.component.zeebe.model.JobWorkerMessage;
+import org.apache.camel.component.zeebe.model.ProcessDeploymentResponse;
+import org.apache.camel.component.zeebe.model.ProcessRequest;
+import org.apache.camel.component.zeebe.model.ProcessResponse;
+import org.apache.camel.test.junit5.CamelTestSupport;
+import org.junit.jupiter.api.Assertions;
+import org.junit.jupiter.api.BeforeAll;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Tag;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.TestInstance;
+import org.mockito.junit.jupiter.MockitoSettings;
+import org.mockito.quality.Strictness;
+
+import static org.junit.jupiter.api.Assertions.assertNotNull;
+import static org.junit.jupiter.api.Assertions.assertTrue;
+
+@Tag(""standalone"")
+@MockitoSettings(strictness = Strictness.LENIENT)
+@TestInstance(TestInstance.Lifecycle.PER_CLASS)
+class ZeebeConsumerIntegrationTest extends CamelTestSupport {
+
+    public static final String TEST_1_DEFINITION_BPMN = ""test1_definition.bpmn"";
+    private ZeebeComponent component;
+
+    private final ObjectMapper objectMapper = new ObjectMapper();
+
+    @BeforeAll
+    void initAll() throws Exception {
+        createComponent();
+        component.doStart();
+
+        DeploymentRequest deployProcessMessage = new DeploymentRequest();
+        deployProcessMessage.setName(TEST_1_DEFINITION_BPMN);
+        deployProcessMessage
+                .setContent(this.getClass().getClassLoader().getResourceAsStream(""data/test1_definition.bpmn"").readAllBytes());
+
+        DeploymentResponse deploymentResponse = component.getZeebeService().deployResource(deployProcessMessage);
+
+        ProcessRequest processRequest = new ProcessRequest();
+        processRequest.setProcessId(((ProcessDeploymentResponse) deploymentResponse).getBpmnProcessId());
+        ProcessResponse processResponse = component.getZeebeService().startProcess(processRequest);
+    }
+
+    @BeforeEach
+    void init() throws Exception {
+
+    }
+
+    @Test
+    public void shouldProcessJobWorkerMessage() throws Exception {
+        MockEndpoint workerMock = getMockEndpoint(""mock:jobWorker"");
+        workerMock.expectedMinimumMessageCount(1);
+
+        for (int i = 0; i < 10; i++) {
+            if (!workerMock.getExchanges().isEmpty()) {
+                break;
+            }
+            TimeUnit.SECONDS.sleep(2);","[{'comment': ""Please, avoid `sleeps` on the test code. Our tests already consume way too much time and we have been trying to reduce this. If some kind of synchronization is needed, I'd recommend looking at using Awaitility to do so."", 'commenter': 'orpiske'}]"
9191,components/camel-zeebe/src/test/java/org/apache/camel/component/zeebe/ZeebeConsumerIntegrationTest.java,"@@ -0,0 +1,184 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.camel.component.zeebe;
+
+import java.util.List;
+import java.util.concurrent.TimeUnit;
+
+import com.fasterxml.jackson.databind.ObjectMapper;
+import org.apache.camel.CamelContext;
+import org.apache.camel.Exchange;
+import org.apache.camel.builder.RouteBuilder;
+import org.apache.camel.component.mock.MockEndpoint;
+import org.apache.camel.component.zeebe.model.DeploymentRequest;
+import org.apache.camel.component.zeebe.model.DeploymentResponse;
+import org.apache.camel.component.zeebe.model.JobRequest;
+import org.apache.camel.component.zeebe.model.JobWorkerMessage;
+import org.apache.camel.component.zeebe.model.ProcessDeploymentResponse;
+import org.apache.camel.component.zeebe.model.ProcessRequest;
+import org.apache.camel.component.zeebe.model.ProcessResponse;
+import org.apache.camel.test.junit5.CamelTestSupport;
+import org.junit.jupiter.api.Assertions;
+import org.junit.jupiter.api.BeforeAll;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Tag;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.TestInstance;
+import org.mockito.junit.jupiter.MockitoSettings;
+import org.mockito.quality.Strictness;
+
+import static org.junit.jupiter.api.Assertions.assertNotNull;
+import static org.junit.jupiter.api.Assertions.assertTrue;
+
+@Tag(""standalone"")
+@MockitoSettings(strictness = Strictness.LENIENT)
+@TestInstance(TestInstance.Lifecycle.PER_CLASS)
+class ZeebeConsumerIntegrationTest extends CamelTestSupport {
+
+    public static final String TEST_1_DEFINITION_BPMN = ""test1_definition.bpmn"";
+    private ZeebeComponent component;
+
+    private final ObjectMapper objectMapper = new ObjectMapper();
+
+    @BeforeAll
+    void initAll() throws Exception {
+        createComponent();
+        component.doStart();
+
+        DeploymentRequest deployProcessMessage = new DeploymentRequest();
+        deployProcessMessage.setName(TEST_1_DEFINITION_BPMN);
+        deployProcessMessage
+                .setContent(this.getClass().getClassLoader().getResourceAsStream(""data/test1_definition.bpmn"").readAllBytes());
+
+        DeploymentResponse deploymentResponse = component.getZeebeService().deployResource(deployProcessMessage);
+
+        ProcessRequest processRequest = new ProcessRequest();
+        processRequest.setProcessId(((ProcessDeploymentResponse) deploymentResponse).getBpmnProcessId());
+        ProcessResponse processResponse = component.getZeebeService().startProcess(processRequest);
+    }
+
+    @BeforeEach
+    void init() throws Exception {
+
+    }
+
+    @Test
+    public void shouldProcessJobWorkerMessage() throws Exception {
+        MockEndpoint workerMock = getMockEndpoint(""mock:jobWorker"");
+        workerMock.expectedMinimumMessageCount(1);
+
+        for (int i = 0; i < 10; i++) {
+            if (!workerMock.getExchanges().isEmpty()) {
+                break;
+            }
+            TimeUnit.SECONDS.sleep(2);
+        }
+        MockEndpoint.assertIsSatisfied(context);
+
+        List<Exchange> exchanges = workerMock.getExchanges();
+        for (Exchange exchange : exchanges) {
+            JobWorkerMessage jobWorkerMessage = exchange.getIn().getBody(JobWorkerMessage.class);
+            if (jobWorkerMessage != null) {
+                assertTrue(jobWorkerMessage.getKey() > 0);
+                assertTrue(jobWorkerMessage.getProcessInstanceKey() > 0);
+                assertNotNull(jobWorkerMessage.getBpmnProcessId());
+                assertTrue(jobWorkerMessage.getProcessDefinitionVersion() > 0);
+                assertTrue(jobWorkerMessage.getProcessDefinitionKey() > 0);
+                assertNotNull(jobWorkerMessage.getElementId());
+                assertTrue(jobWorkerMessage.getProcessInstanceKey() > 0);
+                assertNotNull(jobWorkerMessage.getWorker());
+                assertTrue(jobWorkerMessage.getRetries() > 0);
+                assertTrue(jobWorkerMessage.getDeadline() > 0);
+
+                JobRequest jobRequest = new JobRequest();
+                jobRequest.setJobKey(jobWorkerMessage.getKey());
+                component.getZeebeService().completeJob(jobRequest);
+            } else {
+                Assertions.fail();","[{'comment': 'It would be good to have a fail message here.', 'commenter': 'orpiske'}]"
9191,components/camel-zeebe/src/test/java/org/apache/camel/component/zeebe/ZeebeConsumerIntegrationTest.java,"@@ -0,0 +1,184 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.camel.component.zeebe;
+
+import java.util.List;
+import java.util.concurrent.TimeUnit;
+
+import com.fasterxml.jackson.databind.ObjectMapper;
+import org.apache.camel.CamelContext;
+import org.apache.camel.Exchange;
+import org.apache.camel.builder.RouteBuilder;
+import org.apache.camel.component.mock.MockEndpoint;
+import org.apache.camel.component.zeebe.model.DeploymentRequest;
+import org.apache.camel.component.zeebe.model.DeploymentResponse;
+import org.apache.camel.component.zeebe.model.JobRequest;
+import org.apache.camel.component.zeebe.model.JobWorkerMessage;
+import org.apache.camel.component.zeebe.model.ProcessDeploymentResponse;
+import org.apache.camel.component.zeebe.model.ProcessRequest;
+import org.apache.camel.component.zeebe.model.ProcessResponse;
+import org.apache.camel.test.junit5.CamelTestSupport;
+import org.junit.jupiter.api.Assertions;
+import org.junit.jupiter.api.BeforeAll;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Tag;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.TestInstance;
+import org.mockito.junit.jupiter.MockitoSettings;
+import org.mockito.quality.Strictness;
+
+import static org.junit.jupiter.api.Assertions.assertNotNull;
+import static org.junit.jupiter.api.Assertions.assertTrue;
+
+@Tag(""standalone"")
+@MockitoSettings(strictness = Strictness.LENIENT)
+@TestInstance(TestInstance.Lifecycle.PER_CLASS)
+class ZeebeConsumerIntegrationTest extends CamelTestSupport {
+
+    public static final String TEST_1_DEFINITION_BPMN = ""test1_definition.bpmn"";
+    private ZeebeComponent component;
+
+    private final ObjectMapper objectMapper = new ObjectMapper();
+
+    @BeforeAll
+    void initAll() throws Exception {
+        createComponent();
+        component.doStart();
+
+        DeploymentRequest deployProcessMessage = new DeploymentRequest();
+        deployProcessMessage.setName(TEST_1_DEFINITION_BPMN);
+        deployProcessMessage
+                .setContent(this.getClass().getClassLoader().getResourceAsStream(""data/test1_definition.bpmn"").readAllBytes());
+
+        DeploymentResponse deploymentResponse = component.getZeebeService().deployResource(deployProcessMessage);
+
+        ProcessRequest processRequest = new ProcessRequest();
+        processRequest.setProcessId(((ProcessDeploymentResponse) deploymentResponse).getBpmnProcessId());
+        ProcessResponse processResponse = component.getZeebeService().startProcess(processRequest);
+    }
+
+    @BeforeEach
+    void init() throws Exception {
+
+    }
+
+    @Test
+    public void shouldProcessJobWorkerMessage() throws Exception {
+        MockEndpoint workerMock = getMockEndpoint(""mock:jobWorker"");
+        workerMock.expectedMinimumMessageCount(1);
+
+        for (int i = 0; i < 10; i++) {
+            if (!workerMock.getExchanges().isEmpty()) {
+                break;
+            }
+            TimeUnit.SECONDS.sleep(2);
+        }
+        MockEndpoint.assertIsSatisfied(context);
+
+        List<Exchange> exchanges = workerMock.getExchanges();
+        for (Exchange exchange : exchanges) {
+            JobWorkerMessage jobWorkerMessage = exchange.getIn().getBody(JobWorkerMessage.class);
+            if (jobWorkerMessage != null) {
+                assertTrue(jobWorkerMessage.getKey() > 0);
+                assertTrue(jobWorkerMessage.getProcessInstanceKey() > 0);
+                assertNotNull(jobWorkerMessage.getBpmnProcessId());
+                assertTrue(jobWorkerMessage.getProcessDefinitionVersion() > 0);
+                assertTrue(jobWorkerMessage.getProcessDefinitionKey() > 0);
+                assertNotNull(jobWorkerMessage.getElementId());
+                assertTrue(jobWorkerMessage.getProcessInstanceKey() > 0);
+                assertNotNull(jobWorkerMessage.getWorker());
+                assertTrue(jobWorkerMessage.getRetries() > 0);
+                assertTrue(jobWorkerMessage.getDeadline() > 0);
+
+                JobRequest jobRequest = new JobRequest();
+                jobRequest.setJobKey(jobWorkerMessage.getKey());
+                component.getZeebeService().completeJob(jobRequest);
+            } else {
+                Assertions.fail();
+            }
+        }
+    }
+
+    @Test
+    public void shouldProcessJobWorkerMessageJSON() throws Exception {
+        MockEndpoint workerMock = getMockEndpoint(""mock:jobWorker_JSON"");
+        workerMock.expectedMinimumMessageCount(1);
+
+        for (int i = 0; i < 10; i++) {
+            if (!workerMock.getExchanges().isEmpty()) {
+                break;
+            }
+            TimeUnit.SECONDS.sleep(2);","[{'comment': 'Same note about `sleeps` as I raised before.', 'commenter': 'orpiske'}]"
9191,components/camel-zeebe/src/test/java/org/apache/camel/component/zeebe/ZeebeConsumerIntegrationTest.java,"@@ -0,0 +1,184 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.camel.component.zeebe;
+
+import java.util.List;
+import java.util.concurrent.TimeUnit;
+
+import com.fasterxml.jackson.databind.ObjectMapper;
+import org.apache.camel.CamelContext;
+import org.apache.camel.Exchange;
+import org.apache.camel.builder.RouteBuilder;
+import org.apache.camel.component.mock.MockEndpoint;
+import org.apache.camel.component.zeebe.model.DeploymentRequest;
+import org.apache.camel.component.zeebe.model.DeploymentResponse;
+import org.apache.camel.component.zeebe.model.JobRequest;
+import org.apache.camel.component.zeebe.model.JobWorkerMessage;
+import org.apache.camel.component.zeebe.model.ProcessDeploymentResponse;
+import org.apache.camel.component.zeebe.model.ProcessRequest;
+import org.apache.camel.component.zeebe.model.ProcessResponse;
+import org.apache.camel.test.junit5.CamelTestSupport;
+import org.junit.jupiter.api.Assertions;
+import org.junit.jupiter.api.BeforeAll;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Tag;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.TestInstance;
+import org.mockito.junit.jupiter.MockitoSettings;
+import org.mockito.quality.Strictness;
+
+import static org.junit.jupiter.api.Assertions.assertNotNull;
+import static org.junit.jupiter.api.Assertions.assertTrue;
+
+@Tag(""standalone"")
+@MockitoSettings(strictness = Strictness.LENIENT)
+@TestInstance(TestInstance.Lifecycle.PER_CLASS)
+class ZeebeConsumerIntegrationTest extends CamelTestSupport {
+
+    public static final String TEST_1_DEFINITION_BPMN = ""test1_definition.bpmn"";
+    private ZeebeComponent component;
+
+    private final ObjectMapper objectMapper = new ObjectMapper();
+
+    @BeforeAll
+    void initAll() throws Exception {
+        createComponent();
+        component.doStart();
+
+        DeploymentRequest deployProcessMessage = new DeploymentRequest();
+        deployProcessMessage.setName(TEST_1_DEFINITION_BPMN);
+        deployProcessMessage
+                .setContent(this.getClass().getClassLoader().getResourceAsStream(""data/test1_definition.bpmn"").readAllBytes());
+
+        DeploymentResponse deploymentResponse = component.getZeebeService().deployResource(deployProcessMessage);
+
+        ProcessRequest processRequest = new ProcessRequest();
+        processRequest.setProcessId(((ProcessDeploymentResponse) deploymentResponse).getBpmnProcessId());
+        ProcessResponse processResponse = component.getZeebeService().startProcess(processRequest);
+    }
+
+    @BeforeEach
+    void init() throws Exception {
+
+    }
+
+    @Test
+    public void shouldProcessJobWorkerMessage() throws Exception {
+        MockEndpoint workerMock = getMockEndpoint(""mock:jobWorker"");
+        workerMock.expectedMinimumMessageCount(1);
+
+        for (int i = 0; i < 10; i++) {
+            if (!workerMock.getExchanges().isEmpty()) {
+                break;
+            }
+            TimeUnit.SECONDS.sleep(2);
+        }
+        MockEndpoint.assertIsSatisfied(context);
+
+        List<Exchange> exchanges = workerMock.getExchanges();
+        for (Exchange exchange : exchanges) {
+            JobWorkerMessage jobWorkerMessage = exchange.getIn().getBody(JobWorkerMessage.class);
+            if (jobWorkerMessage != null) {
+                assertTrue(jobWorkerMessage.getKey() > 0);
+                assertTrue(jobWorkerMessage.getProcessInstanceKey() > 0);
+                assertNotNull(jobWorkerMessage.getBpmnProcessId());
+                assertTrue(jobWorkerMessage.getProcessDefinitionVersion() > 0);
+                assertTrue(jobWorkerMessage.getProcessDefinitionKey() > 0);
+                assertNotNull(jobWorkerMessage.getElementId());
+                assertTrue(jobWorkerMessage.getProcessInstanceKey() > 0);
+                assertNotNull(jobWorkerMessage.getWorker());
+                assertTrue(jobWorkerMessage.getRetries() > 0);
+                assertTrue(jobWorkerMessage.getDeadline() > 0);
+
+                JobRequest jobRequest = new JobRequest();
+                jobRequest.setJobKey(jobWorkerMessage.getKey());
+                component.getZeebeService().completeJob(jobRequest);
+            } else {
+                Assertions.fail();
+            }
+        }
+    }
+
+    @Test
+    public void shouldProcessJobWorkerMessageJSON() throws Exception {
+        MockEndpoint workerMock = getMockEndpoint(""mock:jobWorker_JSON"");
+        workerMock.expectedMinimumMessageCount(1);
+
+        for (int i = 0; i < 10; i++) {
+            if (!workerMock.getExchanges().isEmpty()) {
+                break;
+            }
+            TimeUnit.SECONDS.sleep(2);
+        }
+        MockEndpoint.assertIsSatisfied(context);
+
+        List<Exchange> exchanges = workerMock.getExchanges();
+        for (Exchange exchange : exchanges) {
+            String jobWorkerMessageString = exchange.getIn().getBody(String.class);
+            if (jobWorkerMessageString != null) {
+                JobWorkerMessage jobWorkerMessage = objectMapper.readValue(jobWorkerMessageString, JobWorkerMessage.class);
+
+                assertTrue(jobWorkerMessage.getKey() > 0);
+                assertTrue(jobWorkerMessage.getProcessInstanceKey() > 0);
+                assertNotNull(jobWorkerMessage.getBpmnProcessId());
+                assertTrue(jobWorkerMessage.getProcessDefinitionVersion() > 0);
+                assertTrue(jobWorkerMessage.getProcessDefinitionKey() > 0);
+                assertNotNull(jobWorkerMessage.getElementId());
+                assertTrue(jobWorkerMessage.getProcessInstanceKey() > 0);
+                assertNotNull(jobWorkerMessage.getWorker());
+                assertTrue(jobWorkerMessage.getRetries() > 0);
+                assertTrue(jobWorkerMessage.getDeadline() > 0);
+
+                JobRequest jobRequest = new JobRequest();
+                jobRequest.setJobKey(jobWorkerMessage.getKey());
+                component.getZeebeService().completeJob(jobRequest);
+            } else {
+                Assertions.fail();","[{'comment': 'Same note about `fail` messages.', 'commenter': 'orpiske'}]"
9191,components/camel-zeebe/src/test/java/org/apache/camel/component/zeebe/model/DeploymentRequestTest.java,"@@ -0,0 +1,61 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.camel.component.zeebe.model;
+
+import com.fasterxml.jackson.core.JsonProcessingException;
+import com.fasterxml.jackson.databind.ObjectMapper;
+import org.junit.jupiter.api.Test;
+
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.fail;
+
+public class DeploymentRequestTest {
+
+    private static final String MARSHAL_TEST_RESULT_1 = ""{\""name\"":\""test.bpmn\"",\""content\"":\""dGVzdCBjb250ZW50\""}"";
+
+    private final ObjectMapper objectMapper = new ObjectMapper();
+
+    @Test
+    public void marshalTest() {
+        DeploymentRequest message = new DeploymentRequest();
+        message.setName(""test.bpmn"");
+        message.setContent(""test content"".getBytes());
+
+        try {
+            String messageString = objectMapper.writeValueAsString(message);
+            assertEquals(MARSHAL_TEST_RESULT_1, messageString);
+        } catch (JsonProcessingException e) {
+            fail(""Error in JSON processing"");
+        }","[{'comment': 'Please use `Assert.assertDoesNotThrow`  whenever you need to assert some piece of test code does not throw an exception.', 'commenter': 'orpiske'}]"
9191,components/camel-zeebe/src/test/java/org/apache/camel/component/zeebe/model/DeploymentRequestTest.java,"@@ -0,0 +1,61 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.camel.component.zeebe.model;
+
+import com.fasterxml.jackson.core.JsonProcessingException;
+import com.fasterxml.jackson.databind.ObjectMapper;
+import org.junit.jupiter.api.Test;
+
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.fail;
+
+public class DeploymentRequestTest {
+
+    private static final String MARSHAL_TEST_RESULT_1 = ""{\""name\"":\""test.bpmn\"",\""content\"":\""dGVzdCBjb250ZW50\""}"";
+
+    private final ObjectMapper objectMapper = new ObjectMapper();
+
+    @Test
+    public void marshalTest() {
+        DeploymentRequest message = new DeploymentRequest();
+        message.setName(""test.bpmn"");
+        message.setContent(""test content"".getBytes());
+
+        try {
+            String messageString = objectMapper.writeValueAsString(message);
+            assertEquals(MARSHAL_TEST_RESULT_1, messageString);
+        } catch (JsonProcessingException e) {
+            fail(""Error in JSON processing"");
+        }
+    }
+
+    @Test
+    public void unmarshalTest() {
+        try {
+            DeploymentRequest unmarshalledMessage1 = objectMapper.readValue(MARSHAL_TEST_RESULT_1, DeploymentRequest.class);
+
+            DeploymentRequest message = new DeploymentRequest();
+            message.setName(""test.bpmn"");
+            message.setContent(""test content"".getBytes());
+
+            assertEquals(message, unmarshalledMessage1);
+        } catch (JsonProcessingException e) {","[{'comment': 'Same as above.', 'commenter': 'orpiske'}]"
9191,components/camel-zeebe/pom.xml,"@@ -0,0 +1,158 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--
+  ~  Licensed to the Apache Software Foundation (ASF) under one or more
+  ~  contributor license agreements.  See the NOTICE file distributed with
+  ~  this work for additional information regarding copyright ownership.
+  ~  The ASF licenses this file to You under the Apache License, Version 2.0
+  ~  (the ""License""); you may not use this file except in compliance with
+  ~  the License.  You may obtain a copy of the License at
+  ~
+  ~        http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~  Unless required by applicable law or agreed to in writing, software
+  ~  distributed under the License is distributed on an ""AS IS"" BASIS,
+  ~  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~  See the License for the specific language governing permissions and
+  ~  limitations under the License.
+  -->
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
+         xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+    <modelVersion>4.0.0</modelVersion>
+
+    <parent>
+        <groupId>org.apache.camel</groupId>
+        <artifactId>components</artifactId>
+        <version>3.21.0-SNAPSHOT</version>
+    </parent>
+
+    <artifactId>camel-zeebe</artifactId>
+    <packaging>jar</packaging>
+    <name>Camel :: Zeebe</name>
+    <description>Camel Zeebe support</description>
+
+    <properties>
+        <firstVersion>3.20</firstVersion>
+        <supportLevel>Experimental</supportLevel>
+        <zeebe.version>8.1.0</zeebe.version>
+    </properties>
+
+    <dependencies>
+        <dependency>
+            <groupId>org.apache.camel</groupId>
+            <artifactId>camel-support</artifactId>
+        </dependency>
+
+        <!-- jackson -->
+        <dependency>
+            <groupId>com.fasterxml.jackson.core</groupId>
+            <artifactId>jackson-core</artifactId>
+            <version>${jackson2-version}</version>
+        </dependency>
+        <dependency>
+            <groupId>com.fasterxml.jackson.core</groupId>
+            <artifactId>jackson-annotations</artifactId>
+            <version>${jackson2-version}</version>
+        </dependency>
+        <dependency>
+            <groupId>com.fasterxml.jackson.core</groupId>
+            <artifactId>jackson-databind</artifactId>
+            <version>${jackson2-version}</version>
+        </dependency>
+
+        <dependency>
+            <groupId>io.camunda</groupId>
+            <artifactId>zeebe-client-java</artifactId>
+            <version>${zeebe.version}</version>
+        </dependency>
+
+        <!-- test dependencies -->
+        <dependency>
+            <groupId>org.apache.logging.log4j</groupId>
+            <artifactId>log4j-slf4j-impl</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.junit.jupiter</groupId>
+            <artifactId>junit-jupiter</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.mockito</groupId>
+            <artifactId>mockito-junit-jupiter</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.apache.camel</groupId>
+            <artifactId>camel-test-junit5</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.testcontainers</groupId>
+            <artifactId>junit-jupiter</artifactId>
+            <scope>test</scope>
+        </dependency>
+    </dependencies>
+
+    <build>
+        <plugins>
+            <plugin>
+                <groupId>org.apache.maven.plugins</groupId>
+                <artifactId>maven-surefire-plugin</artifactId>
+                <configuration>
+                    <excludes>
+                        <exclude>**/*IntegrationTest.java</exclude>","[{'comment': 'Our standard is to name Integration tests as `SomeThingIT.java` (i.e.: **IT.java). Our default surefire configuration is set to skip that and the failsafe is configured to include that. This also impacts a bit the code analysis on Sonar. \r\n\r\nPlease, can you rename the integration tests to match this, so we avoid this extra code?', 'commenter': 'orpiske'}, {'comment': ""Obs.: it's component-specific configurations for surefire and failsafe are OK to keep if they are needed. "", 'commenter': 'orpiske'}, {'comment': 'I did set this up analog to the Salesforce connector. The integration tests only succeed with a locally installed zeebe instance, therefore I wanted it restricted to a profile, again analog to how it is setup fo4 Salesforce. If there is a better way to achieve this I am all ears. \r\n ', 'commenter': 'LoRez'}, {'comment': 'I tried renaming the integration tests to IT but then I was not able to disable them through the profile and they failed when the service is not present, which I guess will be the case for almost everybody.\r\nIs there a way to name them IT and insure that they are only executed when the zeebe-integration profile is active?', 'commenter': 'LoRez'}, {'comment': ""You can use JUnit's `@DisabledIfSystemProperty` or `@EnabledIfSystemProperty`. \r\n\r\nHere's an example: https://github.com/apache/camel/blob/main/components/camel-kafka/src/test/java/org/apache/camel/component/kafka/integration/health/KafkaConsumerBadPortHealthCheckIT.java#L61-L62"", 'commenter': 'orpiske'}, {'comment': 'Ok, changed the behavior to use EnbaledIfSystemProperty. Works fine. Thank you', 'commenter': 'LoRez'}]"
9191,components/camel-zeebe/src/main/docs/zeebe-component.adoc,"@@ -0,0 +1,293 @@
+= Zeebe Component
+:doctitle: Zeebe
+:shortname: zeebe
+:artifactid: camel-zeebe
+:description: Zeebe component which does integrage with Camunda Zeebe to interact with the API.
+:since: 1.0-SNAPSHOT
+:supportlevel: Experimental
+:component-header: Both producer and consumer are supported
+
+*Since Camel {since}*
+
+*{component-header}*
+
+The *Zeebe*: components provides the ability to interact with business processes in https://github.com/camunda/zeebe[Zeebe].
+
+In order to use the Zeebe component, Maven users will need to add the
+following dependency to their `pom.xml`:
+
+Prerequisites
+
+You must have access to a local zeebe instance. More information is available at
+https://camunda.com/platform/zeebe/[Camunda Zeebe].
+
+*pom.xml*
+
+[source,xml]
+----
+<dependency>
+    <groupId>org.apache.camel</groupId>
+    <artifactId>camel-zeebe</artifactId>
+    <version>x.x.x</version>
+    <!-- use the same version as your Camel core version -->
+</dependency>
+----","[{'comment': 'This seems a bit out of order. The dependency is listed after the prerequisites. ', 'commenter': 'orpiske'}, {'comment': 'It seems there are multiple flavors how adocs are structured. I changed it so that the pom info is at the end as in the redis component.', 'commenter': 'LoRez'}, {'comment': 'Thanks. That works.', 'commenter': 'orpiske'}]"
9191,components/camel-zeebe/pom.xml,"@@ -0,0 +1,122 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--","[{'comment': 'Use same license header as other pom.xml files', 'commenter': 'davsclaus'}]"
9191,components/camel-zeebe/pom.xml,"@@ -0,0 +1,122 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--
+  ~  Licensed to the Apache Software Foundation (ASF) under one or more
+  ~  contributor license agreements.  See the NOTICE file distributed with
+  ~  this work for additional information regarding copyright ownership.
+  ~  The ASF licenses this file to You under the Apache License, Version 2.0
+  ~  (the ""License""); you may not use this file except in compliance with
+  ~  the License.  You may obtain a copy of the License at
+  ~
+  ~        http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~  Unless required by applicable law or agreed to in writing, software
+  ~  distributed under the License is distributed on an ""AS IS"" BASIS,
+  ~  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~  See the License for the specific language governing permissions and
+  ~  limitations under the License.
+  -->
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
+         xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+    <modelVersion>4.0.0</modelVersion>
+
+    <parent>
+        <groupId>org.apache.camel</groupId>
+        <artifactId>components</artifactId>
+        <version>3.21.0-SNAPSHOT</version>
+    </parent>
+
+    <artifactId>camel-zeebe</artifactId>
+    <packaging>jar</packaging>
+    <name>Camel :: Zeebe</name>
+    <description>Camel Zeebe support</description>
+
+    <properties>
+        <firstVersion>3.20</firstVersion>","[{'comment': '3.21', 'commenter': 'davsclaus'}]"
9191,components/camel-zeebe/src/main/java/org/apache/camel/component/zeebe/ZeebeComponent.java,"@@ -0,0 +1,133 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.camel.component.zeebe;
+
+import java.util.Map;
+
+import org.apache.camel.Endpoint;
+import org.apache.camel.component.zeebe.internal.OperationName;
+import org.apache.camel.component.zeebe.internal.ZeebeService;
+import org.apache.camel.spi.Metadata;
+import org.apache.camel.support.DefaultComponent;
+
+@org.apache.camel.spi.annotations.Component(""zeebe"")
+public class ZeebeComponent extends DefaultComponent {
+
+    @Metadata(defaultValue = """" + ZeebeConstants.DEFAULT_GATEWAY_HOST)
+    String gatewayHost;
+    @Metadata(defaultValue = """" + ZeebeConstants.DEFAULT_GATEWAY_PORT)
+    int gatewayPort;
+    @Metadata
+    String clientId;
+    @Metadata","[{'comment': 'label = security, secret = true', 'commenter': 'davsclaus'}]"
9191,components/camel-zeebe/src/main/java/org/apache/camel/component/zeebe/ZeebeComponent.java,"@@ -0,0 +1,133 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.camel.component.zeebe;
+
+import java.util.Map;
+
+import org.apache.camel.Endpoint;
+import org.apache.camel.component.zeebe.internal.OperationName;
+import org.apache.camel.component.zeebe.internal.ZeebeService;
+import org.apache.camel.spi.Metadata;
+import org.apache.camel.support.DefaultComponent;
+
+@org.apache.camel.spi.annotations.Component(""zeebe"")
+public class ZeebeComponent extends DefaultComponent {
+
+    @Metadata(defaultValue = """" + ZeebeConstants.DEFAULT_GATEWAY_HOST)
+    String gatewayHost;
+    @Metadata(defaultValue = """" + ZeebeConstants.DEFAULT_GATEWAY_PORT)
+    int gatewayPort;
+    @Metadata
+    String clientId;
+    @Metadata
+    String clientSecret;
+    @Metadata","[{'comment': 'label = security', 'commenter': 'davsclaus'}]"
9191,components/camel-zeebe/src/main/java/org/apache/camel/component/zeebe/ZeebeComponent.java,"@@ -0,0 +1,133 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.camel.component.zeebe;
+
+import java.util.Map;
+
+import org.apache.camel.Endpoint;
+import org.apache.camel.component.zeebe.internal.OperationName;
+import org.apache.camel.component.zeebe.internal.ZeebeService;
+import org.apache.camel.spi.Metadata;
+import org.apache.camel.support.DefaultComponent;
+
+@org.apache.camel.spi.annotations.Component(""zeebe"")
+public class ZeebeComponent extends DefaultComponent {
+
+    @Metadata(defaultValue = """" + ZeebeConstants.DEFAULT_GATEWAY_HOST)
+    String gatewayHost;
+    @Metadata(defaultValue = """" + ZeebeConstants.DEFAULT_GATEWAY_PORT)
+    int gatewayPort;
+    @Metadata","[{'comment': 'label = security', 'commenter': 'davsclaus'}]"
9191,components/camel-zeebe/src/main/java/org/apache/camel/component/zeebe/ZeebeConsumer.java,"@@ -0,0 +1,119 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.camel.component.zeebe;
+
+import com.fasterxml.jackson.core.JsonProcessingException;
+import com.fasterxml.jackson.databind.ObjectMapper;
+import io.camunda.zeebe.client.api.response.ActivatedJob;
+import io.camunda.zeebe.client.api.worker.JobClient;
+import io.camunda.zeebe.client.api.worker.JobHandler;
+import io.camunda.zeebe.client.api.worker.JobWorker;
+import org.apache.camel.AsyncCallback;
+import org.apache.camel.CamelException;
+import org.apache.camel.Exchange;
+import org.apache.camel.Processor;
+import org.apache.camel.component.zeebe.internal.OperationName;
+import org.apache.camel.component.zeebe.model.JobWorkerMessage;
+import org.apache.camel.support.DefaultConsumer;
+import org.apache.camel.util.ObjectHelper;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class ZeebeConsumer extends DefaultConsumer {
+    private static final Logger LOG = LoggerFactory.getLogger(ZeebeConsumer.class);
+
+    private final ZeebeEndpoint endpoint;
+
+    private JobWorker jobWorker;
+
+    private ObjectMapper objectMapper = new ObjectMapper();
+
+    public ZeebeConsumer(ZeebeEndpoint endpoint, Processor processor) throws CamelException {
+        super(endpoint, processor);
+        this.endpoint = endpoint;
+    }
+
+    @Override
+    protected void doStart() throws Exception {
+        super.doStart();
+
+        final OperationName operationName = getEndpoint().getOperationName();
+        switch (operationName) {
+            case REGISTER_JOB_WORKER:
+                ObjectHelper.notNull(getEndpoint().getJobKey(), ""jobKey"");
+
+                jobWorker = getEndpoint().getZeebeService().registerJobHandler(new ConsumerJobHandler(),
+                        getEndpoint().getJobKey(), getEndpoint().getTimeout());
+                break;
+            default:
+                LOG.error(""Invalid Operation {}"", operationName.value());","[{'comment': 'Do not log and throw exception, only throw exception', 'commenter': 'davsclaus'}]"
9210,components/camel-atmosphere-websocket/src/test/java/org/apache/camel/component/atmosphere/websocket/WebsocketRouteWithInitParamTest.java,"@@ -110,18 +114,18 @@ void testWebsocketSingleClientBroadcastMultipleClientsGuaranteeDelivery() throws
         final int awaitTime = 5;
         connectionKeyUserMap.clear();
 
-        WebsocketTestClient wsclient1 = new WebsocketTestClient(""ws://localhost:"" + PORT + ""/hola3"", 2);
-        WebsocketTestClient wsclient2 = new WebsocketTestClient(""ws://localhost:"" + PORT + ""/hola3"", 2);
-        WebsocketTestClient wsclient3 = new WebsocketTestClient(""ws://localhost:"" + PORT + ""/hola3"", 2);
+        WebsocketTestClient wsclient1 = new WebsocketTestClient(""ws://localhost:"" + PORT + ""/guarantee"", 2);
+        WebsocketTestClient wsclient2 = new WebsocketTestClient(""ws://localhost:"" + PORT + ""/guarantee"", 2);
+        WebsocketTestClient wsclient3 = new WebsocketTestClient(""ws://localhost:"" + PORT + ""/guarantee"", 2);
 
         wsclient1.connect();
-        wsclient1.await(awaitTime);
+        wsclient1.await(1);","[{'comment': 'Is this change expected?', 'commenter': 'essobedo'}, {'comment': 'in this way the test runs faster, I noticed that when connecting a high await time is not useful, moreover, there are 3 consequent await', 'commenter': 'Croway'}, {'comment': 'Hm, I am afraid this may cause problems in our Apache CI. Our nodes there are not so fast, so the the time needed to receive the messages could be higher. ', 'commenter': 'orpiske'}]"
9210,components/camel-atmosphere-websocket/src/test/java/org/apache/camel/component/atmosphere/websocket/WebsocketRouteWithInitParamTest.java,"@@ -41,6 +43,8 @@ public class WebsocketRouteWithInitParamTest extends WebsocketCamelRouterWithIni
     private static String[] broadcastMessageTo = {};
     private static Map<String, String> connectionKeyUserMap = new HashMap<>();
 
+    private ExecutorService executor = Executors.newSingleThreadExecutor();","[{'comment': 'Where is it used?', 'commenter': 'essobedo'}, {'comment': 'nice catch, it is just a leftover', 'commenter': 'Croway'}]"
9210,components/camel-atmosphere-websocket/src/main/java/org/apache/camel/component/atmosphere/websocket/WebsocketEndpoint.java,"@@ -86,15 +86,15 @@ public void setSendToAll(boolean sendToAll) {
         this.sendToAll = sendToAll;
     }
 
-    public boolean isUseStreaming() {
-        return useStreaming;
+    public boolean isStreaming() {
+        return streaming;
     }
 
     /**
      * To enable streaming to send data as multiple text fragments.
      */
-    public void setUseStreaming(boolean useStreaming) {
-        this.useStreaming = useStreaming;
+    public void setStreaming(boolean streaming) {","[{'comment': 'I hope there is a better way, renaming a property should be avoided', 'commenter': 'essobedo'}, {'comment': ""I've spent some time, and the only solution I found is renaming that property, I still cannot explain why, but, when useStreaming=true is used, all the messages are consumed by the same endpoint. https://issues.apache.org/jira/browse/CAMEL-18978"", 'commenter': 'Croway'}, {'comment': 'TBH, this is still puzzling me', 'commenter': 'orpiske'}, {'comment': 'I\'m sorry but I\'m a bit concerned about the fact that we impact end users by renaming a property because for an unknown reason it ""fixes"" a test. Renaming the property is just a workaround, it doesn\'t really fix the problem that needs to be addressed as it could be potentially major.\r\n\r\nCould you please describe the problem you met in https://issues.apache.org/jira/browse/CAMEL-18978 instead of describing the solution, just to be sure that we are not facing an XY problem and to allow us to understand the problem.\r\n\r\n', 'commenter': 'essobedo'}, {'comment': 'Hi @essobedo thanks a lot for your review, you were right, useStreaming was not the issue, after some time debugging it, I noticed that Atmosphere builds an in-memory map for each consumer but, without this information https://github.com/apache/camel/pull/9210/files#diff-c20b148a113e2656ed364867af72660ee3204358f5ab036e1f4ac3c810f5c88fR62, the path, the logic in Atmosphere is not enough, and messages are redirected to the first entry of the map.', 'commenter': 'Croway'}, {'comment': 'Well done! Great news 🎆 ', 'commenter': 'essobedo'}]"
9210,docs/user-manual/modules/ROOT/pages/camel-4-migration-guide.adoc,"@@ -59,3 +59,7 @@ All the `camel-test` modules that were JUnit 4.x based has been removed. All tes
 === camel-caffeine
 
 The `keyType` parameter has been removed. The Key for the cache will now be only `String` type. More information in CAMEL-18877.
+
+=== camel-atmosphere-websocket
+
+The `useStreaming` parameter was renamed to `streaming`. More information in CAMEL-18978.","[{'comment': 'Could be removed', 'commenter': 'essobedo'}]"
9210,components/camel-jms/src/test/java/org/apache/camel/component/jms/JmsRequestReplyTempQueueMultipleConsumersTest.java,"@@ -45,7 +45,7 @@
 public class JmsRequestReplyTempQueueMultipleConsumersTest extends CamelTestSupport {
 
     @RegisterExtension
-    public ArtemisService service = ArtemisServiceFactory.createPersistentVMService();
+    public ArtemisService service = ArtemisServiceFactory.createVMService();","[{'comment': 'Is-this change required?', 'commenter': 'essobedo'}, {'comment': 'The test behave the same, the persistence part is not used anyway, the VMService is a little bit faster, but I can restore PersistentVM', 'commenter': 'Croway'}, {'comment': ""I think using the non-persistent service is fine on this case. I don't think the broker needs to persist messages in this scenario."", 'commenter': 'orpiske'}, {'comment': 'The question is more: is it an integration or a unit test? If it is a unit test, this change makes sense otherwise in the case of an integration test, it is better to keep the persistence even if it is faster.', 'commenter': 'essobedo'}, {'comment': 'This is a unit test. It is named as so (our integration tests are named as `*IT.java`).', 'commenter': 'orpiske'}]"
9233,components/camel-aws/camel-aws2-s3/src/main/java/org/apache/camel/component/aws2/s3/AWS2S3Producer.java,"@@ -562,7 +562,13 @@ private void listObjects(S3Client s3Client, Exchange exchange) throws InvalidPay
                 message.setBody(objectList.contents());
             }
         } else {
-            ListObjectsResponse objectList = s3Client.listObjects(ListObjectsRequest.builder().bucket(bucketName).build());
+            final ListObjectsRequest listObjectsRequest = ListObjectsRequest
+                    .builder()
+                    .bucket(bucketName)
+                    .delimiter(getConfiguration().getDelimiter())","[{'comment': ""I would add a guard to check if the delimiter is set on the configuration, same for the prefix, otherwise setting them on the request doesn't make sense. Also it would be a good idea to have a way to provide this parameter as headers, for being a bit more dynamic.\r\n\r\nYou need also to modify https://github.com/apache/camel/blob/main/components/camel-aws/camel-aws2-s3/src/main/java/org/apache/camel/component/aws2/s3/AWS2S3Configuration.java#L45-L48\r\n \r\nand remove the label consumer, since now they are common."", 'commenter': 'oscerd'}, {'comment': 'I did not checked if the delimiter and prefix are setted on the configuration because it already is null on the ListObjectsRequest builder and it will stay as null if is null on the configuration, but i can add the check to avoid an unecessary operation on the builder.\r\n\r\nAbout the need of go also to main, should i do a cherry-pick?', 'commenter': 'alexandredavi'}, {'comment': '> I did not checked if the delimiter and prefix are setted on the configuration because it already is null on the ListObjectsRequest builder and it will stay as null if is null on the configuration, but i can add the check to avoid an unecessary operation on the builder.\r\n> \r\n\r\nEffectively we are not checking even on the consumer side, so I would maintain the same behavior. So ignore my first review on that part.\r\n\r\n> About the need of go also to main, should i do a cherry-pick?\r\n\r\nYes, it should be straightforward I think.', 'commenter': 'oscerd'}]"
9294,components/camel-pubnub/src/main/java/org/apache/camel/component/pubnub/PubNubConsumer.java,"@@ -131,6 +138,41 @@ public void presence(PubNub pubnub, PNPresenceEventResult presence) {
             }
         }
 
+        @Override
+        public void signal(@NotNull PubNub pubnub, @NotNull PNSignalResult pnSignalResult) {
+            System.out.println(""A"");","[{'comment': 'Are you sure about this println?', 'commenter': 'oscerd'}, {'comment': 'ops!, not really :) anyway tests that are present in pubnub do not use these features', 'commenter': 'Croway'}]"
9295,components/camel-openapi-java/src/main/java/org/apache/camel/openapi/jmx/JmxRestDefinitionsResolver.java,"@@ -16,11 +16,8 @@
  */
 package org.apache.camel.openapi.jmx;
 
-import java.io.InputStream;
 import java.lang.management.ManagementFactory;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.Set;
+import java.util.*;","[{'comment': 'This will fail with sourcecheck profile.', 'commenter': 'oscerd'}]"
9295,core/camel-xml-io/src/main/java/org/apache/camel/xml/io/PrettyPrintXMLWriter.java,"@@ -0,0 +1,369 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.xml.io;
+
+import java.io.IOException;
+import java.io.Writer;
+import java.util.LinkedList;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+/**
+ * Implementation of XMLWriter which emits nicely formatted documents.
+ */
+public class PrettyPrintXMLWriter {
+    /**
+     * Line separator (""\n"" on UNIX)
+     */
+    protected static final String LS = System.getProperty(""line.separator"");","[{'comment': 'Minor thing, but `System.lineSeparator()` is a bit clearer', 'commenter': 'orpiske'}]"
9295,core/camel-xml-io/src/main/java/org/apache/camel/xml/io/PrettyPrintXMLWriter.java,"@@ -0,0 +1,369 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.xml.io;
+
+import java.io.IOException;
+import java.io.Writer;
+import java.util.LinkedList;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+/**
+ * Implementation of XMLWriter which emits nicely formatted documents.
+ */
+public class PrettyPrintXMLWriter {
+    /**
+     * Line separator (""\n"" on UNIX)
+     */
+    protected static final String LS = System.getProperty(""line.separator"");
+
+    private final Writer writer;
+    private final String lineIndenter;
+    private final String lineSeparator;
+    private final String encoding;
+    private final String docType;
+    private final LinkedList<String> elementStack = new LinkedList<>();","[{'comment': 'Maybe it would be better to use a List here, so to give more flexibility.', 'commenter': 'orpiske'}]"
9295,core/camel-xml-io/src/test/java/org/apache/camel/xml/out/ModelWriterTest.java,"@@ -0,0 +1,219 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.xml.out;
+
+import java.io.*;","[{'comment': 'This may fail the checkstyle check', 'commenter': 'orpiske'}]"
9295,core/camel-xml-io/src/test/java/org/apache/camel/xml/out/ModelWriterTest.java,"@@ -0,0 +1,219 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.xml.out;
+
+import java.io.*;
+import java.lang.reflect.Field;
+import java.lang.reflect.Method;
+import java.lang.reflect.Modifier;
+import java.nio.file.Files;
+import java.nio.file.Paths;
+import java.util.*;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.stream.Stream;
+
+import jakarta.xml.bind.annotation.XmlTransient;
+
+import org.apache.camel.model.RouteTemplatesDefinition;
+import org.apache.camel.model.RoutesDefinition;
+import org.apache.camel.model.TemplatedRoutesDefinition;
+import org.apache.camel.model.rest.RestsDefinition;
+import org.apache.camel.xml.in.ModelParser;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.Arguments;
+import org.junit.jupiter.params.provider.MethodSource;
+
+import static org.junit.jupiter.api.AssertionFailureBuilder.assertionFailure;
+import static org.junit.jupiter.api.Assertions.*;
+
+public class ModelWriterTest {
+
+    public static final String NAMESPACE = ""http://camel.apache.org/schema/spring"";
+
+    @ParameterizedTest
+    @MethodSource(""routes"")","[{'comment': 'Given that this code is doing something complex, I think it would be good to annotate it with `@Display` describing the expectations (i.e.: `@Display(""Tests that given an XML file containing X, will generate/process/something Y"")`)', 'commenter': 'orpiske'}]"
9295,core/camel-xml-io/src/test/java/org/apache/camel/xml/out/ModelWriterTest.java,"@@ -0,0 +1,219 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.xml.out;
+
+import java.io.*;
+import java.lang.reflect.Field;
+import java.lang.reflect.Method;
+import java.lang.reflect.Modifier;
+import java.nio.file.Files;
+import java.nio.file.Paths;
+import java.util.*;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.stream.Stream;
+
+import jakarta.xml.bind.annotation.XmlTransient;
+
+import org.apache.camel.model.RouteTemplatesDefinition;
+import org.apache.camel.model.RoutesDefinition;
+import org.apache.camel.model.TemplatedRoutesDefinition;
+import org.apache.camel.model.rest.RestsDefinition;
+import org.apache.camel.xml.in.ModelParser;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.Arguments;
+import org.junit.jupiter.params.provider.MethodSource;
+
+import static org.junit.jupiter.api.AssertionFailureBuilder.assertionFailure;
+import static org.junit.jupiter.api.Assertions.*;
+
+public class ModelWriterTest {
+
+    public static final String NAMESPACE = ""http://camel.apache.org/schema/spring"";
+
+    @ParameterizedTest
+    @MethodSource(""routes"")
+    void testRoutes(String xml, String ns) throws Exception {
+        try (InputStream is = getClass().getClassLoader().getResourceAsStream(xml)) {
+            RoutesDefinition expected = new ModelParser(is, NAMESPACE).parseRoutesDefinition().get();
+            StringWriter sw = new StringWriter();
+            new ModelWriter(sw, ns).writeRoutesDefinition(expected);
+            RoutesDefinition actual = new ModelParser(new StringReader(sw.toString()), ns).parseRoutesDefinition().get();
+            assertDeepEquals(expected, actual, sw.toString());
+        }
+    }
+
+    @ParameterizedTest
+    @MethodSource(""rests"")","[{'comment': 'Same suggestion about `@Display` here and on the other tests.', 'commenter': 'orpiske'}]"
9295,core/camel-xml-io/src/test/java/org/apache/camel/xml/out/ModelWriterTest.java,"@@ -0,0 +1,219 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.xml.out;
+
+import java.io.*;
+import java.lang.reflect.Field;
+import java.lang.reflect.Method;
+import java.lang.reflect.Modifier;
+import java.nio.file.Files;
+import java.nio.file.Paths;
+import java.util.*;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.stream.Stream;
+
+import jakarta.xml.bind.annotation.XmlTransient;
+
+import org.apache.camel.model.RouteTemplatesDefinition;
+import org.apache.camel.model.RoutesDefinition;
+import org.apache.camel.model.TemplatedRoutesDefinition;
+import org.apache.camel.model.rest.RestsDefinition;
+import org.apache.camel.xml.in.ModelParser;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.Arguments;
+import org.junit.jupiter.params.provider.MethodSource;
+
+import static org.junit.jupiter.api.AssertionFailureBuilder.assertionFailure;
+import static org.junit.jupiter.api.Assertions.*;
+
+public class ModelWriterTest {
+
+    public static final String NAMESPACE = ""http://camel.apache.org/schema/spring"";
+
+    @ParameterizedTest
+    @MethodSource(""routes"")
+    void testRoutes(String xml, String ns) throws Exception {
+        try (InputStream is = getClass().getClassLoader().getResourceAsStream(xml)) {
+            RoutesDefinition expected = new ModelParser(is, NAMESPACE).parseRoutesDefinition().get();
+            StringWriter sw = new StringWriter();
+            new ModelWriter(sw, ns).writeRoutesDefinition(expected);
+            RoutesDefinition actual = new ModelParser(new StringReader(sw.toString()), ns).parseRoutesDefinition().get();
+            assertDeepEquals(expected, actual, sw.toString());
+        }
+    }
+
+    @ParameterizedTest
+    @MethodSource(""rests"")
+    void testRests(String xml, String ns) throws Exception {
+        try (InputStream is = getClass().getClassLoader().getResourceAsStream(xml)) {
+            RestsDefinition expected = new ModelParser(is, NAMESPACE).parseRestsDefinition().get();
+            StringWriter sw = new StringWriter();
+            new ModelWriter(sw, ns).writeRestsDefinition(expected);
+            RestsDefinition actual = new ModelParser(new StringReader(sw.toString()), ns).parseRestsDefinition().get();
+            assertDeepEquals(expected, actual, sw.toString());
+        }
+    }
+
+    @ParameterizedTest
+    @MethodSource(""routeTemplates"")
+    void testRouteTemplates(String xml, String ns) throws Exception {
+        try (InputStream is = getClass().getClassLoader().getResourceAsStream(xml)) {
+            RouteTemplatesDefinition expected = new ModelParser(is, NAMESPACE).parseRouteTemplatesDefinition().get();
+            StringWriter sw = new StringWriter();
+            new ModelWriter(sw, ns).writeRouteTemplatesDefinition(expected);
+            RouteTemplatesDefinition actual
+                    = new ModelParser(new StringReader(sw.toString()), ns).parseRouteTemplatesDefinition().get();
+            assertDeepEquals(expected, actual, sw.toString());
+        }
+    }
+
+    @ParameterizedTest
+    @MethodSource(""templatedRoutes"")
+    void testTemplatedRoutes(String xml, String ns) throws Exception {
+        try (InputStream is = getClass().getClassLoader().getResourceAsStream(xml)) {
+            TemplatedRoutesDefinition expected = new ModelParser(is, NAMESPACE).parseTemplatedRoutesDefinition().get();
+            StringWriter sw = new StringWriter();
+            new ModelWriter(sw, ns).writeTemplatedRoutesDefinition(expected);
+            TemplatedRoutesDefinition actual
+                    = new ModelParser(new StringReader(sw.toString()), ns).parseTemplatedRoutesDefinition().get();
+            assertDeepEquals(expected, actual, sw.toString());
+        }
+    }
+
+    private static Stream<Arguments> routes() {
+        return definitions(""routes"");
+    }
+
+    private static Stream<Arguments> rests() {
+        return definitions(""rests"");
+    }
+
+    private static Stream<Arguments> routeTemplates() {
+        return definitions(""routeTemplates"");
+    }
+
+    private static Stream<Arguments> templatedRoutes() {
+        return definitions(""templatedRoutes"");
+    }
+
+    private static Stream<Arguments> definitions(String xml) {
+        try {
+            return Files.list(Paths.get(""src/test/resources""))
+                    .filter(p -> {
+                        try {
+                            return Files.isRegularFile(p)
+                                    && p.getFileName().toString().endsWith("".xml"")
+                                    && Files.readString(p).contains(""<"" + xml);
+                        } catch (IOException e) {
+                            throw new IOError(e);
+                        }
+                    })
+                    .map(p -> p.getFileName().toString())
+                    .flatMap(p -> Stream.of(Arguments.of(p, """"), Arguments.of(p, NAMESPACE)));
+        } catch (IOException e) {
+            throw new IOError(e);
+        }
+    }
+
+    private static void assertDeepEquals(Object expected, Object actual, String message) {
+        try {
+            try {
+                deepEquals(expected, actual, """");
+            } catch (AssertionError e) {
+                assertionFailure() //
+                        .cause(e)
+                        .message(message) //
+                        .expected(expected) //
+                        .actual(actual) //
+                        .buildAndThrow();
+            }
+        } catch (IllegalAccessException e) {
+            assertionFailure().cause(e).buildAndThrow();
+        }
+    }
+
+    private static void deepEquals(Object expected, Object actual, String path) throws IllegalAccessException {
+        if (expected == null || actual == null) {
+            assertSame(expected, actual, path);
+        } else if (expected.getClass() != actual.getClass()) {
+            fail(""Not equals at "" + path);
+        } else if (expected instanceof Collection) {
+            Iterator<?> ie = ((Collection) expected).iterator();
+            Iterator<?> ia = ((Collection) actual).iterator();
+            int i = 0;
+            while (ie.hasNext() && ia.hasNext()) {
+                deepEquals(ie.next(), ia.next(), path + ""["" + (i++) + ""]"");
+            }
+            assertEquals(ie.hasNext(), ia.hasNext(), path);
+        } else if (expected.getClass() == AtomicBoolean.class) {
+            assertEquals(((AtomicBoolean) expected).get(), ((AtomicBoolean) actual).get(), path);
+        } else if (expected.getClass().isEnum()) {
+            assertEquals(((Enum) expected).name(), ((Enum) actual).name(), path);
+        } else if (expected.getClass().getName().startsWith(""java."")) {
+            assertEquals(expected, actual, path);
+        } else {
+            for (Class<?> clazz = expected.getClass(); clazz != Object.class; clazz = clazz.getSuperclass()) {
+                for (Field field : clazz.getDeclaredFields()) {
+                    if (isTransient(field)) {
+                        continue;
+                    }
+                    field.setAccessible(true);
+                    Object fe = field.get(expected);
+                    Object fa = field.get(actual);
+                    deepEquals(fe, fa, (path.length() > 0 ? path + ""."" : path) + field.getName());
+                }
+            }
+        }
+    }
+
+    private static Map<Field, Boolean> TRANSIENT = new ConcurrentHashMap<>();
+
+    private static boolean isTransient(Field field) {
+        return TRANSIENT.computeIfAbsent(field, ModelWriterTest::checkIsTransient);
+    }
+
+    private static boolean checkIsTransient(Field field) {
+        if (Modifier.isStatic(field.getModifiers())) {
+            return true;
+        }
+        if (field.getAnnotation(XmlTransient.class) != null) {
+            return true;
+        }
+        String name = field.getName();
+        try {
+            Method method = field.getDeclaringClass().getDeclaredMethod(
+                    ""get"" + name.substring(0, 1).toUpperCase() + name.substring(1));
+            if (method.getAnnotation(XmlTransient.class) != null) {
+                return true;
+            }
+        } catch (Throwable t) {
+            // ignore
+        }","[{'comment': 'We should not catch `Throwable`. This would also catch JVM errors (such as OOME) and could hide some serious problems. In general, catching just Exception should be fine. ', 'commenter': 'orpiske'}]"
9295,core/camel-xml-io/src/test/java/org/apache/camel/xml/out/ModelWriterTest.java,"@@ -0,0 +1,219 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.xml.out;
+
+import java.io.*;
+import java.lang.reflect.Field;
+import java.lang.reflect.Method;
+import java.lang.reflect.Modifier;
+import java.nio.file.Files;
+import java.nio.file.Paths;
+import java.util.*;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.stream.Stream;
+
+import jakarta.xml.bind.annotation.XmlTransient;
+
+import org.apache.camel.model.RouteTemplatesDefinition;
+import org.apache.camel.model.RoutesDefinition;
+import org.apache.camel.model.TemplatedRoutesDefinition;
+import org.apache.camel.model.rest.RestsDefinition;
+import org.apache.camel.xml.in.ModelParser;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.Arguments;
+import org.junit.jupiter.params.provider.MethodSource;
+
+import static org.junit.jupiter.api.AssertionFailureBuilder.assertionFailure;
+import static org.junit.jupiter.api.Assertions.*;
+
+public class ModelWriterTest {
+
+    public static final String NAMESPACE = ""http://camel.apache.org/schema/spring"";
+
+    @ParameterizedTest
+    @MethodSource(""routes"")
+    void testRoutes(String xml, String ns) throws Exception {
+        try (InputStream is = getClass().getClassLoader().getResourceAsStream(xml)) {
+            RoutesDefinition expected = new ModelParser(is, NAMESPACE).parseRoutesDefinition().get();
+            StringWriter sw = new StringWriter();
+            new ModelWriter(sw, ns).writeRoutesDefinition(expected);
+            RoutesDefinition actual = new ModelParser(new StringReader(sw.toString()), ns).parseRoutesDefinition().get();
+            assertDeepEquals(expected, actual, sw.toString());
+        }
+    }
+
+    @ParameterizedTest
+    @MethodSource(""rests"")
+    void testRests(String xml, String ns) throws Exception {
+        try (InputStream is = getClass().getClassLoader().getResourceAsStream(xml)) {
+            RestsDefinition expected = new ModelParser(is, NAMESPACE).parseRestsDefinition().get();
+            StringWriter sw = new StringWriter();
+            new ModelWriter(sw, ns).writeRestsDefinition(expected);
+            RestsDefinition actual = new ModelParser(new StringReader(sw.toString()), ns).parseRestsDefinition().get();
+            assertDeepEquals(expected, actual, sw.toString());
+        }
+    }
+
+    @ParameterizedTest
+    @MethodSource(""routeTemplates"")
+    void testRouteTemplates(String xml, String ns) throws Exception {
+        try (InputStream is = getClass().getClassLoader().getResourceAsStream(xml)) {
+            RouteTemplatesDefinition expected = new ModelParser(is, NAMESPACE).parseRouteTemplatesDefinition().get();
+            StringWriter sw = new StringWriter();
+            new ModelWriter(sw, ns).writeRouteTemplatesDefinition(expected);
+            RouteTemplatesDefinition actual
+                    = new ModelParser(new StringReader(sw.toString()), ns).parseRouteTemplatesDefinition().get();
+            assertDeepEquals(expected, actual, sw.toString());
+        }
+    }
+
+    @ParameterizedTest
+    @MethodSource(""templatedRoutes"")
+    void testTemplatedRoutes(String xml, String ns) throws Exception {
+        try (InputStream is = getClass().getClassLoader().getResourceAsStream(xml)) {
+            TemplatedRoutesDefinition expected = new ModelParser(is, NAMESPACE).parseTemplatedRoutesDefinition().get();
+            StringWriter sw = new StringWriter();
+            new ModelWriter(sw, ns).writeTemplatedRoutesDefinition(expected);
+            TemplatedRoutesDefinition actual
+                    = new ModelParser(new StringReader(sw.toString()), ns).parseTemplatedRoutesDefinition().get();
+            assertDeepEquals(expected, actual, sw.toString());
+        }
+    }
+
+    private static Stream<Arguments> routes() {
+        return definitions(""routes"");
+    }
+
+    private static Stream<Arguments> rests() {
+        return definitions(""rests"");
+    }
+
+    private static Stream<Arguments> routeTemplates() {
+        return definitions(""routeTemplates"");
+    }
+
+    private static Stream<Arguments> templatedRoutes() {
+        return definitions(""templatedRoutes"");
+    }
+
+    private static Stream<Arguments> definitions(String xml) {
+        try {
+            return Files.list(Paths.get(""src/test/resources""))
+                    .filter(p -> {
+                        try {
+                            return Files.isRegularFile(p)
+                                    && p.getFileName().toString().endsWith("".xml"")
+                                    && Files.readString(p).contains(""<"" + xml);
+                        } catch (IOException e) {
+                            throw new IOError(e);
+                        }
+                    })
+                    .map(p -> p.getFileName().toString())
+                    .flatMap(p -> Stream.of(Arguments.of(p, """"), Arguments.of(p, NAMESPACE)));
+        } catch (IOException e) {
+            throw new IOError(e);
+        }
+    }
+
+    private static void assertDeepEquals(Object expected, Object actual, String message) {
+        try {
+            try {
+                deepEquals(expected, actual, """");
+            } catch (AssertionError e) {
+                assertionFailure() //
+                        .cause(e)
+                        .message(message) //
+                        .expected(expected) //
+                        .actual(actual) //
+                        .buildAndThrow();
+            }
+        } catch (IllegalAccessException e) {
+            assertionFailure().cause(e).buildAndThrow();
+        }
+    }
+
+    private static void deepEquals(Object expected, Object actual, String path) throws IllegalAccessException {
+        if (expected == null || actual == null) {
+            assertSame(expected, actual, path);
+        } else if (expected.getClass() != actual.getClass()) {
+            fail(""Not equals at "" + path);
+        } else if (expected instanceof Collection) {
+            Iterator<?> ie = ((Collection) expected).iterator();
+            Iterator<?> ia = ((Collection) actual).iterator();
+            int i = 0;
+            while (ie.hasNext() && ia.hasNext()) {
+                deepEquals(ie.next(), ia.next(), path + ""["" + (i++) + ""]"");
+            }
+            assertEquals(ie.hasNext(), ia.hasNext(), path);
+        } else if (expected.getClass() == AtomicBoolean.class) {
+            assertEquals(((AtomicBoolean) expected).get(), ((AtomicBoolean) actual).get(), path);
+        } else if (expected.getClass().isEnum()) {
+            assertEquals(((Enum) expected).name(), ((Enum) actual).name(), path);
+        } else if (expected.getClass().getName().startsWith(""java."")) {
+            assertEquals(expected, actual, path);
+        } else {
+            for (Class<?> clazz = expected.getClass(); clazz != Object.class; clazz = clazz.getSuperclass()) {
+                for (Field field : clazz.getDeclaredFields()) {
+                    if (isTransient(field)) {
+                        continue;
+                    }
+                    field.setAccessible(true);
+                    Object fe = field.get(expected);
+                    Object fa = field.get(actual);
+                    deepEquals(fe, fa, (path.length() > 0 ? path + ""."" : path) + field.getName());
+                }
+            }
+        }
+    }
+
+    private static Map<Field, Boolean> TRANSIENT = new ConcurrentHashMap<>();
+
+    private static boolean isTransient(Field field) {
+        return TRANSIENT.computeIfAbsent(field, ModelWriterTest::checkIsTransient);
+    }
+
+    private static boolean checkIsTransient(Field field) {
+        if (Modifier.isStatic(field.getModifiers())) {
+            return true;
+        }
+        if (field.getAnnotation(XmlTransient.class) != null) {
+            return true;
+        }
+        String name = field.getName();
+        try {
+            Method method = field.getDeclaringClass().getDeclaredMethod(
+                    ""get"" + name.substring(0, 1).toUpperCase() + name.substring(1));
+            if (method.getAnnotation(XmlTransient.class) != null) {
+                return true;
+            }
+        } catch (Throwable t) {
+            // ignore
+        }
+        try {
+            Method method = field.getDeclaringClass().getDeclaredMethod(
+                    ""set"" + name.substring(0, 1).toUpperCase() + name.substring(1),
+                    field.getType());
+            if (method.getAnnotation(XmlTransient.class) != null) {
+                return true;
+            }
+        } catch (Throwable t) {","[{'comment': 'Same note about catching `Throwable`', 'commenter': 'orpiske'}]"
9332,core/camel-core/src/test/java/org/apache/camel/builder/ExpressionBuilderConcurrencyTest.java,"@@ -0,0 +1,106 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.builder;
+
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import org.apache.camel.ContextTestSupport;
+import org.apache.camel.Exchange;
+import org.apache.camel.Processor;
+import org.apache.camel.component.mock.MockEndpoint;
+import org.apache.camel.model.language.SimpleExpression;
+import org.junit.jupiter.api.Assertions;
+import org.junit.jupiter.api.Test;
+
+public class ExpressionBuilderConcurrencyTest extends ContextTestSupport {
+
+    @Test
+    public void testConcatExpressionConcurrency() throws Exception {
+        MockEndpoint mockWithFailure = getMockEndpoint(""mock:result"");
+        mockWithFailure.expectedMessageCount(102);
+        mockWithFailure.assertIsSatisfied();
+        //assertMockEndpointsSatisfied();","[{'comment': 'Could be removed', 'commenter': 'essobedo'}]"
9332,core/camel-core/src/test/java/org/apache/camel/builder/ExpressionBuilderConcurrencyTest.java,"@@ -0,0 +1,106 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.builder;
+
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import org.apache.camel.ContextTestSupport;
+import org.apache.camel.Exchange;
+import org.apache.camel.Processor;
+import org.apache.camel.component.mock.MockEndpoint;
+import org.apache.camel.model.language.SimpleExpression;
+import org.junit.jupiter.api.Assertions;
+import org.junit.jupiter.api.Test;
+
+public class ExpressionBuilderConcurrencyTest extends ContextTestSupport {
+
+    @Test
+    public void testConcatExpressionConcurrency() throws Exception {
+        MockEndpoint mockWithFailure = getMockEndpoint(""mock:result"");
+        mockWithFailure.expectedMessageCount(102);
+        mockWithFailure.assertIsSatisfied();
+        //assertMockEndpointsSatisfied();
+        List<Exchange> exchanges = mockWithFailure.getExchanges();
+        exchanges.stream()
+                .forEach(exchange -> Assertions.assertTrue(exchange.getMessage()
+                        .getHeader(""#CustomHeader"", String.class)
+                        .equals(""This is a test a with startLabel: `Document` endLabel: `Document` and label: `ALabel`"")));","[{'comment': 'For clarity, it should rather be a simple `for` loop. Moreover, please use `assertEquals` instead.', 'commenter': 'essobedo'}]"
9332,core/camel-core/src/test/java/org/apache/camel/builder/ExpressionBuilderConcurrencyTest.java,"@@ -0,0 +1,106 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.builder;
+
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import org.apache.camel.ContextTestSupport;
+import org.apache.camel.Exchange;
+import org.apache.camel.Processor;
+import org.apache.camel.component.mock.MockEndpoint;
+import org.apache.camel.model.language.SimpleExpression;
+import org.junit.jupiter.api.Assertions;
+import org.junit.jupiter.api.Test;
+
+public class ExpressionBuilderConcurrencyTest extends ContextTestSupport {
+
+    @Test
+    public void testConcatExpressionConcurrency() throws Exception {
+        MockEndpoint mockWithFailure = getMockEndpoint(""mock:result"");
+        mockWithFailure.expectedMessageCount(102);","[{'comment': ""Let's put `100` to avoid making it sound like a magic number"", 'commenter': 'essobedo'}]"
9332,core/camel-core/src/test/java/org/apache/camel/builder/ExpressionBuilderConcurrencyTest.java,"@@ -0,0 +1,106 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.builder;
+
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import org.apache.camel.ContextTestSupport;
+import org.apache.camel.Exchange;
+import org.apache.camel.Processor;
+import org.apache.camel.component.mock.MockEndpoint;
+import org.apache.camel.model.language.SimpleExpression;
+import org.junit.jupiter.api.Assertions;
+import org.junit.jupiter.api.Test;
+
+public class ExpressionBuilderConcurrencyTest extends ContextTestSupport {
+
+    @Test
+    public void testConcatExpressionConcurrency() throws Exception {
+        MockEndpoint mockWithFailure = getMockEndpoint(""mock:result"");
+        mockWithFailure.expectedMessageCount(102);
+        mockWithFailure.assertIsSatisfied();
+        //assertMockEndpointsSatisfied();
+        List<Exchange> exchanges = mockWithFailure.getExchanges();
+        exchanges.stream()
+                .forEach(exchange -> Assertions.assertTrue(exchange.getMessage()
+                        .getHeader(""#CustomHeader"", String.class)
+                        .equals(""This is a test a with startLabel: `Document` endLabel: `Document` and label: `ALabel`"")));
+    }
+
+    @Override
+    protected RouteBuilder createRouteBuilder() throws Exception {
+
+        return new RouteBuilder() {
+            Map body = new HashMap() {
+                {
+                    put(""label"", ""ALabel"");
+                    put(""startLabel"", ""Document"");
+                    put(""endLabel"", ""Document"");
+                }
+            };","[{'comment': 'Let\'s use, `Map.of(""label"", ""ALabel"", ""startLabel"", ""Document"", ""endLabel"", ""Document"")` instead', 'commenter': 'essobedo'}, {'comment': 'Done!', 'commenter': 'rhuan080'}]"
9332,core/camel-support/src/main/java/org/apache/camel/support/builder/ExpressionBuilder.java,"@@ -1577,74 +1578,122 @@ public String toString() {
      * Returns an expression which returns the string concatenation value of the various
      * expressions
      *
+     * @param context the Camel context
      * @param expressions the expression to be concatenated dynamically
      * @return an expression which when evaluated will return the concatenated values
      */
-    public static Expression concatExpression(final Collection<Expression> expressions) {
-        return concatExpression(expressions, null);
+    public static Expression concatExpression(final CamelContext context, final Collection<Expression> expressions) {
+        return concatExpression(context, expressions, null);
     }
 
     /**
      * Returns an expression which returns the string concatenation value of the various
      * expressions
      *
+     * @param context the Camel context
      * @param expressions the expression to be concatenated dynamically
      * @param description the text description of the expression
      * @return an expression which when evaluated will return the concatenated values
      */
-    public static Expression concatExpression(final Collection<Expression> expressions, final String description) {
-        return new ExpressionAdapter() {
+    public static Expression concatExpression(final CamelContext context, final Collection<Expression> expressions, final String description) {
+
+        for (Expression expression : expressions) {
+            if(expression instanceof ConstantExpressionAdapter){
+                return concatExpressionOptimized(context, expressions, description);
+            }
+        }
 
-            private Collection<Object> col;
+        return concatExpression(expressions,description);
+    }
+
+    /**
+     * Returns an expression which returns the string concatenation value of the various
+     * expressions
+     *
+     * @param expressions the expression to be concatenated dynamically
+     * @param description the text description of the expression
+     * @return an expression which when evaluated will return the concatenated values
+     */
+    private static Expression concatExpression(final Collection<Expression> expressions, final String description) {
+        return new ExpressionAdapter() {
 
             @Override
             public Object evaluate(Exchange exchange) {
                 StringBuilder buffer = new StringBuilder();
-                if (col != null) {
-                    // optimize for constant expressions so we can do this a bit faster
-                    for (Object obj : col) {
-                        if (obj instanceof Expression) {
-                            Expression expression = (Expression) obj;
-                            String text = expression.evaluate(exchange, String.class);
-                            if (text != null) {
-                                buffer.append(text);
-                            }
-                        } else {
-                            buffer.append((String) obj);
-                        }
+                for (Expression expression : expressions) {
+                    String text = expression.evaluate(exchange, String.class);
+                    if (text != null) {
+                        buffer.append(text);
                     }
+                }
+                return buffer.toString();
+            }
+
+            @Override
+            public void init(CamelContext context) {
+                boolean constant = false;","[{'comment': 'Not needed', 'commenter': 'essobedo'}]"
9332,core/camel-support/src/main/java/org/apache/camel/support/builder/ExpressionBuilder.java,"@@ -1577,74 +1578,122 @@ public String toString() {
      * Returns an expression which returns the string concatenation value of the various
      * expressions
      *
+     * @param context the Camel context
      * @param expressions the expression to be concatenated dynamically
      * @return an expression which when evaluated will return the concatenated values
      */
-    public static Expression concatExpression(final Collection<Expression> expressions) {
-        return concatExpression(expressions, null);
+    public static Expression concatExpression(final CamelContext context, final Collection<Expression> expressions) {
+        return concatExpression(context, expressions, null);
     }
 
     /**
      * Returns an expression which returns the string concatenation value of the various
      * expressions
      *
+     * @param context the Camel context
      * @param expressions the expression to be concatenated dynamically
      * @param description the text description of the expression
      * @return an expression which when evaluated will return the concatenated values
      */
-    public static Expression concatExpression(final Collection<Expression> expressions, final String description) {
-        return new ExpressionAdapter() {
+    public static Expression concatExpression(final CamelContext context, final Collection<Expression> expressions, final String description) {
+
+        for (Expression expression : expressions) {
+            if(expression instanceof ConstantExpressionAdapter){
+                return concatExpressionOptimized(context, expressions, description);
+            }
+        }
 
-            private Collection<Object> col;
+        return concatExpression(expressions,description);
+    }
+
+    /**
+     * Returns an expression which returns the string concatenation value of the various
+     * expressions
+     *
+     * @param expressions the expression to be concatenated dynamically
+     * @param description the text description of the expression
+     * @return an expression which when evaluated will return the concatenated values
+     */
+    private static Expression concatExpression(final Collection<Expression> expressions, final String description) {
+        return new ExpressionAdapter() {
 
             @Override
             public Object evaluate(Exchange exchange) {
                 StringBuilder buffer = new StringBuilder();
-                if (col != null) {
-                    // optimize for constant expressions so we can do this a bit faster
-                    for (Object obj : col) {
-                        if (obj instanceof Expression) {
-                            Expression expression = (Expression) obj;
-                            String text = expression.evaluate(exchange, String.class);
-                            if (text != null) {
-                                buffer.append(text);
-                            }
-                        } else {
-                            buffer.append((String) obj);
-                        }
+                for (Expression expression : expressions) {
+                    String text = expression.evaluate(exchange, String.class);
+                    if (text != null) {
+                        buffer.append(text);
                     }
+                }
+                return buffer.toString();
+            }
+
+            @Override
+            public void init(CamelContext context) {
+                boolean constant = false;
+                for (Expression expression : expressions) {
+                    expression.init(context);
+                }
+            }
+
+            @Override
+            public String toString() {
+                if (description != null) {
+                    return description;
                 } else {
-                    for (Expression expression : expressions) {
+                    return ""concat("" + expressions + "")"";
+                }
+            }
+        };
+    }
+
+    /**
+     * Returns an optimized expression which returns the string concatenation value of the various.
+     * expressions
+     *
+     * @param context the Camel context
+     * @param expressions the expression to be concatenated dynamically
+     * @param description the text description of the expression
+     * @return an expression which when evaluated will return the concatenated values
+     */
+    private static Expression concatExpressionOptimized(final CamelContext context, final Collection<Expression> expressions, final String description) {
+        Collection<Object> preprocessedExpression = new ArrayList<>(expressions.size());
+        for (Expression expression : expressions) {
+            if (expression instanceof ConstantExpressionAdapter) {
+                expression.init(context);","[{'comment': ""I did not realize that for some `ConstantExpressionAdapter` we had to initialize it first to get its value, I don't know if it is acceptable to call `init` so early? @oscerd WDYT?\r\n\r\nIf it is not acceptable, the other way could be to use a volatile boolean field to know if the expression has been initialized or not and use the Double-checked locking approach to ensure that it is initialized once. Even if it adds a locking mechanism it is only during the initialization phase which happens only once per expression when properly used so the overhead is limited."", 'commenter': 'essobedo'}, {'comment': 'Hi @essobedo, Looking at the `ConstantExpression`, I think that calling the `init` so early is not a problem. Waiting for the @oscerd to confirm it for us. \r\n\r\nAbout the lock, the problem is the `evaluate` method being called concurrently with the `init`calling.  Thus, I think the lock should be put at the `evaluate` method as well. However, we came back to the penalty we said before.', 'commenter': 'rhuan080'}, {'comment': '> About the lock, the problem is the `evaluate` method being called concurrently with the `init`calling. Thus, I think the lock should be put at the `evaluate` method as well. However, we came back to the penalty we said before.\r\n\r\nTo be thread-safe, we have to consider the state changes and the visibility of those changes. Here only the `init` method affects the state and the `init` method is always called before `evaluate` so applying a double-check locking approach in the `init` method is good enough as it ensures that the state is changed only once at the very first call and that all threads thanks to a volatile read or synchronized block will always have the right state before calling `evaluate`. I hope it is clear enough.\r\n\r\n', 'commenter': 'essobedo'}]"
9332,core/camel-support/src/main/java/org/apache/camel/support/builder/ExpressionBuilder.java,"@@ -1577,74 +1578,122 @@ public String toString() {
      * Returns an expression which returns the string concatenation value of the various
      * expressions
      *
+     * @param context the Camel context
      * @param expressions the expression to be concatenated dynamically
      * @return an expression which when evaluated will return the concatenated values
      */
-    public static Expression concatExpression(final Collection<Expression> expressions) {
-        return concatExpression(expressions, null);
+    public static Expression concatExpression(final CamelContext context, final Collection<Expression> expressions) {
+        return concatExpression(context, expressions, null);
     }
 
     /**
      * Returns an expression which returns the string concatenation value of the various
      * expressions
      *
+     * @param context the Camel context
      * @param expressions the expression to be concatenated dynamically
      * @param description the text description of the expression
      * @return an expression which when evaluated will return the concatenated values
      */
-    public static Expression concatExpression(final Collection<Expression> expressions, final String description) {
-        return new ExpressionAdapter() {
+    public static Expression concatExpression(final CamelContext context, final Collection<Expression> expressions, final String description) {
+
+        for (Expression expression : expressions) {
+            if(expression instanceof ConstantExpressionAdapter){
+                return concatExpressionOptimized(context, expressions, description);
+            }
+        }
 
-            private Collection<Object> col;
+        return concatExpression(expressions,description);
+    }
+
+    /**
+     * Returns an expression which returns the string concatenation value of the various
+     * expressions
+     *
+     * @param expressions the expression to be concatenated dynamically
+     * @param description the text description of the expression
+     * @return an expression which when evaluated will return the concatenated values
+     */
+    private static Expression concatExpression(final Collection<Expression> expressions, final String description) {
+        return new ExpressionAdapter() {
 
             @Override
             public Object evaluate(Exchange exchange) {
                 StringBuilder buffer = new StringBuilder();
-                if (col != null) {
-                    // optimize for constant expressions so we can do this a bit faster
-                    for (Object obj : col) {
-                        if (obj instanceof Expression) {
-                            Expression expression = (Expression) obj;
-                            String text = expression.evaluate(exchange, String.class);
-                            if (text != null) {
-                                buffer.append(text);
-                            }
-                        } else {
-                            buffer.append((String) obj);
-                        }
+                for (Expression expression : expressions) {
+                    String text = expression.evaluate(exchange, String.class);
+                    if (text != null) {
+                        buffer.append(text);
                     }
+                }
+                return buffer.toString();
+            }
+
+            @Override
+            public void init(CamelContext context) {
+                boolean constant = false;
+                for (Expression expression : expressions) {
+                    expression.init(context);
+                }
+            }
+
+            @Override
+            public String toString() {
+                if (description != null) {
+                    return description;
                 } else {
-                    for (Expression expression : expressions) {
+                    return ""concat("" + expressions + "")"";
+                }
+            }
+        };
+    }
+
+    /**
+     * Returns an optimized expression which returns the string concatenation value of the various.
+     * expressions
+     *
+     * @param context the Camel context
+     * @param expressions the expression to be concatenated dynamically
+     * @param description the text description of the expression
+     * @return an expression which when evaluated will return the concatenated values
+     */
+    private static Expression concatExpressionOptimized(final CamelContext context, final Collection<Expression> expressions, final String description) {
+        Collection<Object> preprocessedExpression = new ArrayList<>(expressions.size());
+        for (Expression expression : expressions) {
+            if (expression instanceof ConstantExpressionAdapter) {
+                expression.init(context);
+                Object value = ((ConstantExpressionAdapter) expression).getValue();
+                preprocessedExpression.add(value.toString());
+            } else {
+                preprocessedExpression.add(expression);
+            }
+        }
+
+        return new ExpressionAdapter() {
+
+            private final Collection<Object> col = Collections.unmodifiableCollection(preprocessedExpression);
+
+            @Override
+            public Object evaluate(Exchange exchange) {
+                StringBuilder buffer = new StringBuilder();
+                for (Object obj : col) {
+                    if (obj instanceof Expression) {
+                        Expression expression = (Expression) obj;
                         String text = expression.evaluate(exchange, String.class);
                         if (text != null) {
                             buffer.append(text);
                         }
+                    } else {
+                        buffer.append((String) obj);
                     }
                 }
                 return buffer.toString();
             }
 
             @Override
             public void init(CamelContext context) {
-                boolean constant = false;
                 for (Expression expression : expressions) {
                     expression.init(context);","[{'comment': 'Assuming that it is acceptable to call `init` when creating the expression, we could avoid calling init on expressions of type `ConstantExpressionAdapter` as they are already initialized', 'commenter': 'essobedo'}]"
9332,core/camel-support/src/main/java/org/apache/camel/support/builder/ExpressionBuilder.java,"@@ -1593,59 +1594,109 @@ public static Expression concatExpression(final Collection<Expression> expressio
      * @return an expression which when evaluated will return the concatenated values
      */
     public static Expression concatExpression(final Collection<Expression> expressions, final String description) {
-        return new ExpressionAdapter() {
 
-            private Collection<Object> col;
+        for (Expression expression : expressions) {
+            if(expression instanceof ConstantExpressionAdapter){
+                return concatExpressionOptimized(expressions, description);
+            }
+        }
+
+        return concatExpressionUnoptimized(expressions,description);
+    }
+
+    /**
+     * Returns an expression which returns the string concatenation value of the various
+     * expressions
+     *
+     * @param expressions the expression to be concatenated dynamically
+     * @param description the text description of the expression
+     * @return an expression which when evaluated will return the concatenated values
+     */
+    private static Expression concatExpressionUnoptimized(final Collection<Expression> expressions, final String description) {
+        return new ExpressionAdapter() {
 
             @Override
             public Object evaluate(Exchange exchange) {
                 StringBuilder buffer = new StringBuilder();
-                if (col != null) {
-                    // optimize for constant expressions so we can do this a bit faster
-                    for (Object obj : col) {
-                        if (obj instanceof Expression) {
-                            Expression expression = (Expression) obj;
-                            String text = expression.evaluate(exchange, String.class);
-                            if (text != null) {
-                                buffer.append(text);
-                            }
-                        } else {
-                            buffer.append((String) obj);
-                        }
+                for (Expression expression : expressions) {
+                    String text = expression.evaluate(exchange, String.class);
+                    if (text != null) {
+                        buffer.append(text);
                     }
+                }
+                return buffer.toString();
+            }
+
+            @Override
+            public void init(CamelContext context) {
+                for (Expression expression : expressions) {
+                    expression.init(context);
+                }
+            }
+
+            @Override
+            public String toString() {
+                if (description != null) {
+                    return description;
                 } else {
-                    for (Expression expression : expressions) {
+                    return ""concat("" + expressions + "")"";
+                }
+            }
+        };
+    }
+
+    /**
+     * Returns an optimized expression which returns the string concatenation value of the various.
+     * expressions
+     *
+     * @param expressions the expression to be concatenated dynamically
+     * @param description the text description of the expression
+     * @return an expression which when evaluated will return the concatenated values
+     */
+    private static Expression concatExpressionOptimized(final Collection<Expression> expressions, final String description) {
+
+
+        return new ExpressionAdapter() {
+
+            private Collection<Object> col;
+
+            @Override
+            public Object evaluate(Exchange exchange) {
+                StringBuilder buffer = new StringBuilder();
+                for (Object obj : col) {
+                    if (obj instanceof Expression) {
+                        Expression expression = (Expression) obj;
                         String text = expression.evaluate(exchange, String.class);
                         if (text != null) {
                             buffer.append(text);
                         }
+                    } else {
+                        buffer.append((String) obj);
                     }
                 }
                 return buffer.toString();
             }
 
             @Override
             public void init(CamelContext context) {
-                boolean constant = false;
                 for (Expression expression : expressions) {
                     expression.init(context);
-                    constant |= expression instanceof ConstantExpressionAdapter;
                 }
-                if (constant) {
-                    // okay some of the expressions are constant so we can optimize and avoid
-                    // evaluate them but use their constant value as-is directly
-                    // this can be common with the simple language where you use it for templating
-                    // by mixing string text and simple functions together (or via the log EIP)
-                    col = new ArrayList<>(expressions.size());
+
+                if(col == null) {
+                    Collection<Object> preprocessedExpression = new ArrayList<>(expressions.size());
                     for (Expression expression : expressions) {
                         if (expression instanceof ConstantExpressionAdapter) {
+                            expression.init(context);","[{'comment': ""it's already initialized so it is not needed"", 'commenter': 'essobedo'}, {'comment': ""My fault. I'm sorry. Fixed. "", 'commenter': 'rhuan080'}]"
9339,components/camel-aws/camel-aws2-kinesis/src/main/java/org/apache/camel/component/aws2/kinesis/consumer/KinesisDefaultResumeAdapter.java,"@@ -46,8 +47,8 @@ public void setRequestBuilder(GetShardIteratorRequest.Builder resumable) {
 
     @Override
     public void resume() {
-        assert streamName != null;
-        assert resumable != null;","[{'comment': ""Using Java's assert is the correct away to assert for nullity in non-public code as is the case here (obs.: the code is internally public, but not public in the to Camel users).  "", 'commenter': 'orpiske'}, {'comment': ""Thanks for your feedback.\r\n\r\nIMHO no matter if it's about a user-facing pubic or not-public logic, at the end of the day this code would run in a production environment where  typically Java assertion is not explicitly enabled. Then having these null guards using Java assertion would simply get skipped, then users would only see the **side effects** of these null values **later on** on their call stack and they / we would need to guess and find out the **root cause** (which was null values not being checked early enough). On the other hand having this check eagerly through `ObjectHelper#notNull` would not end up in such a scenarios."", 'commenter': 'bvahdat'}, {'comment': 'These 2 are [invariants which is why checking for assertions is the correct approach](https://docs.oracle.com/javase/7/docs/technotes/guides/language/assert.html#usage-invariants). In normal circumstances they should be defined as final members of the `KinesisDefaultResumeAdapter` class. Unfortunately our code is made in a way that does not favor usage of final variables in many places (which then, would make the assert unnecessary) ', 'commenter': 'orpiske'}, {'comment': ""> These 2 are [invariants which is why checking for assertions is the correct approach](https://docs.oracle.com/javase/7/docs/technotes/guides/language/assert.html#usage-invariants). In normal circumstances they should be defined as final members of the `KinesisDefaultResumeAdapter` class. Unfortunately our code is made in a way that does not favor usage of final variables in many places (which then, would make the assert unnecessary)\r\n\r\nIn the very same page [it says](https://docs.oracle.com/javase/7/docs/technotes/guides/language/assert.html#putting-assertions-into-your-code):\r\n\r\n> Do not use assertions for argument checking in public methods.\r\nArgument checking is typically part of the published specifications (or contract) of a method, and these specifications must be obeyed whether assertions are enabled or disabled. Another problem with using assertions for argument checking is that erroneous arguments should result in an appropriate runtime exception (such as IllegalArgumentException, IndexOutOfBoundsException, or NullPointerException). An assertion failure will not throw an appropriate exception.\r\n\r\nAnd by Camel we additionally make a differentiation of about if that given public method is a _user-facing public code_ or not and then we apply the assert approach or not depending on that?  As a concrete example consider the change by *this* conversation here. Even if this class is not a _user-facing public code_, according to the recommendation :point_up_2: that assert is done inside it's contract implementation method, namely `org.apache.camel.resume.ResumeAdapter#resume` which is wrong according to the recommendation :point_up_2:.\r\n\r\n```\r\n@Override\r\n    public void resume() {\r\n        assert streamName != null;\r\n        assert resumable != null;\r\n       ...\r\n       ...\r\n}\r\n```\r\n\r\nEDIT:\r\nSo ideally according to the recommendation above we should do a proper null-check (not through Java assert keyword) by the following 2 methods of this class:\r\n\r\n```\r\n@Override\r\npublic void setStreamName(String streamName) {\r\n  this.streamName = streamName;\r\n}\r\n\r\npublic void setRequestBuilder(GetShardIteratorRequest.Builder resumable) {\r\n  this.resumable = resumable;\r\n}\r\n```\r\n\r\nBut I will apply the changes the way you are asking me to do, it's alright 👍 "", 'commenter': 'bvahdat'}, {'comment': ""> And by Camel we additionally make a differentiation of about if that given public method is a user-facing public code or not and then we apply the assert approach or not depending on that?\n\n\nYes. But we don't have yet a way - other than documentation - to properly convey this. I think we would need to use Java modules to do that. Sealed classes may eventually help as well, but I don't think we've put these two particular features in our radar yet."", 'commenter': 'orpiske'}]"
9339,components/camel-caffeine/src/main/java/org/apache/camel/component/caffeine/resume/CaffeineCache.java,"@@ -57,7 +58,7 @@ public CaffeineCache(Cache<K, Object> cache, long cacheSize) {
 
     @Override
     public boolean contains(K key, Object entry) {
-        assert key != null;
+        ObjectHelper.notNull(key, ""key"");","[{'comment': 'Assert is the correct check here, as this is set internally by the resume code and it should not be null. The assert only adds a layer of check when running in tests as surefire/failsafe will enable native Java assertions by default in those cases.', 'commenter': 'orpiske'}, {'comment': '> The assert only adds a layer of check when running in tests as surefire/failsafe will enable native Java assertions by default in those cases.\r\n\r\nBut this is not a test running under surefire/failsafe control. So the same reasoning applies here as :point_up_2:.', 'commenter': 'bvahdat'}, {'comment': 'I am wrong about this one. `ObjectHelper` is OK here.', 'commenter': 'orpiske'}]"
9339,components/camel-kafka/src/main/java/org/apache/camel/processor/resume/kafka/KafkaResumeStrategyConfiguration.java,"@@ -37,29 +38,23 @@ public Properties getProducerProperties() {
     }
 
     void setProducerProperties(Properties producerProperties) {
-        assert producerProperties != null;
-
-        this.producerProperties = producerProperties;
+        this.producerProperties = ObjectHelper.notNull(producerProperties, ""producerProperties"");","[{'comment': 'Assert is the correct one: this not user-facing public code.', 'commenter': 'orpiske'}, {'comment': 'My same reasoning as very top :point_up_2:.', 'commenter': 'bvahdat'}, {'comment': 'This one is not a public interface (the method has package visibility, so it should, indeed use an assert). ', 'commenter': 'orpiske'}]"
9339,components/camel-kafka/src/main/java/org/apache/camel/processor/resume/kafka/KafkaResumeStrategyConfiguration.java,"@@ -37,29 +38,23 @@ public Properties getProducerProperties() {
     }
 
     void setProducerProperties(Properties producerProperties) {
-        assert producerProperties != null;
-
-        this.producerProperties = producerProperties;
+        this.producerProperties = ObjectHelper.notNull(producerProperties, ""producerProperties"");
     }
 
     public Properties getConsumerProperties() {
         return consumerProperties;
     }
 
     void setConsumerProperties(Properties consumerProperties) {
-        assert consumerProperties != null;
-
-        this.consumerProperties = consumerProperties;","[{'comment': 'Same as above', 'commenter': 'orpiske'}, {'comment': 'My same reasoning as very top :point_up_2:.', 'commenter': 'bvahdat'}, {'comment': 'Same as the other one.', 'commenter': 'orpiske'}]"
9339,components/camel-kafka/src/main/java/org/apache/camel/processor/resume/kafka/KafkaResumeStrategyConfiguration.java,"@@ -37,29 +38,23 @@ public Properties getProducerProperties() {
     }
 
     void setProducerProperties(Properties producerProperties) {
-        assert producerProperties != null;
-
-        this.producerProperties = producerProperties;
+        this.producerProperties = ObjectHelper.notNull(producerProperties, ""producerProperties"");
     }
 
     public Properties getConsumerProperties() {
         return consumerProperties;
     }
 
     void setConsumerProperties(Properties consumerProperties) {
-        assert consumerProperties != null;
-
-        this.consumerProperties = consumerProperties;
+        this.consumerProperties = ObjectHelper.notNull(consumerProperties, ""consumerProperties"");
     }
 
     public String getTopic() {
         return topic;
     }
 
     void setTopic(String topic) {
-        assert topic != null;
-
-        this.topic = topic;","[{'comment': 'Same as above.', 'commenter': 'orpiske'}, {'comment': 'My same reasoning as very top :point_up_2:.', 'commenter': 'bvahdat'}, {'comment': 'Also not a public interface.', 'commenter': 'orpiske'}]"
9339,components/camel-wal/src/main/java/org/apache/camel/component/wal/LogWriter.java,"@@ -239,7 +240,7 @@ public void updateState(EntryInfo.CachedEntryInfo entryInfo, LogEntry.EntryState
 
          Trying to update a persisted entry here is not acceptable
          */
-        assert layerInfo != null;
+        ObjectHelper.notNull(layerInfo, ""layerInfo"");","[{'comment': 'This is also not correct and also impacts the performance of the log writer as the assert is native and would not be enabled in production code (whereas the ObjectHelper will incur the cost of `notNull` check on a critical section of this code).', 'commenter': 'orpiske'}, {'comment': '> impacts the performance of the log write\r\n\r\nNot sure if a null check through `ObjectHelper.notNull`will have any reasonable performance impact, or do we maybe have any benchmark for that which proves it otherwise?\r\n', 'commenter': 'bvahdat'}, {'comment': 'The impact of `ObjectHelper.nonNull` is pretty small. Almost close to none, but still a bit slower. \r\n\r\n```\r\nAssertTest.benchmarkAssert   avgt   10  183.115 ± 0.844  us/op\r\nAssertTest.benchmarkHelper   avgt   10  186.937 ± 0.779  us/op\r\n```\r\n\r\nOf all the items I commented, this one is the only one which is a big -1 from me. The log writer adds a small bit of latency on the Resume process due to the I/O, so every bit of performance that can be saved here, is important. \r\n', 'commenter': 'orpiske'}]"
9339,core/camel-support/src/main/java/org/apache/camel/support/resume/AdapterHelper.java,"@@ -41,9 +42,9 @@ private AdapterHelper() {
     }
 
     public static ResumeAdapter eval(CamelContext context, ResumeAware resumeAware, ResumeStrategy resumeStrategy) {
-        assert context != null;
-        assert resumeAware != null;
-        assert resumeStrategy != null;
+        ObjectHelper.notNull(context, ""context"");
+        ObjectHelper.notNull(resumeAware, ""resumeAware"");
+        ObjectHelper.notNull(resumeStrategy, ""resumeStrategy"");","[{'comment': 'Assert is the correct one here as this is an internal interface where the nullity condition should not happen in any circumstance. ', 'commenter': 'orpiske'}, {'comment': ""My same reasoning as very top 👆.\r\n\r\nOther than that when we run Camel's own tests (where Java assertion through surefire/failsafe plugins are enabled) then it could be that all these assertions are properly fulfilled which is given through a **concrete test setup**, but what if the setup and data of a given Camel user's production environment is different than what we had by our tests which suddenly they would end up with null values here. So using `ObjectHelper.notNull` guarantees we always verify these, no matter if through Camel test **setup and configuration** or the ones from the users."", 'commenter': 'bvahdat'}, {'comment': 'The reasoning is the other way around: is to ensure that we catch misbehaved tests, tests that may affect this piece of code with these or any thing non-production that may be doing something nasty. \r\n\r\nThe nullity check for most of these is already performed by the calling code. This one is a good example of that:\r\n- [MasterConsumer.java](https://github.com/apache/camel/blob/main/components/camel-master/src/main/java/org/apache/camel/component/master/MasterConsumer.java#L143-L152)\r\n- [DefaultRoute.java](https://github.com/apache/camel/blob/main/core/camel-base-engine/src/main/java/org/apache/camel/impl/engine/DefaultRoute.java#L646-L649)\r\n\r\nSo, the native assertion allow us to add a small layer of ""protection"" without adding too many runtime checks.', 'commenter': 'orpiske'}]"
9339,test-infra/camel-test-infra-core/src/test/java/org/apache/camel/test/infra/core/DefaultAnnotationProcessor.java,"@@ -151,13 +152,12 @@ private void doInvokeFixture(Annotation annotation, Field field, Object instance
                 if (field.getType() == MockEndpoint.class) {
                     final MockEndpoint mockEndpoint = contextExtension.getMockEndpoint(uri);
 
-                    assert mockEndpoint != null;
-
+                    ObjectHelper.notNull(mockEndpoint, ""mockEndpoint"");
                     field.set(instance, mockEndpoint);
                 } else {
                     final Endpoint endpoint = context.getEndpoint(uri);
 
-                    assert endpoint != null;
+                    ObjectHelper.notNull(endpoint, ""endpoint"");","[{'comment': ""A bit torn on this one, as the assert is missing a message saying what's going on."", 'commenter': 'orpiske'}, {'comment': 'I think [the message here](https://github.com/apache/camel/blob/camel-4.0.0-M1/core/camel-util/src/main/java/org/apache/camel/util/ObjectHelper.java#L156) would be clear enough as:\r\n\r\n```\r\nendpoint must be specified\r\n``` ', 'commenter': 'bvahdat'}, {'comment': 'Yeah, that would be ok.', 'commenter': 'orpiske'}]"
9339,test-infra/camel-test-infra-core/src/test/java/org/apache/camel/test/infra/core/api/CamelTestSupportHelper.java,"@@ -30,7 +31,7 @@ public interface CamelTestSupportHelper {
 
     default <T extends Endpoint> T getMandatoryEndpoint(String uri, Class<T> type) {
         T endpoint = getCamelContextExtension().getContext().getEndpoint(uri, type);
-        assert endpoint != null : ""No endpoint found for uri: "" + uri;","[{'comment': 'Assert is OK here.', 'commenter': 'orpiske'}, {'comment': ""Sorry didn't get your point here. So is this change OK? Otherwise the same rational behind it as per my comments above."", 'commenter': 'bvahdat'}, {'comment': 'I am fine with either assert or ObjectHelper here.', 'commenter': 'orpiske'}]"
9344,core/camel-support/src/main/java/org/apache/camel/saga/InMemorySagaCoordinator.java,"@@ -75,6 +75,13 @@ public String getId() {
 
     @Override
     public CompletableFuture<Void> beginStep(Exchange exchange, CamelSagaStep step) {
+        Status status = currentStatus.get();
+        if (status != Status.RUNNING) {
+            CompletableFuture<Void> res = new CompletableFuture<>();
+            res.completeExceptionally(new IllegalStateException(""Cannot begin: status is "" + status));
+            return res;
+        }
+","[{'comment': 'Would you mind adding a test case somewhere in https://github.com/apache/camel/blob/main/core/camel-core/src/test/java/org/apache/camel/processor to prove that it fixes the bug?', 'commenter': 'essobedo'}, {'comment': 'Sure and thanks for pointing the src directory out. I was thinking about a test case but have not find the right place.', 'commenter': 'zhfeng'}]"
9344,core/camel-core/src/test/java/org/apache/camel/processor/SagaTimeoutTest.java,"@@ -81,6 +110,29 @@ public void configure() throws Exception {
                         .compensation(""mock:compensate"").completion(""mock:complete"")
                         .to(""mock:end"");
 
+                from(""direct:saga-multi-participants"")
+                        .process(exchange -> {
+                            exchange.getMessage().setHeader(""id"", UUID.randomUUID().toString());
+                        })
+                        .saga()
+                        .propagation(SagaPropagation.REQUIRES_NEW)
+                        .to(""direct:service1"")
+                        .to(""direct:service2"");
+
+                from(""direct:service1"")
+                        .saga().option(""id"", header(""id""))
+                        .propagation(SagaPropagation.MANDATORY).timeout(100, TimeUnit.MILLISECONDS)
+                        .compensation(""mock:compensate"").completion(""mock:complete"")
+                        .process(exchange -> {
+                            Thread.sleep(300L, 0);
+                        })","[{'comment': 'You could use the `delay` EIP instead https://camel.apache.org/components/3.20.x/eips/delay-eip.html', 'commenter': 'essobedo'}, {'comment': 'Nice catch! I will change to use `deplay`. Thanks!', 'commenter': 'zhfeng'}, {'comment': 'Done', 'commenter': 'zhfeng'}]"
9344,core/camel-core/src/test/java/org/apache/camel/processor/SagaTimeoutTest.java,"@@ -64,6 +70,29 @@ public void testTimeoutHasNoEffectIfCompleted() throws Exception {
         compensate.assertIsNotSatisfied();
     }
 
+    @Test
+    public void testTimeoutMultiParticipants() throws Exception {
+
+        MockEndpoint compensate = getMockEndpoint(""mock:compensate"");
+        compensate.expectedMessageCount(1);","[{'comment': 'That should be `2`, when a timeout expires all participants should be compensated', 'commenter': 'essobedo'}, {'comment': 'There is only `service1` involved in the saga transction. `service2` can not join because the status is `COMPENSATED`. So I think it should be `1`.', 'commenter': 'zhfeng'}, {'comment': 'Ah ok, that makes sense indeed', 'commenter': 'essobedo'}]"
9344,core/camel-core/src/test/java/org/apache/camel/processor/SagaTimeoutTest.java,"@@ -64,6 +70,29 @@ public void testTimeoutHasNoEffectIfCompleted() throws Exception {
         compensate.assertIsNotSatisfied();
     }
 
+    @Test
+    public void testTimeoutMultiParticipants() throws Exception {
+
+        MockEndpoint compensate = getMockEndpoint(""mock:compensate"");
+        compensate.expectedMessageCount(1);
+
+        MockEndpoint complete = getMockEndpoint(""mock:complete"");
+        complete.expectedMessageCount(2);","[{'comment': 'That should be `0` since the Saga participants are compensated none can be completed. The participants cannot be both completed and compensated.', 'commenter': 'essobedo'}, {'comment': 'OK, I use `complete.assertIsNotSatisfied();` but yeah, it coud be more clearer with \r\n```java\r\ncomplete.expectedMessageCount(0); \r\n...\r\ncomplete.assertIsSatisfied();\r\n```', 'commenter': 'zhfeng'}, {'comment': 'Oh, I missed that, it would be definitively more clear 😄 It makes me wonder in which case `assertIsNotSatisfied` can be useful, it sounds like a very dangerous method.', 'commenter': 'essobedo'}, {'comment': 'Done', 'commenter': 'zhfeng'}]"
9349,components/camel-dhis2/LICENSE,"@@ -0,0 +1,24 @@
+Copyright (c) 2004-2022, University of Oslo","[{'comment': ""The code must be provided with an ASF License compliant license: https://www.apache.org/legal/resolved.html#category-a\r\n\r\nAs far as I see this project has been licensed as BSD 3-Clause\r\n\r\nThis copyright of University of Oslo shouldn't be there."", 'commenter': 'oscerd'}]"
9349,components/camel-dhis2/camel-dhis2-api/pom.xml,"@@ -0,0 +1,50 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
+         xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+
+    <modelVersion>4.0.0</modelVersion>
+
+    <parent>
+        <groupId>org.apache.camel</groupId>
+        <artifactId>camel-dhis2-parent</artifactId>
+        <version>4.0.0-SNAPSHOT</version>
+    </parent>
+
+    <artifactId>camel-dhis2-api</artifactId>
+    <name>Camel DHIS2 API</name>
+    <description>Camel DHIS2 API</description>
+    <packaging>jar</packaging>
+
+    <properties>
+        <firstVersion>3.21.0</firstVersion>","[{'comment': 'This should be 4.0.0-SNAPSHOT', 'commenter': 'oscerd'}, {'comment': ""We're going to contribute the component to the `camel-3.x` branch as well. Should it be anyway 4.0.0-SNAPSHOT?"", 'commenter': 'cjmamo'}, {'comment': 'In that case no, it should be 3.21.0, but only after 3.21.0 will be release, so for the moment it should be 4.0.0-SNAPSHOT, until we release', 'commenter': 'oscerd'}]"
9355,dsl/camel-jbang/camel-jbang-core/src/main/java/org/apache/camel/dsl/jbang/core/commands/catalog/CatalogBaseCommand.java,"@@ -19,11 +19,13 @@
 import java.util.Arrays;
 import java.util.List;
 import java.util.Locale;
+import java.util.Map;
 import java.util.stream.Collectors;
 
 import com.github.freva.asciitable.AsciiTable;
 import com.github.freva.asciitable.Column;
 import com.github.freva.asciitable.HorizontalAlign;
+import io.vertx.core.json.Json;","[{'comment': 'We should not use vertx for json.\r\n\r\nInstead we have `camel-util-json` where we have Camel specific json library.\r\n', 'commenter': 'davsclaus'}]"
9359,components/camel-bean/src/main/java/org/apache/camel/component/bean/BeanInfo.java,"@@ -63,7 +63,9 @@ public class BeanInfo {
     private static final Logger LOG = LoggerFactory.getLogger(BeanInfo.class);
     private static final String CGLIB_CLASS_SEPARATOR = ""$$"";
     private static final String CGLIB_METHOD_MARKER = ""CGLIB$"";
+    private static final String BYTE_BUDDY_CLASS_SEPARATOR = ""$ByteBuddy$"";
     private static final String BYTE_BUDDY_METHOD_MARKER = ""$accessor$"";
+    private static final String ARIES_PROXY_CLASS_PREFIX = ""Proxy"";","[{'comment': 'This is not accepted as Proxy has no special marker that would cause problems for end users that have normal classes that are named `ProxyMyWorld` or something.\r\n\r\nWhy does Aries not use a special marker like the others do', 'commenter': 'davsclaus'}, {'comment': 'The class name of aries-proxy class is created as:\r\n```\r\nclassName = ""Proxy"" + AbstractWovenProxyAdapter.getSanitizedUUIDString();\r\n```\r\nSo it would be possible to create a regex for it, if we wanted to be more precise. But the class name is created in default java package, so it should be pretty resistant to real world user classes. At least that was how I thought about it.', 'commenter': 'rastislavpapp'}, {'comment': 'Or the check could be done via reflection, checking for some other markers.', 'commenter': 'rastislavpapp'}, {'comment': 'Reflection should be avoided.', 'commenter': 'oscerd'}]"
9389,components/camel-observation/src/test/java/org/apache/camel/observation/CamelMicrometerObservationTestSupport.java,"@@ -0,0 +1,255 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.observation;
+
+import java.net.URI;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.stream.Collectors;
+
+import io.micrometer.core.instrument.MeterRegistry;
+import io.micrometer.core.instrument.observation.DefaultMeterObservationHandler;
+import io.micrometer.core.instrument.simple.SimpleMeterRegistry;
+import io.micrometer.observation.ObservationHandler;
+import io.micrometer.observation.ObservationRegistry;
+import io.micrometer.observation.tck.TestObservationRegistry;
+import io.micrometer.tracing.handler.PropagatingSenderTracingObservationHandler;
+import io.micrometer.tracing.otel.bridge.OtelBaggageManager;
+import io.micrometer.tracing.otel.bridge.OtelCurrentTraceContext;
+import io.micrometer.tracing.otel.bridge.OtelPropagator;
+import io.micrometer.tracing.otel.bridge.OtelTracer;
+import io.opentelemetry.api.common.AttributeKey;
+import io.opentelemetry.api.trace.Tracer;
+import io.opentelemetry.context.Context;
+import io.opentelemetry.context.propagation.ContextPropagators;
+import io.opentelemetry.extension.trace.propagation.B3Propagator;
+import io.opentelemetry.sdk.testing.exporter.InMemorySpanExporter;
+import io.opentelemetry.sdk.trace.ReadWriteSpan;
+import io.opentelemetry.sdk.trace.ReadableSpan;
+import io.opentelemetry.sdk.trace.SdkTracerProvider;
+import io.opentelemetry.sdk.trace.SpanProcessor;
+import io.opentelemetry.sdk.trace.data.SpanData;
+import io.opentelemetry.sdk.trace.export.SimpleSpanProcessor;
+import org.apache.camel.CamelContext;
+import org.apache.camel.test.junit5.CamelTestSupport;
+import org.apache.camel.tracing.SpanDecorator;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertNotNull;
+
+class CamelMicrometerObservationTestSupport extends CamelTestSupport {
+
+    static final AttributeKey<String> CAMEL_URI_KEY = AttributeKey.stringKey(""camel-uri"");
+    static final AttributeKey<String> COMPONENT_KEY = AttributeKey.stringKey(""component"");
+    static final AttributeKey<String> PRE_KEY = AttributeKey.stringKey(""pre"");
+    static final AttributeKey<String> POST_KEY = AttributeKey.stringKey(""post"");
+
+    private InMemorySpanExporter inMemorySpanExporter = InMemorySpanExporter.create();
+    private SpanTestData[] expected;
+    private Tracer tracer;
+    private MicrometerObservationTracer micrometerObservationTracer;
+    private SdkTracerProvider tracerFactory;
+
+    private MeterRegistry meterRegistry = new SimpleMeterRegistry();
+
+    private ObservationRegistry observationRegistry;
+
+    CamelMicrometerObservationTestSupport(SpanTestData[] expected) {
+        this.expected = expected;
+    }
+
+    @Override
+    protected CamelContext createCamelContext() throws Exception {
+        CamelContext context = super.createCamelContext();
+        micrometerObservationTracer = new MicrometerObservationTracer();
+
+        tracerFactory = SdkTracerProvider.builder()
+                .addSpanProcessor(new LoggingSpanProcessor())
+                .addSpanProcessor(SimpleSpanProcessor.create(inMemorySpanExporter)).build();
+
+        tracer = tracerFactory.get(""tracerTest"");
+
+        observationRegistry = ObservationRegistry.create();
+        observationRegistry.observationConfig().observationHandler(new DefaultMeterObservationHandler(meterRegistry));
+
+        io.micrometer.tracing.Tracer otelTracer = otelTracer();
+        OtelPropagator otelPropagator = new OtelPropagator(ContextPropagators.create(B3Propagator.injectingSingleHeader()), tracer);
+        observationRegistry.observationConfig().observationHandler(new ObservationHandler.FirstMatchingCompositeObservationHandler(new CamelPropagatingSenderTracingObservationHandler<>(otelTracer, otelPropagator), new CamelPropagatingReceiverTracingObservationHandler<>(otelTracer, otelPropagator), new CamelDefaultTracingObservationHandler(otelTracer)));
+
+        micrometerObservationTracer.setObservationRegistry(observationRegistry);
+        // if you want baggage
+        micrometerObservationTracer.setTracer(otelTracer);
+        micrometerObservationTracer.setExcludePatterns(getExcludePatterns());
+        micrometerObservationTracer.addDecorator(new TestSEDASpanDecorator());
+        micrometerObservationTracer.init(context);
+        return context;
+    }
+
+    private OtelTracer otelTracer() {
+        OtelCurrentTraceContext otelCurrentTraceContext = new OtelCurrentTraceContext();
+        OtelBaggageManager otelBaggageManager = new OtelBaggageManager(otelCurrentTraceContext, Collections.emptyList(), Collections.emptyList());
+        return new OtelTracer(tracer, otelCurrentTraceContext, o -> {
+
+        }, otelBaggageManager);
+    }
+
+    protected Set<String> getExcludePatterns() {
+        return new HashSet<>();
+    }
+
+    protected void verify() {
+        verify(expected, false);
+    }
+
+    protected void verify(boolean async) {
+        verify(expected, async);
+    }
+
+    protected List<SpanData> verify(SpanTestData[] expected, boolean async) {
+        List<SpanData> spans = inMemorySpanExporter.getFinishedSpanItems();
+        spans.forEach(mockSpan -> {
+            System.out.println(""Span: "" + mockSpan);
+            System.out.println(""\tComponent: "" + mockSpan.getAttributes().get(COMPONENT_KEY));
+            System.out.println(""\tTags: "" + mockSpan.getAttributes());
+            System.out.println(""\tLogs: "");","[{'comment': 'This should go to a log file, to make it easier for us in the CI. ', 'commenter': 'orpiske'}, {'comment': ""Just FYI I've literally copied that from OpenTelemetry code."", 'commenter': 'marcingrzejszczak'}, {'comment': 'Thanks for the heads up! I will fix it there. ', 'commenter': 'orpiske'}]"
9401,components/camel-dhis2/camel-dhis2-component/src/main/java/org/apache/camel/component/dhis2/Dhis2Configuration.java,"@@ -0,0 +1,97 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.dhis2;
+
+import org.apache.camel.component.dhis2.internal.Dhis2ApiName;
+import org.apache.camel.spi.Configurer;
+import org.apache.camel.spi.Metadata;
+import org.apache.camel.spi.UriParam;
+import org.apache.camel.spi.UriParams;
+import org.apache.camel.spi.UriPath;
+import org.hisp.dhis.integration.sdk.api.Dhis2Client;
+
+@UriParams
+@Configurer
+public class Dhis2Configuration {
+    @UriParam(description = ""Base API URL"")
+    private String baseApiUrl;
+
+    @UriParam(description = ""Username"")
+    private String username;
+
+    @UriParam(description = ""Password"")","[{'comment': 'secret = true, label = ""security""', 'commenter': 'davsclaus'}]"
9401,components/camel-dhis2/camel-dhis2-component/src/main/java/org/apache/camel/component/dhis2/Dhis2Configuration.java,"@@ -0,0 +1,97 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.dhis2;
+
+import org.apache.camel.component.dhis2.internal.Dhis2ApiName;
+import org.apache.camel.spi.Configurer;
+import org.apache.camel.spi.Metadata;
+import org.apache.camel.spi.UriParam;
+import org.apache.camel.spi.UriParams;
+import org.apache.camel.spi.UriPath;
+import org.hisp.dhis.integration.sdk.api.Dhis2Client;
+
+@UriParams
+@Configurer
+public class Dhis2Configuration {
+    @UriParam(description = ""Base API URL"")
+    private String baseApiUrl;
+
+    @UriParam(description = ""Username"")
+    private String username;","[{'comment': 'secret = true, label = ""security""', 'commenter': 'davsclaus'}]"
9401,components/camel-dhis2/camel-dhis2-component/src/main/java/org/apache/camel/component/dhis2/Dhis2Configuration.java,"@@ -0,0 +1,97 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.dhis2;
+
+import org.apache.camel.component.dhis2.internal.Dhis2ApiName;
+import org.apache.camel.spi.Configurer;
+import org.apache.camel.spi.Metadata;
+import org.apache.camel.spi.UriParam;
+import org.apache.camel.spi.UriParams;
+import org.apache.camel.spi.UriPath;
+import org.hisp.dhis.integration.sdk.api.Dhis2Client;
+
+@UriParams
+@Configurer
+public class Dhis2Configuration {","[{'comment': 'The descriptions are a bit short. Its for humans/docs so it may be nicer to add a little bit more text', 'commenter': 'davsclaus'}]"
9401,components/camel-dhis2/camel-dhis2-component/src/main/java/org/apache/camel/component/dhis2/Dhis2Endpoint.java,"@@ -0,0 +1,113 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.dhis2;
+
+import java.util.Map;
+
+import org.apache.camel.Category;
+import org.apache.camel.Consumer;
+import org.apache.camel.Processor;
+import org.apache.camel.Producer;
+import org.apache.camel.component.dhis2.api.Dhis2Get;
+import org.apache.camel.component.dhis2.api.Dhis2Post;
+import org.apache.camel.component.dhis2.api.Dhis2ResourceTables;
+import org.apache.camel.component.dhis2.internal.Dhis2ApiCollection;
+import org.apache.camel.component.dhis2.internal.Dhis2ApiName;
+import org.apache.camel.component.dhis2.internal.Dhis2Constants;
+import org.apache.camel.component.dhis2.internal.Dhis2PropertiesHelper;
+import org.apache.camel.spi.UriEndpoint;
+import org.apache.camel.spi.UriParam;
+import org.apache.camel.support.component.AbstractApiEndpoint;
+import org.apache.camel.support.component.ApiMethod;
+import org.apache.camel.support.component.ApiMethodPropertiesHelper;
+import org.hisp.dhis.integration.sdk.api.Dhis2Client;
+
+/**
+ * Leverages the DHIS2 Java SDK to integrate Apache Camel with the DHIS2 Web API.
+ * <p>
+ */
+@UriEndpoint(firstVersion = ""3.21.0"", scheme = ""dhis2"", title = ""DHIS2"", syntax = ""dhis2:methodName"",
+             apiSyntax = ""apiName/methodName"", category = {
+                     Category.API })
+public class Dhis2Endpoint extends AbstractApiEndpoint<Dhis2ApiName, Dhis2Configuration> {
+
+    @UriParam
+    private final Dhis2Configuration configuration;
+
+    // TODO create and manage API proxy","[{'comment': 'There is a TODO here', 'commenter': 'davsclaus'}]"
9592,components/camel-azure/camel-azure-servicebus/src/main/java/org/apache/camel/component/azure/servicebus/ServiceBusConsumer.java,"@@ -145,6 +145,9 @@ private void onEventListener(final ServiceBusReceivedMessage message) {
         // use default consumer callback
         AsyncCallback cb = defaultConsumerCallback(exchange, true);
         getAsyncProcessor().process(exchange, cb);
+        if (exchange.getException() != null) {","[{'comment': 'Its actually a bit more complex if you use aync processing, as the ""result"" is only done when the callback is done, and not when the process is returned.\r\n\r\nIs there some API in azure to rollback/abandon we can explicit call instead of rethrowing exception', 'commenter': 'davsclaus'}]"
9592,components/camel-azure/camel-azure-servicebus/src/main/java/org/apache/camel/component/azure/servicebus/client/ServiceBusClientFactory.java,"@@ -79,9 +79,7 @@ private static ServiceBusClientBuilder.ServiceBusReceiverClientBuilder createBas
             final ServiceBusClientBuilder busClientBuilder, final ServiceBusConfiguration configuration) {
         final ServiceBusClientBuilder.ServiceBusReceiverClientBuilder receiverClientBuilder = busClientBuilder.receiver();
 
-        if (configuration.isDisableAutoComplete()) {
-            receiverClientBuilder.disableAutoComplete();
-        }
+        receiverClientBuilder.disableAutoComplete();","[{'comment': 'Could you add a code comment here why this is disabled - eg that you take hands on commit / rollback in the consumer manually', 'commenter': 'davsclaus'}, {'comment': 'Done.', 'commenter': 'dylanpiergies'}]"
9592,components/camel-azure/camel-azure-servicebus/src/main/java/org/apache/camel/component/azure/servicebus/client/ServiceBusClientFactory.java,"@@ -79,9 +79,10 @@ private static ServiceBusClientBuilder.ServiceBusReceiverClientBuilder createBas
             final ServiceBusClientBuilder busClientBuilder, final ServiceBusConfiguration configuration) {
         final ServiceBusClientBuilder.ServiceBusReceiverClientBuilder receiverClientBuilder = busClientBuilder.receiver();
 
-        if (configuration.isDisableAutoComplete()) {
-            receiverClientBuilder.disableAutoComplete();
-        }
+        // We handle auto-complete in the producer, since we have no way to propagate errors back to the reactive","[{'comment': 'in the consumer ???', 'commenter': 'davsclaus'}, {'comment': ':facepalm: Corrected.', 'commenter': 'dylanpiergies'}]"
9652,test-infra/camel-test-infra-zookeeper/src/test/java/org/apache/camel/test/infra/zookeeper/services/ZooKeeperContainer.java,"@@ -23,7 +23,12 @@
 import org.testcontainers.containers.wait.strategy.Wait;
 
 public class ZooKeeperContainer extends GenericContainer {
-    public static final String CONTAINER_IMAGE = ""zookeeper:3.5"";
+    if (arch == ppc64le) {
+        public static final String CONTAINER_IMAGE = ""icr.io/ppc64le-oss/zookeeper-ppc64le:v3.8.0-bv""
+    } else {
+        public static final String CONTAINER_IMAGE = ""zookeeper:3.5"";
+    }
+    ","[{'comment': 'I\'m not sure that it can compile, maybe you meant: \r\n\r\n`public static final String CONTAINER_IMAGE = arch == ppc64le ? ""icr.io/ppc64le-oss/zookeeper-ppc64le:v3.8.0-bv"" : ""zookeeper:3.5"";`\r\n\r\nor \r\n```\r\n   public static final String CONTAINER_IMAGE;\r\n   static {\r\n        if (arch == ppc64le) {\r\n            CONTAINER_IMAGE = ""icr.io/ppc64le-oss/zookeeper-ppc64le:v3.8.0-bv"";\r\n        } else {\r\n            CONTAINER_IMAGE = ""zookeeper:3.5"";\r\n        }\r\n    }\r\n```', 'commenter': 'essobedo'}, {'comment': '@essobedo locally all the above 3 changes are working.\r\n`public static final String CONTAINER_IMAGE = arch == ppc64le ? ""icr.io/ppc64le-oss/zookeeper-ppc64le:v3.8.0-bv"" : ""zookeeper:3.5"";`\r\nLet me use above way to use the zoo-keeper image, as it will optimize the code. Thanks for your review.', 'commenter': 'Balavva-Mirji'}, {'comment': ""I'm afraid that it cannot even work this way because `arch` and `ppc64le` are both unknown."", 'commenter': 'essobedo'}]"
9672,components/camel-kudu/src/test/java/org/apache/camel/component/kudu/KuduScanTest.java,"@@ -107,6 +111,34 @@ public void scan() throws InterruptedException {
 
     }
 
+    @Test
+    public void scanWithPredicate() throws InterruptedException {
+        errorEndpoint.expectedMessageCount(0);
+        successEndpoint.expectedMessageCount(2);
+
+        // without predicate
+        Map<String, Object> headers = new HashMap<>();
+        headers.put(KuduConstants.CAMEL_KUDU_SCAN_PREDICATE, null);
+        sendBody(""direct:scan"", null, headers);
+        List<Map<String, Object>> results = (List<Map<String, Object>>) successEndpoint.getReceivedExchanges()
+                .get(0).getIn().getBody(List.class);
+        // two records with id=1 and id=2 are expected to be returned
+        assertEquals(2, results.size());","[{'comment': 'Just a minor suggestion ... maybe use the comment in the `assertEquals` so that:\r\n` assertEquals(2, results.size(), ""two records with id=1 and id=2 are expected to be returned"");`\r\n\r\nThat way we don\'t have to dig into the code to read the expectations and the errors on CI are easier to read.', 'commenter': 'orpiske'}, {'comment': 'Thanks for the review! Will update the PR soon.', 'commenter': 'sekikn'}]"
9672,components/camel-kudu/src/test/java/org/apache/camel/component/kudu/KuduScanTest.java,"@@ -107,6 +111,34 @@ public void scan() throws InterruptedException {
 
     }
 
+    @Test
+    public void scanWithPredicate() throws InterruptedException {
+        errorEndpoint.expectedMessageCount(0);
+        successEndpoint.expectedMessageCount(2);
+
+        // without predicate
+        Map<String, Object> headers = new HashMap<>();
+        headers.put(KuduConstants.CAMEL_KUDU_SCAN_PREDICATE, null);
+        sendBody(""direct:scan"", null, headers);
+        List<Map<String, Object>> results = (List<Map<String, Object>>) successEndpoint.getReceivedExchanges()
+                .get(0).getIn().getBody(List.class);
+        // two records with id=1 and id=2 are expected to be returned
+        assertEquals(2, results.size());
+
+        // with predicate
+        ColumnSchema schema = new ColumnSchema.ColumnSchemaBuilder(""id"", Type.INT32).build();
+        KuduPredicate predicate = KuduPredicate.newComparisonPredicate(schema, KuduPredicate.ComparisonOp.EQUAL, 2);
+        headers.put(KuduConstants.CAMEL_KUDU_SCAN_PREDICATE, predicate);
+        sendBody(""direct:scan"", null, headers);
+        results = (List<Map<String, Object>>) successEndpoint.getReceivedExchanges()
+                .get(1).getIn().getBody(List.class);
+        // only one record with id=2 is expected to be returned
+        assertEquals(1, results.size());","[{'comment': 'Same note about the assert.', 'commenter': 'orpiske'}]"
9751,components/camel-platform-http/src/main/java/org/apache/camel/component/platform/http/spi/Method.java,"@@ -16,11 +16,7 @@
  */
 package org.apache.camel.component.platform.http.spi;
 
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.Locale;
-import java.util.Set;
-import java.util.TreeSet;
+import java.util.*;","[{'comment': 'We do not use wildcard imports', 'commenter': 'davsclaus'}, {'comment': ""Fixed. It's IDE's optimization"", 'commenter': 'dk2k'}, {'comment': 'Sorry for accidentally merging branch apache:main in', 'commenter': 'dk2k'}]"
9782,tooling/maven/camel-package-maven-plugin/src/main/java/org/apache/camel/maven/packaging/generics/GenericsUtil.java,"@@ -74,7 +74,7 @@ private static boolean isAssignableFrom(boolean isDelegateOrEvent, Class<?> inje
         } else if (beanType instanceof WildcardType) {
             return isAssignableFrom(isDelegateOrEvent, (Type) injectionPointType, (WildcardType) beanType);
         } else {
-            throw new IllegalArgumentException(""Unsupported type "" + injectionPointType.getClass());
+            throw new IllegalArgumentException(""Unsupported type "" + injectionPointType);","[{'comment': ""I'm wondering if it would make sense to do the same line 61"", 'commenter': 'essobedo'}, {'comment': ""in the line 61 requiredType has type implementing Type (it's an interface). Hence, requiredType.getClass() gives relevant information"", 'commenter': 'dk2k'}]"
9797,components/camel-sql/src/generated/java/org/apache/camel/component/sql/stored/template/generated/TokenMgrError.java,"@@ -47,7 +47,7 @@ public class TokenMgrError extends Error
    * Replaces unprintable characters by their escaped (or unicode escaped)
    * equivalents in the given string
    */
-  protected static final String addEscapes(String str) {
+  protected static String addEscapes(String str) {","[{'comment': ""This class is generated so I'm afraid that this change won't have any effect"", 'commenter': 'essobedo'}]"
9816,components/camel-soap/src/main/java/org/apache/camel/dataformat/soap/SoapDataFormat.java,"@@ -121,33 +121,18 @@ protected List<Object> createContentFromObject(
             final Object inputObject, String soapAction,
             List<Object> headerElements) {
         List<Object> bodyParts = new ArrayList<>();
-        List<Object> headerParts = new ArrayList<>();
         bodyParts.add(inputObject);
 
         List<Object> bodyElements = new ArrayList<>();
         for (Object bodyObj : bodyParts) {
             QName name = elementNameStrategy.findQNameForSoapActionOrType(soapAction, bodyObj.getClass());
             if (name == null) {
                 LOG.warn(""Could not find QName for class {}"", bodyObj.getClass().getName());
-                continue;
             } else {
                 bodyElements.add(getElement(bodyObj, name));
             }
         }
 
-        for (Object headerObj : headerParts) {
-            QName name = elementNameStrategy.findQNameForSoapActionOrType(soapAction, headerObj.getClass());
-            if (name == null) {
-                LOG.warn(""Could not find QName for class {}"", headerObj.getClass().getName());
-                continue;
-            } else {
-                JAXBElement<?> headerElem = getElement(headerObj, name);
-                if (null != headerElem) {
-                    headerElements.add(headerElem);","[{'comment': 'Headers is added to the incoming headerElements parameter in the method, so the old code looks correct', 'commenter': 'davsclaus'}, {'comment': 'headerParts is always an empty list. You refer to the code inside the loop, but this loop iterates through an empty list. Hence, the referred code is never reached. The entire loop can be removed', 'commenter': 'dk2k'}]"
9827,components/camel-jdbc/src/main/java/org/apache/camel/component/jdbc/JdbcProducer.java,"@@ -194,21 +193,12 @@ private boolean doCreateAndExecuteSqlStatementWithHeaders(Exchange exchange, Str
 
     private boolean doCreateAndExecuteSqlStatement(Exchange exchange, String sql, Connection conn) throws Exception {
 
+        Statement stmt = null;
         ResultSet rs = null;
         boolean shouldCloseResources = true;
 
         try {
-            // We might need to leave it open to allow post-processing of the result set. This is why we","[{'comment': 'This is a bit wrong, in case you use JdbcOutputType.StreamList then we need to close it in the UoW, eg its when setResultSet returns false.\r\n\r\nBut I think we can keep the closing in the finally block if setResultSet returns true. Then its closed eager in finally, and then again in UoW done, but its already closed and isClosed will return true.', 'commenter': 'davsclaus'}, {'comment': ""if `setResultSet` resturns `false`, it has added `exchange.getExchangeExtension().addOnCompletion(new ResultSetIteratorCompletion(iterator))`. So I think we don't need to close it in the UoW here. "", 'commenter': 'zhfeng'}, {'comment': 'Or it should be better to move these codes\r\n```java\r\ntry {\r\n...\r\nshouldCloseResources = setResultSet(exchange, conn, rs);\r\n...\r\n\r\n} finally {\r\n            if (shouldCloseResources) {\r\n                closeQuietly(rs);\r\n                closeQuietly(stmt);\r\n            } else {\r\n                exchange.getExchangeExtension().addOnCompletion(new SynchronizationAdapter() {\r\n                @Override\r\n                public void onDone(Exchange exchange) {\r\n                    closeQuietly(rs);\r\n                    closeQuietly(stmt);\r\n                }\r\n            });\r\n           }\r\n        }       \r\n\r\n```', 'commenter': 'zhfeng'}, {'comment': 'Yeah then the closing logic is at the same place and easier to ensure is correct', 'commenter': 'davsclaus'}]"
9828,catalog/camel-report-maven-plugin/src/main/java/org/apache/camel/maven/RouteCoverageMojo.java,"@@ -503,9 +503,7 @@ private static void gatherRouteCoverageSummary(
 
     private static String padString(int level) {
         StringBuilder sb = new StringBuilder();
-        for (int i = 0; i < level; i++) {
-            sb.append(""  "");
-        }
+        sb.append(""  "".repeat(Math.max(0, level)));","[{'comment': 'Should it not just be .repeat(level). The level is not intended to be negative', 'commenter': 'davsclaus'}, {'comment': ""it should. And the StringBuilder isn't necessary after the loop gor removed. So it will be at least one more commit here.\r\nIt was just the automated substitution - to be on the safe side"", 'commenter': 'dk2k'}, {'comment': 'Can you remove the Math.max code as repeat already check that the input must be a positive value', 'commenter': 'davsclaus'}, {'comment': 'fixed', 'commenter': 'dk2k'}]"
9939,components/camel-as2/camel-as2-component/src/test/resources/mendelson/key4.cer,"@@ -0,0 +1,21 @@
+-----BEGIN CERTIFICATE-----","[{'comment': 'This file should be provided via parameters instead of being kept in the code base (i.e.: `mvn -Das2.http.key=/path/to/key`).', 'commenter': 'orpiske'}, {'comment': ""I don't think having Mendelson certificates (provided by this resource and saved as is) in a separate folder is an issue. The similar folder jsse with the certificates got approved in https://github.com/apache/camel/pull/8896 as I can see. The both folders never leak into the AS2 artifact."", 'commenter': 'dk2k'}, {'comment': ""That's a bad practice. Other reviewers may have missed. "", 'commenter': 'orpiske'}]"
9939,components/camel-as2/camel-as2-component/src/test/java/org/apache/camel/component/as2/MendelsonSslEndpointIT.java,"@@ -0,0 +1,132 @@
+package org.apache.camel.component.as2;
+
+import java.nio.charset.Charset;
+
+import javax.net.ssl.HostnameVerifier;
+
+import org.apache.camel.CamelContext;
+import org.apache.camel.Exchange;
+import org.apache.camel.component.as2.api.AS2EncryptionAlgorithm;
+import org.apache.camel.component.as2.api.AS2MessageStructure;
+import org.apache.camel.component.as2.api.AS2SignatureAlgorithm;
+import org.apache.camel.component.as2.internal.AS2ApiName;
+import org.apache.camel.impl.DefaultCamelContext;
+import org.apache.http.conn.ssl.NoopHostnameVerifier;
+import org.junit.jupiter.api.Assertions;
+import org.junit.jupiter.api.BeforeAll;
+import org.junit.jupiter.api.Disabled;
+import org.junit.jupiter.api.Test;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * Test class for testing connection to a public 3rd party AS2 server Mendelson. This class gives more info for
+ * camel-as2 connectivity to a remote server compared to HTTPS connection to localhost server. Eventually test method(s)
+ * will be committed with @Disabled annotation due to they can fail because the mendelson server goes offline or the
+ * certificate expires. I assume we don't want a build to fail because of such 3rd party connectivity dependency.
+ * Mendelson page: http://mendelson-e-c.com/as2_testserver
+ */
+public class MendelsonSslEndpointIT extends AbstractAS2ITSupport {
+
+    private static final Logger LOG = LoggerFactory.getLogger(MendelsonSslEndpointIT.class);
+    private MendelsonCertLoader mendelsonCertLoader;
+    private static HostnameVerifier hostnameVerifier;
+
+    private static final String[] SIGNED_RECEIPT_MIC_ALGORITHMS = new String[] { ""sha1"", ""md5"" };
+
+    private static final String EDI_MESSAGE = ""UNB+UNOA:1+005435656:1+006415160:1+060515:1434+00000000000778'\n""
+                                              + ""UNH+00000000000117+INVOIC:D:97B:UN'\n""
+                                              + ""BGM+380+342459+9'\n""
+                                              + ""DTM+3:20060515:102'\n""
+                                              + ""RFF+ON:521052'\n""
+                                              + ""NAD+BY+792820524::16++CUMMINS MID-RANGE ENGINE PLANT'\n""
+                                              + ""NAD+SE+005435656::16++GENERAL WIDGET COMPANY'\n""
+                                              + ""CUX+1:USD'\n""
+                                              + ""LIN+1++157870:IN'\n""
+                                              + ""IMD+F++:::WIDGET'\n""
+                                              + ""QTY+47:1020:EA'\n""
+                                              + ""ALI+US'\n""
+                                              + ""MOA+203:1202.58'\n""
+                                              + ""PRI+INV:1.179'\n""
+                                              + ""LIN+2++157871:IN'\n""
+                                              + ""IMD+F++:::Message from Camel AS2 via HTTPS'\n""
+                                              + ""QTY+47:20:EA'\n""
+                                              + ""ALI+JP'\n""
+                                              + ""MOA+203:410'\n""
+                                              + ""PRI+INV:20.5'\n""
+                                              + ""UNS+S'\n""
+                                              + ""MOA+39:2137.58'\n""
+                                              + ""ALC+C+ABG'\n""
+                                              + ""MOA+8:525'\n""
+                                              + ""UNT+23+00000000000117'\n""
+                                              + ""UNZ+1+00000000000778'\n"";
+
+    @BeforeAll
+    public void setupTest() {
+        hostnameVerifier = new NoopHostnameVerifier();
+        mendelsonCertLoader = new MendelsonCertLoader();
+        mendelsonCertLoader.setupCertificateChain();
+        mendelsonCertLoader.setupSslContext();
+    }
+
+    @Disabled
+    @Test
+    public void testCreateEndpointAndSendViaHTTPS() throws Exception {
+        CamelContext camelContext = new DefaultCamelContext();
+        camelContext.start();
+
+        org.apache.http.entity.ContentType contentTypeEdifact
+                = org.apache.http.entity.ContentType.create(""application/edifact"", (Charset) null);
+
+        String methodName = ""send"";
+        AS2ApiName as2ApiNameClient = AS2ApiName.CLIENT;
+
+        AS2Configuration endpointConfiguration = new AS2Configuration();
+        endpointConfiguration.setApiName(as2ApiNameClient);
+        endpointConfiguration.setMethodName(methodName);
+        endpointConfiguration.setRequestUri(""/as2/HttpReceiver"");
+        endpointConfiguration.setSignedReceiptMicAlgorithms(SIGNED_RECEIPT_MIC_ALGORITHMS);
+
+        endpointConfiguration.setAs2MessageStructure(AS2MessageStructure.SIGNED_ENCRYPTED);
+        endpointConfiguration.setSigningAlgorithm(AS2SignatureAlgorithm.SHA3_256WITHRSA);
+        endpointConfiguration.setEncryptingAlgorithm(AS2EncryptionAlgorithm.DES_EDE3_CBC);
+        endpointConfiguration.setSigningCertificateChain(mendelsonCertLoader.getChain());
+        endpointConfiguration.setSigningPrivateKey(mendelsonCertLoader.getPrivateKey());
+        endpointConfiguration.setEncryptingCertificateChain(mendelsonCertLoader.getChain());
+
+        endpointConfiguration.setAs2Version(""1.0"");
+        endpointConfiguration.setAs2To(""mendelsontestAS2"");
+        endpointConfiguration.setAs2From(""mycompanyAS2"");
+        endpointConfiguration.setEdiMessageType(contentTypeEdifact);
+        endpointConfiguration.setFrom(""dk2kEdi"");
+        endpointConfiguration.setSubject(""mysubject"");
+        endpointConfiguration.setSigningAlgorithm(AS2SignatureAlgorithm.MD2WITHRSA);
+        endpointConfiguration.setEdiMessageTransferEncoding(""7bit"");
+        endpointConfiguration.setAttachedFileName(""from_camel.txt"");
+
+        endpointConfiguration.setSslContext(mendelsonCertLoader.getSslContext());
+        endpointConfiguration.setHostnameVerifier(hostnameVerifier);
+
+        AS2Component as2Component = new AS2Component();
+        as2Component.setCamelContext(camelContext);
+        as2Component.setConfiguration(endpointConfiguration);
+        as2Component.start();
+
+        AS2Endpoint endpoint = (AS2Endpoint) as2Component
+                .createEndpoint(""as2://client/send?targetHostName=testas2.mendelson-e-c.com""
+                                + ""&targetPortNumber=8444&inBody=ediMessage&requestUri=/as2/HttpReceiver"" +
+                                ""&ediMessageContentType=application/edifact"" +
+                                ""&signingAlgorithm=SHA3_256WITHRSA"");
+
+        Assertions.assertEquals(""mycompanyAS2"", endpoint.getAs2From());
+        Assertions.assertEquals(""mendelsontestAS2"", endpoint.getAs2To());
+        Assertions.assertEquals(""dk2kEdi"", endpoint.getFrom());","[{'comment': 'These values taken for the assertion expectations should be configurable so that they are not bound to this specific AS2 instance.', 'commenter': 'orpiske'}, {'comment': 'The entire idea of this test class is to bound it to a public AS2 service. It contains ""Mendelson"" in the class name', 'commenter': 'dk2k'}, {'comment': 'See my notes [here](https://github.com/apache/camel/pull/9939#discussion_r1180040542).', 'commenter': 'orpiske'}]"
9939,components/camel-as2/camel-as2-component/src/test/java/org/apache/camel/component/as2/MendelsonCertLoader.java,"@@ -0,0 +1,183 @@
+package org.apache.camel.component.as2;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.nio.charset.StandardCharsets;
+import java.security.KeyManagementException;
+import java.security.KeyStore;
+import java.security.KeyStoreException;
+import java.security.NoSuchAlgorithmException;
+import java.security.PrivateKey;
+import java.security.UnrecoverableKeyException;
+import java.security.cert.Certificate;
+import java.security.cert.CertificateException;
+import java.security.cert.CertificateFactory;
+import java.security.spec.InvalidKeySpecException;
+import java.util.ArrayList;
+import java.util.Base64;
+import java.util.List;
+
+import javax.net.ssl.SSLContext;
+
+import org.apache.commons.io.IOUtils;
+import org.apache.http.conn.ssl.TrustAllStrategy;
+import org.apache.http.ssl.SSLContexts;
+
+/**
+ * That's a utility class for preparing Mendelson-specific certificate chain, private key, ssl context
+ */
+public class MendelsonCertLoader {
+
+    private static final String MENDELSON_CERT = ""mendelson/key4.cer"";
+    private static final String MENDELSON_PRIVATE_KEY = ""mendelson/key3.pfx"";
+
+    private final List<Certificate> chainAsList = new ArrayList<>();
+
+    private PrivateKey privateKey;
+    private SSLContext sslContext;
+
+    public void setupSslContext() {
+        try {
+            InputStream mendelsonPrivateKeyAsStream = getClass().getClassLoader().getResourceAsStream(MENDELSON_PRIVATE_KEY);
+            KeyStore keyStore = getKeyStore(mendelsonPrivateKeyAsStream);
+            sslContext = SSLContexts.custom().setKeyStoreType(""PKCS12"")
+                    .loadTrustMaterial(keyStore, new TrustAllStrategy())
+                    .build();
+        } catch (KeyStoreException e) {
+            e.printStackTrace();
+        } catch (KeyManagementException e) {
+            e.printStackTrace();
+        } catch (IOException e) {
+            e.printStackTrace();
+        } catch (NoSuchAlgorithmException e) {
+            e.printStackTrace();
+        }
+
+        if (sslContext == null) {
+            throw new IllegalStateException(""failed to configure SSL context"");
+        }
+    }
+
+    private KeyStore getKeyStore(InputStream inputStream) throws IOException, NoSuchAlgorithmException {
+        String password = ""test"";
+        KeyStore ks;
+        try {
+            ks = KeyStore.getInstance(""PKCS12"");
+            ks.load(inputStream, password.toCharArray());
+            return ks;
+        } catch (KeyStoreException e) {
+            e.printStackTrace();
+        } catch (CertificateException e) {
+            e.printStackTrace();
+        }
+        throw new IllegalStateException(""about to return null"");
+    }
+
+    public void setupCertificateChain() {
+
+        InputStream mendelsonCertAsStream = getClass().getClassLoader().getResourceAsStream(MENDELSON_CERT);
+        if (mendelsonCertAsStream == null) {
+            //LOG.error(""Couldn't read out client certificate as stream."");
+            throw new IllegalStateException(""Couldn't read out certificate as stream."");
+        }
+
+        InputStream mendelsonPrivateKeyAsStream = getClass().getClassLoader().getResourceAsStream(MENDELSON_PRIVATE_KEY);
+        if (mendelsonPrivateKeyAsStream == null) {
+            //LOG.error(""Couldn't read out private key as stream."");
+            throw new IllegalStateException(""Couldn't read out key storage as stream."");
+        }
+
+        try {
+            Certificate mendelsonCert = getCertificateFromStream(mendelsonCertAsStream);
+            chainAsList.add(mendelsonCert);
+
+            //private key
+            privateKey = getPrivateKeyFromPKCSStream(mendelsonPrivateKeyAsStream);
+
+        } catch (IOException e) {
+            String errMsg = ""Error while trying to load certificate to the keyload. IO error when reading a byte array.  "" + e;
+            System.out.println(errMsg);
+        } catch (NoSuchAlgorithmException e) {
+            String errMsg = ""Error while trying to load certificate to the keyload. Requested algorithm isn't found.  "" + e;
+            System.out.println(errMsg);
+        } catch (CertificateException e) {
+            String errMsg = ""Error while trying to load certificate to the keyload. There is a certificate problem.  "" + e;
+            System.out.println(errMsg);
+        } catch (InvalidKeySpecException e) {
+            String errMsg = ""Can not init private key store  "" + e;
+            System.out.println(errMsg);
+        }
+    }
+
+    public SSLContext getSslContext() {
+        return sslContext;
+    }
+
+    public Certificate[] getChain() {
+        if (chainAsList.size() > 0) {
+            Certificate[] arrayCert = new Certificate[chainAsList.size()];
+
+            for (int i = 0; i < chainAsList.size(); i++) {
+                arrayCert[i] = chainAsList.get(i);
+            }
+            return arrayCert;
+        } else {
+            return null;
+        }
+    }
+
+    public PrivateKey getPrivateKey() {
+        return privateKey;
+    }
+
+    private List<Certificate> getCertificatesFromStream(InputStream inputStream) throws IOException, CertificateException {
+        CertificateFactory certificateFactory = CertificateFactory.getInstance(""X.509"");
+        return (List<Certificate>) certificateFactory.generateCertificates(inputStream);
+    }
+
+    private Certificate getCertificateFromStream(InputStream inputStream) throws IOException, CertificateException {
+        CertificateFactory certificateFactory = CertificateFactory.getInstance(""X.509"");
+        return certificateFactory.generateCertificate(inputStream);
+    }
+
+    //https://stackoverflow.com/questions/18644286/creating-privatekey-object-from-pkcs12
+    private PrivateKey getPrivateKeyFromPKCSStream(InputStream inputStream)
+            throws IOException, NoSuchAlgorithmException, InvalidKeySpecException {
+        String password = ""test"";
+        KeyStore ks = null;
+        try {
+            ks = KeyStore.getInstance(""PKCS12"");
+        } catch (KeyStoreException e) {
+            e.printStackTrace();
+        }
+        try {
+            ks.load(inputStream, password.toCharArray());
+        } catch (CertificateException e) {
+            e.printStackTrace();
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+        try {
+            return (PrivateKey) ks.getKey(
+                    ks.aliases().nextElement(),
+                    password.toCharArray());
+        } catch (KeyStoreException e) {
+            e.printStackTrace();
+        } catch (UnrecoverableKeyException e) {
+            e.printStackTrace();
+        }","[{'comment': 'I believe all these exceptions being caught in this block should be logged.', 'commenter': 'orpiske'}, {'comment': 'fixed', 'commenter': 'dk2k'}]"
9939,components/camel-as2/camel-as2-component/src/test/java/org/apache/camel/component/as2/MendelsonCertLoader.java,"@@ -0,0 +1,183 @@
+package org.apache.camel.component.as2;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.nio.charset.StandardCharsets;
+import java.security.KeyManagementException;
+import java.security.KeyStore;
+import java.security.KeyStoreException;
+import java.security.NoSuchAlgorithmException;
+import java.security.PrivateKey;
+import java.security.UnrecoverableKeyException;
+import java.security.cert.Certificate;
+import java.security.cert.CertificateException;
+import java.security.cert.CertificateFactory;
+import java.security.spec.InvalidKeySpecException;
+import java.util.ArrayList;
+import java.util.Base64;
+import java.util.List;
+
+import javax.net.ssl.SSLContext;
+
+import org.apache.commons.io.IOUtils;
+import org.apache.http.conn.ssl.TrustAllStrategy;
+import org.apache.http.ssl.SSLContexts;
+
+/**
+ * That's a utility class for preparing Mendelson-specific certificate chain, private key, ssl context
+ */
+public class MendelsonCertLoader {
+
+    private static final String MENDELSON_CERT = ""mendelson/key4.cer"";
+    private static final String MENDELSON_PRIVATE_KEY = ""mendelson/key3.pfx"";
+
+    private final List<Certificate> chainAsList = new ArrayList<>();
+
+    private PrivateKey privateKey;
+    private SSLContext sslContext;
+
+    public void setupSslContext() {
+        try {
+            InputStream mendelsonPrivateKeyAsStream = getClass().getClassLoader().getResourceAsStream(MENDELSON_PRIVATE_KEY);
+            KeyStore keyStore = getKeyStore(mendelsonPrivateKeyAsStream);
+            sslContext = SSLContexts.custom().setKeyStoreType(""PKCS12"")
+                    .loadTrustMaterial(keyStore, new TrustAllStrategy())
+                    .build();
+        } catch (KeyStoreException e) {
+            e.printStackTrace();
+        } catch (KeyManagementException e) {
+            e.printStackTrace();
+        } catch (IOException e) {
+            e.printStackTrace();
+        } catch (NoSuchAlgorithmException e) {
+            e.printStackTrace();
+        }
+
+        if (sslContext == null) {
+            throw new IllegalStateException(""failed to configure SSL context"");
+        }
+    }
+
+    private KeyStore getKeyStore(InputStream inputStream) throws IOException, NoSuchAlgorithmException {
+        String password = ""test"";
+        KeyStore ks;
+        try {
+            ks = KeyStore.getInstance(""PKCS12"");
+            ks.load(inputStream, password.toCharArray());
+            return ks;
+        } catch (KeyStoreException e) {
+            e.printStackTrace();
+        } catch (CertificateException e) {
+            e.printStackTrace();
+        }
+        throw new IllegalStateException(""about to return null"");
+    }
+
+    public void setupCertificateChain() {
+
+        InputStream mendelsonCertAsStream = getClass().getClassLoader().getResourceAsStream(MENDELSON_CERT);
+        if (mendelsonCertAsStream == null) {
+            //LOG.error(""Couldn't read out client certificate as stream."");
+            throw new IllegalStateException(""Couldn't read out certificate as stream."");
+        }
+
+        InputStream mendelsonPrivateKeyAsStream = getClass().getClassLoader().getResourceAsStream(MENDELSON_PRIVATE_KEY);
+        if (mendelsonPrivateKeyAsStream == null) {
+            //LOG.error(""Couldn't read out private key as stream."");
+            throw new IllegalStateException(""Couldn't read out key storage as stream."");
+        }
+
+        try {
+            Certificate mendelsonCert = getCertificateFromStream(mendelsonCertAsStream);
+            chainAsList.add(mendelsonCert);
+
+            //private key
+            privateKey = getPrivateKeyFromPKCSStream(mendelsonPrivateKeyAsStream);
+
+        } catch (IOException e) {
+            String errMsg = ""Error while trying to load certificate to the keyload. IO error when reading a byte array.  "" + e;
+            System.out.println(errMsg);
+        } catch (NoSuchAlgorithmException e) {
+            String errMsg = ""Error while trying to load certificate to the keyload. Requested algorithm isn't found.  "" + e;
+            System.out.println(errMsg);
+        } catch (CertificateException e) {
+            String errMsg = ""Error while trying to load certificate to the keyload. There is a certificate problem.  "" + e;
+            System.out.println(errMsg);
+        } catch (InvalidKeySpecException e) {
+            String errMsg = ""Can not init private key store  "" + e;
+            System.out.println(errMsg);
+        }
+    }
+
+    public SSLContext getSslContext() {
+        return sslContext;
+    }
+
+    public Certificate[] getChain() {
+        if (chainAsList.size() > 0) {
+            Certificate[] arrayCert = new Certificate[chainAsList.size()];
+
+            for (int i = 0; i < chainAsList.size(); i++) {
+                arrayCert[i] = chainAsList.get(i);
+            }
+            return arrayCert;
+        } else {
+            return null;
+        }
+    }
+
+    public PrivateKey getPrivateKey() {
+        return privateKey;
+    }
+
+    private List<Certificate> getCertificatesFromStream(InputStream inputStream) throws IOException, CertificateException {
+        CertificateFactory certificateFactory = CertificateFactory.getInstance(""X.509"");
+        return (List<Certificate>) certificateFactory.generateCertificates(inputStream);
+    }
+
+    private Certificate getCertificateFromStream(InputStream inputStream) throws IOException, CertificateException {
+        CertificateFactory certificateFactory = CertificateFactory.getInstance(""X.509"");
+        return certificateFactory.generateCertificate(inputStream);
+    }
+
+    //https://stackoverflow.com/questions/18644286/creating-privatekey-object-from-pkcs12
+    private PrivateKey getPrivateKeyFromPKCSStream(InputStream inputStream)
+            throws IOException, NoSuchAlgorithmException, InvalidKeySpecException {
+        String password = ""test"";
+        KeyStore ks = null;
+        try {
+            ks = KeyStore.getInstance(""PKCS12"");
+        } catch (KeyStoreException e) {
+            e.printStackTrace();
+        }
+        try {
+            ks.load(inputStream, password.toCharArray());
+        } catch (CertificateException e) {
+            e.printStackTrace();
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+        try {
+            return (PrivateKey) ks.getKey(
+                    ks.aliases().nextElement(),
+                    password.toCharArray());
+        } catch (KeyStoreException e) {
+            e.printStackTrace();
+        } catch (UnrecoverableKeyException e) {
+            e.printStackTrace();
+        }
+        throw new IllegalStateException(""about to return null"");","[{'comment': 'Maybe provide a better error message here. ', 'commenter': 'orpiske'}, {'comment': 'fixed', 'commenter': 'dk2k'}]"
9939,components/camel-as2/camel-as2-component/src/test/java/org/apache/camel/component/as2/MendelsonCertLoader.java,"@@ -0,0 +1,183 @@
+package org.apache.camel.component.as2;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.nio.charset.StandardCharsets;
+import java.security.KeyManagementException;
+import java.security.KeyStore;
+import java.security.KeyStoreException;
+import java.security.NoSuchAlgorithmException;
+import java.security.PrivateKey;
+import java.security.UnrecoverableKeyException;
+import java.security.cert.Certificate;
+import java.security.cert.CertificateException;
+import java.security.cert.CertificateFactory;
+import java.security.spec.InvalidKeySpecException;
+import java.util.ArrayList;
+import java.util.Base64;
+import java.util.List;
+
+import javax.net.ssl.SSLContext;
+
+import org.apache.commons.io.IOUtils;
+import org.apache.http.conn.ssl.TrustAllStrategy;
+import org.apache.http.ssl.SSLContexts;
+
+/**
+ * That's a utility class for preparing Mendelson-specific certificate chain, private key, ssl context
+ */
+public class MendelsonCertLoader {
+
+    private static final String MENDELSON_CERT = ""mendelson/key4.cer"";
+    private static final String MENDELSON_PRIVATE_KEY = ""mendelson/key3.pfx"";
+
+    private final List<Certificate> chainAsList = new ArrayList<>();
+
+    private PrivateKey privateKey;
+    private SSLContext sslContext;
+
+    public void setupSslContext() {
+        try {
+            InputStream mendelsonPrivateKeyAsStream = getClass().getClassLoader().getResourceAsStream(MENDELSON_PRIVATE_KEY);
+            KeyStore keyStore = getKeyStore(mendelsonPrivateKeyAsStream);
+            sslContext = SSLContexts.custom().setKeyStoreType(""PKCS12"")
+                    .loadTrustMaterial(keyStore, new TrustAllStrategy())
+                    .build();
+        } catch (KeyStoreException e) {
+            e.printStackTrace();
+        } catch (KeyManagementException e) {
+            e.printStackTrace();
+        } catch (IOException e) {
+            e.printStackTrace();
+        } catch (NoSuchAlgorithmException e) {
+            e.printStackTrace();
+        }
+
+        if (sslContext == null) {
+            throw new IllegalStateException(""failed to configure SSL context"");
+        }
+    }
+
+    private KeyStore getKeyStore(InputStream inputStream) throws IOException, NoSuchAlgorithmException {
+        String password = ""test"";
+        KeyStore ks;
+        try {
+            ks = KeyStore.getInstance(""PKCS12"");
+            ks.load(inputStream, password.toCharArray());
+            return ks;
+        } catch (KeyStoreException e) {
+            e.printStackTrace();
+        } catch (CertificateException e) {
+            e.printStackTrace();
+        }
+        throw new IllegalStateException(""about to return null"");
+    }
+
+    public void setupCertificateChain() {
+
+        InputStream mendelsonCertAsStream = getClass().getClassLoader().getResourceAsStream(MENDELSON_CERT);
+        if (mendelsonCertAsStream == null) {
+            //LOG.error(""Couldn't read out client certificate as stream."");
+            throw new IllegalStateException(""Couldn't read out certificate as stream."");
+        }
+
+        InputStream mendelsonPrivateKeyAsStream = getClass().getClassLoader().getResourceAsStream(MENDELSON_PRIVATE_KEY);
+        if (mendelsonPrivateKeyAsStream == null) {
+            //LOG.error(""Couldn't read out private key as stream."");
+            throw new IllegalStateException(""Couldn't read out key storage as stream."");
+        }
+
+        try {
+            Certificate mendelsonCert = getCertificateFromStream(mendelsonCertAsStream);
+            chainAsList.add(mendelsonCert);
+
+            //private key
+            privateKey = getPrivateKeyFromPKCSStream(mendelsonPrivateKeyAsStream);
+
+        } catch (IOException e) {
+            String errMsg = ""Error while trying to load certificate to the keyload. IO error when reading a byte array.  "" + e;
+            System.out.println(errMsg);
+        } catch (NoSuchAlgorithmException e) {
+            String errMsg = ""Error while trying to load certificate to the keyload. Requested algorithm isn't found.  "" + e;
+            System.out.println(errMsg);
+        } catch (CertificateException e) {
+            String errMsg = ""Error while trying to load certificate to the keyload. There is a certificate problem.  "" + e;
+            System.out.println(errMsg);
+        } catch (InvalidKeySpecException e) {
+            String errMsg = ""Can not init private key store  "" + e;
+            System.out.println(errMsg);
+        }","[{'comment': 'I believe all the messages being sent to the `stdout` here should be handled by a logger. ', 'commenter': 'orpiske'}, {'comment': 'fixed', 'commenter': 'dk2k'}]"
9939,components/camel-as2/camel-as2-component/src/test/java/org/apache/camel/component/as2/MendelsonCertLoader.java,"@@ -0,0 +1,183 @@
+package org.apache.camel.component.as2;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.nio.charset.StandardCharsets;
+import java.security.KeyManagementException;
+import java.security.KeyStore;
+import java.security.KeyStoreException;
+import java.security.NoSuchAlgorithmException;
+import java.security.PrivateKey;
+import java.security.UnrecoverableKeyException;
+import java.security.cert.Certificate;
+import java.security.cert.CertificateException;
+import java.security.cert.CertificateFactory;
+import java.security.spec.InvalidKeySpecException;
+import java.util.ArrayList;
+import java.util.Base64;
+import java.util.List;
+
+import javax.net.ssl.SSLContext;
+
+import org.apache.commons.io.IOUtils;
+import org.apache.http.conn.ssl.TrustAllStrategy;
+import org.apache.http.ssl.SSLContexts;
+
+/**
+ * That's a utility class for preparing Mendelson-specific certificate chain, private key, ssl context
+ */
+public class MendelsonCertLoader {","[{'comment': 'I am not entirely sure we want this file as it is. This is tied to an specific instance of a service. Instead, I think it would be better to make it generic and configurable, so that anyone willing to test with a different instance could do so.', 'commenter': 'orpiske'}, {'comment': 'I\'m not sure that the requested changes are in the scope of the ticket CAMEL-17946. Maybe we need another ticket like ""Provide versatile testing harness for AS2 component"".\r\nLet me explain the situation. All the Mendelson-related classes are in the test folder, they aren\'t part of AS2 JAR artifact. My idea was to provide a basic mechanism so that interested persons can verify my results for HTTPS AS2 connection - scientific approach. I din\'t aim to provide a versatile mechanism. Mendelson is almost the only public resource for testing, it was mentioned in https://github.com/apache/camel/pull/8896 and not by me. It doesn\'t bring something proprietary into the code base.\r\nImportant facts about Mendelson resource. It provides concrete type of private key and keystore. And its certificate chain is degenerated - consists of the only certificate. Furthermore, the same certificate chain is used for encryption and signing.\r\nThe only Mendelson test method is @Disabled by default.\r\nIt is important to test AS2 connection to non-localhost server due to it\'s the only way to test the behaviour of the new config param HostnameVerifier.\r\nOne other PRO: it was difficult to construct SSLContext from scratch for me. If I could choose, I would prefer to have real-life code examples in the code base.', 'commenter': 'dk2k'}, {'comment': ""What I am considering here is: if this is disabled, it won't be tested often. If it won't be tested often, the code will rot and it will be upon us (maintainers/committers) to figure out - several months in the future - if it's still relevant or not (and, as things change, certificates get expired, etc) it's one hell of a pain to update and fix things on these obscure technologies. \r\n\r\n So, by making it generic and configurable ... users themselves can handle this and put more burden on the maintainers.\r\n \r\n I am -1 on this, but let's see what others have to say. "", 'commenter': 'orpiske'}, {'comment': ""Since there was no feedback, let me provide more clarity: what I am asking here is to implement something like this: https://github.com/apache/camel/blob/main/components/camel-kafka/src/test/java/org/apache/camel/component/kafka/integration/KafkaConsumerAuthManualTest.java\r\n\r\nThat is a manual test for connecting to an authenticated Kafka instance. I wrote to try it verify a problem an specific vendor of a managed Kafka service was having. As you can see in the linked test, there's no reference to any specific instance. I'd like this code to apply the same pattern."", 'commenter': 'orpiske'}, {'comment': 'I still hope to get more comments from other maintainers and contributors, I\'m not in a rush. I think we need to calm down and don\'t take this PR personal.\r\n\r\nI can agree that the test class\'s name for mendelson should be appended with ""ManualTest"" and not ""IT"" like now. But I don\'t understand why I should deliver a semi-prepared test class with a dependency on env variables instead of fully operational and friendly self-sustainable test class which matches all its requirements. Why a person would need to create env vars on his/her machine? They may intersect with existing vars, he/she may forget to remove them after all. That\'s an invasive approach.\r\n\r\nI have another example for ManualTest class:  https://github.com/apache/camel/blob/main/components/camel-cometd/src/test/java/org/apache/camel/component/cometd/CometdProducerConsumerInteractiveAuthenticatedManualTest.java\r\nLines 73-74 were last edited by you (I don\'t say that you were the initial author). And in these lines the test class reads a keystore file from a similar resource folder jsse palced in test section of the sources. The test class CometdProducerConsumerInteractiveAuthenticatedManualTest isn\'t environment aware. All the config variables are part of the test class. Why is it OK to have it like this?', 'commenter': 'dk2k'}, {'comment': 'What happen if the Mendelson some day will not work anymore? We need a way to be not dependant on this kind of 3rd party stuff. We are trying to do this in multiple components, by adding containerized services to run when needed. This is really not in line with what we are doing. If this will be disabled for a long time, it will be something maintainers will have to deal with in the future. So I would prefer a different solution, so anyone could maintain this piece of software.', 'commenter': 'oscerd'}, {'comment': 'I\'m not sure that disabled by default test can be considered a dependency. It\'s just good manners: showing a way a person can establish HTTPS AS2 connection to non-localhost server.\r\n\r\nIf Mendelson goes down, just remove two classes with Mendelson in the name, the test/resource folder mendelson and the file test-server.properties. I will be able to do that myself. No hurt feelings on my side then :)\r\n\r\nI think dockerization of AS2 server is beyond the scope of the ticket CAMEL-17946\r\nBesides, what exactly are you going to dockerize? Camel AS2 server component? Both Camel AS2 server and client can have issues which will allow them to communicate, but not to other AS2-compliant server (what if the sources of both client and server suffer from the same issue?). Another point: it\'s important to test HTTPS connection to non-localhost server - test the new HostnameVerifier field. Will docker allow that?\r\n\r\nI\'m not sure you have seen my latest commit with moving Mendelson connection settings to a property file as per @davsclaus \'s comment. Now a person needs to turn on 2 ""knobs"" to connect to Mendelson:\r\n- remove/comment @Disabled annotation\r\n- explicitly set Mendelson hostname in the properties.\r\n\r\nPlease let me know if the latest commit mitigates or even eliminates your concerns. If it dosen\'t, I will remove all Mendelson-related stuff.', 'commenter': 'dk2k'}]"
9939,components/camel-as2/camel-as2-component/pom.xml,"@@ -64,6 +64,12 @@
             <artifactId>camel-jetty</artifactId>
             <scope>test</scope>
         </dependency>
+        <dependency>
+            <groupId>commons-io</groupId>
+            <artifactId>commons-io</artifactId>
+            <version>2.10.0</version>
+            <scope>test</scope>
+        </dependency>","[{'comment': 'This likely needs to be correctly aligned w/ the `commons-io` version we use.', 'commenter': 'orpiske'}, {'comment': 'Will stick to 2.11.0 from the camel-parent POM', 'commenter': 'dk2k'}]"
10066,components/camel-rest-openapi/pom.xml,"@@ -48,17 +49,16 @@
             <groupId>org.apache.camel</groupId>
             <artifactId>camel-rest</artifactId>
         </dependency>
-
+        
+         <dependency>
+            <groupId>io.swagger.core.v3</groupId>
+            <artifactId>swagger-models</artifactId>
+            <version>${swagger-openapi3-version}</version>
+        </dependency>
         <dependency>
-            <groupId>io.apicurio</groupId>
-            <artifactId>apicurio-data-models</artifactId>
-            <version>${apicurio-version}</version>","[{'comment': ""I think the placeholder for apicurio-version could be removed from parent pom, since it won't be used anymore."", 'commenter': 'oscerd'}, {'comment': ""apicurio-data-models is still used in camel-openapi-rest-dsl-generator. I'll see if that could also be upgraded to use swagger instead. However I noticed that I hadn't changed all the swagger versions in the camel-dependencies pom to align them with the parent pom so I did that."", 'commenter': 'klease'}]"
10101,components/camel-snmp/src/test/java/org/apache/camel/component/snmp/TrapTest.java,"@@ -0,0 +1,126 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.snmp;
+
+import org.apache.camel.Endpoint;
+import org.apache.camel.Exchange;
+import org.apache.camel.LoggingLevel;
+import org.apache.camel.Message;
+import org.apache.camel.Producer;
+import org.apache.camel.builder.RouteBuilder;
+import org.apache.camel.component.mock.MockEndpoint;
+import org.apache.camel.test.AvailablePortFinder;
+import org.junit.jupiter.api.Assertions;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.MethodSource;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import org.snmp4j.PDU;
+import org.snmp4j.PDUv1;
+import org.snmp4j.mp.SnmpConstants;
+import org.snmp4j.smi.OID;
+import org.snmp4j.smi.OctetString;
+import org.snmp4j.smi.TimeTicks;
+import org.snmp4j.smi.Variable;
+import org.snmp4j.smi.VariableBinding;
+
+import static org.junit.jupiter.api.Assertions.assertTrue;
+
+public class TrapTest extends SnmpTestSupport {
+    private static final Logger LOG = LoggerFactory.getLogger(TrapTest.class);
+
+    @ParameterizedTest
+    @MethodSource(""supportedVersions"")
+    public void testSendReceiveTraps(int version) throws Exception {
+        PDU trap = createTrap(version);
+
+        // Send it
+        LOG.info(""Sending pdu "" + trap);
+        Endpoint endpoint = context.getEndpoint(""direct:snmptrapV"" + version);
+        Exchange exchange = endpoint.createExchange();
+        exchange.getIn().setBody(trap);
+        Producer producer = endpoint.createProducer();
+        producer.process(exchange);
+
+        synchronized (this) {
+            Thread.sleep(1000);
+        }","[{'comment': 'Can we do this without the `Thread.sleep`, please? We already have plenty of those making out tests artificially slow. ', 'commenter': 'orpiske'}, {'comment': 'IOW: I think you can use Awaitility here. ', 'commenter': 'orpiske'}, {'comment': ""I'll create another PR with change of this code. TBH I don't remember writing this, and definitely Awaitility should be better here, "", 'commenter': 'JiriOndrusek'}, {'comment': 'Thanks @JiriOndrusek, much appreciated! ', 'commenter': 'orpiske'}, {'comment': 'PR: https://github.com/apache/camel/pull/10102', 'commenter': 'JiriOndrusek'}]"
10218,components/camel-parquet-avro/ReadMe.txt,"@@ -0,0 +1,13 @@
+Camel Data Format Project","[{'comment': ""I don't think README is needed anymore"", 'commenter': 'oscerd'}, {'comment': 'removed', 'commenter': 'onderson'}]"
10218,components/camel-parquet-avro/pom.xml,"@@ -0,0 +1,169 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <artifactId>components</artifactId>
+    <groupId>org.apache.camel</groupId>
+    <version>4.0.0-SNAPSHOT</version>
+  </parent>
+
+  <groupId>org.apache.camel.dataformat.parquet.avro</groupId>
+  <artifactId>camel-parquet-avro</artifactId>
+  <packaging>jar</packaging>
+  <version>4.0.0-SNAPSHOT</version>
+
+  <name>Camel :: ParquetAvro</name>
+  <description>Camel ParquetAvro DataFormat</description>
+
+  <properties>
+    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
+    <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
+  </properties>
+
+  <dependencyManagement>
+    <dependencies>
+      <!-- Camel BOM -->
+      <dependency>
+        <groupId>org.apache.camel</groupId>
+        <artifactId>camel-bom</artifactId>
+        <version>4.0.0-SNAPSHOT</version>
+        <scope>import</scope>
+        <type>pom</type>
+      </dependency>
+    </dependencies>
+  </dependencyManagement>
+
+  <dependencies>
+
+    <dependency>
+      <groupId>org.apache.camel</groupId>
+      <artifactId>camel-support</artifactId>
+    </dependency>
+
+    <dependency>
+      <groupId>commons-io</groupId>
+      <artifactId>commons-io</artifactId>
+      <version>${commons-io-version}</version>
+    </dependency>
+
+    <dependency>
+      <groupId>org.apache.parquet</groupId>
+      <artifactId>parquet-common</artifactId>
+      <version>1.12.0</version>","[{'comment': 'This should go as propercy placeholder in parent/pom', 'commenter': 'oscerd'}, {'comment': 'done', 'commenter': 'onderson'}]"
10218,components/camel-parquet-avro/pom.xml,"@@ -0,0 +1,169 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <artifactId>components</artifactId>
+    <groupId>org.apache.camel</groupId>
+    <version>4.0.0-SNAPSHOT</version>
+  </parent>
+
+  <groupId>org.apache.camel.dataformat.parquet.avro</groupId>
+  <artifactId>camel-parquet-avro</artifactId>
+  <packaging>jar</packaging>
+  <version>4.0.0-SNAPSHOT</version>
+
+  <name>Camel :: ParquetAvro</name>
+  <description>Camel ParquetAvro DataFormat</description>
+
+  <properties>
+    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
+    <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
+  </properties>
+
+  <dependencyManagement>
+    <dependencies>
+      <!-- Camel BOM -->
+      <dependency>
+        <groupId>org.apache.camel</groupId>
+        <artifactId>camel-bom</artifactId>
+        <version>4.0.0-SNAPSHOT</version>
+        <scope>import</scope>
+        <type>pom</type>
+      </dependency>
+    </dependencies>
+  </dependencyManagement>
+
+  <dependencies>
+
+    <dependency>
+      <groupId>org.apache.camel</groupId>
+      <artifactId>camel-support</artifactId>
+    </dependency>
+
+    <dependency>
+      <groupId>commons-io</groupId>
+      <artifactId>commons-io</artifactId>
+      <version>${commons-io-version}</version>
+    </dependency>
+
+    <dependency>
+      <groupId>org.apache.parquet</groupId>
+      <artifactId>parquet-common</artifactId>
+      <version>1.12.0</version>
+    </dependency>
+
+    <dependency>
+      <groupId>org.apache.hadoop</groupId>
+      <artifactId>hadoop-client</artifactId>
+      <version>3.3.4</version>
+      <scope>provided</scope>
+    </dependency>
+
+    <dependency>
+      <groupId>org.apache.parquet</groupId>
+      <artifactId>parquet-avro</artifactId>
+      <version>1.12.3</version>","[{'comment': 'Same', 'commenter': 'oscerd'}, {'comment': 'done', 'commenter': 'onderson'}]"
10218,components/camel-parquet-avro/pom.xml,"@@ -0,0 +1,169 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <artifactId>components</artifactId>
+    <groupId>org.apache.camel</groupId>
+    <version>4.0.0-SNAPSHOT</version>
+  </parent>
+
+  <groupId>org.apache.camel.dataformat.parquet.avro</groupId>
+  <artifactId>camel-parquet-avro</artifactId>
+  <packaging>jar</packaging>
+  <version>4.0.0-SNAPSHOT</version>
+
+  <name>Camel :: ParquetAvro</name>
+  <description>Camel ParquetAvro DataFormat</description>
+
+  <properties>
+    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
+    <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
+  </properties>
+
+  <dependencyManagement>
+    <dependencies>
+      <!-- Camel BOM -->
+      <dependency>
+        <groupId>org.apache.camel</groupId>
+        <artifactId>camel-bom</artifactId>
+        <version>4.0.0-SNAPSHOT</version>
+        <scope>import</scope>
+        <type>pom</type>
+      </dependency>
+    </dependencies>
+  </dependencyManagement>
+
+  <dependencies>
+
+    <dependency>
+      <groupId>org.apache.camel</groupId>
+      <artifactId>camel-support</artifactId>
+    </dependency>
+
+    <dependency>
+      <groupId>commons-io</groupId>
+      <artifactId>commons-io</artifactId>
+      <version>${commons-io-version}</version>
+    </dependency>
+
+    <dependency>
+      <groupId>org.apache.parquet</groupId>
+      <artifactId>parquet-common</artifactId>
+      <version>1.12.0</version>
+    </dependency>
+
+    <dependency>
+      <groupId>org.apache.hadoop</groupId>
+      <artifactId>hadoop-client</artifactId>
+      <version>3.3.4</version>","[{'comment': 'This should come from property placeholder in parent pom', 'commenter': 'oscerd'}, {'comment': 'done', 'commenter': 'onderson'}]"
10218,components/camel-parquet-avro/pom.xml,"@@ -0,0 +1,169 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <artifactId>components</artifactId>
+    <groupId>org.apache.camel</groupId>
+    <version>4.0.0-SNAPSHOT</version>
+  </parent>
+
+  <groupId>org.apache.camel.dataformat.parquet.avro</groupId>
+  <artifactId>camel-parquet-avro</artifactId>
+  <packaging>jar</packaging>
+  <version>4.0.0-SNAPSHOT</version>
+
+  <name>Camel :: ParquetAvro</name>
+  <description>Camel ParquetAvro DataFormat</description>
+
+  <properties>
+    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
+    <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
+  </properties>
+
+  <dependencyManagement>
+    <dependencies>
+      <!-- Camel BOM -->
+      <dependency>","[{'comment': 'The bom is not needed here', 'commenter': 'oscerd'}, {'comment': 'removed', 'commenter': 'onderson'}]"
10218,components/camel-parquet-avro/pom.xml,"@@ -0,0 +1,169 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <artifactId>components</artifactId>
+    <groupId>org.apache.camel</groupId>
+    <version>4.0.0-SNAPSHOT</version>
+  </parent>
+
+  <groupId>org.apache.camel.dataformat.parquet.avro</groupId>
+  <artifactId>camel-parquet-avro</artifactId>
+  <packaging>jar</packaging>
+  <version>4.0.0-SNAPSHOT</version>
+
+  <name>Camel :: ParquetAvro</name>
+  <description>Camel ParquetAvro DataFormat</description>
+
+  <properties>
+    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
+    <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
+  </properties>
+
+  <dependencyManagement>
+    <dependencies>
+      <!-- Camel BOM -->
+      <dependency>
+        <groupId>org.apache.camel</groupId>
+        <artifactId>camel-bom</artifactId>
+        <version>4.0.0-SNAPSHOT</version>
+        <scope>import</scope>
+        <type>pom</type>
+      </dependency>
+    </dependencies>
+  </dependencyManagement>
+
+  <dependencies>
+
+    <dependency>
+      <groupId>org.apache.camel</groupId>
+      <artifactId>camel-support</artifactId>
+    </dependency>
+
+    <dependency>
+      <groupId>commons-io</groupId>
+      <artifactId>commons-io</artifactId>
+      <version>${commons-io-version}</version>
+    </dependency>
+
+    <dependency>
+      <groupId>org.apache.parquet</groupId>
+      <artifactId>parquet-common</artifactId>
+      <version>1.12.0</version>
+    </dependency>
+
+    <dependency>
+      <groupId>org.apache.hadoop</groupId>
+      <artifactId>hadoop-client</artifactId>
+      <version>3.3.4</version>
+      <scope>provided</scope>
+    </dependency>
+
+    <dependency>
+      <groupId>org.apache.parquet</groupId>
+      <artifactId>parquet-avro</artifactId>
+      <version>1.12.3</version>
+    </dependency>
+
+    <!-- logging -->
+    <dependency>
+      <groupId>org.apache.logging.log4j</groupId>
+      <artifactId>log4j-slf4j-impl</artifactId>
+      <version>${log4j2-version}</version>
+      <scope>test</scope>
+    </dependency>
+
+    <!-- testing -->
+    <dependency>
+      <groupId>org.apache.camel</groupId>
+      <artifactId>camel-test-junit5</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.apache.camel</groupId>
+      <artifactId>camel-spring-xml</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.apache.camel</groupId>
+      <artifactId>camel-test-spring-junit5</artifactId>
+      <scope>test</scope>
+    </dependency>
+
+    <dependency>
+      <groupId>jakarta.xml.bind</groupId>
+      <artifactId>jakarta.xml.bind-api</artifactId>
+      <version>${jakarta-xml-bind-api-version}</version>
+      <optional>true</optional>
+    </dependency>
+  </dependencies>
+
+  <build>","[{'comment': ""All of the build stuff, should all come from components pom and above. You don't need to declare them here."", 'commenter': 'oscerd'}, {'comment': 'removed', 'commenter': 'onderson'}]"
10218,components/camel-parquet-avro/src/main/java/org/apache/camel/dataformat/parquet/avro/ParquetAvroDataFormat.java,"@@ -0,0 +1,125 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.dataformat.parquet.avro;
+
+import java.io.BufferedOutputStream;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.util.ArrayList;
+import java.util.List;
+
+import org.apache.avro.reflect.ReflectData;
+import org.apache.camel.Exchange;
+import org.apache.camel.spi.DataFormat;
+import org.apache.camel.spi.DataFormatName;
+import org.apache.camel.spi.annotations.Dataformat;
+import org.apache.camel.support.DefaultUuidGenerator;
+import org.apache.camel.support.service.ServiceSupport;
+import org.apache.hadoop.conf.Configuration;
+import org.apache.hadoop.fs.FileSystem;
+import org.apache.parquet.avro.AvroParquetReader;
+import org.apache.parquet.avro.AvroParquetWriter;
+import org.apache.parquet.hadoop.ParquetReader;
+import org.apache.parquet.hadoop.ParquetWriter;
+
+import static org.apache.parquet.hadoop.ParquetFileWriter.Mode.OVERWRITE;
+import static org.apache.parquet.hadoop.metadata.CompressionCodecName.GZIP;
+
+@Dataformat(""parquetAvro"")
+public class ParquetAvroDataFormat extends ServiceSupport implements DataFormat, DataFormatName {
+
+    private static final DefaultUuidGenerator DEFAULT_UUID_GENERATOR = new DefaultUuidGenerator();
+
+    private Class<?> unmarshalType;
+
+    public String getDataFormatName() {
+        return ""parquet-avro"";
+    }
+
+    public void marshal(Exchange exchange, Object graph, OutputStream stream) throws Exception {
+        // marshal from the Java object (graph) to the parquet-avro type
+        Configuration conf = new Configuration();
+
+        FileSystem.get(conf).setWriteChecksum(false);
+
+        BufferedOutputStream parquetOutput = new BufferedOutputStream(stream);
+        ParquetOutputStream parquetOutputStream = new ParquetOutputStream(
+                DEFAULT_UUID_GENERATOR.generateUuid(),
+                parquetOutput);
+
+        List<?> list = (List<?>) graph;
+
+        try (ParquetWriter writer = AvroParquetWriter.builder(parquetOutputStream)
+                .withSchema(ReflectData.AllowNull.get().getSchema(unmarshalType)) // generate nullable fields
+                .withDataModel(ReflectData.get())
+                .withConf(conf)
+                .withCompressionCodec(GZIP)","[{'comment': 'I think, but I could be wrong, compression codec and some other parameter here could be options at dataformat level.', 'commenter': 'oscerd'}, {'comment': 'agree defaulted as it is. can raise another jira for enhancement perhaps?', 'commenter': 'onderson'}, {'comment': 'Yes please create a JIRA', 'commenter': 'davsclaus'}]"
10218,dsl/camel-endpointdsl/pom.xml,"@@ -44,6 +44,11 @@
             <groupId>org.apache.camel</groupId>
             <artifactId>camel-core-engine</artifactId>
         </dependency>
+        <dependency>
+            <groupId>com.sun.mail</groupId>
+            <artifactId>jakarta.mail</artifactId>","[{'comment': ""Looks weird, I don't think it should be here."", 'commenter': 'oscerd'}, {'comment': ""was failing for me in a full local build. that's why i had to add it. i can remove it if it is only for me."", 'commenter': 'onderson'}, {'comment': 'Yeah lets remove it, as CI builds are okay, and we have migrated to JakartaEE and Angular Mail 2', 'commenter': 'davsclaus'}]"
10286,components/camel-salesforce/camel-salesforce-component/src/main/java/org/apache/camel/component/salesforce/SalesforceConsumer.java,"@@ -290,6 +294,24 @@ protected void doStart() throws Exception {
         subscribed = true;
     }
 
+    /**
+     * If alsoStopSubscription is added, any underlying subscriptions will be stopped as well.
+     *
+     * SubscriptionHelper also logs out, so this will terminate the salesforce session as well.
+     *
+     * @param alsoStopSubscription
+     */
+    public void stop(boolean alsoStopSubscription) {
+        stop();
+        if (alsoStopSubscription) {
+            try {
+                subscriptionHelper.stop();
+            } catch (Exception e) {
+                LOG.warn(""Failed to stop subscription due to: "" + e.getMessage());","[{'comment': 'This should be: \r\n\r\n```\r\n                LOG.warn(""Failed to stop subscription due to: {}"", e.getMessage(), e);\r\n```', 'commenter': 'orpiske'}, {'comment': 'Thank you, that is an excellent point. I have updated the line.', 'commenter': 'jsight'}, {'comment': 'Thanks. Just a note: I meant without concatenating the log string at all.\r\n\r\nUse log marker like this:\r\n\r\n```\r\nLOG.warn(""Failed to stop subscription due to: {}"", e.getMessage(), e);\r\n```\r\n\r\nInstead of concatenating the last part of the log message:\r\n```\r\nLOG.warn(""Failed to stop subscription due to: "" + e.getMessage(), e);\r\n```\r\n\r\n\r\n', 'commenter': 'orpiske'}, {'comment': 'Oh, of course. Sorry I overlooked that part. I have updated the code.', 'commenter': 'jsight'}]"
10286,components/camel-salesforce/camel-salesforce-component/src/main/java/org/apache/camel/component/salesforce/SalesforceConsumer.java,"@@ -290,6 +294,24 @@ protected void doStart() throws Exception {
         subscribed = true;
     }
 
+    /**
+     * If alsoStopSubscription is added, any underlying subscriptions will be stopped as well.
+     *
+     * SubscriptionHelper also logs out, so this will terminate the salesforce session as well.
+     *
+     * @param alsoStopSubscription
+     */
+    public void stop(boolean alsoStopSubscription) {
+        stop();
+        if (alsoStopSubscription) {
+            try {","[{'comment': 'We could add a LOG.info here about manually stopping invoked - this may be good to have in the logs so end users can see this was invoked on purpose', 'commenter': 'davsclaus'}]"
10293,components/camel-activemq/src/main/java/org/apache/camel/component/activemq/package.html,"@@ -0,0 +1,31 @@
+<!--","[{'comment': 'Not sure we need this.', 'commenter': 'oscerd'}]"
10293,components/camel-activemq/src/main/java/org/apache/camel/component/activemq/ActiveMQComponent.java,"@@ -0,0 +1,283 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.activemq;
+
+import java.util.Map;
+import java.util.concurrent.CopyOnWriteArrayList;
+
+import org.apache.activemq.Service;
+import org.apache.camel.CamelContext;
+import org.apache.camel.Endpoint;
+import org.apache.camel.component.jms.JmsComponent;
+import org.apache.camel.component.jms.JmsConfiguration;
+import org.apache.camel.component.jms.JmsEndpoint;
+import org.apache.camel.component.jms.QueueBrowseStrategy;
+import org.apache.camel.spi.Metadata;
+import org.apache.camel.spi.annotations.Component;
+import org.apache.camel.support.component.PropertyConfigurerSupport;
+import org.apache.camel.util.ObjectHelper;
+import org.apache.camel.util.PropertiesHelper;
+import org.apache.camel.util.URISupport;
+import org.springframework.jms.connection.SingleConnectionFactory;
+import org.springframework.jms.core.JmsTemplate;
+
+/**
+ * The ActiveMQ Component.
+ */
+@Component(""activemq"")
+public class ActiveMQComponent extends JmsComponent {
+    private final CopyOnWriteArrayList<SingleConnectionFactory> singleConnectionFactoryList = new CopyOnWriteArrayList<>();
+    private final CopyOnWriteArrayList<Service> pooledConnectionFactoryServiceList = new CopyOnWriteArrayList<>();","[{'comment': ""```suggestion\r\n    private final List<SingleConnectionFactory> singleConnectionFactoryList = new CopyOnWriteArrayList<>();\r\n    private final List<Service> pooledConnectionFactoryServiceList = new CopyOnWriteArrayList<>();\r\n```\r\n\r\nIt looks like we don't call any specific methods so we can use `List`"", 'commenter': 'essobedo'}]"
10293,components/camel-activemq/src/main/java/org/apache/camel/component/activemq/ActiveMQComponent.java,"@@ -0,0 +1,283 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.activemq;
+
+import java.util.Map;
+import java.util.concurrent.CopyOnWriteArrayList;
+
+import org.apache.activemq.Service;
+import org.apache.camel.CamelContext;
+import org.apache.camel.Endpoint;
+import org.apache.camel.component.jms.JmsComponent;
+import org.apache.camel.component.jms.JmsConfiguration;
+import org.apache.camel.component.jms.JmsEndpoint;
+import org.apache.camel.component.jms.QueueBrowseStrategy;
+import org.apache.camel.spi.Metadata;
+import org.apache.camel.spi.annotations.Component;
+import org.apache.camel.support.component.PropertyConfigurerSupport;
+import org.apache.camel.util.ObjectHelper;
+import org.apache.camel.util.PropertiesHelper;
+import org.apache.camel.util.URISupport;
+import org.springframework.jms.connection.SingleConnectionFactory;
+import org.springframework.jms.core.JmsTemplate;
+
+/**
+ * The ActiveMQ Component.
+ */
+@Component(""activemq"")
+public class ActiveMQComponent extends JmsComponent {
+    private final CopyOnWriteArrayList<SingleConnectionFactory> singleConnectionFactoryList = new CopyOnWriteArrayList<>();
+    private final CopyOnWriteArrayList<Service> pooledConnectionFactoryServiceList = new CopyOnWriteArrayList<>();
+
+    public ActiveMQComponent() {
+    }
+
+    public ActiveMQComponent(CamelContext context) {
+        super(context);
+    }
+
+    public ActiveMQComponent(ActiveMQConfiguration configuration) {
+        setConfiguration(configuration);
+    }
+
+    /**
+     * Creates an <a href=""http://camel.apache.org/activemq.html"">ActiveMQ Component</a>
+     *
+     * @return the created component
+     */
+    public static ActiveMQComponent activeMQComponent() {
+        return new ActiveMQComponent();
+    }
+
+    /**
+     * Creates an <a href=""http://camel.apache.org/activemq.html"">ActiveMQ Component</a> connecting to the given
+     * <a href=""http://activemq.apache.org/configuring-transports.html"">broker URL</a>
+     *
+     * @param  brokerURL the URL to connect to
+     * @return           the created component
+     */
+    public static ActiveMQComponent activeMQComponent(String brokerURL) {
+        ActiveMQComponent answer = new ActiveMQComponent();
+        if (answer.getConfiguration() instanceof ActiveMQConfiguration) {
+            ((ActiveMQConfiguration) answer.getConfiguration()).setBrokerURL(brokerURL);","[{'comment': '```suggestion\r\n        if (answer.getConfiguration() instanceof ActiveMQConfiguration activeMQConfiguration) {\r\n            activeMQConfiguration.setBrokerURL(brokerURL);\r\n```', 'commenter': 'essobedo'}, {'comment': 'In which case can we have another type?', 'commenter': 'essobedo'}, {'comment': 'I mean this test should always pass or fail', 'commenter': 'essobedo'}]"
10293,components/camel-activemq/src/main/java/org/apache/camel/component/activemq/ActiveMQComponent.java,"@@ -0,0 +1,283 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.activemq;
+
+import java.util.Map;
+import java.util.concurrent.CopyOnWriteArrayList;
+
+import org.apache.activemq.Service;
+import org.apache.camel.CamelContext;
+import org.apache.camel.Endpoint;
+import org.apache.camel.component.jms.JmsComponent;
+import org.apache.camel.component.jms.JmsConfiguration;
+import org.apache.camel.component.jms.JmsEndpoint;
+import org.apache.camel.component.jms.QueueBrowseStrategy;
+import org.apache.camel.spi.Metadata;
+import org.apache.camel.spi.annotations.Component;
+import org.apache.camel.support.component.PropertyConfigurerSupport;
+import org.apache.camel.util.ObjectHelper;
+import org.apache.camel.util.PropertiesHelper;
+import org.apache.camel.util.URISupport;
+import org.springframework.jms.connection.SingleConnectionFactory;
+import org.springframework.jms.core.JmsTemplate;
+
+/**
+ * The ActiveMQ Component.
+ */
+@Component(""activemq"")
+public class ActiveMQComponent extends JmsComponent {
+    private final CopyOnWriteArrayList<SingleConnectionFactory> singleConnectionFactoryList = new CopyOnWriteArrayList<>();
+    private final CopyOnWriteArrayList<Service> pooledConnectionFactoryServiceList = new CopyOnWriteArrayList<>();
+
+    public ActiveMQComponent() {
+    }
+
+    public ActiveMQComponent(CamelContext context) {
+        super(context);
+    }
+
+    public ActiveMQComponent(ActiveMQConfiguration configuration) {
+        setConfiguration(configuration);
+    }
+
+    /**
+     * Creates an <a href=""http://camel.apache.org/activemq.html"">ActiveMQ Component</a>
+     *
+     * @return the created component
+     */
+    public static ActiveMQComponent activeMQComponent() {
+        return new ActiveMQComponent();
+    }
+
+    /**
+     * Creates an <a href=""http://camel.apache.org/activemq.html"">ActiveMQ Component</a> connecting to the given
+     * <a href=""http://activemq.apache.org/configuring-transports.html"">broker URL</a>
+     *
+     * @param  brokerURL the URL to connect to
+     * @return           the created component
+     */
+    public static ActiveMQComponent activeMQComponent(String brokerURL) {
+        ActiveMQComponent answer = new ActiveMQComponent();
+        if (answer.getConfiguration() instanceof ActiveMQConfiguration) {
+            ((ActiveMQConfiguration) answer.getConfiguration()).setBrokerURL(brokerURL);
+        }
+
+        return answer;
+    }
+
+    public String getBrokerURL() {
+        if (getConfiguration() instanceof ActiveMQConfiguration) {
+            return ((ActiveMQConfiguration) getConfiguration()).getBrokerURL();","[{'comment': '```suggestion\r\n        if (getConfiguration() instanceof ActiveMQConfiguration activeMQConfiguration) {\r\n            return activeMQConfiguration.getBrokerURL();\r\n```', 'commenter': 'essobedo'}]"
10293,components/camel-activemq/src/main/java/org/apache/camel/component/activemq/ActiveMQComponent.java,"@@ -0,0 +1,283 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.activemq;
+
+import java.util.Map;
+import java.util.concurrent.CopyOnWriteArrayList;
+
+import org.apache.activemq.Service;
+import org.apache.camel.CamelContext;
+import org.apache.camel.Endpoint;
+import org.apache.camel.component.jms.JmsComponent;
+import org.apache.camel.component.jms.JmsConfiguration;
+import org.apache.camel.component.jms.JmsEndpoint;
+import org.apache.camel.component.jms.QueueBrowseStrategy;
+import org.apache.camel.spi.Metadata;
+import org.apache.camel.spi.annotations.Component;
+import org.apache.camel.support.component.PropertyConfigurerSupport;
+import org.apache.camel.util.ObjectHelper;
+import org.apache.camel.util.PropertiesHelper;
+import org.apache.camel.util.URISupport;
+import org.springframework.jms.connection.SingleConnectionFactory;
+import org.springframework.jms.core.JmsTemplate;
+
+/**
+ * The ActiveMQ Component.
+ */
+@Component(""activemq"")
+public class ActiveMQComponent extends JmsComponent {
+    private final CopyOnWriteArrayList<SingleConnectionFactory> singleConnectionFactoryList = new CopyOnWriteArrayList<>();
+    private final CopyOnWriteArrayList<Service> pooledConnectionFactoryServiceList = new CopyOnWriteArrayList<>();
+
+    public ActiveMQComponent() {
+    }
+
+    public ActiveMQComponent(CamelContext context) {
+        super(context);
+    }
+
+    public ActiveMQComponent(ActiveMQConfiguration configuration) {
+        setConfiguration(configuration);
+    }
+
+    /**
+     * Creates an <a href=""http://camel.apache.org/activemq.html"">ActiveMQ Component</a>
+     *
+     * @return the created component
+     */
+    public static ActiveMQComponent activeMQComponent() {
+        return new ActiveMQComponent();
+    }
+
+    /**
+     * Creates an <a href=""http://camel.apache.org/activemq.html"">ActiveMQ Component</a> connecting to the given
+     * <a href=""http://activemq.apache.org/configuring-transports.html"">broker URL</a>
+     *
+     * @param  brokerURL the URL to connect to
+     * @return           the created component
+     */
+    public static ActiveMQComponent activeMQComponent(String brokerURL) {
+        ActiveMQComponent answer = new ActiveMQComponent();
+        if (answer.getConfiguration() instanceof ActiveMQConfiguration) {
+            ((ActiveMQConfiguration) answer.getConfiguration()).setBrokerURL(brokerURL);
+        }
+
+        return answer;
+    }
+
+    public String getBrokerURL() {
+        if (getConfiguration() instanceof ActiveMQConfiguration) {
+            return ((ActiveMQConfiguration) getConfiguration()).getBrokerURL();
+        }
+        return null;
+    }
+
+    /**
+     * Sets the broker URL to use to connect to ActiveMQ. If none configured then localhost:61616 is used by default
+     * (however can be overridden by configuration from environment variables)
+     */
+    @Metadata(label = ""common"")
+    public void setBrokerURL(String brokerURL) {
+        if (getConfiguration() instanceof ActiveMQConfiguration) {
+            ((ActiveMQConfiguration) getConfiguration()).setBrokerURL(brokerURL);","[{'comment': '```suggestion\r\n        if (getConfiguration() instanceof ActiveMQConfiguration activeMQConfiguration) {\r\n            activeMQConfiguration.setBrokerURL(brokerURL);\r\n```', 'commenter': 'essobedo'}]"
10293,components/camel-activemq/src/main/java/org/apache/camel/component/activemq/ActiveMQComponent.java,"@@ -0,0 +1,283 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.activemq;
+
+import java.util.Map;
+import java.util.concurrent.CopyOnWriteArrayList;
+
+import org.apache.activemq.Service;
+import org.apache.camel.CamelContext;
+import org.apache.camel.Endpoint;
+import org.apache.camel.component.jms.JmsComponent;
+import org.apache.camel.component.jms.JmsConfiguration;
+import org.apache.camel.component.jms.JmsEndpoint;
+import org.apache.camel.component.jms.QueueBrowseStrategy;
+import org.apache.camel.spi.Metadata;
+import org.apache.camel.spi.annotations.Component;
+import org.apache.camel.support.component.PropertyConfigurerSupport;
+import org.apache.camel.util.ObjectHelper;
+import org.apache.camel.util.PropertiesHelper;
+import org.apache.camel.util.URISupport;
+import org.springframework.jms.connection.SingleConnectionFactory;
+import org.springframework.jms.core.JmsTemplate;
+
+/**
+ * The ActiveMQ Component.
+ */
+@Component(""activemq"")
+public class ActiveMQComponent extends JmsComponent {
+    private final CopyOnWriteArrayList<SingleConnectionFactory> singleConnectionFactoryList = new CopyOnWriteArrayList<>();
+    private final CopyOnWriteArrayList<Service> pooledConnectionFactoryServiceList = new CopyOnWriteArrayList<>();
+
+    public ActiveMQComponent() {
+    }
+
+    public ActiveMQComponent(CamelContext context) {
+        super(context);
+    }
+
+    public ActiveMQComponent(ActiveMQConfiguration configuration) {
+        setConfiguration(configuration);
+    }
+
+    /**
+     * Creates an <a href=""http://camel.apache.org/activemq.html"">ActiveMQ Component</a>
+     *
+     * @return the created component
+     */
+    public static ActiveMQComponent activeMQComponent() {
+        return new ActiveMQComponent();
+    }
+
+    /**
+     * Creates an <a href=""http://camel.apache.org/activemq.html"">ActiveMQ Component</a> connecting to the given
+     * <a href=""http://activemq.apache.org/configuring-transports.html"">broker URL</a>
+     *
+     * @param  brokerURL the URL to connect to
+     * @return           the created component
+     */
+    public static ActiveMQComponent activeMQComponent(String brokerURL) {
+        ActiveMQComponent answer = new ActiveMQComponent();
+        if (answer.getConfiguration() instanceof ActiveMQConfiguration) {
+            ((ActiveMQConfiguration) answer.getConfiguration()).setBrokerURL(brokerURL);
+        }
+
+        return answer;
+    }
+
+    public String getBrokerURL() {
+        if (getConfiguration() instanceof ActiveMQConfiguration) {
+            return ((ActiveMQConfiguration) getConfiguration()).getBrokerURL();
+        }
+        return null;
+    }
+
+    /**
+     * Sets the broker URL to use to connect to ActiveMQ. If none configured then localhost:61616 is used by default
+     * (however can be overridden by configuration from environment variables)
+     */
+    @Metadata(label = ""common"")
+    public void setBrokerURL(String brokerURL) {
+        if (getConfiguration() instanceof ActiveMQConfiguration) {
+            ((ActiveMQConfiguration) getConfiguration()).setBrokerURL(brokerURL);
+        }
+    }
+
+    /**
+     * Define if all Java packages are trusted or not (for Java object JMS message types). Notice its not recommended
+     * practice to send Java serialized objects over network. Setting this to true can expose security risks, so use
+     * this with care.
+     */
+    @Metadata(defaultValue = ""false"", label = ""advanced"")
+    public void setTrustAllPackages(boolean trustAllPackages) {
+        if (getConfiguration() instanceof ActiveMQConfiguration) {
+            ((ActiveMQConfiguration) getConfiguration()).setTrustAllPackages(trustAllPackages);","[{'comment': '```suggestion\r\n        if (getConfiguration() instanceof ActiveMQConfiguration) {\r\n            ((ActiveMQConfiguration) getConfiguration()).setTrustAllPackages(trustAllPackages);\r\n```\r\n```suggestion\r\n        if (getConfiguration() instanceof ActiveMQConfiguration activeMQConfiguration) {\r\n            activeMQConfiguration.setTrustAllPackages(trustAllPackages);\r\n```', 'commenter': 'essobedo'}]"
10293,components/camel-activemq/src/main/java/org/apache/camel/component/activemq/ActiveMQComponent.java,"@@ -0,0 +1,283 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.activemq;
+
+import java.util.Map;
+import java.util.concurrent.CopyOnWriteArrayList;
+
+import org.apache.activemq.Service;
+import org.apache.camel.CamelContext;
+import org.apache.camel.Endpoint;
+import org.apache.camel.component.jms.JmsComponent;
+import org.apache.camel.component.jms.JmsConfiguration;
+import org.apache.camel.component.jms.JmsEndpoint;
+import org.apache.camel.component.jms.QueueBrowseStrategy;
+import org.apache.camel.spi.Metadata;
+import org.apache.camel.spi.annotations.Component;
+import org.apache.camel.support.component.PropertyConfigurerSupport;
+import org.apache.camel.util.ObjectHelper;
+import org.apache.camel.util.PropertiesHelper;
+import org.apache.camel.util.URISupport;
+import org.springframework.jms.connection.SingleConnectionFactory;
+import org.springframework.jms.core.JmsTemplate;
+
+/**
+ * The ActiveMQ Component.
+ */
+@Component(""activemq"")
+public class ActiveMQComponent extends JmsComponent {
+    private final CopyOnWriteArrayList<SingleConnectionFactory> singleConnectionFactoryList = new CopyOnWriteArrayList<>();
+    private final CopyOnWriteArrayList<Service> pooledConnectionFactoryServiceList = new CopyOnWriteArrayList<>();
+
+    public ActiveMQComponent() {
+    }
+
+    public ActiveMQComponent(CamelContext context) {
+        super(context);
+    }
+
+    public ActiveMQComponent(ActiveMQConfiguration configuration) {
+        setConfiguration(configuration);
+    }
+
+    /**
+     * Creates an <a href=""http://camel.apache.org/activemq.html"">ActiveMQ Component</a>
+     *
+     * @return the created component
+     */
+    public static ActiveMQComponent activeMQComponent() {
+        return new ActiveMQComponent();
+    }
+
+    /**
+     * Creates an <a href=""http://camel.apache.org/activemq.html"">ActiveMQ Component</a> connecting to the given
+     * <a href=""http://activemq.apache.org/configuring-transports.html"">broker URL</a>
+     *
+     * @param  brokerURL the URL to connect to
+     * @return           the created component
+     */
+    public static ActiveMQComponent activeMQComponent(String brokerURL) {
+        ActiveMQComponent answer = new ActiveMQComponent();
+        if (answer.getConfiguration() instanceof ActiveMQConfiguration) {
+            ((ActiveMQConfiguration) answer.getConfiguration()).setBrokerURL(brokerURL);
+        }
+
+        return answer;
+    }
+
+    public String getBrokerURL() {
+        if (getConfiguration() instanceof ActiveMQConfiguration) {
+            return ((ActiveMQConfiguration) getConfiguration()).getBrokerURL();
+        }
+        return null;
+    }
+
+    /**
+     * Sets the broker URL to use to connect to ActiveMQ. If none configured then localhost:61616 is used by default
+     * (however can be overridden by configuration from environment variables)
+     */
+    @Metadata(label = ""common"")
+    public void setBrokerURL(String brokerURL) {
+        if (getConfiguration() instanceof ActiveMQConfiguration) {
+            ((ActiveMQConfiguration) getConfiguration()).setBrokerURL(brokerURL);
+        }
+    }
+
+    /**
+     * Define if all Java packages are trusted or not (for Java object JMS message types). Notice its not recommended
+     * practice to send Java serialized objects over network. Setting this to true can expose security risks, so use
+     * this with care.
+     */
+    @Metadata(defaultValue = ""false"", label = ""advanced"")
+    public void setTrustAllPackages(boolean trustAllPackages) {
+        if (getConfiguration() instanceof ActiveMQConfiguration) {
+            ((ActiveMQConfiguration) getConfiguration()).setTrustAllPackages(trustAllPackages);
+        }
+    }
+
+    public boolean isTrustAllPackages() {
+        if (getConfiguration() instanceof ActiveMQConfiguration) {
+            return ((ActiveMQConfiguration) getConfiguration()).isTrustAllPackages();","[{'comment': '```suggestion\r\n        if (getConfiguration() instanceof ActiveMQConfiguration activeMQConfiguration) {\r\n            return activeMQConfiguration.isTrustAllPackages();\r\n```', 'commenter': 'essobedo'}]"
10293,components/camel-activemq/src/main/java/org/apache/camel/component/activemq/ActiveMQComponent.java,"@@ -0,0 +1,283 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.activemq;
+
+import java.util.Map;
+import java.util.concurrent.CopyOnWriteArrayList;
+
+import org.apache.activemq.Service;
+import org.apache.camel.CamelContext;
+import org.apache.camel.Endpoint;
+import org.apache.camel.component.jms.JmsComponent;
+import org.apache.camel.component.jms.JmsConfiguration;
+import org.apache.camel.component.jms.JmsEndpoint;
+import org.apache.camel.component.jms.QueueBrowseStrategy;
+import org.apache.camel.spi.Metadata;
+import org.apache.camel.spi.annotations.Component;
+import org.apache.camel.support.component.PropertyConfigurerSupport;
+import org.apache.camel.util.ObjectHelper;
+import org.apache.camel.util.PropertiesHelper;
+import org.apache.camel.util.URISupport;
+import org.springframework.jms.connection.SingleConnectionFactory;
+import org.springframework.jms.core.JmsTemplate;
+
+/**
+ * The ActiveMQ Component.
+ */
+@Component(""activemq"")
+public class ActiveMQComponent extends JmsComponent {
+    private final CopyOnWriteArrayList<SingleConnectionFactory> singleConnectionFactoryList = new CopyOnWriteArrayList<>();
+    private final CopyOnWriteArrayList<Service> pooledConnectionFactoryServiceList = new CopyOnWriteArrayList<>();
+
+    public ActiveMQComponent() {
+    }
+
+    public ActiveMQComponent(CamelContext context) {
+        super(context);
+    }
+
+    public ActiveMQComponent(ActiveMQConfiguration configuration) {
+        setConfiguration(configuration);
+    }
+
+    /**
+     * Creates an <a href=""http://camel.apache.org/activemq.html"">ActiveMQ Component</a>
+     *
+     * @return the created component
+     */
+    public static ActiveMQComponent activeMQComponent() {
+        return new ActiveMQComponent();
+    }
+
+    /**
+     * Creates an <a href=""http://camel.apache.org/activemq.html"">ActiveMQ Component</a> connecting to the given
+     * <a href=""http://activemq.apache.org/configuring-transports.html"">broker URL</a>
+     *
+     * @param  brokerURL the URL to connect to
+     * @return           the created component
+     */
+    public static ActiveMQComponent activeMQComponent(String brokerURL) {
+        ActiveMQComponent answer = new ActiveMQComponent();
+        if (answer.getConfiguration() instanceof ActiveMQConfiguration) {
+            ((ActiveMQConfiguration) answer.getConfiguration()).setBrokerURL(brokerURL);
+        }
+
+        return answer;
+    }
+
+    public String getBrokerURL() {
+        if (getConfiguration() instanceof ActiveMQConfiguration) {
+            return ((ActiveMQConfiguration) getConfiguration()).getBrokerURL();
+        }
+        return null;
+    }
+
+    /**
+     * Sets the broker URL to use to connect to ActiveMQ. If none configured then localhost:61616 is used by default
+     * (however can be overridden by configuration from environment variables)
+     */
+    @Metadata(label = ""common"")
+    public void setBrokerURL(String brokerURL) {
+        if (getConfiguration() instanceof ActiveMQConfiguration) {
+            ((ActiveMQConfiguration) getConfiguration()).setBrokerURL(brokerURL);
+        }
+    }
+
+    /**
+     * Define if all Java packages are trusted or not (for Java object JMS message types). Notice its not recommended
+     * practice to send Java serialized objects over network. Setting this to true can expose security risks, so use
+     * this with care.
+     */
+    @Metadata(defaultValue = ""false"", label = ""advanced"")
+    public void setTrustAllPackages(boolean trustAllPackages) {
+        if (getConfiguration() instanceof ActiveMQConfiguration) {
+            ((ActiveMQConfiguration) getConfiguration()).setTrustAllPackages(trustAllPackages);
+        }
+    }
+
+    public boolean isTrustAllPackages() {
+        if (getConfiguration() instanceof ActiveMQConfiguration) {
+            return ((ActiveMQConfiguration) getConfiguration()).isTrustAllPackages();
+        }
+        return false;
+    }
+
+    /**
+     * Enables or disables whether a PooledConnectionFactory will be used so that when messages are sent to ActiveMQ
+     * from outside of a message consuming thread, pooling will be used rather than the default with the Spring
+     * {@link JmsTemplate} which will create a new connection, session, producer for each message then close them all
+     * down again.
+     * <p/>
+     * The default value is true.
+     */
+    @Metadata(defaultValue = ""true"", label = ""common"")
+    public void setUsePooledConnection(boolean usePooledConnection) {
+        if (getConfiguration() instanceof ActiveMQConfiguration) {
+            ((ActiveMQConfiguration) getConfiguration()).setUsePooledConnection(usePooledConnection);","[{'comment': '```suggestion\r\n        if (getConfiguration() instanceof ActiveMQConfiguration activeMQConfiguration) {\r\n            activeMQConfiguration.setUsePooledConnection(usePooledConnection);\r\n```', 'commenter': 'essobedo'}]"
10293,components/camel-activemq/src/main/java/org/apache/camel/component/activemq/ActiveMQComponent.java,"@@ -0,0 +1,283 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.activemq;
+
+import java.util.Map;
+import java.util.concurrent.CopyOnWriteArrayList;
+
+import org.apache.activemq.Service;
+import org.apache.camel.CamelContext;
+import org.apache.camel.Endpoint;
+import org.apache.camel.component.jms.JmsComponent;
+import org.apache.camel.component.jms.JmsConfiguration;
+import org.apache.camel.component.jms.JmsEndpoint;
+import org.apache.camel.component.jms.QueueBrowseStrategy;
+import org.apache.camel.spi.Metadata;
+import org.apache.camel.spi.annotations.Component;
+import org.apache.camel.support.component.PropertyConfigurerSupport;
+import org.apache.camel.util.ObjectHelper;
+import org.apache.camel.util.PropertiesHelper;
+import org.apache.camel.util.URISupport;
+import org.springframework.jms.connection.SingleConnectionFactory;
+import org.springframework.jms.core.JmsTemplate;
+
+/**
+ * The ActiveMQ Component.
+ */
+@Component(""activemq"")
+public class ActiveMQComponent extends JmsComponent {
+    private final CopyOnWriteArrayList<SingleConnectionFactory> singleConnectionFactoryList = new CopyOnWriteArrayList<>();
+    private final CopyOnWriteArrayList<Service> pooledConnectionFactoryServiceList = new CopyOnWriteArrayList<>();
+
+    public ActiveMQComponent() {
+    }
+
+    public ActiveMQComponent(CamelContext context) {
+        super(context);
+    }
+
+    public ActiveMQComponent(ActiveMQConfiguration configuration) {
+        setConfiguration(configuration);
+    }
+
+    /**
+     * Creates an <a href=""http://camel.apache.org/activemq.html"">ActiveMQ Component</a>
+     *
+     * @return the created component
+     */
+    public static ActiveMQComponent activeMQComponent() {
+        return new ActiveMQComponent();
+    }
+
+    /**
+     * Creates an <a href=""http://camel.apache.org/activemq.html"">ActiveMQ Component</a> connecting to the given
+     * <a href=""http://activemq.apache.org/configuring-transports.html"">broker URL</a>
+     *
+     * @param  brokerURL the URL to connect to
+     * @return           the created component
+     */
+    public static ActiveMQComponent activeMQComponent(String brokerURL) {
+        ActiveMQComponent answer = new ActiveMQComponent();
+        if (answer.getConfiguration() instanceof ActiveMQConfiguration) {
+            ((ActiveMQConfiguration) answer.getConfiguration()).setBrokerURL(brokerURL);
+        }
+
+        return answer;
+    }
+
+    public String getBrokerURL() {
+        if (getConfiguration() instanceof ActiveMQConfiguration) {
+            return ((ActiveMQConfiguration) getConfiguration()).getBrokerURL();
+        }
+        return null;
+    }
+
+    /**
+     * Sets the broker URL to use to connect to ActiveMQ. If none configured then localhost:61616 is used by default
+     * (however can be overridden by configuration from environment variables)
+     */
+    @Metadata(label = ""common"")
+    public void setBrokerURL(String brokerURL) {
+        if (getConfiguration() instanceof ActiveMQConfiguration) {
+            ((ActiveMQConfiguration) getConfiguration()).setBrokerURL(brokerURL);
+        }
+    }
+
+    /**
+     * Define if all Java packages are trusted or not (for Java object JMS message types). Notice its not recommended
+     * practice to send Java serialized objects over network. Setting this to true can expose security risks, so use
+     * this with care.
+     */
+    @Metadata(defaultValue = ""false"", label = ""advanced"")
+    public void setTrustAllPackages(boolean trustAllPackages) {
+        if (getConfiguration() instanceof ActiveMQConfiguration) {
+            ((ActiveMQConfiguration) getConfiguration()).setTrustAllPackages(trustAllPackages);
+        }
+    }
+
+    public boolean isTrustAllPackages() {
+        if (getConfiguration() instanceof ActiveMQConfiguration) {
+            return ((ActiveMQConfiguration) getConfiguration()).isTrustAllPackages();
+        }
+        return false;
+    }
+
+    /**
+     * Enables or disables whether a PooledConnectionFactory will be used so that when messages are sent to ActiveMQ
+     * from outside of a message consuming thread, pooling will be used rather than the default with the Spring
+     * {@link JmsTemplate} which will create a new connection, session, producer for each message then close them all
+     * down again.
+     * <p/>
+     * The default value is true.
+     */
+    @Metadata(defaultValue = ""true"", label = ""common"")
+    public void setUsePooledConnection(boolean usePooledConnection) {
+        if (getConfiguration() instanceof ActiveMQConfiguration) {
+            ((ActiveMQConfiguration) getConfiguration()).setUsePooledConnection(usePooledConnection);
+        }
+    }
+
+    public boolean isUsePooledConnection() {
+        if (getConfiguration() instanceof ActiveMQConfiguration) {
+            return ((ActiveMQConfiguration) getConfiguration()).isUsePooledConnection();","[{'comment': '```suggestion\r\n        if (getConfiguration() instanceof ActiveMQConfiguration activeMQConfiguration) {\r\n            return activeMQConfiguration.isUsePooledConnection();\r\n```', 'commenter': 'essobedo'}]"
10293,components/camel-activemq/src/main/java/org/apache/camel/component/activemq/ActiveMQComponent.java,"@@ -0,0 +1,283 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.activemq;
+
+import java.util.Map;
+import java.util.concurrent.CopyOnWriteArrayList;
+
+import org.apache.activemq.Service;
+import org.apache.camel.CamelContext;
+import org.apache.camel.Endpoint;
+import org.apache.camel.component.jms.JmsComponent;
+import org.apache.camel.component.jms.JmsConfiguration;
+import org.apache.camel.component.jms.JmsEndpoint;
+import org.apache.camel.component.jms.QueueBrowseStrategy;
+import org.apache.camel.spi.Metadata;
+import org.apache.camel.spi.annotations.Component;
+import org.apache.camel.support.component.PropertyConfigurerSupport;
+import org.apache.camel.util.ObjectHelper;
+import org.apache.camel.util.PropertiesHelper;
+import org.apache.camel.util.URISupport;
+import org.springframework.jms.connection.SingleConnectionFactory;
+import org.springframework.jms.core.JmsTemplate;
+
+/**
+ * The ActiveMQ Component.
+ */
+@Component(""activemq"")
+public class ActiveMQComponent extends JmsComponent {
+    private final CopyOnWriteArrayList<SingleConnectionFactory> singleConnectionFactoryList = new CopyOnWriteArrayList<>();
+    private final CopyOnWriteArrayList<Service> pooledConnectionFactoryServiceList = new CopyOnWriteArrayList<>();
+
+    public ActiveMQComponent() {
+    }
+
+    public ActiveMQComponent(CamelContext context) {
+        super(context);
+    }
+
+    public ActiveMQComponent(ActiveMQConfiguration configuration) {
+        setConfiguration(configuration);
+    }
+
+    /**
+     * Creates an <a href=""http://camel.apache.org/activemq.html"">ActiveMQ Component</a>
+     *
+     * @return the created component
+     */
+    public static ActiveMQComponent activeMQComponent() {
+        return new ActiveMQComponent();
+    }
+
+    /**
+     * Creates an <a href=""http://camel.apache.org/activemq.html"">ActiveMQ Component</a> connecting to the given
+     * <a href=""http://activemq.apache.org/configuring-transports.html"">broker URL</a>
+     *
+     * @param  brokerURL the URL to connect to
+     * @return           the created component
+     */
+    public static ActiveMQComponent activeMQComponent(String brokerURL) {
+        ActiveMQComponent answer = new ActiveMQComponent();
+        if (answer.getConfiguration() instanceof ActiveMQConfiguration) {
+            ((ActiveMQConfiguration) answer.getConfiguration()).setBrokerURL(brokerURL);
+        }
+
+        return answer;
+    }
+
+    public String getBrokerURL() {
+        if (getConfiguration() instanceof ActiveMQConfiguration) {
+            return ((ActiveMQConfiguration) getConfiguration()).getBrokerURL();
+        }
+        return null;
+    }
+
+    /**
+     * Sets the broker URL to use to connect to ActiveMQ. If none configured then localhost:61616 is used by default
+     * (however can be overridden by configuration from environment variables)
+     */
+    @Metadata(label = ""common"")
+    public void setBrokerURL(String brokerURL) {
+        if (getConfiguration() instanceof ActiveMQConfiguration) {
+            ((ActiveMQConfiguration) getConfiguration()).setBrokerURL(brokerURL);
+        }
+    }
+
+    /**
+     * Define if all Java packages are trusted or not (for Java object JMS message types). Notice its not recommended
+     * practice to send Java serialized objects over network. Setting this to true can expose security risks, so use
+     * this with care.
+     */
+    @Metadata(defaultValue = ""false"", label = ""advanced"")
+    public void setTrustAllPackages(boolean trustAllPackages) {
+        if (getConfiguration() instanceof ActiveMQConfiguration) {
+            ((ActiveMQConfiguration) getConfiguration()).setTrustAllPackages(trustAllPackages);
+        }
+    }
+
+    public boolean isTrustAllPackages() {
+        if (getConfiguration() instanceof ActiveMQConfiguration) {
+            return ((ActiveMQConfiguration) getConfiguration()).isTrustAllPackages();
+        }
+        return false;
+    }
+
+    /**
+     * Enables or disables whether a PooledConnectionFactory will be used so that when messages are sent to ActiveMQ
+     * from outside of a message consuming thread, pooling will be used rather than the default with the Spring
+     * {@link JmsTemplate} which will create a new connection, session, producer for each message then close them all
+     * down again.
+     * <p/>
+     * The default value is true.
+     */
+    @Metadata(defaultValue = ""true"", label = ""common"")
+    public void setUsePooledConnection(boolean usePooledConnection) {
+        if (getConfiguration() instanceof ActiveMQConfiguration) {
+            ((ActiveMQConfiguration) getConfiguration()).setUsePooledConnection(usePooledConnection);
+        }
+    }
+
+    public boolean isUsePooledConnection() {
+        if (getConfiguration() instanceof ActiveMQConfiguration) {
+            return ((ActiveMQConfiguration) getConfiguration()).isUsePooledConnection();
+        }
+        return true;
+    }
+
+    /**
+     * Enables or disables whether a Spring {@link SingleConnectionFactory} will be used so that when messages are sent
+     * to ActiveMQ from outside of a message consuming thread, pooling will be used rather than the default with the
+     * Spring {@link JmsTemplate} which will create a new connection, session, producer for each message then close them
+     * all down again.
+     * <p/>
+     * The default value is false and a pooled connection is used by default.
+     */
+    @Metadata(defaultValue = ""false"", label = ""common"")
+    public void setUseSingleConnection(boolean useSingleConnection) {
+        if (getConfiguration() instanceof ActiveMQConfiguration) {
+            ((ActiveMQConfiguration) getConfiguration()).setUseSingleConnection(useSingleConnection);","[{'comment': '```suggestion\r\n        if (getConfiguration() instanceof ActiveMQConfiguration activeMQConfiguration) {\r\n            activeMQConfiguration.setUseSingleConnection(useSingleConnection);\r\n```', 'commenter': 'essobedo'}]"
10293,components/camel-activemq/src/main/java/org/apache/camel/component/activemq/ActiveMQComponent.java,"@@ -0,0 +1,283 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.activemq;
+
+import java.util.Map;
+import java.util.concurrent.CopyOnWriteArrayList;
+
+import org.apache.activemq.Service;
+import org.apache.camel.CamelContext;
+import org.apache.camel.Endpoint;
+import org.apache.camel.component.jms.JmsComponent;
+import org.apache.camel.component.jms.JmsConfiguration;
+import org.apache.camel.component.jms.JmsEndpoint;
+import org.apache.camel.component.jms.QueueBrowseStrategy;
+import org.apache.camel.spi.Metadata;
+import org.apache.camel.spi.annotations.Component;
+import org.apache.camel.support.component.PropertyConfigurerSupport;
+import org.apache.camel.util.ObjectHelper;
+import org.apache.camel.util.PropertiesHelper;
+import org.apache.camel.util.URISupport;
+import org.springframework.jms.connection.SingleConnectionFactory;
+import org.springframework.jms.core.JmsTemplate;
+
+/**
+ * The ActiveMQ Component.
+ */
+@Component(""activemq"")
+public class ActiveMQComponent extends JmsComponent {
+    private final CopyOnWriteArrayList<SingleConnectionFactory> singleConnectionFactoryList = new CopyOnWriteArrayList<>();
+    private final CopyOnWriteArrayList<Service> pooledConnectionFactoryServiceList = new CopyOnWriteArrayList<>();
+
+    public ActiveMQComponent() {
+    }
+
+    public ActiveMQComponent(CamelContext context) {
+        super(context);
+    }
+
+    public ActiveMQComponent(ActiveMQConfiguration configuration) {
+        setConfiguration(configuration);
+    }
+
+    /**
+     * Creates an <a href=""http://camel.apache.org/activemq.html"">ActiveMQ Component</a>
+     *
+     * @return the created component
+     */
+    public static ActiveMQComponent activeMQComponent() {
+        return new ActiveMQComponent();
+    }
+
+    /**
+     * Creates an <a href=""http://camel.apache.org/activemq.html"">ActiveMQ Component</a> connecting to the given
+     * <a href=""http://activemq.apache.org/configuring-transports.html"">broker URL</a>
+     *
+     * @param  brokerURL the URL to connect to
+     * @return           the created component
+     */
+    public static ActiveMQComponent activeMQComponent(String brokerURL) {
+        ActiveMQComponent answer = new ActiveMQComponent();
+        if (answer.getConfiguration() instanceof ActiveMQConfiguration) {
+            ((ActiveMQConfiguration) answer.getConfiguration()).setBrokerURL(brokerURL);
+        }
+
+        return answer;
+    }
+
+    public String getBrokerURL() {
+        if (getConfiguration() instanceof ActiveMQConfiguration) {
+            return ((ActiveMQConfiguration) getConfiguration()).getBrokerURL();
+        }
+        return null;
+    }
+
+    /**
+     * Sets the broker URL to use to connect to ActiveMQ. If none configured then localhost:61616 is used by default
+     * (however can be overridden by configuration from environment variables)
+     */
+    @Metadata(label = ""common"")
+    public void setBrokerURL(String brokerURL) {
+        if (getConfiguration() instanceof ActiveMQConfiguration) {
+            ((ActiveMQConfiguration) getConfiguration()).setBrokerURL(brokerURL);
+        }
+    }
+
+    /**
+     * Define if all Java packages are trusted or not (for Java object JMS message types). Notice its not recommended
+     * practice to send Java serialized objects over network. Setting this to true can expose security risks, so use
+     * this with care.
+     */
+    @Metadata(defaultValue = ""false"", label = ""advanced"")
+    public void setTrustAllPackages(boolean trustAllPackages) {
+        if (getConfiguration() instanceof ActiveMQConfiguration) {
+            ((ActiveMQConfiguration) getConfiguration()).setTrustAllPackages(trustAllPackages);
+        }
+    }
+
+    public boolean isTrustAllPackages() {
+        if (getConfiguration() instanceof ActiveMQConfiguration) {
+            return ((ActiveMQConfiguration) getConfiguration()).isTrustAllPackages();
+        }
+        return false;
+    }
+
+    /**
+     * Enables or disables whether a PooledConnectionFactory will be used so that when messages are sent to ActiveMQ
+     * from outside of a message consuming thread, pooling will be used rather than the default with the Spring
+     * {@link JmsTemplate} which will create a new connection, session, producer for each message then close them all
+     * down again.
+     * <p/>
+     * The default value is true.
+     */
+    @Metadata(defaultValue = ""true"", label = ""common"")
+    public void setUsePooledConnection(boolean usePooledConnection) {
+        if (getConfiguration() instanceof ActiveMQConfiguration) {
+            ((ActiveMQConfiguration) getConfiguration()).setUsePooledConnection(usePooledConnection);
+        }
+    }
+
+    public boolean isUsePooledConnection() {
+        if (getConfiguration() instanceof ActiveMQConfiguration) {
+            return ((ActiveMQConfiguration) getConfiguration()).isUsePooledConnection();
+        }
+        return true;
+    }
+
+    /**
+     * Enables or disables whether a Spring {@link SingleConnectionFactory} will be used so that when messages are sent
+     * to ActiveMQ from outside of a message consuming thread, pooling will be used rather than the default with the
+     * Spring {@link JmsTemplate} which will create a new connection, session, producer for each message then close them
+     * all down again.
+     * <p/>
+     * The default value is false and a pooled connection is used by default.
+     */
+    @Metadata(defaultValue = ""false"", label = ""common"")
+    public void setUseSingleConnection(boolean useSingleConnection) {
+        if (getConfiguration() instanceof ActiveMQConfiguration) {
+            ((ActiveMQConfiguration) getConfiguration()).setUseSingleConnection(useSingleConnection);
+        }
+    }
+
+    public boolean isUseSingleConnection() {
+        if (getConfiguration() instanceof ActiveMQConfiguration) {
+            return ((ActiveMQConfiguration) getConfiguration()).isUseSingleConnection();","[{'comment': '```suggestion\r\n        if (getConfiguration() instanceof ActiveMQConfiguration activeMQConfiguration) {\r\n            return activeMQConfiguration.isUseSingleConnection();\r\n```', 'commenter': 'essobedo'}]"
10293,components/camel-activemq/src/main/java/org/apache/camel/component/activemq/ActiveMQComponent.java,"@@ -0,0 +1,283 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.activemq;
+
+import java.util.Map;
+import java.util.concurrent.CopyOnWriteArrayList;
+
+import org.apache.activemq.Service;
+import org.apache.camel.CamelContext;
+import org.apache.camel.Endpoint;
+import org.apache.camel.component.jms.JmsComponent;
+import org.apache.camel.component.jms.JmsConfiguration;
+import org.apache.camel.component.jms.JmsEndpoint;
+import org.apache.camel.component.jms.QueueBrowseStrategy;
+import org.apache.camel.spi.Metadata;
+import org.apache.camel.spi.annotations.Component;
+import org.apache.camel.support.component.PropertyConfigurerSupport;
+import org.apache.camel.util.ObjectHelper;
+import org.apache.camel.util.PropertiesHelper;
+import org.apache.camel.util.URISupport;
+import org.springframework.jms.connection.SingleConnectionFactory;
+import org.springframework.jms.core.JmsTemplate;
+
+/**
+ * The ActiveMQ Component.
+ */
+@Component(""activemq"")
+public class ActiveMQComponent extends JmsComponent {
+    private final CopyOnWriteArrayList<SingleConnectionFactory> singleConnectionFactoryList = new CopyOnWriteArrayList<>();
+    private final CopyOnWriteArrayList<Service> pooledConnectionFactoryServiceList = new CopyOnWriteArrayList<>();
+
+    public ActiveMQComponent() {
+    }
+
+    public ActiveMQComponent(CamelContext context) {
+        super(context);
+    }
+
+    public ActiveMQComponent(ActiveMQConfiguration configuration) {
+        setConfiguration(configuration);
+    }
+
+    /**
+     * Creates an <a href=""http://camel.apache.org/activemq.html"">ActiveMQ Component</a>
+     *
+     * @return the created component
+     */
+    public static ActiveMQComponent activeMQComponent() {
+        return new ActiveMQComponent();
+    }
+
+    /**
+     * Creates an <a href=""http://camel.apache.org/activemq.html"">ActiveMQ Component</a> connecting to the given
+     * <a href=""http://activemq.apache.org/configuring-transports.html"">broker URL</a>
+     *
+     * @param  brokerURL the URL to connect to
+     * @return           the created component
+     */
+    public static ActiveMQComponent activeMQComponent(String brokerURL) {
+        ActiveMQComponent answer = new ActiveMQComponent();
+        if (answer.getConfiguration() instanceof ActiveMQConfiguration) {
+            ((ActiveMQConfiguration) answer.getConfiguration()).setBrokerURL(brokerURL);
+        }
+
+        return answer;
+    }
+
+    public String getBrokerURL() {
+        if (getConfiguration() instanceof ActiveMQConfiguration) {
+            return ((ActiveMQConfiguration) getConfiguration()).getBrokerURL();
+        }
+        return null;
+    }
+
+    /**
+     * Sets the broker URL to use to connect to ActiveMQ. If none configured then localhost:61616 is used by default
+     * (however can be overridden by configuration from environment variables)
+     */
+    @Metadata(label = ""common"")
+    public void setBrokerURL(String brokerURL) {
+        if (getConfiguration() instanceof ActiveMQConfiguration) {
+            ((ActiveMQConfiguration) getConfiguration()).setBrokerURL(brokerURL);
+        }
+    }
+
+    /**
+     * Define if all Java packages are trusted or not (for Java object JMS message types). Notice its not recommended
+     * practice to send Java serialized objects over network. Setting this to true can expose security risks, so use
+     * this with care.
+     */
+    @Metadata(defaultValue = ""false"", label = ""advanced"")
+    public void setTrustAllPackages(boolean trustAllPackages) {
+        if (getConfiguration() instanceof ActiveMQConfiguration) {
+            ((ActiveMQConfiguration) getConfiguration()).setTrustAllPackages(trustAllPackages);
+        }
+    }
+
+    public boolean isTrustAllPackages() {
+        if (getConfiguration() instanceof ActiveMQConfiguration) {
+            return ((ActiveMQConfiguration) getConfiguration()).isTrustAllPackages();
+        }
+        return false;
+    }
+
+    /**
+     * Enables or disables whether a PooledConnectionFactory will be used so that when messages are sent to ActiveMQ
+     * from outside of a message consuming thread, pooling will be used rather than the default with the Spring
+     * {@link JmsTemplate} which will create a new connection, session, producer for each message then close them all
+     * down again.
+     * <p/>
+     * The default value is true.
+     */
+    @Metadata(defaultValue = ""true"", label = ""common"")
+    public void setUsePooledConnection(boolean usePooledConnection) {
+        if (getConfiguration() instanceof ActiveMQConfiguration) {
+            ((ActiveMQConfiguration) getConfiguration()).setUsePooledConnection(usePooledConnection);
+        }
+    }
+
+    public boolean isUsePooledConnection() {
+        if (getConfiguration() instanceof ActiveMQConfiguration) {
+            return ((ActiveMQConfiguration) getConfiguration()).isUsePooledConnection();
+        }
+        return true;
+    }
+
+    /**
+     * Enables or disables whether a Spring {@link SingleConnectionFactory} will be used so that when messages are sent
+     * to ActiveMQ from outside of a message consuming thread, pooling will be used rather than the default with the
+     * Spring {@link JmsTemplate} which will create a new connection, session, producer for each message then close them
+     * all down again.
+     * <p/>
+     * The default value is false and a pooled connection is used by default.
+     */
+    @Metadata(defaultValue = ""false"", label = ""common"")
+    public void setUseSingleConnection(boolean useSingleConnection) {
+        if (getConfiguration() instanceof ActiveMQConfiguration) {
+            ((ActiveMQConfiguration) getConfiguration()).setUseSingleConnection(useSingleConnection);
+        }
+    }
+
+    public boolean isUseSingleConnection() {
+        if (getConfiguration() instanceof ActiveMQConfiguration) {
+            return ((ActiveMQConfiguration) getConfiguration()).isUseSingleConnection();
+        }
+        return false;
+    }
+
+    @Override
+    protected void setProperties(Endpoint bean, Map<String, Object> parameters) throws Exception {
+        Object useSingleConnection = parameters.remove(""useSingleConnection"");
+        if (useSingleConnection != null) {
+            ((ActiveMQConfiguration) ((JmsEndpoint) bean).getConfiguration())
+                    .setUseSingleConnection(
+                            PropertyConfigurerSupport.property(getCamelContext(), boolean.class, useSingleConnection));
+        }
+        Object usePooledConnection = parameters.remove(""usePooledConnection"");
+        if (usePooledConnection != null) {
+            ((ActiveMQConfiguration) ((JmsEndpoint) bean).getConfiguration())
+                    .setUsePooledConnection(
+                            PropertyConfigurerSupport.property(getCamelContext(), boolean.class, usePooledConnection));
+        }
+        super.setProperties(bean, parameters);
+    }
+
+    protected void addPooledConnectionFactoryService(Service pooledConnectionFactoryService) {
+        pooledConnectionFactoryServiceList.add(pooledConnectionFactoryService);
+    }
+
+    protected void addSingleConnectionFactory(SingleConnectionFactory singleConnectionFactory) {
+        singleConnectionFactoryList.add(singleConnectionFactory);
+    }
+
+    @Override
+    @SuppressWarnings(""unchecked"")
+    protected String convertPathToActualDestination(String path, Map<String, Object> parameters) {
+        // support ActiveMQ destination options using the destination. prefix
+        // http://activemq.apache.org/destination-options.html
+        Map options = PropertiesHelper.extractProperties(parameters, ""destination."");
+
+        String query = URISupport.createQueryString(options);
+
+        // if we have destination options then append them to the destination
+        // name
+        if (ObjectHelper.isNotEmpty(query)) {
+            return path + ""?"" + query;
+        } else {
+            return path;
+        }
+    }
+
+    @Override
+    protected void doInit() throws Exception {
+        super.doInit();
+
+        // use OriginalDestinationPropagateStrategy by default if no custom
+        // strategy has been set
+        if (getMessageCreatedStrategy() == null) {
+            setMessageCreatedStrategy(new OriginalDestinationPropagateStrategy());
+        }
+    }
+
+    @Override
+    protected void doStop() throws Exception {
+        for (Service s : pooledConnectionFactoryServiceList) {
+            try {
+                s.stop();
+            } catch (Exception e) {
+                // ignore","[{'comment': 'I would personally rather prefer to add a logger to this class and log the errors', 'commenter': 'essobedo'}]"
10293,components/camel-activemq/src/main/java/org/apache/camel/component/activemq/ActiveMQComponent.java,"@@ -0,0 +1,283 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.activemq;
+
+import java.util.Map;
+import java.util.concurrent.CopyOnWriteArrayList;
+
+import org.apache.activemq.Service;
+import org.apache.camel.CamelContext;
+import org.apache.camel.Endpoint;
+import org.apache.camel.component.jms.JmsComponent;
+import org.apache.camel.component.jms.JmsConfiguration;
+import org.apache.camel.component.jms.JmsEndpoint;
+import org.apache.camel.component.jms.QueueBrowseStrategy;
+import org.apache.camel.spi.Metadata;
+import org.apache.camel.spi.annotations.Component;
+import org.apache.camel.support.component.PropertyConfigurerSupport;
+import org.apache.camel.util.ObjectHelper;
+import org.apache.camel.util.PropertiesHelper;
+import org.apache.camel.util.URISupport;
+import org.springframework.jms.connection.SingleConnectionFactory;
+import org.springframework.jms.core.JmsTemplate;
+
+/**
+ * The ActiveMQ Component.
+ */
+@Component(""activemq"")
+public class ActiveMQComponent extends JmsComponent {
+    private final CopyOnWriteArrayList<SingleConnectionFactory> singleConnectionFactoryList = new CopyOnWriteArrayList<>();
+    private final CopyOnWriteArrayList<Service> pooledConnectionFactoryServiceList = new CopyOnWriteArrayList<>();
+
+    public ActiveMQComponent() {
+    }
+
+    public ActiveMQComponent(CamelContext context) {
+        super(context);
+    }
+
+    public ActiveMQComponent(ActiveMQConfiguration configuration) {
+        setConfiguration(configuration);
+    }
+
+    /**
+     * Creates an <a href=""http://camel.apache.org/activemq.html"">ActiveMQ Component</a>
+     *
+     * @return the created component
+     */
+    public static ActiveMQComponent activeMQComponent() {
+        return new ActiveMQComponent();
+    }
+
+    /**
+     * Creates an <a href=""http://camel.apache.org/activemq.html"">ActiveMQ Component</a> connecting to the given
+     * <a href=""http://activemq.apache.org/configuring-transports.html"">broker URL</a>
+     *
+     * @param  brokerURL the URL to connect to
+     * @return           the created component
+     */
+    public static ActiveMQComponent activeMQComponent(String brokerURL) {
+        ActiveMQComponent answer = new ActiveMQComponent();
+        if (answer.getConfiguration() instanceof ActiveMQConfiguration) {
+            ((ActiveMQConfiguration) answer.getConfiguration()).setBrokerURL(brokerURL);
+        }
+
+        return answer;
+    }
+
+    public String getBrokerURL() {
+        if (getConfiguration() instanceof ActiveMQConfiguration) {
+            return ((ActiveMQConfiguration) getConfiguration()).getBrokerURL();
+        }
+        return null;
+    }
+
+    /**
+     * Sets the broker URL to use to connect to ActiveMQ. If none configured then localhost:61616 is used by default
+     * (however can be overridden by configuration from environment variables)
+     */
+    @Metadata(label = ""common"")
+    public void setBrokerURL(String brokerURL) {
+        if (getConfiguration() instanceof ActiveMQConfiguration) {
+            ((ActiveMQConfiguration) getConfiguration()).setBrokerURL(brokerURL);
+        }
+    }
+
+    /**
+     * Define if all Java packages are trusted or not (for Java object JMS message types). Notice its not recommended
+     * practice to send Java serialized objects over network. Setting this to true can expose security risks, so use
+     * this with care.
+     */
+    @Metadata(defaultValue = ""false"", label = ""advanced"")
+    public void setTrustAllPackages(boolean trustAllPackages) {
+        if (getConfiguration() instanceof ActiveMQConfiguration) {
+            ((ActiveMQConfiguration) getConfiguration()).setTrustAllPackages(trustAllPackages);
+        }
+    }
+
+    public boolean isTrustAllPackages() {
+        if (getConfiguration() instanceof ActiveMQConfiguration) {
+            return ((ActiveMQConfiguration) getConfiguration()).isTrustAllPackages();
+        }
+        return false;
+    }
+
+    /**
+     * Enables or disables whether a PooledConnectionFactory will be used so that when messages are sent to ActiveMQ
+     * from outside of a message consuming thread, pooling will be used rather than the default with the Spring
+     * {@link JmsTemplate} which will create a new connection, session, producer for each message then close them all
+     * down again.
+     * <p/>
+     * The default value is true.
+     */
+    @Metadata(defaultValue = ""true"", label = ""common"")
+    public void setUsePooledConnection(boolean usePooledConnection) {
+        if (getConfiguration() instanceof ActiveMQConfiguration) {
+            ((ActiveMQConfiguration) getConfiguration()).setUsePooledConnection(usePooledConnection);
+        }
+    }
+
+    public boolean isUsePooledConnection() {
+        if (getConfiguration() instanceof ActiveMQConfiguration) {
+            return ((ActiveMQConfiguration) getConfiguration()).isUsePooledConnection();
+        }
+        return true;
+    }
+
+    /**
+     * Enables or disables whether a Spring {@link SingleConnectionFactory} will be used so that when messages are sent
+     * to ActiveMQ from outside of a message consuming thread, pooling will be used rather than the default with the
+     * Spring {@link JmsTemplate} which will create a new connection, session, producer for each message then close them
+     * all down again.
+     * <p/>
+     * The default value is false and a pooled connection is used by default.
+     */
+    @Metadata(defaultValue = ""false"", label = ""common"")
+    public void setUseSingleConnection(boolean useSingleConnection) {
+        if (getConfiguration() instanceof ActiveMQConfiguration) {
+            ((ActiveMQConfiguration) getConfiguration()).setUseSingleConnection(useSingleConnection);
+        }
+    }
+
+    public boolean isUseSingleConnection() {
+        if (getConfiguration() instanceof ActiveMQConfiguration) {
+            return ((ActiveMQConfiguration) getConfiguration()).isUseSingleConnection();
+        }
+        return false;
+    }
+
+    @Override
+    protected void setProperties(Endpoint bean, Map<String, Object> parameters) throws Exception {
+        Object useSingleConnection = parameters.remove(""useSingleConnection"");
+        if (useSingleConnection != null) {
+            ((ActiveMQConfiguration) ((JmsEndpoint) bean).getConfiguration())
+                    .setUseSingleConnection(
+                            PropertyConfigurerSupport.property(getCamelContext(), boolean.class, useSingleConnection));
+        }
+        Object usePooledConnection = parameters.remove(""usePooledConnection"");
+        if (usePooledConnection != null) {
+            ((ActiveMQConfiguration) ((JmsEndpoint) bean).getConfiguration())
+                    .setUsePooledConnection(
+                            PropertyConfigurerSupport.property(getCamelContext(), boolean.class, usePooledConnection));
+        }
+        super.setProperties(bean, parameters);
+    }
+
+    protected void addPooledConnectionFactoryService(Service pooledConnectionFactoryService) {
+        pooledConnectionFactoryServiceList.add(pooledConnectionFactoryService);
+    }
+
+    protected void addSingleConnectionFactory(SingleConnectionFactory singleConnectionFactory) {
+        singleConnectionFactoryList.add(singleConnectionFactory);
+    }
+
+    @Override
+    @SuppressWarnings(""unchecked"")
+    protected String convertPathToActualDestination(String path, Map<String, Object> parameters) {
+        // support ActiveMQ destination options using the destination. prefix
+        // http://activemq.apache.org/destination-options.html
+        Map options = PropertiesHelper.extractProperties(parameters, ""destination."");
+
+        String query = URISupport.createQueryString(options);
+
+        // if we have destination options then append them to the destination
+        // name
+        if (ObjectHelper.isNotEmpty(query)) {
+            return path + ""?"" + query;
+        } else {
+            return path;
+        }
+    }
+
+    @Override
+    protected void doInit() throws Exception {
+        super.doInit();
+
+        // use OriginalDestinationPropagateStrategy by default if no custom
+        // strategy has been set
+        if (getMessageCreatedStrategy() == null) {
+            setMessageCreatedStrategy(new OriginalDestinationPropagateStrategy());
+        }
+    }
+
+    @Override
+    protected void doStop() throws Exception {
+        for (Service s : pooledConnectionFactoryServiceList) {
+            try {
+                s.stop();
+            } catch (Exception e) {
+                // ignore
+            }
+        }
+        pooledConnectionFactoryServiceList.clear();
+
+        for (SingleConnectionFactory s : singleConnectionFactoryList) {
+            try {
+                s.destroy();
+            } catch (Exception e) {
+                // ignore","[{'comment': 'ditto', 'commenter': 'essobedo'}]"
10293,components/camel-activemq/src/main/java/org/apache/camel/component/activemq/ActiveMQComponent.java,"@@ -0,0 +1,283 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.activemq;
+
+import java.util.Map;
+import java.util.concurrent.CopyOnWriteArrayList;
+
+import org.apache.activemq.Service;
+import org.apache.camel.CamelContext;
+import org.apache.camel.Endpoint;
+import org.apache.camel.component.jms.JmsComponent;
+import org.apache.camel.component.jms.JmsConfiguration;
+import org.apache.camel.component.jms.JmsEndpoint;
+import org.apache.camel.component.jms.QueueBrowseStrategy;
+import org.apache.camel.spi.Metadata;
+import org.apache.camel.spi.annotations.Component;
+import org.apache.camel.support.component.PropertyConfigurerSupport;
+import org.apache.camel.util.ObjectHelper;
+import org.apache.camel.util.PropertiesHelper;
+import org.apache.camel.util.URISupport;
+import org.springframework.jms.connection.SingleConnectionFactory;
+import org.springframework.jms.core.JmsTemplate;
+
+/**
+ * The ActiveMQ Component.
+ */
+@Component(""activemq"")
+public class ActiveMQComponent extends JmsComponent {
+    private final CopyOnWriteArrayList<SingleConnectionFactory> singleConnectionFactoryList = new CopyOnWriteArrayList<>();
+    private final CopyOnWriteArrayList<Service> pooledConnectionFactoryServiceList = new CopyOnWriteArrayList<>();
+
+    public ActiveMQComponent() {
+    }
+
+    public ActiveMQComponent(CamelContext context) {
+        super(context);
+    }
+
+    public ActiveMQComponent(ActiveMQConfiguration configuration) {
+        setConfiguration(configuration);
+    }
+
+    /**
+     * Creates an <a href=""http://camel.apache.org/activemq.html"">ActiveMQ Component</a>
+     *
+     * @return the created component
+     */
+    public static ActiveMQComponent activeMQComponent() {
+        return new ActiveMQComponent();
+    }
+
+    /**
+     * Creates an <a href=""http://camel.apache.org/activemq.html"">ActiveMQ Component</a> connecting to the given
+     * <a href=""http://activemq.apache.org/configuring-transports.html"">broker URL</a>
+     *
+     * @param  brokerURL the URL to connect to
+     * @return           the created component
+     */
+    public static ActiveMQComponent activeMQComponent(String brokerURL) {
+        ActiveMQComponent answer = new ActiveMQComponent();
+        if (answer.getConfiguration() instanceof ActiveMQConfiguration) {
+            ((ActiveMQConfiguration) answer.getConfiguration()).setBrokerURL(brokerURL);
+        }
+
+        return answer;
+    }
+
+    public String getBrokerURL() {
+        if (getConfiguration() instanceof ActiveMQConfiguration) {
+            return ((ActiveMQConfiguration) getConfiguration()).getBrokerURL();
+        }
+        return null;
+    }
+
+    /**
+     * Sets the broker URL to use to connect to ActiveMQ. If none configured then localhost:61616 is used by default
+     * (however can be overridden by configuration from environment variables)
+     */
+    @Metadata(label = ""common"")
+    public void setBrokerURL(String brokerURL) {
+        if (getConfiguration() instanceof ActiveMQConfiguration) {
+            ((ActiveMQConfiguration) getConfiguration()).setBrokerURL(brokerURL);
+        }
+    }
+
+    /**
+     * Define if all Java packages are trusted or not (for Java object JMS message types). Notice its not recommended
+     * practice to send Java serialized objects over network. Setting this to true can expose security risks, so use
+     * this with care.
+     */
+    @Metadata(defaultValue = ""false"", label = ""advanced"")
+    public void setTrustAllPackages(boolean trustAllPackages) {
+        if (getConfiguration() instanceof ActiveMQConfiguration) {
+            ((ActiveMQConfiguration) getConfiguration()).setTrustAllPackages(trustAllPackages);
+        }
+    }
+
+    public boolean isTrustAllPackages() {
+        if (getConfiguration() instanceof ActiveMQConfiguration) {
+            return ((ActiveMQConfiguration) getConfiguration()).isTrustAllPackages();
+        }
+        return false;
+    }
+
+    /**
+     * Enables or disables whether a PooledConnectionFactory will be used so that when messages are sent to ActiveMQ
+     * from outside of a message consuming thread, pooling will be used rather than the default with the Spring
+     * {@link JmsTemplate} which will create a new connection, session, producer for each message then close them all
+     * down again.
+     * <p/>
+     * The default value is true.
+     */
+    @Metadata(defaultValue = ""true"", label = ""common"")
+    public void setUsePooledConnection(boolean usePooledConnection) {
+        if (getConfiguration() instanceof ActiveMQConfiguration) {
+            ((ActiveMQConfiguration) getConfiguration()).setUsePooledConnection(usePooledConnection);
+        }
+    }
+
+    public boolean isUsePooledConnection() {
+        if (getConfiguration() instanceof ActiveMQConfiguration) {
+            return ((ActiveMQConfiguration) getConfiguration()).isUsePooledConnection();
+        }
+        return true;
+    }
+
+    /**
+     * Enables or disables whether a Spring {@link SingleConnectionFactory} will be used so that when messages are sent
+     * to ActiveMQ from outside of a message consuming thread, pooling will be used rather than the default with the
+     * Spring {@link JmsTemplate} which will create a new connection, session, producer for each message then close them
+     * all down again.
+     * <p/>
+     * The default value is false and a pooled connection is used by default.
+     */
+    @Metadata(defaultValue = ""false"", label = ""common"")
+    public void setUseSingleConnection(boolean useSingleConnection) {
+        if (getConfiguration() instanceof ActiveMQConfiguration) {
+            ((ActiveMQConfiguration) getConfiguration()).setUseSingleConnection(useSingleConnection);
+        }
+    }
+
+    public boolean isUseSingleConnection() {
+        if (getConfiguration() instanceof ActiveMQConfiguration) {
+            return ((ActiveMQConfiguration) getConfiguration()).isUseSingleConnection();
+        }
+        return false;
+    }
+
+    @Override
+    protected void setProperties(Endpoint bean, Map<String, Object> parameters) throws Exception {
+        Object useSingleConnection = parameters.remove(""useSingleConnection"");
+        if (useSingleConnection != null) {
+            ((ActiveMQConfiguration) ((JmsEndpoint) bean).getConfiguration())
+                    .setUseSingleConnection(
+                            PropertyConfigurerSupport.property(getCamelContext(), boolean.class, useSingleConnection));
+        }
+        Object usePooledConnection = parameters.remove(""usePooledConnection"");
+        if (usePooledConnection != null) {
+            ((ActiveMQConfiguration) ((JmsEndpoint) bean).getConfiguration())
+                    .setUsePooledConnection(
+                            PropertyConfigurerSupport.property(getCamelContext(), boolean.class, usePooledConnection));
+        }
+        super.setProperties(bean, parameters);
+    }
+
+    protected void addPooledConnectionFactoryService(Service pooledConnectionFactoryService) {
+        pooledConnectionFactoryServiceList.add(pooledConnectionFactoryService);
+    }
+
+    protected void addSingleConnectionFactory(SingleConnectionFactory singleConnectionFactory) {
+        singleConnectionFactoryList.add(singleConnectionFactory);
+    }
+
+    @Override
+    @SuppressWarnings(""unchecked"")
+    protected String convertPathToActualDestination(String path, Map<String, Object> parameters) {
+        // support ActiveMQ destination options using the destination. prefix
+        // http://activemq.apache.org/destination-options.html
+        Map options = PropertiesHelper.extractProperties(parameters, ""destination."");
+
+        String query = URISupport.createQueryString(options);
+
+        // if we have destination options then append them to the destination
+        // name
+        if (ObjectHelper.isNotEmpty(query)) {
+            return path + ""?"" + query;
+        } else {
+            return path;
+        }
+    }
+
+    @Override
+    protected void doInit() throws Exception {
+        super.doInit();
+
+        // use OriginalDestinationPropagateStrategy by default if no custom
+        // strategy has been set
+        if (getMessageCreatedStrategy() == null) {
+            setMessageCreatedStrategy(new OriginalDestinationPropagateStrategy());
+        }
+    }
+
+    @Override
+    protected void doStop() throws Exception {
+        for (Service s : pooledConnectionFactoryServiceList) {
+            try {
+                s.stop();
+            } catch (Exception e) {
+                // ignore
+            }
+        }
+        pooledConnectionFactoryServiceList.clear();
+
+        for (SingleConnectionFactory s : singleConnectionFactoryList) {
+            try {
+                s.destroy();
+            } catch (Exception e) {
+                // ignore
+            }
+        }
+        singleConnectionFactoryList.clear();
+
+        super.doStop();
+    }
+
+    /**
+     * Configuration of ActiveMQ
+     */
+    @Override
+    public void setConfiguration(JmsConfiguration configuration) {
+        if (configuration instanceof ActiveMQConfiguration) {
+            ((ActiveMQConfiguration) configuration).setActiveMQComponent(this);","[{'comment': '```suggestion\r\n        if (configuration instanceof ActiveMQConfiguration activeMQConfiguration) {\r\n            activeMQConfiguration.setActiveMQComponent(this);\r\n```', 'commenter': 'essobedo'}]"
10293,components/camel-activemq/src/main/java/org/apache/camel/component/activemq/ActiveMQConfiguration.java,"@@ -0,0 +1,220 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.activemq;
+
+import java.lang.reflect.Constructor;
+
+import jakarta.jms.ConnectionFactory;
+
+import org.apache.activemq.ActiveMQConnectionFactory;
+import org.apache.activemq.Service;
+import org.apache.camel.RuntimeCamelException;
+import org.apache.camel.component.jms.JmsConfiguration;
+import org.springframework.jms.connection.CachingConnectionFactory;
+import org.springframework.jms.connection.DelegatingConnectionFactory;
+import org.springframework.jms.connection.JmsTransactionManager;
+import org.springframework.jms.connection.SingleConnectionFactory;
+import org.springframework.jms.core.JmsTemplate;
+import org.springframework.transaction.PlatformTransactionManager;
+
+public class ActiveMQConfiguration extends JmsConfiguration {
+    private ActiveMQComponent activeMQComponent;
+    private String brokerURL = ActiveMQConnectionFactory.DEFAULT_BROKER_URL;
+    private volatile boolean customBrokerURL;
+    private boolean useSingleConnection;
+    private boolean usePooledConnection = true;
+    private boolean trustAllPackages;
+
+    public ActiveMQConfiguration() {
+    }
+
+    public String getBrokerURL() {
+        return brokerURL;
+    }
+
+    /**
+     * Sets the broker URL to use to connect to ActiveMQ broker.
+     */
+    public void setBrokerURL(String brokerURL) {
+        this.brokerURL = brokerURL;
+        this.customBrokerURL = true;
+    }
+
+    public boolean isUseSingleConnection() {
+        return useSingleConnection;
+    }
+
+    /**
+     * @deprecated - use JmsConfiguration#getUsername()
+     * @see        JmsConfiguration#getUsername()
+     */
+    @Deprecated
+    public String getUserName() {
+        return getUsername();
+    }
+
+    /**
+     * @deprecated - use JmsConfiguration#setUsername(String)
+     * @see        JmsConfiguration#setUsername(String)
+     */
+    @Deprecated
+    public void setUserName(String userName) {
+        setUsername(userName);
+    }
+
+    /**
+     * Enables or disables whether a Spring {@link SingleConnectionFactory} will be used so that when messages are sent
+     * to ActiveMQ from outside of a message consuming thread, pooling will be used rather than the default with the
+     * Spring {@link JmsTemplate} which will create a new connection, session, producer for each message then close them
+     * all down again.
+     * <p/>
+     * The default value is false and a pooled connection is used by default.
+     */
+    public void setUseSingleConnection(boolean useSingleConnection) {
+        this.useSingleConnection = useSingleConnection;
+    }
+
+    public boolean isUsePooledConnection() {
+        return usePooledConnection;
+    }
+
+    /**
+     * Enables or disables whether a PooledConnectionFactory will be used so that when messages are sent to ActiveMQ
+     * from outside of a message consuming thread, pooling will be used rather than the default with the Spring
+     * {@link JmsTemplate} which will create a new connection, session, producer for each message then close them all
+     * down again.
+     * <p/>
+     * The default value is true.
+     */
+    public void setUsePooledConnection(boolean usePooledConnection) {
+        this.usePooledConnection = usePooledConnection;
+    }
+
+    public boolean isTrustAllPackages() {
+        return trustAllPackages;
+    }
+
+    /**
+     * ObjectMessage objects depend on Java serialization of marshal/unmarshal object payload. This process is generally
+     * considered unsafe as malicious payload can exploit the host system. That's why starting with versions 5.12.2 and
+     * 5.13.0, ActiveMQ enforces users to explicitly whitelist packages that can be exchanged using ObjectMessages.
+     * <br/>
+     * This option can be set to <tt>true</tt> to trust all packages (eg whitelist is *).
+     * <p/>
+     * See more details at: http://activemq.apache.org/objectmessage.html
+     */
+    public void setTrustAllPackages(boolean trustAllPackages) {
+        this.trustAllPackages = trustAllPackages;
+    }
+
+    /**
+     * Factory method to create a default transaction manager if one is not specified
+     */
+    @Override
+    protected PlatformTransactionManager createTransactionManager() {
+        JmsTransactionManager answer = new JmsTransactionManager(getOrCreateConnectionFactory());
+        answer.afterPropertiesSet();
+        return answer;
+    }
+
+    protected void setActiveMQComponent(ActiveMQComponent activeMQComponent) {
+        this.activeMQComponent = activeMQComponent;
+    }
+
+    @Override
+    public void setConnectionFactory(ConnectionFactory connectionFactory) {
+        ActiveMQConnectionFactory acf = null;
+
+        ConnectionFactory target = connectionFactory;
+        if (target instanceof CachingConnectionFactory) {
+            CachingConnectionFactory ccf = (CachingConnectionFactory) target;
+            target = ccf.getTargetConnectionFactory();","[{'comment': '```suggestion\r\n        if (target instanceof CachingConnectionFactory ccf) {\r\n            target = ccf.getTargetConnectionFactory();\r\n```', 'commenter': 'essobedo'}]"
10293,components/camel-activemq/src/main/java/org/apache/camel/component/activemq/ActiveMQConfiguration.java,"@@ -0,0 +1,220 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.activemq;
+
+import java.lang.reflect.Constructor;
+
+import jakarta.jms.ConnectionFactory;
+
+import org.apache.activemq.ActiveMQConnectionFactory;
+import org.apache.activemq.Service;
+import org.apache.camel.RuntimeCamelException;
+import org.apache.camel.component.jms.JmsConfiguration;
+import org.springframework.jms.connection.CachingConnectionFactory;
+import org.springframework.jms.connection.DelegatingConnectionFactory;
+import org.springframework.jms.connection.JmsTransactionManager;
+import org.springframework.jms.connection.SingleConnectionFactory;
+import org.springframework.jms.core.JmsTemplate;
+import org.springframework.transaction.PlatformTransactionManager;
+
+public class ActiveMQConfiguration extends JmsConfiguration {
+    private ActiveMQComponent activeMQComponent;
+    private String brokerURL = ActiveMQConnectionFactory.DEFAULT_BROKER_URL;
+    private volatile boolean customBrokerURL;
+    private boolean useSingleConnection;
+    private boolean usePooledConnection = true;
+    private boolean trustAllPackages;
+
+    public ActiveMQConfiguration() {
+    }
+
+    public String getBrokerURL() {
+        return brokerURL;
+    }
+
+    /**
+     * Sets the broker URL to use to connect to ActiveMQ broker.
+     */
+    public void setBrokerURL(String brokerURL) {
+        this.brokerURL = brokerURL;
+        this.customBrokerURL = true;
+    }
+
+    public boolean isUseSingleConnection() {
+        return useSingleConnection;
+    }
+
+    /**
+     * @deprecated - use JmsConfiguration#getUsername()
+     * @see        JmsConfiguration#getUsername()
+     */
+    @Deprecated
+    public String getUserName() {
+        return getUsername();
+    }
+
+    /**
+     * @deprecated - use JmsConfiguration#setUsername(String)
+     * @see        JmsConfiguration#setUsername(String)
+     */
+    @Deprecated
+    public void setUserName(String userName) {
+        setUsername(userName);
+    }
+
+    /**
+     * Enables or disables whether a Spring {@link SingleConnectionFactory} will be used so that when messages are sent
+     * to ActiveMQ from outside of a message consuming thread, pooling will be used rather than the default with the
+     * Spring {@link JmsTemplate} which will create a new connection, session, producer for each message then close them
+     * all down again.
+     * <p/>
+     * The default value is false and a pooled connection is used by default.
+     */
+    public void setUseSingleConnection(boolean useSingleConnection) {
+        this.useSingleConnection = useSingleConnection;
+    }
+
+    public boolean isUsePooledConnection() {
+        return usePooledConnection;
+    }
+
+    /**
+     * Enables or disables whether a PooledConnectionFactory will be used so that when messages are sent to ActiveMQ
+     * from outside of a message consuming thread, pooling will be used rather than the default with the Spring
+     * {@link JmsTemplate} which will create a new connection, session, producer for each message then close them all
+     * down again.
+     * <p/>
+     * The default value is true.
+     */
+    public void setUsePooledConnection(boolean usePooledConnection) {
+        this.usePooledConnection = usePooledConnection;
+    }
+
+    public boolean isTrustAllPackages() {
+        return trustAllPackages;
+    }
+
+    /**
+     * ObjectMessage objects depend on Java serialization of marshal/unmarshal object payload. This process is generally
+     * considered unsafe as malicious payload can exploit the host system. That's why starting with versions 5.12.2 and
+     * 5.13.0, ActiveMQ enforces users to explicitly whitelist packages that can be exchanged using ObjectMessages.
+     * <br/>
+     * This option can be set to <tt>true</tt> to trust all packages (eg whitelist is *).
+     * <p/>
+     * See more details at: http://activemq.apache.org/objectmessage.html
+     */
+    public void setTrustAllPackages(boolean trustAllPackages) {
+        this.trustAllPackages = trustAllPackages;
+    }
+
+    /**
+     * Factory method to create a default transaction manager if one is not specified
+     */
+    @Override
+    protected PlatformTransactionManager createTransactionManager() {
+        JmsTransactionManager answer = new JmsTransactionManager(getOrCreateConnectionFactory());
+        answer.afterPropertiesSet();
+        return answer;
+    }
+
+    protected void setActiveMQComponent(ActiveMQComponent activeMQComponent) {
+        this.activeMQComponent = activeMQComponent;
+    }
+
+    @Override
+    public void setConnectionFactory(ConnectionFactory connectionFactory) {
+        ActiveMQConnectionFactory acf = null;
+
+        ConnectionFactory target = connectionFactory;
+        if (target instanceof CachingConnectionFactory) {
+            CachingConnectionFactory ccf = (CachingConnectionFactory) target;
+            target = ccf.getTargetConnectionFactory();
+        }
+        if (target instanceof DelegatingConnectionFactory) {
+            DelegatingConnectionFactory dcf = (DelegatingConnectionFactory) target;
+            target = dcf.getTargetConnectionFactory();","[{'comment': '```suggestion\r\n        if (target instanceof DelegatingConnectionFactory dcf) {\r\n            target = dcf.getTargetConnectionFactory();\r\n```', 'commenter': 'essobedo'}]"
10293,components/camel-activemq/src/main/java/org/apache/camel/component/activemq/ActiveMQConfiguration.java,"@@ -0,0 +1,220 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.activemq;
+
+import java.lang.reflect.Constructor;
+
+import jakarta.jms.ConnectionFactory;
+
+import org.apache.activemq.ActiveMQConnectionFactory;
+import org.apache.activemq.Service;
+import org.apache.camel.RuntimeCamelException;
+import org.apache.camel.component.jms.JmsConfiguration;
+import org.springframework.jms.connection.CachingConnectionFactory;
+import org.springframework.jms.connection.DelegatingConnectionFactory;
+import org.springframework.jms.connection.JmsTransactionManager;
+import org.springframework.jms.connection.SingleConnectionFactory;
+import org.springframework.jms.core.JmsTemplate;
+import org.springframework.transaction.PlatformTransactionManager;
+
+public class ActiveMQConfiguration extends JmsConfiguration {
+    private ActiveMQComponent activeMQComponent;
+    private String brokerURL = ActiveMQConnectionFactory.DEFAULT_BROKER_URL;
+    private volatile boolean customBrokerURL;
+    private boolean useSingleConnection;
+    private boolean usePooledConnection = true;
+    private boolean trustAllPackages;
+
+    public ActiveMQConfiguration() {
+    }
+
+    public String getBrokerURL() {
+        return brokerURL;
+    }
+
+    /**
+     * Sets the broker URL to use to connect to ActiveMQ broker.
+     */
+    public void setBrokerURL(String brokerURL) {
+        this.brokerURL = brokerURL;
+        this.customBrokerURL = true;
+    }
+
+    public boolean isUseSingleConnection() {
+        return useSingleConnection;
+    }
+
+    /**
+     * @deprecated - use JmsConfiguration#getUsername()
+     * @see        JmsConfiguration#getUsername()
+     */
+    @Deprecated
+    public String getUserName() {
+        return getUsername();
+    }
+
+    /**
+     * @deprecated - use JmsConfiguration#setUsername(String)
+     * @see        JmsConfiguration#setUsername(String)
+     */
+    @Deprecated
+    public void setUserName(String userName) {
+        setUsername(userName);
+    }
+
+    /**
+     * Enables or disables whether a Spring {@link SingleConnectionFactory} will be used so that when messages are sent
+     * to ActiveMQ from outside of a message consuming thread, pooling will be used rather than the default with the
+     * Spring {@link JmsTemplate} which will create a new connection, session, producer for each message then close them
+     * all down again.
+     * <p/>
+     * The default value is false and a pooled connection is used by default.
+     */
+    public void setUseSingleConnection(boolean useSingleConnection) {
+        this.useSingleConnection = useSingleConnection;
+    }
+
+    public boolean isUsePooledConnection() {
+        return usePooledConnection;
+    }
+
+    /**
+     * Enables or disables whether a PooledConnectionFactory will be used so that when messages are sent to ActiveMQ
+     * from outside of a message consuming thread, pooling will be used rather than the default with the Spring
+     * {@link JmsTemplate} which will create a new connection, session, producer for each message then close them all
+     * down again.
+     * <p/>
+     * The default value is true.
+     */
+    public void setUsePooledConnection(boolean usePooledConnection) {
+        this.usePooledConnection = usePooledConnection;
+    }
+
+    public boolean isTrustAllPackages() {
+        return trustAllPackages;
+    }
+
+    /**
+     * ObjectMessage objects depend on Java serialization of marshal/unmarshal object payload. This process is generally
+     * considered unsafe as malicious payload can exploit the host system. That's why starting with versions 5.12.2 and
+     * 5.13.0, ActiveMQ enforces users to explicitly whitelist packages that can be exchanged using ObjectMessages.
+     * <br/>
+     * This option can be set to <tt>true</tt> to trust all packages (eg whitelist is *).
+     * <p/>
+     * See more details at: http://activemq.apache.org/objectmessage.html
+     */
+    public void setTrustAllPackages(boolean trustAllPackages) {
+        this.trustAllPackages = trustAllPackages;
+    }
+
+    /**
+     * Factory method to create a default transaction manager if one is not specified
+     */
+    @Override
+    protected PlatformTransactionManager createTransactionManager() {
+        JmsTransactionManager answer = new JmsTransactionManager(getOrCreateConnectionFactory());
+        answer.afterPropertiesSet();
+        return answer;
+    }
+
+    protected void setActiveMQComponent(ActiveMQComponent activeMQComponent) {
+        this.activeMQComponent = activeMQComponent;
+    }
+
+    @Override
+    public void setConnectionFactory(ConnectionFactory connectionFactory) {
+        ActiveMQConnectionFactory acf = null;
+
+        ConnectionFactory target = connectionFactory;
+        if (target instanceof CachingConnectionFactory) {
+            CachingConnectionFactory ccf = (CachingConnectionFactory) target;
+            target = ccf.getTargetConnectionFactory();
+        }
+        if (target instanceof DelegatingConnectionFactory) {
+            DelegatingConnectionFactory dcf = (DelegatingConnectionFactory) target;
+            target = dcf.getTargetConnectionFactory();
+        }
+        if (target instanceof ActiveMQConnectionFactory) {
+            acf = (ActiveMQConnectionFactory) target;
+        }","[{'comment': 'Would it make sense to use if / else if blocks instead in this case? ', 'commenter': 'essobedo'}]"
10293,components/camel-activemq/src/main/java/org/apache/camel/component/activemq/OriginalDestinationPropagateStrategy.java,"@@ -0,0 +1,56 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.activemq;
+
+import jakarta.jms.Message;
+import jakarta.jms.Session;
+
+import org.apache.activemq.command.ActiveMQDestination;
+import org.apache.activemq.command.ActiveMQMessage;
+import org.apache.camel.Exchange;
+import org.apache.camel.component.jms.JmsMessage;
+import org.apache.camel.component.jms.MessageCreatedStrategy;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * A strategy to enrich JMS message with their original destination if the Camel route originates from a JMS
+ * destination.
+ */
+public class OriginalDestinationPropagateStrategy implements MessageCreatedStrategy {
+
+    private static final transient Logger LOG = LoggerFactory.getLogger(OriginalDestinationPropagateStrategy.class);
+
+    @Override
+    public void onMessageCreated(Message message, Session session, Exchange exchange, Throwable cause) {
+        if (exchange.getIn() instanceof JmsMessage) {
+            JmsMessage msg = exchange.getIn(JmsMessage.class);
+            Message jms = msg.getJmsMessage();
+            if (jms != null && jms instanceof ActiveMQMessage && message instanceof ActiveMQMessage) {
+                ActiveMQMessage amq = (ActiveMQMessage) jms;
+                if (amq.getOriginalDestination() == null) {
+                    ActiveMQDestination from = amq.getDestination();
+                    if (from != null) {
+                        LOG.trace(""Setting OriginalDestination: {} on {}"", from, message);
+                        ((ActiveMQMessage) message).setOriginalDestination(from);","[{'comment': '```suggestion\r\n        if (exchange.getIn() instanceof JmsMessage msg) {\r\n            Message jms = msg.getJmsMessage();\r\n            if (jms instanceof ActiveMQMessage amq && message instanceof ActiveMQMessage activeMQMessage) {\r\n                if (amq.getOriginalDestination() == null) {\r\n                    ActiveMQDestination from = amq.getDestination();\r\n                    if (from != null) {\r\n                        LOG.trace(""Setting OriginalDestination: {} on {}"", from, message);\r\n                        activeMQMessage.setOriginalDestination(from);\r\n```', 'commenter': 'essobedo'}]"
10293,components/camel-activemq/src/main/java/org/apache/camel/component/activemq/converter/ActiveMQMessageConverter.java,"@@ -0,0 +1,97 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.activemq.converter;
+
+import java.io.Serializable;
+
+import jakarta.jms.JMSException;
+import jakarta.jms.Message;
+import jakarta.jms.MessageListener;
+
+import org.apache.activemq.command.ActiveMQMessage;
+import org.apache.activemq.command.ActiveMQObjectMessage;
+import org.apache.activemq.command.ActiveMQTextMessage;
+import org.apache.camel.Converter;
+import org.apache.camel.Exchange;
+import org.apache.camel.Processor;
+import org.apache.camel.component.jms.JmsBinding;
+
+@Converter(generateLoader = true)
+public class ActiveMQMessageConverter {
+    private JmsBinding binding = new JmsBinding();
+
+    /**
+     * Converts the inbound message exchange to an ActiveMQ JMS message
+     *
+     * @return the ActiveMQ message
+     */
+    @Converter
+    public ActiveMQMessage toMessage(Exchange exchange) throws JMSException {
+        ActiveMQMessage message = createActiveMQMessage(exchange);
+        getBinding().appendJmsProperties(message, exchange);
+        return message;
+    }
+
+    /**
+     * Allows a JMS {@link MessageListener} to be converted to a Camel {@link Processor} so that we can provide better
+     * <a href="""">Bean Integration</a> so that we can use any JMS MessageListener in in Camel as a bean
+     *
+     * @param  listener the JMS message listener
+     * @return          a newly created Camel Processor which when invoked will invoke
+     *                  {@link MessageListener#onMessage(Message)}
+     */
+    @Converter
+    public Processor toProcessor(final MessageListener listener) {
+        return new Processor() {
+            public void process(Exchange exchange) throws Exception {
+                Message message = toMessage(exchange);
+                listener.onMessage(message);
+            }
+
+            @Override
+            public String toString() {
+                return ""Processor of MessageListener: "" + listener;
+            }
+        };
+    }
+
+    private static ActiveMQMessage createActiveMQMessage(Exchange exchange) throws JMSException {
+        Object body = exchange.getIn().getBody();
+        if (body instanceof String) {
+            ActiveMQTextMessage answer = new ActiveMQTextMessage();
+            answer.setText((String) body);","[{'comment': '```suggestion\r\n        if (body instanceof String bodyAsString) {\r\n            ActiveMQTextMessage answer = new ActiveMQTextMessage();\r\n            answer.setText(bodyAsString);\r\n```', 'commenter': 'essobedo'}]"
10293,components/camel-activemq/src/main/java/org/apache/camel/component/activemq/converter/ActiveMQMessageConverter.java,"@@ -0,0 +1,97 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.activemq.converter;
+
+import java.io.Serializable;
+
+import jakarta.jms.JMSException;
+import jakarta.jms.Message;
+import jakarta.jms.MessageListener;
+
+import org.apache.activemq.command.ActiveMQMessage;
+import org.apache.activemq.command.ActiveMQObjectMessage;
+import org.apache.activemq.command.ActiveMQTextMessage;
+import org.apache.camel.Converter;
+import org.apache.camel.Exchange;
+import org.apache.camel.Processor;
+import org.apache.camel.component.jms.JmsBinding;
+
+@Converter(generateLoader = true)
+public class ActiveMQMessageConverter {
+    private JmsBinding binding = new JmsBinding();
+
+    /**
+     * Converts the inbound message exchange to an ActiveMQ JMS message
+     *
+     * @return the ActiveMQ message
+     */
+    @Converter
+    public ActiveMQMessage toMessage(Exchange exchange) throws JMSException {
+        ActiveMQMessage message = createActiveMQMessage(exchange);
+        getBinding().appendJmsProperties(message, exchange);
+        return message;
+    }
+
+    /**
+     * Allows a JMS {@link MessageListener} to be converted to a Camel {@link Processor} so that we can provide better
+     * <a href="""">Bean Integration</a> so that we can use any JMS MessageListener in in Camel as a bean
+     *
+     * @param  listener the JMS message listener
+     * @return          a newly created Camel Processor which when invoked will invoke
+     *                  {@link MessageListener#onMessage(Message)}
+     */
+    @Converter
+    public Processor toProcessor(final MessageListener listener) {
+        return new Processor() {
+            public void process(Exchange exchange) throws Exception {
+                Message message = toMessage(exchange);
+                listener.onMessage(message);
+            }
+
+            @Override
+            public String toString() {
+                return ""Processor of MessageListener: "" + listener;
+            }
+        };
+    }
+
+    private static ActiveMQMessage createActiveMQMessage(Exchange exchange) throws JMSException {
+        Object body = exchange.getIn().getBody();
+        if (body instanceof String) {
+            ActiveMQTextMessage answer = new ActiveMQTextMessage();
+            answer.setText((String) body);
+            return answer;
+        } else if (body instanceof Serializable) {
+            ActiveMQObjectMessage answer = new ActiveMQObjectMessage();
+            answer.setObject((Serializable) body);","[{'comment': '```suggestion\r\n        } else if (body instanceof Serializable bodyAsObject) {\r\n            ActiveMQObjectMessage answer = new ActiveMQObjectMessage();\r\n            answer.setObject(bodyAsObject);\r\n```', 'commenter': 'essobedo'}]"
10293,parent/pom.xml,"@@ -50,6 +50,7 @@
         <checkstyle.failOnViolation>false</checkstyle.failOnViolation>
         <!-- dependency versions -->
         <abdera-version>1.1.3</abdera-version>
+        <activemq-version>5.18.1</activemq-version>","[{'comment': ""I'm wondering if we need to add it also to `camel-dependencies/pom.xml`"", 'commenter': 'essobedo'}, {'comment': 'regen can do that', 'commenter': 'davsclaus'}, {'comment': 'Good to know, I was not sure', 'commenter': 'essobedo'}]"
10315,components/camel-kafka/src/main/java/org/apache/camel/component/kafka/KafkaFetchRecords.java,"@@ -358,6 +358,10 @@ protected void startPolling() {
             if (LOG.isTraceEnabled()) {
                 LOG.trace(""The kafka consumer was woken up while polling on thread {} for {}"", threadId, getPrintableTopic());
             }
+        } catch (Error e) { // NOSONAR - rethrown","[{'comment': 'I kinda forgot whether the order of the catch matters, eg I would assume this should be last, so regular exception can be caught for the normal exceptions', 'commenter': 'davsclaus'}, {'comment': 'Yeah, if we were to implement this ... it would have to be the last one, indeed. ', 'commenter': 'orpiske'}, {'comment': '@orpiske Although it would not resolve the problem entirely, capturing the error and implementing appropriate logging would provide valuable insights to the developer regarding the occurrences of poll timeouts and the consumer leaving the group.', 'commenter': 'devdeegaw'}, {'comment': '@orpiske We found the root cause during our usage of the Spring Kafka framework (KafkaMessageListenerContainer as the listener for message consumption). However, thanks to the error handling and logging capabilities provided by the framework, we were able to capture and log the errors, despite not yet determining the root cause.', 'commenter': 'devdeegaw'}, {'comment': ""The problem is: just because it worked on your particular scenario, there's no guarantee it would work reliably (or work at all) on all others that fall on the same category (i.e.: all other sub-classes of Error).\r\n\r\n"", 'commenter': 'orpiske'}]"
10388,core/camel-core-languages/src/main/java/org/apache/camel/language/csimple/CSimpleHelper.java,"@@ -163,6 +178,40 @@ public static String bodyOneLine(Exchange exchange) {
         return body;
     }
 
+    public static String prettyBody(Exchange exchange) {
+        String body = exchange.getIn().getBody(String.class);
+
+        if (body == null) {
+            return null;
+        } else if (body.startsWith(""{"") && body.endsWith(""}"") || body.startsWith(""["") && body.endsWith(""]"")) {
+            body = Jsoner.prettyPrint(body); //json
+        } else if (body.startsWith(""<"") && body.endsWith("">"")) {
+            return CSimpleHelper.prettyXml(body); //xml
+        }","[{'comment': 'You should rather rely on the content type (aka the header `Exchange.CONTENT_TYPE`)', 'commenter': 'essobedo'}, {'comment': 'is this header always set? What if user load data from a file?', 'commenter': 'gilvansfilho'}]"
10388,core/camel-core-languages/src/main/java/org/apache/camel/language/csimple/CSimpleHelper.java,"@@ -163,6 +178,40 @@ public static String bodyOneLine(Exchange exchange) {
         return body;
     }
 
+    public static String prettyBody(Exchange exchange) {
+        String body = exchange.getIn().getBody(String.class);
+
+        if (body == null) {
+            return null;
+        } else if (body.startsWith(""{"") && body.endsWith(""}"") || body.startsWith(""["") && body.endsWith(""]"")) {
+            body = Jsoner.prettyPrint(body); //json
+        } else if (body.startsWith(""<"") && body.endsWith("">"")) {
+            return CSimpleHelper.prettyXml(body); //xml
+        }
+
+        return body;
+    }
+
+    private static String prettyXml(String rawXml) {
+        try {
+            InputSource src = new InputSource(new StringReader(rawXml));
+            Document document = DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(src);","[{'comment': 'If you get the content of the body as `InputStream`, you could use `StreamSource` instead which would prevent to parse it first', 'commenter': 'essobedo'}, {'comment': 'I will replace by `org.apache.camel.util.xml.XmlPrettyPrinter`', 'commenter': 'gilvansfilho'}]"
10388,core/camel-core-languages/src/main/java/org/apache/camel/language/csimple/CSimpleHelper.java,"@@ -163,6 +178,40 @@ public static String bodyOneLine(Exchange exchange) {
         return body;
     }
 
+    public static String prettyBody(Exchange exchange) {
+        String body = exchange.getIn().getBody(String.class);
+
+        if (body == null) {
+            return null;
+        } else if (body.startsWith(""{"") && body.endsWith(""}"") || body.startsWith(""["") && body.endsWith(""]"")) {
+            body = Jsoner.prettyPrint(body); //json
+        } else if (body.startsWith(""<"") && body.endsWith("">"")) {
+            return CSimpleHelper.prettyXml(body); //xml
+        }
+
+        return body;
+    }
+
+    private static String prettyXml(String rawXml) {
+        try {
+            InputSource src = new InputSource(new StringReader(rawXml));
+            Document document = DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(src);
+
+            TransformerFactory transformerFactory = TransformerFactory.newInstance();
+            transformerFactory.setAttribute(""indent-number"", 2);
+            Transformer transformer = transformerFactory.newTransformer();
+            transformer.setOutputProperty(OutputKeys.ENCODING, ""UTF-8"");
+            transformer.setOutputProperty(OutputKeys.OMIT_XML_DECLARATION, ""yes"");","[{'comment': 'Why remove the XML declaration? without it, you cannot easily know the encoding to use to parse the content', 'commenter': 'essobedo'}, {'comment': 'I was looking a way to use original XML Declaration instead replace with new one (which is what `Transformer` does) but I am going to replace this block by `org.apache.camel.util.xml.XmlPrettyPrinter`', 'commenter': 'gilvansfilho'}]"
10388,core/camel-core-languages/src/main/java/org/apache/camel/language/csimple/CSimpleHelper.java,"@@ -163,6 +178,40 @@ public static String bodyOneLine(Exchange exchange) {
         return body;
     }
 
+    public static String prettyBody(Exchange exchange) {
+        String body = exchange.getIn().getBody(String.class);
+
+        if (body == null) {
+            return null;
+        } else if (body.startsWith(""{"") && body.endsWith(""}"") || body.startsWith(""["") && body.endsWith(""]"")) {
+            body = Jsoner.prettyPrint(body); //json
+        } else if (body.startsWith(""<"") && body.endsWith("">"")) {
+            return CSimpleHelper.prettyXml(body); //xml
+        }
+
+        return body;
+    }
+
+    private static String prettyXml(String rawXml) {
+        try {
+            InputSource src = new InputSource(new StringReader(rawXml));","[{'comment': ""Please, can you confirm this won't leak? I am under the impression `InputSource` won't close it (same thing if you use a `InputStream`). "", 'commenter': 'orpiske'}, {'comment': 'I will replace by `org.apache.camel.util.xml.XmlPrettyPrinter`', 'commenter': 'gilvansfilho'}]"
10388,core/camel-core-languages/src/main/java/org/apache/camel/language/csimple/CSimpleHelper.java,"@@ -163,6 +165,30 @@ public static String bodyOneLine(Exchange exchange) {
         return body;
     }
 
+    public static String prettyBody(Exchange exchange) {
+        String body = exchange.getIn().getBody(String.class);
+
+        if (body == null) {
+            return null;
+        } else if (body.startsWith(""{"") && body.endsWith(""}"") || body.startsWith(""["") && body.endsWith(""]"")) {
+            body = Jsoner.prettyPrint(body.trim()); //json
+        } else if (body.startsWith(""<"") && body.endsWith("">"")) {
+            return CSimpleHelper.prettyXml(body.trim()); //xml
+        }
+
+        return body;
+    }
+
+    private static String prettyXml(String rawXml) {
+        try {
+            boolean includeDeclaration = rawXml.startsWith(""<?xml"");
+            return XmlPrettyPrinter.pettyPrint(rawXml, 2, includeDeclaration);
+        } catch (Exception e) {
+            e.printStackTrace();","[{'comment': 'remove this dumping stacktrace', 'commenter': 'davsclaus'}]"
10388,core/camel-xml-jaxp-util/src/test/resources/log4j2.properties,"@@ -0,0 +1,32 @@
+## ---------------------------------------------------------------------------
+## Licensed to the Apache Software Foundation (ASF) under one or more
+## contributor license agreements.  See the NOTICE file distributed with
+## this work for additional information regarding copyright ownership.
+## The ASF licenses this file to You under the Apache License, Version 2.0
+## (the ""License""); you may not use this file except in compliance with
+## the License.  You may obtain a copy of the License at
+##
+##      http://www.apache.org/licenses/LICENSE-2.0
+##
+## Unless required by applicable law or agreed to in writing, software
+## distributed under the License is distributed on an ""AS IS"" BASIS,
+## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+## See the License for the specific language governing permissions and
+## limitations under the License.
+## ---------------------------------------------------------------------------
+appender.console.type = Console
+appender.console.name = console
+appender.console.layout.type = PatternLayout
+appender.console.layout.pattern = %d [%-15.15t] %-5p %-30.30c{1} - %m%n
+
+appender.file.type = File
+appender.file.name = file
+appender.file.fileName = target/camel-xml-jaxp-test.log","[{'comment': 'camel-xml-jaxp-util-test.log', 'commenter': 'davsclaus'}]"
10388,core/camel-xml-jaxp-util/pom.xml,"@@ -0,0 +1,72 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one or more
+    contributor license agreements.  See the NOTICE file distributed with
+    this work for additional information regarding copyright ownership.
+    The ASF licenses this file to You under the Apache License, Version 2.0
+    (the ""License""); you may not use this file except in compliance with
+    the License.  You may obtain a copy of the License at
+
+         http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an ""AS IS"" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+
+-->
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"">
+    <modelVersion>4.0.0</modelVersion>
+
+    <parent>
+        <groupId>org.apache.camel</groupId>
+        <artifactId>core</artifactId>
+        <version>4.0.0-SNAPSHOT</version>
+    </parent>
+
+    <artifactId>camel-xml-jaxp-util</artifactId>
+    <packaging>jar</packaging>
+    <name>Camel :: XML JAXP Util</name>
+    <description>Camel XML JAXP Util</description>
+
+    <properties>
+        <firstVersion>3.0.0</firstVersion>","[{'comment': '4.0.0', 'commenter': 'davsclaus'}]"
10388,core/camel-xml-jaxp-util/pom.xml,"@@ -0,0 +1,72 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one or more
+    contributor license agreements.  See the NOTICE file distributed with
+    this work for additional information regarding copyright ownership.
+    The ASF licenses this file to You under the Apache License, Version 2.0
+    (the ""License""); you may not use this file except in compliance with
+    the License.  You may obtain a copy of the License at
+
+         http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an ""AS IS"" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+
+-->
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"">
+    <modelVersion>4.0.0</modelVersion>
+
+    <parent>
+        <groupId>org.apache.camel</groupId>
+        <artifactId>core</artifactId>
+        <version>4.0.0-SNAPSHOT</version>
+    </parent>
+
+    <artifactId>camel-xml-jaxp-util</artifactId>
+    <packaging>jar</packaging>
+    <name>Camel :: XML JAXP Util</name>
+    <description>Camel XML JAXP Util</description>
+
+    <properties>
+        <firstVersion>3.0.0</firstVersion>
+        <label>core,xml</label>
+        <camel-prepare-component>true</camel-prepare-component>","[{'comment': 'I dont think this is needed as this is just util', 'commenter': 'davsclaus'}]"
10388,core/camel-support/src/main/java/org/apache/camel/support/builder/ExpressionBuilder.java,"@@ -2036,4 +2038,42 @@ public String toString() {
         };
     }
 
+    /**
+     * Returns the expression for the message body as pretty formatted string
+     */
+    public static Expression prettyBodyExpression() {
+        return new ExpressionAdapter() {
+            @Override
+            public Object evaluate(Exchange exchange) {
+                String body = exchange.getIn().getBody(String.class);
+
+                if (body == null) {
+                    return null;
+                } else if (body.startsWith(""{"") && body.endsWith(""}"") || body.startsWith(""["") && body.endsWith(""]"")) {
+                    return Jsoner.prettyPrint(body); //json
+                } else if(body.startsWith(""<"") && body.endsWith("">"")) {
+                    return ExpressionBuilder.prettyXml(body); //xml
+
+                }
+
+                return body;
+            }
+
+            @Override
+            public String toString() {
+                return ""prettyBody()"";
+            }
+        };
+    }
+
+    private static String prettyXml(String rawXml) {
+        try {
+            boolean includeDeclaration = rawXml.startsWith(""<?xml"");
+            return XmlPrettyPrinter.pettyPrint(rawXml, 2, includeDeclaration);
+        } catch (Exception e) {
+            e.printStackTrace();","[{'comment': 'remove', 'commenter': 'davsclaus'}]"
10388,core/camel-support/src/main/java/org/apache/camel/support/builder/ExpressionBuilder.java,"@@ -2036,4 +2038,42 @@ public String toString() {
         };
     }
 
+    /**
+     * Returns the expression for the message body as pretty formatted string
+     */
+    public static Expression prettyBodyExpression() {
+        return new ExpressionAdapter() {
+            @Override
+            public Object evaluate(Exchange exchange) {
+                String body = exchange.getIn().getBody(String.class);
+
+                if (body == null) {
+                    return null;
+                } else if (body.startsWith(""{"") && body.endsWith(""}"") || body.startsWith(""["") && body.endsWith(""]"")) {
+                    return Jsoner.prettyPrint(body); //json
+                } else if(body.startsWith(""<"") && body.endsWith("">"")) {","[{'comment': 'fix checkstyle on code,\r\n\r\nrun install -P format,fastinstall', 'commenter': 'davsclaus'}, {'comment': 'I ran it and nothing happens. Running with `-P sourcecheck` I could see that checkstyle error is at `core/camel-support/src/test/java/org/apache/camel/support/RestConsumerContextPathMatcherTest.java` which was not changed by this PR.\r\n\r\nAccording with checkstyle this `https://github.com/apache/camel/blob/main/core/camel-support/src/test/java/org/apache/camel/support/RestConsumerContextPathMatcherTest.java#L29` must be `final`\r\n\r\nDoing so introduces a new error as below:\r\n```\r\n[ERROR] Tests run: 6, Failures: 1, Errors: 0, Skipped: 0, Time elapsed: 0.048 s <<< FAILURE! -- in org.apache.camel.support.RestConsumerContextPathMatcherTest\r\n[ERROR] org.apache.camel.support.RestConsumerContextPathMatcherTest.testRestConsumerContextPathMatcherWithAmbiguousPaths -- Time elapsed: 0.022 s <<< FAILURE!\r\norg.opentest4j.AssertionFailedError: Expected java.lang.IllegalStateException to be thrown, but nothing was thrown.\r\n```', 'commenter': 'gilvansfilho'}]"
10388,core/camel-core-languages/pom.xml,"@@ -51,6 +51,11 @@
             <artifactId>camel-support</artifactId>
         </dependency>
 
+        <dependency>
+            <groupId>org.apache.camel</groupId>
+            <artifactId>camel-xml-jaxp</artifactId>","[{'comment': 'should it not be camel-xml-jaxp-util', 'commenter': 'davsclaus'}]"
10388,core/camel-core-languages/src/main/java/org/apache/camel/language/csimple/CSimpleHelper.java,"@@ -163,6 +169,30 @@ public static String bodyOneLine(Exchange exchange) {
         return body;
     }
 
+    public static String prettyBody(Exchange exchange) {
+        String body = exchange.getIn().getBody(String.class);
+
+        if (body == null) {
+            return null;
+        } else if (body.startsWith(""{"") && body.endsWith(""}"") || body.startsWith(""["") && body.endsWith(""]"")) {
+            body = Jsoner.prettyPrint(body.trim()); //json
+        } else if (body.startsWith(""<"") && body.endsWith("">"")) {
+            return CSimpleHelper.prettyXml(body.trim()); //xml
+        }
+
+        return body;
+    }
+
+    private static String prettyXml(String rawXml) {
+        try {
+            boolean includeDeclaration = rawXml.startsWith(""<?xml"");
+            return XmlPrettyPrinter.pettyPrint(rawXml, 2, includeDeclaration);
+        } catch (Exception e) {
+            LOG.warn(""Something went wrong when trying to pretty format. Returning the raw value"");","[{'comment': 'Remove this WARN', 'commenter': 'davsclaus'}]"
10388,core/camel-support/src/main/java/org/apache/camel/support/builder/ExpressionBuilder.java,"@@ -2036,4 +2042,41 @@ public String toString() {
         };
     }
 
+    /**
+     * Returns the expression for the message body as pretty formatted string
+     */
+    public static Expression prettyBodyExpression() {
+        return new ExpressionAdapter() {
+            @Override
+            public Object evaluate(Exchange exchange) {
+                String body = exchange.getIn().getBody(String.class);
+
+                if (body == null) {
+                    return null;
+                } else if (body.startsWith(""{"") && body.endsWith(""}"") || body.startsWith(""["") && body.endsWith(""]"")) {
+                    return Jsoner.prettyPrint(body); //json
+                } else if(body.startsWith(""<"") && body.endsWith("">"")) {
+                    return ExpressionBuilder.prettyXml(body); //xml
+                }
+
+                return body;
+            }
+
+            @Override
+            public String toString() {
+                return ""prettyBody()"";
+            }
+        };
+    }
+
+    private static String prettyXml(String rawXml) {
+        try {
+            boolean includeDeclaration = rawXml.startsWith(""<?xml"");
+            return XmlPrettyPrinter.pettyPrint(rawXml, 2, includeDeclaration);
+        } catch (Exception e) {
+            LOG.warn(""Something went wrong when trying to pretty format. Returning the raw value"");","[{'comment': 'Remove this WARN', 'commenter': 'davsclaus'}]"
10388,core/camel-xml-jaxp-util/src/main/java/org/apache/camel/util/xml/XmlPrettyPrinter.java,"@@ -47,6 +46,23 @@ public interface ColorPrintElement {
         String color(int type, String value);
     }
 
+    /**
+     * Pad the string with leading spaces
+     *
+     * @param level  level
+     * @param blanks number of blanks per level
+     */
+    private static String padString(int level, int blanks) {","[{'comment': 'Can you do what @orpiske did with the repeat stuff', 'commenter': 'davsclaus'}]"
10388,core/camel-core-languages/src/main/docs/modules/languages/pages/simple-language.adoc,"@@ -96,6 +96,8 @@ converted body can be null.
 
 |bodyOneLine | String | Converts the body to a String and removes all line-breaks so the string is in one line.
 
+|prettyBody | String | Converts the body to a String and pretty print if JSON or XML.","[{'comment': 'Converts the body to a String, and attempts to pretty print if JSon or XML, otherwise the body is returned as the String value.', 'commenter': 'davsclaus'}]"
10399,core/camel-base-engine/src/main/java/org/apache/camel/impl/engine/AbstractCamelContext.java,"@@ -175,12 +175,7 @@
 import org.apache.camel.support.service.BaseService;
 import org.apache.camel.support.service.ServiceHelper;
 import org.apache.camel.support.startup.DefaultStartupStepRecorder;
-import org.apache.camel.util.IOHelper;
-import org.apache.camel.util.ObjectHelper;
-import org.apache.camel.util.StopWatch;
-import org.apache.camel.util.StringHelper;
-import org.apache.camel.util.TimeUtils;
-import org.apache.camel.util.URISupport;
+import org.apache.camel.util.*;","[{'comment': ""Please don't use * import"", 'commenter': 'oscerd'}]"
10399,core/camel-core/src/test/java/org/apache/camel/impl/engine/MyBean.java,"@@ -0,0 +1,8 @@
+package org.apache.camel.impl.engine;","[{'comment': 'License is missing', 'commenter': 'oscerd'}]"
10399,core/camel-util/src/main/java/org/apache/camel/util/UnsafeUriCharactersDecoder.java,"@@ -0,0 +1,55 @@
+package org.apache.camel.util;","[{'comment': 'License is missing', 'commenter': 'oscerd'}]"
10399,core/camel-base-engine/src/main/java/org/apache/camel/impl/engine/AbstractCamelContext.java,"@@ -710,21 +715,28 @@ public Collection<Endpoint> removeEndpoints(String uri) throws Exception {
             answer.add(oldEndpoint);
             stopServices(oldEndpoint);
         } else {
-            List<NormalizedUri> toRemove = new ArrayList<>();
-            for (Map.Entry<NormalizedUri, Endpoint> entry : endpoints.entrySet()) {
-                oldEndpoint = entry.getValue();
-                if (EndpointHelper.matchEndpoint(this, oldEndpoint.getEndpointUri(), uri)) {
-                    try {
-                        stopServices(oldEndpoint);
-                    } catch (Exception e) {
-                        LOG.warn(""Error stopping endpoint {}. This exception will be ignored."", oldEndpoint, e);
+            String decodeUri = unsafeUriCharactersDecodeWithOutPercent(uri);
+            oldEndpoint = endpoints.remove(getEndpointKey(decodeUri));
+            if(oldEndpoint != null){
+                answer.add(oldEndpoint);
+                stopServices(oldEndpoint);
+            } else {
+                List<NormalizedUri> toRemove = new ArrayList<>();
+                for (Map.Entry<NormalizedUri, Endpoint> entry : endpoints.entrySet()) {
+                    oldEndpoint = entry.getValue();
+                    if (EndpointHelper.matchEndpoint(this, oldEndpoint.getEndpointUri(), uri)) {
+                        try {
+                            stopServices(oldEndpoint);
+                        } catch (Exception e) {
+                            LOG.warn(""Error stopping endpoint "" + oldEndpoint + "". This exception will be ignored."", e);","[{'comment': 'Just one minor thing. Log like we used to do before (i.e.; using log markers). Like this:\r\n```\r\nLOG.warn(""Error stopping endpoint {}. This exception will be ignored."", oldEndpoint, e);\r\n```', 'commenter': 'orpiske'}]"
10399,core/camel-util/src/main/java/org/apache/camel/util/UnsafeUriCharactersDecoder.java,"@@ -0,0 +1,71 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.util;
+
+
+import java.util.HashMap;
+import java.util.Map;
+
+public final class UnsafeUriCharactersDecoder {
+    private static final Map<String,String> unsafeStringsRfc1738;
+
+    static {
+        unsafeStringsRfc1738 = new HashMap<>();
+        unsafeStringsRfc1738.put(""%22"",""\"""");
+        unsafeStringsRfc1738.put(""%3C"",""<"");
+        unsafeStringsRfc1738.put(""%3E"","">"");
+        unsafeStringsRfc1738.put(""%7B"",""{"");
+        unsafeStringsRfc1738.put(""%7D"",""}"");
+        unsafeStringsRfc1738.put(""%7C"",""|"");
+        unsafeStringsRfc1738.put(""%5C"",""\\\\"");
+        unsafeStringsRfc1738.put(""%5E"",""^"");
+        unsafeStringsRfc1738.put(""%7E"",""~"");
+        unsafeStringsRfc1738.put(""%5B"",""["");
+        unsafeStringsRfc1738.put(""%5D"",""]"");
+        unsafeStringsRfc1738.put(""%60"",""`"");
+        unsafeStringsRfc1738.put(""%20"","" "");
+        unsafeStringsRfc1738.put(""%23"",""#"");
+    }
+
+    public static String decode(String uri){","[{'comment': 'Maybe add a bit more comments on this method? Ideally, a unit test case so that we/contributors/users know what to expect as in and out of this method?', 'commenter': 'orpiske'}]"
10399,core/camel-util/src/main/java/org/apache/camel/util/URISupport.java,"@@ -22,14 +22,7 @@
 import java.net.URLEncoder;
 import java.nio.charset.Charset;
 import java.nio.charset.StandardCharsets;
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.Iterator;
-import java.util.LinkedHashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
+import java.util.*;","[{'comment': 'This will cause the checkstyle to fail. Star imports are ok for static imports, but not for the regular ones.', 'commenter': 'orpiske'}]"
10488,components/camel-xslt/src/main/java/org/apache/camel/component/xslt/XsltBuilder.java,"@@ -463,7 +481,7 @@ protected void configureTransformer(Transformer transformer, Exchange exchange)
         addParameters(transformer, getParameters());
         transformer.setParameter(""exchange"", exchange);
         transformer.setParameter(""in"", exchange.getIn());
-        transformer.setParameter(""out"", exchange.getOut());
+        transformer.setParameter(""out"", exchange.getMessage());","[{'comment': 'This is not related to this PR and it should be as before', 'commenter': 'davsclaus'}]"
10488,components/camel-xslt-saxon/src/main/java/org/apache/camel/component/xslt/saxon/XsltSaxonEndpoint.java,"@@ -209,8 +209,7 @@ protected XsltSaxonBuilder createXsltBuilder() throws Exception {
             }
         }
 
-        if (factory instanceof TransformerFactoryImpl) {
-            TransformerFactoryImpl tf = (TransformerFactoryImpl) factory;
+        if (factory instanceof TransformerFactoryImpl tf) {","[{'comment': 'This code style is only java 17 and as such this feature cannot be backported to 3.x. \r\n\r\nThis PR is not related to this change, so its better to keep code as before, as it makes backporting bugs and other PRs easier from v4 to v3', 'commenter': 'davsclaus'}, {'comment': ""I'll revert this."", 'commenter': 'ammachado'}]"
10488,components/camel-xslt-saxon/src/main/java/org/apache/camel/component/xslt/saxon/XsltSaxonBuilder.java,"@@ -56,4 +69,66 @@ public void setAllowStAX(boolean allowStAX) {
     protected XmlSourceHandlerFactoryImpl createXmlSourceHandlerFactoryImpl() {
         return new SaxonXmlSourceHandlerFactoryImpl();
     }
+
+    @Override
+    protected Templates createTemplates(TransformerFactory factory, Source source) throws TransformerConfigurationException {
+        final Templates templates = super.createTemplates(factory, source);
+        if (templates instanceof TemplatesImpl templatesImpl && getXsltMessageLogger() != null) {","[{'comment': 'Sorry again one of those java 17 only, if this feature should be backported to 3.x', 'commenter': 'davsclaus'}, {'comment': 'Fixed.', 'commenter': 'ammachado'}]"
10549,components/camel-opensearch/src/test/java/org/apache/camel/component/opensearch/integration/OpensearchGetSearchDeleteExistsUpdateIT.java,"@@ -0,0 +1,913 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.opensearch.integration;
+
+import java.io.ByteArrayInputStream;
+import java.io.StringReader;
+import java.nio.charset.StandardCharsets;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Objects;
+import java.util.concurrent.TimeUnit;
+
+import com.fasterxml.jackson.annotation.JsonInclude;
+import com.fasterxml.jackson.databind.JsonNode;
+import com.fasterxml.jackson.databind.node.ObjectNode;
+import org.apache.camel.builder.RouteBuilder;
+import org.apache.camel.component.opensearch.OpensearchConstants;
+import org.apache.camel.component.opensearch.OpensearchOperation;
+import org.awaitility.Awaitility;
+import org.junit.jupiter.api.Test;
+import org.opensearch.client.opensearch._types.FieldValue;
+import org.opensearch.client.opensearch._types.Result;
+import org.opensearch.client.opensearch._types.query_dsl.MatchQuery;
+import org.opensearch.client.opensearch._types.query_dsl.Query;
+import org.opensearch.client.opensearch.core.DeleteRequest;
+import org.opensearch.client.opensearch.core.GetRequest;
+import org.opensearch.client.opensearch.core.GetResponse;
+import org.opensearch.client.opensearch.core.IndexRequest;
+import org.opensearch.client.opensearch.core.MsearchRequest;
+import org.opensearch.client.opensearch.core.SearchRequest;
+import org.opensearch.client.opensearch.core.mget.MultiGetResponseItem;
+import org.opensearch.client.opensearch.core.msearch.MultiSearchResponseItem;
+import org.opensearch.client.opensearch.core.msearch.MultisearchBody;
+import org.opensearch.client.opensearch.core.msearch.MultisearchHeader;
+import org.opensearch.client.opensearch.core.msearch.RequestItem;
+import org.opensearch.client.opensearch.core.search.HitsMetadata;
+
+import static org.hamcrest.CoreMatchers.equalTo;
+import static org.hamcrest.CoreMatchers.notNullValue;
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertFalse;
+import static org.junit.jupiter.api.Assertions.assertInstanceOf;
+import static org.junit.jupiter.api.Assertions.assertNotNull;
+import static org.junit.jupiter.api.Assertions.assertNotSame;
+import static org.junit.jupiter.api.Assertions.assertNull;
+import static org.junit.jupiter.api.Assertions.assertTrue;
+
+class OpensearchGetSearchDeleteExistsUpdateIT extends OpensearchTestSupport {
+
+    @Test
+    void testIndexWithMap() {
+        //first, Index a value
+        Map<String, String> map = createIndexedData();
+        String indexId = template.requestBody(""direct:index"", map, String.class);
+        assertNotNull(indexId, ""indexId should be set"");
+
+        //now, verify GET succeeded
+        GetResponse<?> response = template.requestBody(""direct:get"", indexId, GetResponse.class);
+        assertNotNull(response, ""response should not be null"");
+        assertNotNull(response.source(), ""response source should not be null"");
+        assertInstanceOf(ObjectNode.class, response.source(), ""response source should be a ObjectNode"");
+        String key = map.keySet().iterator().next();
+        assertTrue(((ObjectNode) response.source()).has(key));
+        assertEquals(map.get(key), ((ObjectNode) response.source()).get(key).asText());
+    }
+
+    @Test
+    void testIndexWithString() {
+        //first, Index a value
+        String indexId = template.requestBody(""direct:index"", ""{\""testIndexWithString\"": \""some-value\""}"", String.class);
+        assertNotNull(indexId, ""indexId should be set"");
+
+        //now, verify GET succeeded
+        GetResponse<?> response = template.requestBody(""direct:get"", indexId, GetResponse.class);
+        assertNotNull(response, ""response should not be null"");
+        assertNotNull(response.source(), ""response source should not be null"");
+        assertInstanceOf(ObjectNode.class, response.source(), ""response source should be a ObjectNode"");
+        assertTrue(((ObjectNode) response.source()).has(""testIndexWithString""));
+        assertEquals(""some-value"", ((ObjectNode) response.source()).get(""testIndexWithString"").asText());
+    }
+
+    @Test
+    void testIndexWithReader() {
+        //first, Index a value
+        String indexId = template.requestBody(""direct:index"", new StringReader(""{\""testIndexWithReader\"": \""some-value\""}""),
+                String.class);
+        assertNotNull(indexId, ""indexId should be set"");
+
+        //now, verify GET succeeded
+        GetResponse<?> response = template.requestBody(""direct:get"", indexId, GetResponse.class);
+        assertNotNull(response, ""response should not be null"");
+        assertNotNull(response.source(), ""response source should not be null"");
+        assertInstanceOf(ObjectNode.class, response.source(), ""response source should be a ObjectNode"");
+        assertTrue(((ObjectNode) response.source()).has(""testIndexWithReader""));
+        assertEquals(""some-value"", ((ObjectNode) response.source()).get(""testIndexWithReader"").asText());
+    }
+
+    @Test
+    void testIndexWithBytes() {
+        //first, Index a value
+        String indexId = template.requestBody(""direct:index"",
+                ""{\""testIndexWithBytes\"": \""some-value\""}"".getBytes(StandardCharsets.UTF_8), String.class);
+        assertNotNull(indexId, ""indexId should be set"");
+
+        //now, verify GET succeeded
+        GetResponse<?> response = template.requestBody(""direct:get"", indexId, GetResponse.class);
+        assertNotNull(response, ""response should not be null"");
+        assertNotNull(response.source(), ""response source should not be null"");
+        assertInstanceOf(ObjectNode.class, response.source(), ""response source should be a ObjectNode"");
+        assertTrue(((ObjectNode) response.source()).has(""testIndexWithBytes""));
+        assertEquals(""some-value"", ((ObjectNode) response.source()).get(""testIndexWithBytes"").asText());
+    }
+
+    @Test
+    void testIndexWithInputStream() {
+        //first, Index a value
+        String indexId = template.requestBody(""direct:index"",
+                new ByteArrayInputStream(""{\""testIndexWithInputStream\"": \""some-value\""}"".getBytes(StandardCharsets.UTF_8)),
+                String.class);
+        assertNotNull(indexId, ""indexId should be set"");
+
+        //now, verify GET succeeded
+        GetResponse<?> response = template.requestBody(""direct:get"", indexId, GetResponse.class);
+        assertNotNull(response, ""response should not be null"");
+        assertNotNull(response.source(), ""response source should not be null"");
+        assertInstanceOf(ObjectNode.class, response.source(), ""response source should be a ObjectNode"");
+        assertTrue(((ObjectNode) response.source()).has(""testIndexWithInputStream""));
+        assertEquals(""some-value"", ((ObjectNode) response.source()).get(""testIndexWithInputStream"").asText());
+    }
+
+    @Test
+    void testIndexWithDocumentType() {
+        Product product = new Product();
+        product.setId(""book-world-records-2021"");
+        product.setStockAvailable(1);
+        product.setPrice(100);
+        product.setDescription(""The book of the year!"");
+        product.setName(""Guinness book of records 2021"");
+
+        //first, Index a value
+        String indexId = template.requestBody(""direct:index-product"", product, String.class);
+        assertNotNull(indexId, ""indexId should be set"");
+
+        //now, verify GET succeeded
+        GetResponse<?> response = template.requestBodyAndHeader(""direct:get"", indexId,
+                OpensearchConstants.PARAM_DOCUMENT_CLASS, Product.class, GetResponse.class);
+        assertNotNull(response, ""response should not be null"");
+        assertNotNull(response.source(), ""response source should not be null"");
+        assertInstanceOf(Product.class, response.source(), ""response source should be a Product"");
+        Product actual = (Product) response.source();
+        assertNotSame(product, actual);
+        assertEquals(product, actual);
+    }
+
+    @Test
+    void testGetWithString() {
+        //first, Index a value
+        Map<String, String> map = createIndexedData();
+        String indexId = template.requestBody(""direct:index"", map, String.class);
+        assertNotNull(indexId, ""indexId should be set"");
+
+        //now, verify GET succeeded
+        GetResponse<?> response = template.requestBody(""direct:get"", indexId, GetResponse.class);
+        assertNotNull(response, ""response should not be null"");
+        assertNotNull(response.source(), ""response source should not be null"");
+        assertInstanceOf(ObjectNode.class, response.source());
+    }
+
+    @Test
+    void testGetWithDocumentType() {
+        //first, Index a value
+        Product product = new Product();
+        product.setId(""book-world-records-1890"");
+        product.setStockAvailable(0);
+        product.setPrice(200);
+        product.setDescription(""The book of the year!"");
+        product.setName(""Guinness book of records 1890"");
+
+        String indexId = template.requestBody(""direct:index"", product, String.class);
+        assertNotNull(indexId, ""indexId should be set"");
+
+        //now, verify GET succeeded
+        GetResponse<?> response = template.requestBodyAndHeader(
+                ""direct:get"", indexId, OpensearchConstants.PARAM_DOCUMENT_CLASS, Product.class, GetResponse.class);
+        assertNotNull(response, ""response should not be null"");
+        assertNotNull(response.source(), ""response source should not be null"");
+        assertInstanceOf(Product.class, response.source());
+        Product p = (Product) response.source();
+        assertEquals(product, p);
+    }
+
+    @Test
+    void testMGetWithString() {
+        //first, Index a value
+        Map<String, String> map = createIndexedData();
+        String indexId = template.requestBody(""direct:index"", map, String.class);
+        assertNotNull(indexId, ""indexId should be set"");
+
+        //now, verify GET succeeded
+        @SuppressWarnings(""unchecked"")
+        List<MultiGetResponseItem<?>> response = template.requestBody(""direct:multiget"", List.of(indexId), List.class);
+        assertNotNull(response, ""response should not be null"");
+        assertEquals(1, response.size(), ""response should contain one result"");
+        assertTrue(response.get(0).isResult());
+        assertNotNull(response.get(0).result().source(), ""response source should not be null"");
+        assertInstanceOf(ObjectNode.class, response.get(0).result().source());
+    }
+
+    @Test
+    void testMGetWithDocumentType() {
+        //first, Index a value
+        Product product = new Product();
+        product.setId(""book-world-records-1890"");
+        product.setStockAvailable(0);
+        product.setPrice(200);
+        product.setDescription(""The book of the year!"");
+        product.setName(""Guinness book of records 1890"");
+
+        String indexId = template.requestBody(""direct:index"", product, String.class);
+        assertNotNull(indexId, ""indexId should be set"");
+
+        //now, verify GET succeeded
+        @SuppressWarnings(""unchecked"")
+        List<MultiGetResponseItem<?>> response = template.requestBodyAndHeader(
+                ""direct:multiget"", List.of(indexId), OpensearchConstants.PARAM_DOCUMENT_CLASS, Product.class, List.class);
+        assertNotNull(response, ""response should not be null"");
+        assertEquals(1, response.size(), ""response should contain one result"");
+        assertTrue(response.get(0).isResult());
+        assertNotNull(response.get(0).result().source(), ""response source should not be null"");
+        assertInstanceOf(Product.class, response.get(0).result().source());
+        Product p = (Product) response.get(0).result().source();
+        assertEquals(product, p);
+    }
+
+    @Test
+    void testDeleteWithString() {
+        //first, Index a value
+        Map<String, String> map = createIndexedData();
+        String indexId = template.requestBody(""direct:index"", map, String.class);
+        assertNotNull(indexId, ""indexId should be set"");
+
+        //now, verify GET succeeded
+        GetResponse<?> response = template.requestBody(""direct:get"", indexId, GetResponse.class);
+        assertNotNull(response, ""response should not be null"");
+        assertNotNull(response.source(), ""response source should not be null"");
+
+        //now, perform Delete
+        Result deleteResponse = template.requestBody(""direct:delete"", indexId, Result.class);
+        assertNotNull(deleteResponse, ""response should not be null"");
+
+        //now, verify GET fails to find the indexed value
+        response = template.requestBody(""direct:get"", indexId, GetResponse.class);
+        assertNotNull(response, ""response should not be null"");
+        assertNull(response.source(), ""response source should be null"");
+    }
+
+    @Test
+    void testSearchWithMapQuery() {
+        //first, Index a value
+        Map<String, String> map1 = Map.of(""testSearchWithMapQuery1"", ""foo"");
+        Map<String, String> map2 = Map.of(""testSearchWithMapQuery2"", ""bar"");
+        Map<String, Object> headers = Map.of(
+                OpensearchConstants.PARAM_OPERATION, OpensearchOperation.Bulk,
+                OpensearchConstants.PARAM_INDEX_NAME, ""twitter"");
+        template.requestBodyAndHeaders(""direct:start"", List.of(Map.of(""doc"", map1), Map.of(""doc"", map2)), headers,
+                String.class);
+
+        // No match
+        Map<String, Object> actualQuery = new HashMap<>();
+        actualQuery.put(""doc.testSearchWithMapQuery1"", ""bar"");
+        Map<String, Object> match = new HashMap<>();
+        match.put(""match"", actualQuery);
+        Map<String, Object> query = new HashMap<>();
+        query.put(""query"", match);
+        HitsMetadata<?> response = template.requestBody(""direct:search"", query, HitsMetadata.class);
+        assertNotNull(response, ""response should not be null"");
+        assertNotNull(response.total());
+        assertEquals(0, response.total().value(), ""response hits should be == 0"");
+
+        // Match
+        actualQuery.put(""doc.testSearchWithMapQuery1"", ""foo"");
+        // the result may see stale data so use Awaitility
+        Awaitility.await().atMost(10, TimeUnit.SECONDS).untilAsserted(() -> {
+            HitsMetadata<?> resp = template.requestBody(""direct:search"", query, HitsMetadata.class);
+            assertNotNull(resp, ""response should not be null"");
+            assertNotNull(resp.total());
+            assertEquals(1, resp.total().value(), ""response hits should be == 1"");
+            assertEquals(1, resp.hits().size(), ""response hits should be == 1"");
+            Object result = resp.hits().get(0).source();
+            assertInstanceOf(ObjectNode.class, result);
+            assertTrue(((ObjectNode) result).has(""doc""));
+            JsonNode node = ((ObjectNode) result).get(""doc"");
+            assertTrue(node.has(""testSearchWithMapQuery1""));
+            assertEquals(""foo"", node.get(""testSearchWithMapQuery1"").asText());
+        });","[{'comment': 'I think it would be better to split this so that `untilAsserted` tests for only 1 assertion. Combining them usually makes it harder to identify the root cause of failures. ', 'commenter': 'orpiske'}]"
10549,components/camel-opensearch/src/test/java/org/apache/camel/component/opensearch/integration/OpensearchGetSearchDeleteExistsUpdateIT.java,"@@ -0,0 +1,913 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.opensearch.integration;
+
+import java.io.ByteArrayInputStream;
+import java.io.StringReader;
+import java.nio.charset.StandardCharsets;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Objects;
+import java.util.concurrent.TimeUnit;
+
+import com.fasterxml.jackson.annotation.JsonInclude;
+import com.fasterxml.jackson.databind.JsonNode;
+import com.fasterxml.jackson.databind.node.ObjectNode;
+import org.apache.camel.builder.RouteBuilder;
+import org.apache.camel.component.opensearch.OpensearchConstants;
+import org.apache.camel.component.opensearch.OpensearchOperation;
+import org.awaitility.Awaitility;
+import org.junit.jupiter.api.Test;
+import org.opensearch.client.opensearch._types.FieldValue;
+import org.opensearch.client.opensearch._types.Result;
+import org.opensearch.client.opensearch._types.query_dsl.MatchQuery;
+import org.opensearch.client.opensearch._types.query_dsl.Query;
+import org.opensearch.client.opensearch.core.DeleteRequest;
+import org.opensearch.client.opensearch.core.GetRequest;
+import org.opensearch.client.opensearch.core.GetResponse;
+import org.opensearch.client.opensearch.core.IndexRequest;
+import org.opensearch.client.opensearch.core.MsearchRequest;
+import org.opensearch.client.opensearch.core.SearchRequest;
+import org.opensearch.client.opensearch.core.mget.MultiGetResponseItem;
+import org.opensearch.client.opensearch.core.msearch.MultiSearchResponseItem;
+import org.opensearch.client.opensearch.core.msearch.MultisearchBody;
+import org.opensearch.client.opensearch.core.msearch.MultisearchHeader;
+import org.opensearch.client.opensearch.core.msearch.RequestItem;
+import org.opensearch.client.opensearch.core.search.HitsMetadata;
+
+import static org.hamcrest.CoreMatchers.equalTo;
+import static org.hamcrest.CoreMatchers.notNullValue;
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertFalse;
+import static org.junit.jupiter.api.Assertions.assertInstanceOf;
+import static org.junit.jupiter.api.Assertions.assertNotNull;
+import static org.junit.jupiter.api.Assertions.assertNotSame;
+import static org.junit.jupiter.api.Assertions.assertNull;
+import static org.junit.jupiter.api.Assertions.assertTrue;
+
+class OpensearchGetSearchDeleteExistsUpdateIT extends OpensearchTestSupport {
+
+    @Test
+    void testIndexWithMap() {
+        //first, Index a value
+        Map<String, String> map = createIndexedData();
+        String indexId = template.requestBody(""direct:index"", map, String.class);
+        assertNotNull(indexId, ""indexId should be set"");
+
+        //now, verify GET succeeded
+        GetResponse<?> response = template.requestBody(""direct:get"", indexId, GetResponse.class);
+        assertNotNull(response, ""response should not be null"");
+        assertNotNull(response.source(), ""response source should not be null"");
+        assertInstanceOf(ObjectNode.class, response.source(), ""response source should be a ObjectNode"");
+        String key = map.keySet().iterator().next();
+        assertTrue(((ObjectNode) response.source()).has(key));
+        assertEquals(map.get(key), ((ObjectNode) response.source()).get(key).asText());
+    }
+
+    @Test
+    void testIndexWithString() {
+        //first, Index a value
+        String indexId = template.requestBody(""direct:index"", ""{\""testIndexWithString\"": \""some-value\""}"", String.class);
+        assertNotNull(indexId, ""indexId should be set"");
+
+        //now, verify GET succeeded
+        GetResponse<?> response = template.requestBody(""direct:get"", indexId, GetResponse.class);
+        assertNotNull(response, ""response should not be null"");
+        assertNotNull(response.source(), ""response source should not be null"");
+        assertInstanceOf(ObjectNode.class, response.source(), ""response source should be a ObjectNode"");
+        assertTrue(((ObjectNode) response.source()).has(""testIndexWithString""));
+        assertEquals(""some-value"", ((ObjectNode) response.source()).get(""testIndexWithString"").asText());
+    }
+
+    @Test
+    void testIndexWithReader() {
+        //first, Index a value
+        String indexId = template.requestBody(""direct:index"", new StringReader(""{\""testIndexWithReader\"": \""some-value\""}""),
+                String.class);
+        assertNotNull(indexId, ""indexId should be set"");
+
+        //now, verify GET succeeded
+        GetResponse<?> response = template.requestBody(""direct:get"", indexId, GetResponse.class);
+        assertNotNull(response, ""response should not be null"");
+        assertNotNull(response.source(), ""response source should not be null"");
+        assertInstanceOf(ObjectNode.class, response.source(), ""response source should be a ObjectNode"");
+        assertTrue(((ObjectNode) response.source()).has(""testIndexWithReader""));
+        assertEquals(""some-value"", ((ObjectNode) response.source()).get(""testIndexWithReader"").asText());
+    }
+
+    @Test
+    void testIndexWithBytes() {
+        //first, Index a value
+        String indexId = template.requestBody(""direct:index"",
+                ""{\""testIndexWithBytes\"": \""some-value\""}"".getBytes(StandardCharsets.UTF_8), String.class);
+        assertNotNull(indexId, ""indexId should be set"");
+
+        //now, verify GET succeeded
+        GetResponse<?> response = template.requestBody(""direct:get"", indexId, GetResponse.class);
+        assertNotNull(response, ""response should not be null"");
+        assertNotNull(response.source(), ""response source should not be null"");
+        assertInstanceOf(ObjectNode.class, response.source(), ""response source should be a ObjectNode"");
+        assertTrue(((ObjectNode) response.source()).has(""testIndexWithBytes""));
+        assertEquals(""some-value"", ((ObjectNode) response.source()).get(""testIndexWithBytes"").asText());
+    }
+
+    @Test
+    void testIndexWithInputStream() {
+        //first, Index a value
+        String indexId = template.requestBody(""direct:index"",
+                new ByteArrayInputStream(""{\""testIndexWithInputStream\"": \""some-value\""}"".getBytes(StandardCharsets.UTF_8)),
+                String.class);
+        assertNotNull(indexId, ""indexId should be set"");
+
+        //now, verify GET succeeded
+        GetResponse<?> response = template.requestBody(""direct:get"", indexId, GetResponse.class);
+        assertNotNull(response, ""response should not be null"");
+        assertNotNull(response.source(), ""response source should not be null"");
+        assertInstanceOf(ObjectNode.class, response.source(), ""response source should be a ObjectNode"");
+        assertTrue(((ObjectNode) response.source()).has(""testIndexWithInputStream""));
+        assertEquals(""some-value"", ((ObjectNode) response.source()).get(""testIndexWithInputStream"").asText());
+    }
+
+    @Test
+    void testIndexWithDocumentType() {
+        Product product = new Product();
+        product.setId(""book-world-records-2021"");
+        product.setStockAvailable(1);
+        product.setPrice(100);
+        product.setDescription(""The book of the year!"");
+        product.setName(""Guinness book of records 2021"");
+
+        //first, Index a value
+        String indexId = template.requestBody(""direct:index-product"", product, String.class);
+        assertNotNull(indexId, ""indexId should be set"");
+
+        //now, verify GET succeeded
+        GetResponse<?> response = template.requestBodyAndHeader(""direct:get"", indexId,
+                OpensearchConstants.PARAM_DOCUMENT_CLASS, Product.class, GetResponse.class);
+        assertNotNull(response, ""response should not be null"");
+        assertNotNull(response.source(), ""response source should not be null"");
+        assertInstanceOf(Product.class, response.source(), ""response source should be a Product"");
+        Product actual = (Product) response.source();
+        assertNotSame(product, actual);
+        assertEquals(product, actual);
+    }
+
+    @Test
+    void testGetWithString() {
+        //first, Index a value
+        Map<String, String> map = createIndexedData();
+        String indexId = template.requestBody(""direct:index"", map, String.class);
+        assertNotNull(indexId, ""indexId should be set"");
+
+        //now, verify GET succeeded
+        GetResponse<?> response = template.requestBody(""direct:get"", indexId, GetResponse.class);
+        assertNotNull(response, ""response should not be null"");
+        assertNotNull(response.source(), ""response source should not be null"");
+        assertInstanceOf(ObjectNode.class, response.source());
+    }
+
+    @Test
+    void testGetWithDocumentType() {
+        //first, Index a value
+        Product product = new Product();
+        product.setId(""book-world-records-1890"");
+        product.setStockAvailable(0);
+        product.setPrice(200);
+        product.setDescription(""The book of the year!"");
+        product.setName(""Guinness book of records 1890"");
+
+        String indexId = template.requestBody(""direct:index"", product, String.class);
+        assertNotNull(indexId, ""indexId should be set"");
+
+        //now, verify GET succeeded
+        GetResponse<?> response = template.requestBodyAndHeader(
+                ""direct:get"", indexId, OpensearchConstants.PARAM_DOCUMENT_CLASS, Product.class, GetResponse.class);
+        assertNotNull(response, ""response should not be null"");
+        assertNotNull(response.source(), ""response source should not be null"");
+        assertInstanceOf(Product.class, response.source());
+        Product p = (Product) response.source();
+        assertEquals(product, p);
+    }
+
+    @Test
+    void testMGetWithString() {
+        //first, Index a value
+        Map<String, String> map = createIndexedData();
+        String indexId = template.requestBody(""direct:index"", map, String.class);
+        assertNotNull(indexId, ""indexId should be set"");
+
+        //now, verify GET succeeded
+        @SuppressWarnings(""unchecked"")
+        List<MultiGetResponseItem<?>> response = template.requestBody(""direct:multiget"", List.of(indexId), List.class);
+        assertNotNull(response, ""response should not be null"");
+        assertEquals(1, response.size(), ""response should contain one result"");
+        assertTrue(response.get(0).isResult());
+        assertNotNull(response.get(0).result().source(), ""response source should not be null"");
+        assertInstanceOf(ObjectNode.class, response.get(0).result().source());
+    }
+
+    @Test
+    void testMGetWithDocumentType() {
+        //first, Index a value
+        Product product = new Product();
+        product.setId(""book-world-records-1890"");
+        product.setStockAvailable(0);
+        product.setPrice(200);
+        product.setDescription(""The book of the year!"");
+        product.setName(""Guinness book of records 1890"");
+
+        String indexId = template.requestBody(""direct:index"", product, String.class);
+        assertNotNull(indexId, ""indexId should be set"");
+
+        //now, verify GET succeeded
+        @SuppressWarnings(""unchecked"")
+        List<MultiGetResponseItem<?>> response = template.requestBodyAndHeader(
+                ""direct:multiget"", List.of(indexId), OpensearchConstants.PARAM_DOCUMENT_CLASS, Product.class, List.class);
+        assertNotNull(response, ""response should not be null"");
+        assertEquals(1, response.size(), ""response should contain one result"");
+        assertTrue(response.get(0).isResult());
+        assertNotNull(response.get(0).result().source(), ""response source should not be null"");
+        assertInstanceOf(Product.class, response.get(0).result().source());
+        Product p = (Product) response.get(0).result().source();
+        assertEquals(product, p);
+    }
+
+    @Test
+    void testDeleteWithString() {
+        //first, Index a value
+        Map<String, String> map = createIndexedData();
+        String indexId = template.requestBody(""direct:index"", map, String.class);
+        assertNotNull(indexId, ""indexId should be set"");
+
+        //now, verify GET succeeded
+        GetResponse<?> response = template.requestBody(""direct:get"", indexId, GetResponse.class);
+        assertNotNull(response, ""response should not be null"");
+        assertNotNull(response.source(), ""response source should not be null"");
+
+        //now, perform Delete
+        Result deleteResponse = template.requestBody(""direct:delete"", indexId, Result.class);
+        assertNotNull(deleteResponse, ""response should not be null"");
+
+        //now, verify GET fails to find the indexed value
+        response = template.requestBody(""direct:get"", indexId, GetResponse.class);
+        assertNotNull(response, ""response should not be null"");
+        assertNull(response.source(), ""response source should be null"");
+    }
+
+    @Test
+    void testSearchWithMapQuery() {
+        //first, Index a value
+        Map<String, String> map1 = Map.of(""testSearchWithMapQuery1"", ""foo"");
+        Map<String, String> map2 = Map.of(""testSearchWithMapQuery2"", ""bar"");
+        Map<String, Object> headers = Map.of(
+                OpensearchConstants.PARAM_OPERATION, OpensearchOperation.Bulk,
+                OpensearchConstants.PARAM_INDEX_NAME, ""twitter"");
+        template.requestBodyAndHeaders(""direct:start"", List.of(Map.of(""doc"", map1), Map.of(""doc"", map2)), headers,
+                String.class);
+
+        // No match
+        Map<String, Object> actualQuery = new HashMap<>();
+        actualQuery.put(""doc.testSearchWithMapQuery1"", ""bar"");
+        Map<String, Object> match = new HashMap<>();
+        match.put(""match"", actualQuery);
+        Map<String, Object> query = new HashMap<>();
+        query.put(""query"", match);
+        HitsMetadata<?> response = template.requestBody(""direct:search"", query, HitsMetadata.class);
+        assertNotNull(response, ""response should not be null"");
+        assertNotNull(response.total());
+        assertEquals(0, response.total().value(), ""response hits should be == 0"");
+
+        // Match
+        actualQuery.put(""doc.testSearchWithMapQuery1"", ""foo"");
+        // the result may see stale data so use Awaitility
+        Awaitility.await().atMost(10, TimeUnit.SECONDS).untilAsserted(() -> {
+            HitsMetadata<?> resp = template.requestBody(""direct:search"", query, HitsMetadata.class);
+            assertNotNull(resp, ""response should not be null"");
+            assertNotNull(resp.total());
+            assertEquals(1, resp.total().value(), ""response hits should be == 1"");
+            assertEquals(1, resp.hits().size(), ""response hits should be == 1"");
+            Object result = resp.hits().get(0).source();
+            assertInstanceOf(ObjectNode.class, result);
+            assertTrue(((ObjectNode) result).has(""doc""));
+            JsonNode node = ((ObjectNode) result).get(""doc"");
+            assertTrue(node.has(""testSearchWithMapQuery1""));
+            assertEquals(""foo"", node.get(""testSearchWithMapQuery1"").asText());
+        });
+    }
+
+    @Test
+    void testSearchWithStringQuery() {
+        //first, Index a value
+        Map<String, String> map1 = Map.of(""testSearchWithStringQuery1"", ""foo"");
+        Map<String, String> map2 = Map.of(""testSearchWithStringQuery2"", ""bar"");
+        Map<String, Object> headers = new HashMap<>();
+        headers.put(OpensearchConstants.PARAM_OPERATION, OpensearchOperation.Bulk);
+        headers.put(OpensearchConstants.PARAM_INDEX_NAME, ""twitter"");
+        template.requestBodyAndHeaders(""direct:start"", List.of(Map.of(""doc"", map1), Map.of(""doc"", map2)), headers,
+                String.class);
+
+        // No match
+        String query = """"""
+                {
+                    ""query"" : { ""match"" : { ""doc.testSearchWithStringQuery1"" : ""bar"" }}
+                }
+                """""";
+
+        HitsMetadata<?> response = template.requestBody(""direct:search"", query, HitsMetadata.class);
+        assertNotNull(response, ""response should not be null"");
+        assertNotNull(response.total());
+        assertEquals(0, response.total().value(), ""response hits should be == 0"");
+
+        // Match
+        String q = """"""
+                {
+                    ""query"" : { ""match"" : { ""doc.testSearchWithStringQuery1"" : ""foo"" }}
+                }
+                """""";
+        // the result may see stale data so use Awaitility
+        Awaitility.await().atMost(10, TimeUnit.SECONDS).untilAsserted(() -> {","[{'comment': 'I think it would be better to split this so that `untilAsserted` tests for only 1 assertion. Combining them usually makes it harder to identify the root cause of failures.\r\n\r\nThe same note for all the others using the same pattern.\r\n\r\n', 'commenter': 'orpiske'}]"
10549,components/camel-opensearch/src/test/java/org/apache/camel/component/opensearch/integration/OpensearchTestSupport.java,"@@ -0,0 +1,125 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.opensearch.integration;
+
+import java.util.HashMap;
+import java.util.Map;
+
+import org.apache.camel.CamelContext;
+import org.apache.camel.component.opensearch.OpensearchComponent;
+import org.apache.camel.test.infra.opensearch.services.OpenSearchService;
+import org.apache.camel.test.infra.opensearch.services.OpenSearchServiceFactory;
+import org.apache.camel.test.junit5.CamelTestSupport;
+import org.apache.http.HttpHost;
+import org.apache.http.auth.AuthScope;
+import org.apache.http.auth.UsernamePasswordCredentials;
+import org.apache.http.client.CredentialsProvider;
+import org.apache.http.impl.client.BasicCredentialsProvider;
+import org.junit.jupiter.api.TestInstance;
+import org.junit.jupiter.api.extension.RegisterExtension;
+import org.opensearch.client.RestClient;
+import org.opensearch.client.RestClientBuilder;
+import org.opensearch.client.json.jackson.JacksonJsonpMapper;
+import org.opensearch.client.opensearch.OpenSearchClient;
+import org.opensearch.client.transport.rest_client.RestClientTransport;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+@TestInstance(TestInstance.Lifecycle.PER_CLASS)
+public class OpensearchTestSupport extends CamelTestSupport {","[{'comment': ""Just as a general note: I'd prefer if our new tests would stop using the `CamelTestSupport` in favor of the new JUnit 5 extension (simpler to use, maintain and debug) introduced on [CAMEL-18957](https://issues.apache.org/jira/browse/CAMEL-18957).\r\n\r\nBut, for now, that's just a non-binding suggestion: it's OK to do it at a later moment."", 'commenter': 'orpiske'}]"
10664,components/camel-atom/src/test/java/org/apache/camel/component/atom/AtomHttpNoCamelParametersTest.java,"@@ -21,8 +21,7 @@
 import org.junit.jupiter.api.condition.DisabledOnOs;
 import org.junit.jupiter.api.condition.OS;
 
-import static org.junit.jupiter.api.Assertions.assertEquals;
-import static org.junit.jupiter.api.Assertions.assertNotNull;
+import static org.junit.jupiter.api.Assertions.*;","[{'comment': ""Please revert this change, we don't use this kind of import"", 'commenter': 'essobedo'}]"
10664,components/camel-atom/src/test/java/org/apache/camel/component/atom/UpdatedDateFilterTest.java,"@@ -28,8 +28,7 @@
 import org.junit.jupiter.api.condition.DisabledOnOs;
 import org.junit.jupiter.api.condition.OS;
 
-import static org.junit.jupiter.api.Assertions.assertEquals;
-import static org.junit.jupiter.api.Assertions.assertNotNull;
+import static org.junit.jupiter.api.Assertions.*;","[{'comment': 'ditto', 'commenter': 'essobedo'}]"
10664,components/camel-optaplanner/pom.xml,"@@ -1,4 +1,4 @@
-<?xml version=""1.0"" encoding=""UTF-8""?>
+git <?xml version=""1.0"" encoding=""UTF-8""?>","[{'comment': 'To revert too as it seems to be a typo', 'commenter': 'essobedo'}]"
10697,components/camel-aws/camel-aws2-kinesis/src/main/java/org/apache/camel/component/aws2/kinesis/Kinesis2Configuration.java,"@@ -67,6 +67,8 @@ public class Kinesis2Configuration implements Cloneable {
     private Integer proxyPort;
     @UriParam(defaultValue = ""false"", description = ""If we want to trust all certificates in case of overriding the endpoint"")
     private boolean trustAllCertificates;
+    @UriParam(defaultValue = ""false"", description = ""If we want to a KinesisAsyncClient instance set it to true"")","[{'comment': 'This is producer only, so it needs to be labelled', 'commenter': 'oscerd'}, {'comment': 'My aim was to make it bi-directional, both consumer and producer will take effect by async connection ?', 'commenter': 'hamed-hatami'}, {'comment': 'Let me declare a label for common then  for the time being', 'commenter': 'hamed-hatami'}]"
10697,components/camel-aws/camel-aws2-kinesis/src/main/java/org/apache/camel/component/aws2/kinesis/client/KinesisClientFactory.java,"@@ -44,4 +45,14 @@ public static KinesisInternalClient getKinesisClient(Kinesis2Configuration confi
             return new KinesisClientStandardImpl(configuration);
         }
     }
+
+    /**
+     * Return the standard aws Kinesis Async client.
+     *
+     * @param  configuration configuration
+     * @return               KinesisAsyncClient
+     */
+    public static KinesisAsyncInternalClient getKinesisAsyncClient(Kinesis2Configuration configuration) {","[{'comment': 'The default and profile credentials are missing. It should be the same as the Sync client, so you should provide the other two implementations', 'commenter': 'oscerd'}, {'comment': ""It's done"", 'commenter': 'hamed-hatami'}]"
10697,components/camel-aws/camel-aws2-kinesis/pom.xml,"@@ -33,6 +33,7 @@
     <description>A Camel Amazon Kinesis Web Service Component Version 2</description>
 
     <properties>
+        <amazon-kinesis-common-version>2.5.1</amazon-kinesis-common-version>","[{'comment': 'This should go in Parent POM', 'commenter': 'oscerd'}, {'comment': ""It's also done"", 'commenter': 'hamed-hatami'}]"
10736,components/camel-caffeine/pom.xml,"@@ -62,6 +62,20 @@
             <version>${metrics-version}</version>
             <scope>test</scope>
         </dependency>
+
+        <dependency>
+            <groupId>org.apache.camel</groupId>
+            <artifactId>camel-test-infra-core</artifactId>
+            <version>${project.version}</version>
+            <type>test-jar</type>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.apache.camel</groupId>
+            <artifactId>camel-test-infra-core</artifactId>
+            <version>4.0.0-SNAPSHOT</version>","[{'comment': 'This should be as above with project.version', 'commenter': 'davsclaus'}, {'comment': ""Thanks for notice, Claus. I'll fix it"", 'commenter': 'LostArtist'}]"
10756,.github/actions/incremental-build/parse_errors.sh,"@@ -0,0 +1,26 @@
+#!/bin/bash
+#
+# Licensed to the Apache Software Foundation (ASF) under one or more
+# contributor license agreements.  See the NOTICE file distributed with
+# this work for additional information regarding copyright ownership.
+# The ASF licenses this file to You under the Apache License, Version 2.0
+# (the ""License""); you may not use this file except in compliance with
+# the License.  You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an ""AS IS"" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+LOG_FILE=$1
+
+OUTPUT_FILE=""error_messages.txt""
+
+echo ""| Failed Test |","[{'comment': '1. Missing the double quotes ("") closing the first line of text. \r\n2. Missing saving the table header to the summary file (```> ""$GITHUB_STEP_SUMMARY""```)', 'commenter': 'orpiske'}]"
10756,.github/actions/incremental-build/parse_errors.sh,"@@ -0,0 +1,26 @@
+#!/bin/bash
+#
+# Licensed to the Apache Software Foundation (ASF) under one or more
+# contributor license agreements.  See the NOTICE file distributed with
+# this work for additional information regarding copyright ownership.
+# The ASF licenses this file to You under the Apache License, Version 2.0
+# (the ""License""); you may not use this file except in compliance with
+# the License.  You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an ""AS IS"" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+LOG_FILE=$1
+
+OUTPUT_FILE=""error_messages.txt""
+
+echo ""| Failed Test |
+| --- |"" > ""$GITHUB_STEP_SUMMARY""","[{'comment': 'Needs to be modified, for appending after fixing the items above.', 'commenter': 'orpiske'}, {'comment': 'For both lines: they need not to be written if there is no errors on the log file. ', 'commenter': 'orpiske'}]"
10804,core/camel-core/src/test/java/org/apache/camel/builder/FluentProducerTemplateTest.java,"@@ -39,19 +40,19 @@
 public class FluentProducerTemplateTest extends ContextTestSupport {
 
     @Test
-    public void testNoEndpoint() throws Exception {
+    public void testNoEndpoint() {
         FluentProducerTemplate fluent = context.createFluentProducerTemplate();
 
         try {
             fluent.withBody(""Hello World"").send();
-            fail(""Should have thrown exception"");
+            Assertions.assertDoesNotThrow(() -> fail(""Should have thrown exception""));","[{'comment': 'This code is wrong as the code was expected to throw an exception, and hence it will execute the .. catch block.', 'commenter': 'davsclaus'}, {'comment': ""Yeah, now I see. Thanks, I'll fix it "", 'commenter': 'LostArtist'}]"
10804,core/camel-core/src/test/java/org/apache/camel/builder/FluentProducerTemplateTest.java,"@@ -239,12 +240,12 @@ public void testExceptionUsingExchange() throws Exception {
     }
 
     @Test
-    public void testExceptionUsingProcessorAndBody() throws Exception {
+    public void testExceptionUsingProcessorAndBody() {
         try {
             DefaultFluentProducerTemplate.on(context)
                     .withBody(""World"")
                     .withProcessor(exchange -> exchange.getIn().setHeader(""foo"", 123)).to(""direct:async"").send();
-            fail();
+            Assertions.assertDoesNotThrow(() -> fail());","[{'comment': 'Same as before', 'commenter': 'davsclaus'}]"
10804,core/camel-main/src/test/java/org/apache/camel/main/MainPropertyPlaceholderTest.java,"@@ -33,7 +34,7 @@ public void testDefaultPropertyPlaceholderLocationDisabled() {
             main.setDefaultPropertyPlaceholderLocation(""false"");
             main.start();
             main.getCamelContext().resolvePropertyPlaceholders(""{{hello}}"");
-            fail(""Expected IllegalArgumentException"");
+            Assertions.assertDoesNotThrow( () -> fail(""Expected IllegalArgumentException""));","[{'comment': 'Same as before', 'commenter': 'davsclaus'}]"
10804,core/camel-main/src/test/java/org/apache/camel/main/MainSupportCommandLineTest.java,"@@ -44,20 +45,20 @@ public CamelContext getCamelContext() {
     }
 
     @Test
-    public void testMainSupport() throws Exception {
+    public void testMainSupport() {
         MyMainSupport my = new MyMainSupport();
-        my.run(new String[] { ""-d"", ""1"" });
+        Assertions.assertDoesNotThrow(() -> my.run(new String[] { ""-d"", ""1"" }));","[{'comment': 'Sorry this code is harder to understand and maintain.\r\n\r\nIts perfect OK for a test method to have throws exception.\r\nAs. the old code is 100% how an end user will write the code.\r\n', 'commenter': 'davsclaus'}, {'comment': ""Yes, I didn't mean to touch it. Will rollback it"", 'commenter': 'LostArtist'}, {'comment': 'Actually, the proposed change is correct.\r\n\r\nIn the case `my.run` throws an exception, that gets recorded as a test error not as a test failure. A test without assertions is not really testing anything (or, instead, doing half of the job). ', 'commenter': 'orpiske'}, {'comment': 'To be even more correct, with regards to the `run` especification, the test code should do something like this:\r\n\r\n```\r\nfinal int ret = Assertions.assertDoesNotThrow(() -> my.run(new String[] { ""-h"" }));\r\nAssertions.assertEquals(0, ret, ""The code should return 0 when -h is requested"");\r\n```\r\n\r\nThat ensures: \r\n1. Proper distinction between errors and failures\r\n2. That the correct return code (0 - or something else, if that\'s the expectation) is returned when a valid option is passed.\r\n', 'commenter': 'orpiske'}]"
10804,core/camel-main/src/test/java/org/apache/camel/main/MainVaultTest.java,"@@ -48,7 +48,7 @@ public void testMainAws() throws Exception {
         Assertions.assertEquals(""myKey"", cfg.getAccessKey());
         Assertions.assertEquals(""mySecret"", cfg.getSecretKey());
         Assertions.assertEquals(""myRegion"", cfg.getRegion());
-        Assertions.assertEquals(false, cfg.isDefaultCredentialsProvider());
+        Assertions.assertFalse(cfg.isDefaultCredentialsProvider());","[{'comment': 'These changes are ok (and the following)', 'commenter': 'davsclaus'}]"
10804,core/camel-core/src/test/java/org/apache/camel/component/file/FileConsumerBeginAndCommitRenameStrategyTest.java,"@@ -47,26 +48,13 @@ public void testRenameSuccess() throws Exception {
     }
 
     @Test
-    public void testIllegalOptions() throws Exception {
-        try {
-            context.getEndpoint(fileUri(""?move=../done/${file:name}&delete=true"")).createConsumer(new Processor() {
-                public void process(Exchange exchange) throws Exception {
-                }
-            });
-            fail(""Should have thrown an exception"");
-        } catch (IllegalArgumentException e) {
-            // ok
-        }
+    public void testIllegalOptions() {
 
-        try {
-            context.getEndpoint(fileUri(""?move=${file:name.noext}.bak&delete=true"")).createConsumer(new Processor() {
-                public void process(Exchange exchange) throws Exception {
-                }
-            });
-            fail(""Should have thrown an exception"");
-        } catch (IllegalArgumentException e) {
-            // ok
-        }
+        Assertions.assertThrows(IllegalArgumentException.class, () -> context.getEndpoint(fileUri(""?move=../done/${file:name}&delete=true"")).createConsumer(exchange -> {
+        }), ""Should have thrown an exception"");","[{'comment': 'More likely you mean: \r\n\r\n```\r\n       Endpoint ep = context.getEndpoint(fileUri(""?move=../done/${file:name}&delete=true""));\r\n        Assertions.assertThrows(IllegalArgumentException.class, () -> ep.createConsumer(exchange -> {\r\n        }), ""Should have thrown an exception"");\r\n```', 'commenter': 'orpiske'}]"
10870,components/camel-aws/camel-aws2-kinesis/src/main/java/org/apache/camel/component/aws2/kinesis/Kinesis2Endpoint.java,"@@ -99,12 +101,20 @@ public Producer createProducer() throws Exception {
 
     @Override
     public Consumer createConsumer(Processor processor) throws Exception {
-        final Kinesis2Consumer consumer = new Kinesis2Consumer(this, processor);
+        var kinesisConnection = KinesisConnection.getInstance();
+        final Kinesis2Consumer consumer = new Kinesis2Consumer(this, processor, kinesisConnection);
         consumer.setSchedulerProperties(getSchedulerProperties());
+        startHealthChecks(kinesisConnection);
         configureConsumer(consumer);
         return consumer;
     }
 
+    private void startHealthChecks(KinesisConnection kinesisConnection) {","[{'comment': 'For this you could use the executor service we have in Camel, like we did here: \r\n\r\nhttps://github.com/apache/camel/blob/main/components/camel-aws/camel-aws2-s3/src/main/java/org/apache/camel/component/aws2/s3/stream/AWS2S3StreamUploadProducer.java#L83', 'commenter': 'oscerd'}, {'comment': ""@oscerd  What a great idea, I've changed the code according to your suggestion"", 'commenter': 'hamed-hatami'}, {'comment': ""@oscerd  it's ready to go, I suppose"", 'commenter': 'hamed-hatami'}, {'comment': '@Andrea Cosentino Please retrigger the pipeline one more time', 'commenter': 'hamed-hatami'}, {'comment': 'If it looks OK, please resolve ', 'commenter': 'hamed-hatami'}]"
10969,components/camel-zookeeper-master/src/test/java/org/apache/camel/component/zookeepermaster/MasterEndpointIT.java,"@@ -54,14 +55,14 @@ public void testEndpoint() throws Exception {
         List<Route> registeredRoutes = camelContext.getRoutes();
         assertEquals(1, registeredRoutes.size(), ""number of routes"");
         MasterEndpoint endpoint = (MasterEndpoint) registeredRoutes.get(0).getEndpoint();
-        assertEquals(""seda:bar"", endpoint.getConsumerEndpointUri(), ""wrong endpoint uri"");
+        assertEquals(""direct:bar"", endpoint.getConsumerEndpointUri(), ""wrong endpoint uri"");
 
         String expectedBody = ""<matched/>"";
 
         resultEndpoint.expectedBodiesReceived(expectedBody);
 
-        // lets wait for the entry to be registered...
-        Thread.sleep(5000);
+        MasterConsumer masterConsumer = (MasterConsumer) camelContext.getRoute(""zookeeper-master-to-direct"").getConsumer();
+        Awaitility.await().until(() -> masterConsumer.isMaster() && masterConsumer.isConnected());","[{'comment': 'You need some kind of duration to not wait forever, like 10 seconds or so', 'commenter': 'davsclaus'}, {'comment': ""Isn't awaitiltiy default timeout 10 seconds? or am I missing something? https://github.com/awaitility/awaitility/wiki/Usage#simple `By default Awaitility will wait for 10 seconds`"", 'commenter': 'Croway'}, {'comment': 'Ah you learn something every day. Thanks', 'commenter': 'davsclaus'}]"
10981,components/camel-platform-http-main/src/test/java/org/apache/camel/component/platform/http/main/MainHttpServerTest.java,"@@ -0,0 +1,62 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.camel.component.platform.http.main;
+
+import java.io.IOException;
+import java.net.URI;
+import java.net.http.HttpClient;
+import java.net.http.HttpRequest;
+import java.net.http.HttpResponse;
+
+import org.apache.camel.CamelContext;
+import org.apache.camel.impl.DefaultCamelContext;
+import org.junit.jupiter.api.Test;
+
+import static org.junit.jupiter.api.Assertions.assertEquals;
+
+class MainHttpServerTest {
+
+    private CamelContext camelContext;
+
+    @Test
+    public void statusIsNotSatisfied() throws IOException, InterruptedException {
+        MainHttpServer server = new MainHttpServer();
+
+        camelContext = new DefaultCamelContext();
+        server.setCamelContext(camelContext);
+
+        camelContext.getRegistry().bind(""fake"", new MainHttpFakeHealthCheck());
+
+        server.setHost(""0.0.0.0"");
+        server.setPort(8080);","[{'comment': 'An oversight on my part: we could probably have used the `AvailablePortFinder`. ', 'commenter': 'orpiske'}]"
10981,components/camel-platform-http-main/src/test/java/org/apache/camel/component/platform/http/main/MainHttpServerTest.java,"@@ -0,0 +1,62 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.camel.component.platform.http.main;
+
+import java.io.IOException;
+import java.net.URI;
+import java.net.http.HttpClient;
+import java.net.http.HttpRequest;
+import java.net.http.HttpResponse;
+
+import org.apache.camel.CamelContext;
+import org.apache.camel.impl.DefaultCamelContext;
+import org.junit.jupiter.api.Test;
+
+import static org.junit.jupiter.api.Assertions.assertEquals;
+
+class MainHttpServerTest {
+
+    private CamelContext camelContext;
+
+    @Test
+    public void statusIsNotSatisfied() throws IOException, InterruptedException {
+        MainHttpServer server = new MainHttpServer();
+
+        camelContext = new DefaultCamelContext();
+        server.setCamelContext(camelContext);
+
+        camelContext.getRegistry().bind(""fake"", new MainHttpFakeHealthCheck());
+
+        server.setHost(""0.0.0.0"");
+        server.setPort(8080);
+        server.setPath(""/"");
+
+        server.setHealthCheckEnabled(true);
+        server.start();
+
+        HttpRequest request = HttpRequest.newBuilder()
+                .uri(URI.create(""http://localhost:8080/q/health/ready""))","[{'comment': ""And we'll need to adjust here once we use the `AvailablePortFinder`."", 'commenter': 'orpiske'}]"
11055,components/camel-opensearch/src/test/java/org/apache/camel/component/opensearch/integration/OpensearchGetSearchDeleteExistsUpdateIT.java,"@@ -289,13 +291,12 @@ void testSearchWithMapQuery() throws Exception {
         HitsMetadata<?> response = template().requestBody(""direct:search"", query, HitsMetadata.class);
         assertNotNull(response, ""response should not be null"");
         assertNotNull(response.total());
-        assertEquals(0, response.total().value(), ""response hits should be == 0"");
 
         // Match
         actualQuery.put(""doc.testSearchWithMapQuery1"", ""foo"");
 
         // Delay the execution, because the search is getting stale results
-        Thread.sleep(2000);
+        Awaitility.await().pollDelay(2, TimeUnit.SECONDS).untilAsserted(() -> assertEquals(0, response.total().value(), ""response hits should be == 0""));","[{'comment': 'I\'m under the impression you have to refresh the reference to the response. As it is, I think you are just delaying the assertion of the `response.total().value()`.\r\n\r\nI believe, it would need to be similar to this:\r\n\r\n```\r\nassertEquals(0, response.total().value(), ""response hits should be == 0""));\r\nAwaitility.await().pollDelay(2, TimeUnit.SECONDS).untilAsserted(() -> \r\n        HitsMetadata<?> response = template().requestBody(""direct:search"", builder, HitsMetadata.class);\r\n        assertNotNull(response, ""response should not be null"");\r\n        // ... other assertions \r\n}\r\n```\r\n\r\nYou probably need to investigate using the same pattern for the others as well.\r\n\r\n', 'commenter': 'orpiske'}]"
11060,components/camel-consul/src/test/java/org/apache/camel/component/consul/cluster/ConsulClusteredRoutePolicyFactoryIT.java,"@@ -94,7 +95,7 @@ public void configure() {
 
             // Start the context after some random time so the startup order
             // changes for each test.
-            Thread.sleep(ThreadLocalRandom.current().nextInt(500));
+            Awaitility.await().atMost(ThreadLocalRandom.current().nextInt(500), TimeUnit.MILLISECONDS);","[{'comment': 'This is missing the terminal operation. You need to add something like `untilAsserted`, `until` or similar.\r\n\r\nI believe we need something similar to this:\r\n\r\n\r\n```\r\nAwaitility.await().pollDelay(ThreadLocalRandom.current().nextInt(500), TimeUnit.MILLISECONDS).untilAsserted(() -> Assertions.assertDoesNotThrow(context::start));\r\n```\r\n\r\n', 'commenter': 'orpiske'}]"
11060,components/camel-consul/src/test/java/org/apache/camel/component/consul/cluster/ConsulClusteredRoutePolicyIT.java,"@@ -94,7 +95,7 @@ public void configure() throws Exception {
 
             // Start the context after some random time so the startup order
             // changes for each test.
-            Thread.sleep(ThreadLocalRandom.current().nextInt(500));
+            Awaitility.await().atMost(ThreadLocalRandom.current().nextInt(500), TimeUnit.MILLISECONDS);","[{'comment': 'Same as above.', 'commenter': 'orpiske'}]"
11060,components/camel-consul/src/test/java/org/apache/camel/component/consul/cluster/ConsulMasterIT.java,"@@ -92,7 +93,7 @@ public void configure() {
 
             // Start the context after some random time so the startup order
             // changes for each test.
-            Thread.sleep(ThreadLocalRandom.current().nextInt(500));
+            Awaitility.await().atMost(ThreadLocalRandom.current().nextInt(500), TimeUnit.MILLISECONDS);","[{'comment': 'Same as above.', 'commenter': 'orpiske'}]"
11061,components/camel-disruptor/src/test/java/org/apache/camel/component/disruptor/SedaDisruptorCompareTest.java,"@@ -232,7 +233,7 @@ void speedTestDisruptor(
         System.out.println(""Starting real test of: "" + componentName);
 
         forceGC();
-        Thread.sleep(1000);
+        Awaitility.await().atMost(1, TimeUnit.SECONDS);","[{'comment': 'This is missing the actual check to performed. Probably you need to put `untilAsserted` or something like that.', 'commenter': 'orpiske'}]"
11076,catalog/camel-report-maven-plugin/pom.xml,"@@ -33,6 +33,15 @@
     <name>Camel :: Catalog :: Camel Report Maven Plugin</name>
     <description>Maven plugin with tools to generate reports on your Camel projects</description>
 
+    <properties>","[{'comment': 'These should be defined in parent/pom.xml and reuse what we have already if possible', 'commenter': 'davsclaus'}, {'comment': 'Done', 'commenter': 'cziesman'}]"
11076,catalog/camel-report-maven-plugin/pom.xml,"@@ -145,12 +188,82 @@
         <dependency>
             <groupId>org.apache.logging.log4j</groupId>
             <artifactId>log4j-core</artifactId>
+        </dependency>
+
+        <!-- test -->
+        <dependency>
+            <groupId>org.junit.jupiter</groupId>
+            <artifactId>junit-jupiter</artifactId>
+            <version>5.9.2</version>
+            <scope>test</scope>
+        </dependency>
+        <dependency>","[{'comment': 'No hardcoded version number, should use the version from parent/pom which for testing libraries is already managed', 'commenter': 'davsclaus'}, {'comment': 'Done', 'commenter': 'cziesman'}]"
11076,catalog/camel-report-maven-plugin/pom.xml,"@@ -145,12 +188,82 @@
         <dependency>
             <groupId>org.apache.logging.log4j</groupId>
             <artifactId>log4j-core</artifactId>
+        </dependency>
+
+        <!-- test -->
+        <dependency>
+            <groupId>org.junit.jupiter</groupId>
+            <artifactId>junit-jupiter</artifactId>
+            <version>5.9.2</version>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.junit.jupiter</groupId>
+            <artifactId>junit-jupiter-params</artifactId>
+            <version>5.9.2</version>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.assertj</groupId>
+            <artifactId>assertj-core</artifactId>
+            <version>3.24.2</version>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.mockito</groupId>
+            <artifactId>mockito-inline</artifactId>
+            <version>5.2.0</version>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.mockito</groupId>
+            <artifactId>mockito-junit-jupiter</artifactId>
+            <version>5.2.0</version>
             <scope>test</scope>
         </dependency>
+
     </dependencies>
 
     <build>
         <plugins>
+            <plugin>
+                <groupId>org.apache.maven.plugins</groupId>
+                <artifactId>maven-surefire-plugin</artifactId>
+                <version>3.1.2</version>","[{'comment': 'No hardcoded version', 'commenter': 'davsclaus'}, {'comment': 'Done', 'commenter': 'cziesman'}]"
11076,catalog/camel-report-maven-plugin/pom.xml,"@@ -33,6 +33,10 @@
     <name>Camel :: Catalog :: Camel Report Maven Plugin</name>
     <description>Maven plugin with tools to generate reports on your Camel projects</description>
 
+    <properties>
+        <poi-version>5.2.3</poi-version>","[{'comment': 'Can you add poi to parent pom.xml as well', 'commenter': 'davsclaus'}, {'comment': 'Sorry, POI was related to Excel generation. I removed the dependencies and the property.', 'commenter': 'cziesman'}]"
11145,core/camel-core/src/test/java/org/apache/camel/component/file/FileConsumerBeginRenameStrategyTest.java,"@@ -50,12 +51,13 @@ public void testRenameFileExists() throws Exception {
         // create a file in inprogress to let there be a duplicate file
         testDirectory(""inprogress"", true);
         FileWriter fw = new FileWriter(testFile(""inprogress/london.txt"").toFile());
-        try {
+
+        assertDoesNotThrow(() -> {
             fw.write(""I was there once in London"");
             fw.flush();
-        } finally {
-            fw.close();
-        }
+        });","[{'comment': '1. This assertion is not correct, as it is asserting a code from the JVM. \r\n2. It could be cleaned up later, by using a try-with-resources.', 'commenter': 'orpiske'}]"
11145,core/camel-core/src/test/java/org/apache/camel/component/file/FileConsumerCommitRenameStrategyTest.java,"@@ -47,10 +48,12 @@ public void testRenameSuccess() throws Exception {
     public void testRenameFileExists() throws Exception {
         // create a file in done to let there be a duplicate file
         testDirectory(""done"", true);
-        try (FileWriter fw = new FileWriter(testFile(""done/london.txt"").toFile())) {
+
+        assertDoesNotThrow(() -> {
+            FileWriter fw = new FileWriter(testFile(""done/london.txt"").toFile());
             fw.write(""I was there once in London"");
             fw.flush();","[{'comment': 'Same as above (and for any other doing the same)', 'commenter': 'orpiske'}]"
11165,components/camel-netty-http/src/main/java/org/apache/camel/component/netty/http/NettyHttpProducer.java,"@@ -51,6 +53,10 @@ public NettyHttpProducer(NettyHttpEndpoint nettyEndpoint, NettyConfiguration con
 
     @Override
     protected void doInit() throws Exception {
+        if (isProxyProtocol()) {","[{'comment': 'I wonder if this can this be checked in createProducer instead?\r\n\r\nAlso we do not log and throw exception, only throw exception', 'commenter': 'davsclaus'}, {'comment': ""> I wonder if this can this be checked in createProducer instead?\r\n\r\nyeah, it's better there. moved.\r\n\r\n> Also we do not log and throw exception, only throw exception\r\n\r\nok, removed the log."", 'commenter': 'luigidemasi'}]"
11170,core/camel-xml-io/src/test/java/org/apache/camel/xml/in/ModelParserTest.java,"@@ -66,13 +66,11 @@ public class ModelParserTest {
 
     public static final String NAMESPACE = ""http://camel.apache.org/schema/spring"";
     private static final List<String> REST_XMLS
-            = List.of(""barRest.xml"", ""simpleRest.xml"", ""simpleRestToD.xml"", ""restAllowedValues.xml"");
-    private static final List<String> TEMPLATE_XMLS = List.of(""barTemplate.xml"");
-    private static final List<String> TEMPLATED_ROUTE_XMLS = List.of(""barTemplatedRoute.xml"");
-    private static final List<String> BEANS_XMLS
-            = List.of(""beansEmpty.xml"", ""beansWithProperties.xml"", ""beansWithSpringNS.xml"");
+            = Arrays.asList(""barRest.xml"", ""simpleRest.xml"", ""simpleRestToD.xml"", ""restAllowedValues.xml"");
+    private static final List<String> TEMPLATE_XMLS = Arrays.asList(""barTemplate.xml"");
+    private static final List<String> TEMPLATED_ROUTE_XMLS = Arrays.asList(""barTemplatedRoute.xml"");
     private static final List<String> ROUTE_CONFIGURATION_XMLS
-            = List.of(""errorHandlerConfiguration.xml"", ""errorHandlerConfigurationRedeliveryPolicyRef.xml"");
+            = Arrays.asList(""errorHandlerConfiguration.xml"", ""errorHandlerConfigurationRedeliveryPolicyRef.xml"");","[{'comment': 'No idea why it keeps doing this. ', 'commenter': 'orpiske'}]"
11178,components/camel-jms/src/main/java/org/apache/camel/component/jms/JmsSendDynamicAware.java,"@@ -109,8 +109,15 @@ private String parseDestinationName(String uri) {
         if (pos != -1) {
             uri = uri.substring(0, pos);
         }
-        // destination name is after last colon
-        pos = uri.lastIndexOf(':');
+
+        // destination name is after last colon (but not after double colon)
+        int posDoubleCol = uri.indexOf(""::"");
+        if (posDoubleCol != -1) {
+            pos = uri.substring(0, posDoubleCol).lastIndexOf(':');
+        } else {
+            pos = uri.lastIndexOf(':');
+        }
+","[{'comment': 'Please, can you take a look at `StringHelper` (I guess `between` method) and try to use that, instead? ', 'commenter': 'orpiske'}, {'comment': 'Thanks, made use of `StringHelper`', 'commenter': 'DenisIstomin'}]"
11230,components/camel-opentelemetry/src/test/java/org/apache/camel/opentelemetry/OpenTelemetryTracingStrategyTest.java,"@@ -0,0 +1,95 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.opentelemetry;
+
+import java.util.function.Function;
+
+import io.opentelemetry.api.trace.Span;
+import io.opentelemetry.api.trace.SpanKind;
+import io.opentelemetry.context.Scope;
+import org.apache.camel.RoutesBuilder;
+import org.apache.camel.builder.RouteBuilder;
+import org.apache.camel.spi.InterceptStrategy;
+import org.junit.jupiter.api.Test;
+
+class OpenTelemetryTracingStrategyTest extends CamelOpenTelemetryTestSupport {
+
+    private static SpanTestData[] testdata = {
+            new SpanTestData().setLabel(""camel-process"").setOperation(""third-party-span"")
+                    .setParentId(1),
+            new SpanTestData().setLabel(""camel-process"").setOperation(""third-party-processor"")
+                    .setParentId(6),
+            new SpanTestData().setLabel(""camel-process"").setOperation(""direct-processor"")
+                    .setParentId(3),
+            new SpanTestData().setLabel(""direct:serviceB"").setOperation(""serviceB"")
+                    .setParentId(4),
+            new SpanTestData().setLabel(""direct:serviceB"").setOperation(""serviceB"")
+                    .setKind(SpanKind.CLIENT)
+                    .setParentId(5),
+            new SpanTestData().setLabel(""to:serviceB"").setOperation(""to-serviceB"")
+                    .setParentId(6),
+            new SpanTestData().setLabel(""direct:serviceA"").setUri(""direct://start"").setOperation(""serviceA"")
+                    .setParentId(7),
+            new SpanTestData().setLabel(""direct:serviceA"").setUri(""direct://start"").setOperation(""serviceA"")
+                    .setKind(SpanKind.CLIENT)
+    };
+
+    OpenTelemetryTracingStrategyTest() {
+        super(testdata);
+    }
+
+    @Test
+    void testTracingOfProcessors() {
+        template.requestBody(""direct:serviceA"", ""Hello"");
+
+        verify();
+    }
+
+    @Override
+    protected RoutesBuilder createRouteBuilder() {
+        return new RouteBuilder() {
+            @Override
+            public void configure() {
+                from(""direct:serviceA"").routeId(""serviceA"")
+                        .process(exchange -> {
+                            callThirdPartyInstrumentation();
+                        }).id(""third-party-processor"")
+                        .to(""direct:serviceB"").id(""to-serviceB"");
+
+                from(""direct:serviceB"").routeId(""serviceB"")
+                        .process(exchange -> {
+                            Thread.sleep(100);","[{'comment': 'Thanks for your contribution!\r\n\r\nPlease, is there a way, maybe this can be done without the `Thread.sleep`? These hard-coded sleeps are almost always a pain in our CI. ', 'commenter': 'orpiske'}, {'comment': 'Also, the same note for the other sleep below.', 'commenter': 'orpiske'}, {'comment': ""Thanks. \r\nI've removed sleeps and test is working fine"", 'commenter': 'RuslanHryn'}, {'comment': 'Thanks!', 'commenter': 'orpiske'}]"
11321,core/camel-core/src/test/java/org/apache/camel/util/CamelContextHelperTest.java,"@@ -45,7 +45,7 @@ public void testParsing() {
         eq(() -> CamelContextHelper.parseBoolean(context, ""false""), false);
         eq(() -> CamelContextHelper.parseBoolean(context, ""TrUe""), true);
         eq(() -> CamelContextHelper.parseBoolean(context, ""FaLsE""), false);
-        fl(() -> CamelContextHelper.parseBoolean(context, ""5""), IllegalArgumentException.class);
+        eq(() -> CamelContextHelper.parseBoolean(context, ""5""), false);","[{'comment': 'Yeah this is bad - it should not be false as the input is invalid. We basically need to just check for true|false as only valid input - as the old code.\r\n\r\nA lot of Camel use is configuration, so if you have a mistake there, then concerting to false would make it appear as working but something was not configured correctly.\r\n\r\n', 'commenter': 'davsclaus'}, {'comment': 'If you want to use Boolean.parseBoolean, then you can do that first, and only check for invalid input if the result was false.\r\n\r\nvar a = Boolean.parseBoolean(s)\r\nif a == false {\r\n   .. // okay the input may be invalid, so check for that\r\n}', 'commenter': 'davsclaus'}, {'comment': 'Or maybe do what Boolean.parseBoolean does but manually, something ala\r\n\r\nif (""true"".equalsIgnoreCase(s)) return Boolean.TRUE\r\n""false"".equalsIgnoreCase(s) return Boolean.FALSE\r\nreturn null\r\n', 'commenter': 'davsclaus'}]"
11354,components/camel-tracing/src/main/java/org/apache/camel/tracing/SpanAdapter.java,"@@ -23,24 +23,12 @@ public interface SpanAdapter {
 
     void setError(boolean error);
 
-    void setTag(Tag key, String value);","[{'comment': 'These are breaking changes, are we ok with that?', 'commenter': 'marcingrzejszczak'}, {'comment': 'See next comment', 'commenter': 'davsclaus'}]"
11354,components/camel-tracing/src/main/java/org/apache/camel/tracing/SpanAdapter.java,"@@ -23,24 +23,12 @@ public interface SpanAdapter {
 
     void setError(boolean error);
 
-    void setTag(Tag key, String value);
-
-    void setTag(Tag key, Number value);
-
     void setTag(String key, String value);
 
     void setTag(String key, Number value);
 
     void setTag(String key, Boolean value);
 
-    default void setLowCardinalityTag(Tag key, String value) {","[{'comment': 'These are breaking changes, are we ok with that?', 'commenter': 'marcingrzejszczak'}, {'comment': 'Yeah Camel end users dont really work directly with this API. And we have migration docs where we can write the steps people need to migrate. And its better to get ahead of this early in Camel v4 than later.', 'commenter': 'davsclaus'}, {'comment': ""If that's fine for you that's fine for me too 😃 "", 'commenter': 'marcingrzejszczak'}]"
11354,components/camel-tracing/src/main/java/org/apache/camel/tracing/TagConstants.java,"@@ -0,0 +1,47 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.tracing;
+
+public class TagConstants {","[{'comment': ""Are these actually different to what we had before? If that's the case that's a breaking change. IMO we should introduce new tags next to the current ones and deprecate the old ones. \r\n\r\nAlso how will ensure the compatibility between this class and semantic conventions of OpenTelemetry? Are we to be compatible with all the versions? Which version is this compatible with, for which date? Semantic Conventions are not stable and they can be changed at any point in time. What's our strategy for such breakages?"", 'commenter': 'marcingrzejszczak'}, {'comment': 'cc @oscerd @davsclaus ', 'commenter': 'marcingrzejszczak'}, {'comment': 'However these Tags are potentially more used by Camel end users and if possible we could have the old tags deprecated and if possible let the old tags delegate to the new tags.', 'commenter': 'davsclaus'}]"
11429,components/camel-aws/camel-aws2-redshift/src/test/java/org/apache/camel/component/aws2/redshift/data/AmazonRedshiftDataClientMock.java,"@@ -0,0 +1,115 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.aws2.redshift.data;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import software.amazon.awssdk.services.redshiftdata.RedshiftDataClient;
+import software.amazon.awssdk.services.redshiftdata.model.*;","[{'comment': ""Please don't use * imports"", 'commenter': 'oscerd'}]"
11429,components/camel-aws/camel-aws2-redshift/src/test/java/org/apache/camel/component/aws2/redshift/data/RedshiftData2ProducerSpringTest.java,"@@ -0,0 +1,217 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.aws2.redshift.data;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import org.apache.camel.EndpointInject;
+import org.apache.camel.Exchange;
+import org.apache.camel.Processor;
+import org.apache.camel.component.mock.MockEndpoint;
+import org.apache.camel.test.spring.junit5.CamelSpringTestSupport;
+import org.junit.jupiter.api.Test;
+import org.springframework.context.support.ClassPathXmlApplicationContext;
+import software.amazon.awssdk.services.redshiftdata.model.*;","[{'comment': 'Ditto', 'commenter': 'oscerd'}]"
11429,components/camel-aws/camel-aws2-redshift/src/test/java/org/apache/camel/component/aws2/redshift/data/RedshiftData2ProducerTest.java,"@@ -0,0 +1,257 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.aws2.redshift.data;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import org.apache.camel.BindToRegistry;
+import org.apache.camel.EndpointInject;
+import org.apache.camel.Exchange;
+import org.apache.camel.Processor;
+import org.apache.camel.builder.RouteBuilder;
+import org.apache.camel.component.mock.MockEndpoint;
+import org.apache.camel.test.junit5.CamelTestSupport;
+import org.junit.jupiter.api.Test;
+import software.amazon.awssdk.services.redshiftdata.model.*;","[{'comment': 'Same', 'commenter': 'oscerd'}]"
11429,components/camel-aws/camel-aws2-redshift/pom.xml,"@@ -0,0 +1,89 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<!--
+
+    Licensed to the Apache Software Foundation (ASF) under one or more
+    contributor license agreements.  See the NOTICE file distributed with
+    this work for additional information regarding copyright ownership.
+    The ASF licenses this file to You under the Apache License, Version 2.0
+    (the ""License""); you may not use this file except in compliance with
+    the License.  You may obtain a copy of the License at
+
+         http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an ""AS IS"" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+
+-->
+<project xmlns=""http://maven.apache.org/POM/4.0.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
+         xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+    <modelVersion>4.0.0</modelVersion>
+
+    <parent>
+        <groupId>org.apache.camel</groupId>
+        <relativePath>../../pom.xml</relativePath>
+        <artifactId>components</artifactId>
+        <version>4.1.0-SNAPSHOT</version>
+    </parent>
+
+    <artifactId>camel-aws2-redshift</artifactId>
+    <packaging>jar</packaging>
+
+    <name>Camel :: AWS Redshift Data</name>
+    <description>A Camel Amazon Web Services Redshift Data Component</description>
+
+    <properties>
+        <camel.surefire.forkTimeout>1200</camel.surefire.forkTimeout>
+    </properties>
+
+    <dependencies>
+        <dependency>
+            <groupId>org.apache.camel</groupId>
+            <artifactId>camel-support</artifactId>
+        </dependency>
+        <dependency>
+            <groupId>org.apache.camel</groupId>
+            <artifactId>camel-health</artifactId>
+        </dependency>
+        <dependency>
+            <groupId>software.amazon.awssdk</groupId>
+            <artifactId>redshiftdata</artifactId>
+            <version>${aws-java-sdk2-version}</version>
+        </dependency>
+        <dependency>
+            <groupId>software.amazon.awssdk</groupId>
+            <artifactId>apache-client</artifactId>
+            <version>${aws-java-sdk2-version}</version>
+        </dependency>
+
+        <!-- for testing -->
+        <dependency>
+            <groupId>org.apache.camel</groupId>
+            <artifactId>camel-test-spring-junit5</artifactId>
+            <scope>test</scope>
+        </dependency>
+
+        <!-- test infra -->
+        <dependency>
+            <groupId>org.apache.camel</groupId>","[{'comment': 'As far as I see we are not testing against localstack, so this dependency could be removed.', 'commenter': 'oscerd'}]"
11449,components/camel-jetty/src/test/java/org/apache/camel/component/jetty/JettyMuteExceptionTest.java,"@@ -41,13 +41,29 @@ public void testMuteException() throws Exception {
         }
     }
 
+    @Test
+    public void testDefaultMuteException() throws Exception {
+        HttpGet get = new HttpGet(""http://localhost:"" + getPort() + ""/fooDefault"");
+        get.addHeader(""Accept"", ""application/text"");
+        try (CloseableHttpClient client = HttpClients.createDefault();
+             CloseableHttpResponse response = client.execute(get)) {
+
+            String responseString = EntityUtils.toString(response.getEntity(), ""UTF-8"");
+            assertEquals("""", responseString);","[{'comment': 'Maybe use `assertTrue(responseString.isEmpty())` ?', 'commenter': 'orpiske'}, {'comment': 'Done, thanks for that.', 'commenter': 'jonomorris'}]"
11449,components/camel-jetty/src/test/java/org/apache/camel/component/jetty/JettyMuteExceptionTest.java,"@@ -41,13 +41,29 @@ public void testMuteException() throws Exception {
         }
     }
 
+    @Test
+    public void testDefaultMuteException() throws Exception {
+        HttpGet get = new HttpGet(""http://localhost:"" + getPort() + ""/fooDefault"");
+        get.addHeader(""Accept"", ""application/text"");
+        try (CloseableHttpClient client = HttpClients.createDefault();
+             CloseableHttpResponse response = client.execute(get)) {
+
+            String responseString = EntityUtils.toString(response.getEntity(), ""UTF-8"");","[{'comment': 'Use `StandardCharsets.UTF_8` \r\n\r\nObs.: I know the other test in there uses ""UTF-8"" (this is an old practice - we still have a few places doing this).', 'commenter': 'orpiske'}, {'comment': 'Done.', 'commenter': 'jonomorris'}]"
11449,components/camel-servlet/src/test/java/org/apache/camel/component/servlet/ServletMuteExceptionTest.java,"@@ -25,6 +25,18 @@
 
 public class ServletMuteExceptionTest extends ServletCamelRouterTestSupport {
 
+    @Test
+    public void testMuteDefaultTrue() throws Exception {
+        WebRequest req = new PostMethodWebRequest(
+                contextUrl + ""/services/muteDefault"",
+                new ByteArrayInputStream("""".getBytes()), ""text/plain"");
+        WebResponse response = query(req, false);
+
+        assertEquals(500, response.getResponseCode());
+        assertEquals(""text/plain"", response.getContentType());
+        assertEquals("""", response.getText());","[{'comment': 'Same note I raised on another text.', 'commenter': 'orpiske'}, {'comment': 'Done, thanks!', 'commenter': 'jonomorris'}]"
11499,components/camel-file/src/main/java/org/apache/camel/component/file/FileConsumer.java,"@@ -171,6 +171,9 @@ protected boolean pollDirectory(String fileName, List<GenericFile<File>> fileLis
     }
 
     private File[] listFiles(File directory) {
+        if (!getEndpoint().isIncludeHiddenDir()) {","[{'comment': 'This seems wrong is it not ?', 'commenter': 'davsclaus'}, {'comment': 'my bad', 'commenter': 'TUCJVXCB'}]"
11499,core/camel-core/src/test/java/org/apache/camel/component/file/FileConsumeHiddenDirTest.java,"@@ -0,0 +1,61 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.file;
+
+import org.apache.camel.ContextTestSupport;
+import org.apache.camel.Exchange;
+import org.apache.camel.builder.RouteBuilder;
+import org.apache.camel.component.mock.MockEndpoint;
+import org.awaitility.Awaitility;
+import org.junit.jupiter.api.Test;
+
+import java.nio.file.Files;
+
+import static org.junit.jupiter.api.Assertions.assertFalse;
+
+/**
+ * Unit test for consuming hidden dir.
+ */
+public class FileConsumeHiddenDirTest extends ContextTestSupport {","[{'comment': 'Can you change the test so it uses a sub folder as hidden folder.\r\n\r\nThe test consumes directly from the hidden folder, we should test that it works for folders that has sub folders where some are hidden and some are not.', 'commenter': 'davsclaus'}]"
11499,components/camel-file/src/main/java/org/apache/camel/component/file/FileConsumer.java,"@@ -314,14 +317,15 @@ public FileEndpoint getEndpoint() {
 
     @Override
     protected boolean isMatchedHiddenFile(GenericFile<File> file, boolean isDirectory) {
-        if (getEndpoint().isIncludeHiddenFiles()) {
-            if (isDirectory) {
-                // skip hidden folders
-                String name = file.getFileNameOnly();
-                if (name.startsWith(""."")) {
-                    return false;
-                }
+        if (isDirectory) {
+            String name = file.getFileNameOnly();
+            if (!name.startsWith(""."")) {
+                return true;
             }
+            return getEndpoint().isIncludeHiddenDir() && !"".camel"".equals(name);","[{'comment': 'It could be a good idea to add "".camel"" as a constant on FileConstants so its easier to see its a special folder name, and also use. the constant in FileProcessStrategyFactory', 'commenter': 'davsclaus'}, {'comment': 'well,I think so, i will update ', 'commenter': 'TUCJVXCB'}]"
11638,core/camel-support/src/main/java/org/apache/camel/support/RestConsumerContextPathMatcher.java,"@@ -16,21 +16,16 @@
  */
 package org.apache.camel.support;
 
-import java.util.ArrayList;
-import java.util.Comparator;
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Locale;
-import java.util.Map;
-import java.util.OptionalInt;
+import java.util.*;","[{'comment': ""Please don't use * import."", 'commenter': 'oscerd'}, {'comment': ""> Please don't use * import.\r\n\r\ngot it"", 'commenter': 'TUCJVXCB'}]"
11638,core/camel-support/src/test/java/org/apache/camel/support/RestConsumerContextPathMatcherTest.java,"@@ -83,19 +83,38 @@ public void testRestConsumerContextPathMatcherSuccess() {
     @Test
     public void testRestConsumerContextPathMatcherWithWildcard() {
         List<RestConsumerContextPathMatcher.ConsumerPath<MockConsumerPath>> consumerPaths = new ArrayList<>();
-        consumerPaths.add(new MockConsumerPath(""GET"", ""/camel/*""));
+        consumerPaths.add(new MockConsumerPath(""GET"", ""/camel/myapp/info""));
+        consumerPaths.add(new MockConsumerPath(""GET"", ""/camel/myapp/{id}""));
+        consumerPaths.add(new MockConsumerPath(""GET"", ""/camel/myapp/order/*""));
 
         RestConsumerContextPathMatcher.ConsumerPath<?> path1 = RestConsumerContextPathMatcher.matchBestPath(""GET"",
-                ""/camel"", consumerPaths);
+                ""/camel/myapp/info"", consumerPaths);
 
         RestConsumerContextPathMatcher.ConsumerPath<?> path2 = RestConsumerContextPathMatcher.matchBestPath(""GET"",
-                ""/camel/foo"", consumerPaths);
+                ""/camel/myapp/1"", consumerPaths);
 
         RestConsumerContextPathMatcher.ConsumerPath<?> path3 = RestConsumerContextPathMatcher.matchBestPath(""GET"",
+                ""/camel/myapp/order/foo"", consumerPaths);
+
+        assertEquals(path1.getConsumerPath(), ""/camel/myapp/info"");
+        assertEquals(path2.getConsumerPath(), ""/camel/myapp/{id}"");
+        assertEquals(path3.getConsumerPath(), ""/camel/myapp/order/*"");
+    }
+
+    @Test
+    public void testRestConsumerContextPathMatcherOrder() {
+        List<RestConsumerContextPathMatcher.ConsumerPath<MockConsumerPath>> consumerPaths = new ArrayList<>();
+        consumerPaths.add(new MockConsumerPath(""GET"", ""/camel/*""));
+        consumerPaths.add(new MockConsumerPath(""GET"", ""/camel/foo""));
+        consumerPaths.add(new MockConsumerPath(""GET"", ""/camel/foo/{id}""));
+
+        RestConsumerContextPathMatcher.ConsumerPath<?> path1 = RestConsumerContextPathMatcher.matchBestPath(""GET"",
+                ""/camel/foo"", consumerPaths);
+
+        RestConsumerContextPathMatcher.ConsumerPath<?> path2 = RestConsumerContextPathMatcher.matchBestPath(""GET"",
                 ""/camel/foo/bar"", consumerPaths);
 
-        assertEquals(path1.getConsumerPath(), ""/camel/*"");
+        assertEquals(path1.getConsumerPath(), ""/camel/foo"");
         assertEquals(path2.getConsumerPath(), ""/camel/*"");","[{'comment': 'Should path2 not select /camel/foo/{id} because its the best candidate.', 'commenter': 'davsclaus'}, {'comment': 'The priority of wildcard is now higher than uri template . The correct order of priority is direct > URI template > wildcard, right?""', 'commenter': 'TUCJVXCB'}, {'comment': 'Correct. Wildcard should be last priority.', 'commenter': 'davsclaus'}]"
11638,core/camel-support/src/main/java/org/apache/camel/support/RestConsumerContextPathMatcher.java,"@@ -331,11 +345,31 @@ private static int countWildcards(String consumerPath) {
         String[] consumerPaths = consumerPath.split(""/"");
         for (String p2 : consumerPaths) {
             if (p2.startsWith(""{"") && p2.endsWith(""}"")) {
-                wildcards++;
+                curlyBraces++;
             }
         }
 
-        return wildcards;
+        return curlyBraces;
+    }
+
+    private static boolean matchWildCard(String requestPath, String consumerPath) {
+        if (!requestPath.endsWith(""/"")) {
+            requestPath = requestPath + ""/"";
+        }
+        // Convert URI template to a regex pattern
+        String regex = consumerPath
+                .replace(""/"", ""\\/"")
+                .replace(""{"", ""(?<"")
+                .replace(""}"", "">[^\\/]+)"");
+
+        // Add support for wildcard * as path suffix
+        regex = regex.replace(""*"", "".*"");
+
+        // Match the provided path against the regex pattern","[{'comment': 'Is there a way to avoid regexp compile, as its slow and would impact high performance.\r\nWe need to do a simpler way of checking this.', 'commenter': 'davsclaus'}, {'comment': '> Is there a way to avoid regexp compile, as its slow and would impact high performance. We need to do a simpler way of checking this.\r\n\r\nShould be precompiled and saved, rather than compiling every request.', 'commenter': 'TUCJVXCB'}, {'comment': '> Is there a way to avoid regexp compile, as its slow and would impact high performance. We need to do a simpler way of checking this.\r\n\r\nTrie tree is suitable for route matching, but it may require substantial code modifications.', 'commenter': 'TUCJVXCB'}, {'comment': 'Ah okay pre-compiled really helps, so its only calling the matcher per message', 'commenter': 'davsclaus'}]"
11653,components/camel-spring-main/src/test/java/org/apache/camel/spring/MainDummyTest.java,"@@ -19,25 +19,31 @@
 import org.apache.camel.CamelContext;
 import org.junit.jupiter.api.Test;
 
-import static org.junit.jupiter.api.Assertions.assertEquals;
-import static org.junit.jupiter.api.Assertions.assertNotNull;
+import static org.junit.jupiter.api.Assertions.*;","[{'comment': ""Please don't use * import"", 'commenter': 'oscerd'}]"
11670,components/camel-micrometer/pom.xml,"@@ -108,6 +108,13 @@
             <version>${assertj-version}</version>
             <scope>test</scope>
         </dependency>
+        <dependency>
+            <groupId>org.awaitility</groupId>
+            <artifactId>awaitility</artifactId>
+            <version>4.2.0</version>","[{'comment': 'This should come as property placeholder from Parent POM', 'commenter': 'oscerd'}, {'comment': 'thanks, fixed', 'commenter': 'LostArtist'}]"
11674,components/camel-bean/src/main/java/org/apache/camel/component/bean/BeanPropertiesFunction.java,"@@ -0,0 +1,51 @@
+package org.apache.camel.component.bean;","[{'comment': 'Please add a license header', 'commenter': 'oscerd'}]"
11674,components/camel-bean/src/main/java/org/apache/camel/component/bean/BeanPropertiesFunction.java,"@@ -0,0 +1,67 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.bean;
+
+import org.apache.camel.CamelContext;
+import org.apache.camel.CamelContextAware;
+import org.apache.camel.NoSuchBeanException;
+import org.apache.camel.RuntimeCamelException;
+import org.apache.camel.spi.PropertiesFunction;
+import org.apache.camel.spi.Registry;
+import org.apache.camel.support.ObjectHelper;
+
+@org.apache.camel.spi.annotations.PropertiesFunction(""bean"")
+public class BeanPropertiesFunction implements PropertiesFunction, CamelContextAware {
+    private CamelContext camelContext;
+
+    @Override
+    public String getName() {
+        return ""bean"";
+    }
+
+    @Override
+    public String apply(String remainder) {
+        String[] beanNameAndMethodName = remainder.split(""\\."");","[{'comment': 'I would like to have better syntax check than doing a split and then assume the array has 2 elements.\r\n\r\nMake some code that checks for only a single dot, and if not present then do a illegal argument exception', 'commenter': 'davsclaus'}]"
11674,components/camel-bean/src/main/java/org/apache/camel/component/bean/BeanPropertiesFunction.java,"@@ -0,0 +1,67 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.bean;
+
+import org.apache.camel.CamelContext;
+import org.apache.camel.CamelContextAware;
+import org.apache.camel.NoSuchBeanException;
+import org.apache.camel.RuntimeCamelException;
+import org.apache.camel.spi.PropertiesFunction;
+import org.apache.camel.spi.Registry;
+import org.apache.camel.support.ObjectHelper;
+
+@org.apache.camel.spi.annotations.PropertiesFunction(""bean"")
+public class BeanPropertiesFunction implements PropertiesFunction, CamelContextAware {
+    private CamelContext camelContext;
+
+    @Override
+    public String getName() {
+        return ""bean"";
+    }
+
+    @Override
+    public String apply(String remainder) {
+        String[] beanNameAndMethodName = remainder.split(""\\."");
+        String beanName = beanNameAndMethodName[0];
+        String methodName = beanNameAndMethodName[1];
+
+        Registry registry = getCamelContext().getRegistry();
+        Object bean = registry.lookupByName(beanName);
+        if (bean == null) {
+            throw new NoSuchBeanException(beanName);
+        }
+
+        String answer = """";
+        try {
+            answer += (String) ObjectHelper.invokeMethodSafe(methodName, bean);","[{'comment': 'Use camel typ e converter to. convert to a string value, as it may invoke a method that returns a boolean, int etc.', 'commenter': 'davsclaus'}]"
11674,components/camel-bean/src/main/java/org/apache/camel/component/bean/BeanPropertiesFunction.java,"@@ -0,0 +1,67 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.bean;
+
+import org.apache.camel.CamelContext;
+import org.apache.camel.CamelContextAware;
+import org.apache.camel.NoSuchBeanException;
+import org.apache.camel.RuntimeCamelException;
+import org.apache.camel.spi.PropertiesFunction;
+import org.apache.camel.spi.Registry;
+import org.apache.camel.support.ObjectHelper;
+
+@org.apache.camel.spi.annotations.PropertiesFunction(""bean"")
+public class BeanPropertiesFunction implements PropertiesFunction, CamelContextAware {
+    private CamelContext camelContext;
+
+    @Override
+    public String getName() {
+        return ""bean"";
+    }
+
+    @Override
+    public String apply(String remainder) {
+        String[] beanNameAndMethodName = remainder.split(""\\."");
+        String beanName = beanNameAndMethodName[0];
+        String methodName = beanNameAndMethodName[1];
+
+        Registry registry = getCamelContext().getRegistry();","[{'comment': 'You can also use mandatoryLookup on CamelContextHelper', 'commenter': 'davsclaus'}]"
11711,components/camel-quartz/src/test/java/org/apache/camel/component/quartz/SpringQuartzConsumerTwoAppsClusteredFailoverTest.java,"@@ -65,7 +66,15 @@ public void testQuartzPersistentStoreClusteredApp() throws Exception {
         log.warn(""Crashed..."");
 
         // wait long enough until the second app takes it over...
-        Thread.sleep(2000);
+        Awaitility.await().untilAsserted(() -> {
+            CamelContext camel2 = app2.getBean(""camelContext2-"" + getClass().getSimpleName(), CamelContext.class);
+
+            MockEndpoint mock2 = camel2.getEndpoint(""mock:result"", MockEndpoint.class);
+            mock2.expectedMinimumMessageCount(3);
+            mock2.expectedMessagesMatches(new ClusteringPredicate(false));
+
+            mock2.assertIsSatisfied();
+        });","[{'comment': 'We can probably shorten the asserted block. ', 'commenter': 'orpiske'}]"
11711,components/camel-quartz/src/test/java/org/apache/camel/component/quartz/SpringQuartzConsumerTwoAppsClusteredRecoveryTest.java,"@@ -55,14 +58,22 @@ public void testQuartzPersistentStoreClusteredApp() throws Exception {
         log.warn(""Crashed..."");
         log.warn(""Crashed..."");
 
-        Thread.sleep(2000);
+        Awaitility.await().timeout(2000, TimeUnit.MILLISECONDS);
 
         // as well as the second one which will run in slave mode as it will not be able to acquire the same lock
         AbstractXmlApplicationContext app2 = newAppContext(""SpringQuartzConsumerRecoveryClusteredAppTwo.xml"");
         app2.start();
 
         // wait long enough until the second app takes it over...
-        Thread.sleep(2000);
+        Awaitility.await().untilAsserted(() -> {
+            CamelContext camel2 = app2.getBean(""camelContext2-"" + getClass().getSimpleName(), CamelContext.class);
+
+            MockEndpoint mock2 = camel2.getEndpoint(""mock:result"", MockEndpoint.class);
+            mock2.expectedMinimumMessageCount(2);
+            mock2.expectedMessagesMatches(new ClusteringPredicate(false));
+
+            mock2.assertIsSatisfied();
+        });","[{'comment': 'Same as above.', 'commenter': 'orpiske'}]"
11711,components/camel-quartz/src/test/java/org/apache/camel/routepolicy/quartz/CronScheduledRoutePolicyTest.java,"@@ -330,10 +331,16 @@ public void configure() {
 
             ServiceHelper.suspendService(context.getRoute(""test"").getConsumer());
 
-            Thread.sleep(5000);
-            template.sendBody(""direct:start"", ""Ready or not, Here, I come"");
+            try {
+                Awaitility.await().timeout(5, TimeUnit.SECONDS).catchUncaughtExceptions().untilAsserted(() -> {
+                    template.sendBody(""direct:start"", ""Ready or not, Here, I come"");
+                    success.assertIsSatisfied();
+                });
+            } catch (CamelExecutionException e) {
+                throw new CamelExecutionException(e.getMessage(), e.getExchange(), e);
+            }","[{'comment': 'Hm, this seems a bit strange to me. I think it would probably be better to separate error handling from the test assertion.', 'commenter': 'orpiske'}]"
11711,components/camel-quartz/src/test/java/org/apache/camel/routepolicy/quartz/SpringMultiplePoliciesOnRouteTest.java,"@@ -34,7 +34,6 @@ public void testMultiplePoliciesOnRoute() throws Exception {
 
         for (int i = 0; i < size; i++) {
             template.sendBody(url, ""Message "" + i);
-            Thread.sleep(3);
         }","[{'comment': ""I think we need this `Thread.sleep` if we want to throttle sending the messages. I have seen this pattern elsewhere. I don't think you need to fix this one right now (see: https://issues.apache.org/jira/browse/CAMEL-19986) "", 'commenter': 'orpiske'}]"
11715,components/camel-micrometer/src/main/docs/micrometer-component.adoc,"@@ -567,17 +575,33 @@ and add a `JmxMeterRegistry` instance:
            HierarchicalNameMapper.DEFAULT));
         return meterRegistry;
     }
-}
 ----
 
-The `HierarchicalNameMapper` strategy determines how meter name and tags are assembled into
-an MBean name.
+CDI::
++
+[source,java]
+----
+    @Produces
+    @Named(MicrometerConstants.METRICS_REGISTRY_NAME))
+    public MeterRegistry getMeterRegistry() {
+        CompositeMeterRegistry meterRegistry = new CompositeMeterRegistry();
+        meterRegistry.add(...);
+        meterRegistry.add(new JmxMeterRegistry(
+           CamelJmxConfig.DEFAULT,
+           Clock.SYSTEM,
+           HierarchicalNameMapper.DEFAULT));
+        return meterRegistry;
+    }
+----
 
+====
+
+The `HierarchicalNameMapper` strategy determines how meter name and tags are assembled into an MBean name.
 
+ifeval::[{show-csb-content} == true]","[{'comment': 'Can you remove this ifeval stuff, we do not use that at ASF', 'commenter': 'davsclaus'}, {'comment': ""Yes, I'll remove that. Thanks!"", 'commenter': 'JiriOndrusek'}, {'comment': 'done', 'commenter': 'JiriOndrusek'}]"
11715,components/camel-micrometer/src/main/docs/micrometer-component.adoc,"@@ -73,8 +73,12 @@ You should define a dedicated registry by providing
 a `MeterRegistry` bean. Micrometer registries primarily determine the backend monitoring system
 to be used. A `CompositeMeterRegistry` can be used to address more than one monitoring target.
 
-For example using Spring Java Configuration:
+For example using Java Configuration:","[{'comment': 'The camel-spring-javaconfig has been removed and this example is not valid anymore', 'commenter': 'davsclaus'}, {'comment': ""I'll remove the whole example"", 'commenter': 'JiriOndrusek'}, {'comment': 'I removed example for this configuration. Is it OK now?', 'commenter': 'JiriOndrusek'}]"
11715,components/camel-micrometer/src/main/docs/micrometer-component.adoc,"@@ -592,3 +555,5 @@ For example to capture data with Prometheus, you can add the following dependenc
 See the following table for options to specify what metrics to capture, or to turn it off.
 
 include::spring-boot:partial$starter.adoc[]
+
+endif::[]","[{'comment': 'Remove this', 'commenter': 'davsclaus'}, {'comment': 'done', 'commenter': 'JiriOndrusek'}]"
11754,parent/pom.xml,"@@ -2697,6 +2697,18 @@
                 <type>pom</type>
                 <scope>import</scope>
             </dependency>
+            <dependency>","[{'comment': 'Unless there is a good reason I would avoid adding other dependencies in parent/pom', 'commenter': 'oscerd'}, {'comment': 'for `xmlunit-core`, it was already used in several projects. In this PR, I only factorize it in the parent dependencyManagement.\r\n\r\nfor `xmlunit-assertj3`, it allows to write simpler code and have a better error message', 'commenter': 'apupier'}, {'comment': 'I can update to use the same xmlunit-core in this PR, and provide a different PR to migrate from xmlunit-core to xmlunit-assertj3 to separate concerns and discuss if it is worthy or not to use the introduced one.', 'commenter': 'apupier'}, {'comment': 'First PR provided for the factorization of the xmlunit-core dependency in dependencyManagement https://github.com/apache/camel/pull/11767', 'commenter': 'apupier'}, {'comment': 'Second PR provided to replace unitcore with assertj https://github.com/apache/camel/pull/11774', 'commenter': 'apupier'}, {'comment': 'the 2 other PRs have been merged.\r\nLess code change in this PR', 'commenter': 'apupier'}]"
11812,core/camel-main/src/main/java/org/apache/camel/main/DefaultConfigurationProperties.java,"@@ -159,6 +159,15 @@ public abstract class DefaultConfigurationProperties<T> {
     private String startupRecorderProfile = ""default"";
     private long startupRecorderDuration;
     private String startupRecorderDir;
+    private boolean sslEnabled;
+    private String sslKeyStore;
+    @Metadata(defaultValue = ""changeit"")
+    private String sslKeystorePassword = ""changeit"";","[{'comment': 'We should not have default passwords', 'commenter': 'davsclaus'}, {'comment': ""I've moved these default passwords."", 'commenter': 'jonomorris'}]"
11837,components/camel-test/camel-test-junit5/src/main/java/org/apache/camel/test/junit5/TestSupport.java,"@@ -581,4 +582,16 @@ public static String fileUri(Path testDirectory) {
     public static String fileUri(Path testDirectory, String query) {
         return ""file:"" + testDirectory + (query.startsWith(""?"") ? """" : ""/"") + query;
     }
+
+    @FunctionalInterface
+    public interface IntConsumer {
+        void execute(int i);
+    }","[{'comment': 'This can be removed.', 'commenter': 'orpiske'}]"
11838,components/camel-azure/camel-azure-servicebus/src/main/java/org/apache/camel/component/azure/servicebus/ServiceBusProducer.java,"@@ -147,12 +147,12 @@ private BiConsumer<Exchange, AsyncCallback> sendMessages() {
 
             Mono<Void> sendMessageAsync;
 
-            if (exchange.getMessage().getBody() instanceof Iterable) {
+            if (exchange.getMessage().getBody() instanceof Iterable<?>) {
                 sendMessageAsync
-                        = serviceBusSenderOperations.sendMessages(convertBodyToList((Iterable<Object>) inputBody),
+                        = serviceBusSenderOperations.sendMessages(convertBodyToList((Iterable<?>) inputBody),
                                 configurationOptionsProxy.getServiceBusTransactionContext(exchange), applicationProperties);
             } else {
-                sendMessageAsync = serviceBusSenderOperations.sendMessages(exchange.getMessage().getBody(String.class),
+                sendMessageAsync = serviceBusSenderOperations.sendMessages(inputBody,","[{'comment': 'What if the input body is a Java class or somethig else. Does ASB know how to handle all kind of java objects ?', 'commenter': 'davsclaus'}, {'comment': ""As I can see both consumers and producers will support only String, byte[] and BinaryData and only those types(besides special AmqpMessageBody and ServiceBusReceivedMessage types) are supported by underlying Azure library.\r\nI think that client developer can always convert any other Java type to String if necessary in proper way(including Camel type converters) than doing it internally and implicitly with toString() method or implicit Camel type converters(as it works so far).\r\n\r\nBinary data like Protobuf messages(our case) can't be properly converted to String type and I believe that many other organizations may have met the same limitation already.\r\n\r\nI understand that potentially that change can break some potentially existing clients who were relying on such implicit conversion of different Java types to String so such change shouldn't be released as minor version upgrade 4.1.X but I hope it can be included in 4.2.0 release together with documentation update.\r\n\r\nMaybe we can add the same change in new Camel 3.X.0 release as well(if any planned)."", 'commenter': 'a-mazurok'}, {'comment': 'In case of other Java types `ServiceBusUtils` will throw `IllegalArgumentException(""Make sure your message data is in String, byte[] or BinaryData"")`(not changed that).', 'commenter': 'a-mazurok'}, {'comment': 'Ok thanks, but we need to leverage Camels type converter systems, so eg if your body is a `java.io.File` or `InputStream` then they can be sent as-is also. \r\n\r\nAnd is BinaryData some kind of azure class ?', 'commenter': 'davsclaus'}, {'comment': ""Yes, BinaryData is Azure special class that is like wrapper that can hold both Strings and bytes inside.\r\nIf I correctly understand your thoughts direction then probably some new endpoint configuration property should be added e.g. `binary` with default value false(backward compatible) that will control if Camel should try to convert any Java class to String or byte[] unless it is already BinaryData type that doesn't need any conversion. "", 'commenter': 'a-mazurok'}, {'comment': 'Yeah that sounds like a good idea.', 'commenter': 'davsclaus'}, {'comment': 'Added new property ""binary"".', 'commenter': 'a-mazurok'}]"
11870,parent/pom.xml,"@@ -952,6 +953,11 @@
                 <artifactId>camel-chunk</artifactId>
                 <version>${project.version}</version>
             </dependency>
+            <dependency>
+                <groupId>org.apache.camel</groupId>
+                <artifactId>camel-cifs</artifactId>","[{'comment': 'Is thius really needed?', 'commenter': 'oscerd'}, {'comment': ""Man, that's not needed. That's very strange. That was the old name I started this component with. I'll erase my local cache and rebuild. Thanks for pointing it out!"", 'commenter': 'orpiske'}]"
11870,components/camel-smb/src/main/resources/META-INF/services/org/apache/camel/component/smb,"@@ -0,0 +1 @@
+class=org.apache.camel.component.cifs.SmbComponent","[{'comment': ""This is also wrong (just noticed based on @oscerd's comment above)"", 'commenter': 'orpiske'}]"
11882,core/camel-core/src/test/java/org/apache/camel/impl/converter/TypeResolverHelperTest.java,"@@ -0,0 +1,76 @@
+package org.apache.camel.impl.converter;","[{'comment': 'Missing license header', 'commenter': 'oscerd'}, {'comment': 'fixed', 'commenter': 'fil512'}]"
11882,core/camel-core/src/test/java/org/apache/camel/impl/converter/TypeResolverHelperTest.java,"@@ -0,0 +1,76 @@
+package org.apache.camel.impl.converter;
+
+import org.apache.camel.TypeConverter;
+import org.apache.camel.converter.TypeConvertible;
+import org.apache.camel.support.SimpleTypeConverter;
+import org.junit.jupiter.api.BeforeAll;
+import org.junit.jupiter.api.Test;
+
+import java.util.HashMap;
+import java.util.Map;
+
+import static org.junit.jupiter.api.Assertions.*;","[{'comment': ""Don't use * imports"", 'commenter': 'oscerd'}, {'comment': 'fixed', 'commenter': 'fil512'}]"
11906,components/camel-dynamic-router/pom.xml,"@@ -69,4 +69,23 @@
       <scope>test</scope>
     </dependency>
   </dependencies>
+
+  <build>","[{'comment': 'Is these settings really needed, we dont have this kind in the other compomnents', 'commenter': 'davsclaus'}, {'comment': 'I am really not sure what I was doing there, so I will just remove it.', 'commenter': 'Steve973'}]"
11906,components/camel-dynamic-router/src/main/java/org/apache/camel/component/dynamicrouter/DynamicRouterControlChannelProcessor.java,"@@ -156,20 +157,22 @@ DynamicRouterControlMessage handleControlMessage(final Exchange exchange) {
     public boolean process(final Exchange exchange, final AsyncCallback callback) {
         LOG.debug(""Received control channel message"");
         DynamicRouterControlMessage controlMessage = handleControlMessage(exchange);
-        final DynamicRouterProcessor processor = Optional.ofNullable(component.getRoutingProcessor(controlMessage.getChannel()))
-                .orElseThrow(() -> new IllegalArgumentException(
-                        ""Control channel message is invalid: wrong channel, or no processors present.""));
-        switch (controlMessage.getMessageType()) {
-            case SUBSCRIBE:
-                processor.addFilter(controlMessage);
-                exchange.getIn().setBody(controlMessage.getId(), String.class);
-                break;
-            case UNSUBSCRIBE:
-                processor.removeFilter(controlMessage.getId());
-                break;
-            default:
-                // Cannot get here due to enum
-                break;
+        try (DynamicRouterMulticastProcessor processor
+                = Optional.ofNullable(component.getRoutingProcessor(controlMessage.getChannel()))
+                        .orElseThrow(() -> new IllegalArgumentException(
+                                ""Control channel message is invalid: wrong channel, or no processors present.""))) {
+            switch (controlMessage.getMessageType()) {
+                case SUBSCRIBE -> {
+                    processor.addFilter(controlMessage);
+                    exchange.getIn().setBody(controlMessage.getId(), String.class);
+                }
+                case UNSUBSCRIBE -> processor.removeFilter(controlMessage.getId());
+                default -> {
+                    // Cannot get here due to enum
+                }
+            }
+        } catch (IOException e) {
+            throw new RuntimeException(e);","[{'comment': 'This is wrong, you should do\r\n\r\nexchange.setException(e);', 'commenter': 'davsclaus'}, {'comment': ""Thanks.  I'll change it as requested."", 'commenter': 'Steve973'}]"
11906,components/camel-dynamic-router/src/main/java/org/apache/camel/component/dynamicrouter/DynamicRouterControlChannelProcessor.java,"@@ -156,20 +157,22 @@ DynamicRouterControlMessage handleControlMessage(final Exchange exchange) {
     public boolean process(final Exchange exchange, final AsyncCallback callback) {
         LOG.debug(""Received control channel message"");
         DynamicRouterControlMessage controlMessage = handleControlMessage(exchange);
-        final DynamicRouterProcessor processor = Optional.ofNullable(component.getRoutingProcessor(controlMessage.getChannel()))
-                .orElseThrow(() -> new IllegalArgumentException(
-                        ""Control channel message is invalid: wrong channel, or no processors present.""));
-        switch (controlMessage.getMessageType()) {
-            case SUBSCRIBE:
-                processor.addFilter(controlMessage);
-                exchange.getIn().setBody(controlMessage.getId(), String.class);
-                break;
-            case UNSUBSCRIBE:
-                processor.removeFilter(controlMessage.getId());
-                break;
-            default:
-                // Cannot get here due to enum
-                break;
+        try (DynamicRouterMulticastProcessor processor
+                = Optional.ofNullable(component.getRoutingProcessor(controlMessage.getChannel()))
+                        .orElseThrow(() -> new IllegalArgumentException(
+                                ""Control channel message is invalid: wrong channel, or no processors present.""))) {","[{'comment': 'This is wrong you should set exchange on exchange and not throw it. And then call callback done true and return true to exit', 'commenter': 'davsclaus'}, {'comment': ""Thanks.  I'll change it as requested."", 'commenter': 'Steve973'}]"
11906,components/camel-dynamic-router/src/main/java/org/apache/camel/component/dynamicrouter/DynamicRouterControlChannelProcessor.java,"@@ -156,20 +157,22 @@ DynamicRouterControlMessage handleControlMessage(final Exchange exchange) {
     public boolean process(final Exchange exchange, final AsyncCallback callback) {
         LOG.debug(""Received control channel message"");
         DynamicRouterControlMessage controlMessage = handleControlMessage(exchange);
-        final DynamicRouterProcessor processor = Optional.ofNullable(component.getRoutingProcessor(controlMessage.getChannel()))
-                .orElseThrow(() -> new IllegalArgumentException(
-                        ""Control channel message is invalid: wrong channel, or no processors present.""));
-        switch (controlMessage.getMessageType()) {
-            case SUBSCRIBE:
-                processor.addFilter(controlMessage);
-                exchange.getIn().setBody(controlMessage.getId(), String.class);
-                break;
-            case UNSUBSCRIBE:
-                processor.removeFilter(controlMessage.getId());
-                break;
-            default:
-                // Cannot get here due to enum
-                break;
+        try (DynamicRouterMulticastProcessor processor
+                = Optional.ofNullable(component.getRoutingProcessor(controlMessage.getChannel()))
+                        .orElseThrow(() -> new IllegalArgumentException(
+                                ""Control channel message is invalid: wrong channel, or no processors present.""))) {
+            switch (controlMessage.getMessageType()) {
+                case SUBSCRIBE -> {
+                    processor.addFilter(controlMessage);
+                    exchange.getIn().setBody(controlMessage.getId(), String.class);
+                }
+                case UNSUBSCRIBE -> processor.removeFilter(controlMessage.getId());
+                default -> {
+                    // Cannot get here due to enum
+                }
+            }
+        } catch (IOException e) {","[{'comment': 'Should catch Exception not only IO', 'commenter': 'davsclaus'}, {'comment': 'Have a look at the changes from your previous comments.  I am not sure the try/catch is still needed.', 'commenter': 'Steve973'}]"
11906,components/camel-dynamic-router/src/main/java/org/apache/camel/component/dynamicrouter/DynamicRouterControlChannelProcessor.java,"@@ -156,20 +157,22 @@ DynamicRouterControlMessage handleControlMessage(final Exchange exchange) {
     public boolean process(final Exchange exchange, final AsyncCallback callback) {
         LOG.debug(""Received control channel message"");
         DynamicRouterControlMessage controlMessage = handleControlMessage(exchange);
-        final DynamicRouterProcessor processor = Optional.ofNullable(component.getRoutingProcessor(controlMessage.getChannel()))
-                .orElseThrow(() -> new IllegalArgumentException(
-                        ""Control channel message is invalid: wrong channel, or no processors present.""));
-        switch (controlMessage.getMessageType()) {
-            case SUBSCRIBE:
-                processor.addFilter(controlMessage);
-                exchange.getIn().setBody(controlMessage.getId(), String.class);
-                break;
-            case UNSUBSCRIBE:
-                processor.removeFilter(controlMessage.getId());
-                break;
-            default:
-                // Cannot get here due to enum
-                break;
+        try (DynamicRouterMulticastProcessor processor
+                = Optional.ofNullable(component.getRoutingProcessor(controlMessage.getChannel()))
+                        .orElseThrow(() -> new IllegalArgumentException(
+                                ""Control channel message is invalid: wrong channel, or no processors present.""))) {
+            switch (controlMessage.getMessageType()) {
+                case SUBSCRIBE -> {
+                    processor.addFilter(controlMessage);
+                    exchange.getIn().setBody(controlMessage.getId(), String.class);","[{'comment': 'Should maybe be changed from getIn to getMessage', 'commenter': 'davsclaus'}, {'comment': 'Thanks.  I will change it as requested.', 'commenter': 'Steve973'}]"
11906,components/camel-dynamic-router/src/main/java/org/apache/camel/component/dynamicrouter/DynamicRouterEndpoint.java,"@@ -140,30 +149,87 @@ protected void doInit() throws Exception {
         super.doInit();","[{'comment': 'Is all this code in the constructor? If so it should be moved to doInit where you do all kind of initialization', 'commenter': 'davsclaus'}, {'comment': 'Apologies, but I am not sure what you mean.  It looks like you are referring to the code in `doInit()`, so I must be misunderstanding you.  Could you please clarify?', 'commenter': 'Steve973'}]"
11906,components/camel-dynamic-router/src/main/java/org/apache/camel/component/dynamicrouter/DynamicRouterMulticastProcessor.java,"@@ -0,0 +1,292 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.dynamicrouter;
+
+import java.util.*;
+import java.util.concurrent.ExecutorService;
+import java.util.function.Supplier;
+import java.util.stream.Collectors;
+
+import org.apache.camel.*;
+import org.apache.camel.processor.FilterProcessor;
+import org.apache.camel.processor.MulticastProcessor;
+import org.apache.camel.processor.ProcessorExchangePair;
+import org.apache.camel.spi.ProducerCache;
+import org.apache.camel.support.*;
+import org.apache.camel.support.service.ServiceHelper;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import static org.apache.camel.component.dynamicrouter.DynamicRouterConstants.MODE_FIRST_MATCH;
+
+public class DynamicRouterMulticastProcessor extends MulticastProcessor {
+
+    private static final Logger LOG = LoggerFactory.getLogger(DynamicRouterMulticastProcessor.class);
+
+    /**
+     * Template for a logging endpoint, showing all, and multiline.
+     */
+    private static final String LOG_ENDPOINT = ""log:%s.%s?level=%s&showAll=true&multiline=true"";
+
+    private boolean ignoreInvalidEndpoints;
+
+    private final ProducerCache producerCache;
+
+    /**
+     * {@link FilterProcessor}s, mapped by subscription ID, to determine if the incoming exchange should be routed based
+     * on the content.
+     */
+    private final TreeMap<String, PrioritizedFilter> filterMap;
+
+    /**
+     * Indicates the behavior of the Dynamic Router when routing participants are selected to receive an incoming
+     * exchange. If the mode is ""firstMatch"", then the exchange is routed only to the first participant that has a
+     * matching predicate. If the mode is ""allMatch"", then the exchange is routed to all participants that have a
+     * matching predicate.
+     */
+    private final String recipientMode;
+
+    /**
+     * The {@link FilterProcessor} factory.
+     */
+    private final Supplier<PrioritizedFilter.PrioritizedFilterFactory> filterProcessorFactorySupplier;
+
+    /**
+     * Flag to log a warning if a message is dropped due to no matching filters.
+     */
+    private final boolean warnDroppedMessage;
+
+    public DynamicRouterMulticastProcessor(String id, CamelContext camelContext, Route route, String recipientMode,
+                                           final boolean warnDroppedMessage,
+                                           final Supplier<PrioritizedFilter.PrioritizedFilterFactory> filterProcessorFactorySupplier,
+                                           ProducerCache producerCache, AggregationStrategy aggregationStrategy,
+                                           boolean parallelProcessing, ExecutorService executorService,
+                                           boolean shutdownExecutorService,
+                                           boolean streaming, boolean stopOnException,
+                                           long timeout, Processor onPrepare, boolean shareUnitOfWork,
+                                           boolean parallelAggregate) {
+        super(camelContext, route, new ArrayList<>(), aggregationStrategy, parallelProcessing, executorService,
+              shutdownExecutorService,
+              streaming, stopOnException, timeout, onPrepare,
+              shareUnitOfWork, parallelAggregate);
+        setId(id);
+        this.producerCache = producerCache;
+        this.filterMap = new TreeMap<>();
+        this.recipientMode = recipientMode;
+        this.filterProcessorFactorySupplier = filterProcessorFactorySupplier;
+        this.warnDroppedMessage = warnDroppedMessage;
+    }
+
+    public boolean isIgnoreInvalidEndpoints() {
+        return ignoreInvalidEndpoints;
+    }
+
+    public void setIgnoreInvalidEndpoints(boolean ignoreInvalidEndpoints) {
+        this.ignoreInvalidEndpoints = ignoreInvalidEndpoints;
+    }
+
+    protected List<Processor> createEndpointProcessors(Exchange exchange) {
+        List<String> recipientList = matchFilters(exchange).stream()
+                .map(PrioritizedFilter::getEndpoint)
+                .distinct()
+                .map(String::trim)
+                .collect(Collectors.toList());
+        if (recipientList.isEmpty()) {
+            // No matching filters, so we will use the default filter that will create a
+            // notification that there were no routing participants that matched the
+            // exchange, which results in a ""dropped"" message.
+            Message exchangeIn = exchange.getIn();
+            Object originalBody = exchangeIn.getBody();
+            exchangeIn.setHeader(""originalBody"", originalBody);
+            String endpoint = String.format(LOG_ENDPOINT, this.getClass().getCanonicalName(), getId(),
+                    warnDroppedMessage ? ""WARN"" : ""DEBUG"");
+            recipientList.add(endpoint);
+            String error = String.format(","[{'comment': 'Hmmm why is this a plain string message returned and not an exception or something, its a bit weird', 'commenter': 'davsclaus'}, {'comment': 'The idea is that, at any given time, recipients could be there, or they could be absent.  If one participant sends a message and there are no recipients for a message, then that message is logged.  In configuration, it can be specified to set this log level to `WARN`.  Otherwise, it is just logged at the debug level.  In a subsequent ticket, I could add the option to set an exception on the exchange when there are no valid recipients present for a message.', 'commenter': 'Steve973'}]"
11906,components/camel-dynamic-router/src/main/java/org/apache/camel/component/dynamicrouter/DynamicRouterEndpoint.java,"@@ -16,21 +16,26 @@
  */
 package org.apache.camel.component.dynamicrouter;
 
+import java.util.concurrent.ExecutorService;
 import java.util.function.Supplier;
 
-import org.apache.camel.Category;
-import org.apache.camel.Consumer;
-import org.apache.camel.Processor;
-import org.apache.camel.Producer;
+import org.apache.camel.*;","[{'comment': 'Just a minor thing: we tend to avoid using star imports.', 'commenter': 'orpiske'}, {'comment': 'Thanks.  I will change it as requested.', 'commenter': 'Steve973'}]"
11906,components/camel-dynamic-router/src/main/java/org/apache/camel/component/dynamicrouter/DynamicRouterEndpoint.java,"@@ -140,30 +149,87 @@ protected void doInit() throws Exception {
         super.doInit();
         DynamicRouterComponent component = getDynamicRouterComponent();
         if (CONTROL_CHANNEL_NAME.equals(configuration.getChannel())) {
-            final DynamicRouterControlChannelProcessor processor = controlChannelProcessorFactorySupplier.get()
-                    .getInstance(component);
-            processor.setConfiguration(configuration);
             try {
                 // There can be multiple control actions, but we do not want to
                 // create another consumer on the control channel, so check to
                 // see if the consumer has already been created, and skip the
                 // creation of another consumer if one already exists
                 if (component.getControlChannelProcessor() == null) {
+                    DynamicRouterControlChannelProcessor processor = controlChannelProcessorFactorySupplier.get()
+                            .getInstance(component);
+                    processor.setConfiguration(configuration);
                     component.setControlChannelProcessor(processor);
                 }
             } catch (Exception e) {
                 throw new IllegalStateException(""Could not create Dynamic Router endpoint"", e);
             }
         } else {
-            final DynamicRouterProcessor processor = processorFactorySupplier.get()
-                    .getInstance(""dynamicRouterProcessor-"" + configuration.getChannel(), getCamelContext(),
-                            configuration.getRecipientMode(), configuration.isWarnDroppedMessage(),
-                            filterProcessorFactorySupplier);
-            ServiceHelper.startService(processor);
+            CamelContext camelContext = getCamelContext();
+            String routeId = configuration.getRouteId();
+            long timeout = configuration.getTimeout();
+            ErrorHandler errorHandler = new NoErrorHandler(null);
+            if (producerCache == null) {
+                producerCache = new DefaultProducerCache(this, camelContext, 1000);
+            }
+            ExecutorService aggregateExecutorService = camelContext.getExecutorServiceManager()
+                    .newScheduledThreadPool(this, ""DynamicRouter-AggregateTask"", 0);
+            if (timeout > 0) {
+                // use a cached thread pool so we each on-the-fly task has a dedicated thread to process completions as they come in
+                aggregateExecutorService = camelContext.getExecutorServiceManager()
+                        .newScheduledThreadPool(this, ""DynamicRouter-AggregateTask"", 0);
+            }
+            AggregationStrategy aggregationStrategy = determineAggregationStrategy(camelContext);
+            DynamicRouterMulticastProcessor processor = processorFactorySupplier.get()
+                    .getInstance(""DynamicRouterMulticastProcessor-"" + configuration.getChannel(), camelContext, null,
+                            configuration.getRecipientMode(),
+                            configuration.isWarnDroppedMessage(), filterProcessorFactorySupplier, producerCache,
+                            aggregationStrategy, configuration.isParallelProcessing(),
+                            determineExecutorService(camelContext), configuration.isShutdownExecutorService(),
+                            configuration.isStreaming(), configuration.isStopOnException(), timeout,
+                            determineOnPrepare(camelContext), configuration.isShareUnitOfWork(),
+                            configuration.isParallelAggregate());
+            processor.setErrorHandler(errorHandler);
+            processor.setAggregateExecutorService(aggregateExecutorService);
+            processor.setIgnoreInvalidEndpoints(configuration.isIgnoreInvalidEndpoints());
+            processor.setId(getId());
+            processor.setRouteId(routeId);","[{'comment': ""I'd probably split this part outside of the init method. I've been broken these large methods in core for a while because: 1. they are hard to read and maintain and 2. they affect JIT compiler ability to inline code when needed. \r\nEven though this is not on the hot path, I would still like to keep the code easier to read/maintain."", 'commenter': 'orpiske'}, {'comment': 'Thanks.  I have no problem with this, so I will make the change that you requested.', 'commenter': 'Steve973'}]"
11906,components/camel-dynamic-router/src/main/java/org/apache/camel/component/dynamicrouter/DynamicRouterEndpoint.java,"@@ -140,30 +149,87 @@ protected void doInit() throws Exception {
         super.doInit();
         DynamicRouterComponent component = getDynamicRouterComponent();
         if (CONTROL_CHANNEL_NAME.equals(configuration.getChannel())) {
-            final DynamicRouterControlChannelProcessor processor = controlChannelProcessorFactorySupplier.get()
-                    .getInstance(component);
-            processor.setConfiguration(configuration);
             try {
                 // There can be multiple control actions, but we do not want to
                 // create another consumer on the control channel, so check to
                 // see if the consumer has already been created, and skip the
                 // creation of another consumer if one already exists
                 if (component.getControlChannelProcessor() == null) {
+                    DynamicRouterControlChannelProcessor processor = controlChannelProcessorFactorySupplier.get()
+                            .getInstance(component);
+                    processor.setConfiguration(configuration);
                     component.setControlChannelProcessor(processor);
                 }
             } catch (Exception e) {
                 throw new IllegalStateException(""Could not create Dynamic Router endpoint"", e);
             }
         } else {
-            final DynamicRouterProcessor processor = processorFactorySupplier.get()
-                    .getInstance(""dynamicRouterProcessor-"" + configuration.getChannel(), getCamelContext(),
-                            configuration.getRecipientMode(), configuration.isWarnDroppedMessage(),
-                            filterProcessorFactorySupplier);
-            ServiceHelper.startService(processor);
+            CamelContext camelContext = getCamelContext();
+            String routeId = configuration.getRouteId();
+            long timeout = configuration.getTimeout();
+            ErrorHandler errorHandler = new NoErrorHandler(null);
+            if (producerCache == null) {
+                producerCache = new DefaultProducerCache(this, camelContext, 1000);
+            }
+            ExecutorService aggregateExecutorService = camelContext.getExecutorServiceManager()
+                    .newScheduledThreadPool(this, ""DynamicRouter-AggregateTask"", 0);
+            if (timeout > 0) {
+                // use a cached thread pool so we each on-the-fly task has a dedicated thread to process completions as they come in
+                aggregateExecutorService = camelContext.getExecutorServiceManager()
+                        .newScheduledThreadPool(this, ""DynamicRouter-AggregateTask"", 0);
+            }
+            AggregationStrategy aggregationStrategy = determineAggregationStrategy(camelContext);
+            DynamicRouterMulticastProcessor processor = processorFactorySupplier.get()
+                    .getInstance(""DynamicRouterMulticastProcessor-"" + configuration.getChannel(), camelContext, null,
+                            configuration.getRecipientMode(),
+                            configuration.isWarnDroppedMessage(), filterProcessorFactorySupplier, producerCache,
+                            aggregationStrategy, configuration.isParallelProcessing(),
+                            determineExecutorService(camelContext), configuration.isShutdownExecutorService(),
+                            configuration.isStreaming(), configuration.isStopOnException(), timeout,
+                            determineOnPrepare(camelContext), configuration.isShareUnitOfWork(),
+                            configuration.isParallelAggregate());
+            processor.setErrorHandler(errorHandler);
+            processor.setAggregateExecutorService(aggregateExecutorService);
+            processor.setIgnoreInvalidEndpoints(configuration.isIgnoreInvalidEndpoints());
+            processor.setId(getId());
+            processor.setRouteId(routeId);
+            ServiceHelper.startService(aggregationStrategy, producerCache, processor);
             component.addRoutingProcessor(configuration.getChannel(), processor);
         }
     }
 
+    protected ExecutorService determineExecutorService(CamelContext camelContext) {
+        ExecutorService executorService = null;
+        if (ObjectHelper.isNotEmpty(configuration.getExecutorService())) {
+            executorService = camelContext.getExecutorServiceManager()
+                    .newThreadPool(this, ""@RecipientList"", configuration.getExecutorService());
+        }
+        if (configuration.isParallelProcessing() && configuration.getExecutorService() == null) {
+            // we are running in parallel, so we need a thread pool
+            executorService = camelContext.getExecutorServiceManager()
+                    .newDefaultThreadPool(this, ""@RecipientList"");
+        }
+        return executorService;
+    }
+
+    protected AggregationStrategy determineAggregationStrategy(CamelContext camelContext) {
+        AggregationStrategy aggregationStrategy = new UseLatestAggregationStrategy();
+        if (ObjectHelper.isNotEmpty(configuration.getAggregationStrategy())) {
+            aggregationStrategy = CamelContextHelper.mandatoryLookup(camelContext,
+                    configuration.getAggregationStrategy(), AggregationStrategy.class);
+        }
+        return aggregationStrategy;
+    }
+
+    protected Processor determineOnPrepare(CamelContext camelContext) {
+        Processor processor = exchange -> {
+        };
+        if (ObjectHelper.isNotEmpty(configuration.getOnPrepare())) {
+            processor = CamelContextHelper.mandatoryLookup(camelContext, configuration.getOnPrepare(), Processor.class);
+        }
+        return processor;","[{'comment': 'Maybe return a static processor to avoid the lambda/instantiation overhead. Something like:\r\n\r\n\r\n```\r\n  \r\n        if (ObjectHelper.isNotEmpty(configuration.getOnPrepare())) {\r\n                return CamelContextHelper.mandatoryLookup(camelContext, configuration.getOnPrepare(), Processor.class);\r\n        }\r\n        return SOME_STATIC_EMPTY_PROCESSOR;\r\n```\r\n\r\n', 'commenter': 'orpiske'}, {'comment': 'Thanks.  I will change it as requested.', 'commenter': 'Steve973'}]"
11906,components/camel-dynamic-router/src/main/java/org/apache/camel/component/dynamicrouter/DynamicRouterEndpoint.java,"@@ -140,30 +149,87 @@ protected void doInit() throws Exception {
         super.doInit();
         DynamicRouterComponent component = getDynamicRouterComponent();
         if (CONTROL_CHANNEL_NAME.equals(configuration.getChannel())) {
-            final DynamicRouterControlChannelProcessor processor = controlChannelProcessorFactorySupplier.get()
-                    .getInstance(component);
-            processor.setConfiguration(configuration);
             try {
                 // There can be multiple control actions, but we do not want to
                 // create another consumer on the control channel, so check to
                 // see if the consumer has already been created, and skip the
                 // creation of another consumer if one already exists
                 if (component.getControlChannelProcessor() == null) {
+                    DynamicRouterControlChannelProcessor processor = controlChannelProcessorFactorySupplier.get()
+                            .getInstance(component);
+                    processor.setConfiguration(configuration);
                     component.setControlChannelProcessor(processor);
                 }
             } catch (Exception e) {
                 throw new IllegalStateException(""Could not create Dynamic Router endpoint"", e);
             }
         } else {
-            final DynamicRouterProcessor processor = processorFactorySupplier.get()
-                    .getInstance(""dynamicRouterProcessor-"" + configuration.getChannel(), getCamelContext(),
-                            configuration.getRecipientMode(), configuration.isWarnDroppedMessage(),
-                            filterProcessorFactorySupplier);
-            ServiceHelper.startService(processor);
+            CamelContext camelContext = getCamelContext();
+            String routeId = configuration.getRouteId();
+            long timeout = configuration.getTimeout();
+            ErrorHandler errorHandler = new NoErrorHandler(null);
+            if (producerCache == null) {
+                producerCache = new DefaultProducerCache(this, camelContext, 1000);
+            }
+            ExecutorService aggregateExecutorService = camelContext.getExecutorServiceManager()
+                    .newScheduledThreadPool(this, ""DynamicRouter-AggregateTask"", 0);
+            if (timeout > 0) {
+                // use a cached thread pool so we each on-the-fly task has a dedicated thread to process completions as they come in
+                aggregateExecutorService = camelContext.getExecutorServiceManager()
+                        .newScheduledThreadPool(this, ""DynamicRouter-AggregateTask"", 0);
+            }
+            AggregationStrategy aggregationStrategy = determineAggregationStrategy(camelContext);
+            DynamicRouterMulticastProcessor processor = processorFactorySupplier.get()
+                    .getInstance(""DynamicRouterMulticastProcessor-"" + configuration.getChannel(), camelContext, null,
+                            configuration.getRecipientMode(),
+                            configuration.isWarnDroppedMessage(), filterProcessorFactorySupplier, producerCache,
+                            aggregationStrategy, configuration.isParallelProcessing(),
+                            determineExecutorService(camelContext), configuration.isShutdownExecutorService(),
+                            configuration.isStreaming(), configuration.isStopOnException(), timeout,
+                            determineOnPrepare(camelContext), configuration.isShareUnitOfWork(),
+                            configuration.isParallelAggregate());
+            processor.setErrorHandler(errorHandler);
+            processor.setAggregateExecutorService(aggregateExecutorService);
+            processor.setIgnoreInvalidEndpoints(configuration.isIgnoreInvalidEndpoints());
+            processor.setId(getId());
+            processor.setRouteId(routeId);
+            ServiceHelper.startService(aggregationStrategy, producerCache, processor);
             component.addRoutingProcessor(configuration.getChannel(), processor);
         }
     }
 
+    protected ExecutorService determineExecutorService(CamelContext camelContext) {
+        ExecutorService executorService = null;
+        if (ObjectHelper.isNotEmpty(configuration.getExecutorService())) {
+            executorService = camelContext.getExecutorServiceManager()
+                    .newThreadPool(this, ""@RecipientList"", configuration.getExecutorService());
+        }
+        if (configuration.isParallelProcessing() && configuration.getExecutorService() == null) {
+            // we are running in parallel, so we need a thread pool
+            executorService = camelContext.getExecutorServiceManager()
+                    .newDefaultThreadPool(this, ""@RecipientList"");
+        }
+        return executorService;
+    }
+
+    protected AggregationStrategy determineAggregationStrategy(CamelContext camelContext) {
+        AggregationStrategy aggregationStrategy = new UseLatestAggregationStrategy();
+        if (ObjectHelper.isNotEmpty(configuration.getAggregationStrategy())) {
+            aggregationStrategy = CamelContextHelper.mandatoryLookup(camelContext,
+                    configuration.getAggregationStrategy(), AggregationStrategy.class);
+        }
+        return aggregationStrategy;","[{'comment': 'This is creating an `UseLatestAggregationStrategy` object unnecessarily, which can add overhead to the GC. Try something like this:\r\n\r\n```\r\n        if (ObjectHelper.isNotEmpty(configuration.getAggregationStrategy())) {\r\n            return CamelContextHelper.mandatoryLookup(camelContext,\r\n                    configuration.getAggregationStrategy(), AggregationStrategy.class);\r\n        }\r\n        // only create a new one if necessary\r\n        return new UseLatestAggregationStrategy()\r\n```', 'commenter': 'orpiske'}, {'comment': 'Thanks.  I will make the change as requested.', 'commenter': 'Steve973'}]"
11906,components/camel-dynamic-router/src/main/java/org/apache/camel/component/dynamicrouter/DynamicRouterMulticastProcessor.java,"@@ -0,0 +1,292 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.dynamicrouter;
+
+import java.util.*;
+import java.util.concurrent.ExecutorService;
+import java.util.function.Supplier;
+import java.util.stream.Collectors;
+
+import org.apache.camel.*;
+import org.apache.camel.processor.FilterProcessor;
+import org.apache.camel.processor.MulticastProcessor;
+import org.apache.camel.processor.ProcessorExchangePair;
+import org.apache.camel.spi.ProducerCache;
+import org.apache.camel.support.*;
+import org.apache.camel.support.service.ServiceHelper;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import static org.apache.camel.component.dynamicrouter.DynamicRouterConstants.MODE_FIRST_MATCH;
+
+public class DynamicRouterMulticastProcessor extends MulticastProcessor {
+
+    private static final Logger LOG = LoggerFactory.getLogger(DynamicRouterMulticastProcessor.class);
+
+    /**
+     * Template for a logging endpoint, showing all, and multiline.
+     */
+    private static final String LOG_ENDPOINT = ""log:%s.%s?level=%s&showAll=true&multiline=true"";
+
+    private boolean ignoreInvalidEndpoints;
+
+    private final ProducerCache producerCache;
+
+    /**
+     * {@link FilterProcessor}s, mapped by subscription ID, to determine if the incoming exchange should be routed based
+     * on the content.
+     */
+    private final TreeMap<String, PrioritizedFilter> filterMap;
+
+    /**
+     * Indicates the behavior of the Dynamic Router when routing participants are selected to receive an incoming
+     * exchange. If the mode is ""firstMatch"", then the exchange is routed only to the first participant that has a
+     * matching predicate. If the mode is ""allMatch"", then the exchange is routed to all participants that have a
+     * matching predicate.
+     */
+    private final String recipientMode;
+
+    /**
+     * The {@link FilterProcessor} factory.
+     */
+    private final Supplier<PrioritizedFilter.PrioritizedFilterFactory> filterProcessorFactorySupplier;
+
+    /**
+     * Flag to log a warning if a message is dropped due to no matching filters.
+     */
+    private final boolean warnDroppedMessage;
+
+    public DynamicRouterMulticastProcessor(String id, CamelContext camelContext, Route route, String recipientMode,
+                                           final boolean warnDroppedMessage,
+                                           final Supplier<PrioritizedFilter.PrioritizedFilterFactory> filterProcessorFactorySupplier,
+                                           ProducerCache producerCache, AggregationStrategy aggregationStrategy,
+                                           boolean parallelProcessing, ExecutorService executorService,
+                                           boolean shutdownExecutorService,
+                                           boolean streaming, boolean stopOnException,
+                                           long timeout, Processor onPrepare, boolean shareUnitOfWork,
+                                           boolean parallelAggregate) {
+        super(camelContext, route, new ArrayList<>(), aggregationStrategy, parallelProcessing, executorService,
+              shutdownExecutorService,
+              streaming, stopOnException, timeout, onPrepare,
+              shareUnitOfWork, parallelAggregate);
+        setId(id);
+        this.producerCache = producerCache;
+        this.filterMap = new TreeMap<>();
+        this.recipientMode = recipientMode;
+        this.filterProcessorFactorySupplier = filterProcessorFactorySupplier;
+        this.warnDroppedMessage = warnDroppedMessage;
+    }
+
+    public boolean isIgnoreInvalidEndpoints() {
+        return ignoreInvalidEndpoints;
+    }
+
+    public void setIgnoreInvalidEndpoints(boolean ignoreInvalidEndpoints) {
+        this.ignoreInvalidEndpoints = ignoreInvalidEndpoints;
+    }
+
+    protected List<Processor> createEndpointProcessors(Exchange exchange) {","[{'comment': ""This method is very likely too large to be inlined by the JIT compiler. I haven't analyzed, but I suspect it could be on the hot path ... so, ideally, it should be broken in smaller pieces. "", 'commenter': 'orpiske'}, {'comment': 'Thanks.  I simplified some of this, so please let me know if it looks better.', 'commenter': 'Steve973'}]"
11906,components/camel-dynamic-router/src/main/java/org/apache/camel/component/dynamicrouter/DynamicRouterMulticastProcessor.java,"@@ -0,0 +1,292 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.component.dynamicrouter;
+
+import java.util.*;
+import java.util.concurrent.ExecutorService;
+import java.util.function.Supplier;
+import java.util.stream.Collectors;
+
+import org.apache.camel.*;
+import org.apache.camel.processor.FilterProcessor;
+import org.apache.camel.processor.MulticastProcessor;
+import org.apache.camel.processor.ProcessorExchangePair;
+import org.apache.camel.spi.ProducerCache;
+import org.apache.camel.support.*;
+import org.apache.camel.support.service.ServiceHelper;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import static org.apache.camel.component.dynamicrouter.DynamicRouterConstants.MODE_FIRST_MATCH;
+
+public class DynamicRouterMulticastProcessor extends MulticastProcessor {
+
+    private static final Logger LOG = LoggerFactory.getLogger(DynamicRouterMulticastProcessor.class);
+
+    /**
+     * Template for a logging endpoint, showing all, and multiline.
+     */
+    private static final String LOG_ENDPOINT = ""log:%s.%s?level=%s&showAll=true&multiline=true"";
+
+    private boolean ignoreInvalidEndpoints;
+
+    private final ProducerCache producerCache;
+
+    /**
+     * {@link FilterProcessor}s, mapped by subscription ID, to determine if the incoming exchange should be routed based
+     * on the content.
+     */
+    private final TreeMap<String, PrioritizedFilter> filterMap;
+
+    /**
+     * Indicates the behavior of the Dynamic Router when routing participants are selected to receive an incoming
+     * exchange. If the mode is ""firstMatch"", then the exchange is routed only to the first participant that has a
+     * matching predicate. If the mode is ""allMatch"", then the exchange is routed to all participants that have a
+     * matching predicate.
+     */
+    private final String recipientMode;
+
+    /**
+     * The {@link FilterProcessor} factory.
+     */
+    private final Supplier<PrioritizedFilter.PrioritizedFilterFactory> filterProcessorFactorySupplier;
+
+    /**
+     * Flag to log a warning if a message is dropped due to no matching filters.
+     */
+    private final boolean warnDroppedMessage;
+
+    public DynamicRouterMulticastProcessor(String id, CamelContext camelContext, Route route, String recipientMode,
+                                           final boolean warnDroppedMessage,
+                                           final Supplier<PrioritizedFilter.PrioritizedFilterFactory> filterProcessorFactorySupplier,
+                                           ProducerCache producerCache, AggregationStrategy aggregationStrategy,
+                                           boolean parallelProcessing, ExecutorService executorService,
+                                           boolean shutdownExecutorService,
+                                           boolean streaming, boolean stopOnException,
+                                           long timeout, Processor onPrepare, boolean shareUnitOfWork,
+                                           boolean parallelAggregate) {
+        super(camelContext, route, new ArrayList<>(), aggregationStrategy, parallelProcessing, executorService,
+              shutdownExecutorService,
+              streaming, stopOnException, timeout, onPrepare,
+              shareUnitOfWork, parallelAggregate);
+        setId(id);
+        this.producerCache = producerCache;
+        this.filterMap = new TreeMap<>();
+        this.recipientMode = recipientMode;
+        this.filterProcessorFactorySupplier = filterProcessorFactorySupplier;
+        this.warnDroppedMessage = warnDroppedMessage;
+    }
+
+    public boolean isIgnoreInvalidEndpoints() {
+        return ignoreInvalidEndpoints;
+    }
+
+    public void setIgnoreInvalidEndpoints(boolean ignoreInvalidEndpoints) {
+        this.ignoreInvalidEndpoints = ignoreInvalidEndpoints;
+    }
+
+    protected List<Processor> createEndpointProcessors(Exchange exchange) {
+        List<String> recipientList = matchFilters(exchange).stream()
+                .map(PrioritizedFilter::getEndpoint)
+                .distinct()
+                .map(String::trim)
+                .collect(Collectors.toList());
+        if (recipientList.isEmpty()) {
+            // No matching filters, so we will use the default filter that will create a
+            // notification that there were no routing participants that matched the
+            // exchange, which results in a ""dropped"" message.
+            Message exchangeIn = exchange.getIn();
+            Object originalBody = exchangeIn.getBody();
+            exchangeIn.setHeader(""originalBody"", originalBody);
+            String endpoint = String.format(LOG_ENDPOINT, this.getClass().getCanonicalName(), getId(),
+                    warnDroppedMessage ? ""WARN"" : ""DEBUG"");
+            recipientList.add(endpoint);
+            String error = String.format(
+                    ""DynamicRouter '%s': no filters matched for an exchange with id: '%s', from route: '%s'.  "" +
+                                         ""The 'originalBody' header contains the original message body."",
+                    getId(), exchange.getExchangeId(), exchange.getFromEndpoint());
+            exchangeIn.setBody(error, String.class);
+        }
+
+        return recipientList.stream()
+                .map(uri -> {
+                    Endpoint endpoint;
+                    try {
+                        endpoint = Optional.ofNullable(exchange.getContext().hasEndpoint(uri))
+                                .orElse(ExchangeHelper.resolveEndpoint(exchange, uri));
+                    } catch (Exception e) {
+                        if (isIgnoreInvalidEndpoints()) {
+                            LOG.debug(""Endpoint uri is invalid: {}. This exception will be ignored."", uri, e);
+                            return null;
+                        } else {
+                            // failure so break out
+                            throw e;
+                        }
+                    }
+                    return endpoint;
+                })
+                .filter(Objects::nonNull)
+                .map(endpoint -> {
+                    Producer producer = producerCache.acquireProducer(endpoint);
+                    Route route = ExchangeHelper.getRoute(exchange);
+                    return wrapInErrorHandler(route, exchange, producer);
+                })
+                .toList();
+    }","[{'comment': 'Re: my comment above about this being too large.\r\n\r\nI would also move this separately and, I think, I would reconsider using the streams here as it would create iterator objects under the hood and could add pressure to the GC. ', 'commenter': 'orpiske'}, {'comment': 'Thanks.  I see what you mean.  Like I mentioned in the previous reply, I have simplified this a bit, so I am looking forward to your feedback.', 'commenter': 'Steve973'}]"
11906,components/camel-dynamic-router/src/main/java/org/apache/camel/component/dynamicrouter/DynamicRouterConfiguration.java,"@@ -131,6 +129,103 @@ public class DynamicRouterConfiguration {
     @UriParam(label = ""common"", defaultValue = ""false"")
     private boolean warnDroppedMessage;
 
+    /**
+     * The ID of the route.
+     */
+    @UriParam(label = ""common"")
+    private String routeId;","[{'comment': 'Why do you need this option and if so, then can you make a better description', 'commenter': 'davsclaus'}]"
11906,components/camel-dynamic-router/src/main/java/org/apache/camel/component/dynamicrouter/DynamicRouterConfiguration.java,"@@ -131,6 +129,103 @@ public class DynamicRouterConfiguration {
     @UriParam(label = ""common"", defaultValue = ""false"")
     private boolean warnDroppedMessage;
 
+    /**
+     * The ID of the route.
+     */
+    @UriParam(label = ""common"")
+    private String routeId;
+
+    /**
+     * If enabled, then sending via multicast occurs concurrently. Note that the caller thread will still wait until all
+     * messages have been fully processed before it continues. It is only the sending and processing of the replies from
+     * the multicast recipients that happens concurrently. When parallel processing is enabled, then the Camel routing
+     * engine will continue processing using the last used thread from the parallel thread pool. However, if you want to
+     * use the original thread that called the multicast, then make sure to enable the synchronous option as well.
+     */
+    @UriParam(label = ""common"", defaultValue = ""false"")
+    private boolean parallelProcessing;
+
+    /**
+     * If enabled then the aggregate method on AggregationStrategy can be called concurrently. Notice that this would
+     * require the implementation of AggregationStrategy to be implemented as thread-safe. By default, this is false,
+     * meaning that Camel synchronizes the call to the aggregate method. Though, in some use-cases, this can be used to
+     * archive higher performance when the AggregationStrategy is implemented as thread-safe.
+     */
+    @UriParam(label = ""common"", defaultValue = ""false"")
+    private boolean parallelAggregate;
+
+    /**
+     * Will stop further processing if an exception or failure occurred during processing of an
+     * {@link org.apache.camel.Exchange} and the caused exception will be thrown. Will also stop if processing the
+     * exchange failed (has a fault message), or an exception was thrown and handled by the error handler (such as using
+     * onException). In all situations, the multicast will stop further processing. This is the same behavior as in the
+     * pipeline that is used by the routing engine. The default behavior is to not stop, but to continue processing
+     * until the end.
+     */
+    @UriParam(label = ""common"", defaultValue = ""false"")
+    private boolean stopOnException;
+
+    /**
+     * Ignore the invalid endpoint exception when attempting to create a producer with an invalid endpoint.
+     */
+    @UriParam(label = ""common"", defaultValue = ""false"")
+    private boolean ignoreInvalidEndpoints;
+
+    /**
+     * If enabled, then Camel will process replies out-of-order (e.g., in the order they come back). If disabled, Camel
+     * will process replies in the same order as defined by the multicast.
+     */
+    @UriParam(label = ""common"", defaultValue = ""false"")
+    private boolean streaming;
+
+    /**
+     * Sets a total timeout specified in milliseconds, when using parallel processing. If the Multicast has not been
+     * able to send and process all replies within the given timeframe, then the timeout triggers and the Multicast
+     * breaks out and continues. Notice that, if you provide a TimeoutAwareAggregationStrategy, then the timeout method
+     * is invoked before breaking out. If the timeout is reached with running tasks still remaining, certain tasks (for
+     * which it is difficult for Camel to shut down in a graceful manner) may continue to run. So use this option with a
+     * bit of care.
+     */
+    @UriParam(label = ""common"", defaultValue = ""-1"")
+    private long timeout;
+
+    /**
+     * Uses the Processor when preparing the {@link org.apache.camel.Exchange} to be sent. This can be used to
+     * deep-clone messages that should be sent, or to provide any custom logic that is needed before the exchange is
+     * sent.
+     */
+    @UriParam(label = ""common"")
+    private String onPrepare;
+
+    /**
+     * Shares the {@link org.apache.camel.spi.UnitOfWork} with the parent and each of the sub messages. Multicast will,
+     * by default, not share a unit of work between the parent exchange and each multicasted exchange. This means each
+     * sub exchange has its own individual unit of work.
+     */
+    @UriParam(label = ""common"", defaultValue = ""false"")
+    private boolean shareUnitOfWork;
+
+    /**
+     * Refers to a custom Thread Pool to be used for parallel processing. Notice that, if you set this option, then
+     * parallel processing is automatically implied, and you do not have to enable that option in addition to this one.
+     */
+    @UriParam(label = ""common"")
+    private String executorService;
+
+    /**
+     * TODO: not a configuration setting","[{'comment': 'TODO here', 'commenter': 'davsclaus'}, {'comment': 'Indeed.  It is now TODONE -- I removed that option.', 'commenter': 'Steve973'}]"
11906,components/camel-dynamic-router/src/main/java/org/apache/camel/component/dynamicrouter/DynamicRouterEndpoint.java,"@@ -140,30 +152,90 @@ protected void doInit() throws Exception {
         super.doInit();
         DynamicRouterComponent component = getDynamicRouterComponent();
         if (CONTROL_CHANNEL_NAME.equals(configuration.getChannel())) {
-            final DynamicRouterControlChannelProcessor processor = controlChannelProcessorFactorySupplier.get()
-                    .getInstance(component);
-            processor.setConfiguration(configuration);
             try {
                 // There can be multiple control actions, but we do not want to
                 // create another consumer on the control channel, so check to
                 // see if the consumer has already been created, and skip the
                 // creation of another consumer if one already exists
                 if (component.getControlChannelProcessor() == null) {
+                    DynamicRouterControlChannelProcessor processor = controlChannelProcessorFactorySupplier.get()
+                            .getInstance(component);
+                    processor.setConfiguration(configuration);
                     component.setControlChannelProcessor(processor);
                 }
             } catch (Exception e) {
                 throw new IllegalStateException(""Could not create Dynamic Router endpoint"", e);
             }
         } else {
-            final DynamicRouterProcessor processor = processorFactorySupplier.get()
-                    .getInstance(""dynamicRouterProcessor-"" + configuration.getChannel(), getCamelContext(),
-                            configuration.getRecipientMode(), configuration.isWarnDroppedMessage(),
-                            filterProcessorFactorySupplier);
-            ServiceHelper.startService(processor);
+            CamelContext camelContext = getCamelContext();
+            String routeId = configuration.getRouteId();
+            long timeout = configuration.getTimeout();
+            ErrorHandler errorHandler = new NoErrorHandler(null);
+            if (producerCache == null) {
+                producerCache = new DefaultProducerCache(this, camelContext, 1000);
+            }
+            ExecutorService aggregateExecutorService = camelContext.getExecutorServiceManager()","[{'comment': 'This looks a bit wrong where you create 2x thread pool if timeout > 0', 'commenter': 'davsclaus'}]"
11920,components/camel-kafka/src/main/java/org/apache/camel/component/kafka/consumer/support/KafkaRecordProcessor.java,"@@ -112,30 +115,48 @@ public ProcessingResult processExchange(
             exchange.setException(e);
         }
         if (exchange.getException() != null) {
-            boolean breakOnErrorExit = processException(exchange, partition, lastResult.getPartitionLastOffset(),
+            
+            LOG.debug(""an exception was thrown for record at partition {} and offset {}"",
+                    record.partition(), record.offset());
+            
+            boolean breakOnErrorExit = processException(exchange, topicPartition, record, lastResult,
                     exceptionHandler);
-            return new ProcessingResult(breakOnErrorExit, lastResult.getPartitionLastOffset(), true);
+            
+            return new ProcessingResult(breakOnErrorExit, lastResult.getPartition(), lastResult.getPartitionLastOffset(), true);
         } else {
-            return new ProcessingResult(false, record.offset(), exchange.getException() != null);
+            return new ProcessingResult(false, record.partition(), record.offset(), exchange.getException() != null);
         }
     }
 
     private boolean processException(
-            Exchange exchange, TopicPartition partition, long partitionLastOffset,
+            Exchange exchange, TopicPartition topicPartition, 
+            ConsumerRecord<Object, Object> record, ProcessingResult lastResult,
             ExceptionHandler exceptionHandler) {
 
         // processing failed due to an unhandled exception, what should we do
         if (configuration.isBreakOnFirstError()) {
+            
+            if (lastResult.getPartition() != -1 &&
+                lastResult.getPartition() != record.partition()) {
+                LOG.error(""about to process an exception with UNEXPECTED partition & offset. Got topic partition {}. "" + 
+                        "" The last result was on partition {} with offset {} but was expecting partition {} with offset {}"",
+                        topicPartition.partition(), lastResult.getPartition(), lastResult.getPartitionLastOffset(), 
+                        record.partition(), record.offset());
+            }
+            
             // we are failing and we should break out
             if (LOG.isWarnEnabled()) {
-                LOG.warn(""Error during processing {} from topic: {}"", exchange, partition.topic(), exchange.getException());
-                LOG.warn(""Will seek consumer to offset {} and start polling again."", partitionLastOffset);
+                LOG.warn(""Error during processing {} from topic: {}"", exchange, topicPartition.topic(), exchange.getException());","[{'comment': 'Maybe also log the exception message for more details? \r\n\r\n```\r\nLOG.warn(""Error during processing exchange {} from topic {}: {}"", exchange, topicPartition.topic(), exchange.getException() ? null : exchange.getException().getMessage(), exchange.getException());\r\n```', 'commenter': 'orpiske'}, {'comment': 'Obs.: the exception message may also be present elsewhere in the log, but if the intention is to provide more data, I think it would be OK. ', 'commenter': 'orpiske'}, {'comment': 'Just one more note: the code as it is, is still not printing the exception message. ', 'commenter': 'orpiske'}, {'comment': 'This is the only item remaining. As it is now, it is logging the message. Instead, I would like it to be exactly like this:\r\n\r\n```\r\nLOG.warn(""Error during processing exchange {} from topic {}: {}"", exchange, topicPartition.topic(), exchange.getException() ? null : exchange.getException().getMessage(), exchange.getException());\r\n```\r\n\r\nJust copy/paste the code above and it should be fine ⬆️ ', 'commenter': 'orpiske'}]"
11920,components/camel-kafka/src/main/java/org/apache/camel/component/kafka/consumer/support/ProcessingResult.java,"@@ -21,14 +21,16 @@
 
 public final class ProcessingResult {
     private static final ProcessingResult UNPROCESSED_RESULT
-            = new ProcessingResult(false, AbstractCommitManager.START_OFFSET, false);
+            = new ProcessingResult(false, -1, AbstractCommitManager.START_OFFSET, false);","[{'comment': 'Please, use a constant here and document it. That way it may be easier for us to understand the code later on.', 'commenter': 'orpiske'}]"
11920,components/camel-kafka/src/main/java/org/apache/camel/component/kafka/consumer/support/KafkaRecordProcessor.java,"@@ -112,30 +115,48 @@ public ProcessingResult processExchange(
             exchange.setException(e);
         }
         if (exchange.getException() != null) {
-            boolean breakOnErrorExit = processException(exchange, partition, lastResult.getPartitionLastOffset(),
+            
+            LOG.debug(""an exception was thrown for record at partition {} and offset {}"",
+                    record.partition(), record.offset());
+            
+            boolean breakOnErrorExit = processException(exchange, topicPartition, record, lastResult,
                     exceptionHandler);
-            return new ProcessingResult(breakOnErrorExit, lastResult.getPartitionLastOffset(), true);
+            
+            return new ProcessingResult(breakOnErrorExit, lastResult.getPartition(), lastResult.getPartitionLastOffset(), true);
         } else {
-            return new ProcessingResult(false, record.offset(), exchange.getException() != null);
+            return new ProcessingResult(false, record.partition(), record.offset(), exchange.getException() != null);
         }
     }
 
     private boolean processException(
-            Exchange exchange, TopicPartition partition, long partitionLastOffset,
+            Exchange exchange, TopicPartition topicPartition, 
+            ConsumerRecord<Object, Object> record, ProcessingResult lastResult,
             ExceptionHandler exceptionHandler) {
 
         // processing failed due to an unhandled exception, what should we do
         if (configuration.isBreakOnFirstError()) {
+            
+            if (lastResult.getPartition() != -1 &&
+                lastResult.getPartition() != record.partition()) {
+                LOG.error(""about to process an exception with UNEXPECTED partition & offset. Got topic partition {}. "" + 
+                        "" The last result was on partition {} with offset {} but was expecting partition {} with offset {}"",
+                        topicPartition.partition(), lastResult.getPartition(), lastResult.getPartitionLastOffset(), 
+                        record.partition(), record.offset());
+            }
+            
             // we are failing and we should break out
             if (LOG.isWarnEnabled()) {
-                LOG.warn(""Error during processing {} from topic: {}"", exchange, partition.topic(), exchange.getException());
-                LOG.warn(""Will seek consumer to offset {} and start polling again."", partitionLastOffset);
+                LOG.warn(""Error during processing {} from topic: {}"", exchange, topicPartition.topic(), exchange.getException());
+                LOG.warn(""Will seek consumer to offset {} on partition {} and start polling again."", 
+                        lastResult.getPartitionLastOffset(), lastResult.getPartition());
             }
 
-            // force commit, so we resume on next poll where we failed except when the failure happened
-            // at the first message in a poll
-            if (partitionLastOffset != AbstractCommitManager.START_OFFSET) {
-                commitManager.forceCommit(partition, partitionLastOffset);
+            // force commit, so we resume on next poll where we failed 
+            // except when the failure happened at the first message in a poll
+            if (lastResult.getPartitionLastOffset() != AbstractCommitManager.START_OFFSET) {
+                // should we use record.offset ?
+                //commitManager.forceCommit(topicPartition, record.offset() - 1);","[{'comment': ""this change that is commented out is what mostly addresses the issues found in CAMEL-20044 and CAMEL-19894\r\n\r\nI can submit this as a separate PR \r\nI commented it out here b/c I had not added unit tests and b/c I wasn't sure if that would impact other ways that the Camel riders would want breakOnFirstError to work\r\n\r\nI did see CAMEL-20089 but hope this fix can move forward as we it does fix 2 other issues "", 'commenter': 'CodeSmell'}, {'comment': ""In this case, it's better to remove the code. We can always refer to the git log for details about the history of the code. "", 'commenter': 'orpiske'}, {'comment': 'I am working on a separate PR for the fix\r\nIs this worth pursuing?', 'commenter': 'CodeSmell'}, {'comment': ""Yes it is. If you can fix it, we'll be happy to look at your proposed changes. \r\n\r\nObs.: I am talking about being better to remove the commented code. "", 'commenter': 'orpiske'}, {'comment': 'Cool. Removed', 'commenter': 'CodeSmell'}]"
11930,pull_request_CAMEL-20061.md,"@@ -0,0 +1,40 @@
+# Description","[{'comment': 'Thanks but this should be removed. You should add some information in src/main/docs, maybe a parameter.', 'commenter': 'oscerd'}, {'comment': 'deleted the file', 'commenter': 'brunoriemenschneider'}]"
11930,components/camel-smpp/src/main/java/org/apache/camel/component/smpp/SmppConfiguration.java,"@@ -733,6 +735,26 @@ public void setSingleDLR(boolean singleDLR) {
         this.singleDLR = singleDLR;
     }
 
+    public String getInterfaceVersion() {
+        return interfaceVersion;
+    }
+
+    /**
+     * Defines the interface version to be used in the binding request with the SMSC. The following values are allowed,
+     * as defined in the SMPP protocol:
+     * <ul>","[{'comment': 'Since this will be used to generate documentation I would avoid ul and li, because for the Javadoc they will be good, but for generating the website they could be a mess.', 'commenter': 'oscerd'}, {'comment': 'I have used the syntax that a lot of the other configuration fields have used (look at this file and scroll up for a few cases). I can see though that they are not really useful in the docs (https://camel.apache.org/components/4.0.x/smpp-component.html). Will remove.', 'commenter': 'brunoriemenschneider'}, {'comment': ""Looks good then. I never noticed that, maybe because I didn't work on this specific component. All good."", 'commenter': 'oscerd'}]"
11930,components/camel-smpp/src/main/java/org/apache/camel/component/smpp/SmppConfiguration.java,"@@ -120,6 +120,8 @@ public class SmppConfiguration implements Cloneable {
     private Integer pduProcessorQueueCapacity = 100;
     @UriParam(label = ""advanced"", defaultValue = ""false"")
     private boolean singleDLR;
+    @UriParam(label = ""advanced"", enums = ""0x00,0x33,0x34,0x50"", defaultValue = ""0x34"")
+    private String interfaceVersion = ""0x34"";","[{'comment': 'Maybe just use a plain string to set the value in better human understandable as just a string with 3.3, 3.4, 5.0 etc. And then internally convert that to what jsnmp uses.', 'commenter': 'davsclaus'}, {'comment': 'The SMPP protocol uses these codes (e.g. se https://smpp.org/SMPP_v5.pdf - chapter 4.7.13) in its specification. Are you sure I should remove them? (Code is simpler/easier to understand like this)', 'commenter': 'brunoriemenschneider'}, {'comment': 'I have introduced a new scheme using ""legacy"", ""3.3"", ""3.4"", ""5.0""', 'commenter': 'brunoriemenschneider'}]"
11930,components/camel-smpp/src/main/java/org/apache/camel/component/smpp/SmppConsumer.java,"@@ -109,7 +110,8 @@ private SMPPSession createSession() throws IOException {
                         BindType.BIND_RX, this.configuration.getSystemId(),
                         this.configuration.getPassword(), this.configuration.getSystemType(),
                         TypeOfNumber.UNKNOWN, NumberingPlanIndicator.UNKNOWN,
-                        configuration.getAddressRange()));
+                        configuration.getAddressRange(),
+                        InterfaceVersion.valueOf(Byte.decode(configuration.getInterfaceVersion()))));","[{'comment': 'See prev comments', 'commenter': 'davsclaus'}, {'comment': 'See above', 'commenter': 'brunoriemenschneider'}]"
11934,core/camel-core/src/test/java/org/apache/camel/component/file/FileConsumerFailureHandledTest.java,"@@ -57,7 +57,7 @@ public void testLondon() throws Exception {
         mock.expectedBodiesReceived(""London"");
 
         template.sendBodyAndHeader(fileUri(), ""London"", Exchange.FILE_NAME, ""london.txt"");
-        mock.assertIsSatisfied(1000);
+        mock.assertIsSatisfied(3000);","[{'comment': 'Why the timeout increase?', 'commenter': 'orpiske'}, {'comment': ""I couldn't find another explanation why this test has failed on a previous PR check run, as locally it passes when I run all camel-core tests. The same I see now but with other tests. After this change of timeout, this `FileConsumerFailureHandledTest` passes but two others fail: \r\n- `org.apache.camel.processor.MulticastParallelTimeoutStreamCachingTest.testCreateOutputStreamCacheBeforeTimeoutButWriteToOutputStreamCacheAfterTimeout`\r\n- `org.apache.camel.processor.MulticastParallelStreamingTest.testMulticastParallel`\r\n\r\nBoth don't use temp directory anyhow and shouldn't be affected by my changes, so I'm wondering how stable such tests are. I'm very new to it so I'm trying to understand if it's something that can happen ocassionally due to slower test execution, or if it's related to my PR changes. I apologize for my confusion as someone new, but really appreciate your guidance and open to suggestions 🙂"", 'commenter': 'anton-goncharov'}, {'comment': 'So, the challenge here is that we have to balance two things: \r\n\r\n1. Quick test execution \r\n2. Stability \r\n\r\n\r\nIn some of the systems where these tests run, such as GitHub, the systems running them could be overloaded at the time of execution. Some tests use fixed sleeps and/or timeouts to wait for ""something"" to happen, but this process is not stable at all (hence, why we have been converting most of the sleeps with Awaitility). \r\n\r\nI suspect that\'s why you see these new failures: maybe if you run them again, you\'ll see a different set of failures. \r\n\r\nNormally, what we do is that we use the [ASF CI](https://ci-builds.apache.org/job/Camel/job/Camel%20JDK17/) as the baseline: as long as tests run fine there, we are OK with it (and we are a bit lenient with [most of] the core check failures on GitHub).\r\n\r\nSo, in this case, I\'d leave it as is. ', 'commenter': 'orpiske'}, {'comment': 'Thanks for the explanation, I will revert the timeouts then and set them back to 1000', 'commenter': 'anton-goncharov'}, {'comment': 'Reverted back to 1000', 'commenter': 'anton-goncharov'}]"
11934,core/camel-core/src/test/java/org/apache/camel/TestSupport.java,"@@ -445,43 +422,6 @@ public static Channel unwrapChannel(Processor processor) {
         }
     }
 
-    /**
-     * Recursively delete a directory, useful to zapping test data
-     *
-     * @param file the directory to be deleted
-     */
-    public static void deleteDirectory(String file) {
-        deleteDirectory(new File(file));
-    }
-
-    /**
-     * Recursively delete a directory, useful to zapping test data
-     *
-     * @param file the directory to be deleted
-     */
-    public static void deleteDirectory(File file) {
-        if (file.isDirectory()) {
-            File[] files = file.listFiles();
-            if (files != null) {
-                for (File child : files) {
-                    deleteDirectory(child);
-                }
-            }
-        }
-
-        file.delete();
-    }
-
-    /**
-     * create the directory
-     *
-     * @param file the directory to be created
-     */
-    public static void createDirectory(String file) {
-        File dir = new File(file);
-        dir.mkdirs();
-    }
-","[{'comment': 'We probably need to document the removal of these methods on the upgrade documentation. They may be used elsewhere / by users.', 'commenter': 'orpiske'}, {'comment': 'Alternatively: wrapping them around the new `tempDir` stuff and marking them as deprecated would be acceptable as well (and, also, adding a note about their deprecation on the upgrade doc).', 'commenter': 'orpiske'}, {'comment': ""That's a good point about not removing them and deprecating instead. I'll take this approach, and will also update the upgrade doc. Thanks!"", 'commenter': 'anton-goncharov'}, {'comment': ""I added the deleted methods back and annotated as `@Deprecated`. About the doc, please let me know if I'm incorrect but this class `org.apache.camel.TestSupport` is from the `test` directory and shouldn't be visible to the end users of `camel-core`. Should I update 4.2→4.3 upgrade doc anyway?"", 'commenter': 'anton-goncharov'}, {'comment': ""Ahh, good point. In this case we don't have to update the docs."", 'commenter': 'orpiske'}]"
11934,core/camel-core/src/test/java/org/apache/camel/component/file/FileConsumerFailureHandledTest.java,"@@ -72,7 +72,7 @@ public void testDublin() throws Exception {
         mock.expectedBodiesReceived(""Dublin"");
 
         template.sendBodyAndHeader(fileUri(), ""Dublin"", Exchange.FILE_NAME, ""dublin.txt"");
-        mock.assertIsSatisfied(1000);
+        mock.assertIsSatisfied(3000);","[{'comment': 'Same note about the timeout increase.', 'commenter': 'orpiske'}, {'comment': 'Reverted back to 1000', 'commenter': 'anton-goncharov'}]"
11934,core/camel-core/src/test/java/org/apache/camel/component/file/FileConsumerFailureHandledTest.java,"@@ -87,7 +87,7 @@ public void testMadrid() throws Exception {
         mock.expectedBodiesReceived(""Madrid"");
 
         template.sendBodyAndHeader(fileUri(), ""Madrid"", Exchange.FILE_NAME, ""madrid.txt"");
-        mock.assertIsSatisfied(1000);
+        mock.assertIsSatisfied(3000);","[{'comment': 'Same note about the timeout increase.', 'commenter': 'orpiske'}, {'comment': 'Reverted back to 1000', 'commenter': 'anton-goncharov'}]"
11935,components/camel-kafka/src/main/java/org/apache/camel/component/kafka/consumer/support/KafkaRecordProcessor.java,"@@ -112,30 +115,56 @@ public ProcessingResult processExchange(
             exchange.setException(e);
         }
         if (exchange.getException() != null) {
-            boolean breakOnErrorExit = processException(exchange, partition, lastResult.getPartitionLastOffset(),
+            
+            LOG.debug(""an exception was thrown for record at partition {} and offset {}"",","[{'comment': 'Minor thing for consistency: capitalize the first letter of the log message. This is pattern we use throughout the code base.', 'commenter': 'orpiske'}]"
11935,components/camel-kafka/src/main/java/org/apache/camel/component/kafka/consumer/support/KafkaRecordProcessor.java,"@@ -112,30 +115,56 @@ public ProcessingResult processExchange(
             exchange.setException(e);
         }
         if (exchange.getException() != null) {
-            boolean breakOnErrorExit = processException(exchange, partition, lastResult.getPartitionLastOffset(),
+            
+            LOG.debug(""an exception was thrown for record at partition {} and offset {}"",
+                    record.partition(), record.offset());
+            
+            boolean breakOnErrorExit = processException(exchange, topicPartition, record, lastResult,
                     exceptionHandler);
-            return new ProcessingResult(breakOnErrorExit, lastResult.getPartitionLastOffset(), true);
+            
+            return new ProcessingResult(breakOnErrorExit, lastResult.getPartition(), lastResult.getPartitionLastOffset(), true);
         } else {
-            return new ProcessingResult(false, record.offset(), exchange.getException() != null);
+            return new ProcessingResult(false, record.partition(), record.offset(), exchange.getException() != null);
         }
     }
 
     private boolean processException(
-            Exchange exchange, TopicPartition partition, long partitionLastOffset,
+            Exchange exchange, TopicPartition topicPartition, 
+            ConsumerRecord<Object, Object> record, ProcessingResult lastResult,
             ExceptionHandler exceptionHandler) {
 
         // processing failed due to an unhandled exception, what should we do
         if (configuration.isBreakOnFirstError()) {
+            
+            if (lastResult.getPartition() != -1 &&
+                lastResult.getPartition() != record.partition()) {
+                LOG.error(""about to process an exception with UNEXPECTED partition & offset. Got topic partition {}. "" + ","[{'comment': 'Same note.', 'commenter': 'orpiske'}]"
11935,components/camel-kafka/src/main/java/org/apache/camel/component/kafka/consumer/support/KafkaRecordProcessorFacade.java,"@@ -77,6 +77,9 @@ public ProcessingResult processPolledRecords(
 
                 lastResult = processRecord(partition, partitionIterator.hasNext(), recordIterator.hasNext(), lastResult,
                         kafkaRecordProcessor, record);
+                
+                LOG.debug(""processed record on partition {} and offset {} and got result for partition {} and offset {}"",","[{'comment': 'Same note.', 'commenter': 'orpiske'}]"
11935,components/camel-kafka/src/main/java/org/apache/camel/component/kafka/consumer/support/KafkaRecordProcessor.java,"@@ -112,30 +115,56 @@ public ProcessingResult processExchange(
             exchange.setException(e);
         }
         if (exchange.getException() != null) {
-            boolean breakOnErrorExit = processException(exchange, partition, lastResult.getPartitionLastOffset(),
+            
+            LOG.debug(""an exception was thrown for record at partition {} and offset {}"",
+                    record.partition(), record.offset());
+            
+            boolean breakOnErrorExit = processException(exchange, topicPartition, record, lastResult,
                     exceptionHandler);
-            return new ProcessingResult(breakOnErrorExit, lastResult.getPartitionLastOffset(), true);
+            
+            return new ProcessingResult(breakOnErrorExit, lastResult.getPartition(), lastResult.getPartitionLastOffset(), true);
         } else {
-            return new ProcessingResult(false, record.offset(), exchange.getException() != null);
+            return new ProcessingResult(false, record.partition(), record.offset(), exchange.getException() != null);
         }
     }
 
     private boolean processException(
-            Exchange exchange, TopicPartition partition, long partitionLastOffset,
+            Exchange exchange, TopicPartition topicPartition, 
+            ConsumerRecord<Object, Object> record, ProcessingResult lastResult,
             ExceptionHandler exceptionHandler) {
 
         // processing failed due to an unhandled exception, what should we do
         if (configuration.isBreakOnFirstError()) {
+            
+            if (lastResult.getPartition() != -1 &&
+                lastResult.getPartition() != record.partition()) {
+                LOG.error(""about to process an exception with UNEXPECTED partition & offset. Got topic partition {}. "" + 
+                        "" The last result was on partition {} with offset {} but was expecting partition {} with offset {}"",
+                        topicPartition.partition(), lastResult.getPartition(), lastResult.getPartitionLastOffset(), 
+                        record.partition(), record.offset());
+            }
+            
             // we are failing and we should break out
             if (LOG.isWarnEnabled()) {
-                LOG.warn(""Error during processing {} from topic: {}"", exchange, partition.topic(), exchange.getException());
-                LOG.warn(""Will seek consumer to offset {} and start polling again."", partitionLastOffset);
+                LOG.warn(""Error during processing {} from topic: {} due to {}"", exchange, topicPartition.topic(), exchange.getException());
+                LOG.warn(""Will seek consumer to offset {} on partition {} and start polling again."", 
+                        record.offset(), record.partition());
             }
 
-            // force commit, so we resume on next poll where we failed except when the failure happened
-            // at the first message in a poll
-            if (partitionLastOffset != AbstractCommitManager.START_OFFSET) {
-                commitManager.forceCommit(partition, partitionLastOffset);
+            // force commit, so we resume on next poll where we failed 
+            // except when the failure happened at the first message in a poll
+            if (lastResult.getPartitionLastOffset() != AbstractCommitManager.START_OFFSET) {
+                // the record we are processing had the error 
+                // so we will force commit the offset prior 
+                // this will enable the current desired behavior to 
+                // retry the message 1 more time
+                //
+                // Note: without a more extensive look at handling of breakOnFirstError
+                // we will still need the lastResult so that we don't force 
+                // retrying this message over and over
+                //if (configuration.isBreakOnFirstErrorWithRetry()) {
+                    commitManager.forceCommit(topicPartition, record.offset() - 1);","[{'comment': '@orpiske \r\nsome thoughts here on this\r\n\r\nThe `forceCommit` was what we had here so kept that for now. \r\nBut based on some of the other conversations I think it may be worth changing that to `commit`.\r\n\r\nThat would defer how `breakOnFirstError` would work based on the `commitManager`\r\n\r\n- no op would mean the route implementation would have to handle the offset using `KafkaManualCommit`\r\n- using synch/asynch would mean that the record with the error would be retried \r\n\r\nthe retry will vary still based on other configuration which is what I think contributes to this flag being so complex and why there are many opinions on how it should work (CAMEL-20089)\r\n\r\nThis may be a way to alter some of the behavior in 3.x until a refactor in 4.x \r\n\r\n\r\n', 'commenter': 'CodeSmell'}, {'comment': ""Understood. I think that's fair. IMHO, it will be important to include that on the documentation as well, so users can refer to this behavior and understand what to expect. \r\n\r\nwdyt? "", 'commenter': 'orpiske'}, {'comment': ""I am good w/ what Camel team thinks is best.\r\nThe change here using `forceCommit` will fix the 2 reported issues so would like to see at least that move forward if you don't see any problems.\r\n\r\nLooking at the code, if we did make some more changes, we may be able to remove the `lastResult` object that is passed around as well since we have access to the Kafka record. \r\n\r\nI can update the docs w/ whatever the new behavior is but may need a pointer as to where/how to do that"", 'commenter': 'CodeSmell'}]"
11935,components/camel-kafka/src/test/java/org/apache/camel/component/kafka/integration/KafkaBreakOnFirstErrorSeekIssueIT.java,"@@ -0,0 +1,146 @@
+package org.apache.camel.component.kafka.integration;
+
+import org.apache.camel.Endpoint;
+import org.apache.camel.EndpointInject;
+import org.apache.camel.Exchange;
+import org.apache.camel.builder.RouteBuilder;
+import org.apache.camel.component.kafka.MockConsumerInterceptor;
+import org.apache.camel.component.mock.MockEndpoint;
+import org.apache.camel.util.CamelKafkaUtil;
+import org.apache.kafka.clients.admin.NewTopic;
+import org.apache.kafka.clients.producer.ProducerRecord;
+import org.awaitility.Awaitility;
+import org.junit.jupiter.api.AfterEach;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.util.Collections;
+import java.util.List;
+import java.util.Properties;
+import java.util.concurrent.TimeUnit;
+
+
+/**
+ * this will test breakOnFirstError functionality
+ * and the issue that was surfaced in CAMEL-19894
+ * regarding failure to correctly commit the offset
+ * in a batch using the Synch Commit Manager
+ * 
+ *  mimics the reproduction of the problem in 
+ *  https://github.com/Krivda/camel-bug-reproduction
+ */
+class KafkaBreakOnFirstErrorSeekIssueIT extends BaseEmbeddedKafkaTestSupport {
+
+    private static final Logger LOG = LoggerFactory.getLogger(KafkaBreakOnFirstErrorSeekIssueIT.class);
+
+    public static final String ROUTE_ID = ""breakOnFirstError-19894"";
+    public static final String TOPIC = ""test-foobar"";
+    
+    @EndpointInject(""kafka:"" + TOPIC
+            + ""?groupId=KafkaBreakOnFirstErrorIT""
+            + ""&autoOffsetReset=earliest""
+            + ""&autoCommitEnable=false""
+            + ""&allowManualCommit=true""
+            + ""&breakOnFirstError=true""
+            + ""&maxPollRecords=8""
+            + ""&pollTimeoutMs=1000""
+            + ""&keyDeserializer=org.apache.kafka.common.serialization.StringDeserializer""
+            + ""&valueDeserializer=org.apache.kafka.common.serialization.StringDeserializer""
+            + ""&kafkaManualCommitFactory=#class:org.apache.camel.component.kafka.consumer.DefaultKafkaManualCommitFactory""
+            + ""&interceptorClasses=org.apache.camel.component.kafka.MockConsumerInterceptor"")
+    private Endpoint from;
+
+    @EndpointInject(""mock:result"")
+    private MockEndpoint to;
+    
+    private org.apache.kafka.clients.producer.KafkaProducer<String, String> producer;
+    
+    @BeforeEach
+    public void init() {
+        // create the topic w/ 2 partitions
+        final NewTopic mytopic = new NewTopic(TOPIC, 2, (short) 1);
+        kafkaAdminClient.createTopics(Collections.singleton(mytopic));
+
+        // setup the producer
+        Properties props = getDefaultProperties();
+        producer = new org.apache.kafka.clients.producer.KafkaProducer<>(props);
+        MockConsumerInterceptor.recordsCaptured.clear();
+    }
+
+     @AfterEach
+     public void after() {
+         if (producer != null) {
+             producer.close();
+         }
+         // clean all test topics
+         kafkaAdminClient.deleteTopics(Collections.singletonList(TOPIC)).all();
+     }
+    
+    @Test
+    void test_camel_19894_test_fix() throws Exception {
+        to.reset();
+        // will consume the payloads from partition 0
+        // and will continually retry the payload with ""5""
+        to.expectedMessageCount(4);
+        to.expectedBodiesReceived(""1"", ""2"", ""3"", ""4"");
+
+        context.getRouteController().stopRoute(ROUTE_ID);
+        
+        this.publishMessagesToKafka();
+        
+        context.getRouteController().startRoute(ROUTE_ID);
+        
+        Awaitility.await()
+            .timeout(30, TimeUnit.SECONDS)
+            .pollDelay(20, TimeUnit.SECONDS)
+            .until(() -> to.getExchanges().size() == 4);
+
+        
+        to.assertIsSatisfied();
+    }
+    
+    @Override
+    protected RouteBuilder createRouteBuilder() {
+        return new RouteBuilder() {
+
+            @Override
+            public void configure() {
+                from(from)
+                    .routeId(ROUTE_ID)
+                    .autoStartup(false)
+                    .process(exchange -> {
+                        LOG.debug(CamelKafkaUtil.buildKafkaLogMessage(""Consuming"", exchange, true));
+                    })
+                    .process(exchange -> {
+                        ifIsFifthRecordThrowException(exchange);
+                    })
+                    .to(to)
+                    .end();
+            }
+        };
+    }
+    
+    private void ifIsFifthRecordThrowException(Exchange e) {
+        if (e.getMessage().getBody().equals(""5"")) {
+            throw new RuntimeException(""ERROR_TRIGGERED_BY_TEST"");
+        }
+    }
+    
+    private void publishMessagesToKafka() {
+        final List<String> producedRecordsPartition0 = List.of(""5"", ""6"", ""7"", ""8""); //, ""9"", ""10"", ""11"");","[{'comment': ""This test isn't complete as I don't think increasing the partitions is working"", 'commenter': 'CodeSmell'}]"
11935,components/camel-kafka/src/main/java/org/apache/camel/component/kafka/consumer/support/KafkaRecordProcessor.java,"@@ -149,14 +146,30 @@ private boolean processException(
                 Exception exc = exchange.getException();
                 LOG.warn(""Error during processing {} from topic: {} due to {}"", exchange, topicPartition.topic(),
                         exc.getMessage());
-                LOG.warn(""Will seek consumer to offset {} on partition {} and start polling again."",
-                        lastResult.getPartitionLastOffset(), lastResult.getPartition());
+                LOG.warn(""Will seek consumer to offset {} on partition {} and start polling again."", 
+                        record.offset(), record.partition());
             }
 
             // force commit, so we resume on next poll where we failed 
             // except when the failure happened at the first message in a poll
             if (lastResult.getPartitionLastOffset() != AbstractCommitManager.START_OFFSET) {
-                commitManager.forceCommit(topicPartition, lastResult.getPartitionLastOffset());
+                // the record we are processing had the error 
+                // so we will force commit the offset prior 
+                // this will enable the current desired behavior to 
+                // retry the message 1 more time
+                //
+                // Note: without a more extensive look at handling of breakOnFirstError
+                // we will still need the lastResult so that we don't force 
+                // retrying this message over and over
+                // commitManager.forceCommit(topicPartition, record.offset() - 1);
+                
+                // we should just do a commit (vs the original forceCommit)
+                // when route uses NOOP Commit Manager it will rely
+                // on the route implementation to explicitly commit offset
+                // when route uses Synch/Asynch Commit Manager it will 
+                // ALWAYS commit the offset for the failing record
+                // and will ALWAYS retry it
+                commitManager.commit(topicPartition);","[{'comment': 'This is the key change in behavior\r\nIt goes beyond a fix and gives route implementers ability to choose how breakOnFirstError should work using the commit manager ', 'commenter': 'CodeSmell'}]"
11935,components/camel-kafka/src/test/java/org/apache/camel/component/kafka/integration/KafkaBreakOnFirstErrorWithBatchUsingKafkaManualCommitIT.java,"@@ -0,0 +1,159 @@
+package org.apache.camel.component.kafka.integration;
+
+import org.apache.camel.Endpoint;
+import org.apache.camel.EndpointInject;
+import org.apache.camel.Exchange;
+import org.apache.camel.builder.RouteBuilder;
+import org.apache.camel.component.kafka.KafkaConstants;
+import org.apache.camel.component.kafka.MockConsumerInterceptor;
+import org.apache.camel.component.kafka.consumer.KafkaManualCommit;
+import org.apache.camel.component.mock.MockEndpoint;
+import org.apache.camel.util.CamelKafkaUtil;
+import org.apache.kafka.clients.producer.ProducerRecord;
+import org.awaitility.Awaitility;
+import org.junit.jupiter.api.AfterEach;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.util.Collections;
+import java.util.Properties;
+import java.util.concurrent.TimeUnit;
+
+import static org.junit.jupiter.api.Assertions.assertNotNull;
+
+/**
+ * this will test basic breakOnFirstError functionality
+ * uses allowManualCommit and KafkaManualCommit
+ * because relying on Camel default to use NOOP Commit Manager
+ * this means the route implementation MUST manage all offset commits
+ */
+class KafkaBreakOnFirstErrorWithBatchUsingKafkaManualCommitIT extends BaseEmbeddedKafkaTestSupport {
+
+    private static final Logger LOG = LoggerFactory.getLogger(KafkaBreakOnFirstErrorWithBatchUsingKafkaManualCommitIT.class);
+
+    public static final String ROUTE_ID = ""breakOnFirstErrorBatchOnExceptionIT"";
+    public static final String TOPIC = ""test-foobar"";
+
+    @EndpointInject(""kafka:"" + TOPIC
+            + ""?groupId=KafkaBreakOnFirstErrorIT""
+            + ""&autoOffsetReset=earliest""
+            + ""&autoCommitEnable=false""
+            + ""&allowManualCommit=true""
+            + ""&breakOnFirstError=true""
+            + ""&maxPollRecords=3""
+            + ""&pollTimeoutMs=1000""
+            + ""&keyDeserializer=org.apache.kafka.common.serialization.StringDeserializer""
+            + ""&valueDeserializer=org.apache.kafka.common.serialization.StringDeserializer""
+            + ""&interceptorClasses=org.apache.camel.component.kafka.MockConsumerInterceptor"")
+    private Endpoint from;
+
+    @EndpointInject(""mock:result"")
+    private MockEndpoint to;
+
+    private org.apache.kafka.clients.producer.KafkaProducer<String, String> producer;
+
+    @BeforeEach
+    public void before() {
+        Properties props = getDefaultProperties();
+        producer = new org.apache.kafka.clients.producer.KafkaProducer<>(props);
+        MockConsumerInterceptor.recordsCaptured.clear();
+    }
+
+    @AfterEach
+    public void after() {
+        if (producer != null) {
+            producer.close();
+        }
+        // clean all test topics
+        kafkaAdminClient.deleteTopics(Collections.singletonList(TOPIC)).all();
+    }
+    
+    /**
+     * will continue to retry the message that is in error
+     */
+    @Test
+    public void kafkaBreakOnFirstErrorBasicCapabilityWithoutOnExcepton() throws Exception {
+        to.reset();
+        to.expectedMessageCount(7);
+        
+        // old behavior before the fix
+        // message-3 causes an error 
+        // and breakOnFirstError will cause it to be retried 1x
+        // then we move on
+        //to.expectedBodiesReceivedInAnyOrder(""message-0"", ""message-1"", ""message-2"", ""message-3"", ""message-3"", ""message-4"", ""message-5"");","[{'comment': 'IMO this new behavior is what the route really wants', 'commenter': 'CodeSmell'}]"
11945,components/camel-jms/src/test/java/org/apache/camel/component/jms/AggregatedJmsRouteTest.java,"@@ -92,12 +93,8 @@ public void configure() {
                 from(timeOutEndpointUri).to(""jms:queue:AggregatedJmsRouteTestQueueB"");
 
                 from(""jms:queue:AggregatedJmsRouteTestQueueB"").aggregate(header(""cheese""), (oldExchange, newExchange) -> {
-                    try {
-                        Thread.sleep(2000);
-                    } catch (InterruptedException e) {
-                        LOG.error(""aggregation delay sleep interrupted"", e);
-                        fail(""aggregation delay sleep interrupted"");
-                    }
+                    Awaitility.await().atMost(2, TimeUnit.SECONDS)
+                            .until(() -> true);","[{'comment': 'I think Thread.sleep is fine here. ', 'commenter': 'orpiske'}]"
11945,components/camel-jms/src/test/java/org/apache/camel/component/jms/async/MyAsyncProducer.java,"@@ -51,7 +53,10 @@ public boolean process(final Exchange exchange, final AsyncCallback callback) {
         executor.submit(() -> {
 
             LOG.info(""Simulating a task which takes {} millis to reply"", getEndpoint().getDelay());
-            Thread.sleep(getEndpoint().getDelay());
+
+            Awaitility.await()
+                    .pollDelay(Duration.ofMillis(getEndpoint().getDelay()))
+                    .until(() -> true);","[{'comment': 'I think Thread.sleep is fine here.', 'commenter': 'orpiske'}]"
11945,components/camel-jms/src/test/java/org/apache/camel/component/jms/issues/TempReplyToIssueTest.java,"@@ -75,7 +78,9 @@ public String handleMessage(
         producer.stop();
 
         // sleep a bit so Camel will send the reply a bit later
-        Thread.sleep(1000);
+        Awaitility.await()
+                .pollDelay(Duration.ofMillis(1000))
+                .until(() -> true);","[{'comment': 'I think `Thread.sleep` is fine here.', 'commenter': 'orpiske'}]"
11945,components/camel-jms/src/test/java/org/apache/camel/component/jms/temp/JmsReconnectManualTest.java,"@@ -102,7 +105,9 @@ public void configure() {
          * Wait long enough for the jms client to do a full reconnect. In the Tibco EMS case this means that a Temporary
          * Destination created before is invalid now
          */
-        Thread.sleep(5000);
+        Awaitility.await()
+                .pollDelay(Duration.ofMillis(5000))
+                .until(() -> true);","[{'comment': 'I think `Thread.sleep` is fine here.', 'commenter': 'orpiske'}, {'comment': 'Makes Sense, thank you!', 'commenter': 'rafamqrs'}]"
12089,components/camel-quartz/src/main/java/org/apache/camel/component/quartz/CamelJob.java,"@@ -94,6 +101,18 @@ public void execute(JobExecutionContext context) throws JobExecutionException {
         }
     }
 
+    private boolean hasTriggerExpired(JobExecutionContext context) {
+        Date fireTime = context.getFireTime();
+        if (context.getTrigger().getStartTime() != null && fireTime.before(context.getTrigger().getStartTime())) {
+            // Trigger invalid as Fire Time is before Start Time
+            return true;
+        } else if (context.getTrigger().getEndTime() != null && fireTime.after(context.getTrigger().getEndTime())) {","[{'comment': 'I think this should not be an else if, as you can have set BOTH start and end time, and then you need to check for both of them.', 'commenter': 'davsclaus'}, {'comment': 'Indeed I missed the case, and corrected it in the new commit.', 'commenter': 'prasanthrao'}]"
12121,core/camel-core/src/test/java/org/apache/camel/processor/aggregator/AggregateCompletionByBatchConsumerTest.java,"@@ -0,0 +1,117 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.processor.aggregator;
+
+import java.util.List;
+
+import org.apache.camel.ContextTestSupport;
+import org.apache.camel.Exchange;
+import org.apache.camel.Message;
+import org.apache.camel.builder.RouteBuilder;
+import org.apache.camel.component.mock.MockEndpoint;
+import org.apache.camel.processor.aggregate.GroupedMessageAggregationStrategy;
+import org.junit.jupiter.api.Test;
+
+import static org.junit.jupiter.api.Assertions.assertEquals;
+
+public class AggregateCompletionByBatchConsumerTest extends ContextTestSupport {
+
+    @SuppressWarnings(""unchecked"")
+    @Test
+    public void testCorrelationKey() throws Exception {
+        // START SNIPPET: e2","[{'comment': 'Please remove SNIPPET ', 'commenter': 'oscerd'}]"
12121,core/camel-core/src/test/java/org/apache/camel/processor/aggregator/AggregateCompletionByBatchConsumerTest.java,"@@ -0,0 +1,117 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.processor.aggregator;
+
+import java.util.List;
+
+import org.apache.camel.ContextTestSupport;
+import org.apache.camel.Exchange;
+import org.apache.camel.Message;
+import org.apache.camel.builder.RouteBuilder;
+import org.apache.camel.component.mock.MockEndpoint;
+import org.apache.camel.processor.aggregate.GroupedMessageAggregationStrategy;
+import org.junit.jupiter.api.Test;
+
+import static org.junit.jupiter.api.Assertions.assertEquals;
+
+public class AggregateCompletionByBatchConsumerTest extends ContextTestSupport {
+
+    @SuppressWarnings(""unchecked"")
+    @Test
+    public void testCorrelationKey() throws Exception {
+        // START SNIPPET: e2
+        MockEndpoint result = getMockEndpoint(""mock:result"");
+
+        // we expect 4 messages since we group 4 batches
+        result.expectedMessageCount(4);
+
+        //BATCH_SIZE and not BATCH_COMPLETE is used by aggregate to test for batch completion
+        final Integer batch_size = Integer.valueOf(8);
+
+        // then we sent the batch of message
+        template.sendBodyAndProperty(""direct:start"", ""batch-4"", Exchange.BATCH_SIZE, batch_size);
+        template.sendBodyAndProperty(""direct:start"", ""batch-4"", Exchange.BATCH_SIZE, batch_size);
+        template.sendBodyAndProperty(""direct:start"", ""batch-3"", Exchange.BATCH_SIZE, batch_size);
+        template.sendBodyAndProperty(""direct:start"", ""batch-3"", Exchange.BATCH_SIZE, batch_size);
+        template.sendBodyAndProperty(""direct:start"", ""batch-2"", Exchange.BATCH_SIZE, batch_size);
+        template.sendBodyAndProperty(""direct:start"", ""batch-2"", Exchange.BATCH_SIZE, batch_size);
+        template.sendBodyAndProperty(""direct:start"", ""batch-1"", Exchange.BATCH_SIZE, batch_size);
+        template.sendBodyAndProperty(""direct:start"", ""batch-1"", Exchange.BATCH_SIZE, batch_size);
+
+        assertMockEndpointsSatisfied();
+
+        Exchange out;
+        List<Message> grouped;
+
+        out = result.getExchanges().get(1);
+        grouped = out.getIn().getBody(List.class);
+
+        assertEquals(2, grouped.size());
+
+        assertEquals(""batch-2"", grouped.get(0).getBody(String.class));
+        assertEquals(""batch-2"", grouped.get(1).getBody(String.class));
+        assertEquals(""batch-2"", out.getProperty(Exchange.AGGREGATED_CORRELATION_KEY));
+
+        out = result.getExchanges().get(2);
+        grouped = out.getIn().getBody(List.class);
+
+        assertEquals(2, grouped.size());
+
+        assertEquals(""batch-3"", grouped.get(0).getBody(String.class));
+        assertEquals(""batch-3"", grouped.get(1).getBody(String.class));
+        assertEquals(""batch-3"", out.getProperty(Exchange.AGGREGATED_CORRELATION_KEY));
+
+        out = result.getExchanges().get(3);
+        grouped = out.getIn().getBody(List.class);
+
+        assertEquals(2, grouped.size());
+
+        assertEquals(""batch-4"", grouped.get(0).getBody(String.class));
+        assertEquals(""batch-4"", grouped.get(1).getBody(String.class));
+        assertEquals(""batch-4"", out.getProperty(Exchange.AGGREGATED_CORRELATION_KEY));
+
+        out = result.getExchanges().get(0);
+        grouped = out.getIn().getBody(List.class);
+
+        assertEquals(2, grouped.size());
+
+        assertEquals(""batch-1"", grouped.get(0).getBody(String.class));
+        assertEquals(""batch-1"", grouped.get(1).getBody(String.class));
+        assertEquals(""batch-1"", out.getProperty(Exchange.AGGREGATED_CORRELATION_KEY));
+        // END SNIPPET: e2","[{'comment': 'Same', 'commenter': 'oscerd'}]"
12121,core/camel-core/src/test/java/org/apache/camel/processor/aggregator/AggregateCompletionByBatchConsumerTest.java,"@@ -0,0 +1,117 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.processor.aggregator;
+
+import java.util.List;
+
+import org.apache.camel.ContextTestSupport;
+import org.apache.camel.Exchange;
+import org.apache.camel.Message;
+import org.apache.camel.builder.RouteBuilder;
+import org.apache.camel.component.mock.MockEndpoint;
+import org.apache.camel.processor.aggregate.GroupedMessageAggregationStrategy;
+import org.junit.jupiter.api.Test;
+
+import static org.junit.jupiter.api.Assertions.assertEquals;
+
+public class AggregateCompletionByBatchConsumerTest extends ContextTestSupport {
+
+    @SuppressWarnings(""unchecked"")
+    @Test
+    public void testCorrelationKey() throws Exception {
+        // START SNIPPET: e2
+        MockEndpoint result = getMockEndpoint(""mock:result"");
+
+        // we expect 4 messages since we group 4 batches
+        result.expectedMessageCount(4);
+
+        //BATCH_SIZE and not BATCH_COMPLETE is used by aggregate to test for batch completion
+        final Integer batch_size = Integer.valueOf(8);
+
+        // then we sent the batch of message
+        template.sendBodyAndProperty(""direct:start"", ""batch-4"", Exchange.BATCH_SIZE, batch_size);
+        template.sendBodyAndProperty(""direct:start"", ""batch-4"", Exchange.BATCH_SIZE, batch_size);
+        template.sendBodyAndProperty(""direct:start"", ""batch-3"", Exchange.BATCH_SIZE, batch_size);
+        template.sendBodyAndProperty(""direct:start"", ""batch-3"", Exchange.BATCH_SIZE, batch_size);
+        template.sendBodyAndProperty(""direct:start"", ""batch-2"", Exchange.BATCH_SIZE, batch_size);
+        template.sendBodyAndProperty(""direct:start"", ""batch-2"", Exchange.BATCH_SIZE, batch_size);
+        template.sendBodyAndProperty(""direct:start"", ""batch-1"", Exchange.BATCH_SIZE, batch_size);
+        template.sendBodyAndProperty(""direct:start"", ""batch-1"", Exchange.BATCH_SIZE, batch_size);
+
+        assertMockEndpointsSatisfied();
+
+        Exchange out;
+        List<Message> grouped;
+
+        out = result.getExchanges().get(1);
+        grouped = out.getIn().getBody(List.class);
+
+        assertEquals(2, grouped.size());
+
+        assertEquals(""batch-2"", grouped.get(0).getBody(String.class));
+        assertEquals(""batch-2"", grouped.get(1).getBody(String.class));
+        assertEquals(""batch-2"", out.getProperty(Exchange.AGGREGATED_CORRELATION_KEY));
+
+        out = result.getExchanges().get(2);
+        grouped = out.getIn().getBody(List.class);
+
+        assertEquals(2, grouped.size());
+
+        assertEquals(""batch-3"", grouped.get(0).getBody(String.class));
+        assertEquals(""batch-3"", grouped.get(1).getBody(String.class));
+        assertEquals(""batch-3"", out.getProperty(Exchange.AGGREGATED_CORRELATION_KEY));
+
+        out = result.getExchanges().get(3);
+        grouped = out.getIn().getBody(List.class);
+
+        assertEquals(2, grouped.size());
+
+        assertEquals(""batch-4"", grouped.get(0).getBody(String.class));
+        assertEquals(""batch-4"", grouped.get(1).getBody(String.class));
+        assertEquals(""batch-4"", out.getProperty(Exchange.AGGREGATED_CORRELATION_KEY));
+
+        out = result.getExchanges().get(0);
+        grouped = out.getIn().getBody(List.class);
+
+        assertEquals(2, grouped.size());
+
+        assertEquals(""batch-1"", grouped.get(0).getBody(String.class));
+        assertEquals(""batch-1"", grouped.get(1).getBody(String.class));
+        assertEquals(""batch-1"", out.getProperty(Exchange.AGGREGATED_CORRELATION_KEY));
+        // END SNIPPET: e2
+    }
+
+    @Override
+    protected RouteBuilder createRouteBuilder() throws Exception {
+        return new RouteBuilder() {
+            public void configure() throws Exception {
+                // START SNIPPET: e1","[{'comment': 'Same', 'commenter': 'oscerd'}]"
12121,core/camel-core/src/test/java/org/apache/camel/processor/aggregator/AggregateCompletionByBatchConsumerTest.java,"@@ -0,0 +1,117 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.camel.processor.aggregator;
+
+import java.util.List;
+
+import org.apache.camel.ContextTestSupport;
+import org.apache.camel.Exchange;
+import org.apache.camel.Message;
+import org.apache.camel.builder.RouteBuilder;
+import org.apache.camel.component.mock.MockEndpoint;
+import org.apache.camel.processor.aggregate.GroupedMessageAggregationStrategy;
+import org.junit.jupiter.api.Test;
+
+import static org.junit.jupiter.api.Assertions.assertEquals;
+
+public class AggregateCompletionByBatchConsumerTest extends ContextTestSupport {
+
+    @SuppressWarnings(""unchecked"")
+    @Test
+    public void testCorrelationKey() throws Exception {
+        // START SNIPPET: e2
+        MockEndpoint result = getMockEndpoint(""mock:result"");
+
+        // we expect 4 messages since we group 4 batches
+        result.expectedMessageCount(4);
+
+        //BATCH_SIZE and not BATCH_COMPLETE is used by aggregate to test for batch completion
+        final Integer batch_size = Integer.valueOf(8);
+
+        // then we sent the batch of message
+        template.sendBodyAndProperty(""direct:start"", ""batch-4"", Exchange.BATCH_SIZE, batch_size);
+        template.sendBodyAndProperty(""direct:start"", ""batch-4"", Exchange.BATCH_SIZE, batch_size);
+        template.sendBodyAndProperty(""direct:start"", ""batch-3"", Exchange.BATCH_SIZE, batch_size);
+        template.sendBodyAndProperty(""direct:start"", ""batch-3"", Exchange.BATCH_SIZE, batch_size);
+        template.sendBodyAndProperty(""direct:start"", ""batch-2"", Exchange.BATCH_SIZE, batch_size);
+        template.sendBodyAndProperty(""direct:start"", ""batch-2"", Exchange.BATCH_SIZE, batch_size);
+        template.sendBodyAndProperty(""direct:start"", ""batch-1"", Exchange.BATCH_SIZE, batch_size);
+        template.sendBodyAndProperty(""direct:start"", ""batch-1"", Exchange.BATCH_SIZE, batch_size);
+
+        assertMockEndpointsSatisfied();
+
+        Exchange out;
+        List<Message> grouped;
+
+        out = result.getExchanges().get(1);
+        grouped = out.getIn().getBody(List.class);
+
+        assertEquals(2, grouped.size());
+
+        assertEquals(""batch-2"", grouped.get(0).getBody(String.class));
+        assertEquals(""batch-2"", grouped.get(1).getBody(String.class));
+        assertEquals(""batch-2"", out.getProperty(Exchange.AGGREGATED_CORRELATION_KEY));
+
+        out = result.getExchanges().get(2);
+        grouped = out.getIn().getBody(List.class);
+
+        assertEquals(2, grouped.size());
+
+        assertEquals(""batch-3"", grouped.get(0).getBody(String.class));
+        assertEquals(""batch-3"", grouped.get(1).getBody(String.class));
+        assertEquals(""batch-3"", out.getProperty(Exchange.AGGREGATED_CORRELATION_KEY));
+
+        out = result.getExchanges().get(3);
+        grouped = out.getIn().getBody(List.class);
+
+        assertEquals(2, grouped.size());
+
+        assertEquals(""batch-4"", grouped.get(0).getBody(String.class));
+        assertEquals(""batch-4"", grouped.get(1).getBody(String.class));
+        assertEquals(""batch-4"", out.getProperty(Exchange.AGGREGATED_CORRELATION_KEY));
+
+        out = result.getExchanges().get(0);
+        grouped = out.getIn().getBody(List.class);
+
+        assertEquals(2, grouped.size());
+
+        assertEquals(""batch-1"", grouped.get(0).getBody(String.class));
+        assertEquals(""batch-1"", grouped.get(1).getBody(String.class));
+        assertEquals(""batch-1"", out.getProperty(Exchange.AGGREGATED_CORRELATION_KEY));
+        // END SNIPPET: e2
+    }
+
+    @Override
+    protected RouteBuilder createRouteBuilder() throws Exception {
+        return new RouteBuilder() {
+            public void configure() throws Exception {
+                // START SNIPPET: e1
+                // our route is aggregating from the direct queue and sending
+                // the response to the mock
+                from(""direct:start"")
+                        // aggregate all using body and group the
+                        // exchanges so we get one single exchange containing all
+                        .aggregate(body(), new GroupedMessageAggregationStrategy())
+                        // we are simulating a batch consumer
+                        .completionFromBatchConsumer()
+                        .eagerCheckCompletion()
+                        .to(""mock:result"");
+                // END SNIPPET: e1","[{'comment': 'Same', 'commenter': 'oscerd'}]"
