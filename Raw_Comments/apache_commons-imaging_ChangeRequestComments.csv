Pull,Path,Diff_hunk,Comment
38,src/main/java/org/apache/commons/imaging/formats/png/ChunkReader.java,"@@ -0,0 +1,144 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.imaging.formats.png;
+
+import java.io.DataInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.ArrayList;
+import java.util.List;
+import org.apache.commons.imaging.ImageReadException;
+import static org.apache.commons.imaging.common.BinaryFunctions.readAndVerifyBytes;
+import org.apache.commons.imaging.common.bytesource.ByteSource;
+import org.apache.commons.imaging.formats.png.chunks.ChunkLoader;
+import org.apache.commons.imaging.formats.png.chunks.PngChunk;
+import org.apache.commons.imaging.formats.png.chunks.PngChunkIhdr;
+
+// Replaces readChunk in PngImageParser.
+// This should be a public API. This will allow 3rd party apps
+// to read chunks. Shouldn't ever break.","[{'comment': 'The javadoc here is wrong, it had to be `/**`...', 'commenter': 'kinow'}]"
38,src/main/java/org/apache/commons/imaging/formats/png/ChunkReader.java,"@@ -0,0 +1,144 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.imaging.formats.png;
+
+import java.io.DataInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.ArrayList;
+import java.util.List;
+import org.apache.commons.imaging.ImageReadException;
+import static org.apache.commons.imaging.common.BinaryFunctions.readAndVerifyBytes;
+import org.apache.commons.imaging.common.bytesource.ByteSource;
+import org.apache.commons.imaging.formats.png.chunks.ChunkLoader;
+import org.apache.commons.imaging.formats.png.chunks.PngChunk;
+import org.apache.commons.imaging.formats.png.chunks.PngChunkIhdr;
+
+// Replaces readChunk in PngImageParser.
+// This should be a public API. This will allow 3rd party apps
+// to read chunks. Shouldn't ever break.
+
+/**
+ * {@code PngReader} objects can be used to read PNG chunks from
+ * an input stream.
+ * 
+ * @author Shukant Pal","[{'comment': 'We do not use the `@author` tags any longer (if we find these, they are now removed). This was based on a decision from a long time ago, where the decision was that the source code management systems like subversion/git were taking care of this already (and supporting multiple authors, etc).', 'commenter': 'kinow'}]"
38,src/main/java/org/apache/commons/imaging/formats/png/ChunkReader.java,"@@ -0,0 +1,144 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.imaging.formats.png;
+
+import java.io.DataInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.ArrayList;
+import java.util.List;
+import org.apache.commons.imaging.ImageReadException;
+import static org.apache.commons.imaging.common.BinaryFunctions.readAndVerifyBytes;
+import org.apache.commons.imaging.common.bytesource.ByteSource;
+import org.apache.commons.imaging.formats.png.chunks.ChunkLoader;
+import org.apache.commons.imaging.formats.png.chunks.PngChunk;
+import org.apache.commons.imaging.formats.png.chunks.PngChunkIhdr;
+
+// Replaces readChunk in PngImageParser.
+// This should be a public API. This will allow 3rd party apps
+// to read chunks. Shouldn't ever break.
+
+/**
+ * {@code PngReader} objects can be used to read PNG chunks from
+ * an input stream.
+ * 
+ * @author Shukant Pal
+ */
+public class ChunkReader {
+    
+    DataInputStream input;
+    
+    /**
+     * Asserts that the input stream contains the PNG signature at the
+     * very beginning; throws an ImageReadException otherwise.
+     * 
+     * @throws IOException
+     * @throws ImageReadException ","[{'comment': 'This javadocs need explanation for each exception to prevent failures in newer JDK versions.', 'commenter': 'kinow'}]"
38,src/main/java/org/apache/commons/imaging/formats/png/ChunkReader.java,"@@ -0,0 +1,144 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.imaging.formats.png;
+
+import java.io.DataInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.ArrayList;
+import java.util.List;
+import org.apache.commons.imaging.ImageReadException;
+import static org.apache.commons.imaging.common.BinaryFunctions.readAndVerifyBytes;
+import org.apache.commons.imaging.common.bytesource.ByteSource;
+import org.apache.commons.imaging.formats.png.chunks.ChunkLoader;
+import org.apache.commons.imaging.formats.png.chunks.PngChunk;
+import org.apache.commons.imaging.formats.png.chunks.PngChunkIhdr;
+
+// Replaces readChunk in PngImageParser.
+// This should be a public API. This will allow 3rd party apps
+// to read chunks. Shouldn't ever break.
+
+/**
+ * {@code PngReader} objects can be used to read PNG chunks from
+ * an input stream.
+ * 
+ * @author Shukant Pal
+ */
+public class ChunkReader {
+    
+    DataInputStream input;
+    
+    /**
+     * Asserts that the input stream contains the PNG signature at the
+     * very beginning; throws an ImageReadException otherwise.
+     * 
+     * @throws IOException
+     * @throws ImageReadException 
+     */
+    private void assertSignature() throws IOException, ImageReadException {
+        readAndVerifyBytes(input, PngConstants.PNG_SIGNATURE,
+                ""Not a Valid PNG Segment: Incorrect Signature"");
+    }
+    
+    public ChunkReader() {    
+    }
+    
+    public ChunkReader(InputStream input) throws ImageReadException, IOException {
+        setInput(input);
+    }
+    
+    public final DataInputStream getInput() {
+        return input;
+    }
+    
+    public final void setInput(InputStream input) throws ImageReadException, IOException {
+        this.input = new DataInputStream(input);
+        assertSignature();
+    }
+    
+    /**
+     * Reads all the chunks (satisfying any filters) from the input
+     * stream containing a PNG file.
+     * 
+     * @param selector can be used to filter chunks
+     * @param returnAfterFirst
+     * @return
+     * @throws IOException
+     * @throws ImageReadException 
+     */
+    public List<PngChunk> readChunks(
+            final ChunkLoader.ChunkSelector selector, final boolean returnAfterFirst)
+            throws IOException, ImageReadException {
+        final List<PngChunk> result = new ArrayList<>();
+        
+        while(true) {
+            final ChunkLoader nextChunkLoaded = ChunkLoader.run(input, selector);
+            PngChunk loadedChunk = nextChunkLoaded.loadedChunk();
+            
+            if(loadedChunk != null) {
+                { // (Shukant Pal): I essentially hate how developers
+                  // have created a dumb PngCrc object. Couldn't it just be","[{'comment': 'This wording in a comment is not appropriate for an Open Source project. Shaming any kind of developer and behaviour is not a good idea.', 'commenter': 'kinow'}]"
38,src/main/java/org/apache/commons/imaging/formats/png/PngImageParser.java,"@@ -72,11 +79,65 @@
 
 public class PngImageParser extends ImageParser {
 
+    /*
+     * Changes done (ShukantPal): Improved code readability by using ChunkLoader","[{'comment': 'Author names not needed in these comments.', 'commenter': 'kinow'}]"
38,src/main/java/org/apache/commons/imaging/formats/png/PngImageParser.java,"@@ -100,119 +161,97 @@ public String getDefaultExtension() {
 
     // private final static int tRNS = CharsToQuad('t', 'R', 'N', 's');
 
-    public static String getChunkTypeName(final int chunkType) {
-        final StringBuilder result = new StringBuilder();
-        result.append((char) (0xff & (chunkType >> 24)));
-        result.append((char) (0xff & (chunkType >> 16)));
-        result.append((char) (0xff & (chunkType >> 8)));
-        result.append((char) (0xff & (chunkType >> 0)));
-        return result.toString();
+    public static String getChunkTypeName(final int chunkTypeCode) {
+        return new String(
+                ByteBuffer.allocate(4).putInt(chunkTypeCode).array(),
+                StandardCharsets.ISO_8859_1);
     }
 
     /**
+     * Extracts all the chunks in the PNG file (in the input stream)
+     * and returns a list of their names.
+     * 
+     * @param is
      * @return List of String-formatted chunk types, ie. ""tRNs"".
+     * @throws ImageReadException
+     * @throws IOException
      */
     public List<String> getChunkTypes(final InputStream is)
             throws ImageReadException, IOException {
         final List<PngChunk> chunks = readChunks(is, null, false);
         final List<String> chunkTypes = new ArrayList<>(chunks.size());
         for (final PngChunk chunk : chunks) {
-            chunkTypes.add(getChunkTypeName(chunk.chunkType));
+            chunkTypes.add(getChunkTypeName(chunk.chunkType.toCode()));
         }
         return chunkTypes;
     }
 
     public boolean hasChunkType(final ByteSource byteSource, final ChunkType chunkType)
             throws ImageReadException, IOException {
-        try (InputStream is = byteSource.getInputStream()) {
-            readSignature(is);
-            final List<PngChunk> chunks = readChunks(is, new ChunkType[] { chunkType }, true);
-            return !chunks.isEmpty();
-        }
-    }
-
-    private boolean keepChunk(final int chunkType, final ChunkType[] chunkTypes) {
-        // System.out.println(""keepChunk: "");
-        if (chunkTypes == null) {
-            return true;
-        }
-
-        for (final ChunkType chunkType2 : chunkTypes) {
-            if (chunkType2.value == chunkType) {
-                return true;
-            }
-        }
-        return false;
+        return ChunkReader.newInstance(byteSource)
+                .readChunks(new ChunkUniselector(true, chunkType), true)
+                .size() > 0;
     }
 
-    private List<PngChunk> readChunks(final InputStream is, final ChunkType[] chunkTypes,
-            final boolean returnAfterFirst) throws ImageReadException, IOException {
+    /**
+     * Reads all the chunks (satisfying any filters) from the input
+     * stream containing a PNG file.
+     * 
+     * Replaces the readChunks(InputStream, ChunkTypes[], boolean)
+     * method. Is clean, and readable now.
+     * 
+     * @param inputStream
+     * @param selector
+     * @param returnAfterFirst
+     * @return
+     * @throws IOException
+     * @throws ImageReadException 
+     */
+    private List<PngChunk> readChunks(final InputStream inputStream,
+            final ChunkSelector selector, final boolean returnAfterFirst)
+            throws IOException, ImageReadException {
         final List<PngChunk> result = new ArrayList<>();
-
-        while (true) {
-            final int length = read4Bytes(""Length"", is, ""Not a Valid PNG File"", getByteOrder());
-            final int chunkType = read4Bytes(""ChunkType"", is, ""Not a Valid PNG File"", getByteOrder());
-
-            if (LOGGER.isLoggable(Level.FINEST)) {
-                printCharQuad(""ChunkType"", chunkType);
-                debugNumber(""Length"", length, 4);
-            }
-            final boolean keep = keepChunk(chunkType, chunkTypes);
-
-            byte[] bytes = null;
-            if (keep) {
-                bytes = readBytes(""Chunk Data"", is, length,
-                        ""Not a Valid PNG File: Couldn't read Chunk Data."");
-            } else {
-                skipBytes(is, length, ""Not a Valid PNG File"");
-            }
-
-            if (LOGGER.isLoggable(Level.FINEST)) {
-                if (bytes != null) {
-                    debugNumber(""bytes"", bytes.length, 4);
-                }
-            }
-
-            final int crc = read4Bytes(""CRC"", is, ""Not a Valid PNG File"", getByteOrder());
-
-            if (keep) {
-                if (chunkType == ChunkType.iCCP.value) {
-                    result.add(new PngChunkIccp(length, chunkType, crc, bytes));
-                } else if (chunkType == ChunkType.tEXt.value) {
-                    result.add(new PngChunkText(length, chunkType, crc, bytes));
-                } else if (chunkType == ChunkType.zTXt.value) {
-                    result.add(new PngChunkZtxt(length, chunkType, crc, bytes));
-                } else if (chunkType == ChunkType.IHDR.value) {
-                    result.add(new PngChunkIhdr(length, chunkType, crc, bytes));
-                } else if (chunkType == ChunkType.PLTE.value) {
-                    result.add(new PngChunkPlte(length, chunkType, crc, bytes));
-                } else if (chunkType == ChunkType.pHYs.value) {
-                    result.add(new PngChunkPhys(length, chunkType, crc, bytes));
-                } else if (chunkType == ChunkType.sCAL.value) {
-                    result.add(new PngChunkScal(length, chunkType, crc, bytes));
-                } else if (chunkType == ChunkType.IDAT.value) {
-                    result.add(new PngChunkIdat(length, chunkType, crc, bytes));
-                } else if (chunkType == ChunkType.gAMA.value) {
-                    result.add(new PngChunkGama(length, chunkType, crc, bytes));
-                } else if (chunkType == ChunkType.iTXt.value) {
-                    result.add(new PngChunkItxt(length, chunkType, crc, bytes));
-                } else {
-                    result.add(new PngChunk(length, chunkType, crc, bytes));
+        final DataInputStream dataInput = new DataInputStream(inputStream);
+        
+        while(true) {
+            final ChunkLoader nextChunkLoaded = ChunkLoader.run(dataInput, selector);
+            PngChunk loadedChunk = nextChunkLoaded.loadedChunk();
+            
+            if(loadedChunk != null) {
+                { // (Shukant Pal): I essentially hate how developers","[{'comment': 'Author name not needed. And see note about this kind of note in a previous comment. We must be polite and nice to each developer, no matter how good or bad their code can be.', 'commenter': 'kinow'}]"
38,src/main/java/org/apache/commons/imaging/formats/png/PngImageParser.java,"@@ -100,119 +161,97 @@ public String getDefaultExtension() {
 
     // private final static int tRNS = CharsToQuad('t', 'R', 'N', 's');
 
-    public static String getChunkTypeName(final int chunkType) {
-        final StringBuilder result = new StringBuilder();
-        result.append((char) (0xff & (chunkType >> 24)));
-        result.append((char) (0xff & (chunkType >> 16)));
-        result.append((char) (0xff & (chunkType >> 8)));
-        result.append((char) (0xff & (chunkType >> 0)));
-        return result.toString();
+    public static String getChunkTypeName(final int chunkTypeCode) {
+        return new String(
+                ByteBuffer.allocate(4).putInt(chunkTypeCode).array(),
+                StandardCharsets.ISO_8859_1);
     }
 
     /**
+     * Extracts all the chunks in the PNG file (in the input stream)
+     * and returns a list of their names.
+     * 
+     * @param is
      * @return List of String-formatted chunk types, ie. ""tRNs"".
+     * @throws ImageReadException
+     * @throws IOException
      */
     public List<String> getChunkTypes(final InputStream is)
             throws ImageReadException, IOException {
         final List<PngChunk> chunks = readChunks(is, null, false);
         final List<String> chunkTypes = new ArrayList<>(chunks.size());
         for (final PngChunk chunk : chunks) {
-            chunkTypes.add(getChunkTypeName(chunk.chunkType));
+            chunkTypes.add(getChunkTypeName(chunk.chunkType.toCode()));
         }
         return chunkTypes;
     }
 
     public boolean hasChunkType(final ByteSource byteSource, final ChunkType chunkType)
             throws ImageReadException, IOException {
-        try (InputStream is = byteSource.getInputStream()) {
-            readSignature(is);
-            final List<PngChunk> chunks = readChunks(is, new ChunkType[] { chunkType }, true);
-            return !chunks.isEmpty();
-        }
-    }
-
-    private boolean keepChunk(final int chunkType, final ChunkType[] chunkTypes) {
-        // System.out.println(""keepChunk: "");
-        if (chunkTypes == null) {
-            return true;
-        }
-
-        for (final ChunkType chunkType2 : chunkTypes) {
-            if (chunkType2.value == chunkType) {
-                return true;
-            }
-        }
-        return false;
+        return ChunkReader.newInstance(byteSource)
+                .readChunks(new ChunkUniselector(true, chunkType), true)
+                .size() > 0;
     }
 
-    private List<PngChunk> readChunks(final InputStream is, final ChunkType[] chunkTypes,
-            final boolean returnAfterFirst) throws ImageReadException, IOException {
+    /**
+     * Reads all the chunks (satisfying any filters) from the input
+     * stream containing a PNG file.
+     * 
+     * Replaces the readChunks(InputStream, ChunkTypes[], boolean)
+     * method. Is clean, and readable now.
+     * 
+     * @param inputStream
+     * @param selector
+     * @param returnAfterFirst
+     * @return
+     * @throws IOException
+     * @throws ImageReadException 
+     */
+    private List<PngChunk> readChunks(final InputStream inputStream,
+            final ChunkSelector selector, final boolean returnAfterFirst)
+            throws IOException, ImageReadException {
         final List<PngChunk> result = new ArrayList<>();
-
-        while (true) {
-            final int length = read4Bytes(""Length"", is, ""Not a Valid PNG File"", getByteOrder());
-            final int chunkType = read4Bytes(""ChunkType"", is, ""Not a Valid PNG File"", getByteOrder());
-
-            if (LOGGER.isLoggable(Level.FINEST)) {
-                printCharQuad(""ChunkType"", chunkType);
-                debugNumber(""Length"", length, 4);
-            }
-            final boolean keep = keepChunk(chunkType, chunkTypes);
-
-            byte[] bytes = null;
-            if (keep) {
-                bytes = readBytes(""Chunk Data"", is, length,
-                        ""Not a Valid PNG File: Couldn't read Chunk Data."");
-            } else {
-                skipBytes(is, length, ""Not a Valid PNG File"");
-            }
-
-            if (LOGGER.isLoggable(Level.FINEST)) {
-                if (bytes != null) {
-                    debugNumber(""bytes"", bytes.length, 4);
-                }
-            }
-
-            final int crc = read4Bytes(""CRC"", is, ""Not a Valid PNG File"", getByteOrder());
-
-            if (keep) {
-                if (chunkType == ChunkType.iCCP.value) {
-                    result.add(new PngChunkIccp(length, chunkType, crc, bytes));
-                } else if (chunkType == ChunkType.tEXt.value) {
-                    result.add(new PngChunkText(length, chunkType, crc, bytes));
-                } else if (chunkType == ChunkType.zTXt.value) {
-                    result.add(new PngChunkZtxt(length, chunkType, crc, bytes));
-                } else if (chunkType == ChunkType.IHDR.value) {
-                    result.add(new PngChunkIhdr(length, chunkType, crc, bytes));
-                } else if (chunkType == ChunkType.PLTE.value) {
-                    result.add(new PngChunkPlte(length, chunkType, crc, bytes));
-                } else if (chunkType == ChunkType.pHYs.value) {
-                    result.add(new PngChunkPhys(length, chunkType, crc, bytes));
-                } else if (chunkType == ChunkType.sCAL.value) {
-                    result.add(new PngChunkScal(length, chunkType, crc, bytes));
-                } else if (chunkType == ChunkType.IDAT.value) {
-                    result.add(new PngChunkIdat(length, chunkType, crc, bytes));
-                } else if (chunkType == ChunkType.gAMA.value) {
-                    result.add(new PngChunkGama(length, chunkType, crc, bytes));
-                } else if (chunkType == ChunkType.iTXt.value) {
-                    result.add(new PngChunkItxt(length, chunkType, crc, bytes));
-                } else {
-                    result.add(new PngChunk(length, chunkType, crc, bytes));
+        final DataInputStream dataInput = new DataInputStream(inputStream);
+        
+        while(true) {
+            final ChunkLoader nextChunkLoaded = ChunkLoader.run(dataInput, selector);
+            PngChunk loadedChunk = nextChunkLoaded.loadedChunk();
+            
+            if(loadedChunk != null) {
+                { // (Shukant Pal): I essentially hate how developers
+                  // have created a dumb PngCrc object. Couldn't it just be
+                  // in one method call. Anyways, CRC checking wasn't
+                  // done before. I added this.
+                    final PngCrc png_crc = new PngCrc();
+
+                    final long crc1 = png_crc.start_partial_crc(loadedChunk.chunkType.array, 4);
+                    final long crc2 = loadedChunk.getBytes() == null ? crc1 :
+                           png_crc.continue_partial_crc(
+                                crc1, loadedChunk.getBytes(), loadedChunk.contentSize());
+
+                    int chunkCRC = (int) png_crc.finish_partial_crc(crc2);
+                    
+                    if(chunkCRC != nextChunkLoaded.chunkCrc()) {
+                        throw new ImageReadException(""Illegal CRC value found"" + 
+                                ""(ChunkType: "" + loadedChunk.chunkType +""),"" +
+                                ""(CRC VALUE: "" + nextChunkLoaded.chunkCrc() + ""),"" +
+                                ""(CRC EXPECTED "" + chunkCRC + "")"");
+                    }
                 }
-
-                if (returnAfterFirst) {
-                    return result;
+                
+                result.add(loadedChunk);
+                
+                if(returnAfterFirst) {
+                    break;
                 }
             }
-
-            if (chunkType == ChunkType.IEND.value) {
+            ","[{'comment': 'Extra spaces.', 'commenter': 'kinow'}]"
38,src/main/java/org/apache/commons/imaging/formats/png/PngImageParser.java,"@@ -100,119 +161,97 @@ public String getDefaultExtension() {
 
     // private final static int tRNS = CharsToQuad('t', 'R', 'N', 's');
 
-    public static String getChunkTypeName(final int chunkType) {
-        final StringBuilder result = new StringBuilder();
-        result.append((char) (0xff & (chunkType >> 24)));
-        result.append((char) (0xff & (chunkType >> 16)));
-        result.append((char) (0xff & (chunkType >> 8)));
-        result.append((char) (0xff & (chunkType >> 0)));
-        return result.toString();
+    public static String getChunkTypeName(final int chunkTypeCode) {
+        return new String(
+                ByteBuffer.allocate(4).putInt(chunkTypeCode).array(),
+                StandardCharsets.ISO_8859_1);
     }
 
     /**
+     * Extracts all the chunks in the PNG file (in the input stream)
+     * and returns a list of their names.
+     * 
+     * @param is
      * @return List of String-formatted chunk types, ie. ""tRNs"".
+     * @throws ImageReadException
+     * @throws IOException
      */
     public List<String> getChunkTypes(final InputStream is)
             throws ImageReadException, IOException {
         final List<PngChunk> chunks = readChunks(is, null, false);
         final List<String> chunkTypes = new ArrayList<>(chunks.size());
         for (final PngChunk chunk : chunks) {
-            chunkTypes.add(getChunkTypeName(chunk.chunkType));
+            chunkTypes.add(getChunkTypeName(chunk.chunkType.toCode()));
         }
         return chunkTypes;
     }
 
     public boolean hasChunkType(final ByteSource byteSource, final ChunkType chunkType)
             throws ImageReadException, IOException {
-        try (InputStream is = byteSource.getInputStream()) {
-            readSignature(is);
-            final List<PngChunk> chunks = readChunks(is, new ChunkType[] { chunkType }, true);
-            return !chunks.isEmpty();
-        }
-    }
-
-    private boolean keepChunk(final int chunkType, final ChunkType[] chunkTypes) {
-        // System.out.println(""keepChunk: "");
-        if (chunkTypes == null) {
-            return true;
-        }
-
-        for (final ChunkType chunkType2 : chunkTypes) {
-            if (chunkType2.value == chunkType) {
-                return true;
-            }
-        }
-        return false;
+        return ChunkReader.newInstance(byteSource)
+                .readChunks(new ChunkUniselector(true, chunkType), true)
+                .size() > 0;
     }
 
-    private List<PngChunk> readChunks(final InputStream is, final ChunkType[] chunkTypes,
-            final boolean returnAfterFirst) throws ImageReadException, IOException {
+    /**
+     * Reads all the chunks (satisfying any filters) from the input
+     * stream containing a PNG file.
+     * 
+     * Replaces the readChunks(InputStream, ChunkTypes[], boolean)
+     * method. Is clean, and readable now.
+     * 
+     * @param inputStream
+     * @param selector
+     * @param returnAfterFirst
+     * @return
+     * @throws IOException
+     * @throws ImageReadException 
+     */
+    private List<PngChunk> readChunks(final InputStream inputStream,
+            final ChunkSelector selector, final boolean returnAfterFirst)
+            throws IOException, ImageReadException {
         final List<PngChunk> result = new ArrayList<>();
-
-        while (true) {
-            final int length = read4Bytes(""Length"", is, ""Not a Valid PNG File"", getByteOrder());
-            final int chunkType = read4Bytes(""ChunkType"", is, ""Not a Valid PNG File"", getByteOrder());
-
-            if (LOGGER.isLoggable(Level.FINEST)) {
-                printCharQuad(""ChunkType"", chunkType);
-                debugNumber(""Length"", length, 4);
-            }
-            final boolean keep = keepChunk(chunkType, chunkTypes);
-
-            byte[] bytes = null;
-            if (keep) {
-                bytes = readBytes(""Chunk Data"", is, length,
-                        ""Not a Valid PNG File: Couldn't read Chunk Data."");
-            } else {
-                skipBytes(is, length, ""Not a Valid PNG File"");
-            }
-
-            if (LOGGER.isLoggable(Level.FINEST)) {
-                if (bytes != null) {
-                    debugNumber(""bytes"", bytes.length, 4);
-                }
-            }
-
-            final int crc = read4Bytes(""CRC"", is, ""Not a Valid PNG File"", getByteOrder());
-
-            if (keep) {
-                if (chunkType == ChunkType.iCCP.value) {
-                    result.add(new PngChunkIccp(length, chunkType, crc, bytes));
-                } else if (chunkType == ChunkType.tEXt.value) {
-                    result.add(new PngChunkText(length, chunkType, crc, bytes));
-                } else if (chunkType == ChunkType.zTXt.value) {
-                    result.add(new PngChunkZtxt(length, chunkType, crc, bytes));
-                } else if (chunkType == ChunkType.IHDR.value) {
-                    result.add(new PngChunkIhdr(length, chunkType, crc, bytes));
-                } else if (chunkType == ChunkType.PLTE.value) {
-                    result.add(new PngChunkPlte(length, chunkType, crc, bytes));
-                } else if (chunkType == ChunkType.pHYs.value) {
-                    result.add(new PngChunkPhys(length, chunkType, crc, bytes));
-                } else if (chunkType == ChunkType.sCAL.value) {
-                    result.add(new PngChunkScal(length, chunkType, crc, bytes));
-                } else if (chunkType == ChunkType.IDAT.value) {
-                    result.add(new PngChunkIdat(length, chunkType, crc, bytes));
-                } else if (chunkType == ChunkType.gAMA.value) {
-                    result.add(new PngChunkGama(length, chunkType, crc, bytes));
-                } else if (chunkType == ChunkType.iTXt.value) {
-                    result.add(new PngChunkItxt(length, chunkType, crc, bytes));
-                } else {
-                    result.add(new PngChunk(length, chunkType, crc, bytes));
+        final DataInputStream dataInput = new DataInputStream(inputStream);
+        
+        while(true) {
+            final ChunkLoader nextChunkLoaded = ChunkLoader.run(dataInput, selector);
+            PngChunk loadedChunk = nextChunkLoaded.loadedChunk();
+            
+            if(loadedChunk != null) {
+                { // (Shukant Pal): I essentially hate how developers
+                  // have created a dumb PngCrc object. Couldn't it just be
+                  // in one method call. Anyways, CRC checking wasn't
+                  // done before. I added this.
+                    final PngCrc png_crc = new PngCrc();
+
+                    final long crc1 = png_crc.start_partial_crc(loadedChunk.chunkType.array, 4);
+                    final long crc2 = loadedChunk.getBytes() == null ? crc1 :
+                           png_crc.continue_partial_crc(
+                                crc1, loadedChunk.getBytes(), loadedChunk.contentSize());
+
+                    int chunkCRC = (int) png_crc.finish_partial_crc(crc2);
+                    
+                    if(chunkCRC != nextChunkLoaded.chunkCrc()) {
+                        throw new ImageReadException(""Illegal CRC value found"" + 
+                                ""(ChunkType: "" + loadedChunk.chunkType +""),"" +
+                                ""(CRC VALUE: "" + nextChunkLoaded.chunkCrc() + ""),"" +
+                                ""(CRC EXPECTED "" + chunkCRC + "")"");
+                    }
                 }
-
-                if (returnAfterFirst) {
-                    return result;
+                
+                result.add(loadedChunk);
+                
+                if(returnAfterFirst) {
+                    break;
                 }
             }
-
-            if (chunkType == ChunkType.IEND.value) {
+            
+            if(nextChunkLoaded.isLast()) {
                 break;
-            }
-
+            } // loadedChunk may be null still
         }
-
+        ","[{'comment': 'Extra spaces. Running `mvn` might catch a few errors in this pull request.', 'commenter': 'kinow'}]"
38,src/main/java/org/apache/commons/imaging/formats/png/PngImageParser.java,"@@ -222,58 +261,39 @@ public void readSignature(final InputStream is) throws ImageReadException,
 
     }
 
-    private List<PngChunk> readChunks(final ByteSource byteSource, final ChunkType[] chunkTypes,
-            final boolean returnAfterFirst) throws ImageReadException, IOException {
-        try (InputStream is = byteSource.getInputStream()) {
-            readSignature(is);
-            return readChunks(is, chunkTypes, returnAfterFirst);
-        }
-    }
-
     @Override
     public byte[] getICCProfileBytes(final ByteSource byteSource, final Map<String, Object> params)
             throws ImageReadException, IOException {
-        final List<PngChunk> chunks = readChunks(byteSource, new ChunkType[] { ChunkType.iCCP },
-                true);
-
-        if ((chunks == null) || (chunks.isEmpty())) {
-            // throw new ImageReadException(""Png: No chunks"");
+        final PngChunkIccp pngChunkiCCP = (PngChunkIccp) ICCP_SEL.filterOnlyOne(
+                ChunkReader.newInstance(byteSource).readChunks(ICCP_SEL, true));
+        ","[{'comment': 'Spaces.', 'commenter': 'kinow'}]"
38,src/main/java/org/apache/commons/imaging/formats/png/PngImageParser.java,"@@ -222,58 +261,39 @@ public void readSignature(final InputStream is) throws ImageReadException,
 
     }
 
-    private List<PngChunk> readChunks(final ByteSource byteSource, final ChunkType[] chunkTypes,
-            final boolean returnAfterFirst) throws ImageReadException, IOException {
-        try (InputStream is = byteSource.getInputStream()) {
-            readSignature(is);
-            return readChunks(is, chunkTypes, returnAfterFirst);
-        }
-    }
-
     @Override
     public byte[] getICCProfileBytes(final ByteSource byteSource, final Map<String, Object> params)
             throws ImageReadException, IOException {
-        final List<PngChunk> chunks = readChunks(byteSource, new ChunkType[] { ChunkType.iCCP },
-                true);
-
-        if ((chunks == null) || (chunks.isEmpty())) {
-            // throw new ImageReadException(""Png: No chunks"");
+        final PngChunkIccp pngChunkiCCP = (PngChunkIccp) ICCP_SEL.filterOnlyOne(
+                ChunkReader.newInstance(byteSource).readChunks(ICCP_SEL, true));
+        
+        if(pngChunkiCCP == null) {
+            System.err.println(""Apache Commons Imaging: PNG file doesn't contain ICC profile"");","[{'comment': 'We are now using a logging framework instead of `System.err`, and no need to include the project name. The project name changed from Sanselan to Imaging recently-ish. That could happen again, and there is no need to include it really.', 'commenter': 'kinow'}]"
38,src/main/java/org/apache/commons/imaging/formats/png/PngImageParser.java,"@@ -622,7 +577,9 @@ public BufferedImage getBufferedImage(final ByteSource byteSource, Map<String, O
 
             ScanExpediter scanExpediter;
 
-            switch (pngChunkIHDR.interlaceMethod) {
+            // Note that here we assume the only filter method. Hence, the
+            // filtering and interlacing are combined (correct??)","[{'comment': 'For this note a `TODO` is probably better, as the IDE/static analyzers may tell other developers about it. And remind them to revisit this every now and then.', 'commenter': 'kinow'}]"
38,src/main/java/org/apache/commons/imaging/formats/png/PngImageParser.java,"@@ -732,5 +692,5 @@ public String getXmpXml(final ByteSource byteSource, final Map<String, Object> p
         final PngChunkItxt chunk = xmpChunks.get(0);
         return chunk.getText();
     }
-
+    ","[{'comment': 'Extra space.', 'commenter': 'kinow'}]"
38,src/main/java/org/apache/commons/imaging/formats/png/PngWriter.java,"@@ -29,12 +31,126 @@
 import org.apache.commons.imaging.ImageWriteException;
 import org.apache.commons.imaging.ImagingConstants;
 import org.apache.commons.imaging.PixelDensity;
+import org.apache.commons.imaging.formats.png.chunks.PngChunk;
+import org.apache.commons.imaging.formats.png.chunks.PngChunkIhdr;
+import org.apache.commons.imaging.formats.png.scanline.filters.AdaptiveFilter;
+import org.apache.commons.imaging.formats.png.scanline.filters.AdaptiveFilter.FilterType;
 import org.apache.commons.imaging.internal.Debug;
 import org.apache.commons.imaging.palette.Palette;
 import org.apache.commons.imaging.palette.PaletteFactory;
 import org.apache.commons.imaging.palette.SimplePalette;
 
+/**
+ * Directly writes {@code BufferedImage} objects into an output stream
+ * in the PNG format.
+ * 
+ * PngWriter doesn't use the middle step of converting the BufferedImage
+ * into a list of PNG chunks.
+ * TODO: Support above for manual manipulation
+ * 
+ * @author Shukant Pal
+ */
 class PngWriter {
+    
+    /**
+     * Transforms raw image pixel data into the required PNG IDAT
+     * (compressed) form.
+     * 
+     * {@code DataTransformer} can be used to split compressed pixel
+     * data into different chunks.
+     */
+    static final class ChunkedCompressor {
+        
+        /**
+         * Transformation is done on this pixel data.
+         * 
+         * Can be set using {@code setInput} or passed during object
+         * construction.
+         */
+        private byte[] pixelInput;
+        
+        /**
+         * Keeps the amount of data that has been transformed already.
+         */
+        private int transformedTill;
+        
+        private ByteArrayOutputStream outputStream;
+        
+        private DeflaterOutputStream deflaterOutputStream;
+        
+        ChunkedCompressor() {
+            this.pixelInput = null;
+        }
+        
+        ChunkedCompressor(byte[] pixelInput) {
+            setInput(pixelInput);
+        }
+        
+        void setInput(byte[] pixelInput) {
+            this.pixelInput = pixelInput;
+            this.transformedTill = 0;
+            this.outputStream = new ByteArrayOutputStream();
+            this.deflaterOutputStream = new DeflaterOutputStream(outputStream);
+        }
+        
+        /**
+         * Returns the index till which input has been transformed
+         * into output.
+         * 
+         * @return size of transformed input minus 1 
+         */
+        int transformedAmount() {
+            return transformedTill;
+        }
+        
+        /**
+         * Transforms (at maximum) {@code transformLength} bytes of
+         * input into the required output.
+         * 
+         * See {@code writePixelData} for example usage of this
+         * method.
+         * 
+         * @param transformLength
+         * @return 
+         */
+        byte[] transform(int transformLength) throws IOException, ImageWriteException {
+            if(pixelInput == null) {
+                throw new ImageWriteException(""Couldn't read pixelInput as it is ""
+                        + ""null (it wasn't initialized properly, source bug)"");","[{'comment': 'I think this exception can be re-worded to be more clear to the end user what went wrong. No need to indicate it is an issue in the caller, as that is implicit.', 'commenter': 'kinow'}]"
38,src/main/java/org/apache/commons/imaging/formats/png/PngWriter.java,"@@ -29,12 +31,126 @@
 import org.apache.commons.imaging.ImageWriteException;
 import org.apache.commons.imaging.ImagingConstants;
 import org.apache.commons.imaging.PixelDensity;
+import org.apache.commons.imaging.formats.png.chunks.PngChunk;
+import org.apache.commons.imaging.formats.png.chunks.PngChunkIhdr;
+import org.apache.commons.imaging.formats.png.scanline.filters.AdaptiveFilter;
+import org.apache.commons.imaging.formats.png.scanline.filters.AdaptiveFilter.FilterType;
 import org.apache.commons.imaging.internal.Debug;
 import org.apache.commons.imaging.palette.Palette;
 import org.apache.commons.imaging.palette.PaletteFactory;
 import org.apache.commons.imaging.palette.SimplePalette;
 
+/**
+ * Directly writes {@code BufferedImage} objects into an output stream
+ * in the PNG format.
+ * 
+ * PngWriter doesn't use the middle step of converting the BufferedImage
+ * into a list of PNG chunks.
+ * TODO: Support above for manual manipulation
+ * 
+ * @author Shukant Pal
+ */
 class PngWriter {
+    
+    /**
+     * Transforms raw image pixel data into the required PNG IDAT
+     * (compressed) form.
+     * 
+     * {@code DataTransformer} can be used to split compressed pixel
+     * data into different chunks.
+     */
+    static final class ChunkedCompressor {
+        
+        /**
+         * Transformation is done on this pixel data.
+         * 
+         * Can be set using {@code setInput} or passed during object
+         * construction.
+         */
+        private byte[] pixelInput;
+        
+        /**
+         * Keeps the amount of data that has been transformed already.
+         */
+        private int transformedTill;
+        
+        private ByteArrayOutputStream outputStream;
+        
+        private DeflaterOutputStream deflaterOutputStream;
+        
+        ChunkedCompressor() {
+            this.pixelInput = null;
+        }
+        
+        ChunkedCompressor(byte[] pixelInput) {
+            setInput(pixelInput);
+        }
+        
+        void setInput(byte[] pixelInput) {
+            this.pixelInput = pixelInput;
+            this.transformedTill = 0;
+            this.outputStream = new ByteArrayOutputStream();
+            this.deflaterOutputStream = new DeflaterOutputStream(outputStream);
+        }
+        
+        /**
+         * Returns the index till which input has been transformed
+         * into output.
+         * 
+         * @return size of transformed input minus 1 
+         */
+        int transformedAmount() {
+            return transformedTill;
+        }
+        
+        /**
+         * Transforms (at maximum) {@code transformLength} bytes of
+         * input into the required output.
+         * 
+         * See {@code writePixelData} for example usage of this
+         * method.
+         * 
+         * @param transformLength
+         * @return 
+         */
+        byte[] transform(int transformLength) throws IOException, ImageWriteException {
+            if(pixelInput == null) {
+                throw new ImageWriteException(""Couldn't read pixelInput as it is ""
+                        + ""null (it wasn't initialized properly, source bug)"");
+            }
+            
+            final int end = Math.min(pixelInput.length,
+                    transformedTill + transformLength);
+            final int length = end - transformedTill;
+
+            deflaterOutputStream.write(pixelInput, transformedTill, length);
+            deflaterOutputStream.flush();
+            outputStream.flush();
+
+            final byte[] compressed = outputStream.toByteArray();
+            outputStream.reset();
+            
+            transformedTill += transformLength;
+            return compressed;
+        }
+        
+        /**
+         * Finishes the transformation and closes the deflation
+         * stream.
+         * 
+         * @return
+         * @throws IOException 
+         */
+        byte[] finish() throws IOException {","[{'comment': 'I wonder if there is not a new risk introduced here, of streams not being closed. Have not checked the pull request locally to have a better look yet, but might be worth documenting it in the javadocs if possible.', 'commenter': 'kinow'}]"
38,src/main/java/org/apache/commons/imaging/formats/png/PngWriter.java,"@@ -74,46 +207,47 @@ private void writeChunk(final OutputStream os, final ChunkType chunkType,
                 crc1, data, data.length);
         final int crc = (int) png_crc.finish_partial_crc(crc2);
 
-        writeInt(os, crc);
+        writeInt(outputStream, crc);
     }
 
-    private static class ImageHeader {
-        public final int width;
-        public final int height;
-        public final byte bitDepth;
-        public final PngColorType pngColorType;
-        public final byte compressionMethod;
-        public final byte filterMethod;
-        public final InterlaceMethod interlaceMethod;
-
-        ImageHeader(final int width, final int height, final byte bitDepth,
-                final PngColorType pngColorType, final byte compressionMethod, final byte filterMethod,
-                final InterlaceMethod interlaceMethod) {
-            this.width = width;
-            this.height = height;
-            this.bitDepth = bitDepth;
-            this.pngColorType = pngColorType;
-            this.compressionMethod = compressionMethod;
-            this.filterMethod = filterMethod;
-            this.interlaceMethod = interlaceMethod;
+    /**
+     * Puts the chunk contents (including length, type and CRC) into
+     * the output stream provided.
+     *
+     * Also calculates the CRC if required. (used by writeHeader)
+     *
+     * @param outputStream stream into which chunk is to be written
+     * @param chunk chunk to write
+     * @throws IOException
+     */
+    private void writeChunk(final DataOutputStream outputStream,
+            final PngChunk chunk) throws IOException {
+        outputStream.writeInt(chunk.contentSize());
+        outputStream.writeInt(chunk.chunkType.toCode());
+
+        if (chunk.getBytes() != null) {
+            outputStream.write(chunk.getBytes());
         }
 
-    }
+        int chunkCRC;
 
-    private void writeChunkIHDR(final OutputStream os, final ImageHeader value) throws IOException {
-        final ByteArrayOutputStream baos = new ByteArrayOutputStream();
-        writeInt(baos, value.width);
-        writeInt(baos, value.height);
-        baos.write(0xff & value.bitDepth);
-        baos.write(0xff & value.pngColorType.getValue());
-        baos.write(0xff & value.compressionMethod);
-        baos.write(0xff & value.filterMethod);
-        baos.write(0xff & value.interlaceMethod.ordinal());
-
-        writeChunk(os, ChunkType.IHDR, baos.toByteArray());
+        if (chunk.wasChanged(true)) {","[{'comment': 'This looks weird. I think either `if (chunk.changed)`, or `if (chunk.hasChanged())` would be expected instead?', 'commenter': 'kinow'}]"
38,src/main/java/org/apache/commons/imaging/formats/png/PngWriter.java,"@@ -74,46 +207,47 @@ private void writeChunk(final OutputStream os, final ChunkType chunkType,
                 crc1, data, data.length);
         final int crc = (int) png_crc.finish_partial_crc(crc2);
 
-        writeInt(os, crc);
+        writeInt(outputStream, crc);
     }
 
-    private static class ImageHeader {
-        public final int width;
-        public final int height;
-        public final byte bitDepth;
-        public final PngColorType pngColorType;
-        public final byte compressionMethod;
-        public final byte filterMethod;
-        public final InterlaceMethod interlaceMethod;
-
-        ImageHeader(final int width, final int height, final byte bitDepth,
-                final PngColorType pngColorType, final byte compressionMethod, final byte filterMethod,
-                final InterlaceMethod interlaceMethod) {
-            this.width = width;
-            this.height = height;
-            this.bitDepth = bitDepth;
-            this.pngColorType = pngColorType;
-            this.compressionMethod = compressionMethod;
-            this.filterMethod = filterMethod;
-            this.interlaceMethod = interlaceMethod;
+    /**
+     * Puts the chunk contents (including length, type and CRC) into
+     * the output stream provided.
+     *
+     * Also calculates the CRC if required. (used by writeHeader)
+     *
+     * @param outputStream stream into which chunk is to be written
+     * @param chunk chunk to write
+     * @throws IOException
+     */
+    private void writeChunk(final DataOutputStream outputStream,
+            final PngChunk chunk) throws IOException {
+        outputStream.writeInt(chunk.contentSize());
+        outputStream.writeInt(chunk.chunkType.toCode());
+
+        if (chunk.getBytes() != null) {
+            outputStream.write(chunk.getBytes());
         }
 
-    }
+        int chunkCRC;
 
-    private void writeChunkIHDR(final OutputStream os, final ImageHeader value) throws IOException {
-        final ByteArrayOutputStream baos = new ByteArrayOutputStream();
-        writeInt(baos, value.width);
-        writeInt(baos, value.height);
-        baos.write(0xff & value.bitDepth);
-        baos.write(0xff & value.pngColorType.getValue());
-        baos.write(0xff & value.compressionMethod);
-        baos.write(0xff & value.filterMethod);
-        baos.write(0xff & value.interlaceMethod.ordinal());
-
-        writeChunk(os, ChunkType.IHDR, baos.toByteArray());
+        if (chunk.wasChanged(true)) {
+            final PngCrc png_crc = new PngCrc();
+
+            final long crc1 = png_crc.start_partial_crc(chunk.chunkType.array, 4);
+            final long crc2 = chunk.getBytes() == null ? crc1 : png_crc.continue_partial_crc(
+                    crc1, chunk.getBytes(), chunk.contentSize());
+            chunkCRC = (int) png_crc.finish_partial_crc(crc2);
+        } else {
+            chunkCRC = chunk.crc;
+        }
+
+        outputStream.writeInt(chunkCRC);
     }
 
-    private void writeChunkiTXt(final OutputStream os, final PngText.Itxt text)
+    // Hooray, ImageHeader and writeChunkIhdr eliminated... (remove this later)","[{'comment': 'Note needed? Or was it for development/debug?', 'commenter': 'kinow'}]"
38,src/main/java/org/apache/commons/imaging/formats/png/chunks/ChunkLoader.java,"@@ -0,0 +1,322 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.imaging.formats.png.chunks;
+
+import java.io.DataInputStream;
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import org.apache.commons.imaging.ImageReadException;
+import org.apache.commons.imaging.common.BinaryFunctions;
+import org.apache.commons.imaging.formats.png.ChunkType;
+
+/**
+ * {@code ChunkLoader} objects provide common methods to extract
+ * a chunk from the input stream.
+ *
+ * Instead of storing the CRC in the PngChunk itself, these objects
+ * will separately get the CRC. Each png chunk class should register
+ * a ChunkLoader.
+ *
+ * <h2>Usage</h2>
+ * 
+ * The ChunkLoader object only contains the results of loading a
+ * chunk from a PNG input stream. The real building is done by the
+ * {@code ChunkLoader.run} method. It returns a ChunkLoader object
+ * that has the loadedChunk & its storedCrc. For an example usage,
+ * see {@link PngImageParser.readAllChunks}.
+ * 
+ * @author Shukant Pal
+ */
+public final class ChunkLoader {
+
+    private DataInputStream chunkInput;
+    private ByteBuffer contents;
+    private int storedCrc;
+    private boolean isLast = false;
+
+    private PngChunk loadedChunk;
+
+    public ChunkLoader() {
+        this.chunkInput = null;
+    }
+
+    protected ChunkLoader(DataInputStream chunkInput) {
+        setInput(chunkInput);
+    }
+
+    public DataInputStream getInput() {
+        return this.chunkInput;
+    }
+    
+    public void setInput(DataInputStream chunkInput) {
+        this.chunkInput = chunkInput;
+    }
+    
+    public boolean isLast() {
+        return isLast;
+    }
+    
+    /**
+     * Reads the chunk contents and then builds a {@code Chunk}
+     * object (specific class inheriting from Chunk) from that.
+     *
+     * @param length
+     * @param chunkType
+     * @return
+     * @throws ImageReadException
+     * @throws IOException
+     */
+    public ChunkLoader build(int length, ChunkType chunkType) throws ImageReadException, IOException {
+        if (chunkInput == null) {
+            throw new ImageReadException(""Chunk input not initialized..."");
+        }
+        
+        final byte[] contentsRaw = new byte[length];
+        int realLength = chunkInput.read(contentsRaw);
+        
+        if (realLength != length) {
+            throw new ImageReadException(""The PNG file contains an illegal "" +
+                    ""chunk length, that doesn't exist"");
+        }
+        
+        this.contents = ByteBuffer.wrap(contentsRaw);
+        this.storedCrc = chunkInput.readInt();
+        
+        if (chunkType != null) switch (chunkType) {
+            case IHDR:
+                loadedChunk = new PngChunkIhdr(contents);
+                break;
+            case PLTE:
+                loadedChunk = new PngChunkPlte(contents);
+                break;
+            case IDAT:
+                loadedChunk = new PngChunkIdat(contents);
+                break;
+            case IEND:
+                loadedChunk = new PngChunk(chunkType, contents);
+                isLast = true;
+                break;
+            case gAMA:
+                loadedChunk = new PngChunkGama(contents);
+                break;
+            case iCCP:
+                loadedChunk = new PngChunkIccp(contents);
+                break;
+            case iTXt:
+                loadedChunk = new PngChunkItxt(contents);
+                break;
+            case pHYs:
+                loadedChunk = new PngChunkPhys(contents);
+                break;
+            case sCAL:
+                loadedChunk = new PngChunkScal(contents);
+                break;
+            case tEXt:
+                loadedChunk = new PngChunkText(contents);
+                break;
+            case zTXt:
+                loadedChunk = new PngChunkZtxt(contents);
+                break;
+            default:
+                loadedChunk = new PngChunk(chunkType, contents);
+                break;
+        } else {
+            loadedChunk = null;
+        }
+        
+        return this;
+    }
+    
+    public PngChunk loadedChunk() {
+        return loadedChunk;
+    }
+
+    public int chunkCrc() {
+        return storedCrc;
+    }
+
+    /**
+     * Creates {@code ChunkLoader} object for the next chunk in the input
+     * stream.
+     * 
+     * If the {@code selector} rejects the chunk-type, then the required
+     * amount of bytes are skipped in the input stream. The next chunk can
+     * be read directly.
+     * 
+     * @param chunkInput
+     * @param selector
+     * @return
+     * @throws ImageReadException
+     * @throws IOException 
+     */
+    public static ChunkLoader run(DataInputStream chunkInput, ChunkSelector selector)
+            throws ImageReadException, IOException {
+        final int length = chunkInput.readInt();
+        final ChunkType chunkType = ChunkType.forCode(chunkInput.readInt());
+        
+        // IEND chunk is compulsory to allow reader to get
+        // EOF
+        if ((selector == null || selector.whetherToKeep(chunkType))) {
+            return new ChunkLoader(chunkInput).build(length, chunkType);
+        } else if (chunkType == ChunkType.IEND) {
+           // must tell
+           final ChunkLoader loader = new ChunkLoader();
+           loader.isLast = true;
+           return loader;
+        } else {
+            BinaryFunctions.skipBytes(chunkInput, length + 4,
+                    ""IOException error: BinaryFunctions.skipBytes(), PNG Component"");
+            return new ChunkLoader();// not null
+        }
+    }
+    
+    /**
+     * ChunkSelector object filter out chunks that are not to be
+     * loaded by {@code ChunkLoader.run()} to reduce overall
+     * overhead.
+     * 
+     * <h2>NOTICE</h2>
+     * 
+     * (Replaces PngImageParser.keepChunk}. ChunkSelector also
+     * supports two mode - whiteList and blackList. In whiteList,
+     * the chunk types are the ones to be loaded, and in blackList
+     * all chunks are loaded except the given ones.
+     * 
+     * <h2>USAGE</h2>
+     * There are two ChunkSelector implementations - ChunkListSelector
+     * and ChunkUniselector.
+     */
+    public static abstract class ChunkSelector {
+        
+        protected final boolean whiteList;
+
+        /**
+         * Constructs a new ChunkSelector.
+         * 
+         * @param whiteList - whether chunk types given are to be
+         *      accepted or refused
+         */
+        protected ChunkSelector(boolean whiteList) {
+            this.whiteList = whiteList;
+        }
+        
+        public boolean isWhiteList() {
+            return whiteList;
+        }
+        
+        public boolean isBlackList() {
+            return !whiteList;
+        }
+        
+        /**
+         * Returns whether the given chunk is to be selected for
+         * building.
+         * 
+         * @param chunkType
+         * @return 
+         */
+        public abstract boolean whetherToKeep(ChunkType chunkType);
+        
+        /**
+         * Filters all the chunks in src and the result contains
+         * only chunks which satisfy whetherToKeep(chunk.chunkType)
+         * 
+         * @param src
+         * @return 
+         */
+        public List<PngChunk> filter(List<PngChunk> src) {
+            List<PngChunk> dst = new ArrayList<>();
+            
+            for(PngChunk chunk : src) {
+                if(whetherToKeep(chunk.chunkType))
+                    dst.add(chunk);
+            }
+            
+            return dst;
+        }
+        
+        public PngChunk filterOnlyOne(List<PngChunk> src) throws ImageReadException {
+            List<PngChunk> filtered = filter(src);
+            
+            if(filtered.size() > 1) {
+                throw new ImageReadException(""More than one present in filtered: "" +
+                        ""type is "" + filtered.get(0).chunkType);
+            } else if(filtered.size() == 0) {
+                return null;
+            }
+            
+            return filtered.get(0);
+        }
+        
+    }
+    
+    public static class ChunkListSelector extends ChunkSelector {
+
+        private final ChunkType[] list;
+        
+        public ChunkListSelector(boolean whiteList, ChunkType[] list) {
+            super(whiteList);
+            this.list = list;
+        }
+        
+        public ChunkType[] getList() {
+            return Arrays.copyOf(list, list.length);
+        }
+        
+        @Override
+        public boolean whetherToKeep(ChunkType chunkType) {","[{'comment': 'Method name looks different. I think it would normally appear in an API as `keep()`, or `shouldKeep()`, etc.', 'commenter': 'kinow'}]"
38,src/main/java/org/apache/commons/imaging/formats/png/chunks/PngChunkIhdr.java,"@@ -16,43 +16,177 @@
  */
 package org.apache.commons.imaging.formats.png.chunks;
 
-import static org.apache.commons.imaging.common.BinaryFunctions.read4Bytes;
-import static org.apache.commons.imaging.common.BinaryFunctions.readByte;
-
 import java.io.ByteArrayInputStream;
 import java.io.IOException;
+import java.nio.ByteBuffer;
 
 import org.apache.commons.imaging.ImageReadException;
+import org.apache.commons.imaging.formats.png.ChunkType;
 import org.apache.commons.imaging.formats.png.InterlaceMethod;
 import org.apache.commons.imaging.formats.png.PngColorType;
 
-public class PngChunkIhdr extends PngChunk {
-    public final int width;
-    public final int height;
-    public final int bitDepth;
-    public final PngColorType pngColorType;
-    public final int compressionMethod;
-    public final int filterMethod;
-    public final InterlaceMethod interlaceMethod;
+// BIG FAT NOTE: PngChunkIhdr has now become read-write (mutable) to","[{'comment': 'I think this could be re-worded a bit?', 'commenter': 'kinow'}]"
38,src/main/java/org/apache/commons/imaging/formats/png/chunks/PngChunkIhdr.java,"@@ -16,43 +16,177 @@
  */
 package org.apache.commons.imaging.formats.png.chunks;
 
-import static org.apache.commons.imaging.common.BinaryFunctions.read4Bytes;
-import static org.apache.commons.imaging.common.BinaryFunctions.readByte;
-
 import java.io.ByteArrayInputStream;
 import java.io.IOException;
+import java.nio.ByteBuffer;
 
 import org.apache.commons.imaging.ImageReadException;
+import org.apache.commons.imaging.formats.png.ChunkType;
 import org.apache.commons.imaging.formats.png.InterlaceMethod;
 import org.apache.commons.imaging.formats.png.PngColorType;
 
-public class PngChunkIhdr extends PngChunk {
-    public final int width;
-    public final int height;
-    public final int bitDepth;
-    public final PngColorType pngColorType;
-    public final int compressionMethod;
-    public final int filterMethod;
-    public final InterlaceMethod interlaceMethod;
+// BIG FAT NOTE: PngChunkIhdr has now become read-write (mutable) to
+// remove its duplicate PngWriter.ImageHeader.
 
-    public PngChunkIhdr(final int length, final int chunkType, final int crc, final byte[] bytes) throws ImageReadException, IOException {
+/**
+ * {@code PngChunkIhdr} are mutable PNG chunk objects that holds image
+ * header information.
+ * 
+ * Note that PngChunkIhdr was made mutable to allow PngWriter.ImageHeader
+ * to be removed. Other chunks are (supposed to be) immutable.
+ * 
+ * @author Shukant Pal","[{'comment': 'Author tags should be removed.', 'commenter': 'kinow'}]"
38,src/main/java/org/apache/commons/imaging/formats/png/chunks/PngChunkIhdr.java,"@@ -16,43 +16,177 @@
  */
 package org.apache.commons.imaging.formats.png.chunks;
 
-import static org.apache.commons.imaging.common.BinaryFunctions.read4Bytes;
-import static org.apache.commons.imaging.common.BinaryFunctions.readByte;
-
 import java.io.ByteArrayInputStream;
 import java.io.IOException;
+import java.nio.ByteBuffer;
 
 import org.apache.commons.imaging.ImageReadException;
+import org.apache.commons.imaging.formats.png.ChunkType;
 import org.apache.commons.imaging.formats.png.InterlaceMethod;
 import org.apache.commons.imaging.formats.png.PngColorType;
 
-public class PngChunkIhdr extends PngChunk {
-    public final int width;
-    public final int height;
-    public final int bitDepth;
-    public final PngColorType pngColorType;
-    public final int compressionMethod;
-    public final int filterMethod;
-    public final InterlaceMethod interlaceMethod;
+// BIG FAT NOTE: PngChunkIhdr has now become read-write (mutable) to
+// remove its duplicate PngWriter.ImageHeader.
 
-    public PngChunkIhdr(final int length, final int chunkType, final int crc, final byte[] bytes) throws ImageReadException, IOException {
+/**
+ * {@code PngChunkIhdr} are mutable PNG chunk objects that holds image
+ * header information.
+ * 
+ * Note that PngChunkIhdr was made mutable to allow PngWriter.ImageHeader
+ * to be removed. Other chunks are (supposed to be) immutable.","[{'comment': 'Running `mvn javadoc:javadoc` should catch a few errors in this PR I think. Better to split paragraphs with `<p>` tags, properly formatted.', 'commenter': 'kinow'}]"
38,src/main/java/org/apache/commons/imaging/formats/png/chunks/PngTextChunk.java,"@@ -16,16 +16,38 @@
  */
 package org.apache.commons.imaging.formats.png.chunks;
 
+import java.nio.ByteBuffer;
+import org.apache.commons.imaging.formats.png.ChunkType;
 import org.apache.commons.imaging.formats.png.PngText;
 
+/**
+ * PngTextChunk is an abstraction to iTXT, tEXt, and zTXt chunks,
+ * all of which have a keyword and text value.
+ * 
+ * @author Shukant Pal","[{'comment': 'Author tags should be removed.', 'commenter': 'kinow'}]"
38,src/main/java/org/apache/commons/imaging/formats/png/parser/PixelParser.java,"@@ -14,43 +14,102 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package org.apache.commons.imaging.formats.png;
+package org.apache.commons.imaging.formats.png.parser;
 
 import org.apache.commons.imaging.ImageReadException;
 
-class BitParser {
-    private final byte[] bytes;
+// BitParser renamed to PixelParser
+
+/**
+ * {@code PixelParser} object can parse PNG image data and extract
+ * individual pixel samples.
+ * 
+ * A pixel parser works on a scan-line and can be used to get each
+ * pixel sample in it, based on the bits-per-pixel and bit-depth
+ * fields.
+ * 
+ * @author Shukant Pal","[{'comment': 'Author tags should be removed.', 'commenter': 'kinow'}]"
38,src/main/java/org/apache/commons/imaging/formats/png/scanline/filters/AdaptiveFilter.java,"@@ -0,0 +1,248 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.imaging.formats.png.scanline.filters;
+
+// Encapsulate filtering in this class, instead of embedding the process
+
+import java.util.Arrays;
+
+
+// in ScanExpediter
+
+/**
+ * Filters (and also un-filters) pixel data in each scan-line using
+ * filter method 0.
+ * 
+ * Each scan-line is fed into an {@code AdaptiveFilter} object, which
+ * in turn manipulates the bytes and transforms them from filtered and
+ * un-filtered forms.
+ * 
+ * @author Shukant Pal","[{'comment': 'Author tags should be removed.', 'commenter': 'kinow'}]"
38,src/main/java/org/apache/commons/imaging/formats/png/scanline/filters/AdaptiveFilter.java,"@@ -0,0 +1,248 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.imaging.formats.png.scanline.filters;
+
+// Encapsulate filtering in this class, instead of embedding the process
+
+import java.util.Arrays;
+
+
+// in ScanExpediter","[{'comment': ""What's the meaning of this note?"", 'commenter': 'kinow'}]"
38,src/main/java/org/apache/commons/imaging/formats/png/scanline/filters/AdaptiveFilter.java,"@@ -0,0 +1,248 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.imaging.formats.png.scanline.filters;
+
+// Encapsulate filtering in this class, instead of embedding the process","[{'comment': ""Shouldn't this comment go somewhere else? I think this can be removed."", 'commenter': 'kinow'}]"
43,src/main/java/org/apache/commons/imaging/common/Deflate.java,"@@ -0,0 +1,40 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.imaging.common;
+
+import java.util.zip.DataFormatException;
+import java.util.zip.Inflater;
+
+import org.apache.commons.imaging.ImageReadException;
+
+public class Deflate {
+
+  public static byte[] decompress(final byte[] bytes, final int expected)
+    throws ImageReadException {
+    try {
+      final Inflater inflater = new Inflater();
+      inflater.setInput(bytes);
+      final byte[] result = new byte[expected];
+      inflater.inflate(result);
+      return result;
+    } catch (final DataFormatException e) {
+      throw new ImageReadException(""Unable to decompress image"", e);
+    }","[{'comment': 'Formatting needs to be changed to 4 spaces to match other classes.', 'commenter': 'kinow'}]"
43,src/main/java/org/apache/commons/imaging/common/Deflate.java,"@@ -0,0 +1,40 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.imaging.common;
+
+import java.util.zip.DataFormatException;
+import java.util.zip.Inflater;
+
+import org.apache.commons.imaging.ImageReadException;
+
+public class Deflate {","[{'comment': 'Probably some basic javadocs could help other devs/users :+1: ', 'commenter': 'kinow'}]"
43,src/main/java/org/apache/commons/imaging/formats/tiff/TiffReader.java,"@@ -412,7 +423,7 @@ public void read(final ByteSource byteSource, final Map<String, Object> params,
         readDirectories(byteSource, formatCompliance, listener);
     }
 
-    private TiffImageData getTiffRawImageData(final ByteSource byteSource,
+    public TiffImageData getTiffRawImageData(final ByteSource byteSource,","[{'comment': 'Making methods that were private now public always need a short explanation, as these methods will be now part of the maintained API accessible by users, and we will have to have more care to change it.\r\n\r\nCould you explain why these two methods in TiffReader are public and not private, please?', 'commenter': 'kinow'}, {'comment': 'I reverted these changes', 'commenter': 'pauldaustin'}]"
47,src/main/java/org/apache/commons/imaging/formats/jpeg/decoder/JpegDecoder.java,"@@ -71,11 +73,23 @@ public boolean beginSOS() {
     public void visitSOS(final int marker, final byte[] markerBytes, final byte[] imageData) {
         final ByteArrayInputStream is = new ByteArrayInputStream(imageData);
         try {
+            // read the scan header
             final int segmentLength = read2Bytes(""segmentLength"", is, ""Not a Valid JPEG File"", getByteOrder());
             final byte[] sosSegmentBytes = readBytes(""SosSegment"",
                     is, segmentLength - 2, ""Not a Valid JPEG File"");
             sosSegment = new SosSegment(marker, sosSegmentBytes);
 
+            // read the payload of the scan, this is the remainder of image data after the header
+            // the payload contains the entropy-encoded segments (or ECS) divded by RST markers","[{'comment': 's/divded/divided', 'commenter': 'kinow'}]"
47,src/main/java/org/apache/commons/imaging/formats/jpeg/decoder/JpegInputStream.java,"@@ -15,31 +15,39 @@
 
 package org.apache.commons.imaging.formats.jpeg.decoder;
 
-import java.io.IOException;
-import java.io.InputStream;
-
 import org.apache.commons.imaging.ImageReadException;
 import org.apache.commons.imaging.formats.jpeg.JpegConstants;
 
 class JpegInputStream {
     // Figure F.18, F.2.2.5, page 111 of ITU-T T.81
-    private final InputStream is;
+    private final int[] interval;
+    // next position in the array to read
+    private int nextPos;
     private int cnt;
     private int b;
 
-    JpegInputStream(final InputStream is) {
-        this.is = is;
+    JpegInputStream(final int[] interval) {
+        this.interval = interval;","[{'comment': '`this.interval = Arrays.copyOf(interval, interval.length);` to prevent mutability issues? Not sure if there is any risk (i.e. if internal only, probably not at risk, but may be still a good idea to play defensively here)', 'commenter': 'kinow'}]"
47,src/main/java/org/apache/commons/imaging/formats/jpeg/decoder/JpegInputStream.java,"@@ -57,4 +65,19 @@ public int nextBit() throws IOException, ImageReadException {
         b <<= 1;
         return bit;
     }
+
+    /**
+     * Returns the value from current field (as {@code InputStream.read()} would do)
+     * and set the position of the pointer to the next field to read.
+     * @return
+     * @throws IllegalStateException if the stream hasn't any other value.
+     */
+    int read() {
+        if (this.hasNext() == false) {","[{'comment': '`if (!this.hasNext())`', 'commenter': 'kinow'}]"
47,src/main/java/org/apache/commons/imaging/formats/jpeg/decoder/JpegDecoder.java,"@@ -393,6 +418,74 @@ private void readMCU(final JpegInputStream is, final int[] preds, final Block[]
         }
     }
 
+    /**
+     * Returns an array of JpegInputStream where each field contains the JpegInputStream
+     * for one interval.
+     * @param scanPayload array to read intervals from
+     * @return JpegInputStreams for all intervals, at least one stream is always provided
+     */
+    static JpegInputStream[] splitByRstMarkers(final int[] scanPayload) {
+        final List<Integer> intervalStarts = getIntervalStartPositions(scanPayload);
+        // get number of intervals in payload to init an array of approbiate length
+        final int intervalCount = intervalStarts.size();
+        JpegInputStream[] streams = new JpegInputStream[intervalCount];
+        for (int i = 0; i < intervalCount; i++) {
+            int from = intervalStarts.get(i);
+            int to;
+            if (i < intervalCount - 1) {
+                // because each restart marker needs two bytes the end of
+                // this interval is two bytes before the next interval starts
+                to = intervalStarts.get(i + 1) - 2;
+            } else { // the last interval ends with the array
+                to = scanPayload.length;
+            }
+            int[] interval = Arrays.copyOfRange(scanPayload, from, to);
+            streams[i] = new JpegInputStream(interval);
+        }
+        return streams;
+    }
+
+    /**
+     * Returns the positions of where each interval in the provided array starts.
+     * @param scanPayload array to examine
+     * @return the start positions, the number of start positions is also the count of intervals
+     * while the number of restart markers found = number of start positions - 1
+     * because restart markers are between intervals
+     */
+    static List<Integer> getIntervalStartPositions(final int[] scanPayload) {
+        final List<Integer> intervalStarts = new ArrayList<Integer>();
+        intervalStarts.add( 0 );
+        boolean foundFF = false;
+        boolean foundD0toD7 = false;
+        int pos = 0;
+        while ( pos < scanPayload.length ) {
+            if ( foundFF == true ) {
+                // found 0xFF D0 .. 0xFF D7 => RST marker
+                if ( scanPayload[ pos ] >= ( 0xff & JpegConstants.RST0_MARKER ) &&
+                    scanPayload[ pos ] <= ( 0xff & JpegConstants.RST7_MARKER ) ) {
+                    foundD0toD7 = true;
+                } else { // found 0xFF followed by something else => no RST marker
+                    foundFF = false;
+                }
+            }
+
+            if ( scanPayload[ pos ] == 0xFF ) {
+                foundFF = true;
+            }
+
+            // true if one of the RST markers was found
+            if ( foundFF == true && foundD0toD7 == true ) {","[{'comment': '`if (foundFF && foundD0toD7)`', 'commenter': 'kinow'}]"
47,src/main/java/org/apache/commons/imaging/formats/jpeg/decoder/JpegDecoder.java,"@@ -393,6 +418,74 @@ private void readMCU(final JpegInputStream is, final int[] preds, final Block[]
         }
     }
 
+    /**
+     * Returns an array of JpegInputStream where each field contains the JpegInputStream
+     * for one interval.
+     * @param scanPayload array to read intervals from
+     * @return JpegInputStreams for all intervals, at least one stream is always provided
+     */
+    static JpegInputStream[] splitByRstMarkers(final int[] scanPayload) {
+        final List<Integer> intervalStarts = getIntervalStartPositions(scanPayload);
+        // get number of intervals in payload to init an array of approbiate length
+        final int intervalCount = intervalStarts.size();
+        JpegInputStream[] streams = new JpegInputStream[intervalCount];
+        for (int i = 0; i < intervalCount; i++) {
+            int from = intervalStarts.get(i);
+            int to;
+            if (i < intervalCount - 1) {
+                // because each restart marker needs two bytes the end of
+                // this interval is two bytes before the next interval starts
+                to = intervalStarts.get(i + 1) - 2;
+            } else { // the last interval ends with the array
+                to = scanPayload.length;
+            }
+            int[] interval = Arrays.copyOfRange(scanPayload, from, to);
+            streams[i] = new JpegInputStream(interval);
+        }
+        return streams;
+    }
+
+    /**
+     * Returns the positions of where each interval in the provided array starts.
+     * @param scanPayload array to examine
+     * @return the start positions, the number of start positions is also the count of intervals
+     * while the number of restart markers found = number of start positions - 1
+     * because restart markers are between intervals
+     */
+    static List<Integer> getIntervalStartPositions(final int[] scanPayload) {
+        final List<Integer> intervalStarts = new ArrayList<Integer>();
+        intervalStarts.add( 0 );
+        boolean foundFF = false;
+        boolean foundD0toD7 = false;
+        int pos = 0;
+        while ( pos < scanPayload.length ) {
+            if ( foundFF == true ) {","[{'comment': '`if ( foundFF ) {`', 'commenter': 'kinow'}]"
47,src/main/java/org/apache/commons/imaging/formats/jpeg/decoder/JpegDecoder.java,"@@ -393,6 +418,74 @@ private void readMCU(final JpegInputStream is, final int[] preds, final Block[]
         }
     }
 
+    /**
+     * Returns an array of JpegInputStream where each field contains the JpegInputStream
+     * for one interval.
+     * @param scanPayload array to read intervals from
+     * @return JpegInputStreams for all intervals, at least one stream is always provided
+     */
+    static JpegInputStream[] splitByRstMarkers(final int[] scanPayload) {
+        final List<Integer> intervalStarts = getIntervalStartPositions(scanPayload);
+        // get number of intervals in payload to init an array of approbiate length
+        final int intervalCount = intervalStarts.size();
+        JpegInputStream[] streams = new JpegInputStream[intervalCount];
+        for (int i = 0; i < intervalCount; i++) {
+            int from = intervalStarts.get(i);
+            int to;
+            if (i < intervalCount - 1) {
+                // because each restart marker needs two bytes the end of
+                // this interval is two bytes before the next interval starts
+                to = intervalStarts.get(i + 1) - 2;
+            } else { // the last interval ends with the array
+                to = scanPayload.length;
+            }
+            int[] interval = Arrays.copyOfRange(scanPayload, from, to);
+            streams[i] = new JpegInputStream(interval);
+        }
+        return streams;
+    }
+
+    /**
+     * Returns the positions of where each interval in the provided array starts.
+     * @param scanPayload array to examine
+     * @return the start positions, the number of start positions is also the count of intervals
+     * while the number of restart markers found = number of start positions - 1
+     * because restart markers are between intervals
+     */
+    static List<Integer> getIntervalStartPositions(final int[] scanPayload) {
+        final List<Integer> intervalStarts = new ArrayList<Integer>();
+        intervalStarts.add( 0 );
+        boolean foundFF = false;
+        boolean foundD0toD7 = false;
+        int pos = 0;
+        while ( pos < scanPayload.length ) {
+            if ( foundFF == true ) {
+                // found 0xFF D0 .. 0xFF D7 => RST marker
+                if ( scanPayload[ pos ] >= ( 0xff & JpegConstants.RST0_MARKER ) &&
+                    scanPayload[ pos ] <= ( 0xff & JpegConstants.RST7_MARKER ) ) {
+                    foundD0toD7 = true;
+                } else { // found 0xFF followed by something else => no RST marker
+                    foundFF = false;
+                }
+            }
+
+            if ( scanPayload[ pos ] == 0xFF ) {
+                foundFF = true;
+            }
+
+            // true if one of the RST markers was found
+            if ( foundFF == true && foundD0toD7 == true ) {
+                // we need to add the position after the current position because
+                // we had already read 0xFF and are now at 0xDn
+                intervalStarts.add( pos + 1 );","[{'comment': '`intervalStarts.add(pos + 1);`, spaces', 'commenter': 'kinow'}]"
47,src/main/java/org/apache/commons/imaging/formats/jpeg/decoder/JpegDecoder.java,"@@ -393,6 +418,74 @@ private void readMCU(final JpegInputStream is, final int[] preds, final Block[]
         }
     }
 
+    /**
+     * Returns an array of JpegInputStream where each field contains the JpegInputStream
+     * for one interval.
+     * @param scanPayload array to read intervals from
+     * @return JpegInputStreams for all intervals, at least one stream is always provided
+     */
+    static JpegInputStream[] splitByRstMarkers(final int[] scanPayload) {
+        final List<Integer> intervalStarts = getIntervalStartPositions(scanPayload);
+        // get number of intervals in payload to init an array of approbiate length
+        final int intervalCount = intervalStarts.size();
+        JpegInputStream[] streams = new JpegInputStream[intervalCount];
+        for (int i = 0; i < intervalCount; i++) {
+            int from = intervalStarts.get(i);
+            int to;
+            if (i < intervalCount - 1) {
+                // because each restart marker needs two bytes the end of
+                // this interval is two bytes before the next interval starts
+                to = intervalStarts.get(i + 1) - 2;
+            } else { // the last interval ends with the array
+                to = scanPayload.length;
+            }
+            int[] interval = Arrays.copyOfRange(scanPayload, from, to);
+            streams[i] = new JpegInputStream(interval);
+        }
+        return streams;
+    }
+
+    /**
+     * Returns the positions of where each interval in the provided array starts.
+     * @param scanPayload array to examine
+     * @return the start positions, the number of start positions is also the count of intervals
+     * while the number of restart markers found = number of start positions - 1
+     * because restart markers are between intervals
+     */
+    static List<Integer> getIntervalStartPositions(final int[] scanPayload) {
+        final List<Integer> intervalStarts = new ArrayList<Integer>();
+        intervalStarts.add( 0 );
+        boolean foundFF = false;
+        boolean foundD0toD7 = false;
+        int pos = 0;
+        while ( pos < scanPayload.length ) {
+            if ( foundFF == true ) {
+                // found 0xFF D0 .. 0xFF D7 => RST marker
+                if ( scanPayload[ pos ] >= ( 0xff & JpegConstants.RST0_MARKER ) &&
+                    scanPayload[ pos ] <= ( 0xff & JpegConstants.RST7_MARKER ) ) {
+                    foundD0toD7 = true;
+                } else { // found 0xFF followed by something else => no RST marker
+                    foundFF = false;
+                }
+            }
+
+            if ( scanPayload[ pos ] == 0xFF ) {","[{'comment': '`if (scanPayload[ pos ] == 0xFF) {`, spaces', 'commenter': 'kinow'}]"
47,src/main/java/org/apache/commons/imaging/formats/jpeg/decoder/JpegDecoder.java,"@@ -393,6 +418,74 @@ private void readMCU(final JpegInputStream is, final int[] preds, final Block[]
         }
     }
 
+    /**
+     * Returns an array of JpegInputStream where each field contains the JpegInputStream
+     * for one interval.
+     * @param scanPayload array to read intervals from
+     * @return JpegInputStreams for all intervals, at least one stream is always provided
+     */
+    static JpegInputStream[] splitByRstMarkers(final int[] scanPayload) {
+        final List<Integer> intervalStarts = getIntervalStartPositions(scanPayload);
+        // get number of intervals in payload to init an array of approbiate length
+        final int intervalCount = intervalStarts.size();
+        JpegInputStream[] streams = new JpegInputStream[intervalCount];
+        for (int i = 0; i < intervalCount; i++) {
+            int from = intervalStarts.get(i);
+            int to;
+            if (i < intervalCount - 1) {
+                // because each restart marker needs two bytes the end of
+                // this interval is two bytes before the next interval starts
+                to = intervalStarts.get(i + 1) - 2;
+            } else { // the last interval ends with the array
+                to = scanPayload.length;
+            }
+            int[] interval = Arrays.copyOfRange(scanPayload, from, to);
+            streams[i] = new JpegInputStream(interval);
+        }
+        return streams;
+    }
+
+    /**
+     * Returns the positions of where each interval in the provided array starts.
+     * @param scanPayload array to examine
+     * @return the start positions, the number of start positions is also the count of intervals
+     * while the number of restart markers found = number of start positions - 1
+     * because restart markers are between intervals
+     */
+    static List<Integer> getIntervalStartPositions(final int[] scanPayload) {
+        final List<Integer> intervalStarts = new ArrayList<Integer>();
+        intervalStarts.add( 0 );
+        boolean foundFF = false;
+        boolean foundD0toD7 = false;
+        int pos = 0;
+        while ( pos < scanPayload.length ) {","[{'comment': '`while (pos < scanPayload.length) {`, spaces', 'commenter': 'kinow'}]"
47,src/main/java/org/apache/commons/imaging/formats/jpeg/decoder/JpegDecoder.java,"@@ -393,6 +418,74 @@ private void readMCU(final JpegInputStream is, final int[] preds, final Block[]
         }
     }
 
+    /**
+     * Returns an array of JpegInputStream where each field contains the JpegInputStream
+     * for one interval.
+     * @param scanPayload array to read intervals from
+     * @return JpegInputStreams for all intervals, at least one stream is always provided
+     */
+    static JpegInputStream[] splitByRstMarkers(final int[] scanPayload) {
+        final List<Integer> intervalStarts = getIntervalStartPositions(scanPayload);
+        // get number of intervals in payload to init an array of approbiate length
+        final int intervalCount = intervalStarts.size();
+        JpegInputStream[] streams = new JpegInputStream[intervalCount];
+        for (int i = 0; i < intervalCount; i++) {
+            int from = intervalStarts.get(i);
+            int to;
+            if (i < intervalCount - 1) {
+                // because each restart marker needs two bytes the end of
+                // this interval is two bytes before the next interval starts
+                to = intervalStarts.get(i + 1) - 2;
+            } else { // the last interval ends with the array
+                to = scanPayload.length;
+            }
+            int[] interval = Arrays.copyOfRange(scanPayload, from, to);
+            streams[i] = new JpegInputStream(interval);
+        }
+        return streams;
+    }
+
+    /**
+     * Returns the positions of where each interval in the provided array starts.
+     * @param scanPayload array to examine
+     * @return the start positions, the number of start positions is also the count of intervals
+     * while the number of restart markers found = number of start positions - 1
+     * because restart markers are between intervals
+     */
+    static List<Integer> getIntervalStartPositions(final int[] scanPayload) {
+        final List<Integer> intervalStarts = new ArrayList<Integer>();
+        intervalStarts.add( 0 );","[{'comment': '`intervalStarts.add(0);`, spaces', 'commenter': 'kinow'}]"
47,src/main/java/org/apache/commons/imaging/formats/jpeg/decoder/JpegDecoder.java,"@@ -393,6 +418,74 @@ private void readMCU(final JpegInputStream is, final int[] preds, final Block[]
         }
     }
 
+    /**
+     * Returns an array of JpegInputStream where each field contains the JpegInputStream
+     * for one interval.
+     * @param scanPayload array to read intervals from
+     * @return JpegInputStreams for all intervals, at least one stream is always provided
+     */
+    static JpegInputStream[] splitByRstMarkers(final int[] scanPayload) {
+        final List<Integer> intervalStarts = getIntervalStartPositions(scanPayload);
+        // get number of intervals in payload to init an array of approbiate length
+        final int intervalCount = intervalStarts.size();
+        JpegInputStream[] streams = new JpegInputStream[intervalCount];
+        for (int i = 0; i < intervalCount; i++) {
+            int from = intervalStarts.get(i);
+            int to;
+            if (i < intervalCount - 1) {
+                // because each restart marker needs two bytes the end of
+                // this interval is two bytes before the next interval starts
+                to = intervalStarts.get(i + 1) - 2;
+            } else { // the last interval ends with the array
+                to = scanPayload.length;
+            }
+            int[] interval = Arrays.copyOfRange(scanPayload, from, to);
+            streams[i] = new JpegInputStream(interval);
+        }
+        return streams;
+    }
+
+    /**
+     * Returns the positions of where each interval in the provided array starts.
+     * @param scanPayload array to examine
+     * @return the start positions, the number of start positions is also the count of intervals
+     * while the number of restart markers found = number of start positions - 1
+     * because restart markers are between intervals","[{'comment': 'What about moving the longer text to the main body of the javadocs comment? i.e.\r\n\r\n```java\r\n     * Returns the positions of where each interval in the provided array starts. The number\r\n     * of start positions is also the count of intervals while the number of restart markers\r\n     * found is equal to the number of start positions minus one (because restart markers\r\n     * are between intervals).\r\n     * @param scanPayload array to examine\r\n     * @return the start positions\r\n```', 'commenter': 'kinow'}]"
47,src/main/java/org/apache/commons/imaging/formats/jpeg/decoder/JpegDecoder.java,"@@ -122,8 +134,21 @@ public void visitSOS(final int marker, final byte[] markerBytes, final byte[] im
             }
             final DataBuffer dataBuffer = raster.getDataBuffer();
 
+            final JpegInputStream[] bitInputStreams = splitByRstMarkers(scanPayload);
+            int bitInputStreamCount = 0;
+            JpegInputStream bitInputStream = bitInputStreams[0];
+
             for (int y1 = 0; y1 < vSize * yMCUs; y1 += vSize) {
                 for (int x1 = 0; x1 < hSize * xMCUs; x1 += hSize) {
+                    // provide a the next interval if an interval is read until it's end
+                    // as long there are unread intervals available
+                    if (bitInputStream.hasNext() == false) {","[{'comment': '`if (!bitInputStream.hasNext()) {`', 'commenter': 'kinow'}]"
47,src/main/java/org/apache/commons/imaging/formats/jpeg/decoder/JpegDecoder.java,"@@ -122,8 +134,21 @@ public void visitSOS(final int marker, final byte[] markerBytes, final byte[] im
             }
             final DataBuffer dataBuffer = raster.getDataBuffer();
 
+            final JpegInputStream[] bitInputStreams = splitByRstMarkers(scanPayload);
+            int bitInputStreamCount = 0;
+            JpegInputStream bitInputStream = bitInputStreams[0];
+
             for (int y1 = 0; y1 < vSize * yMCUs; y1 += vSize) {
                 for (int x1 = 0; x1 < hSize * xMCUs; x1 += hSize) {
+                    // provide a the next interval if an interval is read until it's end
+                    // as long there are unread intervals available","[{'comment': 'Maybe\r\n\r\n```\r\nprovide the next interval if an interval is read until its end\r\nas long as there are unread intervals available\r\n```\r\n?', 'commenter': 'kinow'}]"
53,src/main/java/org/apache/commons/imaging/formats/tiff/write/TiffImageWriterLossy.java,"@@ -50,6 +50,8 @@ public void write(final OutputStream os, final TiffOutputSet outputSet)
         final BinaryOutputStream bos = new BinaryOutputStream(os, byteOrder);
 
         writeStep(bos, outputItems);
+
+        bos.close();","[{'comment': ""Hi @emopers \r\n\r\nYou are correct on that. The issue on this method (and I think there might be other places in Imaging with the same issue) is that this was by design.\r\n\r\nThe `BinaryOutputStream` created here wraps the parameter `os`, an `OutputStream` passed by the user. We shouldn't close the stream that the user passed, but calling `BinaryOutputStream#close` will close the underlying stream as well - https://github.com/apache/commons-imaging/blob/8ee267db7a05d26f66e5f0b0ec7af6b813f99345/src/main/java/org/apache/commons/imaging/common/BinaryOutputStream.java#L71\r\n\r\nThat's why some time ago, when we fixed several cases of resources left open by using the `try-with-resources` trick, we left this one as-is."", 'commenter': 'kinow'}]"
62,src/main/java/org/apache/commons/imaging/formats/gif/GifImageMetadataItem.java,"@@ -42,13 +44,16 @@ public int getTopPosition() {
         return topPosition;
     }
 
+    public DisposalMethod getDisposalMethod() { return disposalMethod; }","[{'comment': 'Just format as other methods and checkstyle test should pass, probably Travis will give the green flag after this :+1: ', 'commenter': 'kinow'}, {'comment': 'Thanks. Fixed formatting.', 'commenter': 'christoffer-rydberg'}]"
112,src/main/java/org/apache/commons/imaging/common/itu_t4/T4AndT6Compression.java,"@@ -139,8 +139,8 @@ private static void compress1DLine(final BitInputStreamFlexible inputStream,
     public static byte[] decompressModifiedHuffman(final byte[] compressed,
             final int width, final int height) throws ImageReadException {
         try (ByteArrayInputStream baos = new ByteArrayInputStream(compressed);
-                BitInputStreamFlexible inputStream = new BitInputStreamFlexible(baos);
-                BitArrayOutputStream outputStream = new BitArrayOutputStream()) {","[{'comment': ':+1: ', 'commenter': 'kinow'}]"
112,src/main/java/org/apache/commons/imaging/formats/jpeg/iptc/IptcParser.java,"@@ -59,8 +59,8 @@
      * Block types (or Image Resource IDs) that are not recommended to be
      * interpreted when libraries process Photoshop IPTC metadata.
      *
-     * @see https://www.adobe.com/devnet-apps/photoshop/fileformatashtml/
-     * @see https://issues.apache.org/jira/browse/IMAGING-246
+     * @see <a href=""https://www.adobe.com/devnet-apps/photoshop/fileformatashtml/""> Adobe Photoshop File Formats Specification</a>
+     * @see <a href=""https://issues.apache.org/jira/browse/IMAGING-246>IMAGING-246</a>","[{'comment': 'Merged in your other PR :+1: (thanks!)', 'commenter': 'kinow'}]"
114,src/main/java/org/apache/commons/imaging/color/ColorConversions.java,"@@ -16,44 +16,46 @@
  */
 package org.apache.commons.imaging.color;
 
+import java.awt.Color;
 
 public final class ColorConversions {
-    private static final double REF_X = 95.047;  // Observer= 2, Illuminant= D65
+
+    // White reference
+    /** see: https://en.wikipedia.org/wiki/CIELAB_color_space#From_CIEXYZ_to_CIELAB[10] */
+    private static final double REF_X = 95.047; // Observer= 2, Illuminant= D65
+
+    /** see: https://en.wikipedia.org/wiki/CIELAB_color_space#From_CIEXYZ_to_CIELAB[10] */
     private static final double REF_Y = 100.000;
+
+    /** see: https://en.wikipedia.org/wiki/CIELAB_color_space#From_CIEXYZ_to_CIELAB[10] */
     private static final double REF_Z = 108.883;
 
+    /** see: https://en.wikipedia.org/wiki/CIELAB_color_space#From_CIEXYZ_to_CIELAB[10] */
+    private static final double XYZ_m = 7.787037; // match in slope. Note commonly seen 7.787 gives worse results
+
+    /** see: https://en.wikipedia.org/wiki/CIELAB_color_space#From_CIEXYZ_to_CIELAB[10] */
+    private static final double XYZ_t0 = 0.008856;
+
     private ColorConversions() {
     }
 
     public static ColorCieLab convertXYZtoCIELab(final ColorXyz xyz) {
         return convertXYZtoCIELab(xyz.X, xyz.Y, xyz.Z);
     }
 
-    public static ColorCieLab convertXYZtoCIELab(final double X, final double Y,
-            final double Z) {
+    public static ColorCieLab convertXYZtoCIELab(final double X, final double Y, final double Z) {
 
-        double var_X = X / REF_X; // REF_X = 95.047 Observer= 2, Illuminant=
-                                  // D65
+        double var_X = X / REF_X; // REF_X = 95.047 Observer= 2, Illuminant= D65
         double var_Y = Y / REF_Y; // REF_Y = 100.000
         double var_Z = Z / REF_Z; // REF_Z = 108.883
 
-        if (var_X > 0.008856) {
-            var_X = Math.pow(var_X, (1 / 3.0));
-        } else {
-            var_X = (7.787 * var_X) + (16 / 116.0);
-        }
-        if (var_Y > 0.008856) {
-            var_Y = Math.pow(var_Y, 1 / 3.0);
-        } else {
-            var_Y = (7.787 * var_Y) + (16 / 116.0);
-        }
-        if (var_Z > 0.008856) {
-            var_Z = Math.pow(var_Z, 1 / 3.0);
-        } else {
-            var_Z = (7.787 * var_Z) + (16 / 116.0);
-        }
+        // Pivot XZ:
+        var_X = pivotXYZ(var_X);
+        var_Y = pivotXYZ(var_Y);
+        var_Z = pivotXYZ(var_Z);","[{'comment': 'avoids some copy/paste errors as well, in case there are changes', 'commenter': 'Brixomatic'}]"
114,src/main/java/org/apache/commons/imaging/color/ColorConversions.java,"@@ -68,24 +70,12 @@ public static ColorXyz convertCIELabtoXYZ(final double L, final double a, final
         double var_X = a / 500 + var_Y;
         double var_Z = var_Y - b / 200.0;
 
-        if (Math.pow(var_Y, 3) > 0.008856) {
-            var_Y = Math.pow(var_Y, 3);
-        } else {
-            var_Y = (var_Y - 16 / 116.0) / 7.787;
-        }
-        if (Math.pow(var_X, 3) > 0.008856) {
-            var_X = Math.pow(var_X, 3);
-        } else {
-            var_X = (var_X - 16 / 116.0) / 7.787;
-        }
-        if (Math.pow(var_Z, 3) > 0.008856) {
-            var_Z = Math.pow(var_Z, 3);
-        } else {
-            var_Z = (var_Z - 16 / 116.0) / 7.787;
-        }
+        var_Y = unPivotXYZ(var_Y);
+        var_X = unPivotXYZ(var_X);
+        var_Z = unPivotXYZ(var_Z);","[{'comment': 'again removing some copy/paste', 'commenter': 'Brixomatic'}]"
114,src/main/java/org/apache/commons/imaging/color/ColorConversions.java,"@@ -132,33 +123,31 @@ public static int convertXYZtoRGB(final double X, final double Y, final double Z
         final double var_Y = Y / 100.0; // Where Y = 0  100.000
         final double var_Z = Z / 100.0; // Where Z = 0  108.883
 
-        double var_R = var_X * 3.2406 + var_Y * -1.5372 + var_Z * -0.4986;
-        double var_G = var_X * -0.9689 + var_Y * 1.8758 + var_Z * 0.0415;
-        double var_B = var_X * 0.0557 + var_Y * -0.2040 + var_Z * 1.0570;
+        // see: https://github.com/StanfordHCI/c3/blob/master/java/src/edu/stanford/vis/color/LAB.java
+        double var_R = var_X * 3.2404542 + var_Y * -1.5371385 + var_Z * -0.4985314;
+        double var_G = var_X * -0.9692660 + var_Y * 1.8760108 + var_Z * 0.0415560;
+        double var_B = var_X * 0.0556434 + var_Y * -0.2040259 + var_Z * 1.0572252;","[{'comment': 'Using more precise numbers. This made some small, but noticeable difference in tests.', 'commenter': 'Brixomatic'}]"
114,src/main/java/org/apache/commons/imaging/color/ColorConversions.java,"@@ -168,34 +157,32 @@ public static ColorXyz convertRGBtoXYZ(final int rgb) {
         double var_G = g / 255.0; // Where G = 0  255
         double var_B = b / 255.0; // Where B = 0  255
 
-        if (var_R > 0.04045) {
-            var_R = Math.pow((var_R + 0.055) / 1.055, 2.4);
-        } else {
-            var_R = var_R / 12.92;
-        }
-        if (var_G > 0.04045) {
-            var_G = Math.pow((var_G + 0.055) / 1.055, 2.4);
-        } else {
-            var_G = var_G / 12.92;
-        }
-        if (var_B > 0.04045) {
-            var_B = Math.pow((var_B + 0.055) / 1.055, 2.4);
-        } else {
-            var_B = var_B / 12.92;
-        }
+        // Pivot RGB:
+        var_R = unPivotRGB(var_R);
+        var_G = unPivotRGB(var_G);
+        var_B = unPivotRGB(var_B);
 
-        var_R = var_R * 100;
-        var_G = var_G * 100;
-        var_B = var_B * 100;
+        var_R *= 100;
+        var_G *= 100;
+        var_B *= 100;
 
         // Observer. = 2, Illuminant = D65
-        final double X = var_R * 0.4124 + var_G * 0.3576 + var_B * 0.1805;
-        final double Y = var_R * 0.2126 + var_G * 0.7152 + var_B * 0.0722;
-        final double Z = var_R * 0.0193 + var_G * 0.1192 + var_B * 0.9505;
+        // see: https://github.com/StanfordHCI/c3/blob/master/java/src/edu/stanford/vis/color/LAB.java
+        final double X = var_R * 0.4124564 + var_G * 0.3575761 + var_B * 0.1804375;
+        final double Y = var_R * 0.2126729 + var_G * 0.7151522 + var_B * 0.0721750;
+        final double Z = var_R * 0.0193339 + var_G * 0.1191920 + var_B * 0.9503041;","[{'comment': 'more precise numbers for better conversion', 'commenter': 'Brixomatic'}]"
114,src/main/java/org/apache/commons/imaging/color/ColorConversions.java,"@@ -643,28 +602,30 @@ private static int convertRGBtoRGB(int red, int green, int blue) {
         return rgb;
     }
 
+    private static int convertRGBtoRGB(final Color color) {
+        return color.getRGB() | 0xff << 24; // alpha channel always opaque
+    }","[{'comment': 'Adding the direct use of java.awt.Color.', 'commenter': 'Brixomatic'}, {'comment': 'Ideally we would limit awt use, or remove it, so that users can use Imaging for Android apps too (we have one user with a workaround on his code at the moment). Unless that makes maintaining the code extremely difficult, in which case we can just try to figure out another way to provide a version compatible with Android...', 'commenter': 'kinow'}, {'comment': 'Point taken. I have removed the java.awt reference.\r\n', 'commenter': 'Brixomatic'}]"
114,src/main/java/org/apache/commons/imaging/color/ColorConversions.java,"@@ -643,28 +602,30 @@ private static int convertRGBtoRGB(int red, int green, int blue) {
         return rgb;
     }
 
+    private static int convertRGBtoRGB(final Color color) {
+        return color.getRGB() | 0xff << 24; // alpha channel always opaque
+    }
+
     public static ColorCieLch convertCIELabtoCIELCH(final ColorCieLab cielab) {
         return convertCIELabtoCIELCH(cielab.L, cielab.a, cielab.b);
     }
 
     public static ColorCieLch convertCIELabtoCIELCH(final double L, final double a, final double b) {
-        double var_H = Math.atan2(b, a); // Quadrant by signs
+        // atan2(y,x) returns atan(y/x)
+        final double atanba = Math.atan2(b, a); // Quadrant by signs
 
-        if (var_H > 0) {
-            var_H = (var_H / Math.PI) * 180.0;
-        } else {
-            var_H = 360 - radian_2_degree(Math.abs(var_H));
-        }
+        final double h = atanba > 0 //
+                ? Math.toDegrees(atanba) //
+                : Math.toDegrees(atanba) + 360;","[{'comment': 'We can very well use java.lang.Math, instead of doing it step by step. Also reads better.', 'commenter': 'Brixomatic'}]"
114,src/main/java/org/apache/commons/imaging/color/ColorConversions.java,"@@ -747,4 +700,147 @@ public static ColorXyz convertCIELuvtoXYZ(final double L, final double u, final
 
         return new ColorXyz(X, Y, Z);
     }
+
+    public static ColorDIN99Lab convertCIELabToDIN99bLab(final ColorCieLab cie) {
+        return convertCIELabToDIN99bLab(cie.L, cie.a, cie.b);
+    }
+
+    public static ColorDIN99Lab convertCIELabToDIN99bLab(final double L, final double a, final double b) {
+        final double FAC_1 = 100.0 / Math.log(129.0 / 50.0); // = 105.51
+        final double kE = 1.0; // brightness factor, 1.0 for CIE reference conditions
+        final double kCH = 1.0; // chroma and hue factor, 1.0 for CIE reference conditions
+        final double ang = Math.toRadians(16.0);
+
+        final double L99 = kE * FAC_1 * Math.log(1. + 0.0158 * L);
+        double a99 = 0.0;
+        double b99 = 0.0;
+        if (a != 0.0 || b != 0.0) {
+            final double e = a * Math.cos(ang) + b * Math.sin(ang);
+            final double f = 0.7 * (b * Math.cos(ang) - a * Math.sin(ang));
+            final double G = Math.sqrt(e * e + f * f);
+            if (G != 0.) {
+                final double k = Math.log(1. + 0.045 * G) / (0.045 * kCH * kE * G);
+                a99 = k * e;
+                b99 = k * f;
+            }
+        }
+        return new ColorDIN99Lab(L99, a99, b99);
+    }
+
+    public static ColorCieLab convertDIN99bLabToCIELab(final ColorDIN99Lab dinb) {
+        return convertDIN99bLabToCIELab(dinb.L99, dinb.a99, dinb.b99);
+    }
+
+    public static ColorCieLab convertDIN99bLabToCIELab(final double L99b, final double a99b, final double b99b) {
+        final double kE = 1.0; // brightness factor, 1.0 for CIE reference conditions
+        final double kCH = 1.0; // chroma and hue factor, 1.0 for CIE reference conditions
+        final double FAC_1 = 100.0 / Math.log(129.0 / 50.0); // L99 scaling factor = 105.50867113783109
+        final double ang = Math.toRadians(16.0);
+
+        final double hef = Math.atan2(b99b, a99b);
+        final double C = Math.sqrt(a99b * a99b + b99b * b99b);
+        final double G = (Math.exp(0.045 * C * kCH * kE) - 1.0) / 0.045;
+        final double e = G * Math.cos(hef);
+        final double f = G * Math.sin(hef) / 0.7;
+
+        final double L = (Math.exp(L99b * kE / FAC_1) - 1.) / 0.0158;
+        final double a = e * Math.cos(ang) - f * Math.sin(ang);
+        final double b = e * Math.sin(ang) + f * Math.cos(ang);
+        return new ColorCieLab(L, a, b);
+    }
+
+    /** DIN99o, see: https://de.wikipedia.org/w/index.php?title=Diskussion:DIN99-Farbraum */
+    public static ColorDIN99Lab convertCIELabToDIN99oLab(final ColorCieLab cie) {
+        return convertCIELabToDIN99oLab(cie.L, cie.a, cie.b);
+    }
+
+    /** DIN99o, see: https://de.wikipedia.org/w/index.php?title=Diskussion:DIN99-Farbraum */
+    public static ColorDIN99Lab convertCIELabToDIN99oLab(final double L, final double a, final double b) {
+        final double kE = 1.0; // brightness factor, 1.0 for CIE reference conditions
+        final double kCH = 1.0; // chroma and hue factor, 1.0 for CIE reference conditions
+        final double FAC_1 = 100.0 / Math.log(139.0 / 100.0); // L99 scaling factor = 303.67100547050995
+        final double ang = Math.toRadians(26.0);
+
+        final double L99o = FAC_1 / kE * Math.log(1 + 0.0039 * L); // Lightness correction kE
+        double a99o = 0.0;
+        double b99o = 0.0;
+        if (a != 0.0 || b != 0.0) {
+            final double eo = a * Math.cos(ang) + b * Math.sin(ang); // a stretching
+            final double fo = 0.83 * (b * Math.cos(ang) - a * Math.sin(ang)); // b rotation/stretching
+            final double Go = Math.sqrt(eo * eo + fo * fo); // chroma
+            final double C99o = Math.log(1.0 + 0.075 * Go) / (0.0435 * kCH * kE); // factor for chroma compression and viewing conditions
+            final double heofo = Math.atan2(fo, eo); // arctan in four quadrants
+            final double h99o = heofo + ang; // hue rotation
+            a99o = C99o * Math.cos(h99o);
+            b99o = C99o * Math.sin(h99o);
+        }
+        return new ColorDIN99Lab(L99o, a99o, b99o);
+    }
+
+    /** DIN99o, see: https://de.wikipedia.org/w/index.php?title=Diskussion:DIN99-Farbraum */
+    public static ColorCieLab convertDIN99oLabToCIELab(final ColorDIN99Lab dino) {
+        return convertDIN99oLabToCIELab(dino.L99, dino.a99, dino.b99);
+    }
+
+    /** DIN99o, see: https://de.wikipedia.org/w/index.php?title=Diskussion:DIN99-Farbraum */
+    public static ColorCieLab convertDIN99oLabToCIELab(final double L99o, final double a99o, final double b99o) {
+        final double kE = 1.0; // brightness factor, 1.0 for CIE reference conditions
+        final double kCH = 1.0; // chroma and hue factor, 1.0 for CIE reference conditions
+        final double FAC_1 = 100.0 / Math.log(139.0 / 100.0); // L99 scaling factor = 303.67100547050995
+        final double ang = Math.toRadians(26.0);
+
+        final double L = (Math.exp(L99o * kE / FAC_1) - 1.0) / 0.0039;
+
+        final double h99ef = Math.atan2(b99o, a99o); // arctan in four quadrants
+
+        final double heofo = h99ef - ang; // backwards hue rotation
+
+        final double C99 = Math.sqrt(a99o * a99o + b99o * b99o); // DIN99 chroma
+        final double G = (Math.exp(0.0435 * kE * kCH * C99) - 1.0) / 0.075; // factor for chroma decompression and viewing conditions
+        final double e = G * Math.cos(heofo);
+        final double f = G * Math.sin(heofo);
+
+        final double a = e * Math.cos(ang) - f / 0.83 * Math.sin(ang); // rotation by 26 degrees
+        final double b = e * Math.sin(ang) + f / 0.83 * Math.cos(ang); // rotation by 26 degrees
+
+        return new ColorCieLab(L, a, b);
+    }","[{'comment': ""Note that the DIN99 standard has several iterations. These here deal with DIN99b (important milestone) and DIN99o (latest to date, AFAIK). Note I'm using the new class ColorDIN99Lab for both of these. Not sure we need to have separate classes, since both denote a Lab coordinate in the DIN99 color space.\r\nNote that DIN99 is a German norm (DIN stands or German Institute for Standardization), most comprehensive documents and discussions it are in the German language, hence some links to it point to the original sources consulted for the implementation."", 'commenter': 'Brixomatic'}, {'comment': ""Even though the sources are in German, you've done an excellent job maintaining this new code as similar as possible to the Wikipedia text, and also added some comments :+1: Looks good to me."", 'commenter': 'kinow'}]"
114,src/main/java/org/apache/commons/imaging/color/ColorConversions.java,"@@ -16,44 +16,46 @@
  */
 package org.apache.commons.imaging.color;
 
+import java.awt.Color;
 
 public final class ColorConversions {
-    private static final double REF_X = 95.047;  // Observer= 2, Illuminant= D65
+
+    // White reference
+    /** see: https://en.wikipedia.org/wiki/CIELAB_color_space#From_CIEXYZ_to_CIELAB[10] */
+    private static final double REF_X = 95.047; // Observer= 2, Illuminant= D65
+
+    /** see: https://en.wikipedia.org/wiki/CIELAB_color_space#From_CIEXYZ_to_CIELAB[10] */
     private static final double REF_Y = 100.000;
+
+    /** see: https://en.wikipedia.org/wiki/CIELAB_color_space#From_CIEXYZ_to_CIELAB[10] */
     private static final double REF_Z = 108.883;
 
+    /** see: https://en.wikipedia.org/wiki/CIELAB_color_space#From_CIEXYZ_to_CIELAB[10] */
+    private static final double XYZ_m = 7.787037; // match in slope. Note commonly seen 7.787 gives worse results
+
+    /** see: https://en.wikipedia.org/wiki/CIELAB_color_space#From_CIEXYZ_to_CIELAB[10] */
+    private static final double XYZ_t0 = 0.008856;","[{'comment': ""Extracted these constants to give them a name that matches the published formulas\r\n\r\nNote that for XYZ_m, I'm using a more precise value."", 'commenter': 'Brixomatic'}]"
114,src/main/java/org/apache/commons/imaging/color/ColorConversions.java,"@@ -99,8 +89,8 @@ public static ColorHunterLab convertXYZtoHunterLab(final ColorXyz xyz) {
     public static ColorHunterLab convertXYZtoHunterLab(final double X,
             final double Y, final double Z) {
         final double L = 10 * Math.sqrt(Y);
-        final double a = 17.5 * (((1.02 * X) - Y) / Math.sqrt(Y));
-        final double b = 7 * ((Y - (0.847 * Z)) / Math.sqrt(Y));
+        final double a = Y == 0.0 ? 0.0 : 17.5 * (((1.02 * X) - Y) / Math.sqrt(Y));
+        final double b = Y == 0.0 ? 0.0 : 7 * ((Y - (0.847 * Z)) / Math.sqrt(Y));","[{'comment': 'If Y == 0.0 (as with black color) ""a"" and ""b"" would become ""NaN"", this the same fix that colormine uses (see [HunterLabConverter.cs](https://github.com/muak/ColorMine/blob/master/ColorMine/ColorSpaces/Conversions/HunterLabConverter.cs) )', 'commenter': 'Brixomatic'}, {'comment': 'Oh, good catch! :clap: ', 'commenter': 'kinow'}]"
114,src/test/java/org/apache/commons/imaging/color/ColorConversionsTest.java,"@@ -39,7 +40,7 @@ public void testRGBtoCMYK() {
             Debug.debug(""cmyk_cmy: "" + cmyk_cmy);
             Debug.debug(""cmyk_cmy_rgb: "" + cmyk_cmy_rgb + "" ("" + Integer.toHexString(cmyk_cmy_rgb) + "")"");
 
-            assertEquals((0xffffff & cmyk_cmy_rgb), (0xffffff & rgb));
+            assertEquals(toHexString(0xffffff & rgb), toHexString(0xffffff & cmyk_cmy_rgb));","[{'comment': '""expected"" and ""actual"" values where in the wrong order. Also, comparing the hex strings is much more comprehensible in test failure messages.', 'commenter': 'Brixomatic'}]"
114,src/main/java/org/apache/commons/imaging/color/ColorCieLch.java,"@@ -19,10 +19,14 @@
 /**
  * Represents a color in the CIELCH color space.
  *
- * <p>Contains the constant values for black, white, red,
- * green, and blue.</p>
+ * <p>
+ * Contains the constant values for black, white, red,
+ * green, and blue.
+ * </p>
+ * Changes: H renamed to h.","[{'comment': 'The changes must be documented in a JIRA issue and linked to the changelog (i.e. the JIRA number is added to src/changes/changes.xml later, used to generate the changes report from the project site).', 'commenter': 'kinow'}, {'comment': ""> The changes must be documented in a JIRA issue and linked to the changelog (i.e. the JIRA number is added to src/changes/changes.xml later, used to generate the changes report from the project site).\r\n\r\nI don't have access to the JIRA. Would you mind to do that for me, given my comments in this PR?"", 'commenter': 'Brixomatic'}, {'comment': 'Sure, will create it later and link it here :-) ', 'commenter': 'kinow'}, {'comment': '> Sure, will create it later and link it here :-)\r\n\r\nSplendid, thank you!', 'commenter': 'Brixomatic'}, {'comment': 'Not a problem. But this needs to be removed from this file anyway in the meantime :+1: I will create the issue later once I think of a good title/description.', 'commenter': 'kinow'}]"
114,src/test/java/org/apache/commons/imaging/color/ColorConversionsTest.java,"@@ -116,4 +117,36 @@ public void testXYZ() {
             Debug.debug(""cieluv_xyz"", cieluv_xyz);
         }
     }
+
+    @Test
+    public void testRGBtoDin99b() {
+        for (final int rgb : SAMPLE_RGBS) {
+
+        	final ColorXyz xyz = ColorConversions.convertRGBtoXYZ(rgb);","[{'comment': '@Brixomatic it looks like there are tabs in this file. When you update this PR, could you check if there are any tabs and, please, replace by spaces?', 'commenter': 'kinow'}, {'comment': 'will do', 'commenter': 'Brixomatic'}]"
114,src/main/java/org/apache/commons/imaging/color/ColorConversions.java,"@@ -168,30 +152,24 @@ public static ColorXyz convertRGBtoXYZ(final int rgb) {
         double var_G = g / 255.0; // Where G = 0  255
         double var_B = b / 255.0; // Where B = 0  255
 
-        if (var_R > 0.04045) {
-            var_R = Math.pow((var_R + 0.055) / 1.055, 2.4);
-        } else {
-            var_R = var_R / 12.92;
-        }
-        if (var_G > 0.04045) {
-            var_G = Math.pow((var_G + 0.055) / 1.055, 2.4);
-        } else {
-            var_G = var_G / 12.92;
-        }
-        if (var_B > 0.04045) {
-            var_B = Math.pow((var_B + 0.055) / 1.055, 2.4);
-        } else {
-            var_B = var_B / 12.92;
-        }
+        // Pivot RGB:
+        var_R = unPivotRGB(var_R);
+        var_G = unPivotRGB(var_G);
+        var_B = unPivotRGB(var_B);
 
-        var_R = var_R * 100;
-        var_G = var_G * 100;
-        var_B = var_B * 100;
+        var_R *= 100;
+        var_G *= 100;
+        var_B *= 100;
 
         // Observer. = 2, Illuminant = D65
-        final double X = var_R * 0.4124 + var_G * 0.3576 + var_B * 0.1805;
-        final double Y = var_R * 0.2126 + var_G * 0.7152 + var_B * 0.0722;
-        final double Z = var_R * 0.0193 + var_G * 0.1192 + var_B * 0.9505;
+        // see: https://github.com/StanfordHCI/c3/blob/master/java/src/edu/stanford/vis/color/LAB.java
+        final double X = var_R * 0.4124564 + var_G * 0.3575761 + var_B * 0.1804375;
+        final double Y = var_R * 0.2126729 + var_G * 0.7151522 + var_B * 0.0721750;
+        final double Z = var_R * 0.0193339 + var_G * 0.1191920 + var_B * 0.9503041;
+
+        // final double X = var_R * 0.4124 + var_G * 0.3576 + var_B * 0.1805;
+        // final double Y = var_R * 0.2126 + var_G * 0.7152 + var_B * 0.0722;
+        // final double Z = var_R * 0.0193 + var_G * 0.1192 + var_B * 0.9505;","[{'comment': 'Was it intentionally commented, or left-overs from the development/testing?', 'commenter': 'kinow'}, {'comment': ""I left them over to make the change more apparent, since most sources just list the shorter value. If you like I will remove them. For the time being, I'll add a line of explanation.\r\n"", 'commenter': 'Brixomatic'}]"
114,src/main/java/org/apache/commons/imaging/color/ColorConversions.java,"@@ -747,4 +679,147 @@ public static ColorXyz convertCIELuvtoXYZ(final double L, final double u, final
 
         return new ColorXyz(X, Y, Z);
     }
+
+    public static ColorDIN99Lab convertCIELabToDIN99bLab(final ColorCieLab cie) {
+        return convertCIELabToDIN99bLab(cie.L, cie.a, cie.b);
+    }
+
+    public static ColorDIN99Lab convertCIELabToDIN99bLab(final double L, final double a, final double b) {
+        final double FAC_1 = 100.0 / Math.log(129.0 / 50.0); // = 105.51
+        final double kE = 1.0; // brightness factor, 1.0 for CIE reference conditions
+        final double kCH = 1.0; // chroma and hue factor, 1.0 for CIE reference conditions
+        final double ang = Math.toRadians(16.0);
+
+        final double L99 = kE * FAC_1 * Math.log(1. + 0.0158 * L);
+        double a99 = 0.0;
+        double b99 = 0.0;
+        if (a != 0.0 || b != 0.0) {
+            final double e = a * Math.cos(ang) + b * Math.sin(ang);
+            final double f = 0.7 * (b * Math.cos(ang) - a * Math.sin(ang));
+            final double G = Math.sqrt(e * e + f * f);
+            if (G != 0.) {
+                final double k = Math.log(1. + 0.045 * G) / (0.045 * kCH * kE * G);
+                a99 = k * e;
+                b99 = k * f;
+            }
+        }
+        return new ColorDIN99Lab(L99, a99, b99);
+    }
+
+    public static ColorCieLab convertDIN99bLabToCIELab(final ColorDIN99Lab dinb) {
+        return convertDIN99bLabToCIELab(dinb.L99, dinb.a99, dinb.b99);
+    }
+
+    public static ColorCieLab convertDIN99bLabToCIELab(final double L99b, final double a99b, final double b99b) {
+        final double kE = 1.0; // brightness factor, 1.0 for CIE reference conditions
+        final double kCH = 1.0; // chroma and hue factor, 1.0 for CIE reference conditions
+        final double FAC_1 = 100.0 / Math.log(129.0 / 50.0); // L99 scaling factor = 105.50867113783109
+        final double ang = Math.toRadians(16.0);
+
+        final double hef = Math.atan2(b99b, a99b);
+        final double C = Math.sqrt(a99b * a99b + b99b * b99b);
+        final double G = (Math.exp(0.045 * C * kCH * kE) - 1.0) / 0.045;
+        final double e = G * Math.cos(hef);
+        final double f = G * Math.sin(hef) / 0.7;
+
+        final double L = (Math.exp(L99b * kE / FAC_1) - 1.) / 0.0158;
+        final double a = e * Math.cos(ang) - f * Math.sin(ang);
+        final double b = e * Math.sin(ang) + f * Math.cos(ang);
+        return new ColorCieLab(L, a, b);
+    }
+
+    /** DIN99o, see: https://de.wikipedia.org/w/index.php?title=Diskussion:DIN99-Farbraum */","[{'comment': "":+1: \r\n\r\nThanks for keeping variables similar to the original text. With some machine translation from German to English, and following your code, I think I've managed to review these functions :-) "", 'commenter': 'kinow'}]"
114,src/main/java/org/apache/commons/imaging/color/ColorConversions.java,"@@ -747,4 +679,147 @@ public static ColorXyz convertCIELuvtoXYZ(final double L, final double u, final
 
         return new ColorXyz(X, Y, Z);
     }
+
+    public static ColorDIN99Lab convertCIELabToDIN99bLab(final ColorCieLab cie) {
+        return convertCIELabToDIN99bLab(cie.L, cie.a, cie.b);
+    }
+
+    public static ColorDIN99Lab convertCIELabToDIN99bLab(final double L, final double a, final double b) {
+        final double FAC_1 = 100.0 / Math.log(129.0 / 50.0); // = 105.51
+        final double kE = 1.0; // brightness factor, 1.0 for CIE reference conditions
+        final double kCH = 1.0; // chroma and hue factor, 1.0 for CIE reference conditions
+        final double ang = Math.toRadians(16.0);
+
+        final double L99 = kE * FAC_1 * Math.log(1. + 0.0158 * L);
+        double a99 = 0.0;
+        double b99 = 0.0;
+        if (a != 0.0 || b != 0.0) {
+            final double e = a * Math.cos(ang) + b * Math.sin(ang);
+            final double f = 0.7 * (b * Math.cos(ang) - a * Math.sin(ang));
+            final double G = Math.sqrt(e * e + f * f);
+            if (G != 0.) {
+                final double k = Math.log(1. + 0.045 * G) / (0.045 * kCH * kE * G);
+                a99 = k * e;
+                b99 = k * f;
+            }
+        }
+        return new ColorDIN99Lab(L99, a99, b99);
+    }
+
+    public static ColorCieLab convertDIN99bLabToCIELab(final ColorDIN99Lab dinb) {
+        return convertDIN99bLabToCIELab(dinb.L99, dinb.a99, dinb.b99);
+    }
+
+    public static ColorCieLab convertDIN99bLabToCIELab(final double L99b, final double a99b, final double b99b) {
+        final double kE = 1.0; // brightness factor, 1.0 for CIE reference conditions
+        final double kCH = 1.0; // chroma and hue factor, 1.0 for CIE reference conditions
+        final double FAC_1 = 100.0 / Math.log(129.0 / 50.0); // L99 scaling factor = 105.50867113783109
+        final double ang = Math.toRadians(16.0);
+
+        final double hef = Math.atan2(b99b, a99b);
+        final double C = Math.sqrt(a99b * a99b + b99b * b99b);
+        final double G = (Math.exp(0.045 * C * kCH * kE) - 1.0) / 0.045;
+        final double e = G * Math.cos(hef);
+        final double f = G * Math.sin(hef) / 0.7;
+
+        final double L = (Math.exp(L99b * kE / FAC_1) - 1.) / 0.0158;
+        final double a = e * Math.cos(ang) - f * Math.sin(ang);
+        final double b = e * Math.sin(ang) + f * Math.cos(ang);
+        return new ColorCieLab(L, a, b);
+    }
+
+    /** DIN99o, see: https://de.wikipedia.org/w/index.php?title=Diskussion:DIN99-Farbraum */
+    public static ColorDIN99Lab convertCIELabToDIN99oLab(final ColorCieLab cie) {
+        return convertCIELabToDIN99oLab(cie.L, cie.a, cie.b);
+    }
+
+    /** DIN99o, see: https://de.wikipedia.org/w/index.php?title=Diskussion:DIN99-Farbraum */
+    public static ColorDIN99Lab convertCIELabToDIN99oLab(final double L, final double a, final double b) {
+        final double kE = 1.0; // brightness factor, 1.0 for CIE reference conditions
+        final double kCH = 1.0; // chroma and hue factor, 1.0 for CIE reference conditions
+        final double FAC_1 = 100.0 / Math.log(139.0 / 100.0); // L99 scaling factor = 303.67100547050995
+        final double ang = Math.toRadians(26.0);
+
+        final double L99o = FAC_1 / kE * Math.log(1 + 0.0039 * L); // Lightness correction kE
+        double a99o = 0.0;
+        double b99o = 0.0;
+        if (a != 0.0 || b != 0.0) {
+            final double eo = a * Math.cos(ang) + b * Math.sin(ang); // a stretching
+            final double fo = 0.83 * (b * Math.cos(ang) - a * Math.sin(ang)); // b rotation/stretching
+            final double Go = Math.sqrt(eo * eo + fo * fo); // chroma
+            final double C99o = Math.log(1.0 + 0.075 * Go) / (0.0435 * kCH * kE); // factor for chroma compression and viewing conditions
+            final double heofo = Math.atan2(fo, eo); // arctan in four quadrants
+            final double h99o = heofo + ang; // hue rotation
+            a99o = C99o * Math.cos(h99o);
+            b99o = C99o * Math.sin(h99o);
+        }
+        return new ColorDIN99Lab(L99o, a99o, b99o);
+    }
+
+    /** DIN99o, see: https://de.wikipedia.org/w/index.php?title=Diskussion:DIN99-Farbraum */
+    public static ColorCieLab convertDIN99oLabToCIELab(final ColorDIN99Lab dino) {
+        return convertDIN99oLabToCIELab(dino.L99, dino.a99, dino.b99);
+    }
+
+    /** DIN99o, see: https://de.wikipedia.org/w/index.php?title=Diskussion:DIN99-Farbraum */
+    public static ColorCieLab convertDIN99oLabToCIELab(final double L99o, final double a99o, final double b99o) {
+        final double kE = 1.0; // brightness factor, 1.0 for CIE reference conditions
+        final double kCH = 1.0; // chroma and hue factor, 1.0 for CIE reference conditions
+        final double FAC_1 = 100.0 / Math.log(139.0 / 100.0); // L99 scaling factor = 303.67100547050995
+        final double ang = Math.toRadians(26.0);
+
+        final double L = (Math.exp(L99o * kE / FAC_1) - 1.0) / 0.0039;
+
+        final double h99ef = Math.atan2(b99o, a99o); // arctan in four quadrants
+
+        final double heofo = h99ef - ang; // backwards hue rotation
+
+        final double C99 = Math.sqrt(a99o * a99o + b99o * b99o); // DIN99 chroma
+        final double G = (Math.exp(0.0435 * kE * kCH * C99) - 1.0) / 0.075; // factor for chroma decompression and viewing conditions
+        final double e = G * Math.cos(heofo);
+        final double f = G * Math.sin(heofo);
+
+        final double a = e * Math.cos(ang) - f / 0.83 * Math.sin(ang); // rotation by 26 degrees
+        final double b = e * Math.sin(ang) + f / 0.83 * Math.cos(ang); // rotation by 26 degrees
+
+        return new ColorCieLab(L, a, b);
+    }
+
+    private static double pivotRGB(double n) {
+        if (n > 0.0031308) {
+            n = 1.055 * Math.pow(n, 1 / 2.4) - 0.055;
+        } else {
+            n = 12.92 * n;
+        }
+        return n;
+    }
+
+    private static double unPivotRGB(double n) {
+        if (n > 0.04045) {
+            n = Math.pow((n + 0.055) / 1.055, 2.4);
+        } else {
+            n = n / 12.92;
+        }
+        return n;
+    }
+
+    private static double pivotXYZ(double n) {
+        if (n > XYZ_t0) {
+            n = Math.pow(n, 1 / 3.0);
+        } else {
+            n = XYZ_m * n + 16 / 116.0;
+        }
+        return n;
+    }
+
+    private static double unPivotXYZ(double n) {
+        final double nCube = Math.pow(n, 3);
+        if (nCube > XYZ_t0) {
+            n = nCube;
+        } else {
+            n = (n - 16 / 116.0) / XYZ_m;
+        }
+        return n;","[{'comment': 'These functions here are removing **a lot** of duplicate code. Thanks for tidying it up.', 'commenter': 'kinow'}]"
135,src/main/java/org/apache/commons/imaging/palette/ColorSpaceSubset.java,"@@ -24,8 +24,8 @@
 
     private static final Logger LOGGER = Logger.getLogger(ColorSpaceSubset.class.getName());
 
-    final int[] mins;
-    final int[] maxs;
+    final int[] min;
+    final int[] max;","[{'comment': 'I think these were supposed to be arrays with minimums and maximums. It\'s common to use the ""maximums"" or ""minimums"" as the ""locals minimums"" for example. So `mins` is a better variable name IMO, so that without seeing the type you know it\'s an array (especially given it\'s in a class related to color space).', 'commenter': 'kinow'}, {'comment': 'HI @kinow \r\nSounds logical. Changed\r\nTY', 'commenter': 'arturobernalg'}]"
135,src/main/java/org/apache/commons/imaging/formats/tiff/constants/MicrosoftHdPhotoTagConstants.java,"@@ -152,17 +152,17 @@
     public static final BinaryConstant PIXEL_FORMAT_VALUE_32_BIT_GRAY_FIXED_POINT =
             createMicrosoftHdPhotoGuidEndingWith((byte) 0x3f);
 
-    public static final TagInfoLong EXIF_TAG_TRANSFOMATION = new TagInfoLong(
-            ""Transfomation"", 0xbc02,
+    public static final TagInfoLong EXIF_TAG_TRANSFORMATION = new TagInfoLong(
+            ""Transformation"", 0xbc02,
             TiffDirectoryType.EXIF_DIRECTORY_UNKNOWN);
-    public static final int TRANSFOMATION_VALUE_HORIZONTAL_NORMAL = 0;
-    public static final int TRANSFOMATION_VALUE_MIRROR_VERTICAL = 1;
-    public static final int TRANSFOMATION_VALUE_MIRROR_HORIZONTAL = 2;
-    public static final int TRANSFOMATION_VALUE_ROTATE_180 = 3;
-    public static final int TRANSFOMATION_VALUE_ROTATE_90_CW = 4;
-    public static final int TRANSFOMATION_VALUE_MIRROR_HORIZONTAL_AND_ROTATE_90_CW = 5;
-    public static final int TRANSFOMATION_VALUE_MIRROR_HORIZONTAL_AND_ROTATE_270_CW = 6;
-    public static final int TRANSFOMATION_VALUE_ROTATE_270_CW = 7;
+    public static final int TRANSFORMATION_VALUE_HORIZONTAL_NORMAL = 0;
+    public static final int TRANSFORMATION_VALUE_MIRROR_VERTICAL = 1;
+    public static final int TRANSFORMATION_VALUE_MIRROR_HORIZONTAL = 2;
+    public static final int TRANSFORMATION_VALUE_ROTATE_180 = 3;
+    public static final int TRANSFORMATION_VALUE_ROTATE_90_CW = 4;
+    public static final int TRANSFORMATION_VALUE_MIRROR_HORIZONTAL_AND_ROTATE_90_CW = 5;
+    public static final int TRANSFORMATION_VALUE_MIRROR_HORIZONTAL_AND_ROTATE_270_CW = 6;
+    public static final int TRANSFORMATION_VALUE_ROTATE_270_CW = 7;","[{'comment': 'Ouch! Good catch! Thanks', 'commenter': 'kinow'}, {'comment': ';) just was lucky. I was checking the variable in general', 'commenter': 'arturobernalg'}]"
135,src/main/java/org/apache/commons/imaging/palette/ColorSpaceSubset.java,"@@ -49,11 +49,11 @@
         rgb = -1;
     }
 
-    ColorSpaceSubset(final int total, final int precision, final int[] mins, final int[] maxs) {
+    ColorSpaceSubset(final int total, final int precision, final int[] min, final int[] max) {
         this.total = total;
         this.precision = precision;
-        this.mins = mins;
-        this.maxs = maxs;
+        this.mins = min;
+        this.maxs = max;","[{'comment': 'mins & maxs  ', 'commenter': 'kinow'}, {'comment': 'mmm, true.  sorry. changed ', 'commenter': 'arturobernalg'}, {'comment': ""Thanks for fixing these so quickly @arturobernalg ! I will have to merge it tomorrow morning as I'm in a different notebook  "", 'commenter': 'kinow'}, {'comment': 'thanks men ', 'commenter': 'arturobernalg'}]"
165,src/test/java/org/apache/commons/imaging/formats/tiff/TiffShortIntRoundTripTest.java,"@@ -0,0 +1,229 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.imaging.formats.tiff;
+
+import static org.junit.jupiter.api.Assertions.assertEquals;
+
+import java.awt.image.BufferedImage;","[{'comment': 'Not used.', 'commenter': 'kinow'}, {'comment': 'added a new test that uses it.', 'commenter': 'gwlucastrig'}]"
165,src/main/java/org/apache/commons/imaging/formats/tiff/TiffImageParser.java,"@@ -762,12 +763,12 @@ public void writeImage(final BufferedImage src, final OutputStream os, final Map
     }
 
     /**
-     * Reads the content of a TIFF file that contains floating-point data
-     * samples.
+     * Reads the content of a TIFF file that contains numerical data samples
+     * rather than image-related pixels.
      * <p>
-     * If desired, sub-image data can be read from the file by using a Java Map
-     * instance to specify the subsection of the image that is required. The
-     * following code illustrates the approach:
+     * If desired, sub-image data can be read from the file by using a Java
+     * {@code Map} instance to specify the subsection of the image that
+     * isrequired. The following code illustrates the approach:","[{'comment': 's/isrequired/is required?', 'commenter': 'kinow'}, {'comment': 'done', 'commenter': 'gwlucastrig'}]"
165,src/test/java/org/apache/commons/imaging/formats/tiff/TiffRasterDataIntTest.java,"@@ -0,0 +1,203 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.imaging.formats.tiff;
+
+import static org.junit.jupiter.api.Assertions.assertArrayEquals;
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.fail;
+
+import org.junit.jupiter.api.Test;
+
+/**
+ * Provides unit test for the raster-data class.
+ */
+public class TiffRasterDataIntTest {
+
+    int width = 11;
+    int height = 10;
+    int[] data;
+    TiffRasterData raster;
+    float meanValue;
+
+    public TiffRasterDataIntTest() {
+        double sum = 0;
+        data = new int[width * height];
+        int k = 0;
+        for (int i = 0; i < width; i++) {
+            for (int j = 0; j < height; j++) {
+                data[k] = (int)k;
+                sum += k;
+                k++;
+            }
+        }
+        raster = new TiffRasterDataInt(width, height, data);
+        meanValue = (float) (sum / k);
+    }
+
+    /**
+     * Test of setValue method, of class TiffRasterData.
+     */
+    @Test
+    public void testSetValue() {
+        final TiffRasterData instance = new TiffRasterDataInt(width, height);
+        for (int y = 0; y < height; y++) {
+            for (int x = 0; x < width; x++) {
+                final int index = y * width + height;
+                instance.setValue(x, y, index+0.4f);
+                int test = (int) instance.getValue(x, y);
+                assertEquals(index, test, ""Set/get value test failed"");
+				instance.setIntValue(x, y, index);
+                test = (int) instance.getIntValue(x, y);","[{'comment': 'Unnecessary casting.', 'commenter': 'kinow'}, {'comment': 'done', 'commenter': 'gwlucastrig'}]"
165,src/test/java/org/apache/commons/imaging/formats/tiff/TiffRasterDataIntTest.java,"@@ -0,0 +1,203 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.imaging.formats.tiff;
+
+import static org.junit.jupiter.api.Assertions.assertArrayEquals;
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.fail;
+
+import org.junit.jupiter.api.Test;
+
+/**
+ * Provides unit test for the raster-data class.
+ */
+public class TiffRasterDataIntTest {
+
+    int width = 11;
+    int height = 10;
+    int[] data;
+    TiffRasterData raster;
+    float meanValue;
+
+    public TiffRasterDataIntTest() {
+        double sum = 0;
+        data = new int[width * height];
+        int k = 0;
+        for (int i = 0; i < width; i++) {
+            for (int j = 0; j < height; j++) {
+                data[k] = (int)k;","[{'comment': 'Unnecessary casting.', 'commenter': 'kinow'}, {'comment': 'done', 'commenter': 'gwlucastrig'}]"
165,src/test/java/org/apache/commons/imaging/formats/tiff/TiffRasterDataIntTest.java,"@@ -0,0 +1,203 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.imaging.formats.tiff;
+
+import static org.junit.jupiter.api.Assertions.assertArrayEquals;
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.fail;
+
+import org.junit.jupiter.api.Test;
+
+/**
+ * Provides unit test for the raster-data class.
+ */
+public class TiffRasterDataIntTest {
+
+    int width = 11;
+    int height = 10;
+    int[] data;
+    TiffRasterData raster;
+    float meanValue;
+
+    public TiffRasterDataIntTest() {
+        double sum = 0;
+        data = new int[width * height];
+        int k = 0;
+        for (int i = 0; i < width; i++) {
+            for (int j = 0; j < height; j++) {
+                data[k] = (int)k;
+                sum += k;
+                k++;
+            }
+        }
+        raster = new TiffRasterDataInt(width, height, data);
+        meanValue = (float) (sum / k);
+    }
+
+    /**
+     * Test of setValue method, of class TiffRasterData.
+     */
+    @Test
+    public void testSetValue() {
+        final TiffRasterData instance = new TiffRasterDataInt(width, height);
+        for (int y = 0; y < height; y++) {
+            for (int x = 0; x < width; x++) {
+                final int index = y * width + height;
+                instance.setValue(x, y, index+0.4f);
+                int test = (int) instance.getValue(x, y);
+                assertEquals(index, test, ""Set/get value test failed"");
+				instance.setIntValue(x, y, index);
+                test = (int) instance.getIntValue(x, y);
+                assertEquals(index, test, ""Set/get int value test failed"");
+            }
+        }
+    }
+
+    /**
+     * Test of getValue method, of class TiffRasterData.
+     */
+    @Test
+    public void testGetValue() {
+        for (int y = 0; y < height; y++) {
+            for (int x = 0; x < width; x++) {
+                final int index = y * width + x;
+                int test = (int) raster.getValue(x, y);
+                assertEquals(index, test, ""Get into source data test failed at ("" + x + "","" + y + "")"");
+                test = (int) raster.getIntValue(x, y);","[{'comment': 'Unnecessary casting.', 'commenter': 'kinow'}, {'comment': 'done', 'commenter': 'gwlucastrig'}]"
165,src/test/java/org/apache/commons/imaging/formats/tiff/TiffRasterDataIntTest.java,"@@ -0,0 +1,203 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.imaging.formats.tiff;
+
+import static org.junit.jupiter.api.Assertions.assertArrayEquals;
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.fail;
+
+import org.junit.jupiter.api.Test;
+
+/**
+ * Provides unit test for the raster-data class.
+ */
+public class TiffRasterDataIntTest {
+
+    int width = 11;
+    int height = 10;
+    int[] data;
+    TiffRasterData raster;
+    float meanValue;
+
+    public TiffRasterDataIntTest() {
+        double sum = 0;
+        data = new int[width * height];
+        int k = 0;
+        for (int i = 0; i < width; i++) {
+            for (int j = 0; j < height; j++) {
+                data[k] = (int)k;
+                sum += k;
+                k++;
+            }
+        }
+        raster = new TiffRasterDataInt(width, height, data);
+        meanValue = (float) (sum / k);
+    }
+
+    /**
+     * Test of setValue method, of class TiffRasterData.
+     */
+    @Test
+    public void testSetValue() {
+        final TiffRasterData instance = new TiffRasterDataInt(width, height);
+        for (int y = 0; y < height; y++) {
+            for (int x = 0; x < width; x++) {
+                final int index = y * width + height;
+                instance.setValue(x, y, index+0.4f);
+                int test = (int) instance.getValue(x, y);
+                assertEquals(index, test, ""Set/get value test failed"");
+				instance.setIntValue(x, y, index);
+                test = (int) instance.getIntValue(x, y);
+                assertEquals(index, test, ""Set/get int value test failed"");
+            }
+        }
+    }
+
+    /**
+     * Test of getValue method, of class TiffRasterData.
+     */
+    @Test
+    public void testGetValue() {
+        for (int y = 0; y < height; y++) {
+            for (int x = 0; x < width; x++) {
+                final int index = y * width + x;
+                int test = (int) raster.getValue(x, y);
+                assertEquals(index, test, ""Get into source data test failed at ("" + x + "","" + y + "")"");
+                test = (int) raster.getIntValue(x, y);
+                assertEquals(index, test, ""Get into source data test failed at ("" + x + "","" + y + "")"");
+            }
+        }
+    }
+
+    /**
+     * Test of getSimpleStatistics method, of class TiffRasterData.
+     */
+    @Test
+    public void testGetSimpleStatistics_0args() {
+
+        final TiffRasterStatistics result = raster.getSimpleStatistics();
+        assertEquals(0, result.getMinValue(), ""Min value failure"");
+        assertEquals(width * height - 1, result.getMaxValue(), ""Max value failure"");
+        assertEquals(meanValue, result.getMeanValue(), ""Mean value failure"");
+    }
+
+    /**
+     * Test of getSimpleStatistics method, of class TiffRasterData.
+     */
+    @Test
+    public void testGetSimpleStatistics_float() {
+        // exclude the maximum value (width*height-1).  This will result
+        // in a max value of width*height-2
+        final TiffRasterStatistics result = raster.getSimpleStatistics(width * height - 1);
+        assertEquals(width * height - 2, result.getMaxValue(), ""Max value failure"");
+    }
+
+    /**
+     * Test of getWidth method, of class TiffRasterData.
+     */
+    @Test
+    public void testGetWidth() {
+        assertEquals(width, raster.getWidth(), ""Improper width stored"");
+    }
+
+    /**
+     * Test of getHeight method, of class TiffRasterData.
+     */
+    @Test
+    public void testGetHeight() {
+        assertEquals(width, raster.getWidth(), ""Improper height stored"");
+    }
+
+    /**
+     * Test of getData method, of class TiffRasterData.
+     */
+    @Test
+    public void testGetData() {
+        final float[] result = raster.getData();
+		for(int i=0; i<result.length; i++){
+			assertEquals((int)result[i], data[i]);
+		}
+		final int []iResult = raster.getIntData();
+        assertArrayEquals(data, iResult);
+    }
+
+
+     /**
+     * Test of constructors with bad arguments, of class TiffRasterData.
+     */
+    @Test
+    public void testBadConstructor() {
+        try{
+            final TiffRasterData raster = new TiffRasterDataInt(-1, 10);
+            fail(""Constructor did not detect bad width"");
+        }catch(final IllegalArgumentException illArgEx){
+            // success!
+        }","[{'comment': '@gwlucastrig I believe the tests that are using this pattern `try { something; fail(); } catch {}` is JUnit 4. But for Junit 5 we can use:\r\n\r\n```java\r\nassertThrows(IllegalArgumentException.class, () -> new TiffRasterDataInt(-1, 10));\r\n``` \r\n\r\nThere are other places in this PR where this can be applied, you can look at GitHub\'s UI to search for this ""fail("" text if you\'d like.', 'commenter': 'kinow'}, {'comment': 'done', 'commenter': 'gwlucastrig'}]"
165,src/test/java/org/apache/commons/imaging/formats/tiff/TiffRasterDataIntTest.java,"@@ -0,0 +1,203 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.imaging.formats.tiff;
+
+import static org.junit.jupiter.api.Assertions.assertArrayEquals;
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.fail;
+
+import org.junit.jupiter.api.Test;
+
+/**
+ * Provides unit test for the raster-data class.
+ */
+public class TiffRasterDataIntTest {
+
+    int width = 11;
+    int height = 10;
+    int[] data;
+    TiffRasterData raster;
+    float meanValue;
+
+    public TiffRasterDataIntTest() {
+        double sum = 0;
+        data = new int[width * height];
+        int k = 0;
+        for (int i = 0; i < width; i++) {
+            for (int j = 0; j < height; j++) {
+                data[k] = (int)k;
+                sum += k;
+                k++;
+            }
+        }
+        raster = new TiffRasterDataInt(width, height, data);
+        meanValue = (float) (sum / k);
+    }
+
+    /**
+     * Test of setValue method, of class TiffRasterData.
+     */
+    @Test
+    public void testSetValue() {
+        final TiffRasterData instance = new TiffRasterDataInt(width, height);
+        for (int y = 0; y < height; y++) {
+            for (int x = 0; x < width; x++) {
+                final int index = y * width + height;
+                instance.setValue(x, y, index+0.4f);
+                int test = (int) instance.getValue(x, y);
+                assertEquals(index, test, ""Set/get value test failed"");
+				instance.setIntValue(x, y, index);
+                test = (int) instance.getIntValue(x, y);
+                assertEquals(index, test, ""Set/get int value test failed"");
+            }
+        }
+    }
+
+    /**
+     * Test of getValue method, of class TiffRasterData.
+     */
+    @Test
+    public void testGetValue() {
+        for (int y = 0; y < height; y++) {
+            for (int x = 0; x < width; x++) {
+                final int index = y * width + x;
+                int test = (int) raster.getValue(x, y);
+                assertEquals(index, test, ""Get into source data test failed at ("" + x + "","" + y + "")"");
+                test = (int) raster.getIntValue(x, y);
+                assertEquals(index, test, ""Get into source data test failed at ("" + x + "","" + y + "")"");
+            }
+        }
+    }
+
+    /**
+     * Test of getSimpleStatistics method, of class TiffRasterData.
+     */
+    @Test
+    public void testGetSimpleStatistics_0args() {
+
+        final TiffRasterStatistics result = raster.getSimpleStatistics();
+        assertEquals(0, result.getMinValue(), ""Min value failure"");
+        assertEquals(width * height - 1, result.getMaxValue(), ""Max value failure"");
+        assertEquals(meanValue, result.getMeanValue(), ""Mean value failure"");
+    }
+
+    /**
+     * Test of getSimpleStatistics method, of class TiffRasterData.
+     */
+    @Test
+    public void testGetSimpleStatistics_float() {
+        // exclude the maximum value (width*height-1).  This will result
+        // in a max value of width*height-2
+        final TiffRasterStatistics result = raster.getSimpleStatistics(width * height - 1);
+        assertEquals(width * height - 2, result.getMaxValue(), ""Max value failure"");
+    }
+
+    /**
+     * Test of getWidth method, of class TiffRasterData.
+     */
+    @Test
+    public void testGetWidth() {
+        assertEquals(width, raster.getWidth(), ""Improper width stored"");
+    }
+
+    /**
+     * Test of getHeight method, of class TiffRasterData.
+     */
+    @Test
+    public void testGetHeight() {
+        assertEquals(width, raster.getWidth(), ""Improper height stored"");
+    }
+
+    /**
+     * Test of getData method, of class TiffRasterData.
+     */
+    @Test
+    public void testGetData() {
+        final float[] result = raster.getData();
+		for(int i=0; i<result.length; i++){
+			assertEquals((int)result[i], data[i]);
+		}
+		final int []iResult = raster.getIntData();
+        assertArrayEquals(data, iResult);","[{'comment': ""Tabs and spaces here @gwlucastrig :point_up: (better confirm other files don't have tabs, only spotted it here due to the lines not aligned due to mix spaces/tabs, but we could have in the other files)."", 'commenter': 'kinow'}, {'comment': 'Did a search through the code space.  These are the files that contain tabs\r\nI will fix TiffRasterDataIntTest.java as part of the PR.\r\n\r\n\\test\\java\\org\\apache\\commons\\imaging\\formats\\icns\\IcnsReadTest.java (20 hits)\r\n\\test\\java\\org\\apache\\commons\\imaging\\formats\\png\\PngWithInvalidPngChunkSizeTest.java (20 hits)\r\n\\test\\java\\org\\apache\\commons\\imaging\\formats\\tiff\\TiffRasterDataIntTest.java (13 hits)\r\n\\test\\java\\org\\apache\\commons\\imaging\\TestImageReadException.java (18 hits)\r\n\\test\\java\\org\\apache\\commons\\imaging\\TestImageWriteException.java (80 hits)\r\n ', 'commenter': 'gwlucastrig'}]"
165,src/main/java/org/apache/commons/imaging/formats/tiff/datareaders/ImageDataReader.java,"@@ -519,8 +516,55 @@ protected void applyPredictorToBlock(final int width, final int height, final in
         return samples;
     }
 
+    protected int[] unpackIntSamples(
+        final int width,
+        final int height,
+        final int scansize,
+        final byte[] bytes,
+        final int predictor,
+        final int bitsPerSample,
+        final ByteOrder byteOrder)
+        throws ImageReadException {","[{'comment': '`ImageReadException` never thrown, I think we can remove it from here.', 'commenter': 'kinow'}, {'comment': 'done', 'commenter': 'gwlucastrig'}]"
165,src/main/java/org/apache/commons/imaging/formats/tiff/datareaders/ImageDataReader.java,"@@ -519,8 +516,55 @@ protected void applyPredictorToBlock(final int width, final int height, final in
         return samples;
     }
 
+    protected int[] unpackIntSamples(","[{'comment': 'Javadoc comment, documenting this new method?', 'commenter': 'kinow'}, {'comment': 'done', 'commenter': 'gwlucastrig'}]"
165,src/main/java/org/apache/commons/imaging/formats/tiff/datareaders/ImageDataReader.java,"@@ -602,6 +646,87 @@ void transferBlockToRaster(final int xBlock, final int yBlock,
         }
     }
 
+    /**
+     * Transfer samples obtained from the TIFF file to an integer raster.
+     * @param xBlock coordinate of block relative to source data
+     * @param yBlock coordinate of block relative to source data
+     * @param blockWidth width of block, in pixels
+     * @param blockHeight height of block in pixels
+     * @param blockData the data for the block
+     * @param xRaster coordinate of raster relative to source data
+     * @param yRaster coordinate of raster relative to source data
+     * @param rasterWidth width of the raster (always smaller than source data)
+     * @param rasterHeight height of the raster (always smaller than source
+     * data)
+     * @param rasterData the raster data.
+     */
+    void transferBlockToRaster(final int xBlock, final int yBlock,
+        final int blockWidth, final int blockHeight, final int[] blockData,
+        final int xRaster, final int yRaster,
+        final int rasterWidth, final int rasterHeight, final int[] rasterData) {
+
+        // xR0, yR0 are the coordinates within the raster (upper-left corner)
+        // xR1, yR1 are ONE PAST the coordinates of the lower-right corner
+        int xR0 = xBlock - xRaster;  // xR0, yR0 coordinates relative to
+        int yR0 = yBlock - yRaster; // the raster
+        int xR1 = xR0 + blockWidth;
+        int yR1 = yR0 + blockHeight;
+        if (xR0 < 0) {
+            xR0 = 0;
+        }
+        if (yR0 < 0) {
+            yR0 = 0;
+        }
+        if (xR1 > rasterWidth) {
+            xR1 = rasterWidth;
+        }
+        if (yR1 > rasterHeight) {
+            yR1 = rasterHeight;
+        }
+
+        // Recall that the above logic may have adjusted xR0, xY0 so that
+        // they are not necessarily point to the source pixel at xRaster, yRaster
+        // we compute xSource = xR0+xRaster.
+        //            xOffset = xSource-xBlock
+        // since the block cannot be accessed with a negative offset,
+        // we check for negatives and adjust xR0, yR0 upward as necessary
+        int xB0 = xR0 + xRaster - xBlock;
+        int yB0 = yR0 + yRaster - yBlock;
+        if (xB0 < 0) {
+            xR0 -= xB0;
+            xB0 = 0;
+        }
+        if (yB0 < 0) {
+            yR0 -= yB0;
+            yB0 = 0;
+        }
+
+        int w = xR1 - xR0;
+        int h = yR1 - yR0;
+        if (w <= 0 || h <= 0) {
+            // The call to this method put the block outside the","[{'comment': 's/put/puts?', 'commenter': 'kinow'}]"
165,src/main/java/org/apache/commons/imaging/formats/tiff/datareaders/DataReaderTiled.java,"@@ -286,7 +288,20 @@ public ImageBuilder readImageData(final Rectangle subImageSpecification,
 
     @Override
     public TiffRasterData readRasterData(final Rectangle subImage)
-        throws ImageReadException, IOException {
+            throws ImageReadException, IOException {
+        switch (sampleFormat) {
+            case TiffTagConstants.SAMPLE_FORMAT_VALUE_IEEE_FLOATING_POINT:","[{'comment': ""Code is excellent here @gwlucastrig , but out of curiosity, do you know why we have `SAMPLE_FORMAT_VALUE_IEEE_FLOATING_POINT` and `SAMPLE_FORMAT_VALUE_IEEE_FLOATING_POINT_1`? That's probably from the specification, but since we don't have any javadocs in the constants I can't recall the reason for it."", 'commenter': 'kinow'}, {'comment': 'It took a bit of searching to find what this is about.\r\n\r\n    public static final int SAMPLE_FORMAT_VALUE_COMPLEX_INTEGER = 5;\r\n    public static final int SAMPLE_FORMAT_VALUE_IEEE_FLOATING_POINT_1 = 6;\r\n\r\nSample formats 5 (complex integer) and 6 (complex float) are not actually part of the TIFF spec, but seem to have been introduced by LibTIFF at some point.  There is no support for complex-conjugate-pairs in Commons Imaging at this time. Neither of these values are used elsewhere in the the code.\r\n\r\nAt the very least, I will rename FLOATING_POINT_1 to be COMPLEX_FLOAT.\r\n\r\nYou can read more at\r\n\r\n[Extension TIFF Tag Sample Format](https://www.awaresystems.be/imaging/tiff/tifftags/sampleformat.html)', 'commenter': 'gwlucastrig'}]"
165,src/main/java/org/apache/commons/imaging/formats/tiff/datareaders/DataReaderTiled.java,"@@ -321,19 +336,68 @@ public TiffRasterData readRasterData(final Rectangle subImage)
                 final int tile = iRow * nColumnsOfTiles + iCol;
                 final byte[] compressed = imageData.tiles[tile].getData();
                 final byte[] decompressed = decompress(compressed, compression,
-                    bytesPerTile, tileWidth, tileLength);
+                        bytesPerTile, tileWidth, tileLength);
                 final int x = iCol * tileWidth;
                 final int y = iRow * tileLength;
+
                 final int[] blockData = unpackFloatingPointSamples(
-                    tileWidth, tileLength, tileWidth,
-                    decompressed,
-                    predictor, bitsPerPixel, byteOrder);
+                        tileWidth, tileLength, tileWidth,
+                        decompressed,
+                        predictor, bitsPerPixel, byteOrder);
                 transferBlockToRaster(x, y, tileWidth, tileLength, blockData,
-                    xRaster, yRaster, rasterWidth, rasterHeight, rasterData);
+                        xRaster, yRaster, rasterWidth, rasterHeight, rasterDataFloat);
             }
         }
-
-        return new TiffRasterData(rasterWidth, rasterHeight, rasterData);
+        return new TiffRasterDataFloat(rasterWidth, rasterHeight, rasterDataFloat);
     }
 
+    private TiffRasterData readRasterDataInt(final Rectangle subImage)
+            throws ImageReadException, IOException {
+        final int bitsPerRow = tileWidth * bitsPerPixel;
+        final int bytesPerRow = (bitsPerRow + 7) / 8;
+        final int bytesPerTile = bytesPerRow * tileLength;
+        int xRaster;
+        int yRaster;
+        int rasterWidth;
+        int rasterHeight;
+        if (subImage != null) {
+            xRaster = subImage.x;
+            yRaster = subImage.y;
+            rasterWidth = subImage.width;
+            rasterHeight = subImage.height;
+        } else {
+            xRaster = 0;
+            yRaster = 0;
+            rasterWidth = width;
+            rasterHeight = height;
+        }
+        int[] rasterDataInt = new int[rasterWidth * rasterHeight];
+
+        // tileWidth is the width of the tile
+        // tileLength is the height of the tile
+        final int col0 = xRaster / tileWidth;
+        final int col1 = (xRaster + rasterWidth - 1) / tileWidth;
+        final int row0 = yRaster / tileLength;
+        final int row1 = (yRaster + rasterHeight - 1) / tileLength;","[{'comment': ""Unrelated to this change too, but `tileLength`... shouldn't it be `tileHeight`?"", 'commenter': 'kinow'}, {'comment': 'Actually, tile length is what they call it in the TIFFF specification.  Not sure they used that term, though it might be a holdover from the earlier terminology strip-length. \r\n\r\nIn either case, I think we should leave this one as is...', 'commenter': 'gwlucastrig'}]"
165,src/main/java/org/apache/commons/imaging/formats/tiff/datareaders/DataReaderStrips.java,"@@ -390,16 +405,69 @@ public TiffRasterData readRasterData(final Rectangle subImage)
 
             final byte[] compressed = imageData.getImageData(strip).getData();
             final byte[] decompressed = decompress(compressed, compression,
-                bytesPerStrip, width, rowsInThisStrip);
+                    bytesPerStrip, width, rowsInThisStrip);
 
             final int[] blockData = unpackFloatingPointSamples(
-                width, (int) rowsInThisStrip, width,
-                decompressed,
-                predictor, bitsPerPixel, byteOrder);
+                    width,
+                    (int) rowsInThisStrip,","[{'comment': 'Unnecessary casting.', 'commenter': 'kinow'}, {'comment': 'done', 'commenter': 'gwlucastrig'}]"
165,src/main/java/org/apache/commons/imaging/formats/tiff/datareaders/DataReaderStrips.java,"@@ -390,16 +405,69 @@ public TiffRasterData readRasterData(final Rectangle subImage)
 
             final byte[] compressed = imageData.getImageData(strip).getData();
             final byte[] decompressed = decompress(compressed, compression,
-                bytesPerStrip, width, rowsInThisStrip);
+                    bytesPerStrip, width, rowsInThisStrip);
 
             final int[] blockData = unpackFloatingPointSamples(
-                width, (int) rowsInThisStrip, width,
-                decompressed,
-                predictor, bitsPerPixel, byteOrder);
+                    width,
+                    (int) rowsInThisStrip,
+                    width,
+                    decompressed,
+                    predictor, bitsPerPixel, byteOrder);
             transferBlockToRaster(0, yStrip, width, (int) rowsInThisStrip, blockData,","[{'comment': 'Also unnecessary casting, but not in this PR.', 'commenter': 'kinow'}]"
165,src/main/java/org/apache/commons/imaging/formats/tiff/datareaders/DataReaderStrips.java,"@@ -390,16 +405,69 @@ public TiffRasterData readRasterData(final Rectangle subImage)
 
             final byte[] compressed = imageData.getImageData(strip).getData();
             final byte[] decompressed = decompress(compressed, compression,
-                bytesPerStrip, width, rowsInThisStrip);
+                    bytesPerStrip, width, rowsInThisStrip);
 
             final int[] blockData = unpackFloatingPointSamples(
-                width, (int) rowsInThisStrip, width,
-                decompressed,
-                predictor, bitsPerPixel, byteOrder);
+                    width,
+                    (int) rowsInThisStrip,
+                    width,
+                    decompressed,
+                    predictor, bitsPerPixel, byteOrder);
             transferBlockToRaster(0, yStrip, width, (int) rowsInThisStrip, blockData,
-                xRaster, yRaster, rasterWidth, rasterHeight, rasterData);
+                    xRaster, yRaster, rasterWidth, rasterHeight, rasterDataFloat);
         }
-        return new TiffRasterData(rasterWidth, rasterHeight, rasterData);
+        return new TiffRasterDataFloat(rasterWidth, rasterHeight, rasterDataFloat);
     }
 
+    private TiffRasterData readRasterDataInt(final Rectangle subImage)
+            throws ImageReadException, IOException {
+        int xRaster;
+        int yRaster;
+        int rasterWidth;
+        int rasterHeight;
+        if (subImage != null) {
+            xRaster = subImage.x;
+            yRaster = subImage.y;
+            rasterWidth = subImage.width;
+            rasterHeight = subImage.height;
+        } else {
+            xRaster = 0;
+            yRaster = 0;
+            rasterWidth = width;
+            rasterHeight = height;
+        }
+
+        int[] rasterDataInt = new int[rasterWidth * rasterHeight];
+
+        // the legacy code is optimized to the reading of whole
+        // strips (except for the last strip in the image, which can
+        // be a partial).  So create a working image with compatible
+        // dimensions and read that.  Later on, the working image
+        // will be sub-imaged to the proper size.
+        // strip0 and strip1 give the indices of the strips containing
+        // the first and last rows of pixels in the subimage
+        final int strip0 = yRaster / rowsPerStrip;
+        final int strip1 = (yRaster + rasterHeight - 1) / rowsPerStrip;
+
+        for (int strip = strip0; strip <= strip1; strip++) {
+            final int yStrip = strip * rowsPerStrip;
+            final int rowsRemaining = height - yStrip;
+            final int rowsInThisStrip = Math.min(rowsRemaining, rowsPerStrip);
+            final int bytesPerRow = (bitsPerPixel * width + 7) / 8;
+            final int bytesPerStrip = rowsInThisStrip * bytesPerRow;
+
+            final byte[] compressed = imageData.getImageData(strip).getData();
+            final byte[] decompressed = decompress(compressed, compression,
+                    bytesPerStrip, width, rowsInThisStrip);
+            final int[] blockData = unpackIntSamples(
+                    width,
+                    (int) rowsInThisStrip,","[{'comment': 'Unnecessary casting.', 'commenter': 'kinow'}, {'comment': 'done', 'commenter': 'gwlucastrig'}]"
165,src/main/java/org/apache/commons/imaging/formats/tiff/datareaders/DataReaderStrips.java,"@@ -390,16 +405,69 @@ public TiffRasterData readRasterData(final Rectangle subImage)
 
             final byte[] compressed = imageData.getImageData(strip).getData();
             final byte[] decompressed = decompress(compressed, compression,
-                bytesPerStrip, width, rowsInThisStrip);
+                    bytesPerStrip, width, rowsInThisStrip);
 
             final int[] blockData = unpackFloatingPointSamples(
-                width, (int) rowsInThisStrip, width,
-                decompressed,
-                predictor, bitsPerPixel, byteOrder);
+                    width,
+                    (int) rowsInThisStrip,
+                    width,
+                    decompressed,
+                    predictor, bitsPerPixel, byteOrder);
             transferBlockToRaster(0, yStrip, width, (int) rowsInThisStrip, blockData,
-                xRaster, yRaster, rasterWidth, rasterHeight, rasterData);
+                    xRaster, yRaster, rasterWidth, rasterHeight, rasterDataFloat);
         }
-        return new TiffRasterData(rasterWidth, rasterHeight, rasterData);
+        return new TiffRasterDataFloat(rasterWidth, rasterHeight, rasterDataFloat);
     }
 
+    private TiffRasterData readRasterDataInt(final Rectangle subImage)
+            throws ImageReadException, IOException {
+        int xRaster;
+        int yRaster;
+        int rasterWidth;
+        int rasterHeight;
+        if (subImage != null) {
+            xRaster = subImage.x;
+            yRaster = subImage.y;
+            rasterWidth = subImage.width;
+            rasterHeight = subImage.height;
+        } else {
+            xRaster = 0;
+            yRaster = 0;
+            rasterWidth = width;
+            rasterHeight = height;
+        }
+
+        int[] rasterDataInt = new int[rasterWidth * rasterHeight];
+
+        // the legacy code is optimized to the reading of whole
+        // strips (except for the last strip in the image, which can
+        // be a partial).  So create a working image with compatible
+        // dimensions and read that.  Later on, the working image
+        // will be sub-imaged to the proper size.
+        // strip0 and strip1 give the indices of the strips containing
+        // the first and last rows of pixels in the subimage
+        final int strip0 = yRaster / rowsPerStrip;
+        final int strip1 = (yRaster + rasterHeight - 1) / rowsPerStrip;
+
+        for (int strip = strip0; strip <= strip1; strip++) {
+            final int yStrip = strip * rowsPerStrip;
+            final int rowsRemaining = height - yStrip;
+            final int rowsInThisStrip = Math.min(rowsRemaining, rowsPerStrip);
+            final int bytesPerRow = (bitsPerPixel * width + 7) / 8;
+            final int bytesPerStrip = rowsInThisStrip * bytesPerRow;
+
+            final byte[] compressed = imageData.getImageData(strip).getData();
+            final byte[] decompressed = decompress(compressed, compression,
+                    bytesPerStrip, width, rowsInThisStrip);
+            final int[] blockData = unpackIntSamples(
+                    width,
+                    (int) rowsInThisStrip,
+                    width,
+                    decompressed,
+                    predictor, bitsPerPixel, byteOrder);
+            transferBlockToRaster(0, yStrip, width, (int) rowsInThisStrip, blockData,","[{'comment': 'Unnecessary casting.', 'commenter': 'kinow'}, {'comment': 'Done', 'commenter': 'gwlucastrig'}]"
179,src/main/java/org/apache/commons/imaging/formats/tiff/datareaders/ImageDataReader.java,"@@ -62,15 +63,15 @@
  * Unfortunately, the TIFF floating-point format allows for a lot of different
  * variations. At this time, only the most widely used of these are supported.
  * When this code was written, only a small set of test data products were
- * available. Thus it is likely that developers will wish to extend the
- * range of floating-point data that can be processed as
- * additional test data become available. When implementing extensions to this
- * logic, developers are reminded that image processing requires
- * the handling of literally millions of pixels, so attention to performance
- * is essential to a successful implementation (please see the notes in
- * DataReaderStrips.java for more information).
+ * available. Thus it is likely that developers will wish to extend the range of
+ * floating-point data that can be processed as additional test data become
+ * available. When implementing extensions to this logic, developers are
+ * reminded that image processing requires the handling of literally millions of
+ * pixels, so attention to performance is essential to a successful
+ * implementation (please see the notes in DataReaderStrips.java for more","[{'comment': 'Use `{@code DataReaderStrips}` or `{@link DataReaderStrips}`.', 'commenter': 'kinow'}, {'comment': ""Wow.  That link annotation actually worked.  I've got a new favorite technique  "", 'commenter': 'gwlucastrig'}]"
179,src/main/java/org/apache/commons/imaging/formats/tiff/datareaders/ImageDataReader.java,"@@ -382,53 +413,91 @@ protected void applyPredictorToBlock(final int width, final int height, final in
         final int height,
         final int scanSize,
         final byte[] bytes,
-        final int predictor,
-        final int bitsPerSample,
+        final int bitsPerPixel,
         final ByteOrder byteOrder)
         throws ImageReadException {
+        final int bitsPerSample = bitsPerPixel / samplesPerPixel;
         final int bytesPerSample = bitsPerSample / 8;
-        final int nBytes = bytesPerSample * scanSize * height;
-        final int length = bytes.length < nBytes ? nBytes / scanSize : height;
-
-        final int[] samples = new int[scanSize * height];
+        final int bytesPerScan = scanSize * samplesPerPixel * bytesPerSample;
+        final int nBytes = bytesPerScan * height;
+        final int length = bytes.length < nBytes ? nBytes / bytesPerScan : height;
+        final int[] samples = new int[scanSize * samplesPerPixel * height];
         // floating-point differencing is indicated by a predictor value of 3.
         if (predictor == TiffTagConstants.PREDICTOR_VALUE_FLOATING_POINT_DIFFERENCING) {
             // at this time, this class supports the 32-bit format.  The
             // main reason for this is that we have not located sample data
             // that can be used for testing and analysis.
-            if (bitsPerSample != 32) {
+            if (bitsPerPixel / samplesPerPixel != 32) {
                 throw new ImageReadException(
                     ""Imaging does not yet support floating-point data""
                     + "" with predictor type 3 for ""
-                    + bitsPerSample + "" bits per sample"");
+                    + bitsPerPixel + "" bits per sample"");
             }
-            final int bytesInRow = scanSize * 4;
-            for (int i = 0; i < length; i++) {
-                final int aOffset = i * bytesInRow;
-                final int bOffset = aOffset + scanSize;
-                final int cOffset = bOffset + scanSize;
-                final int dOffset = cOffset + scanSize;
-                // in this loop, the source bytes give delta values.
-                // we adjust them to give true values.  This operation is
-                // done on a row-by-row basis.
-                for (int j = 1; j < bytesInRow; j++) {
-                    bytes[aOffset + j] += bytes[aOffset + j - 1];
+
+            if (planarConfiguration == TiffPlanarConfiguration.CHUNKY) {
+                final int bytesInRow = scanSize * 4 * samplesPerPixel;
+                for (int i = 0; i < length; i++) {
+                    final int aOffset = i * bytesInRow;
+                    final int bOffset = aOffset + scanSize * samplesPerPixel;
+                    final int cOffset = bOffset + scanSize * samplesPerPixel;
+                    final int dOffset = cOffset + scanSize * samplesPerPixel;
+                    // in this loop, the source bytes give delta values.
+                    // we adjust them to give true values.  This operation is
+                    // done on a row-by-row basis.
+                    for (int j = 1; j < bytesInRow; j++) {
+                        bytes[aOffset + j] += bytes[aOffset + j - 1];
+                    }
+                    // pack the bytes into the integer bit-equivalent of
+                    // floating point values
+                    int index = i * scanSize;
+                    for (int j = 0; j < width * samplesPerPixel; j++) {
+                        final int a = bytes[aOffset + j];
+                        final int b = bytes[bOffset + j];
+                        final int c = bytes[cOffset + j];
+                        final int d = bytes[dOffset + j];
+                        // Pack the 4 byte components into a single integer
+                        // in the byte order used by the TIFF standard
+                        samples[index++] = ((a & 0xff) << 24)
+                            | ((b & 0xff) << 16)
+                            | ((c & 0xff) << 8)
+                            | (d & 0xff);
+                    }
                 }
-                // pack the bytes into the integer bit-equivalent of
-                // floating point values
-                int index = i * scanSize;
-                for (int j = 0; j < width; j++) {
-                    final int a = bytes[aOffset + j];
-                    final int b = bytes[bOffset + j];
-                    final int c = bytes[cOffset + j];
-                    final int d = bytes[dOffset + j];
-                    // Pack the 4 byte components into a single integer
-                    // in the byte order used by the TIFF standard
-                    samples[index++] = ((a & 0xff) << 24)
-                        | ((b & 0xff) << 16)
-                        | ((c & 0xff) << 8)
-                        | (d & 0xff);
+            } else {
+                final int bytesInRow = scanSize * 4;
+                for (int iPlane = 0; iPlane < samplesPerPixel; iPlane++) {
+                    int planarIntOffset = iPlane * length * scanSize;
+                    int planarByteOffset = planarIntOffset * 4;
+
+                    for (int i = 0; i < length; i++) {
+                        final int aOffset = i * bytesInRow + planarByteOffset;
+                        final int bOffset = aOffset + scanSize;
+                        final int cOffset = bOffset + scanSize;
+                        final int dOffset = cOffset + scanSize;
+                        // in this loop, the source bytes give delta values.
+                        // we adjust them to give true values.  This operation is
+                        // done on a row-by-row basis.
+                        for (int j = 1; j < bytesInRow; j++) {
+                            bytes[aOffset + j] += bytes[aOffset + j - 1];
+                        }
+                        // pack the bytes into the integer bit-equivalent of
+                        // floating point values
+                        int index = planarIntOffset + i * scanSize;
+                        for (int j = 0; j < width; j++) {
+                            final int a = bytes[aOffset + j];
+                            final int b = bytes[bOffset + j];
+                            final int c = bytes[cOffset + j];
+                            final int d = bytes[dOffset + j];
+                            // Pack the 4 byte components into a single integer
+                            // in the byte order used by the TIFF standard
+                            samples[index++] = ((a & 0xff) << 24)
+                                | ((b & 0xff) << 16)
+                                | ((c & 0xff) << 8)
+                                | (d & 0xff);
+                        }
+                    }","[{'comment': 'For a follow-up, we should probably simplify this method, splitting into separate methods if possible.', 'commenter': 'kinow'}, {'comment': 'In a future PR, I would like to do some code clean up like that.', 'commenter': 'gwlucastrig'}]"
179,src/test/java/org/apache/commons/imaging/formats/tiff/TiffRasterDataTest.java,"@@ -84,6 +85,45 @@ public void testGetValue() {
         }
     }
 
+    /**
+     * Test of setValue method, of class TiffRasterData.
+     */
+    @Test
+    public void testSetValue2() {
+        final TiffRasterData instance = new TiffRasterDataFloat(width, height, 2);
+        for (int y = 0; y < height; y++) {
+            for (int x = 0; x < width; x++) {
+                final int index = y * width + height;
+                instance.setValue(x, y, 1, index);
+                final int test = (int) instance.getValue(x, y, 1);
+                assertEquals(index, test, ""Set/get value test failed at ("" + x + "","" + y + "")"");
+                instance.setIntValue(x, y, 1, index);
+                final int iTest = instance.getIntValue(x, y, 1);
+                assertEquals(index, iTest, ""Get/set value test failed at ("" + x + "","" + y + "")"");
+            }
+        }
+    }
+
+    /**
+     * Test of getValue method, of class TiffRasterData.
+     */
+    @Test
+    public void testGetValue2() {
+        for (int y = 0; y < height; y++) {
+            for (int x = 0; x < width; x++) {
+                final int index = y * width + x;
+                final int test = (int) raster.getValue(x, y, 0);
+                assertEquals(index, test, ""Get into source data test failed at ("" + x + "","" + y + "")"");
+                final int iTest = raster.getIntValue(x, y, 0);
+                assertEquals(index, iTest, ""Get into source data test failed at ("" + x + "","" + y + "")"");
+            }
+        }
+    }
+
+
+
+
+","[{'comment': 'Unnecessary extra blank lines :point_up: ', 'commenter': 'kinow'}, {'comment': 'done', 'commenter': 'gwlucastrig'}]"
179,src/main/java/org/apache/commons/imaging/formats/tiff/datareaders/ImageDataReader.java,"@@ -68,7 +68,11 @@
  * available. When implementing extensions to this logic, developers are
  * reminded that image processing requires the handling of literally millions of
  * pixels, so attention to performance is essential to a successful
+<<<<<<< HEAD
+ * implementation (please see the notes in {@link DataReaderStrips} for more
+=======","[{'comment': 'This happens when conflicts are fixed, but accidentally the git comments are left behind :grimacing: ', 'commenter': 'kinow'}]"
179,src/test/java/org/apache/commons/imaging/formats/tiff/TiffRasterDataTest.java,"@@ -120,10 +120,13 @@ public void testGetValue2() {
         }
     }
 
+<<<<<<< HEAD
+=======","[{'comment': ':arrow_up: ', 'commenter': 'kinow'}]"
214,src/main/java/org/apache/commons/imaging/formats/jpeg/decoder/JpegDecoder.java,"@@ -374,16 +374,14 @@ private void readMCU(final JpegInputStream is, final int[] preds, final Block[]
                                 is,
                                 huffmanACTables[scanComponent.acCodingTableSelector]);
                         final int ssss = rs & 0xf;
-                        final int rrrr = rs >> 4;
-                        final int r = rrrr;","[{'comment': ""If others prefer to have this expressions replaced, that'd be OK for me. But I prefer to keep they as they are, since if there's any performance gain, it might be nanoseconds.\r\n\r\nSimilar to [this comment](https://github.com/apache/commons-imaging/pull/155#discussion_r662990219) from another PR @arturobernalg, these variables are present in code in other languages, and they all come from documents/specification/revisions/etc.\r\n\r\nLooking at this one, it looks like the original author took care to reproduce a flow chart from [this document](https://www.w3.org/Graphics/JPEG/itu-t81.pdf).\r\n\r\n![image](https://user-images.githubusercontent.com/304786/162572879-5ddf3102-65b5-47a9-b820-07d8b46d6104.png)\r\n\r\nI prefer to have the code as similar to the original spec/paper/blog/code/etc, since it's normally easier to work on it if I have to re read the docs, or look at code in other languages.\r\n\r\nImaging has a lot of that, in byte shifting operations, and other places where unless it's a really bad code pattern, or performs drastically worst, I prefer to leave the code to be similar to the source of origin.\r\n\r\nBruno\r\n\r\n"", 'commenter': 'kinow'}, {'comment': 'HI @kinow \r\ntrue. I completely forgot. \r\nReverted.\r\nTY', 'commenter': 'arturobernalg'}]"
271,src/test/java/org/apache/commons/imaging/formats/bmp/BmpRoundtripTest.java,"@@ -140,17 +139,21 @@ private void writeAndReadImageData(final int[][] rawData) throws IOException, Im
 
         final byte[] bytes = Imaging.writeImageToBytes(srcImage, ImageFormats.BMP);
 
-        final File tempFile = Files.createTempFile(""temp"", "".bmp"").toFile();
-        FileUtils.writeByteArrayToFile(tempFile, bytes);
-
         final BufferedImage dstImage = Imaging.getBufferedImage(bytes);
 
-        assertNotNull(dstImage);
-        assertEquals(srcImage.getWidth(), dstImage.getWidth());
-        assertEquals(srcImage.getHeight(), dstImage.getHeight());
-
-        final int[][] dstData = bufferedImageToImageData(dstImage);
-        compare(rawData, dstData);
+        try {
+            assertNotNull(dstImage);
+            assertEquals(srcImage.getWidth(), dstImage.getWidth());
+            assertEquals(srcImage.getHeight(), dstImage.getHeight());
+
+            final int[][] dstData = bufferedImageToImageData(dstImage);
+            compare(rawData, dstData);
+        } catch (final Throwable e) {
+            final Path tempFile = Files.createTempFile(""temp"", "".bmp"");
+            Files.write(tempFile, bytes);
+            System.err.println(""Failed tempFile "" + tempFile);","[{'comment': ""We migrated old Syserr & Sysout calls to JUL `Logger`. See `BitImageParser` for an example use. We can use the same in the tests, so users are able to ignore this output if they want. (The examples use Syserr/Sysout as that can be helpful for users trying in their IDE's)."", 'commenter': 'kinow'}, {'comment': ""Also, reading again the code, I think we can rethink this fallback mechanism.\r\n\r\nRight now, in case there's any exception of any type, it writes the image to the disk. But that might end up doing that unnecessarily for some exception types.\r\n\r\nIt might be simple to just throw the error and let a developer call the code to write it to the disk, I think. Otherwise we will also have to remember to use this boilerplace code whenever we write new test code that loads images into the memory.\r\n\r\nSorry @kpouer, as I believe your initial PR didn't have this, and you added it based on our initial feedback. Right now I'm included to undo that, but give me some time to think about this one :+1: \r\n"", 'commenter': 'kinow'}, {'comment': '(and no need to worry, I can undo the change to always write to disk if we decide to go down that path :wink: :+1: )', 'commenter': 'kinow'}, {'comment': 'Hi, in fact I could undo the change that automatically write the tmp file as it is probably useless in case of automatic tests. But add back the code that writes the file but commented out so it could be activated manually by a developper if needed ?', 'commenter': 'kpouer'}, {'comment': "">Hi, in fact I could undo the change that automatically write the tmp file as it is probably useless in case of automatic tests. But add back the code that writes the file but commented out so it could be activated manually by a developper if needed ?\r\n\r\nThat'd be useful! I really think that'd be better than just writing whenever there's an exception. Sorry for the extra work @kpouer !"", 'commenter': 'kinow'}]"
271,src/test/java/org/apache/commons/imaging/roundtrip/RoundtripBase.java,"@@ -39,35 +38,52 @@ public class RoundtripBase {
     protected void roundtrip(final FormatInfo formatInfo, final BufferedImage testImage,
                              final String tempPrefix, final boolean imageExact) throws IOException,
             ImageReadException, ImageWriteException {
-        final File temp1 = Files.createTempFile(tempPrefix + ""."", "".""
-                + formatInfo.format.getDefaultExtension()).toFile();
-        Debug.debug(""tempFile: "" + temp1.getName());
 
         final ImageParser imageParser = Util.getImageParser(formatInfo.format);
 
+        byte[] temp1;
         final ImagingParameters params = Util.getImageParser(formatInfo.format).getDefaultParameters();
-        try (FileOutputStream fos = new FileOutputStream(temp1)) {
-            imageParser.writeImage(testImage, fos, params);
+        try (ByteArrayOutputStream bos = new ByteArrayOutputStream(1000000)) {","[{'comment': 'Maybe leave it the default value and let it handle expanding the internal buffer? That could be helpful if we load many smaller images, I think (although I have no idea the distribution of sizes of our images & their metadata too).', 'commenter': 'kinow'}]"
271,src/test/java/org/apache/commons/imaging/formats/png/PngTextTest.java,"@@ -74,8 +76,10 @@ public void test() throws Exception {
             bytes = baos.toByteArray();
         }
 
-        final File tempFile = Files.createTempFile(""temp"", "".png"").toFile();
-        FileUtils.writeByteArrayToFile(tempFile, bytes);
+        if (false) { // activate saving tmp file for troubleshooting
+            final File tempFile = Files.createTempFile(""temp"", "".png"").toFile();
+            FileUtils.writeByteArrayToFile(tempFile, bytes);","[{'comment': '`LOGGER` no used here.', 'commenter': 'kinow'}]"
271,src/test/java/org/apache/commons/imaging/formats/png/PngWriteForceTrueColorText.java,"@@ -21,21 +21,25 @@
 import org.junit.jupiter.api.Test;
 
 import java.awt.image.BufferedImage;
+import java.io.ByteArrayOutputStream;
 import java.io.File;
-import java.io.FileOutputStream;
 import java.nio.file.Files;
+import java.nio.file.Path;
 import java.util.List;
+import java.util.logging.Logger;
 
 import static org.junit.jupiter.api.Assertions.assertNotNull;
 
 public class PngWriteForceTrueColorText extends PngBaseTest {
+    private static final Logger LOGGER = Logger.getLogger(PngWriteForceTrueColorText.class.getName());
 
     @Test
     public void test() throws Exception {
         final PngImageParser pngImageParser = new PngImageParser();
         final List<File> images = getPngImages();
         for (final File imageFile : images) {
 
+            byte[] outFile = null;","[{'comment': ""This could be inside the `try` block. I thought it was declared outside for some reason, but apparently it's only used within that block?"", 'commenter': 'kinow'}]"
271,src/test/java/org/apache/commons/imaging/formats/png/PngWriteForceTrueColorText.java,"@@ -50,13 +54,19 @@ public void test() throws Exception {
                 final BufferedImage image = pngImageParser.getBufferedImage(imageFile, new PngImagingParameters());
                 assertNotNull(image);
 
-                final File outFile = Files.createTempFile(imageFile.getName() + ""."", "".png"").toFile();
                 // Debug.debug(""outFile"", outFile);
 
                 final PngImagingParameters params = new PngImagingParameters();
-                params.setForceTrueColor(Boolean.TRUE);
-                try (FileOutputStream fos = new FileOutputStream(outFile)) {
-                    pngImageParser.writeImage(image, fos, params);
+
+                try (ByteArrayOutputStream os = new ByteArrayOutputStream()) {
+                    params.setForceTrueColor(Boolean.TRUE);
+                    pngImageParser.writeImage(image, os, params);
+                    outFile = os.toByteArray();
+                }
+
+                if (false) { // activate saving tmp file for troubleshooting
+                    final Path tempFile = Files.createTempFile(imageFile.getName() + ""."", "".jpg"");
+                    Files.write(tempFile, outFile);","[{'comment': '`LOGGER` not used here.', 'commenter': 'kinow'}]"
271,src/test/java/org/apache/commons/imaging/roundtrip/RoundtripBase.java,"@@ -62,10 +78,18 @@ protected void roundtrip(final FormatInfo formatInfo, final BufferedImage testIm
         }
 
         if (formatInfo.identicalSecondWrite) {
-            final File temp2 = Files.createTempFile(tempPrefix + ""."", ""."" + formatInfo.format.getDefaultExtension()).toFile();
-            try (FileOutputStream fos = new FileOutputStream(temp2)) {
-                imageParser.writeImage(image2, fos, params);
+            if (false) { // activate saving tmp file for troubleshooting
+                final File temp2 = Files.createTempFile(tempPrefix + ""."", ""."" + formatInfo.format.getDefaultExtension()).toFile();
+                try (FileOutputStream fos = new FileOutputStream(temp2)) {
+                    imageParser.writeImage(image2, fos, params);
+                }","[{'comment': '`LOGGER` not used here.', 'commenter': 'kinow'}]"
271,src/test/java/org/apache/commons/imaging/formats/jpeg/exif/ExifRewriteTest.java,"@@ -123,15 +119,12 @@ public void testInsert() throws Exception {
                 final ByteArrayOutputStream baos = new ByteArrayOutputStream();
                 new ExifRewriter().removeExifMetadata(byteSource, baos);
                 final byte[] bytes = baos.toByteArray();
-                final File tempFile = Files.createTempFile(""removed"", "".jpg"").toFile();
-                Debug.debug(""tempFile"", tempFile);
-                FileUtils.writeByteArrayToFile(tempFile, bytes);
 
                 Debug.debug(""Output Segments:"");
                 stripped = new ByteSourceArray(bytes);
                 new JpegUtils().dumpJFIF(stripped);
 
-                assertFalse(hasExifData(tempFile));
+                assertFalse(hasExifData(""removed.jpg"", bytes));","[{'comment': 'Really awkward to have the file name in the `ByteSource` constructor. I think the original devs never imagined using it without a file :slightly_smiling_face: Thank you for keeping the file names :+1: ', 'commenter': 'kinow'}]"
271,src/test/java/org/apache/commons/imaging/formats/jpeg/iptc/IptcUpdateTest.java,"@@ -21,19 +21,15 @@
 import static org.junit.jupiter.api.Assertions.assertNotNull;
 import static org.junit.jupiter.api.Assertions.assertTrue;
 
-import java.io.BufferedOutputStream;
-import java.io.File;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.io.OutputStream;
-import java.nio.file.Files;
+import java.io.*;","[{'comment': 'I think the rest of the code in general is not using `.*` for imports, so better keep that way for consistency (on this file, but also on the rest of the files changed in the PR) :+1: \r\n\r\nIf your IDE did that automatically, try disabling that inspection/auto-save behavior for this project (I know other Commons components also use complete imports).', 'commenter': 'kinow'}, {'comment': 'I will fix that, no problem', 'commenter': 'kpouer'}]"
271,src/test/java/org/apache/commons/imaging/roundtrip/NullParametersRoundtripTest.java,"@@ -38,13 +38,17 @@ public static Stream<FormatInfo> data() {
     @MethodSource(""data"")
     public void testNullParametersRoundtrip(final FormatInfo formatInfo) throws Exception {
         final BufferedImage testImage = TestImages.createFullColorImage(1, 1);
-        final File temp1 = Files.createTempFile(""nullParameters."", ""."" + formatInfo.format.getDefaultExtension()).toFile();
-        Imaging.writeImage(testImage, temp1, formatInfo.format);
-        Imaging.getImageInfo(temp1);
-        Imaging.getImageSize(temp1);
-        Imaging.getMetadata(temp1);
-        Imaging.getICCProfile(temp1);
-        final BufferedImage imageRead = Imaging.getBufferedImage(temp1);
+        final byte[] temp1;
+        try (ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream()) {
+            Imaging.writeImage(testImage, byteArrayOutputStream, formatInfo.format);
+            temp1 = byteArrayOutputStream.toByteArray();
+        }
+        final String filename = ""nullParameters."" + formatInfo.format.getDefaultExtension();
+        Imaging.getImageInfo(new ByteArrayInputStream(temp1), filename);
+        Imaging.getImageSize(new ByteArrayInputStream(temp1), filename);
+        Imaging.getMetadata(new ByteArrayInputStream(temp1), filename);
+        Imaging.getICCProfile(new ByteArrayInputStream(temp1), filename);","[{'comment': 'Hmmm, we cannot re-use the same `ByteArrayInputStream` right? :thinking: would be nicer if we closed these streams at least. Maybe we have to split it into separated test methods?', 'commenter': 'kinow'}, {'comment': 'In fact we can reuse the same ByteArrayInputStream but the code is more verbose, and closing it has no effect (however it is useful for static analysis of IDE so they do not complains about it ;) )\r\n\r\n```java\r\ntry (ByteArrayInputStream bos = new ByteArrayInputStream(temp1)) {\r\n            Imaging.getImageInfo(bos, filename);\r\n            bos.reset();\r\n            Imaging.getImageSize(bos, filename);\r\n            bos.reset();\r\n            Imaging.getMetadata(bos, filename);\r\n            bos.reset();\r\n            Imaging.getICCProfile(bos, filename);\r\n            bos.reset();\r\n            final BufferedImage imageRead = Imaging.getBufferedImage(bos, filename);\r\n            bos.reset();\r\n            assertNotNull(imageRead);\r\n        }\r\n```\r\n\r\nAnother option is to use the methods taking directly a byte[] but it would require to create new methods also taking the filename as the file extension is sometimes used to help reading data (unfortunately some exists but the parameter order is not consistent, sometimes the filename comes first some other time it comes after)', 'commenter': 'kpouer'}, {'comment': ""Argh, your current version is better. Let's keep it like this, it's just a test file. Thanks @kpouer!"", 'commenter': 'kinow'}]"
271,src/test/java/org/apache/commons/imaging/roundtrip/ImageAsserts.java,"@@ -99,4 +99,18 @@ static void assertEquals(final File a, final File b) throws IOException {
             Assertions.assertEquals(aByte, bByte);
         }
     }
+
+    static void assertEquals(byte[] aData, byte[] bData) {
+        for (int i = 0; i < aData.length; i++) {
+            final int aByte = 0xff & aData[i];
+            final int bByte = 0xff & bData[i];
+
+            if (aByte != bByte) {
+                Debug.debug(""i: "" + i);
+                Debug.debug(""aByte: "" + aByte + "" (0x"" + Integer.toHexString(aByte) + ')');
+                Debug.debug(""bByte: "" + bByte + "" (0x"" + Integer.toHexString(bByte) + ')');
+            }
+            Assertions.assertEquals(aByte, bByte);
+        }
+    }","[{'comment': ""Is there a reason for using this over using JUnit's [`assertArrayEquals`](https://junit.org/junit5/docs/5.0.0/api/org/junit/jupiter/api/Assertions.html#assertArrayEquals-byte:A-byte:A-) ? The `Debug` is not active by default, I believe, so using this doesn't seem to add must value."", 'commenter': 'kinow'}, {'comment': 'The only idea was to match the other similar methods of the class.\r\nAlso I am not sure the comparison with assertArrayEquals would be strictly identical as there is a bitwise operation & 0xFF I suppose to make it positive value ? (however I have no idea if it would change something in the unit tests).', 'commenter': 'kpouer'}, {'comment': ""I think the JUnit version should work too. Not sure if what `ImageAsserts#assertEquals(File, File)` is doing is necessary. It's reading the bytes from the stream, I assume, without handling `int` values (and thus having to apply a filter mask `0xff` to clear the other bits in the 32 byte-Java).\r\n\r\nThe point here is that if the JUnit's `assertArrayEquals` work, it's better it's less code for us to test :+1: "", 'commenter': 'kinow'}]"
271,src/test/java/org/apache/commons/imaging/roundtrip/FormatInfo.java,"@@ -130,4 +130,16 @@ class FormatInfo {
         this.identicalSecondWrite = identicalSecondWrite;
         this.preservesResolution = preservesResolution;
     }
+
+    @Override
+    public String toString() {
+        return ""FormatInfo{"" +
+            ""format="" + format +
+            "", canRead="" + canRead +
+            "", canWrite="" + canWrite +
+            "", colorSupport="" + colorSupport +
+            "", identicalSecondWrite="" + identicalSecondWrite +
+            "", preservesResolution="" + preservesResolution +
+            '}';","[{'comment': 'Looks harmless, but was there a reason for adding this one? ', 'commenter': 'kinow'}, {'comment': ""It helped me a little when looking at some FormatInfo in the debugger of my IDE but if you don't find it useful I can remove that."", 'commenter': 'kpouer'}, {'comment': 'Got it. Sounds like something that could be helpful to others too, and tests only, so really no harm in adding it. Thanks for the explanation!', 'commenter': 'kinow'}]"
306,src/test/java/org/apache/commons/imaging/test/TestResources.java,"@@ -0,0 +1,59 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.commons.imaging.test;
+
+import java.io.File;
+import java.net.URI;
+import java.net.URISyntaxException;
+import java.net.URL;
+import java.nio.file.Path;
+import java.nio.file.Paths;
+
+/**
+ * Helper class which provides convenience methods for accessing test resources.
+ */
+public class TestResources {
+    private TestResources() {
+    }
+
+    private static URI resourceUri(String path) {
+        URL url = TestResources.class.getResource(path);
+        if (url == null) {
+            throw new IllegalArgumentException(""Resource does not exist: "" + path);
+        }
+        try {
+            return url.toURI();
+        } catch (URISyntaxException e) {
+            throw new IllegalArgumentException(e);
+        }
+    }
+
+    /**
+     * Gets a {@link File} for a {@linkplain Class#getResource(String) resource path}.
+     */
+    public static File fileResource(String path) {
+        return new File(resourceUri(path));
+    }
+
+    /**
+     * Gets a {@link Path} for a {@linkplain Class#getResource(String) resource path}.
+     */
+    public static Path pathResource(String path) {","[{'comment': ""I am not completely sure about those names; at least `fileResource` sounds a bit like it also verifies that the resource is an existing file (and not a directory), which it doesn't.\r\n\r\nMaybe `resourceFile` and `resourcePath` would be better (or some other name)? What do you think?"", 'commenter': 'Marcono1234'}]"
306,src/test/java/org/apache/commons/imaging/formats/bmp/BmpImageParserTest.java,"@@ -16,6 +16,7 @@
  */
 package org.apache.commons.imaging.formats.bmp;
 
+import static org.apache.commons.imaging.test.TestResources.fileResource;","[{'comment': 'I think we should only use static imports for JUnit.', 'commenter': 'garydgregory'}, {'comment': 'Have changed it to regular imports', 'commenter': 'Marcono1234'}]"
318,src/main/java/org/apache/commons/imaging/formats/tiff/TiffReader.java,"@@ -455,27 +473,55 @@ private TiffHeader readTiffHeader(final ByteSource byteSource) throws ImagingExc
         }
     }
 
-    private TiffHeader readTiffHeader(final InputStream is) throws ImagingException, IOException {
-        final int byteOrder1 = readByte(""BYTE_ORDER_1"", is, ""Not a Valid TIFF File"");
-        final int byteOrder2 = readByte(""BYTE_ORDER_2"", is, ""Not a Valid TIFF File"");
-        if (byteOrder1 != byteOrder2) {
-            throw new ImagingException(""Byte Order bytes don't match ("" + byteOrder1 + "", "" + byteOrder2 + "")."");
-        }
-
-        final ByteOrder byteOrder = getTiffByteOrder(byteOrder1);
-        setByteOrder(byteOrder);
-
-        final int tiffVersion = read2Bytes(""tiffVersion"", is, ""Not a Valid TIFF File"", getByteOrder());
-        if (tiffVersion != 42) {
-            throw new ImagingException(""Unknown TIFF Version: "" + tiffVersion);
-        }
+   private TiffHeader readTiffHeader(final InputStream is) throws ImagingException, IOException {
+    final int byteOrder1 = readByte(""BYTE_ORDER_1"", is, ""Not a Valid TIFF File"");
+    final int byteOrder2 = readByte(""BYTE_ORDER_2"", is, ""Not a Valid TIFF File"");
+    if (byteOrder1 != byteOrder2) {
+      throw new ImagingException(""Byte Order bytes don't match ("" + byteOrder1 + "", "" + byteOrder2 + "")."");
+    }
 
-        final long offsetToFirstIFD =
-                0xFFFFffffL & read4Bytes(""offsetToFirstIFD"", is, ""Not a Valid TIFF File"", getByteOrder());
+    final ByteOrder byteOrder = getTiffByteOrder(byteOrder1);
+    setByteOrder(byteOrder);
+
+    // verify that the file is a supported TIFF format using
+    // the numeric indentifier
+    //     Classic TIFF (32 bit):    42
+    //     Big TIFF (64 bit):        43
+    //
+    final long offsetToFirstIFD;
+    final int tiffVersion = read2Bytes(""tiffVersion"", is, ""Not a Valid TIFF File"", getByteOrder());
+    if (tiffVersion == TIFF_VERSION_STANDARD) {
+      bigTiff = false;
+      standardTiff = true;
+      entryMaxValueLength = TIFF_ENTRY_MAX_VALUE_LENGTH;
+      offsetToFirstIFD
+        = 0xFFFFffffL & read4Bytes(
+          ""offsetToFirstIFD"", is, ""Not a Valid TIFF File"", getByteOrder());
+    } else if (tiffVersion == TIFF_VERSION_BIG) {
+      bigTiff = true;
+      standardTiff = false;
+       entryMaxValueLength = TIFF_ENTRY_MAX_VALUE_LENGTH_BIG;
+      int byteSize","[{'comment': 'I\'m really not a fan of ""newspaper"" formatting, IOW very short lines. I\'ve set the checkstyle max line length to 160 (you can rebase if you want to pick that up).', 'commenter': 'garydgregory'}, {'comment': 'I agree completely on newspaper formatting.  I will rebase and address code changes', 'commenter': 'gwlucastrig'}]"
318,src/main/java/org/apache/commons/imaging/common/BinaryFunctions.java,"@@ -177,6 +177,44 @@ public static int read4Bytes(final String name, final InputStream is,
         return result;
     }
 
+   public static long read8Bytes(final String name,","[{'comment': 'Javadoc?', 'commenter': 'garydgregory'}, {'comment': 'done', 'commenter': 'gwlucastrig'}]"
318,src/main/java/org/apache/commons/imaging/common/ByteConversions.java,"@@ -399,6 +399,43 @@ private static int[] toUInt16s(final byte[] bytes, final int offset, final int l
         return result;
     }
 
+     public static long toLong(final byte[] bytes, final ByteOrder byteOrder) {","[{'comment': 'We should provide Javadocs on all new public and protected methods IMO.', 'commenter': 'garydgregory'}, {'comment': 'Also, it looks like there is an extra space in front of `public`?', 'commenter': 'garydgregory'}]"
318,src/main/java/org/apache/commons/imaging/formats/tiff/TiffField.java,"@@ -234,6 +234,14 @@ public int[] getIntArrayValue() throws ImagingException {
             final int[] numbers = (int[]) o;
             return Arrays.copyOf(numbers, numbers.length);
         }
+        if (o instanceof long[]){","[{'comment': 'The formatting seems off in the block, missing spaces.', 'commenter': 'garydgregory'}, {'comment': 'done', 'commenter': 'gwlucastrig'}]"
318,src/main/java/org/apache/commons/imaging/formats/tiff/TiffField.java,"@@ -288,6 +296,55 @@ public int getIntValueOrArraySum() throws ImagingException {
         // return -1;
     }
 
+    public long[] getLongArrayValue() throws ImagingException {","[{'comment': 'We should provide Javadocs on all new public and protected methods IMO.', 'commenter': 'garydgregory'}, {'comment': 'done', 'commenter': 'gwlucastrig'}]"
318,src/main/java/org/apache/commons/imaging/formats/tiff/TiffField.java,"@@ -288,6 +296,55 @@ public int getIntValueOrArraySum() throws ImagingException {
         // return -1;
     }
 
+    public long[] getLongArrayValue() throws ImagingException {
+        final Object o = getValue();
+        // if (o == null)
+        // return null;
+
+        if (o instanceof Number) {
+            return new  long[] { ((Number) o).longValue() };
+        }
+        if (o instanceof Number[]) {
+            final Number[] numbers = (Number[]) o;
+            final long[] result = Allocator.longArray(numbers.length);
+            Arrays.setAll(result, i -> numbers[i].longValue());
+            return result;
+        }
+        if (o instanceof short[]) {
+            final short[] numbers = (short[]) o;
+            final long[] result = Allocator.longArray(numbers.length);
+            Arrays.setAll(result, i ->  0xffff & numbers[i]);
+            return result;
+        }
+        if (o instanceof int[]) {
+            final int[] numbers = (int[]) o;
+            final long[]result = Allocator.longArray(numbers.length);
+            Arrays.setAll(result, i ->  0xFFFFffffL & numbers[i]);
+            return result;
+        }
+        if (o instanceof long[]){
+          final long[] numbers = (long[]) o;
+          return Arrays.copyOf(numbers, numbers.length);
+        }
+
+        throw new ImagingException(""Unknown value: "" + o + "" for: ""
+                + getTagInfo().getDescription());
+        // return null;
+    }
+
+    public long getLongValue() throws ImagingException {","[{'comment': 'We should provide Javadocs on all new public and protected methods IMO.', 'commenter': 'garydgregory'}, {'comment': 'done', 'commenter': 'gwlucastrig'}]"
318,src/main/java/org/apache/commons/imaging/formats/tiff/TiffReader.java,"@@ -455,27 +473,47 @@ private TiffHeader readTiffHeader(final ByteSource byteSource) throws ImagingExc
         }
     }
 
-    private TiffHeader readTiffHeader(final InputStream is) throws ImagingException, IOException {
-        final int byteOrder1 = readByte(""BYTE_ORDER_1"", is, ""Not a Valid TIFF File"");
-        final int byteOrder2 = readByte(""BYTE_ORDER_2"", is, ""Not a Valid TIFF File"");
-        if (byteOrder1 != byteOrder2) {
-            throw new ImagingException(""Byte Order bytes don't match ("" + byteOrder1 + "", "" + byteOrder2 + "")."");
-        }
-
-        final ByteOrder byteOrder = getTiffByteOrder(byteOrder1);
-        setByteOrder(byteOrder);
-
-        final int tiffVersion = read2Bytes(""tiffVersion"", is, ""Not a Valid TIFF File"", getByteOrder());
-        if (tiffVersion != 42) {
-            throw new ImagingException(""Unknown TIFF Version: "" + tiffVersion);
-        }
+   private TiffHeader readTiffHeader(final InputStream is) throws ImagingException, IOException {","[{'comment': 'Formatting seems odd.', 'commenter': 'garydgregory'}, {'comment': 'done', 'commenter': 'gwlucastrig'}]"
318,src/main/java/org/apache/commons/imaging/formats/tiff/TiffReader.java,"@@ -16,27 +16,29 @@
  */
 package org.apache.commons.imaging.formats.tiff;
 
-import static org.apache.commons.imaging.common.BinaryFunctions.read2Bytes;
-import static org.apache.commons.imaging.common.BinaryFunctions.read4Bytes;
-import static org.apache.commons.imaging.common.BinaryFunctions.readByte;
-import static org.apache.commons.imaging.common.BinaryFunctions.readBytes;
-import static org.apache.commons.imaging.common.BinaryFunctions.skipBytes;
-import static org.apache.commons.imaging.formats.tiff.constants.TiffConstants.TIFF_ENTRY_MAX_VALUE_LENGTH;
-
 import java.io.IOException;
 import java.io.InputStream;
 import java.nio.ByteOrder;
 import java.util.ArrayList;
 import java.util.List;
-
 import org.apache.commons.imaging.FormatCompliance;
 import org.apache.commons.imaging.ImagingException;
 import org.apache.commons.imaging.bytesource.ByteSource;
 import org.apache.commons.imaging.common.BinaryFileParser;
+import static org.apache.commons.imaging.common.BinaryFunctions.read2Bytes;","[{'comment': 'All statics should be grouped at the top. Not sure if Checkstyle can check for us though.', 'commenter': 'garydgregory'}, {'comment': ""I ran checkstyle before submitting and it didn't complain.  But I definitely agree that the statics should go first. I will modify this and submit a new commit tonight or tomorrow."", 'commenter': 'gwlucastrig'}, {'comment': 'done', 'commenter': 'gwlucastrig'}]"
334,src/test/java/org/apache/commons/imaging/formats/tiff/TiffJpegTest.java,"@@ -0,0 +1,185 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.imaging.formats.tiff;
+
+import java.awt.image.BufferedImage;
+import java.io.File;
+import java.io.IOException;
+import org.apache.commons.imaging.Imaging;
+
+import org.apache.commons.imaging.ImagingTestConstants;
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.fail;
+import org.junit.jupiter.api.Test;
+
+/**
+ * Reads files in the BigTIFF samples folder and compares the
+ * BigTIFF files against the standard ""classic"" tiff image.
+ */
+public class TiffJpegTest extends TiffBaseTest {
+
+    static final String[] testSet0 = {
+        ""TestSample.tiff"",
+        ""TestJpegStrips.tiff"",
+        ""TestJpegTiles.tiff"",
+        ""TestJpegStripsRgb.tiff"",
+        ""TestJpegTilesRgb.tiff"",
+        ""TestJpegCMYK.tiff"",};
+
+    static final String[] testSet1 = {
+        ""TestSample264x264.tiff"",
+        ""TestJpegStrips264x264.tiff"",
+        ""TestJpegStrips264x264BigEndian.tiff"",
+        ""TestJpegTiles264x264.tiff"",
+        ""TestJpegTiles264x264BigEndian.tiff"",};
+
+    static final String[] testSet2 = {
+        ""TestSampleArgb.tiff"",
+        ""TestJpegArgb.tiff"",};
+
+    private File getTiffFile(String name) {
+        final File tiffFolder = new File(ImagingTestConstants.TEST_IMAGE_FOLDER, ""tiff"");
+        final File tiffJpegFolder = new File(tiffFolder, ""14"");
+        return new File(tiffJpegFolder, name);
+    }
+
+    private int gray(int argb) {
+        int r = (argb >> 16) & 0xff;
+        int g = (argb >> 8) & 0xff;
+        int b = argb & 0xff;
+        return (int) (0.299 * r + 0.587 * g + 0.114 * b + 0.5);
+    }
+
+    /**
+     * Process a set of files using the first name in the array as
+     * the master image and comparing all subsequent files against its
+     * content on a pixel-by-pixel bases. The first name will usually be
+     * a TIFF file that is stored using a non-lossy compression format
+     * (something other than JPEG). All subsequent files will use
+     * JPEG based compression with an alternate geometry (strips, tiles, etc.).
+     * Because JPEG is lossy, we define a match as values of pixels that
+     * produce gray tones withing a threshold.
+     *
+     * @param testSet an array of 2 or more TIFF file names
+     * @throws IOException in the event of an unexpected I/O exception
+     */
+    private void processTestSet(String[] testSet) throws IOException {
+        File masterFile = getTiffFile(testSet[0]);
+        BufferedImage masterImage = Imaging.getBufferedImage(masterFile);
+        int w = masterImage.getWidth();
+        int h = masterImage.getHeight();
+        int[] masterArgb = new int[w * h];
+        masterImage.getRGB(0, 0, w, h, masterArgb, 0, w);
+
+        int[] masterGray = new int[w * h];
+        for (int i = 0; i < masterArgb.length; i++) {
+            masterGray[i] = gray(masterArgb[i]);
+        }
+
+        for (int iFile = 1; iFile < testSet.length; iFile++) {
+            String name = testSet[iFile];
+            File f = getTiffFile(name);
+            BufferedImage test = Imaging.getBufferedImage(f);
+            int testW = test.getWidth();
+            int testH = test.getHeight();
+            assertEquals(w, testW, ""Width mismatch for "" + name);
+            assertEquals(h, testH, ""Height mismatch for "" + name);
+
+            String label = ""Pixel match for "" + name;
+            int[] testArgb = new int[w * h];
+            test.getRGB(0, 0, w, h, testArgb, 0, w);
+            for (int i = 0; i < testArgb.length; i++) {
+                int testGray = gray(testArgb[i]);
+                int masterA = masterArgb[i] >>> 24;
+                int testA = testArgb[i] >>> 24;
+                assertEquals(masterA, testA, 1, label);
+                assertEquals(masterGray[i], testGray, 4, label);
+            }
+        }
+    }
+
+    void performSubImageTest(String name) throws IOException {
+        // get the full image to be used as a basis for comparison
+        File target = getTiffFile(name);
+        BufferedImage master = Imaging.getBufferedImage(target);
+        int w = master.getWidth();
+        int h = master.getHeight();
+        int[] masterArgb = new int[w * h];
+        master.getRGB(0, 0, w, h, masterArgb, 0, w);
+
+        // Get a subimage
+        TiffImageParser tiffImageParser = new TiffImageParser();
+        TiffImagingParameters params = new TiffImagingParameters();
+        int testX0 = 11;
+        int testY0 = 11;
+        int testW = w - testX0 - 1;
+        int testH = h - testY0 - 1;
+        params.setSubImage(testX0, testY0, testW, testH);
+
+        BufferedImage test = tiffImageParser.getBufferedImage(target, params);
+        int[] testArgb = new int[testW * testH];
+        test.getRGB(0, 0, testW, testH, testArgb, 0, testW);
+        String label = ""Pixel mismatch for "" + name;
+        for (int i = 0; i < testH; i++) {
+            for (int j = 0; j < testH; j++) {
+                int masterIndex = (i + testY0) * w + (j + testX0);
+                int testIndex = i * testW + j;
+                int masterPixel = masterArgb[masterIndex];
+                int testPixel = testArgb[testIndex];
+                assertEquals(masterPixel, testPixel, label);
+            }
+        }
+
+    }
+
+    /**
+     * Verify that TIFF files using JPEG compression provide a pixel-by-pixel
+     * match with source files that use a lossless compression.
+     */
+    @Test
+    public void fullPixelMatchTest() {
+
+        try {
+            // testSet1 is more comprehensive than testSet0 and
+            // would be sufficient to cover all cases.  The test files for testSet0
+            // are simpler and might be more useful for debugging
+            processTestSet(testSet0);
+            processTestSet(testSet1);
+
+            // test set 2 includes a TIFF-specific alpha channel
+            processTestSet(testSet2);
+        } catch (IOException ioex) {
+            fail(""I/O Exception during test "" + ioex.getMessage());
+        }
+
+    }
+
+    /**
+     * Verify that a sub-image extraction supports a pixel-by-pixel match
+     * with the full image extraction.
+     */
+    @Test
+    public void subImageTest() {
+        try {
+            performSubImageTest(""TestJpegProgressive.tiff""); // strips
+            performSubImageTest(""TestJpegTiles264x264.tiff""); // tiles
+        } catch (IOException ioex) {
+            fail(""I/O Exception during test "" + ioex.getMessage());","[{'comment': ""That's not needed at all, just let the test percolate the exception to JUnit."", 'commenter': 'garydgregory'}]"
334,src/test/java/org/apache/commons/imaging/formats/tiff/TiffJpegTest.java,"@@ -0,0 +1,185 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.imaging.formats.tiff;
+
+import java.awt.image.BufferedImage;
+import java.io.File;
+import java.io.IOException;
+import org.apache.commons.imaging.Imaging;
+
+import org.apache.commons.imaging.ImagingTestConstants;
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.fail;
+import org.junit.jupiter.api.Test;
+
+/**
+ * Reads files in the BigTIFF samples folder and compares the
+ * BigTIFF files against the standard ""classic"" tiff image.
+ */
+public class TiffJpegTest extends TiffBaseTest {
+
+    static final String[] testSet0 = {
+        ""TestSample.tiff"",
+        ""TestJpegStrips.tiff"",
+        ""TestJpegTiles.tiff"",
+        ""TestJpegStripsRgb.tiff"",
+        ""TestJpegTilesRgb.tiff"",
+        ""TestJpegCMYK.tiff"",};
+
+    static final String[] testSet1 = {
+        ""TestSample264x264.tiff"",
+        ""TestJpegStrips264x264.tiff"",
+        ""TestJpegStrips264x264BigEndian.tiff"",
+        ""TestJpegTiles264x264.tiff"",
+        ""TestJpegTiles264x264BigEndian.tiff"",};
+
+    static final String[] testSet2 = {
+        ""TestSampleArgb.tiff"",
+        ""TestJpegArgb.tiff"",};
+
+    private File getTiffFile(String name) {
+        final File tiffFolder = new File(ImagingTestConstants.TEST_IMAGE_FOLDER, ""tiff"");
+        final File tiffJpegFolder = new File(tiffFolder, ""14"");
+        return new File(tiffJpegFolder, name);
+    }
+
+    private int gray(int argb) {
+        int r = (argb >> 16) & 0xff;
+        int g = (argb >> 8) & 0xff;
+        int b = argb & 0xff;
+        return (int) (0.299 * r + 0.587 * g + 0.114 * b + 0.5);
+    }
+
+    /**
+     * Process a set of files using the first name in the array as
+     * the master image and comparing all subsequent files against its
+     * content on a pixel-by-pixel bases. The first name will usually be
+     * a TIFF file that is stored using a non-lossy compression format
+     * (something other than JPEG). All subsequent files will use
+     * JPEG based compression with an alternate geometry (strips, tiles, etc.).
+     * Because JPEG is lossy, we define a match as values of pixels that
+     * produce gray tones withing a threshold.
+     *
+     * @param testSet an array of 2 or more TIFF file names
+     * @throws IOException in the event of an unexpected I/O exception
+     */
+    private void processTestSet(String[] testSet) throws IOException {
+        File masterFile = getTiffFile(testSet[0]);
+        BufferedImage masterImage = Imaging.getBufferedImage(masterFile);
+        int w = masterImage.getWidth();
+        int h = masterImage.getHeight();
+        int[] masterArgb = new int[w * h];
+        masterImage.getRGB(0, 0, w, h, masterArgb, 0, w);
+
+        int[] masterGray = new int[w * h];
+        for (int i = 0; i < masterArgb.length; i++) {
+            masterGray[i] = gray(masterArgb[i]);
+        }
+
+        for (int iFile = 1; iFile < testSet.length; iFile++) {
+            String name = testSet[iFile];
+            File f = getTiffFile(name);
+            BufferedImage test = Imaging.getBufferedImage(f);
+            int testW = test.getWidth();
+            int testH = test.getHeight();
+            assertEquals(w, testW, ""Width mismatch for "" + name);
+            assertEquals(h, testH, ""Height mismatch for "" + name);
+
+            String label = ""Pixel match for "" + name;
+            int[] testArgb = new int[w * h];
+            test.getRGB(0, 0, w, h, testArgb, 0, w);
+            for (int i = 0; i < testArgb.length; i++) {
+                int testGray = gray(testArgb[i]);
+                int masterA = masterArgb[i] >>> 24;
+                int testA = testArgb[i] >>> 24;
+                assertEquals(masterA, testA, 1, label);
+                assertEquals(masterGray[i], testGray, 4, label);
+            }
+        }
+    }
+
+    void performSubImageTest(String name) throws IOException {
+        // get the full image to be used as a basis for comparison
+        File target = getTiffFile(name);
+        BufferedImage master = Imaging.getBufferedImage(target);
+        int w = master.getWidth();
+        int h = master.getHeight();
+        int[] masterArgb = new int[w * h];
+        master.getRGB(0, 0, w, h, masterArgb, 0, w);
+
+        // Get a subimage
+        TiffImageParser tiffImageParser = new TiffImageParser();
+        TiffImagingParameters params = new TiffImagingParameters();
+        int testX0 = 11;
+        int testY0 = 11;
+        int testW = w - testX0 - 1;
+        int testH = h - testY0 - 1;
+        params.setSubImage(testX0, testY0, testW, testH);
+
+        BufferedImage test = tiffImageParser.getBufferedImage(target, params);
+        int[] testArgb = new int[testW * testH];
+        test.getRGB(0, 0, testW, testH, testArgb, 0, testW);
+        String label = ""Pixel mismatch for "" + name;
+        for (int i = 0; i < testH; i++) {
+            for (int j = 0; j < testH; j++) {
+                int masterIndex = (i + testY0) * w + (j + testX0);
+                int testIndex = i * testW + j;
+                int masterPixel = masterArgb[masterIndex];
+                int testPixel = testArgb[testIndex];
+                assertEquals(masterPixel, testPixel, label);
+            }
+        }
+
+    }
+
+    /**
+     * Verify that TIFF files using JPEG compression provide a pixel-by-pixel
+     * match with source files that use a lossless compression.
+     */
+    @Test
+    public void fullPixelMatchTest() {
+
+        try {
+            // testSet1 is more comprehensive than testSet0 and
+            // would be sufficient to cover all cases.  The test files for testSet0
+            // are simpler and might be more useful for debugging
+            processTestSet(testSet0);
+            processTestSet(testSet1);
+
+            // test set 2 includes a TIFF-specific alpha channel
+            processTestSet(testSet2);
+        } catch (IOException ioex) {
+            fail(""I/O Exception during test "" + ioex.getMessage());","[{'comment': ""That's not needed at all, just let the test percolate the exception to JUnit."", 'commenter': 'garydgregory'}]"
334,src/test/java/org/apache/commons/imaging/formats/tiff/TiffJpegTest.java,"@@ -0,0 +1,185 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.imaging.formats.tiff;
+
+import java.awt.image.BufferedImage;
+import java.io.File;
+import java.io.IOException;
+import org.apache.commons.imaging.Imaging;
+
+import org.apache.commons.imaging.ImagingTestConstants;
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.fail;
+import org.junit.jupiter.api.Test;
+
+/**
+ * Reads files in the BigTIFF samples folder and compares the
+ * BigTIFF files against the standard ""classic"" tiff image.
+ */
+public class TiffJpegTest extends TiffBaseTest {
+
+    static final String[] testSet0 = {
+        ""TestSample.tiff"",
+        ""TestJpegStrips.tiff"",
+        ""TestJpegTiles.tiff"",
+        ""TestJpegStripsRgb.tiff"",
+        ""TestJpegTilesRgb.tiff"",
+        ""TestJpegCMYK.tiff"",};
+
+    static final String[] testSet1 = {
+        ""TestSample264x264.tiff"",
+        ""TestJpegStrips264x264.tiff"",
+        ""TestJpegStrips264x264BigEndian.tiff"",
+        ""TestJpegTiles264x264.tiff"",
+        ""TestJpegTiles264x264BigEndian.tiff"",};
+
+    static final String[] testSet2 = {
+        ""TestSampleArgb.tiff"",
+        ""TestJpegArgb.tiff"",};
+
+    private File getTiffFile(String name) {
+        final File tiffFolder = new File(ImagingTestConstants.TEST_IMAGE_FOLDER, ""tiff"");
+        final File tiffJpegFolder = new File(tiffFolder, ""14"");
+        return new File(tiffJpegFolder, name);
+    }
+
+    private int gray(int argb) {
+        int r = (argb >> 16) & 0xff;
+        int g = (argb >> 8) & 0xff;
+        int b = argb & 0xff;
+        return (int) (0.299 * r + 0.587 * g + 0.114 * b + 0.5);
+    }
+
+    /**
+     * Process a set of files using the first name in the array as
+     * the master image and comparing all subsequent files against its
+     * content on a pixel-by-pixel bases. The first name will usually be
+     * a TIFF file that is stored using a non-lossy compression format
+     * (something other than JPEG). All subsequent files will use
+     * JPEG based compression with an alternate geometry (strips, tiles, etc.).
+     * Because JPEG is lossy, we define a match as values of pixels that
+     * produce gray tones withing a threshold.
+     *
+     * @param testSet an array of 2 or more TIFF file names
+     * @throws IOException in the event of an unexpected I/O exception
+     */
+    private void processTestSet(String[] testSet) throws IOException {
+        File masterFile = getTiffFile(testSet[0]);
+        BufferedImage masterImage = Imaging.getBufferedImage(masterFile);
+        int w = masterImage.getWidth();
+        int h = masterImage.getHeight();
+        int[] masterArgb = new int[w * h];
+        masterImage.getRGB(0, 0, w, h, masterArgb, 0, w);
+
+        int[] masterGray = new int[w * h];
+        for (int i = 0; i < masterArgb.length; i++) {
+            masterGray[i] = gray(masterArgb[i]);
+        }
+
+        for (int iFile = 1; iFile < testSet.length; iFile++) {
+            String name = testSet[iFile];
+            File f = getTiffFile(name);
+            BufferedImage test = Imaging.getBufferedImage(f);
+            int testW = test.getWidth();
+            int testH = test.getHeight();
+            assertEquals(w, testW, ""Width mismatch for "" + name);
+            assertEquals(h, testH, ""Height mismatch for "" + name);
+
+            String label = ""Pixel match for "" + name;
+            int[] testArgb = new int[w * h];
+            test.getRGB(0, 0, w, h, testArgb, 0, w);
+            for (int i = 0; i < testArgb.length; i++) {
+                int testGray = gray(testArgb[i]);
+                int masterA = masterArgb[i] >>> 24;
+                int testA = testArgb[i] >>> 24;
+                assertEquals(masterA, testA, 1, label);
+                assertEquals(masterGray[i], testGray, 4, label);
+            }
+        }
+    }
+
+    void performSubImageTest(String name) throws IOException {
+        // get the full image to be used as a basis for comparison
+        File target = getTiffFile(name);
+        BufferedImage master = Imaging.getBufferedImage(target);
+        int w = master.getWidth();
+        int h = master.getHeight();
+        int[] masterArgb = new int[w * h];
+        master.getRGB(0, 0, w, h, masterArgb, 0, w);
+
+        // Get a subimage
+        TiffImageParser tiffImageParser = new TiffImageParser();
+        TiffImagingParameters params = new TiffImagingParameters();
+        int testX0 = 11;
+        int testY0 = 11;
+        int testW = w - testX0 - 1;
+        int testH = h - testY0 - 1;
+        params.setSubImage(testX0, testY0, testW, testH);
+
+        BufferedImage test = tiffImageParser.getBufferedImage(target, params);
+        int[] testArgb = new int[testW * testH];
+        test.getRGB(0, 0, testW, testH, testArgb, 0, testW);
+        String label = ""Pixel mismatch for "" + name;
+        for (int i = 0; i < testH; i++) {
+            for (int j = 0; j < testH; j++) {
+                int masterIndex = (i + testY0) * w + (j + testX0);
+                int testIndex = i * testW + j;
+                int masterPixel = masterArgb[masterIndex];
+                int testPixel = testArgb[testIndex];
+                assertEquals(masterPixel, testPixel, label);
+            }
+        }
+
+    }
+
+    /**
+     * Verify that TIFF files using JPEG compression provide a pixel-by-pixel
+     * match with source files that use a lossless compression.
+     */
+    @Test
+    public void fullPixelMatchTest() {
+
+        try {
+            // testSet1 is more comprehensive than testSet0 and
+            // would be sufficient to cover all cases.  The test files for testSet0
+            // are simpler and might be more useful for debugging
+            processTestSet(testSet0);
+            processTestSet(testSet1);
+
+            // test set 2 includes a TIFF-specific alpha channel
+            processTestSet(testSet2);
+        } catch (IOException ioex) {
+            fail(""I/O Exception during test "" + ioex.getMessage());
+        }
+
+    }
+
+    /**
+     * Verify that a sub-image extraction supports a pixel-by-pixel match
+     * with the full image extraction.
+     */
+    @Test
+    public void subImageTest() {","[{'comment': 'Please follow the existing style: test methods are prefixed with ""test"" -> ""testSubImageTest()""\r\n', 'commenter': 'garydgregory'}]"
334,src/test/java/org/apache/commons/imaging/formats/tiff/TiffJpegTest.java,"@@ -0,0 +1,185 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.imaging.formats.tiff;
+
+import java.awt.image.BufferedImage;
+import java.io.File;
+import java.io.IOException;
+import org.apache.commons.imaging.Imaging;
+
+import org.apache.commons.imaging.ImagingTestConstants;
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.fail;
+import org.junit.jupiter.api.Test;
+
+/**
+ * Reads files in the BigTIFF samples folder and compares the
+ * BigTIFF files against the standard ""classic"" tiff image.
+ */
+public class TiffJpegTest extends TiffBaseTest {","[{'comment': 'Please name all test classes with a ""Test"" suffix, not a prefix. ', 'commenter': 'garydgregory'}, {'comment': 'Not sure I follow what you\'re driving at in this one.  TiffJpegTest does have the ""Test"" as suffix.  Did you mean ""don\'t change this one when your rename the methods?""', 'commenter': 'gwlucastrig'}, {'comment': 'My mistake, I was looking at the test fixture files. I suppose the word ""Test"" in the fixture file could be considered superfluous. I\'ll leave it up to you as to what the best names are.', 'commenter': 'garydgregory'}]"
334,src/main/java/org/apache/commons/imaging/formats/tiff/datareaders/DataReaderTiled.java,"@@ -258,10 +266,24 @@ public ImageBuilder readImageData(final Rectangle subImageSpecification,
             for (int iCol = col0; iCol <= col1; iCol++) {
                 final int tile = iRow * nColumnsOfTiles + iCol;
                 final byte[] compressed = imageData.tiles[tile].getData();
-                final byte[] decompressed = decompress(compressed, compression,
-                        bytesPerTile, tileWidth, tileLength);
                 final int x = iCol * tileWidth - x0;
                 final int y = iRow * tileLength - y0;
+                // November 2023 changes to handle JPEG based compression","[{'comment': 'We don\'t need timestamps in comments IMO: ""// Handle JPEG based compression""', 'commenter': 'garydgregory'}]"
334,src/test/data/images/tiff/14/README.txt,"@@ -0,0 +1,58 @@
+","[{'comment': ""Test fixtures belong in the test resource folder `src\\test\\resources\\images`, not here. I'll clean up the other files soon."", 'commenter': 'garydgregory'}]"
334,src/main/java/org/apache/commons/imaging/formats/jpeg/decoder/JpegDecoder.java,"@@ -452,9 +454,21 @@ public void visitSos(final int marker, final byte[] markerBytes, final byte[] im
             Allocator.check(Integer.BYTES * sofnSegment.width * sofnSegment.height);
             switch (sofnSegment.numberOfComponents) {
             case 4:
-                colorModel = new DirectColorModel(24, 0x00ff0000, 0x0000ff00, 0x000000ff);
-                final int[] bandMasks = { 0x00ff0000, 0x0000ff00, 0x000000ff };
-                raster = Raster.createPackedRaster(DataBuffer.TYPE_INT, sofnSegment.width, sofnSegment.height, bandMasks, null);
+                // Special handling for the application-RGB case:  TIFF files with
+                // JPEG compression can support an alpha channel.  This extension
+                // to the JPEG standard is implemented by specifying a color model
+                // with a fourth channel for alpha.
+                if (useTiffRgb) {
+                    colorModel = new DirectColorModel(32, 0x00ff0000, 0x0000ff00, 0x000000ff, 0xff000000);
+                    final int[] bandMasks = {0x00ff0000, 0x0000ff00, 0x000000ff, 0xff000000};","[{'comment': 'This looks like it should be a constant.', 'commenter': 'garydgregory'}, {'comment': 'These do operate as constants, so I will define these masks as static final constants. I wanted to change as little code as possible and maintain the coding style used in the original.  Should I also modify the legacy code?', 'commenter': 'gwlucastrig'}, {'comment': 'If these constants can be refactored, sure. If that refactoring touches a lot of files, consider doing the clean-up in a new PR to make this one a smaller revert/bisect point if we need that in the future. TY!', 'commenter': 'garydgregory'}]"
334,src/main/java/org/apache/commons/imaging/formats/jpeg/decoder/JpegDecoder.java,"@@ -452,9 +454,21 @@ public void visitSos(final int marker, final byte[] markerBytes, final byte[] im
             Allocator.check(Integer.BYTES * sofnSegment.width * sofnSegment.height);
             switch (sofnSegment.numberOfComponents) {
             case 4:
-                colorModel = new DirectColorModel(24, 0x00ff0000, 0x0000ff00, 0x000000ff);
-                final int[] bandMasks = { 0x00ff0000, 0x0000ff00, 0x000000ff };
-                raster = Raster.createPackedRaster(DataBuffer.TYPE_INT, sofnSegment.width, sofnSegment.height, bandMasks, null);
+                // Special handling for the application-RGB case:  TIFF files with
+                // JPEG compression can support an alpha channel.  This extension
+                // to the JPEG standard is implemented by specifying a color model
+                // with a fourth channel for alpha.
+                if (useTiffRgb) {
+                    colorModel = new DirectColorModel(32, 0x00ff0000, 0x0000ff00, 0x000000ff, 0xff000000);
+                    final int[] bandMasks = {0x00ff0000, 0x0000ff00, 0x000000ff, 0xff000000};
+                    raster = Raster.createPackedRaster(DataBuffer.TYPE_INT, sofnSegment.width, sofnSegment.height, bandMasks, null);
+                } else {
+                    colorModel = new DirectColorModel(24, 0x00ff0000, 0x0000ff00, 0x000000ff);
+                    final int[] bandMasks = {0x00ff0000, 0x0000ff00, 0x000000ff};","[{'comment': 'This looks like it should be a constant.', 'commenter': 'garydgregory'}]"
334,src/main/java/org/apache/commons/imaging/formats/tiff/datareaders/DataInterpreterJpeg.java,"@@ -0,0 +1,146 @@
+/* --------------------------------------------------------------------
+ * Copyright (C) 2023  Gary W. Lucas.","[{'comment': ""Is this copyright really necessary? If you leave it in, I'll have to go check and see if we need a notice file update and whatever other legalese is involved."", 'commenter': 'garydgregory'}, {'comment': ""Sorry.  That copyright has absolutely no business being in the code.  My IDE inserted it and I didn't notice.  Will fix."", 'commenter': 'gwlucastrig'}]"
334,src/main/java/org/apache/commons/imaging/formats/jpeg/decoder/JpegDecoder.java,"@@ -46,6 +46,10 @@
 import org.apache.commons.imaging.formats.jpeg.segments.SosSegment;
 
 public class JpegDecoder extends BinaryFileParser implements JpegUtils.Visitor {
+
+    private static final int [] BAND_MASK_ARGB = {0x00ff0000, 0x0000ff00, 0x000000ff, 0xff000000};","[{'comment': 'OK, you define the constants but do not use them. What am I missing?', 'commenter': 'garydgregory'}, {'comment': 'Oops.  I used them on lines 468 and 472.  But I neglected to remove the old lines on 467 and 471.  Will submit and additional change.', 'commenter': 'gwlucastrig'}]"
337,src/test/java/org/apache/commons/imaging/formats/tiff/TiffReadImageInfoTest.java,"@@ -0,0 +1,90 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.imaging.formats.tiff;
+
+import java.io.File;
+import org.apache.commons.imaging.ImageInfo;
+import org.apache.commons.imaging.Imaging;
+import org.apache.commons.imaging.ImagingTestConstants;
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import org.junit.jupiter.api.Test;
+
+/**
+ * Performs a test on the ImageInfo returned from TIFF to confirm
+ * that it contains the specified value for a particular target.
+ * This test is used to confirm that the TiffImageParser is correctly
+ * interpreting the ImageInfo values.
+ */
+public class TiffReadImageInfoTest extends TiffBaseTest {
+
+    // The form of the test set is
+    //    0.   target file name
+    //    1.   Parameter field in ImageInfo
+    //    2.   Expected value
+    static final String[][] testSet = {
+        {""1/matthew2.tif"", ""Color Type"", ""Black and White""},
+        {""7/Oregon Scientific DS6639 - DSC_0307 - small - CMYK.tiff"", ""Color Type"", ""CMYK""},
+        {""10/Imaging247.tiff"", ""Uses Palette"", ""true""},
+        {""12/TransparencyTestStripAssociated.tif"", ""Is Transparent"", ""true""},
+        {""14/TestJpegStrips.tiff"", ""Color Type"", ""YCbCr""}
+","[{'comment': 'No need for extra whitespace.', 'commenter': 'garydgregory'}, {'comment': 'done', 'commenter': 'gwlucastrig'}]"
337,src/test/java/org/apache/commons/imaging/formats/tiff/TiffReadImageInfoTest.java,"@@ -0,0 +1,90 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.imaging.formats.tiff;
+
+import java.io.File;
+import org.apache.commons.imaging.ImageInfo;
+import org.apache.commons.imaging.Imaging;
+import org.apache.commons.imaging.ImagingTestConstants;
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import org.junit.jupiter.api.Test;
+
+/**
+ * Performs a test on the ImageInfo returned from TIFF to confirm
+ * that it contains the specified value for a particular target.
+ * This test is used to confirm that the TiffImageParser is correctly
+ * interpreting the ImageInfo values.
+ */
+public class TiffReadImageInfoTest extends TiffBaseTest {
+
+    // The form of the test set is
+    //    0.   target file name
+    //    1.   Parameter field in ImageInfo
+    //    2.   Expected value
+    static final String[][] testSet = {
+        {""1/matthew2.tif"", ""Color Type"", ""Black and White""},
+        {""7/Oregon Scientific DS6639 - DSC_0307 - small - CMYK.tiff"", ""Color Type"", ""CMYK""},
+        {""10/Imaging247.tiff"", ""Uses Palette"", ""true""},
+        {""12/TransparencyTestStripAssociated.tif"", ""Is Transparent"", ""true""},
+        {""14/TestJpegStrips.tiff"", ""Color Type"", ""YCbCr""}
+
+    };
+
+    /**
+     * Gets the value for the target data field within the ImageInfo string.
+     * This method expects data fields to be given in the form:
+     * parameter name, colon, value, end-of-line
+     *
+     * @param info a valid instance obtained from TiffImageParser
+     * @param target the target data field string
+     * @return the value
+     */
+    private String getValue(ImageInfo info, String target) {
+        String s = info.toString();
+        int i = s.indexOf(target);
+        if (i < 0) {
+            return """";
+        }
+        int j = s.indexOf(':', i);
+        if (j < 0) {
+            return """";
+        }
+        int k = s.indexOf('\n', j);
+        if (k < j) {
+            return """";
+        }
+        String q = s.substring(j + 1, k).trim();","[{'comment': 'No need for `q` local variable.', 'commenter': 'garydgregory'}, {'comment': 'done', 'commenter': 'gwlucastrig'}]"
337,src/test/java/org/apache/commons/imaging/formats/tiff/TiffReadImageInfoTest.java,"@@ -0,0 +1,90 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.imaging.formats.tiff;
+
+import java.io.File;
+import org.apache.commons.imaging.ImageInfo;
+import org.apache.commons.imaging.Imaging;
+import org.apache.commons.imaging.ImagingTestConstants;
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import org.junit.jupiter.api.Test;
+
+/**
+ * Performs a test on the ImageInfo returned from TIFF to confirm
+ * that it contains the specified value for a particular target.
+ * This test is used to confirm that the TiffImageParser is correctly
+ * interpreting the ImageInfo values.
+ */
+public class TiffReadImageInfoTest extends TiffBaseTest {
+
+    // The form of the test set is
+    //    0.   target file name
+    //    1.   Parameter field in ImageInfo
+    //    2.   Expected value
+    static final String[][] testSet = {
+        {""1/matthew2.tif"", ""Color Type"", ""Black and White""},
+        {""7/Oregon Scientific DS6639 - DSC_0307 - small - CMYK.tiff"", ""Color Type"", ""CMYK""},
+        {""10/Imaging247.tiff"", ""Uses Palette"", ""true""},
+        {""12/TransparencyTestStripAssociated.tif"", ""Is Transparent"", ""true""},
+        {""14/TestJpegStrips.tiff"", ""Color Type"", ""YCbCr""}
+
+    };
+
+    /**
+     * Gets the value for the target data field within the ImageInfo string.
+     * This method expects data fields to be given in the form:
+     * parameter name, colon, value, end-of-line
+     *
+     * @param info a valid instance obtained from TiffImageParser
+     * @param target the target data field string
+     * @return the value
+     */
+    private String getValue(ImageInfo info, String target) {
+        String s = info.toString();","[{'comment': 'Use final where you can.', 'commenter': 'garydgregory'}, {'comment': 'done', 'commenter': 'gwlucastrig'}]"
