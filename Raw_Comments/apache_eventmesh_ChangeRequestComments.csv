Pull,Path,Diff_hunk,Comment
307,README.md,"@@ -66,27 +74,38 @@ The protocol of eventmesh is easier and convenient, you can read more [here](doc
 |         |Support MQTT protocol|
 
 ## Quick Start
+
 1. Build and deploy event-store(RocketMQ), see [instruction](https://rocketmq.apache.org/docs/quick-start/).
-2. Build and deploy eventmesh-runtime, see instruction ['eventmesh-runtime quickstart'](docs/en/instructions/eventmesh-runtime-quickstart.md).
-3. Run eventmesh-sdk-java demo, see instruction ['eventmesh-sdk-java quickstart'](docs/en/instructions/eventmesh-sdk-java-quickstart.md). 
+2. Build and deploy eventmesh-runtime, see
+   instruction ['eventmesh-runtime quickstart'](docs/en/instructions/eventmesh-runtime-quickstart.md).
+3. Run eventmesh-sdk-java demo, see
+   instruction ['eventmesh-sdk-java quickstart'](docs/en/instructions/eventmesh-sdk-java-quickstart.md).
 
 ## Contributing
+
 Contributions are always welcomed! Please see [CONTRIBUTING](CONTRIBUTING.md) for detailed guidelines.
 
-You can start with the issues labeled with good first issue. 
+You can start with the issues labeled with good first issue.
 [GitHub Issues](https://github.com/WeBankFinTech/EventMesh/issues)
 
 ## License
+
 [Apache License, Version 2.0](http://www.apache.org/licenses/LICENSE-2.0.html) Copyright (C) Apache Software Foundation.
 
 ## Community
+
 WeChat group：
 
 ![wechat_qr](docs/images/mesh-helper.png)
 
 Mailing Lists:
-| Name | Description |Subscribe	|Unsubscribe|Archive
-| ----    | ----    |----    | ----    | ----    |
-|Users	|User support and questions mailing list|	[Subscribe](mailto:users-subscribe@eventmesh.incubator.apache.org)	|[Unsubscribe](mailto:users-unsubscribe@eventmesh.incubator.apache.org)	|[Mail Archives](https://lists.apache.org/list.html?users@eventmesh.apache.org)|
-|Development	|Development related discussions|	[Subscribe](mailto:dev-subscribe@eventmesh.incubator.apache.org)	|[Unsubscribe](mailto:dev-unsubscribe@eventmesh.incubator.apache.org)	|[Mail Archives](https://lists.apache.org/list.html?dev@eventmesh.apache.org)|
-|Commits	|All commits to repositories|	[Subscribe](mailto:commits-subscribe@eventmesh.incubator.apache.org)	|[Unsubscribe](mailto:commits-unsubscribe@eventmesh.incubator.apache.org)	|[Mail Archives](https://lists.apache.org/list.html?commits@eventmesh.apache.org)|
+| Name | Description |Subscribe |Unsubscribe|Archive | ---- | ---- |---- | ---- | ---- | |Users |User support and","[{'comment': 'here need a new line character, not append  **|Name|** to **Mailing Lists:**', 'commenter': 'xwm1992'}]"
319,eventmesh-runtime/src/main/java/org/apache/eventmesh/runtime/configuration/CommonConfiguration.java,"@@ -15,10 +15,10 @@
 // * limitations under the License.
 // */
 //
-//package org.apache.runtime.configuration;
+//package com.webank.runtime.configuration;
 //
 //import com.google.common.base.Preconditions;
-//import org.apache.runtime.util.EventMeshUtil;
+//import com.webank.runtime.util.EventMeshUtil;","[{'comment': 'here still com.webank', 'commenter': 'xwm1992'}, {'comment': 'Yes, I have noticed that. But I think there is no ""org.apache.runtime"" package...', 'commenter': 'SteveYurongSu'}, {'comment': ""If the class is useless, we'd better remove it :D"", 'commenter': 'SteveYurongSu'}, {'comment': 'Ok, you can remove these classes later', 'commenter': 'xwm1992'}]"
319,eventmesh-runtime/src/main/java/org/apache/eventmesh/runtime/configuration/ConfigurationWraper.java,"@@ -15,7 +15,7 @@
 // * limitations under the License.
 // */
 //
-//package org.apache.runtime.configuration;
+//package com.webank.runtime.configuration;","[{'comment': 'Similar to the above', 'commenter': 'xwm1992'}]"
319,eventmesh-runtime/src/main/java/org/apache/eventmesh/runtime/domain/ConsumeRequest.java,"@@ -14,7 +14,7 @@
 // * See the License for the specific language governing permissions and
 // * limitations under the License.
 // */
-//package org.apache.runtime.domain;
+//package com.webank.runtime.domain;","[{'comment': 'Similar to the above', 'commenter': 'xwm1992'}]"
326,eventmesh-common/build.gradle,"@@ -73,18 +73,18 @@ dependencies {
     testCompile apache_commons, httpclient, guava, netty, fastjson, jackson
 }
 
-uploadArchives {
-    repositories {
-        mavenDeployer {
-            snapshotRepository(url: 'Your target repo address') {
-                authentication(userName: 'Your user name', password: 'Your password')
-            }
-            repository(url: 'Your target repo address') {
-                authentication(userName: 'Your user name', password: 'Your password')
-            }
-        }
-    }
-}
+//uploadArchives {","[{'comment': 'remove it if no used anymore.', 'commenter': 'wqliang'}]"
326,eventmesh-runtime/build.gradle,"@@ -146,15 +141,15 @@ task tar(type: Tar, dependsOn: ['clean', 'jar']) {
     }
 }
 
-uploadArchives {
-    repositories {
-        mavenDeployer {
-            snapshotRepository(url: 'Your target repo address') {
-                authentication(userName: 'Your user name', password: 'Your password')
-            }
-            repository(url: 'Your target repo address') {
-                authentication(userName: 'Your user name', password: 'Your password')
-            }
-        }
-    }
-}
\ No newline at end of file
+//uploadArchives {","[{'comment': 'remove it if no use anymore.', 'commenter': 'wqliang'}]"
326,eventmesh-connector-api/build.gradle,"@@ -51,18 +51,18 @@ dependencies {
     testCompile group: 'junit', name: 'junit', version: '4.12', open_message
 }
 
-uploadArchives {
-    repositories {
-        mavenDeployer {
-            snapshotRepository(url: 'Your target repo address') {
-                authentication(userName: 'Your user name', password: 'Your password')
-            }
-            repository(url: 'Your target repo address') {
-                authentication(userName: 'Your user name', password: 'Your password')
-            }
-        }
-    }
-}
+//uploadArchives {","[{'comment': 'remove it if no use anymore.', 'commenter': 'wqliang'}]"
326,gradle.properties,"@@ -14,11 +14,17 @@
 # See the License for the specific language governing permissions and
 # limitations under the License.
 #
-group=org.apache.eventmesh
-version=1.2.0-SNAPSHOT
-rocketmqVersion=4.4.0
 jdk=1.8
 snapshot=false
-mavenUserName=
-mavenPassword=
-#org.gradle.java.home=C:\\Program Files\\Java\\jdk1.7.0_67
+group=org.apache.eventmesh
+version=1.2.0-SNAPSHOT
+#40位公钥的最后8位","[{'comment': 'English would be better.', 'commenter': 'wqliang'}]"
345,eventmesh-runtime/src/main/java/org/apache/eventmesh/runtime/core/protocol/http/processor/UnSubscribeProcessor.java,"@@ -131,12 +126,15 @@ public void onResponse(HttpCommand httpCommand) {
 
         synchronized (eventMeshHTTPServer.localClientInfoMapping) {
             boolean isChange = true;
+
+            registerClient(unSubscribeRequestHeader, consumerGroup, unSubTopicList, unSubscribeUrl);
+
             for (String unSubTopic : unSubTopicList) {
                 List<Client> groupTopicClients = eventMeshHTTPServer.localClientInfoMapping.get(consumerGroup + ""@"" + unSubTopic);
                 Iterator<Client> clientIterator = groupTopicClients.iterator();
                 while (clientIterator.hasNext()) {
                     Client client = clientIterator.next();
-                    if (StringUtils.equals(client.ip, ip)) {
+                    if (StringUtils.equals(client.ip, ip) && StringUtils.equals(client.url, unSubscribeUrl)) {","[{'comment': ""**client.ip** here should change to use **client.pid** as for equals condition，here ip represent ip+port and the port is random this equal condition will never reached, and client won't unsubscribe"", 'commenter': 'xwm1992'}, {'comment': 'Thanks @xwm1992 I fixed it by using client.pid instead. Thanks.', 'commenter': 'jinrongluo'}]"
388,eventmesh-sdk-java/src/main/java/org/apache/eventmesh/client/http/consumer/LiteConsumer.java,"@@ -234,7 +237,13 @@ public void run() {
     }
 
     public boolean unsubscribe(List<String> topicList, String url) throws Exception {
-        subscription.removeAll(topicList);
+        Set<String> unSub = new HashSet<>(topicList);
+        for (SubscriptionItem item:subscription) {
+            if (unSub.contains(item.getTopic())) {
+                subscription.remove(item);","[{'comment': 'Here, may cause ConcurrentModification Exception, use iterator may be better, please take a look', 'commenter': 'xwm1992'}]"
431,eventmesh-common/src/main/java/org/apache/eventmesh/common/protocol/http/body/client/HeartbeatResponseBody.java,"@@ -27,13 +27,13 @@
 
 public class HeartbeatResponseBody extends Body {
 
-    //响应码
+    //react code","[{'comment': 'return code may be more appropriate', 'commenter': 'xwm1992'}, {'comment': 'I think we may not need to add comments for each attribute, for example here, the `retCode` can express variable information. And I would probably prefer to rename it to `returnCode` rather than add a comment.', 'commenter': 'ruanwenjun'}]"
431,eventmesh-common/src/main/java/org/apache/eventmesh/common/protocol/http/body/message/ReplyMessageResponseBody.java,"@@ -27,13 +27,13 @@
 
 public class ReplyMessageResponseBody extends Body {
 
-    //响应码
+    //react code","[{'comment': 'same as above', 'commenter': 'xwm1992'}]"
431,eventmesh-common/src/main/java/org/apache/eventmesh/common/protocol/http/body/message/ReplyMessageResponseBody.java,"@@ -27,13 +27,13 @@
 
 public class ReplyMessageResponseBody extends Body {
 
-    //响应码
+    //react code
     private Integer retCode;
 
-    //响应信息
+    //react message","[{'comment': 'response message', 'commenter': 'xwm1992'}]"
431,eventmesh-common/src/main/java/org/apache/eventmesh/common/protocol/http/body/message/SendMessageBatchResponseBody.java,"@@ -27,13 +27,13 @@
 
 public class SendMessageBatchResponseBody extends Body {
 
-    //响应码
+    //react code","[{'comment': 'same as above', 'commenter': 'xwm1992'}, {'comment': 'same as above', 'commenter': 'xwm1992'}]"
431,eventmesh-common/src/main/java/org/apache/eventmesh/common/protocol/http/body/message/SendMessageBatchResponseBody.java,"@@ -27,13 +27,13 @@
 
 public class SendMessageBatchResponseBody extends Body {
 
-    //响应码
+    //react code
     private Integer retCode;
 
-    //响应信息
+    //react message","[{'comment': 'same as above', 'commenter': 'xwm1992'}, {'comment': 'same as above', 'commenter': 'xwm1992'}]"
431,eventmesh-common/src/main/java/org/apache/eventmesh/common/protocol/http/body/message/SendMessageBatchV2ResponseBody.java,"@@ -27,13 +27,13 @@
 
 public class SendMessageBatchV2ResponseBody extends Body {
 
-    //响应码
+    //react code","[{'comment': 'same as above', 'commenter': 'xwm1992'}]"
431,eventmesh-common/src/main/java/org/apache/eventmesh/common/protocol/http/body/message/SendMessageBatchV2ResponseBody.java,"@@ -27,13 +27,13 @@
 
 public class SendMessageBatchV2ResponseBody extends Body {
 
-    //响应码
+    //react code
     private Integer retCode;
 
-    //响应信息
+    //react code","[{'comment': 'same as above', 'commenter': 'xwm1992'}]"
431,eventmesh-common/src/main/java/org/apache/eventmesh/common/protocol/http/common/ClientRetCode.java,"@@ -21,6 +21,7 @@
 
     /**
      * 这个RETRY的意思是 客户端发现投递的消息它没有监听时, 告诉EventMesh 发往下一个, 重试几次以实现灰度 , 预留","[{'comment': 'We may also need to remove this Chinese comment', 'commenter': 'ruanwenjun'}, {'comment': 'Got it.', 'commenter': 'Roc-00'}]"
431,eventmesh-common/src/main/java/org/apache/eventmesh/common/protocol/http/common/ProtocolKey.java,"@@ -24,7 +24,7 @@
     public static final String VERSION = ""Version"";
 
     public static class ClientInstanceKey {
-        ////////////////////////////////////协议层请求方描述///////////
+        ////////////////////////////////////Protocol layer requester description///////////","[{'comment': 'It seems not to be a good practice using `///////////////////////` in code.', 'commenter': 'ruanwenjun'}, {'comment': 'what about this“//Protocol layer requester description//”?', 'commenter': 'Roc-00'}, {'comment': 'I think it might be better not use symbols in comments, the book 《Clean code》 suggests that we should use the simplest comments.\r\nBut this is just programming style.', 'commenter': 'ruanwenjun'}]"
463,eventmesh-runtime/src/main/java/org/apache/eventmesh/runtime/core/protocol/tcp/client/session/push/retry/EventMeshTcpRetryer.java,"@@ -76,15 +75,18 @@ public void pushRetry(DownStreamMsgContext downStreamMsgContext) {
             return;
         }
 
-        int maxRetryTimes = SubcriptionType.SYNC.equals(downStreamMsgContext.subscriptionItem.getType()) ? 1 : eventMeshTCPServer.getEventMeshTCPConfiguration().eventMeshTcpMsgRetryTimes;
+        int maxRetryTimes = SubcriptionType.SYNC.equals(downStreamMsgContext.subscriptionItem.getType())
+                ? eventMeshTCPServer.getEventMeshTCPConfiguration().eventMeshTcpMsgSyncRetryTimes
+                : eventMeshTCPServer.getEventMeshTCPConfiguration().eventMeshTcpMsgAsyncRetryTimes;
         if (downStreamMsgContext.retryTimes >= maxRetryTimes) {
-            logger.warn(""pushRetry fail,retry over maxRetryTimes:{}, retryTimes:{}, seq:{}, bizSeq:{}"", maxRetryTimes, downStreamMsgContext.retryTimes,
-                    downStreamMsgContext.seq, EventMeshUtil.getMessageBizSeq(downStreamMsgContext.msgExt));
+            logger.warn(""pushRetry fail,retry over maxRetryTimes:{}, pushType: {}, retryTimes:{}, seq:{}, bizSeq:{}"", downStreamMsgContext.subscriptionItem.getType(),","[{'comment': ""log args position isn't correct"", 'commenter': 'xwm1992'}, {'comment': 'Thanks, done', 'commenter': 'ruanwenjun'}]"
485,eventmesh-runtime/conf/eventmesh.properties,"@@ -56,4 +56,8 @@ eventMesh.server.registry.fetchRegistryAddrIntervalInMills=20000
 #eventMesh.server.defibus.client.comsumeTimeoutInMin=5
 
 #connector plugin
-eventMesh.connector.plugin.type=rocketmq
\ No newline at end of file
+eventMesh.connector.plugin.type=rocketmq
+
+#acl plugin
+eventMesh.server.acl.enabled=false
+eventMesh.acl.plugin.type=acl","[{'comment': 'eventMesh.server.security.enabled & eventMesh.security.plugin.type maybe better', 'commenter': 'xwm1992'}, {'comment': 'OK， I will adjust it.', 'commenter': 'lrhkobe'}]"
485,eventmesh-common/src/main/java/org/apache/eventmesh/common/config/CommonConfiguration.java,"@@ -29,23 +29,13 @@
     public String eventMeshName = """";
     public String sysID = ""5477"";
     public String eventMeshConnectorPluginType = ""rocketmq"";
+    public String eventMeshAclPluginType = ""acl"";","[{'comment': 'eventMeshAclPluginType -> eventMeshSecurityPluginType is better', 'commenter': 'xwm1992'}, {'comment': 'OK， I will adjust it.', 'commenter': 'lrhkobe'}]"
485,eventmesh-common/src/main/java/org/apache/eventmesh/common/config/CommonConfiguration.java,"@@ -29,23 +29,13 @@
     public String eventMeshName = """";
     public String sysID = ""5477"";
     public String eventMeshConnectorPluginType = ""rocketmq"";
+    public String eventMeshAclPluginType = ""acl"";
 
     public String namesrvAddr = """";
-    public String clientUserName = ""username"";
-    public String clientPass = ""user@123"";
-    public Integer consumeThreadMin = 2;
-    public Integer consumeThreadMax = 2;
-    public Integer consumeQueueSize = 10000;
-    public Integer pullBatchSize = 32;
-    public Integer ackWindow = 1000;
-    public Integer pubWindow = 100;
-    public long consumeTimeout = 0L;
-    public Integer pollNameServerInteval = 10 * 1000;
-    public Integer heartbeatBrokerInterval = 30 * 1000;
-    public Integer rebalanceInterval = 20 * 1000;
     public Integer eventMeshRegisterIntervalInMills = 10 * 1000;
     public Integer eventMeshFetchRegistryAddrInterval = 10 * 1000;
     public String eventMeshServerIp = null;
+    public boolean eventMeshServerAclEnable = false;","[{'comment': 'like above', 'commenter': 'xwm1992'}]"
487,eventmesh-protocol-plugin/eventmesh-protocol-tcp/src/main/resources/eventmesh-protocol-tcp.yml,"@@ -0,0 +1,74 @@
+#
+# Licensed to the Apache Software Foundation (ASF) under one or more
+# contributor license agreements.  See the NOTICE file distributed with
+# this work for additional information regarding copyright ownership.
+# The ASF licenses this file to You under the Apache License, Version 2.0
+# (the ""License""); you may not use this file except in compliance with
+# the License.  You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an ""AS IS"" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+eventMesh:","[{'comment': ""this file's configuration is same with http, please have a look"", 'commenter': 'xwm1992'}, {'comment': 'Thanks, done', 'commenter': 'ruanwenjun'}]"
487,eventmesh-protocol-plugin/eventmesh-protocol-api/build.gradle,"@@ -0,0 +1,36 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+dependencies {
+    api project("":eventmesh-connector-plugin:eventmesh-connector-api"")","[{'comment': 'these two dependencies `connector-api` and `registry-api`  may be change to `"":eventmesh-spi""` and  `"":eventmesh-common""`', 'commenter': 'xwm1992'}]"
487,eventmesh-protocol-plugin/eventmesh-protocol-http/build.gradle,"@@ -0,0 +1,26 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+dependencies {
+    api project("":eventmesh-protocol-plugin:eventmesh-protocol-api"")
+    api project("":eventmesh-security-plugin:eventmesh-security-api"")","[{'comment': 'can we split the security plugin from the http protocol , integrate the plugin on runtime ', 'commenter': 'xwm1992'}]"
507,eventmesh-connector-plugin/eventmesh-connector-standalone/src/main/java/org/apache/eventmesh/connector/standalone/broker/MessageQueue.java,"@@ -0,0 +1,219 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.eventmesh.connector.standalone.broker;
+
+import com.google.common.base.Preconditions;
+import org.apache.eventmesh.connector.standalone.broker.model.MessageEntity;
+
+import java.util.concurrent.locks.Condition;
+import java.util.concurrent.locks.ReentrantLock;
+
+/**
+ * This is a block queue, can get entity by offset.
+ * The queue is a FIFO data structure.
+ */
+public class MessageQueue {
+
+    public MessageEntity[] items;
+
+    private int takeIndex;
+
+    private int putIndex;
+
+    private int count;
+
+    private ReentrantLock lock;","[{'comment': 'maybe the lock is final is better in this queue.', 'commenter': 'tydhot'}, {'comment': 'Thanks, agree with you.', 'commenter': 'ruanwenjun'}]"
507,eventmesh-connector-plugin/eventmesh-connector-standalone/src/main/java/org/apache/eventmesh/connector/standalone/broker/task/SubScribeTask.java,"@@ -0,0 +1,109 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.eventmesh.connector.standalone.broker.task;
+
+import io.openmessaging.api.AsyncMessageListener;
+import io.openmessaging.api.Message;
+import org.apache.eventmesh.api.EventMeshAction;
+import org.apache.eventmesh.api.EventMeshAsyncConsumeContext;
+import org.apache.eventmesh.connector.standalone.broker.StandaloneBroker;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicInteger;
+
+public class SubScribeTask implements Runnable {
+
+    private String               topicName;
+    private StandaloneBroker     standaloneBroker;
+    private AsyncMessageListener listener;
+    private volatile boolean isRunning;
+
+    private AtomicInteger offset;
+
+    private final Logger logger = LoggerFactory.getLogger(SubScribeTask.class);
+
+    public SubScribeTask(String topicName,
+                         StandaloneBroker standaloneBroker,
+                         AsyncMessageListener listener) {
+        this.topicName = topicName;
+        this.standaloneBroker = standaloneBroker;
+        this.listener = listener;
+        this.isRunning = true;
+    }
+
+    @Override
+    public void run() {
+        while (isRunning) {
+            try {
+                logger.debug(""execute subscribe task, topic: {}, offset: {}"", topicName, offset);
+                if (offset == null) {
+                    Message message = standaloneBroker.getMessage(topicName);
+                    if (message != null) {
+                        offset = new AtomicInteger((int) message.getOffset());
+                    }
+                }
+                if (offset != null) {
+                    Message message = standaloneBroker.getMessage(topicName, offset.get());
+                    if (message != null) {
+                        EventMeshAsyncConsumeContext consumeContext = new EventMeshAsyncConsumeContext() {
+                            @Override
+                            public void commit(EventMeshAction action) {
+                                switch (action) {
+                                    case CommitMessage:
+                                        // update offset
+                                        offset.incrementAndGet();
+                                        logger.info(""message commit, topic: {}, current offset:{}"", topicName, offset.get());
+                                        break;
+                                    case ReconsumeLater:
+                                        // don't update offset
+                                        break;
+                                    case ManualAck:
+                                        // update offset
+                                        offset.incrementAndGet();","[{'comment': ""Here is the ManualAck, shouldn't update the offset after commit the message, there is an acktask in runtime, only client call this task, the offset will be increment, you can refer the `MessageAckTask`"", 'commenter': 'xwm1992'}, {'comment': 'OK, please take a look.', 'commenter': 'ruanwenjun'}]"
514,eventmesh-runtime/src/test/java/org/apache/eventmesh/runtime/cloudevent/CSVFormat.java,"@@ -0,0 +1,107 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an ""AS IS"" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package org.apache.eventmesh.runtime.cloudevent;
+
+import io.cloudevents.CloudEvent;
+import io.cloudevents.SpecVersion;
+import io.cloudevents.core.builder.CloudEventBuilder;
+import io.cloudevents.core.data.BytesCloudEventData;
+import io.cloudevents.core.format.EventFormat;
+import io.cloudevents.rw.CloudEventDataMapper;
+import io.cloudevents.types.Time;
+
+import java.net.URI;
+import java.nio.charset.StandardCharsets;
+import java.time.OffsetDateTime;
+import java.util.Base64;
+import java.util.Collections;
+import java.util.Objects;
+import java.util.Set;
+import java.util.regex.Pattern;
+
+public class CSVFormat implements EventFormat {
+
+    public static final CSVFormat INSTANCE = new CSVFormat();
+
+    @Override
+    public byte[] serialize(CloudEvent event) {
+        return String.join(
+            "","",
+            event.getSpecVersion().toString(),
+            event.getId(),
+            event.getType(),
+            event.getSource().toString(),
+            Objects.toString(event.getDataContentType()),
+            Objects.toString(event.getDataSchema()),
+            Objects.toString(event.getSubject()),
+            event.getTime() != null
+                ? Time.writeTime(event.getTime())
+                : ""null"",
+            event.getData() != null
+                ? new String(Base64.getEncoder().encode(event.getData().toBytes()), StandardCharsets.UTF_8)
+                : ""null""
+        ).getBytes();
+    }
+
+    @Override
+    public CloudEvent deserialize(byte[] bytes, CloudEventDataMapper mapper) {
+        String[] splitted = new String(bytes, StandardCharsets.UTF_8).split(Pattern.quote("",""));","[{'comment': '`Pattern.quote("","")` can be an attribute in CSVFormat.', 'commenter': 'ruanwenjun'}, {'comment': 'just for test ,copied from CloudEvent', 'commenter': 'wangshaojie4039'}]"
514,eventmesh-runtime/src/test/java/org/apache/eventmesh/runtime/cloudevent/CSVFormat.java,"@@ -0,0 +1,107 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an ""AS IS"" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package org.apache.eventmesh.runtime.cloudevent;
+
+import io.cloudevents.CloudEvent;
+import io.cloudevents.SpecVersion;
+import io.cloudevents.core.builder.CloudEventBuilder;
+import io.cloudevents.core.data.BytesCloudEventData;
+import io.cloudevents.core.format.EventFormat;
+import io.cloudevents.rw.CloudEventDataMapper;
+import io.cloudevents.types.Time;
+
+import java.net.URI;
+import java.nio.charset.StandardCharsets;
+import java.time.OffsetDateTime;
+import java.util.Base64;
+import java.util.Collections;
+import java.util.Objects;
+import java.util.Set;
+import java.util.regex.Pattern;
+
+public class CSVFormat implements EventFormat {
+
+    public static final CSVFormat INSTANCE = new CSVFormat();
+
+    @Override
+    public byte[] serialize(CloudEvent event) {
+        return String.join(
+            "","",
+            event.getSpecVersion().toString(),
+            event.getId(),
+            event.getType(),
+            event.getSource().toString(),
+            Objects.toString(event.getDataContentType()),
+            Objects.toString(event.getDataSchema()),
+            Objects.toString(event.getSubject()),
+            event.getTime() != null
+                ? Time.writeTime(event.getTime())
+                : ""null"",
+            event.getData() != null
+                ? new String(Base64.getEncoder().encode(event.getData().toBytes()), StandardCharsets.UTF_8)
+                : ""null""
+        ).getBytes();
+    }
+
+    @Override
+    public CloudEvent deserialize(byte[] bytes, CloudEventDataMapper mapper) {
+        String[] splitted = new String(bytes, StandardCharsets.UTF_8).split(Pattern.quote("",""));
+        SpecVersion sv = SpecVersion.parse(splitted[0]);
+
+        String id = splitted[1];
+        String type = splitted[2];
+        URI source = URI.create(splitted[3]);
+        String datacontenttype = splitted[4].equals(""null"") ? null : splitted[4];","[{'comment': 'It is better to use `""null"".equals(splitted[4])`', 'commenter': 'ruanwenjun'}, {'comment': 'just for test ,copied from CloudEvent', 'commenter': 'wangshaojie4039'}]"
514,eventmesh-runtime/src/main/java/org/apache/eventmesh/runtime/core/protocol/cloudevent/impl/OMSMessageWriter.java,"@@ -0,0 +1,96 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.eventmesh.runtime.core.protocol.cloudevent.impl;
+
+import io.cloudevents.CloudEventData;
+import io.cloudevents.SpecVersion;
+import io.cloudevents.core.format.EventFormat;
+import io.cloudevents.core.message.MessageWriter;
+import io.cloudevents.rw.CloudEventContextWriter;
+import io.cloudevents.rw.CloudEventRWException;
+import io.cloudevents.rw.CloudEventWriter;
+import io.openmessaging.api.Message;
+
+
+public final class OMSMessageWriter<R> implements MessageWriter<CloudEventWriter<Message>, Message>, CloudEventWriter<Message> {","[{'comment': 'It seems we can remove `R` here ? ', 'commenter': 'ruanwenjun'}]"
514,eventmesh-runtime/src/main/java/org/apache/eventmesh/runtime/core/protocol/cloudevent/impl/OMSMessageWriter.java,"@@ -0,0 +1,96 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.eventmesh.runtime.core.protocol.cloudevent.impl;
+
+import io.cloudevents.CloudEventData;
+import io.cloudevents.SpecVersion;
+import io.cloudevents.core.format.EventFormat;
+import io.cloudevents.core.message.MessageWriter;
+import io.cloudevents.rw.CloudEventContextWriter;
+import io.cloudevents.rw.CloudEventRWException;
+import io.cloudevents.rw.CloudEventWriter;
+import io.openmessaging.api.Message;
+
+
+public final class OMSMessageWriter<R> implements MessageWriter<CloudEventWriter<Message>, Message>, CloudEventWriter<Message> {
+
+    private Message message;
+
+
+    public OMSMessageWriter(String topic) {
+        message = new Message();
+        message.setTopic(topic);
+    }
+
+    public OMSMessageWriter(String topic, String key) {
+        message = new Message();
+        message.setTopic(topic);
+        if (key != null && key.length() > 0) {","[{'comment': '```suggestion\r\nif (StringUtils.isNotEmpty(key)) {\r\n```', 'commenter': 'ruanwenjun'}]"
514,eventmesh-runtime/src/main/java/org/apache/eventmesh/runtime/core/protocol/cloudevent/impl/OMSMessageWriter.java,"@@ -0,0 +1,96 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.eventmesh.runtime.core.protocol.cloudevent.impl;
+
+import io.cloudevents.CloudEventData;
+import io.cloudevents.SpecVersion;
+import io.cloudevents.core.format.EventFormat;
+import io.cloudevents.core.message.MessageWriter;
+import io.cloudevents.rw.CloudEventContextWriter;
+import io.cloudevents.rw.CloudEventRWException;
+import io.cloudevents.rw.CloudEventWriter;
+import io.openmessaging.api.Message;
+
+
+public final class OMSMessageWriter<R> implements MessageWriter<CloudEventWriter<Message>, Message>, CloudEventWriter<Message> {
+
+    private Message message;
+
+
+    public OMSMessageWriter(String topic) {
+        message = new Message();
+        message.setTopic(topic);
+    }
+
+    public OMSMessageWriter(String topic, String key) {
+        message = new Message();
+        message.setTopic(topic);
+        if (key != null && key.length() > 0) {
+            message.setKey(key);
+        }
+    }
+
+    public OMSMessageWriter(String topic, String key, String tag) {
+        message = new Message();
+        message.setTopic(topic);
+        if (tag != null && tag.length() > 0) {","[{'comment': '``` suggestion\r\nif (StringUtils.isNotEmpty(tag)) {\r\n```', 'commenter': 'ruanwenjun'}, {'comment': 'ok', 'commenter': 'wangshaojie4039'}]"
514,eventmesh-runtime/src/main/java/org/apache/eventmesh/runtime/core/protocol/cloudevent/impl/OMSMessageWriter.java,"@@ -0,0 +1,96 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.eventmesh.runtime.core.protocol.cloudevent.impl;
+
+import io.cloudevents.CloudEventData;
+import io.cloudevents.SpecVersion;
+import io.cloudevents.core.format.EventFormat;
+import io.cloudevents.core.message.MessageWriter;
+import io.cloudevents.rw.CloudEventContextWriter;
+import io.cloudevents.rw.CloudEventRWException;
+import io.cloudevents.rw.CloudEventWriter;
+import io.openmessaging.api.Message;
+
+
+public final class OMSMessageWriter<R> implements MessageWriter<CloudEventWriter<Message>, Message>, CloudEventWriter<Message> {
+
+    private Message message;
+
+
+    public OMSMessageWriter(String topic) {
+        message = new Message();
+        message.setTopic(topic);
+    }
+
+    public OMSMessageWriter(String topic, String key) {
+        message = new Message();
+        message.setTopic(topic);
+        if (key != null && key.length() > 0) {
+            message.setKey(key);
+        }
+    }
+
+    public OMSMessageWriter(String topic, String key, String tag) {
+        message = new Message();
+        message.setTopic(topic);
+        if (tag != null && tag.length() > 0) {
+            message.setTag(tag);
+        }
+
+        if (key != null && key.length() > 0) {","[{'comment': '```suggestion\r\nif (StringUtils.isNotEmpty(key)) {\r\n```', 'commenter': 'ruanwenjun'}, {'comment': 'ok', 'commenter': 'wangshaojie4039'}]"
514,eventmesh-runtime/src/test/java/org/apache/eventmesh/runtime/cloudevent/Data.java,"@@ -0,0 +1,197 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an ""AS IS"" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package org.apache.eventmesh.runtime.cloudevent;
+
+import io.cloudevents.CloudEvent;
+import io.cloudevents.core.builder.CloudEventBuilder;
+import io.cloudevents.types.Time;
+
+import java.math.BigDecimal;
+import java.net.URI;
+import java.time.OffsetDateTime;
+import java.util.Objects;
+import java.util.stream.Stream;
+
+public class Data {","[{'comment': 'This class just for UT?', 'commenter': 'ruanwenjun'}, {'comment': 'yes, just use to test', 'commenter': 'wangshaojie4039'}, {'comment': 'Ok, no problem.', 'commenter': 'ruanwenjun'}]"
514,build.gradle,"@@ -385,6 +385,9 @@ subprojects {
             dependency ""org.mockito:mockito-core:2.23.0""
             dependency ""org.powermock:powermock-module-junit4:2.0.2""
             dependency ""org.powermock:powermock-api-mockito2:2.0.2""
+            dependency ""io.cloudevents:cloudevents-core:2.2.0""
+            dependency ""org.junit.jupiter:junit-jupiter:5.7.0""","[{'comment': ""To keep the UT code style consistent, it's better not add jupiter dependency in this pr.\r\nAnd if you hope to add jupiter, it might be better to add another issue to discuss."", 'commenter': 'ruanwenjun'}]"
524,eventmesh-common/src/main/java/org/apache/eventmesh/common/protocol/http/common/EventMeshRetCode.java,"@@ -39,7 +39,8 @@
     EVENTMESH_SUBSCRIBE_ERR(17, ""eventMesh subscribe err""),
     EVENTMESH_UNSUBSCRIBE_ERR(18, ""eventMesh unsubscribe err""),
     EVENTMESH_HEARTBEAT_ERR(19, ""eventMesh heartbeat err""),
-    EVENTMESH_ACL_ERR(20, ""eventMesh acl err"");
+    EVENTMESH_ACL_ERR(20, ""eventMesh acl err""),
+    EVENTMESH_HTTP_MES_SEND_OVER_LIMIT_ERR(20, ""eventMesh http msg send over the limit, "");","[{'comment': ""this code 20 isn't right"", 'commenter': 'xwm1992'}, {'comment': 'Thanks @xwm1992 I fix the error code to make it as 21.\r\n\r\nAdding new commit to this PR', 'commenter': 'jinrongluo'}]"
525,eventmesh-openschema/eventmesh-openschema-registry/build.gradle,"@@ -0,0 +1,53 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+ 
+plugins {
+    id 'org.springframework.boot' version '2.5.4'
+    id 'io.spring.dependency-management'
+    id 'java'
+}
+
+group 'org.apache.eventmesh'
+version '1.2.0-SNAPSHOT'
+
+configurations {
+    compileOnly {
+        extendsFrom annotationProcessor
+    }
+}
+
+repositories {
+    mavenCentral()
+}
+
+dependencies {
+    implementation 'org.springframework.boot:spring-boot-starter-data-jdbc'
+    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
+    implementation 'org.springframework.boot:spring-boot-starter-jdbc'
+    implementation 'org.springframework.boot:spring-boot-starter-web'
+    implementation 'org.springframework:spring-beans:5.1.8.RELEASE'
+    implementation 'org.mybatis.spring.boot:mybatis-spring-boot-starter:2.2.0'","[{'comment': ""Why did you choose to add both jpa and mybatis? It seems you can just choose one of them.\r\nI prefer mybatis.\r\nAnd don't add unnecessary dependencies, it seems Jupiter is not needed."", 'commenter': 'ruanwenjun'}, {'comment': 'I was not familiar with the difference between JPA and mybatis.  So I compared both of them and choose JPA due to its automatic generation of many query languages.\r\n\r\nNext, I will try to modify the JPA part to mybatis since mybatis seems proposed and better maintainable by the community.', 'commenter': 'jzhou59'}, {'comment': 'Use JPA is OK, you can remove the `mybatis`.', 'commenter': 'ruanwenjun'}, {'comment': '> Use JPA is OK, you can remove the `mybatis`.\r\n\r\nYa, Using Spring JPA should be fine. :) ', 'commenter': 'yzhao244'}]"
526,eventmesh-common/src/test/java/org/apache/eventmesh/common/loadbalance/WeightRandomLoadBalanceSelectorTest.java,"@@ -0,0 +1,82 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.eventmesh.common.loadbalance;
+
+import org.junit.Assert;
+import org.junit.Test;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.lang.reflect.Field;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+import java.util.function.Function;
+import java.util.stream.IntStream;
+
+import static java.util.stream.Collectors.groupingBy;
+import static java.util.stream.Collectors.summingInt;
+
+public class WeightRandomLoadBalanceSelectorTest {
+
+    private Logger logger = LoggerFactory.getLogger(WeightRandomLoadBalanceSelectorTest.class);
+
+    @Test
+    public void testSelect() {
+        List<Weight<String>> weightList = new ArrayList<>();
+        weightList.add(new Weight<>(""192.168.0.1"", 10));
+        weightList.add(new Weight<>(""192.168.0.2"", 20));
+        weightList.add(new Weight<>(""192.168.0.3"", 30));
+        WeightRandomLoadBalanceSelector<String> weightRandomLoadBalanceSelector = new WeightRandomLoadBalanceSelector<>(weightList);
+        Assert.assertEquals(LoadBalanceType.WEIGHT_RANDOM, weightRandomLoadBalanceSelector.getType());
+        Map<String, Integer> addressToNum = IntStream.range(0, 100_000)
+                .mapToObj(i -> weightRandomLoadBalanceSelector.select())
+                .collect(groupingBy(Function.identity(), summingInt(i -> 1)));
+
+        addressToNum.forEach((key, value) -> {
+            logger.info(""{}: {}"", key, value);
+        });
+        Assert.assertTrue(addressToNum.get(""192.168.0.3"") > addressToNum.get(""192.168.0.2""));
+        Assert.assertTrue(addressToNum.get(""192.168.0.2"") > addressToNum.get(""192.168.0.1""));
+    }
+
+    @Test
+    public void testSameWeightSelect() throws Exception {
+        List<Weight<String>> weightList = new ArrayList<>();
+        weightList.add(new Weight<>(""192.168.0.1"", 10));
+        weightList.add(new Weight<>(""192.168.0.2"", 10));
+        weightList.add(new Weight<>(""192.168.0.3"", 10));
+        WeightRandomLoadBalanceSelector<String> weightRandomLoadBalanceSelector = new WeightRandomLoadBalanceSelector<>(weightList);
+        Assert.assertEquals(LoadBalanceType.WEIGHT_RANDOM, weightRandomLoadBalanceSelector.getType());
+
+        int testRange = 100_000;
+        Map<String, Integer> addressToNum = IntStream.range(0, testRange)
+                .mapToObj(i -> weightRandomLoadBalanceSelector.select())
+                .collect(groupingBy(Function.identity(), summingInt(i -> 1)));
+
+        Field field = WeightRandomLoadBalanceSelector.class.getDeclaredField(""sameWeightGroup"");
+        field.setAccessible(true);
+        boolean sameWeightGroup = (boolean) field.get(weightRandomLoadBalanceSelector);
+        Assert.assertTrue(sameWeightGroup);
+
+        addressToNum.forEach((key, value) -> {
+            logger.info(""{}: {}"", key, value);
+        });
+        Assert.assertTrue(addressToNum.get(""192.168.0.3"") - addressToNum.get(""192.168.0.2"") < testRange / 10);","[{'comment': '```suggestion\r\n        Assert.assertTrue(Math.abs(addressToNum.get(""192.168.0.3"") - addressToNum.get(""192.168.0.2"")) < testRange / 10);\r\n```\r\nAnd can the error be smaller?', 'commenter': 'ruanwenjun'}, {'comment': 'I have modified the error rate to 5%.', 'commenter': 'horoc'}]"
526,eventmesh-common/src/test/java/org/apache/eventmesh/common/loadbalance/WeightRandomLoadBalanceSelectorTest.java,"@@ -0,0 +1,82 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.eventmesh.common.loadbalance;
+
+import org.junit.Assert;
+import org.junit.Test;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.lang.reflect.Field;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+import java.util.function.Function;
+import java.util.stream.IntStream;
+
+import static java.util.stream.Collectors.groupingBy;
+import static java.util.stream.Collectors.summingInt;
+
+public class WeightRandomLoadBalanceSelectorTest {
+
+    private Logger logger = LoggerFactory.getLogger(WeightRandomLoadBalanceSelectorTest.class);
+
+    @Test
+    public void testSelect() {
+        List<Weight<String>> weightList = new ArrayList<>();
+        weightList.add(new Weight<>(""192.168.0.1"", 10));
+        weightList.add(new Weight<>(""192.168.0.2"", 20));
+        weightList.add(new Weight<>(""192.168.0.3"", 30));
+        WeightRandomLoadBalanceSelector<String> weightRandomLoadBalanceSelector = new WeightRandomLoadBalanceSelector<>(weightList);
+        Assert.assertEquals(LoadBalanceType.WEIGHT_RANDOM, weightRandomLoadBalanceSelector.getType());
+        Map<String, Integer> addressToNum = IntStream.range(0, 100_000)
+                .mapToObj(i -> weightRandomLoadBalanceSelector.select())
+                .collect(groupingBy(Function.identity(), summingInt(i -> 1)));
+
+        addressToNum.forEach((key, value) -> {
+            logger.info(""{}: {}"", key, value);
+        });
+        Assert.assertTrue(addressToNum.get(""192.168.0.3"") > addressToNum.get(""192.168.0.2""));","[{'comment': 'Can we modify this compare method like the following test?\r\nlike (addressToNum.get(""192.168.0.3"")*1.0 / addressToNum.get(""192.168.0.2"")) == 1.5', 'commenter': 'ruanwenjun'}, {'comment': 'You are right, I have modified this compare method', 'commenter': 'horoc'}]"
526,eventmesh-common/src/main/java/org/apache/eventmesh/common/loadbalance/WeightRandomLoadBalanceSelector.java,"@@ -0,0 +1,71 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.eventmesh.common.loadbalance;
+
+import org.apache.commons.lang3.RandomUtils;
+
+import java.util.List;
+
+/**
+ * This selector use the weighted random strategy to select from list.
+ * If all the weights are same, it will randomly select one from list.
+ * If the weights are different, it will select one by using RandomUtils.nextInt(0, w0 + w1 ... + wn)
+ *
+ * @param <T> Target type
+ */
+public class WeightRandomLoadBalanceSelector<T> implements LoadBalanceSelector<T> {
+
+    private final List<Weight<T>> clusterGroup;
+
+    private final int totalWeight;
+
+    private boolean sameWeightGroup = true;
+
+    public WeightRandomLoadBalanceSelector(List<Weight<T>> clusterGroup) {","[{'comment': 'We need to throw an Exception if the clusterGroup is empty?\r\nAnd in your code, it seems the `totalWeight` cannot <= 0?', 'commenter': 'ruanwenjun'}, {'comment': '> We need to throw an Exception if the clusterGroup is empty?\r\n> And in your code, it seems the `totalWeight` cannot <= 0?\r\n\r\nI add a not empty check in the constructor.\r\ntotalWeight equals 0 is acceptable, it will make the sameWeightGroup true.\r\ntotalWeight less than 0 maybe not possiable in the context, the IP_PORT_WEIGHT_PATTERN can not match a negative weight.', 'commenter': 'horoc'}, {'comment': 'Ok', 'commenter': 'ruanwenjun'}]"
526,eventmesh-common/src/main/java/org/apache/eventmesh/common/loadbalance/WeightRandomLoadBalanceSelector.java,"@@ -0,0 +1,76 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.eventmesh.common.loadbalance;
+
+import org.apache.commons.collections4.CollectionUtils;
+import org.apache.commons.lang3.RandomUtils;
+import org.apache.eventmesh.common.EventMeshException;
+
+import java.util.List;
+
+/**
+ * This selector use the weighted random strategy to select from list.
+ * If all the weights are same, it will randomly select one from list.
+ * If the weights are different, it will select one by using RandomUtils.nextInt(0, w0 + w1 ... + wn)
+ *
+ * @param <T> Target type
+ */
+public class WeightRandomLoadBalanceSelector<T> implements LoadBalanceSelector<T> {
+
+    private final List<Weight<T>> clusterGroup;
+
+    private final int totalWeight;
+
+    private boolean sameWeightGroup = true;
+
+    public WeightRandomLoadBalanceSelector(List<Weight<T>> clusterGroup) throws EventMeshException {
+        if (CollectionUtils.isEmpty(clusterGroup)) {
+            throw new EventMeshException(""clusterGroup can not be empty"");
+        }
+        int totalWeight = 0;
+        int firstWeight = clusterGroup.get(0).getWeight();
+        for (Weight<T> weight : clusterGroup) {
+            totalWeight += weight.getWeight();
+            if (sameWeightGroup && firstWeight != weight.getWeight()) {
+                sameWeightGroup = false;
+            }
+        }
+        this.clusterGroup = clusterGroup;
+        this.totalWeight = totalWeight;
+    }
+
+    @Override
+    public T select() {
+        if (!sameWeightGroup) {
+            int targetWeight = RandomUtils.nextInt(0, totalWeight);","[{'comment': 'When the totalWeight is less than 0, this method will throw an IllegalArgumentException, it better to do this check in Constructor.\r\nAnd when the totalWeight is 0, the targetWright is alway 0, so the select method will always return the first element of the clusterGroup.', 'commenter': 'ruanwenjun'}, {'comment': '@horoc do you have any comments?', 'commenter': 'qqeasonchen'}, {'comment': 'Hi, I replied this question in another comment. \r\n\r\nTotalWeight less than 0 maybe not possiable in the context, the IP_PORT_WEIGHT_PATTERN can not match a negative weight.\r\nTotalWeight equals 0 is acceptable, it will make the sameWeightGroup true, the select method will return an element with the same probability.\r\n', 'commenter': 'horoc'}, {'comment': 'This comments can be solved.', 'commenter': 'ruanwenjun'}]"
527,eventmesh-runtime/src/main/java/org/apache/eventmesh/runtime/trace/OpenTelemetryTraceFactory.java,"@@ -41,15 +44,18 @@
 
     private SpanExporter spanExporter;
 
-    private SpanExporter defaultExporter = new LoggingSpanExporter();
+    private SpanExporter defaultExporter = new logExporter();
 
     private SpanProcessor spanProcessor;
 
+    // Name of the service(using the instrumentationName)
+    private String SERVICE_NAME;
+
     public OpenTelemetryTraceFactory(CommonConfiguration configuration){
-        //different spanExporter
         try {
             String exporterName = configuration.eventMeshTraceExporterType;
-            spanExporter = (SpanExporter) Class.forName(""io.opentelemetry.exporter.""+exporterName+"".""+exporterName+""SpanExporter"").newInstance();
+            //todo different spanExporter","[{'comment': 'I have no idea how to set different exporter.What should I do?', 'commenter': 'Roc-00'}, {'comment': 'Different exporter may implement the `SpanExporter` and you can use the reflection to get different exporter instance', 'commenter': 'xwm1992'}]"
527,eventmesh-runtime/src/main/java/org/apache/eventmesh/runtime/exporter/logExporter.java,"@@ -0,0 +1,86 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.eventmesh.runtime.exporter;
+
+import io.opentelemetry.sdk.common.CompletableResultCode;
+import io.opentelemetry.sdk.common.InstrumentationLibraryInfo;
+import io.opentelemetry.sdk.trace.data.SpanData;
+import io.opentelemetry.sdk.trace.export.SpanExporter;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.util.Collection;
+
+/**
+ *  Because the class 'LoggingSpanExporter' in openTelemetry exported garbled code in eventMesh's startUp, I override the 'LoggingSpanExporter'.
+ */
+public class logExporter implements SpanExporter {
+    private static final Logger logger = LoggerFactory.getLogger(logExporter.class);
+
+    @Override
+    public CompletableResultCode export(Collection<SpanData> spans) {
+        // We always have 32 + 16 + name + several whitespace, 60 seems like an OK initial guess.
+        StringBuilder sb = new StringBuilder(60);
+        for (SpanData span : spans) {
+            sb.setLength(0);
+            InstrumentationLibraryInfo instrumentationLibraryInfo = span.getInstrumentationLibraryInfo();
+            sb.append(""'"")
+                    .append(span.getName())
+                    .append(""' : "")
+                    .append(span.getTraceId())
+                    .append("" "")
+                    .append(span.getSpanId())
+                    .append("" "")
+                    .append(span.getKind())
+                    .append("" [tracer: "")
+                    .append(instrumentationLibraryInfo.getName())
+                    .append("":"")
+                    .append(
+                            instrumentationLibraryInfo.getVersion() == null
+                                    ? """"
+                                    : instrumentationLibraryInfo.getVersion())
+                    .append(""] "")
+                    .append(span.getAttributes());
+            logger.info(sb.toString());
+        }
+        return CompletableResultCode.ofSuccess();
+    }
+
+    /**
+     * Flushes the data.
+     * (i guess it is not necessary for slf4j's log)
+     * @return the result of the operation
+     */
+    @Override
+    public CompletableResultCode flush() {
+        CompletableResultCode resultCode = new CompletableResultCode();
+//        for (Handler handler : logger.getHandlers()) {","[{'comment': 'remove the unused code', 'commenter': 'xwm1992'}, {'comment': 'ok', 'commenter': 'Roc-00'}]"
527,tool/license/allowed-licenses.txt,"@@ -564,6 +564,36 @@
             ""moduleLicense"": ""The Apache Software License, Version 2.0"",
             ""moduleVersion"": ""0.8.1"",
             ""moduleName"": ""io.prometheus:simpleclient_httpserver""
+        },
+        {
+            ""moduleLicense"": ""The Apache License, Version 2.0"",
+            ""moduleVersion"": ""1.3.0"",
+            ""moduleName"": ""io.opentelemetry:opentelemetry-exporter-zipkin""
+        },
+        {
+            ""moduleLicense"": ""The Apache Software License, Version 2.0"",
+            ""moduleVersion"": ""2.16.3"",
+            ""moduleName"": ""io.zipkin.reporter2:zipkin-reporter""
+        },
+        {
+            ""moduleLicense"": ""The Apache Software License, Version 2.0"",
+            ""moduleVersion"": ""2.16.3"",
+            ""moduleName"": ""io.zipkin.reporter2:zipkin-sender-okhttp3""
+        },
+        {
+            ""moduleLicense"": ""The Apache Software License, Version 2.0"",
+            ""moduleVersion"": ""2.23.2"",
+            ""moduleName"": ""io.zipkin.zipkin2:zipkin""
+        },
+        {
+            ""moduleLicense"": ""Apache 2.0"",","[{'comment': 'Here not correct, `The Apache Software License, Version 2.0` or  `The Apache License, Version 2.0`', 'commenter': 'xwm1992'}, {'comment': 'Yes, there might some problem with license check plugin, the one license may have different name, and we need to normalize them, we may need to add a LicenseBundleNormalizer  filter.\r\nhttps://github.com/jk1/Gradle-License-Report\r\n\r\nI will test this.', 'commenter': 'ruanwenjun'}]"
527,tool/license/allowed-licenses.txt,"@@ -564,6 +564,36 @@
             ""moduleLicense"": ""The Apache Software License, Version 2.0"",
             ""moduleVersion"": ""0.8.1"",
             ""moduleName"": ""io.prometheus:simpleclient_httpserver""
+        },
+        {
+            ""moduleLicense"": ""The Apache License, Version 2.0"",
+            ""moduleVersion"": ""1.3.0"",
+            ""moduleName"": ""io.opentelemetry:opentelemetry-exporter-zipkin""
+        },
+        {
+            ""moduleLicense"": ""The Apache Software License, Version 2.0"",
+            ""moduleVersion"": ""2.16.3"",
+            ""moduleName"": ""io.zipkin.reporter2:zipkin-reporter""
+        },
+        {
+            ""moduleLicense"": ""The Apache Software License, Version 2.0"",
+            ""moduleVersion"": ""2.16.3"",
+            ""moduleName"": ""io.zipkin.reporter2:zipkin-sender-okhttp3""
+        },
+        {
+            ""moduleLicense"": ""The Apache Software License, Version 2.0"",
+            ""moduleVersion"": ""2.23.2"",
+            ""moduleName"": ""io.zipkin.zipkin2:zipkin""
+        },
+        {
+            ""moduleLicense"": ""Apache 2.0"",
+            ""moduleVersion"": ""3.14.9"",
+            ""moduleName"": ""com.squareup.okhttp3:okhttp""
+        },
+        {
+            ""moduleLicense"": ""Apache 2.0"",","[{'comment': 'same as above', 'commenter': 'xwm1992'}]"
527,eventmesh-runtime/src/main/java/org/apache/eventmesh/runtime/exporter/zipkinExporter.java,"@@ -17,8 +17,9 @@
 package org.apache.eventmesh.runtime.exporter;
 
 import io.opentelemetry.exporter.zipkin.ZipkinSpanExporter;
+import org.apache.eventmesh.common.config.CommonConfiguration;
 
-public class zipkinExporter {
+public class zipkinExporter implements EventMeshExporter {","[{'comment': ""`zipkinExporter` isn't right, change to `ZipkinExporter`"", 'commenter': 'xwm1992'}, {'comment': 'ok', 'commenter': 'Roc-00'}]"
527,eventmesh-runtime/conf/eventmesh.properties,"@@ -74,7 +74,7 @@ eventMesh.server.registry.enabled=false
 eventMesh.metrics.prometheus.port=19090
 
 #trace exporter
-eventmesh.trace.exporter.type=log
+eventmesh.trace.exporter.type=zipkin","[{'comment': 'here may be Zipkin, because of your class name', 'commenter': 'xwm1992'}, {'comment': 'changed', 'commenter': 'Roc-00'}]"
527,eventmesh-runtime/src/main/java/org/apache/eventmesh/runtime/boot/AbstractHTTPServer.java,"@@ -132,13 +142,26 @@ public void sendError(ChannelHandlerContext ctx,
                 ""; charset="" + EventMeshConstants.DEFAULT_CHARSET);
         response.headers().add(HttpHeaderNames.CONTENT_LENGTH, response.content().readableBytes());
         response.headers().add(HttpHeaderNames.CONNECTION, HttpHeaderValues.KEEP_ALIVE);
-        // todo server span end with error, record status, we should get channel here to get span in channel's context in async call..
+        //todo server span end with error, record status, we should get channel here to get span in channel's context in async call..","[{'comment': 'You may need to add a switch to determine whether you want to enter here', 'commenter': 'tydhot'}, {'comment': 'fixed', 'commenter': 'Roc-00'}]"
527,eventmesh-runtime/src/main/java/org/apache/eventmesh/runtime/boot/AbstractHTTPServer.java,"@@ -132,13 +142,26 @@ public void sendError(ChannelHandlerContext ctx,
                 ""; charset="" + EventMeshConstants.DEFAULT_CHARSET);
         response.headers().add(HttpHeaderNames.CONTENT_LENGTH, response.content().readableBytes());
         response.headers().add(HttpHeaderNames.CONNECTION, HttpHeaderValues.KEEP_ALIVE);
-        // todo server span end with error, record status, we should get channel here to get span in channel's context in async call..
+        //todo server span end with error, record status, we should get channel here to get span in channel's context in async call..
+        Context context = ctx.channel().attr(AttributeKeys.SERVER_CONTEXT).get();
+        Span span = context.get(SpanKey.SERVER_KEY);
+        try (Scope ignored = context.makeCurrent()) {
+            span.setStatus(StatusCode.ERROR);//set this span's status to ERROR
+            span.end();// closing the scope does not end the span, this has to be done manually
+        }
         ctx.writeAndFlush(response).addListener(ChannelFutureListener.CLOSE);
     }
 
     public void sendResponse(ChannelHandlerContext ctx,
                              DefaultFullHttpResponse response) {
-        // todo end server span, we should get channel here to get span in channel's context in async call.
+        //todo end server span, we should get channel here to get span in channel's context in async call.","[{'comment': 'You may need to add a switch to determine whether you want to enter here', 'commenter': 'tydhot'}, {'comment': 'fixed', 'commenter': 'Roc-00'}]"
527,eventmesh-runtime/src/main/java/org/apache/eventmesh/runtime/boot/AbstractHTTPServer.java,"@@ -132,13 +142,26 @@ public void sendError(ChannelHandlerContext ctx,
                 ""; charset="" + EventMeshConstants.DEFAULT_CHARSET);
         response.headers().add(HttpHeaderNames.CONTENT_LENGTH, response.content().readableBytes());
         response.headers().add(HttpHeaderNames.CONNECTION, HttpHeaderValues.KEEP_ALIVE);
-        // todo server span end with error, record status, we should get channel here to get span in channel's context in async call..
+        //todo server span end with error, record status, we should get channel here to get span in channel's context in async call..
+        Context context = ctx.channel().attr(AttributeKeys.SERVER_CONTEXT).get();
+        Span span = context.get(SpanKey.SERVER_KEY);
+        try (Scope ignored = context.makeCurrent()) {
+            span.setStatus(StatusCode.ERROR);//set this span's status to ERROR
+            span.end();// closing the scope does not end the span, this has to be done manually
+        }
         ctx.writeAndFlush(response).addListener(ChannelFutureListener.CLOSE);
     }
 
     public void sendResponse(ChannelHandlerContext ctx,
                              DefaultFullHttpResponse response) {
-        // todo end server span, we should get channel here to get span in channel's context in async call.
+        //todo end server span, we should get channel here to get span in channel's context in async call.
+        Context context = ctx.channel().attr(AttributeKeys.SERVER_CONTEXT).get();
+        Span span = context.get(SpanKey.SERVER_KEY);
+        try (Scope ignored = context.makeCurrent()) {
+            span.addEvent(""Send Response"");","[{'comment': 'no need to add event about response ', 'commenter': 'tydhot'}, {'comment': 'fixed', 'commenter': 'Roc-00'}]"
527,eventmesh-runtime/src/main/java/org/apache/eventmesh/runtime/boot/AbstractHTTPServer.java,"@@ -256,7 +294,18 @@ protected void channelRead0(ChannelHandlerContext ctx, HttpRequest httpRequest)
                 requestCommand.setHttpMethod(httpRequest.method().name());
                 requestCommand.setHttpVersion(httpRequest.protocolVersion().protocolName());
                 requestCommand.setRequestCode(requestCode);
-                // todo record command method, version and requestCode in span.
+
+                //todo record command opaque in span.
+                span = tracer.spanBuilder(""HTTP ""+requestCommand.httpMethod).setParent(context).setSpanKind(SpanKind.SERVER).startSpan();
+                span.addEvent(""Span Start"");","[{'comment': 'avoid span event here', 'commenter': 'tydhot'}, {'comment': 'fixed', 'commenter': 'Roc-00'}]"
527,eventmesh-runtime/src/main/java/org/apache/eventmesh/runtime/boot/AbstractHTTPServer.java,"@@ -256,7 +294,18 @@ protected void channelRead0(ChannelHandlerContext ctx, HttpRequest httpRequest)
                 requestCommand.setHttpMethod(httpRequest.method().name());
                 requestCommand.setHttpVersion(httpRequest.protocolVersion().protocolName());
                 requestCommand.setRequestCode(requestCode);
-                // todo record command method, version and requestCode in span.
+
+                //todo record command opaque in span.
+                span = tracer.spanBuilder(""HTTP ""+requestCommand.httpMethod).setParent(context).setSpanKind(SpanKind.SERVER).startSpan();
+                span.addEvent(""Span Start"");
+                //attach the span to the server context
+                context = context.with(SpanKey.SERVER_KEY,span);
+                //put the context in channel
+                ctx.channel().attr(AttributeKeys.SERVER_CONTEXT).set(context);
+                //todo record command method, version and requestCode in span.
+                span.setAttribute(""HttpMethod"",httpRequest.method().name());","[{'comment': 'ues otel key instaed : https://github.com/open-telemetry/opentelemetry-java/blob/main/semconv/src/main/java/io/opentelemetry/semconv/trace/attributes/SemanticAttributes.java', 'commenter': 'tydhot'}, {'comment': 'fixed', 'commenter': 'Roc-00'}]"
527,eventmesh-runtime/src/main/java/org/apache/eventmesh/runtime/boot/AbstractHTTPServer.java,"@@ -256,7 +294,18 @@ protected void channelRead0(ChannelHandlerContext ctx, HttpRequest httpRequest)
                 requestCommand.setHttpMethod(httpRequest.method().name());
                 requestCommand.setHttpVersion(httpRequest.protocolVersion().protocolName());
                 requestCommand.setRequestCode(requestCode);
-                // todo record command method, version and requestCode in span.
+
+                //todo record command opaque in span.
+                span = tracer.spanBuilder(""HTTP ""+requestCommand.httpMethod).setParent(context).setSpanKind(SpanKind.SERVER).startSpan();
+                span.addEvent(""Span Start"");
+                //attach the span to the server context
+                context = context.with(SpanKey.SERVER_KEY,span);
+                //put the context in channel
+                ctx.channel().attr(AttributeKeys.SERVER_CONTEXT).set(context);
+                //todo record command method, version and requestCode in span.
+                span.setAttribute(""HttpMethod"",httpRequest.method().name());
+                span.setAttribute(""HttpVersion"",httpRequest.protocolVersion().protocolName());
+                span.setAttribute(""RequestCode"",requestCode);","[{'comment': 'ues otel key instaed : https://github.com/open-telemetry/opentelemetry-java/blob/main/semconv/src/main/java/io/opentelemetry/semconv/trace/attributes/SemanticAttributes.java', 'commenter': 'tydhot'}, {'comment': 'fixed', 'commenter': 'Roc-00'}]"
527,eventmesh-runtime/src/main/java/org/apache/eventmesh/runtime/boot/AbstractHTTPServer.java,"@@ -298,7 +347,11 @@ protected void channelRead0(ChannelHandlerContext ctx, HttpRequest httpRequest)
                 processEventMeshRequest(ctx, asyncContext);
             } catch (Exception ex) {
                 httpServerLogger.error(""AbrstractHTTPServer.HTTPHandler.channelRead0 err"", ex);
-                // todo span end with exception.
+                //todo span end with exception.
+                span.addEvent(""End Exceptional"");","[{'comment': 'we should add an exception here, but we need to record the cause in event atttribute', 'commenter': 'tydhot'}, {'comment': 'i am not sure whether i am doing it in a right way', 'commenter': 'Roc-00'}]"
527,eventmesh-runtime/src/main/java/org/apache/eventmesh/runtime/trace/OpenTelemetryTraceFactory.java,"@@ -0,0 +1,102 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.eventmesh.runtime.trace;
+
+import io.opentelemetry.api.OpenTelemetry;
+import io.opentelemetry.api.common.Attributes;
+import io.opentelemetry.api.trace.Tracer;
+import io.opentelemetry.api.trace.propagation.W3CTraceContextPropagator;
+import io.opentelemetry.context.propagation.ContextPropagators;
+import io.opentelemetry.context.propagation.TextMapPropagator;
+import io.opentelemetry.sdk.OpenTelemetrySdk;
+import io.opentelemetry.sdk.resources.Resource;
+import io.opentelemetry.sdk.trace.SdkTracerProvider;
+import io.opentelemetry.sdk.trace.SpanProcessor;
+import io.opentelemetry.sdk.trace.export.BatchSpanProcessor;
+import io.opentelemetry.sdk.trace.export.SpanExporter;
+import org.apache.eventmesh.common.config.CommonConfiguration;
+import org.apache.eventmesh.runtime.exporter.EventMeshExporter;
+import org.apache.eventmesh.runtime.exporter.LogExporter;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.util.concurrent.TimeUnit;
+import static io.opentelemetry.api.common.AttributeKey.stringKey;
+
+public class OpenTelemetryTraceFactory {
+    private static final Logger logger = LoggerFactory.getLogger(OpenTelemetryTraceFactory.class);
+
+    private OpenTelemetry openTelemetry;
+
+    private SpanExporter spanExporter;
+
+    private SpanExporter defaultExporter = new LogExporter();
+
+    private SpanProcessor spanProcessor;
+
+    // Name of the service(using the instrumentationName)
+    private final String SERVICE_NAME = ""eventmesh_trace"";
+
+    public OpenTelemetryTraceFactory(CommonConfiguration configuration){
+        try {
+            //different spanExporter
+            String exporterName = configuration.eventMeshTraceExporterType;
+            //use reflection to get spanExporter
+            String className = String.format(""org.apache.eventmesh.runtime.exporter.%sExporter"",exporterName);
+            EventMeshExporter eventMeshExporter = (EventMeshExporter) Class.forName(className).newInstance();
+            spanExporter = eventMeshExporter.getSpanExporter(configuration);
+        }catch (Exception ex){
+            logger.error(""fail to set tracer's exporter,due to{}"",ex.getMessage());","[{'comment': ""fail to set tracer's exporter,due to{} \r\nadd a blank before{}"", 'commenter': 'tydhot'}, {'comment': 'fixed', 'commenter': 'Roc-00'}]"
527,eventmesh-common/src/test/resources/configuration.properties,"@@ -23,4 +23,6 @@ eventMesh.server.name=value5
 eventMesh.server.hostIp=value6
 eventMesh.connector.plugin.type=rocketmq
 eventMesh.security.plugin.type=acl
-eventMesh.registry.plugin.type=namesrv
\ No newline at end of file
+eventMesh.registry.plugin.type=namesrv
+eventMesh.exporter.zipkin.ip=localhost","[{'comment': 'keep the path the same as eventmesh.trace.export.zipkin.ip.', 'commenter': 'qqeasonchen'}, {'comment': 'fixed', 'commenter': 'Roc-00'}]"
527,eventmesh-runtime/conf/eventmesh.properties,"@@ -71,4 +71,20 @@ eventMesh.registry.plugin.type=namesrv
 eventMesh.server.registry.enabled=false
 
 #prometheusPort
-eventMesh.metrics.prometheus.port=19090
\ No newline at end of file
+eventMesh.metrics.prometheus.port=19090
+
+#trace exporter
+eventMesh.trace.exporter.type=Zipkin
+
+#set the maximum batch size to use
+eventMesh.trace.max.export.size=512
+#set the queue size. This must be >= the export batch size
+eventMesh.trace.max.queue.size=2048
+#set the max amount of time an export can run before getting(TimeUnit=SECONDS)
+eventMesh.trace.exporter.timeout=30
+#set time between two different exports(TimeUnit=SECONDS)
+eventMesh.trace.export.interval=5","[{'comment': 'keep the path the same as eventmesh.trace.exporter, eventMesh changed to eventmesh would be better.', 'commenter': 'qqeasonchen'}]"
530,eventmesh-admin/README.md,"@@ -4,10 +4,10 @@ EventMesh Administration Module for EventMesh. It manages Admin Service, Configu
 
 ## Administration Client Manager APIs
 
-### POST /clientmanage/topics/
+### POST /clientmanage/topics","[{'comment': '@yzhao244 I suggest /topicmanage instead of /clientmanage/topics here, what do you think?', 'commenter': 'qqeasonchen'}, {'comment': 'done. :)', 'commenter': 'yzhao244'}]"
531,eventmesh-connector-plugin/eventmesh-connector-rocketmq/src/test/java/org/apache/rocketmq/producer/RocketMQProducerImplTest.java,"@@ -0,0 +1,60 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.rocketmq.producer;
+
+
+import org.apache.eventmesh.api.producer.MeshMQProducer;
+import org.apache.eventmesh.connector.rocketmq.producer.RocketMQProducerImpl;
+
+import org.junit.After;
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.Test;
+
+import io.openmessaging.api.exception.OMSRuntimeException;
+
+public class RocketMQProducerImplTest {
+
+    @Before
+    public void before() {}
+
+
+    @After
+    public void after() {
+        //TBD:Remove topic
+    }
+
+    @Test
+    public void testCreate_Ok() {
+
+        MeshMQProducer meshMQProducer = new RocketMQProducerImpl();
+        try {
+            meshMQProducer.createTopic("""");
+            Assert.assertTrue(""Failed to detect empty topic"", false);
+        } catch (OMSRuntimeException e) {
+            Assert.assertTrue(""Successfully detected empty topic"", true);","[{'comment': 'Do not assert exception; One method should handle one exception.', 'commenter': 'vongosling'}, {'comment': 'fixed.\r\n\r\n> @qqeasonchen meshMQProducer and other names are strange. we could remove the concrete storage name in the code. maybe meshPub is a good name.\r\n\r\n@vongosling changed name to meshPub, thx for the suggestion of the name. :)', 'commenter': 'yzhao244'}]"
531,eventmesh-connector-plugin/eventmesh-connector-rocketmq/src/main/java/org/apache/eventmesh/connector/rocketmq/producer/RocketMQProducerImpl.java,"@@ -149,4 +158,16 @@ public void updateCredential(Properties credentialProperties) {
     public <T> MessageBuilder<T> messageBuilder() {
         return null;
     }
+
+    @Override
+    public void createTopic(String topicName) throws OMSRuntimeException {
+        CreateTopicCommand createTopicCommand = new CreateTopicCommand();
+        createTopicCommand.setTopicName(topicName);
+        try {
+            createTopicCommand.execute();
+        } catch (Exception e) {
+            throw new OMSRuntimeException(-1, 
+                String.format(""RocketMQ can not create topic %s."", topicName), e);","[{'comment': '```suggestion\r\nthrow new OMSRuntimeException(\r\n                String.format(""RocketMQ can not create topic %s."", topicName), e);\r\n```', 'commenter': 'ruanwenjun'}, {'comment': ""It might be better don't add an error code casually here, if you hope to add an error code, you should define it well."", 'commenter': 'ruanwenjun'}]"
531,eventmesh-connector-plugin/eventmesh-connector-rocketmq/src/main/resources/rocketmq-client.properties,"@@ -16,3 +16,6 @@
 #
 #######################rocketmq-client##################
 eventMesh.server.rocketmq.namesrvAddr=127.0.0.1:9876;127.0.0.1:9876
+eventMesh.server.rocketmq.cluster=********","[{'comment': 'Can we add a default value here? Maybe it can run success in most times.', 'commenter': 'ruanwenjun'}, {'comment': 'thx, fixed', 'commenter': 'yzhao244'}]"
531,eventmesh-connector-plugin/eventmesh-connector-rocketmq/src/test/java/org/apache/eventmesh/producer/DefaultProducerImplTest.java,"@@ -0,0 +1,63 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.eventmesh.producer;
+
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+import org.apache.eventmesh.api.producer.MeshMQProducer;
+import org.apache.eventmesh.connector.rocketmq.producer.RocketMQProducerImpl;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+
+import io.openmessaging.api.exception.OMSRuntimeException;
+
+public class DefaultProducerImplTest {
+
+    @Before
+    public void before() {}
+
+
+    @After
+    public void after() {
+        //TBD:Remove topic
+    }
+
+    @Test
+    public void testCreate_EmptyTopic() {
+        MeshMQProducer meshPub = new RocketMQProducerImpl();
+        try {
+            meshPub.createTopic("""");
+        } catch (OMSRuntimeException e) {           
+            assertThat(e.getMessage()).isEqualTo(""RocketMQ can not create topic ."");","[{'comment': '```suggestion\r\nassertThat(e.getMessage()).isEqualTo(""RocketMQ can not create topic."");\r\n```', 'commenter': 'ruanwenjun'}]"
540,eventmesh-starter/build.gradle,"@@ -18,5 +18,6 @@
 dependencies {
     implementation project("":eventmesh-runtime"")
     testImplementation project("":eventmesh-runtime"")
+    implementation project("":eventmesh-connector-plugin:eventmesh-connector-rocketmq"")","[{'comment': '@Hu-Tu-Tu It does not need to add plugin to the dependencies, please refer to the plugin load mechanisam.', 'commenter': 'qqeasonchen'}]"
540,docs/cn/blog/HTTP start.md,"@@ -0,0 +1,195 @@
+# HTTP的启动
+
+> 首先我们先将一下启动前的准备工作，也就是HTTPServer的初始化。
+>
+> 在EventMeshServer初始化的时候，会连带这初始化EventMeshHTTPServer，下面我就几点做出说明：
+
+
+
+1. 在初始化的时候，会初始化多个线程池，这个线程池中会有许多的阻塞的线程队列，当某一种事件发生的时候，就会根据事件来使用线程池工厂来为事件创建线程。【下面是源代码】
+
+```java
+public void initThreadPool() throws Exception {
+    
+		// 批处理消息
+        BlockingQueue<Runnable> batchMsgThreadPoolQueue = new LinkedBlockingQueue<Runnable>(eventMeshHttpConfiguration.eventMeshServerBatchBlockQSize);
+        batchMsgExecutor = ThreadPoolFactory.createThreadPoolExecutor(eventMeshHttpConfiguration.eventMeshServerBatchMsgThreadNum,
+                eventMeshHttpConfiguration.eventMeshServerBatchMsgThreadNum, batchMsgThreadPoolQueue, ""eventMesh-batchMsg-"", true);
+		// 发送消息，和上面的类似
+        BlockingQueue<Runnable> sendMsgThreadPoolQueue=...
+		// 推送消息，和上面的类似
+        BlockingQueue<Runnable> pushMsgThreadPoolQueue =...
+		// 客户端管理，和上面的类似
+        BlockingQueue<Runnable> clientManageThreadPoolQueue =...
+		// 管理线程池，和上面的类似
+        BlockingQueue<Runnable> adminThreadPoolQueue =...
+		// 回复消息，和上面的类似
+        BlockingQueue<Runnable> replyMessageThreadPoolQueue =...
+    }
+```
+
+2. 注册http请求处理器，这个处理器会针对http发过来的请求，获取到请求码，根据请求码注册对应的处理器，并且为这个事件用上面的线程池分配一个线程进行处理。【下面是源代码】
+
+```java
+ public void registerHTTPRequestProcessor() {
+     	// 新建批量消息处理器
+        BatchSendMessageProcessor batchSendMessageProcessor = new BatchSendMessageProcessor(this);
+     	// 获取请求码，并且分配一个线程进行处理
+        registerProcessor(RequestCode.MSG_BATCH_SEND.getRequestCode(),
+                batchSendMessageProcessor, batchMsgExecutor);
+		
+        BatchSendMessageV2Processor batchSendMessageV2Processor =...
+		// 同步消息处理器，和上面的类似
+        SendSyncMessageProcessor sendSyncMessageProcessor =...
+		// 异步消息处理器，和上面的类似
+        SendAsyncMessageProcessor sendAsyncMessageProcessor =...
+		// 管理指标处理器，和上面的类似
+        AdminMetricsProcessor adminMetricsProcessor =...
+		// 心跳处理器，和上面的类似
+        HeartBeatProcessor heartProcessor =...
+		// 订阅处理器，和上面的类似
+        SubscribeProcessor subscribeProcessor =...
+		// 和上面的类似
+        UnSubscribeProcessor unSubscribeProcessor =...
+		// 回复消息处理器，和上面的类似
+        ReplyMessageProcessor replyMessageProcessor =...
+    }
+```
+
+3. 这里就是http初始化的全部代码。
+
+```java
+public class EventMeshHTTPServer extends AbstractHTTPServer {
+	...
+  	//初始化
+    public void init() throws Exception {
+        logger.info(""==================EventMeshHTTPServer Initialing=================="");
+        // 初始化线程组
+        super.init(""eventMesh-http"");
+		// 初始化线程池
+        initThreadPool();
+		// 对指标初始化，主要是把生成的指标用于后台数据处理
+        metrics = new HTTPMetricsServer(this);
+        metrics.init();
+		// 消费者管理初始化，主要是把httpServer注册到事件总线上
+        consumerManager = new ConsumerManager(this);
+        consumerManager.init();
+		
+        producerManager = new ProducerManager(this);
+        producerManager.init();
+		// 重试
+        httpRetryer = new HttpRetryer(this);
+        httpRetryer.init();
+		// 注册http处理器
+        registerHTTPRequestProcessor();
+
+        logger.info(""--------------------------EventMeshHTTPServer inited"");
+    }
+    ...
+}
+```
+
+
+
+> 初始化完成之后，再启动http的服务器端，这里我也同样聊聊以下几点。
+
+1. AbstractHTTPServer的启动，采用的是netty的异步模型框架搭建的。具体来讲，这里创建了两个线程池：`bossGroup`和`workerGroup`，前者是用来轮询`accept`事件并且和`client`建立连接的，后者是用来轮询`read`和`write`时间并且使用`handlers`处理`io`事件的。而且这里采用了回调机制，当调用发出后，并不一定立刻就能得到结果，而是在实际处理的时候调用这个组件完成后，通过状态、通知等回调告知调用者。","[{'comment': '后者是用来轮询`read`和`write`时间并且使用`handlers`处理`io`事件的， 时间or事件？', 'commenter': 'xwm1992'}, {'comment': ""OK, I'll revise it."", 'commenter': 'Hu-Tu-Tu'}]"
540,docs/cn/blog/Implementation of pub and sub.md,"@@ -0,0 +1,344 @@
+# pub和sub的实现-tcp
+
+> Eventmesh-sdk-java作为客户端，与eventmesh-runtime通信，用于完成消息的发送和接收。
+>
+> 那么pub和sub作为客户端，在eventmesh中是怎么实现的？
+
+## 结构
+
+> 我们首先看到sdk-java中tcp这一部分的结构：`common`部分定义了tcp协议下广播消息、异步消息都会用到的公共方法，`impl`是对tcp的pub和sub的真正实现。
+
+![](../../images/blog/structure.png)
+
+
+
+> 下面来具体介绍一下三个实现类的功能，下面是对应的类图：
+>- DefaultEventMeshClient：实现了EventMeshClient接口，用来定义一个具备pub和sub功能的客户端。
+>- SimplePubClientImpl：实现了SimplePubClient接口，同时还继承了TcpClient ，用来定义一个具备pub功能的客户端。
+>- SimpleSubClientImpl：实现了SimpleSubClient接口，同时也继承了TcpClient ，用来定义一个具备sub功能的客户端。
+
+![](../../images/blog/Impl-class-diagram.png)
+
+
+
+## 代码
+
+- 对于client的实现，首先是要和runtime进行连接，也就是和服务器进行连接，连接的过程是：client发送心跳包给server，server对心跳包进行回应，然后client发送连接请求，接收到server的回应之后，客户端和服务器连接成功。在EventMeshClient接口中，它是这样定义连接的：
+
+```java
+void init() throws Exception;
+void heartbeat() throws Exception;
+```
+
+- 在DefaultEventMeshClient中具体的实现如下：
+
+```java
+public void init() throws Exception {
+        this.subClient.init();
+        this.pubClient.init();
+}
+```
+
+```java
+public void heartbeat() throws Exception {
+        this.pubClient.heartbeat();
+        this.subClient.heartbeat();
+}
+```
+
+- 也就是说，一个客户端和服务器的连接被分成了两个部分，一个是pub客户端的连接，一个是sub客户端的连接。那我们具体来看到两个客户端的实现，因为两个客户端实现有点类似，所以我们这里以`SimpleSubClientImpl`为例进行说明：
+
+  > client和server的握手过程
+  >
+  > HELLO_REQUEST(2),                                  //client发给server的握手请求
+  > HELLO_RESPONSE(3),                                 //server回复client的握手请求
+
+```java
+//SimpleSubClientImpl
+public void init() throws Exception {
+        //指向server的启动入口
+        open(new Handler());
+    	//设置了hello的header和body部分，client和server进行握手
+        hello();
+        logger.info(""SimpleSubClientImpl|{}|started!"", clientNo);
+}
+```
+
+> client和server的发送心跳包过程
+>
+> HEARTBEAT_REQUEST(0),                              //client发给server的心跳包
+>
+>  HEARTBEAT_RESPONSE(1),                             //server回复client的心跳包
+
+```java
+//SimpleSubClientImpl
+public void heartbeat() throws Exception {
+    task = scheduler.scheduleAtFixedRate(new Runnable() {
+        @Override
+        public void run() {
+            try {
+                //如果不是处于活跃状态，就重新连接
+                if (!isActive()) {
+                    SimpleSubClientImpl.this.reconnect();
+                }
+                //client向server发送心跳包
+                Package msg = MessageUtils.heartBeat();
+                SimpleSubClientImpl.this.io(msg, EventMeshCommon.DEFAULT_TIME_OUT_MILLS);
+            } catch (Exception ignore) {
+            }
+        }
+    }, EventMeshCommon.HEARTBEAT, EventMeshCommon.HEARTBEAT, TimeUnit.MILLISECONDS);
+}
+```
+
+- 连接成功之后，pub可以实现发布消息，并且可以选择使用异步还是广播的方式进行发布；而sub实现对消息的订阅，并且时刻监听pub发布的消息，对pub发布的消息进行回应。在SimplePubClient和SimpleSubClient的接口中，它们是这样定义的：
+
+```java
+//SimplePubClient
+//对消息进行发布
+Package publish(Package msg, long timeout) throws Exception;
+//发送rr消息
+Package rr(Package msg, long timeout) throws Exception;
+//发送异步单播消息
+void asyncRR(Package msg, AsyncRRCallback callback, long timeout) throws Exception;
+//广播消息
+void broadcast(Package msg, long timeout) throws Exception;
+```
+
+```java
+//SimpleSubClient
+//监听
+void listen() throws Exception;
+//订阅管理
+void subscribe(String topic, SubscriptionMode subscriptionMode, SubcriptionType subcriptionType) throws Exception;
+//取消订阅
+void unsubscribe() throws Exception;
+```
+
+- 下面介绍它们的具体实现
+
+```java
+//SimplePubClientImpl 
+public class SimplePubClientImpl extends TcpClient implements SimplePubClient {
+    ...
+     /**
+     * 发送事件消息, 返回值是EventMesh 给了ACK
+     *
+     * @param msg
+     * @throws Exception
+     */
+    public Package publish(Package msg, long timeout) throws Exception {
+        logger.info(""SimplePubClientImpl|{}|publish|send|type={}|msg={}"", clientNo, msg.getHeader().getCommand(), msg);
+        //请求上下文，发送事件消息
+        return io(msg, timeout);
+    }
+    
+    /**
+     * 发送RR消息
+     *
+     * @param msg
+     * @param timeout
+     * @return
+     * @throws Exception
+     */
+    public Package rr(Package msg, long timeout) throws Exception {
+        logger.info(""SimplePubClientImpl|{}|rr|send|type={}|msg={}"", clientNo, msg.getHeader().getCommand(), msg);
+        return io(msg, timeout);
+    }
+
+    /**
+     * 异步RR
+     *
+     * @param msg
+     * @param callback
+     * @param timeout
+     * @throws Exception
+     */
+    @Override
+    public void asyncRR(Package msg, AsyncRRCallback callback, long timeout) throws Exception {
+        super.send(msg);
+        this.callbackConcurrentHashMap.put((String) RequestContext._key(msg), callback);
+
+    }
+
+    /**
+     * 发送广播消息
+     *
+     * @param msg
+     * @param timeout
+     * @throws Exception
+     */
+    public void broadcast(Package msg, long timeout) throws Exception {
+        logger.info(""SimplePubClientImpl|{}|broadcast|send|type={}|msg={}"", clientNo, msg.getHeader().getCommand(), msg);
+        super.send(msg);
+    }
+
+   ...
+}
+
+```
+
+```java
+public class SimpleSubClientImpl extends TcpClient implements SimpleSubClient {
+    ...
+    //监听
+    public void listen() throws Exception {
+        //调用MessageUtils方法启动监听
+        Package request = MessageUtils.listen();
+        this.io(request, EventMeshCommon.DEFAULT_TIME_OUT_MILLS);
+    }
+
+	//订阅
+    public void subscribe(String topic, SubscriptionMode subscriptionMode, SubcriptionType subcriptionType) throws Exception {
+        subscriptionItems.add(new SubscriptionItem(topic, subscriptionMode, subcriptionType));
+        Package request = MessageUtils.subscribe(topic, subscriptionMode, subcriptionType);
+        this.io(request, EventMeshCommon.DEFAULT_TIME_OUT_MILLS);
+    }
+	//取消订阅
+    public void unsubscribe() throws Exception {
+        Package request = MessageUtils.unsubscribe();
+        this.io(request, EventMeshCommon.DEFAULT_TIME_OUT_MILLS);
+    }
+    
+  ...
+}
+
+```
+
+- 最后就是断连，具体过程就是
+
+  > CLIENT_GOODBYE_REQUEST(4),                         //client主动断连时通知server CLIENT_GOODBYE_RESPONSE(5),                        //server回复client的主动断连通知
+  > SERVER_GOODBYE_REQUEST(6),                         //server主动断连时通知client
+  > SERVER_GOODBYE_RESPONSE(7),                        //client回复server的主动断连通知
+
+- 在EventMeshClient接口中是这样定义的：
+
+```java
+void close();
+```
+
+- 在DefaultEventMeshClient中的具体实现：
+
+```java
+ public void close() {
+        this.pubClient.close();
+        this.subClient.close();
+}
+```
+
+```java
+//SimplePubClientImpl
+private void goodbye() throws Exception {
+        Package msg = MessageUtils.goodbye();
+        this.io(msg, EventMeshCommon.DEFAULT_TIME_OUT_MILLS);
+}
+```
+
+```java
+//SimpleSubClientImpl
+private void goodbye() throws Exception {
+        Package msg = MessageUtils.goodbye();
+        this.io(msg, EventMeshCommon.DEFAULT_TIME_OUT_MILLS);
+}
+```
+
+## 举例
+
+> 在eventmesh中有一个test模块，就是包含了tcp和http两种协议的演示，这些演示，就是对sdk-java作为客户端和runtime的server交互的一些举例，下面我们以tcp的单播消息来对上面的内容做一个举例说明","[{'comment': 'test改为examples', 'commenter': 'xwm1992'}, {'comment': ""OK, I'll revise it"", 'commenter': 'Hu-Tu-Tu'}]"
540,README.zh-CN.md,"@@ -65,8 +65,8 @@ eventmesh的通信协议更加简洁方便，详细内容，阅读更多[这里]
 
 ## 快速开始
 1. 构建并部署event-store(RocketMQ), 请参见[说明](https://rocketmq.apache.org/docs/quick-start/)
-2. 构建并部署eventmesh-runtime，请参见说明['eventmesh-runtime quickstart.zh-CN'](docs/cn/instructions/eventmesh-runtime-quickstart.zh-CN.md)
-3. 运行eventmesh-sdk-java演示，请参见说明['eventmesh-sdk-java quickstart.zh-CN'](docs/cn/instructions/eventmesh-sdk-java-quickstart.zh-CN.md)
+2. 构建并部署eventmesh-runtime，请参见说明['eventmesh-runtime quickstart.zh-CN'](docs/cn/instructions/eventmesh-runtime-quickstart.md)
+3. 运行eventmesh-sdk-java演示，请参见说明['eventmesh-sdk-java quickstart.zh-CN'](docs/cn/instructions/eventmesh-sdk-java-quickstart.md)
 ","[{'comment': '@Hu-Tu-Tu it need rebase first.', 'commenter': 'qqeasonchen'}]"
571,CONTRIBUTING.md,"@@ -3,21 +3,6 @@
 Welcome to EventMesh! This document is a guideline about how to contribute to EventMesh. If you find something incorrect
 or missing, please leave comments / suggestions.
 
-## Before you get started
-
-### Setting up your development environment","[{'comment': '@AhahaGe suggest not removed, but add some comments', 'commenter': 'qqeasonchen'}, {'comment': ""Because with ide, if we don't import it, we can't check code style. And In some other part of this file, we have noticed that.  So I suggest to delete it.\r\n\r\nCode review\r\nAll code should be well reviewed by one or more committers. Some principles:\r\n\r\nReadability: Important code should be well-documented. Comply with our code style.\r\nElegance: New functions, classes or components should be well-designed.\r\nTestability: Important code should be well-tested (high unit test coverage)."", 'commenter': 'AhahaGe'}, {'comment': 'Not every one has set the same code style in their IDE, right? So each time they submit code there are maybe a lot of formatting changes involed, This file is to help the contributor to format their code style.', 'commenter': 'ruanwenjun'}]"
572,eventmesh-protocol-plugin/eventmesh-protocol-openmessage/src/main/java/org/apache/eventmesh/protocol/openmessage/OpenMessageProtocolAdaptor.java,"@@ -0,0 +1,32 @@
+package org.apache.eventmesh.protocol.openmessage;
+
+import org.apache.eventmesh.protocol.api.ProtocolAdaptor;
+import org.apache.eventmesh.protocol.api.ProtocolType;
+
+import io.cloudevents.CloudEvent;
+import io.cloudevents.core.v1.CloudEventV1;
+import io.openmessaging.api.Message;
+
+/**
+ * OpenMessage protocol adaptor, used to transform protocol between
+ * {@link CloudEvent} with {@link Message}.
+ *
+ * @since 1.3.0
+ */
+public class OpenMessageProtocolAdaptor implements ProtocolAdaptor<Message> {
+
+    @Override
+    public CloudEventV1 toCloudEventV1(Message message) {","[{'comment': 'Here we may change the input parameters to `package`', 'commenter': 'xwm1992'}, {'comment': 'Done', 'commenter': 'ruanwenjun'}]"
572,eventmesh-protocol-plugin/eventmesh-protocol-openmessage/src/main/java/org/apache/eventmesh/protocol/openmessage/OpenMessageProtocolAdaptor.java,"@@ -0,0 +1,32 @@
+package org.apache.eventmesh.protocol.openmessage;
+
+import org.apache.eventmesh.protocol.api.ProtocolAdaptor;
+import org.apache.eventmesh.protocol.api.ProtocolType;
+
+import io.cloudevents.CloudEvent;
+import io.cloudevents.core.v1.CloudEventV1;
+import io.openmessaging.api.Message;
+
+/**
+ * OpenMessage protocol adaptor, used to transform protocol between
+ * {@link CloudEvent} with {@link Message}.
+ *
+ * @since 1.3.0
+ */
+public class OpenMessageProtocolAdaptor implements ProtocolAdaptor<Message> {
+
+    @Override
+    public CloudEventV1 toCloudEventV1(Message message) {
+        return null;
+    }
+
+    @Override
+    public Message fromCloudEventV1(CloudEventV1 cloudEvent) {","[{'comment': 'return value should be `package`', 'commenter': 'xwm1992'}, {'comment': 'Done', 'commenter': 'ruanwenjun'}]"
572,eventmesh-protocol-plugin/eventmesh-protocol-cloudevents/src/main/java/org/apache/eventmesh/protocol/cloudevents/CloudEventProtocolAdaptor.java,"@@ -0,0 +1,24 @@
+package org.apache.eventmesh.protocol.cloudevents;
+
+import org.apache.eventmesh.protocol.api.ProtocolAdaptor;
+import org.apache.eventmesh.protocol.api.ProtocolType;
+
+import io.cloudevents.core.v1.CloudEventV1;
+
+public class CloudEventProtocolAdaptor implements ProtocolAdaptor<CloudEventV1> {
+
+    @Override
+    public CloudEventV1 toCloudEventV1(CloudEventV1 cloudEvent) {","[{'comment': 'input parameter should be `package`', 'commenter': 'xwm1992'}, {'comment': 'Done', 'commenter': 'ruanwenjun'}]"
572,eventmesh-protocol-plugin/eventmesh-protocol-cloudevents/src/main/java/org/apache/eventmesh/protocol/cloudevents/CloudEventProtocolAdaptor.java,"@@ -0,0 +1,24 @@
+package org.apache.eventmesh.protocol.cloudevents;
+
+import org.apache.eventmesh.protocol.api.ProtocolAdaptor;
+import org.apache.eventmesh.protocol.api.ProtocolType;
+
+import io.cloudevents.core.v1.CloudEventV1;
+
+public class CloudEventProtocolAdaptor implements ProtocolAdaptor<CloudEventV1> {
+
+    @Override
+    public CloudEventV1 toCloudEventV1(CloudEventV1 cloudEvent) {
+        return cloudEvent;
+    }
+
+    @Override
+    public CloudEventV1 fromCloudEventV1(CloudEventV1 cloudEvent) {","[{'comment': 'return value should be `package`', 'commenter': 'xwm1992'}, {'comment': 'Done', 'commenter': 'ruanwenjun'}]"
575,eventmesh-sdk-java/src/main/java/org/apache/eventmesh/client/tcp/common/MessageUtils.java,"@@ -76,6 +77,14 @@ public static Package asyncMessageAck(Package in) {
         return msg;
     }
 
+    public static Package asyncCloudEvent(CloudEvent cloudEvent) {
+        Package msg = new Package();
+        msg.setHeader(new Header(Command.ASYNC_MESSAGE_TO_SERVER, 0,
+                EventMeshCommon.CLOUD_EVENTS_PROTOCOL_NAME, generateRandomString(seqLength)));","[{'comment': 'the package header contains `Command`, `code`, `msg`, `seq`. The `msg` correspond with `code`，so please add the new attribute to represent the protocol not use the `msg`.', 'commenter': 'xwm1992'}, {'comment': 'ok', 'commenter': 'wangshaojie4039'}]"
575,eventmesh-sdk-java/src/main/java/org/apache/eventmesh/client/tcp/impl/SimplePubClientImpl.java,"@@ -145,6 +146,23 @@ public Package publish(Package msg, long timeout) throws Exception {
         return io(msg, timeout);
     }
 
+
+    @Override
+    public Package publish(CloudEvent cloudEvent, long timeout) throws Exception {
+        Package msg = MessageUtils.asyncCloudEvent(cloudEvent);
+        logger.info(""SimplePubClientImpl|{}|publish|send|type={}|msg={}"", clientNo,","[{'comment': 'please add the protocol type in logging', 'commenter': 'xwm1992'}, {'comment': 'ok', 'commenter': 'wangshaojie4039'}]"
575,eventmesh-common/src/main/java/org/apache/eventmesh/common/protocol/tcp/Header.java,"@@ -17,21 +17,32 @@
 
 package org.apache.eventmesh.common.protocol.tcp;
 
+import java.util.HashMap;
+import java.util.Map;
+
 public class Header {
 
     private Command cmd;
     private int code;
-    private String msg;
+    private String dsec;","[{'comment': 'What is `dsec` mean? `desc`?', 'commenter': 'ruanwenjun'}]"
575,eventmesh-sdk-java/src/main/java/org/apache/eventmesh/client/tcp/common/ReceiveMsgHook.java,"@@ -20,6 +20,13 @@
 import io.netty.channel.ChannelHandlerContext;
 import org.apache.eventmesh.common.protocol.tcp.Package;
 
-public interface ReceiveMsgHook {
+/**
+ * ReceiveMsgHook.
+ *
+ * @param <T> receive message type.
+ */
+public interface ReceiveMsgHook<T> {
     void handle(Package msg, ChannelHandlerContext ctx);
+
+    T convert(Package pkg);","[{'comment': ""If this method just execute by itself, it's not suggested to add this in interface. This will make interface unclear."", 'commenter': 'ruanwenjun'}]"
685,eventmesh-runtime/src/main/java/org/apache/eventmesh/runtime/core/protocol/http/consumer/ConsumerManager.java,"@@ -73,100 +73,97 @@ public void init() throws Exception {
 
     public void start() throws Exception {
         logger.info(""consumerManager started......"");
-        scheduledExecutorService.scheduleAtFixedRate(new Runnable() {
-            @Override
-            public void run() {
-                logger.info(""clientInfo check start....."");
-                synchronized (eventMeshHTTPServer.localClientInfoMapping) {
-                    Map<String, List<Client>> clientInfoMap =
-                        eventMeshHTTPServer.localClientInfoMapping;
-                    if (clientInfoMap.size() > 0) {
-                        for (String key : clientInfoMap.keySet()) {
-                            String consumerGroup = key.split(""@"")[0];
-                            String topic = key.split(""@"")[1];
-                            List<Client> clientList = clientInfoMap.get(key);
-                            Iterator<Client> clientIterator = clientList.iterator();
-                            boolean isChange = false;
-                            while (clientIterator.hasNext()) {
-                                Client client = clientIterator.next();
-                                //The time difference is greater than 3 heartbeat cycles
-                                if (System.currentTimeMillis() - client.lastUpTime.getTime()
-                                    > DEFAULT_UPDATE_TIME) {
-                                    logger.warn(
-                                        ""client {} lastUpdate time {} over three heartbeat cycles"",
-                                        JsonUtils.serialize(client), client.lastUpTime);
-                                    clientIterator.remove();
-                                    isChange = true;
-                                }
+        scheduledExecutorService.scheduleAtFixedRate(() -> {
+            logger.info(""clientInfo check start....."");
+            synchronized (eventMeshHTTPServer.localClientInfoMapping) {
+                Map<String, List<Client>> clientInfoMap =
+                    eventMeshHTTPServer.localClientInfoMapping;
+                if (clientInfoMap.size() > 0) {
+                    for (String key : clientInfoMap.keySet()) {
+                        String consumerGroup = key.split(""@"")[0];
+                        String topic = key.split(""@"")[1];
+                        List<Client> clientList = clientInfoMap.get(key);
+                        Iterator<Client> clientIterator = clientList.iterator();
+                        boolean isChange = false;
+                        while (clientIterator.hasNext()) {
+                            Client client = clientIterator.next();
+                            //The time difference is greater than 3 heartbeat cycles
+                            if (System.currentTimeMillis() - client.lastUpTime.getTime()
+                                > DEFAULT_UPDATE_TIME) {
+                                logger.warn(
+                                    ""client {} lastUpdate time {} over three heartbeat cycles"",
+                                    JsonUtils.serialize(client), client.lastUpTime);
+                                clientIterator.remove();
+                                isChange = true;
                             }
-                            if (isChange) {
-                                if (clientList.size() > 0) {
-                                    //change url
-                                    logger.info(""consumerGroup {} client info changing"",
-                                        consumerGroup);
-                                    Map<String, List<String>> idcUrls = new HashMap<>();
-                                    Set<String> clientUrls = new HashSet<>();
-                                    for (Client client : clientList) {
-                                        clientUrls.add(client.url);
-                                        if (idcUrls.containsKey(client.idc)) {
-                                            idcUrls.get(client.idc)
-                                                .add(StringUtils.deleteWhitespace(client.url));
-                                        } else {
-                                            List<String> urls = new ArrayList<>();
-                                            urls.add(client.url);
-                                            idcUrls.put(client.idc, urls);
-                                        }
+                        }
+                        if (isChange) {
+                            if (clientList.size() > 0) {
+                                //change url
+                                logger.info(""consumerGroup {} client info changing"",
+                                    consumerGroup);
+                                Map<String, List<String>> idcUrls = new HashMap<>();
+                                Set<String> clientUrls = new HashSet<>();
+                                for (Client client : clientList) {
+                                    clientUrls.add(client.url);
+                                    if (idcUrls.containsKey(client.idc)) {
+                                        idcUrls.get(client.idc)
+                                            .add(StringUtils.deleteWhitespace(client.url));
+                                    } else {
+                                        List<String> urls = new ArrayList<>();
+                                        urls.add(client.url);
+                                        idcUrls.put(client.idc, urls);
                                     }
-                                    synchronized (eventMeshHTTPServer.localConsumerGroupMapping) {
-                                        ConsumerGroupConf consumerGroupConf =
-                                            eventMeshHTTPServer.localConsumerGroupMapping
-                                                .get(consumerGroup);
-                                        Map<String, ConsumerGroupTopicConf> map =
-                                            consumerGroupConf.getConsumerGroupTopicConf();
-                                        for (String topicKey : map.keySet()) {
-                                            if (StringUtils.equals(topic, topicKey)) {
-                                                ConsumerGroupTopicConf latestTopicConf =
-                                                    new ConsumerGroupTopicConf();
-                                                latestTopicConf.setConsumerGroup(consumerGroup);
-                                                latestTopicConf.setTopic(topic);
-                                                latestTopicConf.setSubscriptionItem(
-                                                    map.get(topicKey).getSubscriptionItem());
-                                                latestTopicConf.setUrls(clientUrls);
-
-                                                latestTopicConf.setIdcUrls(idcUrls);
-
-                                                map.put(topic, latestTopicConf);
-                                            }
-                                        }
+                                }
+                                synchronized (eventMeshHTTPServer.localConsumerGroupMapping) {
+                                    ConsumerGroupConf consumerGroupConf =
                                         eventMeshHTTPServer.localConsumerGroupMapping
-                                            .put(consumerGroup, consumerGroupConf);
-                                        logger.info(
-                                            ""consumerGroup {} client info changed, ""
-                                                + ""consumerGroupConf {}"", consumerGroup,
-                                            JsonUtils.serialize(consumerGroupConf));
-                                        try {
-                                            notifyConsumerManager(consumerGroup, consumerGroupConf);
-                                        } catch (Exception e) {
-                                            e.printStackTrace();
+                                            .get(consumerGroup);
+                                    Map<String, ConsumerGroupTopicConf> map =
+                                        consumerGroupConf.getConsumerGroupTopicConf();
+                                    for (String topicKey : map.keySet()) {
+                                        if (StringUtils.equals(topic, topicKey)) {
+                                            ConsumerGroupTopicConf latestTopicConf =
+                                                new ConsumerGroupTopicConf();
+                                            latestTopicConf.setConsumerGroup(consumerGroup);
+                                            latestTopicConf.setTopic(topic);
+                                            latestTopicConf.setSubscriptionItem(
+                                                map.get(topicKey).getSubscriptionItem());
+                                            latestTopicConf.setUrls(clientUrls);
+
+                                            latestTopicConf.setIdcUrls(idcUrls);
+
+                                            map.put(topic, latestTopicConf);
                                         }
                                     }
-
-                                } else {
-                                    logger.info(""consumerGroup {} client info removed"",
-                                        consumerGroup);
-                                    //remove
+                                    eventMeshHTTPServer.localConsumerGroupMapping
+                                        .put(consumerGroup, consumerGroupConf);
+                                    logger.info(
+                                        ""consumerGroup {} client info changed, ""
+                                            + ""consumerGroupConf {}"", consumerGroup,
+                                        JsonUtils.serialize(consumerGroupConf));
                                     try {
-                                        notifyConsumerManager(consumerGroup, null);
+                                        notifyConsumerManager(consumerGroup, consumerGroupConf);
                                     } catch (Exception e) {
                                         e.printStackTrace();","[{'comment': 'Please use logger to optimize this print, this can avoid the .out file expansion.', 'commenter': 'ruanwenjun'}]"
685,eventmesh-runtime/src/main/java/org/apache/eventmesh/runtime/core/protocol/http/consumer/ConsumerManager.java,"@@ -73,100 +73,97 @@ public void init() throws Exception {
 
     public void start() throws Exception {
         logger.info(""consumerManager started......"");
-        scheduledExecutorService.scheduleAtFixedRate(new Runnable() {
-            @Override
-            public void run() {
-                logger.info(""clientInfo check start....."");
-                synchronized (eventMeshHTTPServer.localClientInfoMapping) {
-                    Map<String, List<Client>> clientInfoMap =
-                        eventMeshHTTPServer.localClientInfoMapping;
-                    if (clientInfoMap.size() > 0) {
-                        for (String key : clientInfoMap.keySet()) {
-                            String consumerGroup = key.split(""@"")[0];
-                            String topic = key.split(""@"")[1];
-                            List<Client> clientList = clientInfoMap.get(key);
-                            Iterator<Client> clientIterator = clientList.iterator();
-                            boolean isChange = false;
-                            while (clientIterator.hasNext()) {
-                                Client client = clientIterator.next();
-                                //The time difference is greater than 3 heartbeat cycles
-                                if (System.currentTimeMillis() - client.lastUpTime.getTime()
-                                    > DEFAULT_UPDATE_TIME) {
-                                    logger.warn(
-                                        ""client {} lastUpdate time {} over three heartbeat cycles"",
-                                        JsonUtils.serialize(client), client.lastUpTime);
-                                    clientIterator.remove();
-                                    isChange = true;
-                                }
+        scheduledExecutorService.scheduleAtFixedRate(() -> {
+            logger.info(""clientInfo check start....."");
+            synchronized (eventMeshHTTPServer.localClientInfoMapping) {
+                Map<String, List<Client>> clientInfoMap =
+                    eventMeshHTTPServer.localClientInfoMapping;
+                if (clientInfoMap.size() > 0) {
+                    for (String key : clientInfoMap.keySet()) {
+                        String consumerGroup = key.split(""@"")[0];
+                        String topic = key.split(""@"")[1];
+                        List<Client> clientList = clientInfoMap.get(key);
+                        Iterator<Client> clientIterator = clientList.iterator();
+                        boolean isChange = false;
+                        while (clientIterator.hasNext()) {
+                            Client client = clientIterator.next();
+                            //The time difference is greater than 3 heartbeat cycles
+                            if (System.currentTimeMillis() - client.lastUpTime.getTime()
+                                > DEFAULT_UPDATE_TIME) {
+                                logger.warn(
+                                    ""client {} lastUpdate time {} over three heartbeat cycles"",
+                                    JsonUtils.serialize(client), client.lastUpTime);
+                                clientIterator.remove();
+                                isChange = true;
                             }
-                            if (isChange) {
-                                if (clientList.size() > 0) {
-                                    //change url
-                                    logger.info(""consumerGroup {} client info changing"",
-                                        consumerGroup);
-                                    Map<String, List<String>> idcUrls = new HashMap<>();
-                                    Set<String> clientUrls = new HashSet<>();
-                                    for (Client client : clientList) {
-                                        clientUrls.add(client.url);
-                                        if (idcUrls.containsKey(client.idc)) {
-                                            idcUrls.get(client.idc)
-                                                .add(StringUtils.deleteWhitespace(client.url));
-                                        } else {
-                                            List<String> urls = new ArrayList<>();
-                                            urls.add(client.url);
-                                            idcUrls.put(client.idc, urls);
-                                        }
+                        }
+                        if (isChange) {
+                            if (clientList.size() > 0) {
+                                //change url
+                                logger.info(""consumerGroup {} client info changing"",
+                                    consumerGroup);
+                                Map<String, List<String>> idcUrls = new HashMap<>();
+                                Set<String> clientUrls = new HashSet<>();
+                                for (Client client : clientList) {
+                                    clientUrls.add(client.url);
+                                    if (idcUrls.containsKey(client.idc)) {
+                                        idcUrls.get(client.idc)
+                                            .add(StringUtils.deleteWhitespace(client.url));
+                                    } else {
+                                        List<String> urls = new ArrayList<>();
+                                        urls.add(client.url);
+                                        idcUrls.put(client.idc, urls);
                                     }
-                                    synchronized (eventMeshHTTPServer.localConsumerGroupMapping) {
-                                        ConsumerGroupConf consumerGroupConf =
-                                            eventMeshHTTPServer.localConsumerGroupMapping
-                                                .get(consumerGroup);
-                                        Map<String, ConsumerGroupTopicConf> map =
-                                            consumerGroupConf.getConsumerGroupTopicConf();
-                                        for (String topicKey : map.keySet()) {
-                                            if (StringUtils.equals(topic, topicKey)) {
-                                                ConsumerGroupTopicConf latestTopicConf =
-                                                    new ConsumerGroupTopicConf();
-                                                latestTopicConf.setConsumerGroup(consumerGroup);
-                                                latestTopicConf.setTopic(topic);
-                                                latestTopicConf.setSubscriptionItem(
-                                                    map.get(topicKey).getSubscriptionItem());
-                                                latestTopicConf.setUrls(clientUrls);
-
-                                                latestTopicConf.setIdcUrls(idcUrls);
-
-                                                map.put(topic, latestTopicConf);
-                                            }
-                                        }
+                                }
+                                synchronized (eventMeshHTTPServer.localConsumerGroupMapping) {
+                                    ConsumerGroupConf consumerGroupConf =
                                         eventMeshHTTPServer.localConsumerGroupMapping
-                                            .put(consumerGroup, consumerGroupConf);
-                                        logger.info(
-                                            ""consumerGroup {} client info changed, ""
-                                                + ""consumerGroupConf {}"", consumerGroup,
-                                            JsonUtils.serialize(consumerGroupConf));
-                                        try {
-                                            notifyConsumerManager(consumerGroup, consumerGroupConf);
-                                        } catch (Exception e) {
-                                            e.printStackTrace();
+                                            .get(consumerGroup);
+                                    Map<String, ConsumerGroupTopicConf> map =
+                                        consumerGroupConf.getConsumerGroupTopicConf();
+                                    for (String topicKey : map.keySet()) {
+                                        if (StringUtils.equals(topic, topicKey)) {
+                                            ConsumerGroupTopicConf latestTopicConf =
+                                                new ConsumerGroupTopicConf();
+                                            latestTopicConf.setConsumerGroup(consumerGroup);
+                                            latestTopicConf.setTopic(topic);
+                                            latestTopicConf.setSubscriptionItem(
+                                                map.get(topicKey).getSubscriptionItem());
+                                            latestTopicConf.setUrls(clientUrls);
+
+                                            latestTopicConf.setIdcUrls(idcUrls);
+
+                                            map.put(topic, latestTopicConf);
                                         }
                                     }
-
-                                } else {
-                                    logger.info(""consumerGroup {} client info removed"",
-                                        consumerGroup);
-                                    //remove
+                                    eventMeshHTTPServer.localConsumerGroupMapping
+                                        .put(consumerGroup, consumerGroupConf);
+                                    logger.info(
+                                        ""consumerGroup {} client info changed, ""
+                                            + ""consumerGroupConf {}"", consumerGroup,
+                                        JsonUtils.serialize(consumerGroupConf));
                                     try {
-                                        notifyConsumerManager(consumerGroup, null);
+                                        notifyConsumerManager(consumerGroup, consumerGroupConf);
                                     } catch (Exception e) {
                                         e.printStackTrace();
                                     }
+                                }
 
-                                    eventMeshHTTPServer.localConsumerGroupMapping.keySet()
-                                        .removeIf(s -> StringUtils.equals(consumerGroup, s));
+                            } else {
+                                logger.info(""consumerGroup {} client info removed"",
+                                    consumerGroup);
+                                //remove
+                                try {
+                                    notifyConsumerManager(consumerGroup, null);
+                                } catch (Exception e) {
+                                    e.printStackTrace();","[{'comment': 'Use logger.', 'commenter': 'ruanwenjun'}]"
723,docs/cn/instructions/eventmesh-runtime-protocol.md,"@@ -290,7 +290,7 @@ message RequestHeader {
     string protocolDesc = 12;
 }
 
-message EventMeshMessage {
+message SimpleMessage {","[{'comment': 'What about using `MessageRequest`?', 'commenter': 'ruanwenjun'}, {'comment': 'in my opinion, the naming need to be consistent across the protocol.\r\n\r\nIf we choose to use MessageRequest, then we have to add ""Request"" to the other message names as well: ""BatchMessageRequest"", ""SubscriptionRequest"", ""HeartBeatRequest"".\r\n\r\nBut I also think adding the word ""Request"" is a little bit redundant, because this is already a GRPC request message in nature. ', 'commenter': 'jinrongluo'}, {'comment': 'Ok, I just worried that someone might mistakenly think this is a message type.', 'commenter': 'ruanwenjun'}]"
723,docs/cn/instructions/eventmesh-runtime-quickstart-with-docker.md,"@@ -78,7 +78,7 @@ sudo vi eventmesh.properties
 |----------------------------|-------|----------------------------|
 | eventMesh.server.http.port | 10105 | EventMesh http server port |
 | eventMesh.server.tcp.port  | 10000 | EventMesh tcp server port  |
-
+| eventMesh.server.grpc.port | 10205 | EventMesh grpc server port |
 
 
 ### 配置 rocketmq-client.properties","[{'comment': 'Remove rocketmq...', 'commenter': 'vongosling'}, {'comment': ""I didn't change any rocketmq related information. it is in the original readme document."", 'commenter': 'jinrongluo'}]"
723,docs/cn/instructions/eventmesh-sdk-java-quickstart.md,"@@ -70,5 +70,54 @@ TCP 和 HTTP 示例都在**eventmesh-example**模块下
 运行org.apache.eventmesh.http.demo.pub.eventmeshmessage.AsyncPublishInstance的主要方法
 ```
 
+### 3. GRPC 演示
 
+> 对于 GRPC, eventmesh-sdk-java 实现了 Google gRPC 和 Google Protocol Buffers 协议. 它能异步和同步发送事件到 eventmesh-runtime.","[{'comment': 'No need to mention Google, gRPC and Protocol Buffer.', 'commenter': 'vongosling'}]"
723,docs/en/instructions/eventmesh-sdk-java-quickstart.md,"@@ -70,3 +70,55 @@ Run the main method of org.apache.eventmesh.http.demo.sub.SpringBootDemoApplicat
 Run the main method of org.apache.eventmesh.http.demo.pub.eventmeshmessage.AsyncPublishInstance
 ```
 
+### 3. GRPC DEMO
+
+> As to GRPC, eventmesh-sdk-java implements the Google gRPC and Google Protocol Buffers. It can send events to eventmesh-runtime asynchronously
+> and synchronously (using request-reply). It can also subscribe to the events using webhook subscriber and stream subscriber.
+> Apache CloudEvents protocol is also supported in the demo.","[{'comment': 'CloudEvents is CNCF spec', 'commenter': 'vongosling'}]"
723,eventmesh-examples/src/main/java/org/apache/eventmesh/grpc/sub/CloudEventsSubscribeReply.java,"@@ -0,0 +1,69 @@
+package org.apache.eventmesh.grpc.sub;
+
+import io.cloudevents.CloudEvent;
+import lombok.extern.slf4j.Slf4j;
+import org.apache.eventmesh.client.grpc.config.EventMeshGrpcClientConfig;
+import org.apache.eventmesh.client.grpc.consumer.EventMeshGrpcConsumer;
+import org.apache.eventmesh.client.grpc.consumer.ReceiveMsgHook;
+import org.apache.eventmesh.client.tcp.common.EventMeshCommon;
+import org.apache.eventmesh.common.protocol.SubscriptionItem;
+import org.apache.eventmesh.common.protocol.SubscriptionMode;
+import org.apache.eventmesh.common.protocol.SubscriptionType;
+import org.apache.eventmesh.util.Utils;
+
+import java.util.Collections;
+import java.util.Optional;
+import java.util.Properties;
+
+@Slf4j
+public class CloudEventsSubscribeReply implements ReceiveMsgHook<CloudEvent> {
+
+    public static CloudEventsSubscribeReply handler = new CloudEventsSubscribeReply();
+
+    public static void main(String[] args) throws InterruptedException {
+        Properties properties = Utils.readPropertiesFile(""application.properties"");
+        final String eventMeshIp = properties.getProperty(""eventmesh.ip"");
+        final String eventMeshGrpcPort = properties.getProperty(""eventmesh.grpc.port"");
+
+        final String topic = ""TEST-TOPIC-GRPC-RR"";
+
+        EventMeshGrpcClientConfig eventMeshClientConfig = EventMeshGrpcClientConfig.builder()
+            .serverAddr(eventMeshIp)
+            .serverPort(Integer.parseInt(eventMeshGrpcPort))
+            .consumerGroup(""EventMeshTest-consumerGroup"")
+            .env(""env"").idc(""idc"")
+            .sys(""1234"").build();
+
+        SubscriptionItem subscriptionItem = new SubscriptionItem();
+        subscriptionItem.setTopic(topic);
+        subscriptionItem.setMode(SubscriptionMode.CLUSTERING);
+        subscriptionItem.setType(SubscriptionType.ASYNC);","[{'comment': 'this should be `subscriptionItem.setType(SubscriptionType.SYNC)`, because this is request-reply mode.', 'commenter': 'xwm1992'}]"
723,eventmesh-examples/src/main/java/org/apache/eventmesh/grpc/sub/EventmeshSubscribeReply.java,"@@ -0,0 +1,68 @@
+package org.apache.eventmesh.grpc.sub;
+
+import lombok.extern.slf4j.Slf4j;
+import org.apache.eventmesh.client.grpc.config.EventMeshGrpcClientConfig;
+import org.apache.eventmesh.client.grpc.consumer.EventMeshGrpcConsumer;
+import org.apache.eventmesh.client.grpc.consumer.ReceiveMsgHook;
+import org.apache.eventmesh.client.tcp.common.EventMeshCommon;
+import org.apache.eventmesh.common.EventMeshMessage;
+import org.apache.eventmesh.common.protocol.SubscriptionItem;
+import org.apache.eventmesh.common.protocol.SubscriptionMode;
+import org.apache.eventmesh.common.protocol.SubscriptionType;
+import org.apache.eventmesh.util.Utils;
+
+import java.util.Collections;
+import java.util.Optional;
+import java.util.Properties;
+
+@Slf4j
+public class EventmeshSubscribeReply implements ReceiveMsgHook<EventMeshMessage> {
+
+    public static EventmeshSubscribeReply handler = new EventmeshSubscribeReply();
+
+    public static void main(String[] args) throws InterruptedException {
+        Properties properties = Utils.readPropertiesFile(""application.properties"");
+        final String eventMeshIp = properties.getProperty(""eventmesh.ip"");
+        final String eventMeshGrpcPort = properties.getProperty(""eventmesh.grpc.port"");
+
+        final String topic = ""TEST-TOPIC-GRPC-RR"";
+
+        EventMeshGrpcClientConfig eventMeshClientConfig = EventMeshGrpcClientConfig.builder()
+            .serverAddr(eventMeshIp)
+            .serverPort(Integer.parseInt(eventMeshGrpcPort))
+            .consumerGroup(""EventMeshTest-consumerGroup"")
+            .env(""env"").idc(""idc"")
+            .sys(""1234"").build();
+
+        SubscriptionItem subscriptionItem = new SubscriptionItem();
+        subscriptionItem.setTopic(topic);
+        subscriptionItem.setMode(SubscriptionMode.CLUSTERING);
+        subscriptionItem.setType(SubscriptionType.ASYNC);","[{'comment': 'this should be `subscriptionItem.setType(SubscriptionType.SYNC)`', 'commenter': 'xwm1992'}]"
749,eventmesh-trace-plugin/eventmesh-trace-api/src/main/java/org/apache/eventmesh/trace/api/TraceService.java,"@@ -0,0 +1,55 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.eventmesh.trace.api;
+
+import org.apache.eventmesh.spi.EventMeshExtensionType;
+import org.apache.eventmesh.spi.EventMeshSPI;
+
+import io.opentelemetry.api.trace.Tracer;
+import io.opentelemetry.context.propagation.TextMapPropagator;
+
+/**
+ * The top-level interface of trace
+ */
+@EventMeshSPI(isSingleton = true, eventMeshExtensionType = EventMeshExtensionType.TRACE)
+public interface TraceService {
+    /**
+     * init the trace service
+     */
+    void init();
+
+    /**
+     * close the trace service
+     */
+    void shutdown();
+
+    /**
+     * get the tracer
+     *
+     * @param instrumentationName
+     * @return
+     */
+    Tracer getTracer(String instrumentationName);","[{'comment': 'Return `io.opentelemetry.api.trace.Tracer` here seems not good, this will bind the opentelemetry to all plugin.\r\nCan we define a Trace class?', 'commenter': 'ruanwenjun'}, {'comment': ""I have no idea how to define 'a Trace class'."", 'commenter': 'Roc-00'}]"
807,eventmesh-examples/src/main/java/org/apache/eventmesh/grpc/sub/app/service/SubService.java,"@@ -115,8 +115,8 @@ public void cleanup() {
      * Count the message already consumed
      */
     public void consumeMessage(String msg) {
-        logger.info(""consume message {}"", msg);
+        logger.info(""consume message: {}"", msg);
         countDownLatch.countDown();
-        logger.info(""remaining number of messages to be consumed {}"", countDownLatch.getCount());
+        logger.info(""remaining number of messages to be consumed : {}"", countDownLatch.getCount());","[{'comment': 'For  code style consistency, you can delete this space.\r\n```suggestion\r\n        logger.info(""remaining number of messages to be consumed: {}"", countDownLatch.getCount());\r\n```', 'commenter': 'ruanwenjun'}]"
807,eventmesh-examples/src/main/java/org/apache/eventmesh/http/demo/pub/eventmeshmessage/SyncRequestInstance.java,"@@ -71,7 +73,7 @@ public static void main(String[] args) throws Exception {
 
             EventMeshMessage rsp = eventMeshHttpProducer.request(eventMeshMessage, 10000);
             if (logger.isDebugEnabled()) {
-                logger.debug(""sendmsg : {}, return : {}, cost:{}ms"", eventMeshMessage.getContent(), rsp.getContent(),
+                logger.debug(""sendmsg : {}, return : {}, cost:{} ms"", eventMeshMessage.getContent(), rsp.getContent(),","[{'comment': '```suggestion\r\n                logger.debug(""sendmsg: {}, return: {}, cost:{} ms"", eventMeshMessage.getContent(), rsp.getContent(),\r\n```', 'commenter': 'ruanwenjun'}, {'comment': 'ok, I completed the codestyle style consistency in second pr.  please review it. @ruanwenjun ', 'commenter': 'fengyongshe'}]"
821,eventmesh-schema-plugin/eventmesh-schema-api/src/main/java/org/apache/eventmesh/schema/api/SchemaPluginFactory.java,"@@ -0,0 +1,40 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.eventmesh.schema.api;
+
+import static com.google.common.base.Preconditions.checkNotNull;
+
+import org.apache.eventmesh.spi.EventMeshExtensionFactory;
+
+import lombok.experimental.UtilityClass;
+
+@UtilityClass
+public class SchemaPluginFactory {
+
+    /**
+     * Get {@code SchemaRegistry}
+     *
+     * @param schemaRegistryType the name of schema registry that configured in properties file
+     * @return schema registry plugin or null
+     */
+    public static SchemaRegistry getSchemaRegistry(String schemaRegistryType) {
+        checkNotNull(schemaRegistryType, ""SchemaRegistryType cannot be null"");
+        SchemaRegistry schemaRegistry = EventMeshExtensionFactory.getExtension(SchemaRegistry.class, schemaRegistryType);
+        return checkNotNull(schemaRegistry, ""MetricsRegistryType: "" + schemaRegistryType + "" is not supported"");
+    }","[{'comment': '```suggestion\r\n        return checkNotNull(schemaRegistry, ""SchemaRegistryType: "" + schemaRegistryType + "" is not supported"");\r\n```', 'commenter': 'ruanwenjun'}, {'comment': 'fixed', 'commenter': 'jzhou59'}]"
821,eventmesh-schema-plugin/eventmesh-schema-api/src/main/java/org/apache/eventmesh/schema/api/SchemaType.java,"@@ -0,0 +1,36 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.eventmesh.schema.api;
+
+import org.apache.commons.lang3.StringUtils;
+
+public enum SchemaType {
+    JSON(""JSON""),
+    AVRO(""AVRO""),
+    PROTOBUF(""PROTOBUF"");
+
+    private final String schemaTypeName;
+
+    SchemaType(String schemaTypeName) {
+        this.schemaTypeName = StringUtils.upperCase(StringUtils.deleteWhitespace(schemaTypeName));
+    }","[{'comment': 'Use `this.schemaTypeName = schemaTypeName` is better.', 'commenter': 'ruanwenjun'}, {'comment': 'Ok, I was trying to specify all schema types to uppercase.\r\nBut you are right, I have altered the schema type according to IETF(or official) abbreviation.\r\n\r\nReferences:\r\n- [JSON](https://datatracker.ietf.org/doc/html/rfc8259)\r\n- [Avro](https://avro.apache.org/docs/current/spec.html)\r\n- [Protobuf](https://datatracker.ietf.org/doc/html/draft-rfernando-protocol-buffers-00#section-1.1)', 'commenter': 'jzhou59'}]"
835,tools/third-party-dependencies/known-dependencies.txt,"@@ -124,4 +124,10 @@ system-rules-1.16.1.jar
 truth-0.30.jar
 zipkin-2.23.2.jar
 zipkin-reporter-2.16.3.jar
-zipkin-sender-okhttp3-2.16.3.jar
\ No newline at end of file
+zipkin-sender-okhttp3-2.16.3.jar
+httpasyncclient-4.1.3.jar
+httpcore-nio-4.4.6.jar
+javassist-3.21.0-GA.jar
+nacos-client-2.0.4.jar
+reflections-0.9.11.jar
+snakeyaml-1.23.jar","[{'comment': 'It needed to add notice into `NOTICE`', 'commenter': 'ruanwenjun'}, {'comment': 'What is a NOTICE？', 'commenter': 'li-xiao-shuang'}, {'comment': 'According to [Apache license](https://www.apache.org/licenses/LICENSE-2.0.html#redistribution), We need to add notice of third-party jar which is in Apache license into our NOTICE file.  But we are missing the NOTICE file :). @xwm1992 This might be an urgent thing need to fix.', 'commenter': 'ruanwenjun'}, {'comment': '> According to [Apache license](https://www.apache.org/licenses/LICENSE-2.0.html#redistribution), We need to add notice of third-party jar which is in Apache license into our NOTICE file. But we are missing the NOTICE file :). @xwm1992 This might be an urgent thing need to fix.\r\n\r\nI think there may be a lot to add, you can separate the issue to operate', 'commenter': 'li-xiao-shuang'}]"
835,eventmesh-spi/src/main/java/org/apache/eventmesh/spi/EventMeshExtensionFactory.java,"@@ -35,8 +35,7 @@
  * The extension fetching factory, all extension plugins should be fetched by this factory.
  * And all the extension plugins defined in eventmesh should have {@link EventMeshSPI} annotation.
  */
-public enum EventMeshExtensionFactory {
-    ;
+public class EventMeshExtensionFactory {","[{'comment': ""Use `enum` here is just want to make a singleton class, you can simply to add a private constructor if you want to remove the enum, but I don't think this is a needed change."", 'commenter': 'ruanwenjun'}, {'comment': 'All operations are static without creating an instance', 'commenter': 'li-xiao-shuang'}, {'comment': 'You need to add a private constructor and make this class final, this is [a good pattern](https://codepumpkin.com/use-private-constructor-java/).', 'commenter': 'ruanwenjun'}]"
835,eventmesh-runtime/src/main/java/org/apache/eventmesh/runtime/boot/EventMeshTCPServer.java,"@@ -292,37 +293,14 @@ public void shutdown() throws Exception {
         logger.info(""--------------------------EventMeshTCPServer Shutdown"");
     }
 
-    private void selfRegisterToRegistry() throws Exception {
-
-        boolean registerResult = registerToRegistry();
-        if (!registerResult) {
-            throw new EventMeshException(""eventMesh fail to register"");
-        }
-
-        tcpRegisterTask = scheduler.scheduleAtFixedRate(
-                () -> {
-                    try {
-                        boolean heartbeatResult = registerToRegistry();
-                        if (!heartbeatResult) {
-                            logger.error(""selfRegisterToRegistry fail"");
-                        }
-                    } catch (Exception ex) {
-                        logger.error(""selfRegisterToRegistry fail"", ex);
-                    }
-                },
-                eventMeshTCPConfiguration.eventMeshRegisterIntervalInMills,
-                eventMeshTCPConfiguration.eventMeshRegisterIntervalInMills,
-                TimeUnit.MILLISECONDS);
-    }
-
     public boolean registerToRegistry() {","[{'comment': '```suggestion\r\n    public boolean register() {\r\n```', 'commenter': 'ruanwenjun'}]"
835,eventmesh-runtime/src/main/java/org/apache/eventmesh/runtime/boot/EventMeshTCPServer.java,"@@ -334,35 +312,35 @@ public boolean registerToRegistry() {
     }
 
     private void selfUnRegisterToRegistry() throws Exception {","[{'comment': 'Suggest rename to `unRegister`', 'commenter': 'ruanwenjun'}]"
835,eventmesh-runtime/src/main/java/org/apache/eventmesh/runtime/boot/EventMeshServer.java,"@@ -101,18 +122,26 @@ public void start() throws Exception {
         if (eventMeshHttpConfiguration != null && eventMeshHttpConfiguration.eventMeshServerSecurityEnable) {
             acl.start();
         }
-
+        // registry start
         if (eventMeshTCPConfiguration != null
-                && eventMeshTCPConfiguration.eventMeshTcpServerEnabled
-                && eventMeshTCPConfiguration.eventMeshServerRegistryEnable) {
+            && eventMeshTCPConfiguration.eventMeshTcpServerEnabled
+            && eventMeshTCPConfiguration.eventMeshServerRegistryEnable) {
+            registry.start();
+        }
+        if (eventMeshHttpConfiguration != null && eventMeshHttpConfiguration.eventMeshServerRegistryEnable) {
+            registry.start();
+        }
+        if (eventMeshGrpcConfiguration != null && eventMeshGrpcConfiguration.eventMeshServerRegistryEnable) {
             registry.start();
         }","[{'comment': 'Can we simplify this? When we need to register, we may need to register not matter it use http/tcp/grpc.', 'commenter': 'ruanwenjun'}, {'comment': 'Here we just reuse the existing format and register for each protocol', 'commenter': 'li-xiao-shuang'}, {'comment': 'You can split it if you want to start HTTP or GRPC later', 'commenter': 'li-xiao-shuang'}]"
835,eventmesh-registry-plugin/eventmesh-registry-nacos/src/main/java/org/apache/eventmesh/registry/nacos/service/NacosRegistryService.java,"@@ -0,0 +1,178 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.eventmesh.registry.nacos.service;
+
+import org.apache.eventmesh.api.exception.RegistryException;
+import org.apache.eventmesh.api.registry.RegistryService;
+import org.apache.eventmesh.api.registry.dto.EventMeshDataInfo;
+import org.apache.eventmesh.api.registry.dto.EventMeshRegisterInfo;
+import org.apache.eventmesh.api.registry.dto.EventMeshUnRegisterInfo;
+import org.apache.eventmesh.common.config.CommonConfiguration;
+import org.apache.eventmesh.common.utils.ConfigurationContextUtil;
+import org.apache.eventmesh.registry.nacos.constant.NacosConstant;
+
+import org.apache.commons.lang3.StringUtils;
+
+import java.util.List;
+import java.util.Map;
+import java.util.Properties;
+import java.util.concurrent.atomic.AtomicBoolean;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import com.alibaba.nacos.api.exception.NacosException;
+import com.alibaba.nacos.api.naming.NamingService;
+import com.alibaba.nacos.api.naming.pojo.Instance;
+import com.alibaba.nacos.client.naming.NacosNamingService;
+
+public class NacosRegistryService implements RegistryService {
+
+    private static final Logger logger = LoggerFactory.getLogger(NacosRegistryService.class);
+
+    private static final AtomicBoolean INIT_STATUS = new AtomicBoolean(false);
+
+    private static final AtomicBoolean START_STATUS = new AtomicBoolean(false);
+
+    private String serverAddr;
+
+    private String username;
+
+    private String password;
+
+    private NamingService namingService;
+
+","[{'comment': 'Please remove the extra empty line.', 'commenter': 'ruanwenjun'}]"
835,eventmesh-registry-plugin/eventmesh-registry-nacos/src/main/java/org/apache/eventmesh/registry/nacos/service/NacosRegistryService.java,"@@ -0,0 +1,178 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.eventmesh.registry.nacos.service;
+
+import org.apache.eventmesh.api.exception.RegistryException;
+import org.apache.eventmesh.api.registry.RegistryService;
+import org.apache.eventmesh.api.registry.dto.EventMeshDataInfo;
+import org.apache.eventmesh.api.registry.dto.EventMeshRegisterInfo;
+import org.apache.eventmesh.api.registry.dto.EventMeshUnRegisterInfo;
+import org.apache.eventmesh.common.config.CommonConfiguration;
+import org.apache.eventmesh.common.utils.ConfigurationContextUtil;
+import org.apache.eventmesh.registry.nacos.constant.NacosConstant;
+
+import org.apache.commons.lang3.StringUtils;
+
+import java.util.List;
+import java.util.Map;
+import java.util.Properties;
+import java.util.concurrent.atomic.AtomicBoolean;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import com.alibaba.nacos.api.exception.NacosException;
+import com.alibaba.nacos.api.naming.NamingService;
+import com.alibaba.nacos.api.naming.pojo.Instance;
+import com.alibaba.nacos.client.naming.NacosNamingService;
+
+public class NacosRegistryService implements RegistryService {
+
+    private static final Logger logger = LoggerFactory.getLogger(NacosRegistryService.class);
+
+    private static final AtomicBoolean INIT_STATUS = new AtomicBoolean(false);
+
+    private static final AtomicBoolean START_STATUS = new AtomicBoolean(false);
+
+    private String serverAddr;
+
+    private String username;
+
+    private String password;
+
+    private NamingService namingService;
+
+
+    @Override
+    public void init() throws RegistryException {
+        boolean update = INIT_STATUS.compareAndSet(false, true);
+        if (!update) {
+            return;
+        }
+        for (String key : ConfigurationContextUtil.KEYS) {
+            CommonConfiguration commonConfiguration = ConfigurationContextUtil.get(key);
+            if (null == commonConfiguration) {
+                continue;
+            }
+            if (StringUtils.isBlank(commonConfiguration.namesrvAddr)) {
+                throw new RegistryException(""namesrvAddr cannot be null"");
+            }
+            this.serverAddr = commonConfiguration.namesrvAddr;
+            this.username = commonConfiguration.eventMeshRegistryPluginUsername;
+            this.password = commonConfiguration.eventMeshRegistryPluginPassword;
+            break;
+        }
+    }
+
+    @Override
+    public void start() throws RegistryException {
+        boolean update = START_STATUS.compareAndSet(false, true);
+        if (!update) {
+            return;
+        }
+        try {
+            Properties properties = new Properties();
+            properties.setProperty(NacosConstant.SERVER_ADDR, serverAddr);
+            properties.setProperty(NacosConstant.USERNAME, username);
+            properties.setProperty(NacosConstant.PASSWORD, password);
+            namingService = new NacosNamingService(properties);
+        } catch (NacosException e) {
+            logger.error(""[NacosRegistryService][start] error"", e);
+            throw new RegistryException(e.getMessage());
+        }
+    }
+
+    @Override
+    public void shutdown() throws RegistryException {
+        INIT_STATUS.compareAndSet(true, false);
+        START_STATUS.compareAndSet(true, false);
+        try {
+            namingService.shutDown();
+        } catch (NacosException e) {
+            logger.error(""[NacosRegistryService][shutdown] error"", e);
+            throw new RegistryException(e.getMessage());
+        }
+        logger.info(""NacosRegistryService close"");
+    }
+
+    @Override
+    public List<EventMeshDataInfo> findEventMeshInfoByCluster(String clusterName) throws RegistryException {
+        return null;","[{'comment': 'It needed to add a `TODO` here, if this is not finished.', 'commenter': 'ruanwenjun'}]"
835,eventmesh-common/src/main/java/org/apache/eventmesh/common/utils/ConfigurationContextUtil.java,"@@ -0,0 +1,74 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.eventmesh.common.utils;
+
+import org.apache.eventmesh.common.config.CommonConfiguration;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.concurrent.ConcurrentHashMap;
+
+/**
+ * ConfigurationContextUtil.
+ */
+public class ConfigurationContextUtil {
+
+    private static final ConcurrentHashMap<String, CommonConfiguration> CONFIGURATION_MAP = new ConcurrentHashMap<>();
+
+    public static final String HTTP = ""http"";
+
+    public static final String TCP = ""tcp"";
+    public static final String GRPC = ""grpc"";
+
+    public static final List<String> KEYS = new ArrayList<String>() {
+        {
+            add(HTTP);
+            add(TCP);
+            add(GRPC);
+        }
+    };
+
+
+    /**
+     * Save http, tcp, grpc configuration at startup for global use.","[{'comment': 'Since you use `putIfAbsent` here, you need to add comment to announce that this method will not overwrite the value, or you can change the `add` to `putIfAbsent`.', 'commenter': 'ruanwenjun'}]"
835,eventmesh-common/src/main/java/org/apache/eventmesh/common/utils/ConfigurationContextUtil.java,"@@ -0,0 +1,74 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.eventmesh.common.utils;
+
+import org.apache.eventmesh.common.config.CommonConfiguration;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.concurrent.ConcurrentHashMap;
+
+/**
+ * ConfigurationContextUtil.
+ */
+public class ConfigurationContextUtil {
+
+    private static final ConcurrentHashMap<String, CommonConfiguration> CONFIGURATION_MAP = new ConcurrentHashMap<>();
+
+    public static final String HTTP = ""http"";
+
+    public static final String TCP = ""tcp"";
+    public static final String GRPC = ""grpc"";
+
+    public static final List<String> KEYS = new ArrayList<String>() {
+        {
+            add(HTTP);
+            add(TCP);
+            add(GRPC);
+        }
+    };","[{'comment': 'Use this way will generate an extra child class of ArrayList, this is not a good practice.\r\n```suggestion\r\n    public static final List<String> KEYS = Lists.newArrayList(HTTP, TCP, GRPC);\r\n```', 'commenter': 'ruanwenjun'}]"
849,tools/third-party-dependencies/known-dependencies.txt,"@@ -130,4 +130,5 @@ httpcore-nio-4.4.6.jar
 javassist-3.21.0-GA.jar
 nacos-client-2.0.4.jar
 reflections-0.9.11.jar
-snakeyaml-1.23.jar
\ No newline at end of file
+snakeyaml-1.23.jar
+spring-boot-starter-web-2.6.7.jar","[{'comment': ""Right now, the example module will not be packaged into distribution, so we may don't need to add license of `spring-boot-starter-web-2.6.7`? Actually, I suggest we add example into our distribution. cc @xwm1992 "", 'commenter': 'ruanwenjun'}, {'comment': 'So ? You decide .', 'commenter': 'misselvexu'}, {'comment': ""> Right now, the example module will not be packaged into distribution, so we may don't need to add license of `spring-boot-starter-web-2.6.7`? Actually, I suggest we add example into our distribution. cc @xwm1992\r\n\r\nnot only for distribution, theses modules are all upload to the maven repository. https://mvnrepository.com/artifact/org.apache.eventmesh"", 'commenter': 'xwm1992'}, {'comment': 'Got it, fixed.', 'commenter': 'misselvexu'}, {'comment': ""Currently, the check license script will only check the third-part libs in distribution. If we didn't add the example module in distribution, we can't add `spring-boot-starter-web-2.6.7.jar ` in this file, otherwise the license check will fail."", 'commenter': 'ruanwenjun'}, {'comment': ""> Currently, the check license script will only check the third-part libs in distribution. If we didn't add the example module in distribution, we can't add `spring-boot-starter-web-2.6.7.jar ` in this file, otherwise the license check will fail.\r\n\r\nOk, I get what you mean,  we either only upgrade the `spring-boot-starter-web-2.6.7.jar` version and not add this to the file `known-dependencies.txt`, or add the `example moudule` into the distribution ? I prefer the former, not add  `spring-boot-starter-web-2.6.7.jar` to the files, because the `example` don't need to be used in distributions. @misselvexu @ruanwenjun what's your opinion?"", 'commenter': 'xwm1992'}, {'comment': 'Already removed temporarily .', 'commenter': 'misselvexu'}, {'comment': ""In this PR, we don't need to add `pring-boot-starter-web-2.6.7.jar` into `known-dependencies.txt `. We can add another PR to add example module into distribution."", 'commenter': 'ruanwenjun'}, {'comment': 'okay. I will submit another PR to fix it.', 'commenter': 'misselvexu'}, {'comment': 'Before submit PR, you can discuss this in issue or mail, I am not sure if this is needed.', 'commenter': 'ruanwenjun'}]"
867,eventmesh-trace-plugin/eventmesh-trace-zipkin/src/main/java/org/apache/eventmesh/trace/zipkin/ZipkinTraceService.java,"@@ -92,7 +94,8 @@ public void init() {
             .setTracerProvider(sdkTracerProvider)
             .build();
 
-        Runtime.getRuntime().addShutdownHook(new Thread(sdkTracerProvider::close));
+        shutdownHook = new Thread(sdkTracerProvider::close);
+        Runtime.getRuntime().addShutdownHook(shutdownHook);","[{'comment': ""I don't think this change is needed."", 'commenter': 'ruanwenjun'}, {'comment': ""^ to keep the reference to the shutdownHookThread, thus the behavior of `addShutdownHook` could be tested (it raise `Hook previously registered` when the same shutdownHookThread is added at second time).\r\n\r\nhttps://github.com/apache/incubator-eventmesh/blob/6ea8944b8c91314b296acbb9ef107902c32b084d/eventmesh-trace-plugin/eventmesh-trace-zipkin/src/test/java/org/apache/eventmesh/trace/zipkin/ZipkinTraceServiceTest.java#L47-L55\r\n\r\nthe `new Thread(sdkTracerProvider::close)` is not the same shutdownHookThread as previous, it could be added successfully and doesn't raise any exception (thus the behavior of `addShutdownHook` could not be tested).\r\n\r\nhttps://github.com/apache/incubator-eventmesh/blob/836e3a5bd6a25c9831b0c6a8db30c997c68f0e91/eventmesh-trace-plugin/eventmesh-trace-zipkin/src/main/java/org/apache/eventmesh/trace/zipkin/ZipkinTraceService.java#L95"", 'commenter': 'HoffmanZheng'}, {'comment': 'In your assert, you add a shutdown hook twice, then it throws an exception. Does this test make sense? ', 'commenter': 'ruanwenjun'}, {'comment': '> add a shutdown hook twice, then it throws an exception\r\n\r\nthe shutdown hook is already added in the `zipkinTraceService.init();`, thus it throws exception in test as expected.\r\n\r\nIt ensures the `addShutdownHook` is called in the `init()` method, and the `Thread(sdkTracerProvider::close)` is added there. If someone change the behavior of that (e.g. remove the whole line `Runtime.getRuntime().addShutdownHook(new Thread(sdkTracerProvider::close));`), the unit test would fail.\r\n', 'commenter': 'HoffmanZheng'}, {'comment': 'OK, I got it.', 'commenter': 'ruanwenjun'}]"
867,eventmesh-trace-plugin/eventmesh-trace-zipkin/src/test/java/org/apache/eventmesh/trace/zipkin/ZipkinTraceServiceTest.java,"@@ -0,0 +1,70 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.eventmesh.trace.zipkin;
+
+import static org.junit.Assert.assertThrows;
+
+import java.lang.reflect.Field;
+
+import org.junit.Assert;
+import org.junit.Test;
+import org.mockito.Mockito;
+
+import io.opentelemetry.api.OpenTelemetry;
+import io.opentelemetry.sdk.trace.SdkTracerProvider;
+
+public class ZipkinTraceServiceTest {
+
+    @Test
+    public void testInit() throws NoSuchFieldException, IllegalAccessException {
+        ZipkinTraceService zipkinTraceService = new ZipkinTraceService();
+        zipkinTraceService.init();
+
+        Field sdkTracerProviderField = ZipkinTraceService.class.getDeclaredField(""sdkTracerProvider"");
+        Field openTelemetryField = ZipkinTraceService.class.getDeclaredField(""openTelemetry"");
+        Field shutdownHookField = ZipkinTraceService.class.getDeclaredField(""shutdownHook"");
+        sdkTracerProviderField.setAccessible(true);
+        openTelemetryField.setAccessible(true);
+        shutdownHookField.setAccessible(true);","[{'comment': 'The better way is to change the visibility in `ZipkinTraceService` rather than use reflect.', 'commenter': 'ruanwenjun'}, {'comment': 'Do you mean change the modifier of these member variable from private to `protected` ?\r\nThat makes sense to me, the test code located in the same package of `ZipkinTraceService `, which makes the protected member variable also accessible.', 'commenter': 'HoffmanZheng'}, {'comment': 'Yes.', 'commenter': 'ruanwenjun'}]"
884,eventmesh-sdk-java/build.gradle,"@@ -15,10 +15,15 @@
  * limitations under the License.
  */
 
+plugins {
+    id 'java-library'
+    id 'com.github.johnrengelman.shadow' version '7.1.2'","[{'comment': 'After I use the `java-library` and change the dependency configuration to `api`, the built jar file still does not contain the dependencies.\r\nThus the `shadow` plugin used here to generate a fat jar. (for your [reference](https://discuss.gradle.org/t/how-to-include-dependencies-in-jar/19571))', 'commenter': 'HoffmanZheng'}]"
884,eventmesh-sdk-java/build.gradle,"@@ -50,10 +54,9 @@ dependencies {
     implementation ""io.grpc:grpc-protobuf:1.15.0""
     implementation ""io.grpc:grpc-stub:1.15.0""
     implementation ""com.google.protobuf:protobuf-java-util:3.5.1""
-    compileOnly 'org.projectlombok:lombok:1.18.22'
+    api 'org.projectlombok:lombok:1.18.22'","[{'comment': ""In my knowledge, the lombok plugin will only be used in compile time.\r\n```suggestion\r\n    compileOnly 'org.projectlombok:lombok:1.18.22'\r\n```"", 'commenter': 'ruanwenjun'}, {'comment': ""also make sense to me, seems the `eventmesh-example` uses that only for log. it's not necessary to export to the users of `eventmesh-sdk-java`\r\nhttps://github.com/apache/incubator-eventmesh/blob/c055e8324fd6b0c67055b2f4c6731f386acdb5a4/eventmesh-examples/src/main/java/org/apache/eventmesh/http/demo/sub/controller/SubController.java#L42\r\nhttps://github.com/apache/incubator-eventmesh/blob/c055e8324fd6b0c67055b2f4c6731f386acdb5a4/eventmesh-examples/src/main/java/org/apache/eventmesh/http/demo/sub/controller/SubController.java#L56"", 'commenter': 'HoffmanZheng'}]"
884,eventmesh-sdk-java/build.gradle,"@@ -15,10 +15,14 @@
  * limitations under the License.
  */
 
+plugins {
+    id 'java-library'
+}
+","[{'comment': 'It seems this already defined at root `build.gradle`\r\n```suggestion\r\n```', 'commenter': 'ruanwenjun'}]"
894,eventmesh-sdk-java/src/test/java/org/apache/eventmesh/client/grpc/consumer/EventMeshGrpcConsumerTest.java,"@@ -0,0 +1,155 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.eventmesh.client.grpc.consumer;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.verifyZeroInteractions;
+import static org.mockito.Mockito.when;
+
+import org.apache.eventmesh.client.grpc.config.EventMeshGrpcClientConfig;
+import org.apache.eventmesh.common.EventMeshMessage;
+import org.apache.eventmesh.common.protocol.SubscriptionItem;
+import org.apache.eventmesh.common.protocol.SubscriptionMode;
+import org.apache.eventmesh.common.protocol.SubscriptionType;
+import org.apache.eventmesh.common.protocol.grpc.protos.ConsumerServiceGrpc.ConsumerServiceBlockingStub;
+import org.apache.eventmesh.common.protocol.grpc.protos.ConsumerServiceGrpc.ConsumerServiceStub;
+import org.apache.eventmesh.common.protocol.grpc.protos.HeartbeatServiceGrpc.HeartbeatServiceBlockingStub;
+import org.apache.eventmesh.common.protocol.grpc.protos.Response;
+import org.apache.eventmesh.common.protocol.grpc.protos.SimpleMessage;
+import org.apache.eventmesh.common.protocol.grpc.protos.Subscription;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import java.util.Optional;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.Mockito;
+import org.mockito.internal.util.reflection.FieldSetter;
+import org.powermock.core.classloader.annotations.PowerMockIgnore;
+import org.powermock.core.classloader.annotations.PrepareForTest;
+import org.powermock.modules.junit4.PowerMockRunner;
+
+import io.grpc.stub.StreamObserver;
+
+@RunWith(PowerMockRunner.class)
+@PrepareForTest({ConsumerServiceBlockingStub.class, ConsumerServiceStub.class, HeartbeatServiceBlockingStub.class})
+@PowerMockIgnore({""javax.management.*"", ""com.sun.org.apache.xerces.*"", ""javax.xml.*"", ""org.xml.*"", ""org.w3c.*""})
+public class EventMeshGrpcConsumerTest {
+
+    @Mock
+    private ConsumerServiceBlockingStub consumerClient;
+    @Mock
+    private ConsumerServiceStub consumerAsyncClient;
+    @Mock
+    private HeartbeatServiceBlockingStub heartbeatClient;
+    private EventMeshGrpcConsumer eventMeshGrpcConsumer;
+
+    @Before
+    public void setUp() throws Exception {
+        eventMeshGrpcConsumer = new EventMeshGrpcConsumer(EventMeshGrpcClientConfig.builder().build());
+        eventMeshGrpcConsumer.init();
+        FieldSetter.setField(eventMeshGrpcConsumer, eventMeshGrpcConsumer.getClass().getDeclaredField(""consumerClient""),
+            consumerClient);
+        FieldSetter.setField(eventMeshGrpcConsumer,
+            eventMeshGrpcConsumer.getClass().getDeclaredField(""consumerAsyncClient""), consumerAsyncClient);
+        FieldSetter.setField(eventMeshGrpcConsumer,
+            eventMeshGrpcConsumer.getClass().getDeclaredField(""heartbeatClient""), heartbeatClient);
+        when(consumerClient.subscribe(any())).thenReturn(Response.getDefaultInstance());","[{'comment': 'Use reflect to create test object is not a good practice, When someone changes the field name, he cannot find out the problem in compile.\r\nYou can try to change the scope of field in `consumerClient`. The same to other test file.', 'commenter': 'ruanwenjun'}, {'comment': 'Yes, if someone change the field name, error will only be thrown when the test case is run. Change the field scope to `protected` will resolve the problem. I have another idea, what about we create a setter method with protected modification and `VisibleForTest` comment. Like this:\r\n\r\n```java\r\nprivate ConsumerServiceBlockingStub consumerClient;\r\n\r\n/**\r\n*VisibleForTest\r\n**/\r\nprotected void setConsumerClient(ConsumerServiceBlockingStub consumerClient) {\r\n    this.consumerClient = consumerClient;\r\n}\r\n```', 'commenter': 'wallezhang'}, {'comment': ""I would like to change the field to default or protected, no need to add setter method, in fact, we shouldn't add a method to modify this field."", 'commenter': 'ruanwenjun'}, {'comment': 'OK, I try to fix it.', 'commenter': 'wallezhang'}]"
897,eventmesh-webhook/eventmesh-webhook-api/src/main/java/org/apache/eventmesh/webhook/api/WebHookConfig.java,"@@ -75,7 +75,9 @@ public class WebHookConfig {
 	private String cloudEventName;
 
 	/**
-	 * 如果是http协议就需要标记请求头 contentType的类型
+	 * 	转出数据格式 -> 指定如何将 CloudEvent 序列化为字节序列
+	 *  如果是http协议就需要标记请求头 contentType的类型
+	 *  contentType -> DataContentType
 	 */
 	private String DataContentType;","[{'comment': 'DataContentType -> dataContentType ?', 'commenter': 'xwm1992'}, {'comment': 'the code comments please change to English', 'commenter': 'xwm1992'}]"
901,eventmesh-registry-plugin/eventmesh-registry-consul/src/main/java/org/apache/eventmesh/registry/consul/service/ConsulRegistryService.java,"@@ -0,0 +1,174 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.eventmesh.registry.consul.service;
+
+import static org.apache.eventmesh.registry.consul.constant.ConsulConstant.DEFAULT_CONNECTION_TIMEOUT;
+import static org.apache.eventmesh.registry.consul.constant.ConsulConstant.DEFAULT_MAX_CONNECTIONS;
+import static org.apache.eventmesh.registry.consul.constant.ConsulConstant.DEFAULT_MAX_PER_ROUTE_CONNECTIONS;
+import static org.apache.eventmesh.registry.consul.constant.ConsulConstant.DEFAULT_READ_TIMEOUT;
+import static org.apache.eventmesh.registry.consul.constant.ConsulConstant.IP_PORT_SEPARATOR;
+
+import org.apache.eventmesh.api.exception.RegistryException;
+import org.apache.eventmesh.api.registry.RegistryService;
+import org.apache.eventmesh.api.registry.dto.EventMeshDataInfo;
+import org.apache.eventmesh.api.registry.dto.EventMeshRegisterInfo;
+import org.apache.eventmesh.api.registry.dto.EventMeshUnRegisterInfo;
+import org.apache.eventmesh.common.config.CommonConfiguration;
+import org.apache.eventmesh.common.utils.ConfigurationContextUtil;
+
+import org.apache.commons.lang3.StringUtils;
+import org.apache.http.client.HttpClient;
+import org.apache.http.client.config.RequestConfig;
+import org.apache.http.impl.client.HttpClientBuilder;
+import org.apache.http.impl.conn.PoolingHttpClientConnectionManager;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.atomic.AtomicBoolean;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import com.ecwid.consul.v1.ConsulClient;
+import com.ecwid.consul.v1.ConsulRawClient;
+import com.ecwid.consul.v1.agent.model.NewService;
+import com.ecwid.consul.v1.agent.model.Service;
+import com.ecwid.consul.v1.health.HealthServicesRequest;
+
+public class ConsulRegistryService implements RegistryService {
+
+    private static final Logger logger = LoggerFactory.getLogger(ConsulRegistryService.class);
+
+    private static final AtomicBoolean INIT_STATUS = new AtomicBoolean(false);
+
+    private static final AtomicBoolean START_STATUS = new AtomicBoolean(false);
+
+    private String consulHost;
+
+    private String consulPort;
+
+    private ConsulClient consulClient;
+
+    @Override
+    public void init() throws RegistryException {
+        if (INIT_STATUS.compareAndSet(false, true)) {
+            for (String key : ConfigurationContextUtil.KEYS) {
+                CommonConfiguration commonConfiguration = ConfigurationContextUtil.get(key);
+                if (null != commonConfiguration) {
+                    String namesrvAddr = commonConfiguration.namesrvAddr;
+                    if (StringUtils.isBlank(namesrvAddr)) {
+                        throw new RegistryException(""namesrvAddr cannot be null"");
+                    }
+                    String[] addr = namesrvAddr.split("":"");
+                    if (addr.length != 2) {
+                        throw new RegistryException(""Illegal namesrvAddr"");
+                    }
+                    this.consulHost = addr[0];
+                    this.consulPort = addr[1];
+                    break;
+                }
+            }
+        }
+    }
+
+    @Override
+    public void start() throws RegistryException {
+        consulClient = new ConsulClient(new ConsulRawClient(consulHost, Integer.parseInt(consulPort), getHttpClient()));","[{'comment': 'I think ACL should be supported', 'commenter': 'li-xiao-shuang'}, {'comment': 'Token support？', 'commenter': 'huyuanxin'}, {'comment': '> Token support？\r\n\r\nYes, authentication needs to be turned on in actual applications, so it needs to support authentication', 'commenter': 'li-xiao-shuang'}]"
901,eventmesh-registry-plugin/eventmesh-registry-consul/src/main/java/org/apache/eventmesh/registry/consul/service/ConsulRegistryService.java,"@@ -0,0 +1,174 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.eventmesh.registry.consul.service;
+
+import static org.apache.eventmesh.registry.consul.constant.ConsulConstant.DEFAULT_CONNECTION_TIMEOUT;
+import static org.apache.eventmesh.registry.consul.constant.ConsulConstant.DEFAULT_MAX_CONNECTIONS;
+import static org.apache.eventmesh.registry.consul.constant.ConsulConstant.DEFAULT_MAX_PER_ROUTE_CONNECTIONS;
+import static org.apache.eventmesh.registry.consul.constant.ConsulConstant.DEFAULT_READ_TIMEOUT;
+import static org.apache.eventmesh.registry.consul.constant.ConsulConstant.IP_PORT_SEPARATOR;
+
+import org.apache.eventmesh.api.exception.RegistryException;
+import org.apache.eventmesh.api.registry.RegistryService;
+import org.apache.eventmesh.api.registry.dto.EventMeshDataInfo;
+import org.apache.eventmesh.api.registry.dto.EventMeshRegisterInfo;
+import org.apache.eventmesh.api.registry.dto.EventMeshUnRegisterInfo;
+import org.apache.eventmesh.common.config.CommonConfiguration;
+import org.apache.eventmesh.common.utils.ConfigurationContextUtil;
+
+import org.apache.commons.lang3.StringUtils;
+import org.apache.http.client.HttpClient;
+import org.apache.http.client.config.RequestConfig;
+import org.apache.http.impl.client.HttpClientBuilder;
+import org.apache.http.impl.conn.PoolingHttpClientConnectionManager;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.atomic.AtomicBoolean;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import com.ecwid.consul.v1.ConsulClient;
+import com.ecwid.consul.v1.ConsulRawClient;
+import com.ecwid.consul.v1.agent.model.NewService;
+import com.ecwid.consul.v1.agent.model.Service;
+import com.ecwid.consul.v1.health.HealthServicesRequest;
+
+public class ConsulRegistryService implements RegistryService {
+
+    private static final Logger logger = LoggerFactory.getLogger(ConsulRegistryService.class);
+
+    private static final AtomicBoolean INIT_STATUS = new AtomicBoolean(false);
+
+    private static final AtomicBoolean START_STATUS = new AtomicBoolean(false);
+
+    private String consulHost;
+
+    private String consulPort;
+
+    private ConsulClient consulClient;
+
+    @Override
+    public void init() throws RegistryException {
+        if (INIT_STATUS.compareAndSet(false, true)) {
+            for (String key : ConfigurationContextUtil.KEYS) {
+                CommonConfiguration commonConfiguration = ConfigurationContextUtil.get(key);
+                if (null != commonConfiguration) {
+                    String namesrvAddr = commonConfiguration.namesrvAddr;
+                    if (StringUtils.isBlank(namesrvAddr)) {
+                        throw new RegistryException(""namesrvAddr cannot be null"");
+                    }
+                    String[] addr = namesrvAddr.split("":"");
+                    if (addr.length != 2) {
+                        throw new RegistryException(""Illegal namesrvAddr"");
+                    }
+                    this.consulHost = addr[0];
+                    this.consulPort = addr[1];
+                    break;
+                }
+            }
+        }
+    }
+
+    @Override
+    public void start() throws RegistryException {
+        consulClient = new ConsulClient(new ConsulRawClient(consulHost, Integer.parseInt(consulPort), getHttpClient()));
+    }
+
+    @Override
+    public void shutdown() throws RegistryException {
+        INIT_STATUS.compareAndSet(true, false);
+        START_STATUS.compareAndSet(true, false);
+        consulClient = null;
+    }
+
+    @Override
+    public boolean register(EventMeshRegisterInfo eventMeshRegisterInfo) throws RegistryException {
+        try {
+            String[] ipPort = eventMeshRegisterInfo.getEndPoint().split(IP_PORT_SEPARATOR);
+            NewService service = new NewService();
+            service.setPort(Integer.parseInt(ipPort[1]));
+            service.setAddress(ipPort[0]);
+            service.setName(eventMeshRegisterInfo.getEventMeshClusterName());
+            service.setId(eventMeshRegisterInfo.getEventMeshClusterName() + ""-"" + eventMeshRegisterInfo.getEventMeshName());
+            consulClient.agentServiceRegister(service);
+        } catch (Exception e) {
+            throw new RegistryException(e.getMessage());
+        }
+        logger.info(""EventMesh successfully registered to consul"");
+        return true;
+    }
+
+    @Override
+    public boolean unRegister(EventMeshUnRegisterInfo eventMeshUnRegisterInfo) throws RegistryException {
+        try {
+            consulClient.agentServiceDeregister(eventMeshUnRegisterInfo.getEventMeshClusterName() + ""-"" + eventMeshUnRegisterInfo.getEventMeshName());
+        } catch (Exception e) {
+            throw new RegistryException(e.getMessage());
+        }
+        logger.info(""EventMesh successfully unregistered to consul"");
+        return true;
+    }
+
+    @Override
+    public List<EventMeshDataInfo> findEventMeshInfoByCluster(String clusterName) throws RegistryException {
+        Map<String, Service> agentServices = consulClient.getAgentServices().getValue();
+        HealthServicesRequest request = HealthServicesRequest.newBuilder().setPassing(true).build();
+        consulClient.getHealthServices(clusterName, request);
+        List<EventMeshDataInfo> eventMeshDataInfos = new ArrayList<>();
+        agentServices.forEach((k, v) -> {
+            String[] split = v.getId().split(""-"");
+            eventMeshDataInfos.add(new EventMeshDataInfo(split[0], split[1], v.getAddress() + "":"" + v.getPort(), 0));
+        });
+        return eventMeshDataInfos;
+    }
+
+    @Override
+    public Map<String, Map<String, Integer>> findEventMeshClientDistributionData(String clusterName, String group, String purpose)
+        throws RegistryException {
+        return Collections.emptyMap();
+    }
+
+
+    private HttpClient getHttpClient() {","[{'comment': ""consul already provides DEFAULT_HTTP_TRANSPORT, I don't think this code is necessary"", 'commenter': 'li-xiao-shuang'}, {'comment': 'yep,I will delete it', 'commenter': 'huyuanxin'}]"
901,eventmesh-registry-plugin/eventmesh-registry-consul/src/main/java/org/apache/eventmesh/registry/consul/service/ConsulRegistryService.java,"@@ -0,0 +1,174 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.eventmesh.registry.consul.service;
+
+import static org.apache.eventmesh.registry.consul.constant.ConsulConstant.DEFAULT_CONNECTION_TIMEOUT;
+import static org.apache.eventmesh.registry.consul.constant.ConsulConstant.DEFAULT_MAX_CONNECTIONS;
+import static org.apache.eventmesh.registry.consul.constant.ConsulConstant.DEFAULT_MAX_PER_ROUTE_CONNECTIONS;
+import static org.apache.eventmesh.registry.consul.constant.ConsulConstant.DEFAULT_READ_TIMEOUT;
+import static org.apache.eventmesh.registry.consul.constant.ConsulConstant.IP_PORT_SEPARATOR;
+
+import org.apache.eventmesh.api.exception.RegistryException;
+import org.apache.eventmesh.api.registry.RegistryService;
+import org.apache.eventmesh.api.registry.dto.EventMeshDataInfo;
+import org.apache.eventmesh.api.registry.dto.EventMeshRegisterInfo;
+import org.apache.eventmesh.api.registry.dto.EventMeshUnRegisterInfo;
+import org.apache.eventmesh.common.config.CommonConfiguration;
+import org.apache.eventmesh.common.utils.ConfigurationContextUtil;
+
+import org.apache.commons.lang3.StringUtils;
+import org.apache.http.client.HttpClient;
+import org.apache.http.client.config.RequestConfig;
+import org.apache.http.impl.client.HttpClientBuilder;
+import org.apache.http.impl.conn.PoolingHttpClientConnectionManager;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.atomic.AtomicBoolean;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import com.ecwid.consul.v1.ConsulClient;
+import com.ecwid.consul.v1.ConsulRawClient;
+import com.ecwid.consul.v1.agent.model.NewService;
+import com.ecwid.consul.v1.agent.model.Service;
+import com.ecwid.consul.v1.health.HealthServicesRequest;
+
+public class ConsulRegistryService implements RegistryService {
+
+    private static final Logger logger = LoggerFactory.getLogger(ConsulRegistryService.class);
+
+    private static final AtomicBoolean INIT_STATUS = new AtomicBoolean(false);
+
+    private static final AtomicBoolean START_STATUS = new AtomicBoolean(false);
+
+    private String consulHost;
+
+    private String consulPort;
+
+    private ConsulClient consulClient;
+
+    @Override
+    public void init() throws RegistryException {
+        if (INIT_STATUS.compareAndSet(false, true)) {
+            for (String key : ConfigurationContextUtil.KEYS) {
+                CommonConfiguration commonConfiguration = ConfigurationContextUtil.get(key);
+                if (null != commonConfiguration) {
+                    String namesrvAddr = commonConfiguration.namesrvAddr;
+                    if (StringUtils.isBlank(namesrvAddr)) {
+                        throw new RegistryException(""namesrvAddr cannot be null"");
+                    }
+                    String[] addr = namesrvAddr.split("":"");
+                    if (addr.length != 2) {
+                        throw new RegistryException(""Illegal namesrvAddr"");
+                    }
+                    this.consulHost = addr[0];
+                    this.consulPort = addr[1];
+                    break;
+                }
+            }
+        }
+    }
+
+    @Override
+    public void start() throws RegistryException {
+        consulClient = new ConsulClient(new ConsulRawClient(consulHost, Integer.parseInt(consulPort), getHttpClient()));
+    }
+
+    @Override
+    public void shutdown() throws RegistryException {
+        INIT_STATUS.compareAndSet(true, false);
+        START_STATUS.compareAndSet(true, false);
+        consulClient = null;
+    }
+
+    @Override
+    public boolean register(EventMeshRegisterInfo eventMeshRegisterInfo) throws RegistryException {
+        try {
+            String[] ipPort = eventMeshRegisterInfo.getEndPoint().split(IP_PORT_SEPARATOR);
+            NewService service = new NewService();
+            service.setPort(Integer.parseInt(ipPort[1]));
+            service.setAddress(ipPort[0]);
+            service.setName(eventMeshRegisterInfo.getEventMeshClusterName());","[{'comment': 'Many service instances may share the same logical service name. The service name of eventmesh should be used here, not the cluster name. Can the namespace of consul distinguish clusters?', 'commenter': 'li-xiao-shuang'}]"
906,README.zh-CN.md,"@@ -1,81 +1,89 @@
-# Apache EventMesh (Incubating)
+<div align=""center"">
 
-[![CI status](https://github.com/apache/incubator-eventmesh/actions/workflows/ci.yml/badge.svg)](https://github.com/apache/incubator-eventmesh/actions/workflows/ci.yml)
-[![CodeCov](https://codecov.io/gh/apache/incubator-eventmesh/branch/develop/graph/badge.svg)](https://codecov.io/gh/apache/incubator-eventmesh)
-[![Language grade: Java](https://img.shields.io/lgtm/grade/java/g/apache/incubator-eventmesh.svg?logo=lgtm&logoWidth=18)](https://lgtm.com/projects/g/apache/incubator-eventmesh/context:java)
-[![Total alerts](https://img.shields.io/lgtm/alerts/g/apache/incubator-eventmesh.svg?logo=lgtm&logoWidth=18)](https://lgtm.com/projects/g/apache/incubator-eventmesh/alerts/)
-[![GitHub release](https://img.shields.io/badge/release-download-orange.svg)](https://github.com/apache/incubator-eventmesh/releases)
-[![License](https://img.shields.io/badge/license-Apache%202-4EB1BA.svg)](https://www.apache.org/licenses/LICENSE-2.0.html)
+<br /><br />
+<img src=""docs/images/logo.png"" width=""256"">
+<br />
 
-![logo](docs/images/logo2.png)
+[![CI status](https://img.shields.io/github/workflow/status/apache/incubator-eventmesh/Continuous%20Integration?logo=github&style=for-the-badge)](https://github.com/apache/incubator-eventmesh/actions/workflows/ci.yml)
+[![CodeCov](https://img.shields.io/codecov/c/gh/apache/incubator-eventmesh/master?logo=codecov&style=for-the-badge)](https://codecov.io/gh/apache/incubator-eventmesh)
+[![Code Quality: Java](https://img.shields.io/lgtm/grade/java/g/apache/incubator-eventmesh.svg?logo=lgtm&logoWidth=18&style=for-the-badge)](https://lgtm.com/projects/g/apache/incubator-eventmesh/context:java)
+[![Total Alerts](https://img.shields.io/lgtm/alerts/g/apache/incubator-eventmesh.svg?logo=lgtm&logoWidth=18&style=for-the-badge)](https://lgtm.com/projects/g/apache/incubator-eventmesh/alerts/)
 
-## 什么是Event Mesh？
+[![License](https://img.shields.io/github/license/apache/incubator-eventmesh?style=for-the-badge)](https://www.apache.org/licenses/LICENSE-2.0.html)
+[![GitHub Release](https://img.shields.io/github/v/release/apache/eventmesh?style=for-the-badge)](https://github.com/apache/incubator-eventmesh/releases)
+[![Slack Status](https://img.shields.io/badge/slack-join_chat-blue.svg?logo=slack&style=for-the-badge)](https://join.slack.com/t/apacheeventmesh/shared_invite/zt-16y1n77va-q~JepYy3RqpkygDYmQaQbw)
 
-EventMesh是一个动态的云原生事件驱动架构基础设施，用于分离应用程序和后端中间件层，它支持广泛的用例，包括复杂的混合云、使用了不同技术栈的分布式架构。
+[📦 文档 (英文)](https://eventmesh.apache.org/docs/introduction) |
+[📔 例子](https://github.com/apache/incubator-eventmesh/tree/master/eventmesh-examples) |
+[⚙️ 路线图](https://eventmesh.apache.org/docs/roadmap) |
+[🌐 简体中文](README.zh-CN.md)
+</div>
 
-**多运行时:**
-![architecture1](docs/images/eventmesh-arch3.png)
+# Apache EventMesh (孵化期)","[{'comment': ""```suggestion\r\n# Apache EventMesh (Incubating)\r\n```\r\n\r\nI think there's no need to change this line."", 'commenter': 'xiaoyang-sde'}]"
921,eventmesh-webhook/eventmesh-webhook-admin/src/main/java/org/apache/eventmesh/webhook/admin/FileWebHookConfigOperation.java,"@@ -49,77 +49,54 @@ public FileWebHookConfigOperation(String filePath) throws FileNotFoundException
 
 	@Override
 	public Integer insertWebHookConfig(WebHookConfig webHookConfig) {
-		String manufacturerName = webHookConfig.getManufacturerName();
-		String manuDirPath = filePath + FILE_SEPARATOR + manufacturerName;
-		File manuDir = new File(manuDirPath);
+		File manuDir = new File(getWebhookConfigManuDir(webHookConfig));
 		if (!manuDir.exists()) {
 			manuDir.mkdir();
 		}
-		File webhookConfigFile = new File(manuDirPath + FILE_SEPARATOR + webHookConfig.getManufacturerEventName() + FILE_EXTENSION);
+		File webhookConfigFile = new File(getWebhookConfigFilePath(webHookConfig));
 		if (webhookConfigFile.exists()) {
-			logger.error(""webhookConfig "" + manufacturerName + ""_"" + webHookConfig.getManufacturerEventName() + "" is existed"");
-			return 0;
-		}
-		try (FileWriter fw = new FileWriter(webhookConfigFile); BufferedWriter bw = new BufferedWriter(fw)) {
-			bw.write(JsonUtils.serialize(webHookConfig));
-		} catch (IOException e) {
-			e.printStackTrace();
+			logger.error(""webhookConfig "" + webHookConfig.getCallbackPath() + "" is existed"");","[{'comment': '```suggestion\r\n\t\t\tlogger.error(""webhookConfig {} is already existed"", webHookConfig.getCallbackPath());\r\n```', 'commenter': 'ruanwenjun'}]"
921,eventmesh-webhook/eventmesh-webhook-admin/src/main/java/org/apache/eventmesh/webhook/admin/FileWebHookConfigOperation.java,"@@ -17,24 +17,24 @@
 package org.apache.eventmesh.webhook.admin;
 
 import java.io.*;
+import java.nio.channels.FileLock;
 import java.util.ArrayList;
 import java.util.List;
 
+import com.alibaba.nacos.common.utils.MD5Utils;
 import org.apache.eventmesh.common.utils.JsonUtils;
 import org.apache.eventmesh.webhook.api.WebHookConfig;
 import org.apache.eventmesh.webhook.api.WebHookConfigOperation;
+import org.apache.eventmesh.webhook.api.WebHookOperationConstant;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 public class FileWebHookConfigOperation implements WebHookConfigOperation {
 
 	private static final Logger logger = LoggerFactory.getLogger(FileWebHookConfigOperation.class);
 
-	private String filePath;
+	private final String filePath;","[{'comment': '```suggestion\r\n\tprivate final String webHookFileDir;\r\n```', 'commenter': 'ruanwenjun'}]"
921,eventmesh-webhook/eventmesh-webhook-admin/src/main/java/org/apache/eventmesh/webhook/admin/FileWebHookConfigOperation.java,"@@ -49,77 +49,54 @@ public FileWebHookConfigOperation(String filePath) throws FileNotFoundException
 
 	@Override
 	public Integer insertWebHookConfig(WebHookConfig webHookConfig) {
-		String manufacturerName = webHookConfig.getManufacturerName();
-		String manuDirPath = filePath + FILE_SEPARATOR + manufacturerName;
-		File manuDir = new File(manuDirPath);
+		File manuDir = new File(getWebhookConfigManuDir(webHookConfig));
 		if (!manuDir.exists()) {
 			manuDir.mkdir();
 		}
-		File webhookConfigFile = new File(manuDirPath + FILE_SEPARATOR + webHookConfig.getManufacturerEventName() + FILE_EXTENSION);
+		File webhookConfigFile = new File(getWebhookConfigFilePath(webHookConfig));
 		if (webhookConfigFile.exists()) {
-			logger.error(""webhookConfig "" + manufacturerName + ""_"" + webHookConfig.getManufacturerEventName() + "" is existed"");
-			return 0;
-		}
-		try (FileWriter fw = new FileWriter(webhookConfigFile); BufferedWriter bw = new BufferedWriter(fw)) {
-			bw.write(JsonUtils.serialize(webHookConfig));
-		} catch (IOException e) {
-			e.printStackTrace();
+			logger.error(""webhookConfig "" + webHookConfig.getCallbackPath() + "" is existed"");
 			return 0;
 		}
-		return 1;
+		return writeToFile(webhookConfigFile, webHookConfig) ? 1 : 0;
 	}
 
 	@Override
 	public Integer updateWebHookConfig(WebHookConfig webHookConfig) {","[{'comment': 'Please change this method to return a boolean value.', 'commenter': 'ruanwenjun'}]"
921,eventmesh-webhook/eventmesh-webhook-admin/src/main/java/org/apache/eventmesh/webhook/admin/FileWebHookConfigOperation.java,"@@ -49,77 +49,54 @@ public FileWebHookConfigOperation(String filePath) throws FileNotFoundException
 
 	@Override
 	public Integer insertWebHookConfig(WebHookConfig webHookConfig) {
-		String manufacturerName = webHookConfig.getManufacturerName();
-		String manuDirPath = filePath + FILE_SEPARATOR + manufacturerName;
-		File manuDir = new File(manuDirPath);
+		File manuDir = new File(getWebhookConfigManuDir(webHookConfig));
 		if (!manuDir.exists()) {
 			manuDir.mkdir();
 		}
-		File webhookConfigFile = new File(manuDirPath + FILE_SEPARATOR + webHookConfig.getManufacturerEventName() + FILE_EXTENSION);
+		File webhookConfigFile = new File(getWebhookConfigFilePath(webHookConfig));
 		if (webhookConfigFile.exists()) {
-			logger.error(""webhookConfig "" + manufacturerName + ""_"" + webHookConfig.getManufacturerEventName() + "" is existed"");
-			return 0;
-		}
-		try (FileWriter fw = new FileWriter(webhookConfigFile); BufferedWriter bw = new BufferedWriter(fw)) {
-			bw.write(JsonUtils.serialize(webHookConfig));
-		} catch (IOException e) {
-			e.printStackTrace();
+			logger.error(""webhookConfig "" + webHookConfig.getCallbackPath() + "" is existed"");
 			return 0;
 		}
-		return 1;
+		return writeToFile(webhookConfigFile, webHookConfig) ? 1 : 0;
 	}
 
 	@Override
 	public Integer updateWebHookConfig(WebHookConfig webHookConfig) {
-		String manufacturerName = webHookConfig.getManufacturerName();
-		String manuDirPath = filePath + FILE_SEPARATOR + manufacturerName;
-		File webhookConfigFile = new File(manuDirPath + FILE_SEPARATOR + webHookConfig.getManufacturerEventName() + FILE_EXTENSION);
+		File webhookConfigFile = new File(getWebhookConfigFilePath(webHookConfig));
 		if (!webhookConfigFile.exists()) {
-			logger.error(""webhookConfig "" + manufacturerName + ""_"" + webHookConfig.getManufacturerEventName() + "" is not existed"");
+			logger.error(""webhookConfig "" + webHookConfig.getCallbackPath() + "" is not existed"");","[{'comment': '```suggestion\r\n\t\t\tlogger.error(""webhookConfig {} is not existed"", webHookConfig.getCallbackPath());\r\n```', 'commenter': 'ruanwenjun'}]"
921,eventmesh-webhook/eventmesh-webhook-admin/src/main/java/org/apache/eventmesh/webhook/admin/FileWebHookConfigOperation.java,"@@ -49,77 +49,54 @@ public FileWebHookConfigOperation(String filePath) throws FileNotFoundException
 
 	@Override
 	public Integer insertWebHookConfig(WebHookConfig webHookConfig) {
-		String manufacturerName = webHookConfig.getManufacturerName();
-		String manuDirPath = filePath + FILE_SEPARATOR + manufacturerName;
-		File manuDir = new File(manuDirPath);
+		File manuDir = new File(getWebhookConfigManuDir(webHookConfig));
 		if (!manuDir.exists()) {
 			manuDir.mkdir();
 		}
-		File webhookConfigFile = new File(manuDirPath + FILE_SEPARATOR + webHookConfig.getManufacturerEventName() + FILE_EXTENSION);
+		File webhookConfigFile = new File(getWebhookConfigFilePath(webHookConfig));
 		if (webhookConfigFile.exists()) {
-			logger.error(""webhookConfig "" + manufacturerName + ""_"" + webHookConfig.getManufacturerEventName() + "" is existed"");
-			return 0;
-		}
-		try (FileWriter fw = new FileWriter(webhookConfigFile); BufferedWriter bw = new BufferedWriter(fw)) {
-			bw.write(JsonUtils.serialize(webHookConfig));
-		} catch (IOException e) {
-			e.printStackTrace();
+			logger.error(""webhookConfig "" + webHookConfig.getCallbackPath() + "" is existed"");
 			return 0;
 		}
-		return 1;
+		return writeToFile(webhookConfigFile, webHookConfig) ? 1 : 0;
 	}
 
 	@Override
 	public Integer updateWebHookConfig(WebHookConfig webHookConfig) {
-		String manufacturerName = webHookConfig.getManufacturerName();
-		String manuDirPath = filePath + FILE_SEPARATOR + manufacturerName;
-		File webhookConfigFile = new File(manuDirPath + FILE_SEPARATOR + webHookConfig.getManufacturerEventName() + FILE_EXTENSION);
+		File webhookConfigFile = new File(getWebhookConfigFilePath(webHookConfig));
 		if (!webhookConfigFile.exists()) {
-			logger.error(""webhookConfig "" + manufacturerName + ""_"" + webHookConfig.getManufacturerEventName() + "" is not existed"");
+			logger.error(""webhookConfig "" + webHookConfig.getCallbackPath() + "" is not existed"");
 			return 0;
 		}
-		try (FileWriter fw = new FileWriter(webhookConfigFile); BufferedWriter bw = new BufferedWriter(fw)) {
-			bw.write(JsonUtils.serialize(webHookConfig));
-		} catch (IOException e) {
-			e.printStackTrace();
-			return 0;
-		}
-		return 1;
+		return writeToFile(webhookConfigFile, webHookConfig) ? 1 : 0;
 	}
 
 	@Override
 	public Integer deleteWebHookConfig(WebHookConfig webHookConfig) {
-		String manufacturerName = webHookConfig.getManufacturerName();
-		String manuDirPath = filePath + FILE_SEPARATOR + manufacturerName;
-		File webhookConfigFile = new File(manuDirPath + FILE_SEPARATOR + webHookConfig.getManufacturerEventName() + FILE_EXTENSION);
+		File webhookConfigFile = new File(getWebhookConfigFilePath(webHookConfig));
 		if (!webhookConfigFile.exists()) {
-			logger.error(""webhookConfig "" + manufacturerName + ""_"" + webHookConfig.getManufacturerEventName() + "" is not existed"");
+			logger.error(""webhookConfig "" + webHookConfig.getCallbackPath() + "" is not existed"");
 			return 0;
 		}
 		return webhookConfigFile.delete() ? 1 : 0;
 	}
 
 	@Override
 	public WebHookConfig queryWebHookConfigById(WebHookConfig webHookConfig) {
-		String manufacturerName = webHookConfig.getManufacturerName();
-		String manuDirPath = filePath + FILE_SEPARATOR + manufacturerName;
-		File webhookConfigFile = new File(manuDirPath + FILE_SEPARATOR + webHookConfig.getManufacturerEventName() + FILE_EXTENSION);
+		File webhookConfigFile = new File(getWebhookConfigFilePath(webHookConfig));
 		if (!webhookConfigFile.exists()) {
-			logger.error(""webhookConfig "" + manufacturerName + ""_"" + webHookConfig.getManufacturerEventName() + "" is not existed"");
+			logger.error(""webhookConfig "" + webHookConfig.getCallbackPath() + "" is not existed"");
 			return null;
 		}
-
 		return getWebHookConfigFromFile(webhookConfigFile);
 	}
 
 	@Override
 	public List<WebHookConfig> queryWebHookConfigByManufacturer(WebHookConfig webHookConfig, Integer pageNum,
 			Integer pageSize) {
-		String manufacturerName = webHookConfig.getManufacturerName();
-		String manuDirPath = filePath + FILE_SEPARATOR + manufacturerName;
-		File manuDir = new File(manuDirPath);
+		File manuDir = new File(getWebhookConfigManuDir(webHookConfig));","[{'comment': ""You don't need to call `getWebhookConfigManuDir` again\r\n```suggestion\r\n        String webHookFilePath = getWebhookConfigManuDir(webHookConfig);\r\n\t\tFile manuDir = new File(webHookFilePath);\r\n```"", 'commenter': 'ruanwenjun'}]"
921,eventmesh-webhook/eventmesh-webhook-admin/src/main/java/org/apache/eventmesh/webhook/admin/FileWebHookConfigOperation.java,"@@ -140,12 +117,50 @@ private WebHookConfig getWebHookConfigFromFile(File webhookConfigFile) {
 			while ((line = br.readLine()) != null) {
 				fileContent += line;
 			}
-		} catch (FileNotFoundException e) {
-			e.printStackTrace();
 		} catch (IOException e) {
-			e.printStackTrace();
+			logger.error(""get webhook from file {} error"", webhookConfigFile.getPath(), e);
 		}
 		return JsonUtils.deserialize(fileContent, WebHookConfig.class);
 	}
 
+	private synchronized boolean writeToFile(File webhookConfigFile, WebHookConfig webHookConfig) {","[{'comment': 'There is no need to add synchronized here? Will this method modify any variable?', 'commenter': 'ruanwenjun'}]"
921,eventmesh-webhook/eventmesh-webhook-admin/src/main/java/org/apache/eventmesh/webhook/admin/FileWebHookConfigOperation.java,"@@ -140,12 +117,50 @@ private WebHookConfig getWebHookConfigFromFile(File webhookConfigFile) {
 			while ((line = br.readLine()) != null) {
 				fileContent += line;
 			}
-		} catch (FileNotFoundException e) {
-			e.printStackTrace();
 		} catch (IOException e) {
-			e.printStackTrace();
+			logger.error(""get webhook from file {} error"", webhookConfigFile.getPath(), e);
 		}
 		return JsonUtils.deserialize(fileContent, WebHookConfig.class);
 	}
 
+	private synchronized boolean writeToFile(File webhookConfigFile, WebHookConfig webHookConfig) {
+		FileOutputStream fos = null;
+		BufferedWriter bw = null;
+		FileLock lock = null;","[{'comment': 'Please use try with resource, this can help you to close the resource in a safe way, of you need to add multiple try catch in your finally block.\r\n```java\r\ntry{\r\n    if (fos != null) {\r\n\t\tfos.close();\r\n\t}\r\n}catch (IOException e){\r\n}\r\ntry{\r\n    if (bw != null) {\r\n\t\tbw.close();\r\n\t}\r\n}catch (IOException e){\r\n}\r\ntry{\r\n   if (lock != null) {\r\n\t\tlock.close();\r\n\t}\r\n}catch (IOException e){\r\n}\r\n', 'commenter': 'ruanwenjun'}]"
921,eventmesh-webhook/eventmesh-webhook-admin/src/main/java/org/apache/eventmesh/webhook/admin/FileWebHookConfigOperation.java,"@@ -140,12 +117,50 @@ private WebHookConfig getWebHookConfigFromFile(File webhookConfigFile) {
 			while ((line = br.readLine()) != null) {
 				fileContent += line;
 			}
-		} catch (FileNotFoundException e) {
-			e.printStackTrace();
 		} catch (IOException e) {
-			e.printStackTrace();
+			logger.error(""get webhook from file {} error"", webhookConfigFile.getPath(), e);
 		}
 		return JsonUtils.deserialize(fileContent, WebHookConfig.class);
 	}
 
+	private synchronized boolean writeToFile(File webhookConfigFile, WebHookConfig webHookConfig) {
+		FileOutputStream fos = null;
+		BufferedWriter bw = null;
+		FileLock lock = null;
+		try {
+			fos = new FileOutputStream(webhookConfigFile);
+			bw = new BufferedWriter(new OutputStreamWriter(fos));
+			// lock this file
+			lock = fos.getChannel().lock();
+			bw.write(JsonUtils.serialize(webHookConfig));
+		} catch (IOException e) {
+			logger.error(""write webhookConfig {} to file error"", webHookConfig.getCallbackPath());
+			return false;
+		} finally {
+			try {
+				if (fos != null) {
+					fos.close();
+				}
+				if (bw != null) {
+					bw.close();
+				}
+				if (lock != null) {
+					lock.release();
+				}
+			} catch (IOException e) {
+				logger.warn(""writeToFile finally caught an exception"", e);
+			}
+		}
+		return true;
+	}
+
+	private String getWebhookConfigManuDir(WebHookConfig webHookConfig) {
+		return filePath + WebHookOperationConstant.FILE_SEPARATOR + webHookConfig.getCloudEventName();
+	}
+
+	private String getWebhookConfigFilePath(WebHookConfig webHookConfig) {
+		return this.getWebhookConfigManuDir(webHookConfig) + WebHookOperationConstant.FILE_SEPARATOR + MD5Utils.md5Hex(webHookConfig.getCallbackPath(), ""UTF_8"") + WebHookOperationConstant.FILE_EXTENSION;","[{'comment': 'Why we need to use `MD5Utils.md5Hex(webHookConfig.getCallbackPath(), ""UTF_8"")` to deal with the path here?', 'commenter': 'ruanwenjun'}, {'comment': ""because the path may contain some speacial char like '/', which is illegal as a file name. I've changed to use URLEncoder.encode method."", 'commenter': 'JellyBo'}, {'comment': ""OK, if so, it's better to add comment in the method."", 'commenter': 'ruanwenjun'}]"
921,eventmesh-webhook/eventmesh-webhook-admin/src/main/java/org/apache/eventmesh/webhook/admin/NacosWebHookConfigOperation.java,"@@ -68,49 +58,41 @@ public Integer insertWebHookConfig(WebHookConfig webHookConfig) {
 		String manufacturerName = webHookConfig.getManufacturerName();
 		try {
 			// 判断配置是否已存在
-			if (configService.getConfig(webHookConfig.getManufacturerEventName() + DATA_ID_EXTENSION, GROUP_PREFIX + manufacturerName, TIMEOUT_MS) != null) {
-				logger.error(""insertWebHookConfig failed, config is existed"");
+			if (configService.getConfig(getWebHookConfigDataId(webHookConfig), getManuGroupId(webHookConfig), TIMEOUT_MS) != null) {","[{'comment': 'Please remove the chinese comment.', 'commenter': 'ruanwenjun'}]"
921,eventmesh-webhook/eventmesh-webhook-api/src/main/java/org/apache/eventmesh/webhook/api/WebHookOperationConstant.java,"@@ -0,0 +1,22 @@
+package org.apache.eventmesh.webhook.api;
+
+import java.io.File;
+
+/**
+ * Webhook常量类
+ */
+public class WebHookOperationConstant {
+
+    public static final String FILE_SEPARATOR = File.separator;
+
+    public static final String FILE_EXTENSION = "".json"";
+
+    public static final String GROUP_PREFIX = ""webhook_"" ;
+
+    public static final String DATA_ID_EXTENSION = "".json"";
+
+    public static final String MANUFACTURERS_DATA_ID = ""manufacturers"" + DATA_ID_EXTENSION;
+
+    public static final Integer TIMEOUT_MS = 3*1000;","[{'comment': 'Use int here will cause extra implicit conversion.\r\n```suggestion\r\n    public static final long TIMEOUT_MS = 3 * 1000L;\r\n```', 'commenter': 'ruanwenjun'}]"
921,eventmesh-webhook/eventmesh-webhook-receive/src/main/java/org/apache/eventmesh/webhook/receive/storage/HookConfigOperationManage.java,"@@ -97,10 +94,10 @@ public WebHookConfig queryWebHookConfigById(WebHookConfig webHookConfig) {
         if(filePattern) return cacheWebHookConfig.get(webHookConfig.getCallbackPath());
         else{
             try {
-                String content = configService.getConfig(webHookConfig.getManufacturerEventName() + DATA_ID_EXTENSION, GROUP_PREFIX + webHookConfig.getManufacturerName(), TIMEOUT_MS);
+                String content = configService.getConfig(MD5Utils.md5Hex(webHookConfig.getCallbackPath(), ""UTF_8"") + WebHookOperationConstant.DATA_ID_EXTENSION, WebHookOperationConstant.GROUP_PREFIX + webHookConfig.getManufacturerName(), WebHookOperationConstant.TIMEOUT_MS);","[{'comment': 'Can we add a utils method to do this convert? If we change the path parten, we need to modified evenywhere.', 'commenter': 'ruanwenjun'}]"
937,eventmesh-runtime/conf/eventmesh.properties,"@@ -89,4 +89,17 @@ eventMesh.metrics.plugin=prometheus
 
 # trace plugin
 eventMesh.server.trace.enabled=false
-eventMesh.trace.plugin=zipkin
\ No newline at end of file
+eventMesh.trace.plugin=zipkin
+
+# webhook
+# 是否启动webhook admin服务","[{'comment': 'please change the Chinese comments to English in the project.', 'commenter': 'xwm1992'}]"
937,docs/cn/features/webhook.md,"@@ -0,0 +1,158 @@
+
+
+## webhook使用流程
+#### 第一步：在eventmesh配置webhook相关信息并且启动
+
+##### 配置说明
+```
+# 是否启动webhook admin服务
+eventMesh.webHook.admin.start=true
+
+# webhook事件配置存储模式。目前只支持file与nacos
+eventMesh.webHook.operationMode=file
+# 文件存储模式的文件存放路径，如果写上#{eventMeshHome}，在eventMesh根目录
+eventMesh.webHook.fileMode.filePath= #{eventMeshHome}/webhook
+
+# nacos存储模式，配置命名规则是eventMesh.webHook.nacosMode.{nacos 原生配置key} 具体的配置请看 [nacos github api](https://github.com/alibaba/nacos/blob/develop/api/src/main/java/com/alibaba/nacos/api/SystemPropertyKeyConst.java)
+## nacos的地址
+eventMesh.webHook.nacosMode.serverAddr=127.0.0.1:8848
+
+# webhook eventcloud 发送模式。与eventMesh.connector.plugin.type 配置一样
+eventMesh.webHook.producer.connector=standalone
+```
+
+#### 第二步：添加webhook配置信息
+配置信息说明
+```java
+	/**
+	 * 厂商调用的path。厂商事件调用地址、 [http or https ]://[域名 or IP 【厂商可以被调用】]:[端口]/webhook/[callbackPath]
+	 * 比如：http://127.0.0.1:10504/webhook/test/event 需要把全完url填入厂商调用输入中
+	 * callbackPath 是唯一
+	 * manufacturer callback path
+	 */
+    private String callbackPath;
+
+    /**
+     * 厂商的名字
+     * manufacturer name ,like github
+     */
+    private String manufacturerName;
+
+    /**
+     * 厂商的事件名
+     * webhook event name ,like rep-push
+     */
+    private String manufacturerEventName;
+
+    /**
+     * 
+     * http header content type
+     */
+    private String contentType = ""application/json"";
+
+    /**
+     * 说明
+     * description of this WebHookConfig
+     */
+    private String description;
+
+    /**
+     * 有一些厂商使用验签方式，
+     * secret key ,for authentication
+     */
+    private String secret;
+
+    /**
+     *  有一些厂商使用验签方式，使用账户密码方式
+     * userName ,for HTTP authentication
+     */
+    private String userName;
+
+    /**
+     *  有一些厂商使用验签方式，使用账户密码方式
+     * password ,for HTTP authentication
+     */
+    private String password;
+
+
+
+    /**
+     * 事件发送到那个topic
+     * roll out event name ,like topic to mq
+     */
+    private String cloudEventName;
+
+    /**
+     * roll out data format -> CloudEvent serialization mode
+     * If HTTP protocol is used, the request header contentType needs to be marked
+     */
+    private String dataContentType = ""application/json"";;
+
+    /**
+     * source of event
+     */
+    private String cloudEventSource;
+
+    /**
+     * cloudEvent事件对象唯一标识符识别方式，uuid或者manufacturerEventId(厂商id)
+     * id of cloudEvent ,like uuid/manufacturerEventId
+     */
+    private String cloudEventIdGenerateMode;
+
+```
+
+##### 添加接口
+路径： /webhook/insertWebHookConfig
+方法： POST
+contentType： application/json
+
+输入参数：
+| 字段 | 说明 | 类型 |　必须 | 默认值　|
+| -- | -- | -- | -- | -- |
+| callbackPath | 调用地址，唯一地址 | string | 是　| null　|
+| manufacturerName | 厂商名 | string | 是　| null　|
+| manufacturerEventName | 厂商事件名 | string | 是　| null　|
+| contentType | http connettype | string | 否　| application/json　|
+| description | 配置说明 | string | 否　| null　|
+| secret | 验签密钥 | string | 否　| null　|
+| userName | 用户名 | string | 否　| null　|
+| password | 用户密码 | string | 否　| null　|
+| cloudEventName | 事件名（） | string | 是　| null　|
+| cloudEventSource | 事件来源可以填写 | string | 是　| null　|
+| cloudEventIdGenerateMode | cloudEvent事件对象唯一标识符识别方式，uuid或者manufacturerEventId(厂商id)  | string | 否　| manufacturerEventId　|
+
+输出参数：１　成功，０失败
+
+
+
+
+#### 第三步：查看配置是否成功
+1. file存储模式。请到eventMesh.webHook.fileMode.filePath 目录下查看。文件名为callbackPath转移后的
+2. nacos存储模式。请到eventMesh.webHook.nacosMode.serverAddr 配置的nacos服务去看
+
+#### 第四步：配置cloudevent的消费者
+
+
+#### 第五步：在厂商配置webhook相关信息
+> 厂商操作请看【厂商webhook操作说明】
+
+
+## 厂商webhook操作说明
+### github 注册
+#### 第一步：进入对应的项目
+#### 第二步：点击setting
+![](../images/webhook/webhook-github-setting.png)","[{'comment': 'these images not display may be url is not correct', 'commenter': 'xwm1992'}]"
937,eventmesh-runtime/src/main/java/org/apache/eventmesh/runtime/core/protocol/http/processor/HandlerService.java,"@@ -0,0 +1,233 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.eventmesh.runtime.core.protocol.http.processor;
+
+import org.apache.eventmesh.runtime.boot.HTTPTrace;
+import org.apache.eventmesh.runtime.boot.HTTPTrace.TraceOperation;
+import org.apache.eventmesh.runtime.metrics.http.HTTPMetricsServer;
+import org.apache.eventmesh.runtime.util.HttpResponseUtils;
+import org.apache.eventmesh.runtime.util.RemotingHelper;
+
+import java.util.Map;
+import java.util.Map.Entry;
+import java.util.Objects;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ThreadPoolExecutor;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import io.netty.channel.ChannelFutureListener;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.handler.codec.http.HttpRequest;
+import io.netty.handler.codec.http.HttpResponse;
+
+import lombok.Setter;
+
+
+public class HandlerService {
+
+    private Logger httpServerLogger = LoggerFactory.getLogger(this.getClass());
+
+    private Logger httpLogger = LoggerFactory.getLogger(""http"");
+
+    private Map<String, ProcessorWrapper> httpProcessorMap = new ConcurrentHashMap<>();
+
+    @Setter
+    private HTTPMetricsServer metrics;
+
+    @Setter
+    private HTTPTrace httpTrace;
+
+
+    public void init() {
+        httpServerLogger.info(""HandlerService start "");
+    }
+
+    public void register(HttpProcessor httpProcessor, ThreadPoolExecutor threadPoolExecutor) {
+        for (String path : httpProcessor.paths()) {
+            this.register(path, httpProcessor, threadPoolExecutor);
+        }
+    }
+
+    public void register(String path, HttpProcessor httpProcessor, ThreadPoolExecutor threadPoolExecutor) {
+
+        if (httpProcessorMap.containsKey(path)) {
+            throw new RuntimeException(String.format(""HandlerService path %s repeat, repeat processor is %s "",
+                    path, httpProcessor.getClass().getSimpleName()));
+        }
+        ProcessorWrapper processorWrapper = new ProcessorWrapper();
+        processorWrapper.threadPoolExecutor = threadPoolExecutor;
+        processorWrapper.httpProcessor = httpProcessor;
+        if (httpProcessor instanceof AsynHttpProcessor) {
+            processorWrapper.asyn = (AsynHttpProcessor) httpProcessor;
+        } else {
+            processorWrapper.httpProcessor = httpProcessor;
+        }
+        httpProcessorMap.put(path, processorWrapper);
+        httpServerLogger.info(""path is {}  proocessor name is"", path, httpProcessor.getClass().getSimpleName());","[{'comment': 'change -> httpServerLogger.info(""path is {} processor name is {}"", path, httpProcessor.getClass().getSimpleName());\r\n', 'commenter': 'xwm1992'}]"
937,eventmesh-runtime/src/main/java/org/apache/eventmesh/runtime/core/protocol/http/processor/HandlerService.java,"@@ -0,0 +1,233 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.eventmesh.runtime.core.protocol.http.processor;
+
+import org.apache.eventmesh.runtime.boot.HTTPTrace;
+import org.apache.eventmesh.runtime.boot.HTTPTrace.TraceOperation;
+import org.apache.eventmesh.runtime.metrics.http.HTTPMetricsServer;
+import org.apache.eventmesh.runtime.util.HttpResponseUtils;
+import org.apache.eventmesh.runtime.util.RemotingHelper;
+
+import java.util.Map;
+import java.util.Map.Entry;
+import java.util.Objects;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ThreadPoolExecutor;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import io.netty.channel.ChannelFutureListener;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.handler.codec.http.HttpRequest;
+import io.netty.handler.codec.http.HttpResponse;
+
+import lombok.Setter;
+
+
+public class HandlerService {
+
+    private Logger httpServerLogger = LoggerFactory.getLogger(this.getClass());
+
+    private Logger httpLogger = LoggerFactory.getLogger(""http"");
+
+    private Map<String, ProcessorWrapper> httpProcessorMap = new ConcurrentHashMap<>();
+
+    @Setter
+    private HTTPMetricsServer metrics;
+
+    @Setter
+    private HTTPTrace httpTrace;
+
+
+    public void init() {
+        httpServerLogger.info(""HandlerService start "");
+    }
+
+    public void register(HttpProcessor httpProcessor, ThreadPoolExecutor threadPoolExecutor) {
+        for (String path : httpProcessor.paths()) {
+            this.register(path, httpProcessor, threadPoolExecutor);
+        }
+    }
+
+    public void register(String path, HttpProcessor httpProcessor, ThreadPoolExecutor threadPoolExecutor) {
+
+        if (httpProcessorMap.containsKey(path)) {
+            throw new RuntimeException(String.format(""HandlerService path %s repeat, repeat processor is %s "",
+                    path, httpProcessor.getClass().getSimpleName()));
+        }
+        ProcessorWrapper processorWrapper = new ProcessorWrapper();
+        processorWrapper.threadPoolExecutor = threadPoolExecutor;
+        processorWrapper.httpProcessor = httpProcessor;
+        if (httpProcessor instanceof AsynHttpProcessor) {
+            processorWrapper.asyn = (AsynHttpProcessor) httpProcessor;
+        } else {
+            processorWrapper.httpProcessor = httpProcessor;
+        }
+        httpProcessorMap.put(path, processorWrapper);
+        httpServerLogger.info(""path is {}  proocessor name is"", path, httpProcessor.getClass().getSimpleName());
+    }
+
+    public boolean isProcessorWrapper(HttpRequest httpRequest) {
+        return this.getProcessorWrapper(httpRequest) == null ? false : true;","[{'comment': 'change -> return this.getProcessorWrapper(httpRequest) != null;', 'commenter': 'xwm1992'}]"
937,eventmesh-runtime/src/main/java/org/apache/eventmesh/runtime/core/protocol/http/processor/HandlerService.java,"@@ -0,0 +1,233 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.eventmesh.runtime.core.protocol.http.processor;
+
+import org.apache.eventmesh.runtime.boot.HTTPTrace;
+import org.apache.eventmesh.runtime.boot.HTTPTrace.TraceOperation;
+import org.apache.eventmesh.runtime.metrics.http.HTTPMetricsServer;
+import org.apache.eventmesh.runtime.util.HttpResponseUtils;
+import org.apache.eventmesh.runtime.util.RemotingHelper;
+
+import java.util.Map;
+import java.util.Map.Entry;
+import java.util.Objects;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ThreadPoolExecutor;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import io.netty.channel.ChannelFutureListener;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.handler.codec.http.HttpRequest;
+import io.netty.handler.codec.http.HttpResponse;
+
+import lombok.Setter;
+
+
+public class HandlerService {
+
+    private Logger httpServerLogger = LoggerFactory.getLogger(this.getClass());
+
+    private Logger httpLogger = LoggerFactory.getLogger(""http"");
+
+    private Map<String, ProcessorWrapper> httpProcessorMap = new ConcurrentHashMap<>();
+
+    @Setter
+    private HTTPMetricsServer metrics;
+
+    @Setter
+    private HTTPTrace httpTrace;
+
+
+    public void init() {
+        httpServerLogger.info(""HandlerService start "");
+    }
+
+    public void register(HttpProcessor httpProcessor, ThreadPoolExecutor threadPoolExecutor) {
+        for (String path : httpProcessor.paths()) {
+            this.register(path, httpProcessor, threadPoolExecutor);
+        }
+    }
+
+    public void register(String path, HttpProcessor httpProcessor, ThreadPoolExecutor threadPoolExecutor) {
+
+        if (httpProcessorMap.containsKey(path)) {
+            throw new RuntimeException(String.format(""HandlerService path %s repeat, repeat processor is %s "",
+                    path, httpProcessor.getClass().getSimpleName()));
+        }
+        ProcessorWrapper processorWrapper = new ProcessorWrapper();
+        processorWrapper.threadPoolExecutor = threadPoolExecutor;
+        processorWrapper.httpProcessor = httpProcessor;
+        if (httpProcessor instanceof AsynHttpProcessor) {
+            processorWrapper.asyn = (AsynHttpProcessor) httpProcessor;
+        } else {
+            processorWrapper.httpProcessor = httpProcessor;
+        }
+        httpProcessorMap.put(path, processorWrapper);
+        httpServerLogger.info(""path is {}  proocessor name is"", path, httpProcessor.getClass().getSimpleName());
+    }
+
+    public boolean isProcessorWrapper(HttpRequest httpRequest) {
+        return this.getProcessorWrapper(httpRequest) == null ? false : true;
+    }
+
+    private ProcessorWrapper getProcessorWrapper(HttpRequest httpRequest) {
+        String uri = httpRequest.uri();
+        for (Entry<String, ProcessorWrapper> e : httpProcessorMap.entrySet()) {
+            if (e.getKey().startsWith(uri)) {
+                return e.getValue();
+            }
+        }
+        return null;
+    }
+
+    /**
+     * @param httpRequest
+     */
+    public void handler(ChannelHandlerContext ctx, HttpRequest httpRequest) {
+
+
+        TraceOperation traceOperation = httpTrace.getTraceOperation(httpRequest, ctx.channel());
+
+        ProcessorWrapper processorWrapper = getProcessorWrapper(httpRequest);
+        if (Objects.isNull(processorWrapper)) {
+            this.sendResponse(ctx, HttpResponseUtils.createNotFound());
+        }
+        try {
+            HandlerSpecific handlerSpecific = new HandlerSpecific();
+            handlerSpecific.httpRequest = httpRequest;
+            handlerSpecific.ctx = ctx;
+            handlerSpecific.traceOperation = traceOperation;
+            processorWrapper.threadPoolExecutor.execute(handlerSpecific);","[{'comment': '`processorWrapper` may produce NullPointerException', 'commenter': 'xwm1992'}]"
937,eventmesh-runtime/src/main/java/org/apache/eventmesh/runtime/core/protocol/http/processor/HandlerService.java,"@@ -0,0 +1,233 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.eventmesh.runtime.core.protocol.http.processor;
+
+import org.apache.eventmesh.runtime.boot.HTTPTrace;
+import org.apache.eventmesh.runtime.boot.HTTPTrace.TraceOperation;
+import org.apache.eventmesh.runtime.metrics.http.HTTPMetricsServer;
+import org.apache.eventmesh.runtime.util.HttpResponseUtils;
+import org.apache.eventmesh.runtime.util.RemotingHelper;
+
+import java.util.Map;
+import java.util.Map.Entry;
+import java.util.Objects;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ThreadPoolExecutor;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import io.netty.channel.ChannelFutureListener;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.handler.codec.http.HttpRequest;
+import io.netty.handler.codec.http.HttpResponse;
+
+import lombok.Setter;
+
+
+public class HandlerService {
+
+    private Logger httpServerLogger = LoggerFactory.getLogger(this.getClass());
+
+    private Logger httpLogger = LoggerFactory.getLogger(""http"");
+
+    private Map<String, ProcessorWrapper> httpProcessorMap = new ConcurrentHashMap<>();
+
+    @Setter
+    private HTTPMetricsServer metrics;
+
+    @Setter
+    private HTTPTrace httpTrace;
+
+
+    public void init() {
+        httpServerLogger.info(""HandlerService start "");
+    }
+
+    public void register(HttpProcessor httpProcessor, ThreadPoolExecutor threadPoolExecutor) {
+        for (String path : httpProcessor.paths()) {
+            this.register(path, httpProcessor, threadPoolExecutor);
+        }
+    }
+
+    public void register(String path, HttpProcessor httpProcessor, ThreadPoolExecutor threadPoolExecutor) {
+
+        if (httpProcessorMap.containsKey(path)) {
+            throw new RuntimeException(String.format(""HandlerService path %s repeat, repeat processor is %s "",
+                    path, httpProcessor.getClass().getSimpleName()));
+        }
+        ProcessorWrapper processorWrapper = new ProcessorWrapper();
+        processorWrapper.threadPoolExecutor = threadPoolExecutor;
+        processorWrapper.httpProcessor = httpProcessor;
+        if (httpProcessor instanceof AsynHttpProcessor) {
+            processorWrapper.asyn = (AsynHttpProcessor) httpProcessor;
+        } else {
+            processorWrapper.httpProcessor = httpProcessor;
+        }
+        httpProcessorMap.put(path, processorWrapper);
+        httpServerLogger.info(""path is {}  proocessor name is"", path, httpProcessor.getClass().getSimpleName());
+    }
+
+    public boolean isProcessorWrapper(HttpRequest httpRequest) {
+        return this.getProcessorWrapper(httpRequest) == null ? false : true;
+    }
+
+    private ProcessorWrapper getProcessorWrapper(HttpRequest httpRequest) {
+        String uri = httpRequest.uri();
+        for (Entry<String, ProcessorWrapper> e : httpProcessorMap.entrySet()) {
+            if (e.getKey().startsWith(uri)) {
+                return e.getValue();
+            }
+        }
+        return null;
+    }
+
+    /**
+     * @param httpRequest
+     */
+    public void handler(ChannelHandlerContext ctx, HttpRequest httpRequest) {
+
+
+        TraceOperation traceOperation = httpTrace.getTraceOperation(httpRequest, ctx.channel());
+
+        ProcessorWrapper processorWrapper = getProcessorWrapper(httpRequest);
+        if (Objects.isNull(processorWrapper)) {
+            this.sendResponse(ctx, HttpResponseUtils.createNotFound());
+        }
+        try {
+            HandlerSpecific handlerSpecific = new HandlerSpecific();
+            handlerSpecific.httpRequest = httpRequest;
+            handlerSpecific.ctx = ctx;
+            handlerSpecific.traceOperation = traceOperation;
+            processorWrapper.threadPoolExecutor.execute(handlerSpecific);
+        } catch (Exception e) {
+            httpServerLogger.error(e.getMessage(), e);
+            this.sendResponse(ctx, HttpResponseUtils.createInternalServerError());
+        }
+    }
+
+    private void sendResponse(ChannelHandlerContext ctx, HttpResponse response) {
+        this.sendResponse(ctx, response, true);
+    }
+
+    private void sendResponse(ChannelHandlerContext ctx, HttpResponse response, boolean isClose) {
+        ctx.writeAndFlush(response).addListener((ChannelFutureListener) f -> {
+            if (!f.isSuccess()) {
+                httpLogger.warn(""send response to [{}] fail, will close this channel"",
+                        RemotingHelper.parseChannelRemoteAddr(f.channel()));
+                if (isClose) {
+                    f.channel().close();
+                }
+            }
+        });
+    }
+
+    class HandlerSpecific implements Runnable {
+
+        private TraceOperation traceOperation;
+
+        private ChannelHandlerContext ctx;
+
+        private HttpRequest httpRequest;
+
+        private HttpResponse response;
+
+        private Throwable exception;
+
+        long requestTime = System.currentTimeMillis();
+
+
+        public void run() {
+            ProcessorWrapper processorWrapper = HandlerService.this.httpProcessorMap.get(httpRequest.uri());
+            try {
+                this.postHandler();
+                if (Objects.isNull(processorWrapper.httpProcessor)) {
+                    processorWrapper.asyn.handler(this, httpRequest);
+                    return;
+                }
+                response = processorWrapper.httpProcessor.handler(httpRequest);
+
+                this.preHandler();
+            } catch (Throwable e) {
+                httpServerLogger.error(""{},{}"");","[{'comment': 'this line is no use.', 'commenter': 'xwm1992'}]"
937,eventmesh-webhook/eventmesh-webhook-admin/src/main/java/org/apache/eventmesh/webhook/admin/FileWebHookConfigOperation.java,"@@ -48,141 +45,144 @@ public class FileWebHookConfigOperation implements WebHookConfigOperation {
 
     private static final Logger logger = LoggerFactory.getLogger(FileWebHookConfigOperation.class);
 
-	private final String webHookFilePath;
-
-	private static final String FILE_PROPERTIES_PREFIX = ""eventMesh.webHook.fileMode."";
-
-	public FileWebHookConfigOperation(Properties properties) throws FileNotFoundException {
-		String webHookFilePath = properties.getProperty(FILE_PROPERTIES_PREFIX + ""filePath"");
-		assert webHookFilePath != null;
-		File webHookFileDir = new File(webHookFilePath);
-		if (!webHookFileDir.isDirectory()) {
-			throw new FileNotFoundException(""File path "" + webHookFilePath + "" is not directory"");
-		}
-		if (!webHookFileDir.exists()) {
-			webHookFileDir.mkdirs();
-		}
-		this.webHookFilePath = webHookFilePath;
-	}
-
-	@Override
-	public Integer insertWebHookConfig(WebHookConfig webHookConfig) {
-		if (!webHookConfig.getCallbackPath().startsWith(WebHookOperationConstant.CALLBACK_PATH_PREFIX)) {
-			logger.error(""webhookConfig callback path must start with {}"", WebHookOperationConstant.CALLBACK_PATH_PREFIX);
-			return 0;
-		}
-		File manuDir = new File(getWebhookConfigManuDir(webHookConfig));
-		if (!manuDir.exists()) {
-			manuDir.mkdir();
-		}
-		File webhookConfigFile = getWebhookConfigFile(webHookConfig);
-		if (webhookConfigFile.exists()) {
-			logger.error(""webhookConfig {} is existed"", webHookConfig.getCallbackPath());
-			return 0;
-		}
-		return writeToFile(webhookConfigFile, webHookConfig) ? 1 : 0;
-	}
-
-	@Override
-	public Integer updateWebHookConfig(WebHookConfig webHookConfig) {
-		File webhookConfigFile = getWebhookConfigFile(webHookConfig);
-		if (!webhookConfigFile.exists()) {
-			logger.error(""webhookConfig {} is not existed"", webHookConfig.getCallbackPath());
-			return 0;
-		}
-		return writeToFile(webhookConfigFile, webHookConfig) ? 1 : 0;
-	}
-
-	@Override
-	public Integer deleteWebHookConfig(WebHookConfig webHookConfig) {
-		File webhookConfigFile = getWebhookConfigFile(webHookConfig);
-		if (!webhookConfigFile.exists()) {
-			logger.error(""webhookConfig {} is not existed"", webHookConfig.getCallbackPath());
-			return 0;
-		}
-		return webhookConfigFile.delete() ? 1 : 0;
-	}
-
-	@Override
-	public WebHookConfig queryWebHookConfigById(WebHookConfig webHookConfig) {
-		File webhookConfigFile = getWebhookConfigFile(webHookConfig);
-		if (!webhookConfigFile.exists()) {
-			logger.error(""webhookConfig {} is not existed"", webHookConfig.getCallbackPath());
-			return null;
-		}
-		return getWebHookConfigFromFile(webhookConfigFile);
-	}
-
-	@Override
-	public List<WebHookConfig> queryWebHookConfigByManufacturer(WebHookConfig webHookConfig, Integer pageNum,
-			Integer pageSize) {
-		String manuDirPath = getWebhookConfigManuDir(webHookConfig);
-		File manuDir = new File(manuDirPath);
-		if (!manuDir.exists()) {
-			logger.warn(""webhookConfig dir {} is not existed"", manuDirPath);
-			return new ArrayList<>();
-		}
-		File[] webhookFiles = manuDir.listFiles();
-		int startIndex = (pageNum-1)*pageSize, endIndex = pageNum*pageSize-1;
-		List<WebHookConfig> webHookConfigs = new ArrayList<>();
-		if (webhookFiles.length > startIndex) {
-			for (int i = startIndex; i < endIndex && i < webhookFiles.length; i++) {
-				webHookConfigs.add(getWebHookConfigFromFile(webhookFiles[i]));
-			}
-		}
-		return webHookConfigs;
-	}
-
-	private WebHookConfig getWebHookConfigFromFile(File webhookConfigFile) {
-		StringBuffer fileContent = new StringBuffer();
-		try (BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(webhookConfigFile)))) {
-			String line = null;
-			while ((line = br.readLine()) != null) {
-				fileContent.append(line);
-			}
-		} catch (IOException e) {
-			logger.error(""get webhook from file {} error"", webhookConfigFile.getPath(), e);
-			return null;
-		}
-		return JsonUtils.deserialize(fileContent.toString(), WebHookConfig.class);
-	}
-
-	private boolean writeToFile(File webhookConfigFile, WebHookConfig webHookConfig) {
-		FileLock lock = null;
-		try (FileOutputStream fos = new FileOutputStream(webhookConfigFile);BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(fos))){
-			// lock this file
-			lock = fos.getChannel().lock();
-			bw.write(JsonUtils.serialize(webHookConfig));
-		} catch (IOException e) {
-			logger.error(""write webhookConfig {} to file error"", webHookConfig.getCallbackPath());
-			return false;
-		} finally {
-			try {
-				if (lock != null) {
-					lock.release();
-				}
-			} catch (IOException e) {
-				logger.warn(""writeToFile finally caught an exception"", e);
-			}
-		}
-		return true;
-	}
-
-	private String getWebhookConfigManuDir(WebHookConfig webHookConfig) {
-		return webHookFilePath + WebHookOperationConstant.FILE_SEPARATOR + webHookConfig.getManufacturerName();
-	}
-
-	private File getWebhookConfigFile(WebHookConfig webHookConfig) {
-		String webhookConfigFilePath = null;
-		try {
-			// use URLEncoder.encode before, because the path may contain some speacial char like '/', which is illegal as a file name.
-			webhookConfigFilePath = this.getWebhookConfigManuDir(webHookConfig) + WebHookOperationConstant.FILE_SEPARATOR + URLEncoder.encode(webHookConfig.getCallbackPath(), ""UTF-8"") + WebHookOperationConstant.FILE_EXTENSION;
-		} catch (UnsupportedEncodingException e) {
-			logger.error(""get webhookConfig file path {} failed"", webHookConfig.getCallbackPath(), e);
-		}
-		assert webhookConfigFilePath != null;
-		return new File(webhookConfigFilePath);
-	}
+    private final String webHookFilePath;
+
+
+    public FileWebHookConfigOperation(Properties properties) throws FileNotFoundException {
+        String webHookFilePath = WebHookOperationConstant.getFilePath(properties.getProperty(""filePath""));
+
+        assert webHookFilePath != null;","[{'comment': 'Here is always true, need remove', 'commenter': 'xwm1992'}]"
937,eventmesh-webhook/eventmesh-webhook-admin/src/main/java/org/apache/eventmesh/webhook/admin/FileWebHookConfigOperation.java,"@@ -48,141 +45,144 @@ public class FileWebHookConfigOperation implements WebHookConfigOperation {
 
     private static final Logger logger = LoggerFactory.getLogger(FileWebHookConfigOperation.class);
 
-	private final String webHookFilePath;
-
-	private static final String FILE_PROPERTIES_PREFIX = ""eventMesh.webHook.fileMode."";
-
-	public FileWebHookConfigOperation(Properties properties) throws FileNotFoundException {
-		String webHookFilePath = properties.getProperty(FILE_PROPERTIES_PREFIX + ""filePath"");
-		assert webHookFilePath != null;
-		File webHookFileDir = new File(webHookFilePath);
-		if (!webHookFileDir.isDirectory()) {
-			throw new FileNotFoundException(""File path "" + webHookFilePath + "" is not directory"");
-		}
-		if (!webHookFileDir.exists()) {
-			webHookFileDir.mkdirs();
-		}
-		this.webHookFilePath = webHookFilePath;
-	}
-
-	@Override
-	public Integer insertWebHookConfig(WebHookConfig webHookConfig) {
-		if (!webHookConfig.getCallbackPath().startsWith(WebHookOperationConstant.CALLBACK_PATH_PREFIX)) {
-			logger.error(""webhookConfig callback path must start with {}"", WebHookOperationConstant.CALLBACK_PATH_PREFIX);
-			return 0;
-		}
-		File manuDir = new File(getWebhookConfigManuDir(webHookConfig));
-		if (!manuDir.exists()) {
-			manuDir.mkdir();
-		}
-		File webhookConfigFile = getWebhookConfigFile(webHookConfig);
-		if (webhookConfigFile.exists()) {
-			logger.error(""webhookConfig {} is existed"", webHookConfig.getCallbackPath());
-			return 0;
-		}
-		return writeToFile(webhookConfigFile, webHookConfig) ? 1 : 0;
-	}
-
-	@Override
-	public Integer updateWebHookConfig(WebHookConfig webHookConfig) {
-		File webhookConfigFile = getWebhookConfigFile(webHookConfig);
-		if (!webhookConfigFile.exists()) {
-			logger.error(""webhookConfig {} is not existed"", webHookConfig.getCallbackPath());
-			return 0;
-		}
-		return writeToFile(webhookConfigFile, webHookConfig) ? 1 : 0;
-	}
-
-	@Override
-	public Integer deleteWebHookConfig(WebHookConfig webHookConfig) {
-		File webhookConfigFile = getWebhookConfigFile(webHookConfig);
-		if (!webhookConfigFile.exists()) {
-			logger.error(""webhookConfig {} is not existed"", webHookConfig.getCallbackPath());
-			return 0;
-		}
-		return webhookConfigFile.delete() ? 1 : 0;
-	}
-
-	@Override
-	public WebHookConfig queryWebHookConfigById(WebHookConfig webHookConfig) {
-		File webhookConfigFile = getWebhookConfigFile(webHookConfig);
-		if (!webhookConfigFile.exists()) {
-			logger.error(""webhookConfig {} is not existed"", webHookConfig.getCallbackPath());
-			return null;
-		}
-		return getWebHookConfigFromFile(webhookConfigFile);
-	}
-
-	@Override
-	public List<WebHookConfig> queryWebHookConfigByManufacturer(WebHookConfig webHookConfig, Integer pageNum,
-			Integer pageSize) {
-		String manuDirPath = getWebhookConfigManuDir(webHookConfig);
-		File manuDir = new File(manuDirPath);
-		if (!manuDir.exists()) {
-			logger.warn(""webhookConfig dir {} is not existed"", manuDirPath);
-			return new ArrayList<>();
-		}
-		File[] webhookFiles = manuDir.listFiles();
-		int startIndex = (pageNum-1)*pageSize, endIndex = pageNum*pageSize-1;
-		List<WebHookConfig> webHookConfigs = new ArrayList<>();
-		if (webhookFiles.length > startIndex) {
-			for (int i = startIndex; i < endIndex && i < webhookFiles.length; i++) {
-				webHookConfigs.add(getWebHookConfigFromFile(webhookFiles[i]));
-			}
-		}
-		return webHookConfigs;
-	}
-
-	private WebHookConfig getWebHookConfigFromFile(File webhookConfigFile) {
-		StringBuffer fileContent = new StringBuffer();
-		try (BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(webhookConfigFile)))) {
-			String line = null;
-			while ((line = br.readLine()) != null) {
-				fileContent.append(line);
-			}
-		} catch (IOException e) {
-			logger.error(""get webhook from file {} error"", webhookConfigFile.getPath(), e);
-			return null;
-		}
-		return JsonUtils.deserialize(fileContent.toString(), WebHookConfig.class);
-	}
-
-	private boolean writeToFile(File webhookConfigFile, WebHookConfig webHookConfig) {
-		FileLock lock = null;
-		try (FileOutputStream fos = new FileOutputStream(webhookConfigFile);BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(fos))){
-			// lock this file
-			lock = fos.getChannel().lock();
-			bw.write(JsonUtils.serialize(webHookConfig));
-		} catch (IOException e) {
-			logger.error(""write webhookConfig {} to file error"", webHookConfig.getCallbackPath());
-			return false;
-		} finally {
-			try {
-				if (lock != null) {
-					lock.release();
-				}
-			} catch (IOException e) {
-				logger.warn(""writeToFile finally caught an exception"", e);
-			}
-		}
-		return true;
-	}
-
-	private String getWebhookConfigManuDir(WebHookConfig webHookConfig) {
-		return webHookFilePath + WebHookOperationConstant.FILE_SEPARATOR + webHookConfig.getManufacturerName();
-	}
-
-	private File getWebhookConfigFile(WebHookConfig webHookConfig) {
-		String webhookConfigFilePath = null;
-		try {
-			// use URLEncoder.encode before, because the path may contain some speacial char like '/', which is illegal as a file name.
-			webhookConfigFilePath = this.getWebhookConfigManuDir(webHookConfig) + WebHookOperationConstant.FILE_SEPARATOR + URLEncoder.encode(webHookConfig.getCallbackPath(), ""UTF-8"") + WebHookOperationConstant.FILE_EXTENSION;
-		} catch (UnsupportedEncodingException e) {
-			logger.error(""get webhookConfig file path {} failed"", webHookConfig.getCallbackPath(), e);
-		}
-		assert webhookConfigFilePath != null;
-		return new File(webhookConfigFilePath);
-	}
+    private final String webHookFilePath;
+
+
+    public FileWebHookConfigOperation(Properties properties) throws FileNotFoundException {
+        String webHookFilePath = WebHookOperationConstant.getFilePath(properties.getProperty(""filePath""));
+
+        assert webHookFilePath != null;
+        File webHookFileDir = new File(webHookFilePath);
+        if (!webHookFileDir.isDirectory()) {
+            throw new FileNotFoundException(""File path "" + webHookFilePath + "" is not directory"");
+        }
+        if (!webHookFileDir.exists()) {
+            webHookFileDir.mkdirs();
+        }
+        this.webHookFilePath = webHookFilePath;
+    }
+
+    @Override
+    public Integer insertWebHookConfig(WebHookConfig webHookConfig) {
+        if (!webHookConfig.getCallbackPath().startsWith(WebHookOperationConstant.CALLBACK_PATH_PREFIX)) {
+            logger.error(""webhookConfig callback path must start with {}"", WebHookOperationConstant.CALLBACK_PATH_PREFIX);
+            return 0;
+        }
+        File manuDir = new File(getWebhookConfigManuDir(webHookConfig));
+        if (!manuDir.exists()) {
+            manuDir.mkdir();
+        }
+        File webhookConfigFile = getWebhookConfigFile(webHookConfig);
+        if (webhookConfigFile.exists()) {
+            logger.error(""webhookConfig {} is existed"", webHookConfig.getCallbackPath());
+            return 0;
+        }
+        return writeToFile(webhookConfigFile, webHookConfig) ? 1 : 0;
+    }
+
+    @Override
+    public Integer updateWebHookConfig(WebHookConfig webHookConfig) {
+        File webhookConfigFile = getWebhookConfigFile(webHookConfig);
+        if (!webhookConfigFile.exists()) {
+            logger.error(""webhookConfig {} is not existed"", webHookConfig.getCallbackPath());
+            return 0;
+        }
+        return writeToFile(webhookConfigFile, webHookConfig) ? 1 : 0;
+    }
+
+    @Override
+    public Integer deleteWebHookConfig(WebHookConfig webHookConfig) {
+        File webhookConfigFile = getWebhookConfigFile(webHookConfig);
+        if (!webhookConfigFile.exists()) {
+            logger.error(""webhookConfig {} is not existed"", webHookConfig.getCallbackPath());
+            return 0;
+        }
+        return webhookConfigFile.delete() ? 1 : 0;
+    }
+
+    @Override
+    public WebHookConfig queryWebHookConfigById(WebHookConfig webHookConfig) {
+        File webhookConfigFile = getWebhookConfigFile(webHookConfig);
+        if (!webhookConfigFile.exists()) {
+            logger.error(""webhookConfig {} is not existed"", webHookConfig.getCallbackPath());
+            return null;
+        }
+        return getWebHookConfigFromFile(webhookConfigFile);
+    }
+
+    @Override
+    public List<WebHookConfig> queryWebHookConfigByManufacturer(WebHookConfig webHookConfig, Integer pageNum,
+                                                                Integer pageSize) {
+        String manuDirPath = getWebhookConfigManuDir(webHookConfig);
+        File manuDir = new File(manuDirPath);
+        if (!manuDir.exists()) {
+            logger.warn(""webhookConfig dir {} is not existed"", manuDirPath);
+            return new ArrayList<>();
+        }
+        File[] webhookFiles = manuDir.listFiles();
+        int startIndex = (pageNum - 1) * pageSize;
+        int endIndex = pageNum * pageSize - 1;
+        List<WebHookConfig> webHookConfigs = new ArrayList<>();
+        if (webhookFiles.length > startIndex) {","[{'comment': 'Here webhookFiles may cause NullPointException', 'commenter': 'xwm1992'}]"
937,eventmesh-webhook/eventmesh-webhook-admin/src/main/java/org/apache/eventmesh/webhook/admin/NacosWebHookConfigOperation.java,"@@ -16,182 +16,190 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-import com.alibaba.nacos.api.PropertyKeyConst;
-import com.alibaba.nacos.api.config.ConfigFactory;
-import com.alibaba.nacos.api.config.ConfigService;
-import com.alibaba.nacos.api.config.ConfigType;
-import com.alibaba.nacos.api.exception.NacosException;
-import com.alibaba.nacos.shaded.io.grpc.netty.shaded.io.netty.util.internal.StringUtil;
+
+import static org.apache.eventmesh.webhook.api.WebHookOperationConstant.DATA_ID_EXTENSION;
+import static org.apache.eventmesh.webhook.api.WebHookOperationConstant.GROUP_PREFIX;
+import static org.apache.eventmesh.webhook.api.WebHookOperationConstant.MANUFACTURERS_DATA_ID;
+import static org.apache.eventmesh.webhook.api.WebHookOperationConstant.TIMEOUT_MS;
+
+
+
 import org.apache.eventmesh.common.utils.JsonUtils;
 import org.apache.eventmesh.webhook.api.ManufacturerObject;
 import org.apache.eventmesh.webhook.api.WebHookConfig;
 import org.apache.eventmesh.webhook.api.WebHookConfigOperation;
+import org.apache.eventmesh.webhook.api.WebHookOperationConstant;
 
 import java.io.UnsupportedEncodingException;
 import java.net.URLEncoder;
-import java.util.*;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Properties;
+
 
-import org.apache.eventmesh.webhook.api.WebHookOperationConstant;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import static org.apache.eventmesh.webhook.api.WebHookOperationConstant.*;
-
-public class NacosWebHookConfigOperation implements WebHookConfigOperation{
-
-	private static final Logger logger = LoggerFactory.getLogger(NacosWebHookConfigOperation.class);
-
-	private ConfigService configService;
-
-	private static final String NACOS_PROPERTIES_PREFIX = ""eventMesh.webHook.nacosMode."";
-
-	public NacosWebHookConfigOperation(Properties properties) throws NacosException {
-		Properties nacosProperties = new Properties();
-		nacosProperties.put(PropertyKeyConst.SERVER_ADDR, properties.getProperty(NACOS_PROPERTIES_PREFIX + PropertyKeyConst.SERVER_ADDR));
-		nacosProperties.put(PropertyKeyConst.NAMESPACE, properties.getProperty(NACOS_PROPERTIES_PREFIX + PropertyKeyConst.NAMESPACE));
-		nacosProperties.put(PropertyKeyConst.USERNAME, properties.getProperty(NACOS_PROPERTIES_PREFIX + PropertyKeyConst.USERNAME));
-		nacosProperties.put(PropertyKeyConst.PASSWORD, properties.getProperty(NACOS_PROPERTIES_PREFIX + PropertyKeyConst.PASSWORD));
-		configService = ConfigFactory.createConfigService(nacosProperties);
-
-		String manufacturers= configService.getConfig(MANUFACTURERS_DATA_ID, ""webhook"", TIMEOUT_MS);
-		if (manufacturers == null) {
-			configService.publishConfig(MANUFACTURERS_DATA_ID, ""webhook"", JsonUtils.serialize(new ManufacturerObject()), ConfigType.JSON.getType());
-		}
-
-	}
-
-	@Override
-	public Integer insertWebHookConfig(WebHookConfig webHookConfig) {
-		if (!webHookConfig.getCallbackPath().startsWith(WebHookOperationConstant.CALLBACK_PATH_PREFIX)) {
-			logger.error(""webhookConfig callback path must start with {}"", WebHookOperationConstant.CALLBACK_PATH_PREFIX);
-			return 0;
-		}
-		Boolean result;
-		String manufacturerName = webHookConfig.getManufacturerName();
-		try {
-			if (configService.getConfig(getWebHookConfigDataId(webHookConfig), getManuGroupId(webHookConfig), TIMEOUT_MS) != null) {
-				logger.error(""insertWebHookConfig failed, config has existed"");
-				return 0;
-			}
-			result = configService.publishConfig(getWebHookConfigDataId(webHookConfig), getManuGroupId(webHookConfig), JsonUtils.serialize(webHookConfig), ConfigType.JSON.getType());
-		} catch (NacosException e) {
-			logger.error(""insertWebHookConfig failed"", e);
-			return 0;
-		}
-		if (result) {
-			// update manufacturer config
-			try {
-				ManufacturerObject manufacturerObject = getManufacturersInfo();
-				manufacturerObject.addManufacturer(manufacturerName);
-				manufacturerObject.getManufacturerEvents(manufacturerName).add(getWebHookConfigDataId(webHookConfig));
-				configService.publishConfig(MANUFACTURERS_DATA_ID, ""webhook"", JsonUtils.serialize(manufacturerObject), ConfigType.JSON.getType());
-			} catch (NacosException e) {
-				logger.error(""update manufacturersInfo error"", e);
-				//rollback insert
-				try {
-					configService.removeConfig(getWebHookConfigDataId(webHookConfig), getManuGroupId(webHookConfig));
-				} catch (NacosException ex) {
-					logger.error(""rollback insertWebHookConfig failed"", e);
-				}
-			}
-		}
-		return result ? 1 : 0;
-	}
-
-	@Override
-	public Integer updateWebHookConfig(WebHookConfig webHookConfig) {
-		Boolean result = false;
-		try {
-			if (configService.getConfig(getWebHookConfigDataId(webHookConfig), getManuGroupId(webHookConfig), TIMEOUT_MS) == null) {
-				logger.error(""updateWebHookConfig failed, config is not existed"");
-				return 0;
-			}
-			result = configService.publishConfig(getWebHookConfigDataId(webHookConfig), getManuGroupId(webHookConfig), JsonUtils.serialize(webHookConfig), ConfigType.JSON.getType());
-		} catch (NacosException e) {
-			logger.error(""updateWebHookConfig failed"", e);
-		}
-		return result ? 1 : 0;
-	}
-
-	@Override
-	public Integer deleteWebHookConfig(WebHookConfig webHookConfig) {
-		Boolean result = false;
-		String manufacturerName = webHookConfig.getManufacturerName();
-		try {
-			result = configService.removeConfig(getWebHookConfigDataId(webHookConfig), getManuGroupId(webHookConfig));
-		} catch (NacosException e) {
-			logger.error(""deleteWebHookConfig failed"", e);
-		}
-		if (result) {
-			//更新集合
-			try {
-				ManufacturerObject manufacturerObject = getManufacturersInfo();
-				manufacturerObject.getManufacturerEvents(manufacturerName).remove(getWebHookConfigDataId(webHookConfig));
-				configService.publishConfig(MANUFACTURERS_DATA_ID, ""webhook"", JsonUtils.serialize(manufacturerObject), ConfigType.JSON.getType());
-			} catch (NacosException e) {
-				logger.error(""update manufacturersInfo error"", e);
-			}
-		}
-		return result ? 1 : 0;
-	}
-
-	@Override
-	public WebHookConfig queryWebHookConfigById(WebHookConfig webHookConfig) {
-		try {
-			String content = configService.getConfig(getWebHookConfigDataId(webHookConfig), getManuGroupId(webHookConfig), TIMEOUT_MS);
-			return JsonUtils.deserialize(content, WebHookConfig.class);
-		} catch (NacosException e) {
-			logger.error(""queryWebHookConfigById failed"", e);
-		}
-		return null;
-	}
-
-	@Override
-	public List<WebHookConfig> queryWebHookConfigByManufacturer(WebHookConfig webHookConfig, Integer pageNum,
-			Integer pageSize) {
-		List<WebHookConfig> webHookConfigs = new ArrayList<>();
-		String manufacturerName = webHookConfig.getManufacturerName();
-		// get manufacturer event list
-		try {
-			ManufacturerObject manufacturerObject = getManufacturersInfo();
-			List<String> manufacturerEvents = manufacturerObject.getManufacturerEvents(manufacturerName);
-			int startIndex = (pageNum-1)*pageSize, endIndex = pageNum*pageSize-1;
-			if (manufacturerEvents.size() > startIndex) {
-				// nacos API is not able to get all config, so use foreach
-				for (int i=startIndex; i<endIndex && i<manufacturerEvents.size(); i++) {
-					String content = configService.getConfig(manufacturerEvents.get(i)+ DATA_ID_EXTENSION, getManuGroupId(webHookConfig), TIMEOUT_MS);
-					webHookConfigs.add(JsonUtils.deserialize(content, WebHookConfig.class));
-				}
-			}
-		} catch (NacosException e) {
-			logger.error(""queryWebHookConfigByManufacturer failed"", e);
-		}
-		return webHookConfigs;
-	}
-
-	/**
-	 * @param webHookConfig
-	 * @return
-	 */
-	private String getWebHookConfigDataId(WebHookConfig webHookConfig) {
-		try {
-			// use URLEncoder.encode before, because the path may contain some speacial char like '/', which is illegal as a data id.
-			return URLEncoder.encode(webHookConfig.getCallbackPath(), ""UTF-8"") + DATA_ID_EXTENSION;
-		} catch (UnsupportedEncodingException e) {
-			logger.error(""get webhookConfig dataId {} failed"", webHookConfig.getCallbackPath(), e);
-		}
-		return webHookConfig.getCallbackPath() + DATA_ID_EXTENSION;
-	}
-
-	private String getManuGroupId(WebHookConfig webHookConfig) {
-		return GROUP_PREFIX + webHookConfig.getManufacturerName();
-	}
-
-	private ManufacturerObject getManufacturersInfo() throws NacosException {
-		String manufacturersContent = configService.getConfig(MANUFACTURERS_DATA_ID, ""webhook"", TIMEOUT_MS);
-		return StringUtil.isNullOrEmpty(manufacturersContent) ?
-				new ManufacturerObject():
-				JsonUtils.deserialize(manufacturersContent, ManufacturerObject.class);
-	}
+import com.alibaba.nacos.api.config.ConfigFactory;
+import com.alibaba.nacos.api.config.ConfigService;
+import com.alibaba.nacos.api.config.ConfigType;
+import com.alibaba.nacos.api.exception.NacosException;
+import com.alibaba.nacos.shaded.io.grpc.netty.shaded.io.netty.util.internal.StringUtil;
+
+
+public class NacosWebHookConfigOperation implements WebHookConfigOperation {
+
+    private static final Logger logger = LoggerFactory.getLogger(NacosWebHookConfigOperation.class);
+
+    private ConfigService configService;","[{'comment': 'Here can add final', 'commenter': 'xwm1992'}]"
937,eventmesh-common/src/main/java/org/apache/eventmesh/common/config/ConfigurationWrapper.java,"@@ -24,28 +24,31 @@
 import java.io.BufferedReader;
 import java.io.FileReader;
 import java.io.IOException;
+import java.util.Map.Entry;
 import java.util.Properties;
 import java.util.concurrent.ScheduledExecutorService;
 import java.util.concurrent.TimeUnit;
 
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import com.fasterxml.jackson.databind.ObjectMapper;
 import com.google.common.base.Preconditions;
 
 public class ConfigurationWrapper {
 
     public Logger logger = LoggerFactory.getLogger(this.getClass());
-    
+
     private static final long TIME_INTERVAL = 30 * 1000L;
-    
+
     private String file;
 
     private Properties properties = new Properties();
 
     private boolean reload;
 
-    private ScheduledExecutorService configLoader = ThreadPoolFactory.createSingleScheduledExecutor(""eventMesh-configLoader-"");
+    private ScheduledExecutorService configLoader = ThreadPoolFactory
+            .createSingleScheduledExecutor(""eventMesh-configLoader-"");","[{'comment': 'These variables can be added final', 'commenter': 'xwm1992'}]"
937,eventmesh-runtime/src/main/java/org/apache/eventmesh/runtime/core/protocol/http/processor/HandlerService.java,"@@ -0,0 +1,232 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.eventmesh.runtime.core.protocol.http.processor;
+
+import org.apache.eventmesh.runtime.boot.HTTPTrace;
+import org.apache.eventmesh.runtime.boot.HTTPTrace.TraceOperation;
+import org.apache.eventmesh.runtime.metrics.http.HTTPMetricsServer;
+import org.apache.eventmesh.runtime.util.HttpResponseUtils;
+import org.apache.eventmesh.runtime.util.RemotingHelper;
+
+import java.util.Map;
+import java.util.Map.Entry;
+import java.util.Objects;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ThreadPoolExecutor;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import io.netty.channel.ChannelFutureListener;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.handler.codec.http.HttpRequest;
+import io.netty.handler.codec.http.HttpResponse;
+
+import lombok.Setter;
+
+
+public class HandlerService {
+
+    private Logger httpServerLogger = LoggerFactory.getLogger(this.getClass());
+
+    private Logger httpLogger = LoggerFactory.getLogger(""http"");
+
+    private Map<String, ProcessorWrapper> httpProcessorMap = new ConcurrentHashMap<>();
+
+    @Setter
+    private HTTPMetricsServer metrics;
+
+    @Setter
+    private HTTPTrace httpTrace;
+
+
+    public void init() {
+        httpServerLogger.info(""HandlerService start "");
+    }
+
+    public void register(HttpProcessor httpProcessor, ThreadPoolExecutor threadPoolExecutor) {
+        for (String path : httpProcessor.paths()) {
+            this.register(path, httpProcessor, threadPoolExecutor);
+        }
+    }
+
+    public void register(String path, HttpProcessor httpProcessor, ThreadPoolExecutor threadPoolExecutor) {
+
+        if (httpProcessorMap.containsKey(path)) {
+            throw new RuntimeException(String.format(""HandlerService path %s repeat, repeat processor is %s "",
+                    path, httpProcessor.getClass().getSimpleName()));
+        }
+        ProcessorWrapper processorWrapper = new ProcessorWrapper();
+        processorWrapper.threadPoolExecutor = threadPoolExecutor;
+        processorWrapper.httpProcessor = httpProcessor;
+        if (httpProcessor instanceof AsynHttpProcessor) {
+            processorWrapper.asyn = (AsynHttpProcessor) httpProcessor;
+        } else {
+            processorWrapper.httpProcessor = httpProcessor;","[{'comment': '`processorWrapper.httpProcessor` has already assigned value at line 76', 'commenter': 'xwm1992'}, {'comment': 'ok', 'commenter': 'githublaohu'}]"
937,eventmesh-runtime/src/main/java/org/apache/eventmesh/runtime/core/protocol/http/processor/HandlerService.java,"@@ -0,0 +1,232 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.eventmesh.runtime.core.protocol.http.processor;
+
+import org.apache.eventmesh.runtime.boot.HTTPTrace;
+import org.apache.eventmesh.runtime.boot.HTTPTrace.TraceOperation;
+import org.apache.eventmesh.runtime.metrics.http.HTTPMetricsServer;
+import org.apache.eventmesh.runtime.util.HttpResponseUtils;
+import org.apache.eventmesh.runtime.util.RemotingHelper;
+
+import java.util.Map;
+import java.util.Map.Entry;
+import java.util.Objects;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ThreadPoolExecutor;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import io.netty.channel.ChannelFutureListener;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.handler.codec.http.HttpRequest;
+import io.netty.handler.codec.http.HttpResponse;
+
+import lombok.Setter;
+
+
+public class HandlerService {
+
+    private Logger httpServerLogger = LoggerFactory.getLogger(this.getClass());
+
+    private Logger httpLogger = LoggerFactory.getLogger(""http"");
+
+    private Map<String, ProcessorWrapper> httpProcessorMap = new ConcurrentHashMap<>();
+
+    @Setter
+    private HTTPMetricsServer metrics;
+
+    @Setter
+    private HTTPTrace httpTrace;
+
+
+    public void init() {
+        httpServerLogger.info(""HandlerService start "");
+    }
+
+    public void register(HttpProcessor httpProcessor, ThreadPoolExecutor threadPoolExecutor) {
+        for (String path : httpProcessor.paths()) {
+            this.register(path, httpProcessor, threadPoolExecutor);
+        }
+    }
+
+    public void register(String path, HttpProcessor httpProcessor, ThreadPoolExecutor threadPoolExecutor) {
+
+        if (httpProcessorMap.containsKey(path)) {
+            throw new RuntimeException(String.format(""HandlerService path %s repeat, repeat processor is %s "",
+                    path, httpProcessor.getClass().getSimpleName()));
+        }
+        ProcessorWrapper processorWrapper = new ProcessorWrapper();
+        processorWrapper.threadPoolExecutor = threadPoolExecutor;
+        processorWrapper.httpProcessor = httpProcessor;
+        if (httpProcessor instanceof AsynHttpProcessor) {
+            processorWrapper.asyn = (AsynHttpProcessor) httpProcessor;
+        } else {
+            processorWrapper.httpProcessor = httpProcessor;
+        }
+        httpProcessorMap.put(path, processorWrapper);
+        httpServerLogger.info(""path is {}  proocessor name is {}"", path, httpProcessor.getClass().getSimpleName());
+    }
+
+    public boolean isProcessorWrapper(HttpRequest httpRequest) {
+        return Objects.nonNull(this.getProcessorWrapper(httpRequest));
+    }
+
+    private ProcessorWrapper getProcessorWrapper(HttpRequest httpRequest) {
+        String uri = httpRequest.uri();
+        for (Entry<String, ProcessorWrapper> e : httpProcessorMap.entrySet()) {
+            if (e.getKey().startsWith(uri)) {
+                return e.getValue();
+            }
+        }
+        return null;
+    }
+
+    /**
+     * @param httpRequest
+     */
+    public void handler(ChannelHandlerContext ctx, HttpRequest httpRequest) {
+
+
+        TraceOperation traceOperation = httpTrace.getTraceOperation(httpRequest, ctx.channel());
+
+        ProcessorWrapper processorWrapper = getProcessorWrapper(httpRequest);
+        if (Objects.isNull(processorWrapper)) {
+            this.sendResponse(ctx, HttpResponseUtils.createNotFound());","[{'comment': 'after sendResponse here need to return ?', 'commenter': 'xwm1992'}]"
937,eventmesh-runtime/src/main/java/org/apache/eventmesh/runtime/core/protocol/http/processor/AsynHttpProcessor.java,"@@ -0,0 +1,35 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.eventmesh.runtime.core.protocol.http.processor;
+
+import org.apache.eventmesh.runtime.core.protocol.http.processor.HandlerService.HandlerSpecific;
+
+import io.netty.handler.codec.http.HttpRequest;
+import io.netty.handler.codec.http.HttpResponse;
+
+/**
+ * aysn http processor
+ */
+public interface AsynHttpProcessor extends HttpProcessor {","[{'comment': 'please rename to AsyncHttpProcessor', 'commenter': 'xwm1992'}, {'comment': 'ok', 'commenter': 'githublaohu'}]"
937,eventmesh-runtime/src/main/java/org/apache/eventmesh/runtime/core/protocol/http/processor/AsynHttpProcessor.java,"@@ -0,0 +1,35 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.eventmesh.runtime.core.protocol.http.processor;
+
+import org.apache.eventmesh.runtime.core.protocol.http.processor.HandlerService.HandlerSpecific;
+
+import io.netty.handler.codec.http.HttpRequest;
+import io.netty.handler.codec.http.HttpResponse;
+
+/**
+ * aysn http processor","[{'comment': 'aysn -> async', 'commenter': 'xwm1992'}, {'comment': 'ok', 'commenter': 'githublaohu'}]"
937,eventmesh-runtime/src/main/java/org/apache/eventmesh/runtime/core/protocol/http/processor/HandlerService.java,"@@ -0,0 +1,232 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.eventmesh.runtime.core.protocol.http.processor;
+
+import org.apache.eventmesh.runtime.boot.HTTPTrace;
+import org.apache.eventmesh.runtime.boot.HTTPTrace.TraceOperation;
+import org.apache.eventmesh.runtime.metrics.http.HTTPMetricsServer;
+import org.apache.eventmesh.runtime.util.HttpResponseUtils;
+import org.apache.eventmesh.runtime.util.RemotingHelper;
+
+import java.util.Map;
+import java.util.Map.Entry;
+import java.util.Objects;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ThreadPoolExecutor;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import io.netty.channel.ChannelFutureListener;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.handler.codec.http.HttpRequest;
+import io.netty.handler.codec.http.HttpResponse;
+
+import lombok.Setter;
+
+
+public class HandlerService {
+
+    private Logger httpServerLogger = LoggerFactory.getLogger(this.getClass());
+
+    private Logger httpLogger = LoggerFactory.getLogger(""http"");
+
+    private Map<String, ProcessorWrapper> httpProcessorMap = new ConcurrentHashMap<>();
+
+    @Setter
+    private HTTPMetricsServer metrics;
+
+    @Setter
+    private HTTPTrace httpTrace;
+
+
+    public void init() {
+        httpServerLogger.info(""HandlerService start "");
+    }
+
+    public void register(HttpProcessor httpProcessor, ThreadPoolExecutor threadPoolExecutor) {
+        for (String path : httpProcessor.paths()) {
+            this.register(path, httpProcessor, threadPoolExecutor);
+        }
+    }
+
+    public void register(String path, HttpProcessor httpProcessor, ThreadPoolExecutor threadPoolExecutor) {
+
+        if (httpProcessorMap.containsKey(path)) {
+            throw new RuntimeException(String.format(""HandlerService path %s repeat, repeat processor is %s "",
+                    path, httpProcessor.getClass().getSimpleName()));
+        }
+        ProcessorWrapper processorWrapper = new ProcessorWrapper();
+        processorWrapper.threadPoolExecutor = threadPoolExecutor;
+        processorWrapper.httpProcessor = httpProcessor;
+        if (httpProcessor instanceof AsynHttpProcessor) {
+            processorWrapper.asyn = (AsynHttpProcessor) httpProcessor;
+        } else {
+            processorWrapper.httpProcessor = httpProcessor;
+        }
+        httpProcessorMap.put(path, processorWrapper);
+        httpServerLogger.info(""path is {}  proocessor name is {}"", path, httpProcessor.getClass().getSimpleName());
+    }
+
+    public boolean isProcessorWrapper(HttpRequest httpRequest) {
+        return Objects.nonNull(this.getProcessorWrapper(httpRequest));
+    }
+
+    private ProcessorWrapper getProcessorWrapper(HttpRequest httpRequest) {
+        String uri = httpRequest.uri();
+        for (Entry<String, ProcessorWrapper> e : httpProcessorMap.entrySet()) {
+            if (e.getKey().startsWith(uri)) {
+                return e.getValue();
+            }
+        }
+        return null;
+    }
+
+    /**
+     * @param httpRequest
+     */
+    public void handler(ChannelHandlerContext ctx, HttpRequest httpRequest) {
+
+
+        TraceOperation traceOperation = httpTrace.getTraceOperation(httpRequest, ctx.channel());
+
+        ProcessorWrapper processorWrapper = getProcessorWrapper(httpRequest);
+        if (Objects.isNull(processorWrapper)) {
+            this.sendResponse(ctx, HttpResponseUtils.createNotFound());
+        }
+        try {
+            HandlerSpecific handlerSpecific = new HandlerSpecific();
+            handlerSpecific.httpRequest = httpRequest;
+            handlerSpecific.ctx = ctx;
+            handlerSpecific.traceOperation = traceOperation;
+            processorWrapper.threadPoolExecutor.execute(handlerSpecific);
+        } catch (Exception e) {
+            httpServerLogger.error(e.getMessage(), e);
+            this.sendResponse(ctx, HttpResponseUtils.createInternalServerError());
+        }
+    }
+
+    private void sendResponse(ChannelHandlerContext ctx, HttpResponse response) {
+        this.sendResponse(ctx, response, true);
+    }
+
+    private void sendResponse(ChannelHandlerContext ctx, HttpResponse response, boolean isClose) {
+        ctx.writeAndFlush(response).addListener((ChannelFutureListener) f -> {
+            if (!f.isSuccess()) {
+                httpLogger.warn(""send response to [{}] fail, will close this channel"",
+                        RemotingHelper.parseChannelRemoteAddr(f.channel()));
+                if (isClose) {
+                    f.channel().close();
+                }
+            }
+        });
+    }
+
+    class HandlerSpecific implements Runnable {
+
+        private TraceOperation traceOperation;
+
+        private ChannelHandlerContext ctx;
+
+        private HttpRequest httpRequest;
+
+        private HttpResponse response;
+
+        private Throwable exception;
+
+        long requestTime = System.currentTimeMillis();
+
+
+        public void run() {
+            ProcessorWrapper processorWrapper = HandlerService.this.httpProcessorMap.get(httpRequest.uri());
+            try {
+                this.postHandler();
+                if (Objects.isNull(processorWrapper.httpProcessor)) {
+                    processorWrapper.asyn.handler(this, httpRequest);
+                    return;
+                }
+                response = processorWrapper.httpProcessor.handler(httpRequest);
+
+                this.preHandler();
+            } catch (Throwable e) {
+                httpServerLogger.error(e.getMessage(), e);
+                exception = e;
+                this.errer();
+            }
+        }
+
+        private void preHandler() {
+            metrics.getSummaryMetrics().recordHTTPRequest();
+            if (httpLogger.isDebugEnabled()) {
+                httpLogger.debug(""{}"", httpRequest);
+            }
+            if (Objects.isNull(response)) {
+                this.response = HttpResponseUtils.createSuccess();
+            }
+            this.traceOperation.endTrace();
+            this.sendResponse(this.response);
+        }
+
+        private void postHandler() {
+            metrics.getSummaryMetrics().recordHTTPReqResTimeCost(System.currentTimeMillis() - requestTime);
+            if (httpLogger.isDebugEnabled()) {
+                httpLogger.debug(""{}"", response);
+            }
+        }
+
+        private void errer() {
+            this.traceOperation.exceptionTrace(this.exception);
+            metrics.getSummaryMetrics().recordHTTPDiscard();
+            metrics.getSummaryMetrics().recordHTTPReqResTimeCost(System.currentTimeMillis() - requestTime);
+            this.sendResponse(HttpResponseUtils.createInternalServerError());
+        }
+
+
+        public void setResponseJsonBody(String body) {
+            this.sendResponse(HttpResponseUtils.setResponseJsonBody(body, ctx));
+        }
+
+        public void setResponseTextBody(String body) {
+            this.sendResponse(HttpResponseUtils.setResponseTextBody(body, ctx));
+        }
+
+        public void sendResponse(HttpResponse response) {
+            this.response = response;
+            this.preHandler();
+        }
+
+        /**
+         * @param count
+         */
+        public void recordSendBatchMsgFailed(int count) {
+            metrics.getSummaryMetrics().recordSendBatchMsgFailed(1);
+        }
+
+    }
+
+
+    private static class ProcessorWrapper {
+
+        private ThreadPoolExecutor threadPoolExecutor;
+
+        private HttpProcessor httpProcessor;
+
+        private AsynHttpProcessor asyn;","[{'comment': 'asyn -> async', 'commenter': 'xwm1992'}, {'comment': 'ok', 'commenter': 'githublaohu'}]"
937,eventmesh-webhook/eventmesh-webhook-receive/src/main/java/org/apache/eventmesh/webhook/receive/storage/HookConfigOperationManage.java,"@@ -61,20 +63,19 @@ public HookConfigOperationManage() {
      * @param operationMode file/nacos...
      * @param config        Parameters required to initialize the behavior","[{'comment': 'remove these comments', 'commenter': 'xwm1992'}, {'comment': 'OK', 'commenter': 'githublaohu'}]"
937,eventmesh-webhook/eventmesh-webhook-receive/src/main/java/org/apache/eventmesh/webhook/receive/storage/WebhookFileListener.java,"@@ -74,9 +75,6 @@ public WebhookFileListener(String filePath, Map<String, WebHookConfig> cacheWebH
      */
     public void filePatternInit() throws FileNotFoundException {","[{'comment': 'After updating the code , this FileNotFoundException will never thrown， can be removed', 'commenter': 'xwm1992'}, {'comment': 'OK', 'commenter': 'githublaohu'}]"
944,eventmesh-runtime/src/main/java/org/apache/eventmesh/runtime/acl/Acl.java,"@@ -87,8 +87,8 @@ public static void doAclCheckInHttpSend(String remoteAddr, String user, String p
     }
 
     public static void doAclCheckInHttpSend(String remoteAddr, String user, String pass, String subsystem, String topic,
-                                            String requestURI) throws AclException {
-        aclService.doAclCheckInSend(buildHttpAclProperties(remoteAddr, user, pass, subsystem, topic, requestURI));
+                                            String requestUri) throws AclException {
+        aclService.doAclCheckInSend(buildHttpAclProperties(remoteAddr, user, pass, subsystem, topic, requestUri));","[{'comment': ""Please revert this change, it's better to use URI here rather than Uri, since URI is the abbreviation for `Uniform Resource Identifier`."", 'commenter': 'ruanwenjun'}]"
966,eventmesh-runtime/src/main/java/org/apache/eventmesh/runtime/util/RemotingHelper.java,"@@ -50,6 +50,9 @@ public static String exceptionSimpleDesc(final Throwable e) {
 
     public static SocketAddress string2SocketAddress(final String addr) {
         int split = addr.lastIndexOf("":"");
+        if (split == -1) {","[{'comment': ""It's better to not do these kinds of changes in this PR, you just want to add UT right? Please revert the extra change."", 'commenter': 'ruanwenjun'}, {'comment': 'ok, already revert.', 'commenter': 'walterlife'}]"
966,build.gradle,"@@ -465,8 +465,8 @@ subprojects {
             dependency ""com.github.stefanbirkner:system-rules:1.16.1""
             dependency ""org.assertj:assertj-core:2.6.0""
 
-            dependency ""org.mockito:mockito-core:2.23.0""
-            dependency ""org.mockito:mockito-inline:3.6.28""
+            dependency ""org.mockito:mockito-core:3.8.0""
+            dependency ""org.mockito:mockito-inline:3.8.0""","[{'comment': 'Is there any reason we need to upgrade these version?', 'commenter': 'ruanwenjun'}, {'comment': 'In some unit-test scenarios, mock static methods are required, and this feature, mockito-inline, was introduced in higher versions, So upgrade the corresponding version.', 'commenter': 'walterlife'}, {'comment': 'Ok, if so, we can remove the powermock.', 'commenter': 'ruanwenjun'}]"
976,docs/en/installation/01-runtime.md,"@@ -40,20 +40,21 @@ bash bin/start.sh
 
 Gradle is the build automation tool used by Apache EventMesh (Incubating). Please refer to the [offical guide](https://docs.gradle.org/current/userguide/installation.html) to install the latest release of Gradle.
 
-Download and extract the source code of the latest release (v1.4.0) from [GitHub releases](https://github.com/apache/incubator-eventmesh/releases).
+Download and extract the source code of the latest release from [EventMesh download](https://eventmesh.apache.org/download).
 
 ```console
-wget https://github.com/apache/incubator-eventmesh/archive/refs/tags/v1.4.0.tar.gz
+wget https://dlcdn.apache.org/incubator/eventmesh/1.4.0-incubating/apache-eventmesh-{version}-source.tar.gz","[{'comment': 'please change this to https://dlcdn.apache.org/incubator/eventmesh/{version}-incubating/apache-eventmesh-{version}-incubating-source.tar.gz', 'commenter': 'xwm1992'}, {'comment': 'Thanks for your review, done.', 'commenter': 'ruanwenjun'}]"
976,docs/en/installation/01-runtime.md,"@@ -40,20 +40,21 @@ bash bin/start.sh
 
 Gradle is the build automation tool used by Apache EventMesh (Incubating). Please refer to the [offical guide](https://docs.gradle.org/current/userguide/installation.html) to install the latest release of Gradle.
 
-Download and extract the source code of the latest release (v1.4.0) from [GitHub releases](https://github.com/apache/incubator-eventmesh/releases).
+Download and extract the source code of the latest release from [EventMesh download](https://eventmesh.apache.org/download).
 
 ```console
-wget https://github.com/apache/incubator-eventmesh/archive/refs/tags/v1.4.0.tar.gz
+wget https://dlcdn.apache.org/incubator/eventmesh/1.4.0-incubating/apache-eventmesh-{version}-source.tar.gz
 
-tar -xvzf v1.4.0.tar.gz
+tar -xvzf apache-eventmesh-{version}-source.tar.gz","[{'comment': 'change apache-eventmesh-{version}-source.tar.gz -> apache-eventmesh-{version}-incubating-source.tar.gz', 'commenter': 'xwm1992'}, {'comment': 'Done', 'commenter': 'ruanwenjun'}]"
976,docs/en/installation/01-runtime.md,"@@ -40,20 +40,21 @@ bash bin/start.sh
 
 Gradle is the build automation tool used by Apache EventMesh (Incubating). Please refer to the [offical guide](https://docs.gradle.org/current/userguide/installation.html) to install the latest release of Gradle.
 
-Download and extract the source code of the latest release (v1.4.0) from [GitHub releases](https://github.com/apache/incubator-eventmesh/releases).
+Download and extract the source code of the latest release from [EventMesh download](https://eventmesh.apache.org/download).
 
 ```console
-wget https://github.com/apache/incubator-eventmesh/archive/refs/tags/v1.4.0.tar.gz
+wget https://dlcdn.apache.org/incubator/eventmesh/1.4.0-incubating/apache-eventmesh-{version}-source.tar.gz
 
-tar -xvzf v1.4.0.tar.gz
+tar -xvzf apache-eventmesh-{version}-source.tar.gz
 ```
 
 Build the source code with Gradle.
 
 ```console
-cd incubator-eventmesh-1.4.0
-gradle clean build
+cd apache-eventmesh-{version}-source","[{'comment': 'change apache-eventmesh-{version}-source -> apache-eventmesh-{version}-incubating-source', 'commenter': 'xwm1992'}, {'comment': 'Done', 'commenter': 'ruanwenjun'}]"
990,eventmesh-runtime/src/main/java/org/apache/eventmesh/runtime/boot/EventMeshStartup.java,"@@ -35,6 +36,7 @@ public static void main(String[] args) throws Exception {
             ConfigurationWrapper configurationWrapper =
                     new ConfigurationWrapper(EventMeshConstants.EVENTMESH_CONF_HOME,
                             EventMeshConstants.EVENTMESH_CONF_FILE, false);
+            ConfigurationContextUtil.setBaseConfigurationWrapper(configurationWrapper);","[{'comment': 'Sorry, I am confused why you want to add this line. Could you please not modify eventmesh-runtime? Generally, eventmesh-runtime is not encouraged to be changed.', 'commenter': 'kirinzhu'}, {'comment': 'Please refer to what eventmesh-connector-rocketmq looks like, so that we could merge your branch into master branch in the further future.', 'commenter': 'kirinzhu'}, {'comment': '> Sorry, I am confused why you want to add this line. Could you please not modify eventmesh-runtime? Generally, eventmesh-runtime is not encouraged to be changed.\r\n\r\nBecause we use the configuration center for unified management of configuration information, we hope to have a unified configuration reference, instead of piecemeal configuration like eventmesh-connector-rocketmq. It is really hard to understand from the perspective of redis-connector.  Therefore, I will remove this part of the function first, and then raise an issue to solve the configuration problem.', 'commenter': 'mytang0'}]"
1027,eventmesh-connector-plugin/eventmesh-connector-knative/src/main/java/org/apache/eventmesh/connector/knative/producer/KnativeProducerImpl.java,"@@ -0,0 +1,85 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.eventmesh.connector.knative.producer;
+
+import io.cloudevents.CloudEvent;
+import org.apache.eventmesh.api.RequestReplyCallback;
+import org.apache.eventmesh.api.SendCallback;
+import org.apache.eventmesh.api.producer.Producer;
+
+import java.util.Properties;
+
+public class KnativeProducerImpl implements Producer {
+
+    private ProducerImpl producer;
+
+    @Override
+    public void init(Properties properties) throws Exception {
+        producer = new ProducerImpl(properties);
+    }
+
+    @Override
+    public boolean isStarted() {
+        return producer.isStarted();
+    }
+
+    @Override
+    public boolean isClosed() {
+        return producer.isClosed();
+    }
+
+    @Override
+    public void sendOneway(CloudEvent cloudEvent) {","[{'comment': 'Please not implement this method, you should impelement the `publish` method with the send call back.', 'commenter': 'xwm1992'}, {'comment': 'Thanks for your comments. I will change to the ```publish``` method instead.', 'commenter': 'pchengma'}, {'comment': 'Implemented ```publish``` method with SendCallback.', 'commenter': 'pchengma'}]"
1027,eventmesh-connector-plugin/eventmesh-connector-knative/src/main/java/org/apache/eventmesh/connector/knative/producer/AbstractProducer.java,"@@ -0,0 +1,60 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.eventmesh.connector.knative.producer;
+
+import org.apache.eventmesh.connector.knative.cloudevent.impl.KnativeHeaders;
+
+import java.io.IOException;
+import java.net.HttpURLConnection;
+import java.net.URL;
+import java.util.Properties;
+import java.util.concurrent.atomic.AtomicBoolean;
+
+public abstract class AbstractProducer {
+
+    final Properties properties;
+    HttpURLConnection httpUrlConnection;
+    protected final AtomicBoolean started = new AtomicBoolean(false);
+
+    AbstractProducer(final Properties properties) throws IOException {
+        this.properties = properties;
+        URL url = new URL(properties.getProperty(""url""));
+        this.httpUrlConnection = (HttpURLConnection) url.openConnection();
+        httpUrlConnection.setDoOutput(true);
+        httpUrlConnection.setDoInput(true);
+
+        // Set HTTP header for CloudEvent:
+        this.httpUrlConnection.setRequestProperty(KnativeHeaders.CONTENT_TYPE, properties.getProperty(KnativeHeaders.CONTENT_TYPE));
+        this.httpUrlConnection.setRequestProperty(KnativeHeaders.CE_ID, properties.getProperty(KnativeHeaders.CE_ID));
+        this.httpUrlConnection.setRequestProperty(KnativeHeaders.CE_SPECVERSION, properties.getProperty(KnativeHeaders.CE_SPECVERSION));
+        this.httpUrlConnection.setRequestProperty(KnativeHeaders.CE_TYPE, properties.getProperty(KnativeHeaders.CE_TYPE));
+        this.httpUrlConnection.setRequestProperty(KnativeHeaders.CE_SOURCE, properties.getProperty(KnativeHeaders.CE_SOURCE));","[{'comment': 'These code for HTTP header attributes with the request, I recommend that you can write them when you `send the cloud events not when you init the `producer`. ', 'commenter': 'xwm1992'}, {'comment': 'Thanks for your comments. I will move this part out of the ```init``` period.', 'commenter': 'pchengma'}, {'comment': 'Moved HTTP header setting into ```send``` method.', 'commenter': 'pchengma'}]"
1027,eventmesh-connector-plugin/eventmesh-connector-knative/src/main/java/org/apache/eventmesh/connector/knative/producer/ProducerImpl.java,"@@ -0,0 +1,61 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.eventmesh.connector.knative.producer;
+
+import io.cloudevents.CloudEvent;
+import org.apache.eventmesh.connector.knative.cloudevent.KnativeMessageFactory;
+
+import java.io.BufferedReader;
+import java.io.IOException;
+import java.io.InputStreamReader;
+import java.nio.charset.StandardCharsets;
+import java.util.Properties;
+
+public class ProducerImpl extends AbstractProducer {
+
+    public ProducerImpl(final Properties properties) throws IOException {
+        super(properties);
+    }
+
+    public Properties attributes() {
+        return properties;
+    }
+
+    public void sendOneway(CloudEvent cloudEvent) {
+        // Get CloudEvent data:
+        try {
+            String data = KnativeMessageFactory.createReader(cloudEvent);
+            super.getHttpUrlConnection().getOutputStream().write(data.getBytes(StandardCharsets.UTF_8));
+
+            // Send CloudEvent message:
+            String s = """";
+            int code = super.getHttpUrlConnection().getResponseCode();
+            if (code == 200) {
+                BufferedReader reader = new BufferedReader(
+                        new InputStreamReader(super.getHttpUrlConnection().getInputStream()));
+                String line;
+                while ((line = reader.readLine()) != null) {
+                    s += line + ""\n"";
+                }
+                reader.close();
+            }
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+}","[{'comment': ""You don't need to have this method, and when you implement the publish method with the callback, you can use the `Async Http Client`, here don't implement synchronously."", 'commenter': 'xwm1992'}, {'comment': 'Thanks for your comments. I will change to the asynchronous way to call the ```publish``` method.', 'commenter': 'pchengma'}, {'comment': '- Implemented ```sendAsync``` method by using AsyncHttpClient.\r\n- Added a simple exception checker method ```checkProducerException``` and a utility method ```convertSendResult``` to help implement methods with SendCallback.\r\n- Added AsyncHttpClient dependency to build.gradle file.', 'commenter': 'pchengma'}]"
1027,eventmesh-connector-plugin/eventmesh-connector-knative/src/main/java/org/apache/eventmesh/connector/knative/cloudevent/impl/KnativeMessageWriter.java,"@@ -0,0 +1,72 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.eventmesh.connector.knative.cloudevent.impl;
+
+import io.cloudevents.CloudEvent;
+import io.cloudevents.CloudEventData;
+import io.cloudevents.SpecVersion;
+import io.cloudevents.core.v1.CloudEventBuilder;
+import io.cloudevents.core.format.EventFormat;
+import io.cloudevents.core.message.MessageWriter;
+import io.cloudevents.rw.CloudEventContextWriter;
+import io.cloudevents.rw.CloudEventRWException;
+import io.cloudevents.rw.CloudEventWriter;
+
+import java.net.URI;
+import java.nio.charset.StandardCharsets;
+
+public class KnativeMessageWriter implements MessageWriter<CloudEventWriter<String>, String>, CloudEventWriter<String> {
+
+    public CloudEvent message;
+
+    public KnativeMessageWriter(String data) {
+        String s = ""{ \""msg\"": [\"""" + data + ""\""]}"";
+        this.message = new CloudEventBuilder()
+                .withId(""my-id"")
+                .withSource(URI.create(""/myClient""))
+                .withType(""dev.knative.cronjob.event"")
+                .withDataContentType(""application/json"")
+                .withData(s.getBytes(StandardCharsets.UTF_8))
+                .build();
+    }","[{'comment': 'These codes look strange, you use the cloudeventbuilder to build the cloud events, but you only want to put the data, other attributes are useless.', 'commenter': 'xwm1992'}, {'comment': 'Thanks for your comments. I will remove the unnecessary attributes.', 'commenter': 'pchengma'}, {'comment': 'Removed unnecessary attributes in ```KnativeMessageWriter```.', 'commenter': 'pchengma'}]"
1135,eventmesh-runtime/src/main/java/org/apache/eventmesh/runtime/admin/response/GetMetricsResponse.java,"@@ -0,0 +1,160 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.eventmesh.runtime.admin.response;
+
+import com.fasterxml.jackson.annotation.JsonCreator;
+import com.fasterxml.jackson.annotation.JsonProperty;
+
+
+public class GetMetricsResponse {
+    //HTTP Metrics","[{'comment': '```suggestion\r\n    // HTTP Metrics\r\n```', 'commenter': 'xiaoyang-sde'}]"
1135,eventmesh-runtime/src/main/java/org/apache/eventmesh/runtime/admin/response/GetMetricsResponse.java,"@@ -0,0 +1,160 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.eventmesh.runtime.admin.response;
+
+import com.fasterxml.jackson.annotation.JsonCreator;
+import com.fasterxml.jackson.annotation.JsonProperty;
+
+
+public class GetMetricsResponse {
+    //HTTP Metrics
+    public float maxHTTPTPS;
+    public float avgHTTPTPS;
+    public long maxHTTPCost;
+    public float avgHTTPCost;
+    public float avgHTTPBodyDecodeCost;
+    public long httpDiscard;
+    public float maxBatchSendMsgTPS;
+    public float avgBatchSendMsgTPS;
+    public long sendBatchMsgNumSum;
+    public long sendBatchMsgFailNumSum;
+    public float sendBatchMsgFailRate;
+    public long sendBatchMsgDiscardNumSum;
+    public float maxSendMsgTPS;
+    public float avgSendMsgTPS;
+    public long sendMsgNumSum;
+    public long sendMsgFailNumSum;
+    public float sendMsgFailRate;
+    public long replyMsgNumSum;
+    public long replyMsgFailNumSum;
+    public float maxPushMsgTPS;
+    public float avgPushMsgTPS;
+    public long pushHTTPMsgNumSum;
+    public long pushHTTPMsgFailNumSum;
+    public float pushHTTPMsgFailRate;
+    public float maxHTTPPushLatency;
+    public float avgHTTPPushLatency;
+    public int batchMsgQueueSize;
+    public int sendMsgQueueSize;
+    public int pushMsgQueueSize;
+    public int retryHTTPQueueSize;
+    public float avgBatchSendMsgCost;
+    public float avgSendMsgCost;
+    public float avgReplyMsgCost;
+
+    //TCP Metrics","[{'comment': '```suggestion\r\n    // TCP Metrics\r\n```', 'commenter': 'xiaoyang-sde'}]"
1135,eventmesh-runtime/src/main/java/org/apache/eventmesh/runtime/admin/response/GetMetricsResponse.java,"@@ -0,0 +1,160 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.eventmesh.runtime.admin.response;
+
+import com.fasterxml.jackson.annotation.JsonCreator;
+import com.fasterxml.jackson.annotation.JsonProperty;
+
+
+public class GetMetricsResponse {
+    //HTTP Metrics
+    public float maxHTTPTPS;
+    public float avgHTTPTPS;
+    public long maxHTTPCost;
+    public float avgHTTPCost;
+    public float avgHTTPBodyDecodeCost;
+    public long httpDiscard;
+    public float maxBatchSendMsgTPS;
+    public float avgBatchSendMsgTPS;
+    public long sendBatchMsgNumSum;
+    public long sendBatchMsgFailNumSum;
+    public float sendBatchMsgFailRate;
+    public long sendBatchMsgDiscardNumSum;
+    public float maxSendMsgTPS;
+    public float avgSendMsgTPS;
+    public long sendMsgNumSum;
+    public long sendMsgFailNumSum;
+    public float sendMsgFailRate;
+    public long replyMsgNumSum;
+    public long replyMsgFailNumSum;
+    public float maxPushMsgTPS;
+    public float avgPushMsgTPS;
+    public long pushHTTPMsgNumSum;
+    public long pushHTTPMsgFailNumSum;
+    public float pushHTTPMsgFailRate;
+    public float maxHTTPPushLatency;
+    public float avgHTTPPushLatency;
+    public int batchMsgQueueSize;
+    public int sendMsgQueueSize;
+    public int pushMsgQueueSize;
+    public int retryHTTPQueueSize;
+    public float avgBatchSendMsgCost;
+    public float avgSendMsgCost;
+    public float avgReplyMsgCost;
+
+    //TCP Metrics
+    public int retryTCPQueueSize;
+    public int client2eventMeshTCPTPS;
+    public int eventMesh2mqTCPTPS;
+    public int mq2eventMeshTCPTPS;
+    public int eventMesh2clientTCPTPS;
+    public int allTCPTPS;
+    public int allTCPConnections;
+    public int subTopicTCPNum;
+
+
+    @JsonCreator
+    public GetMetricsResponse(
+            //HTTP Metrics","[{'comment': '```suggestion\r\n            // HTTP Metrics\r\n```', 'commenter': 'xiaoyang-sde'}]"
1135,eventmesh-runtime/src/main/java/org/apache/eventmesh/runtime/admin/response/GetMetricsResponse.java,"@@ -0,0 +1,160 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.eventmesh.runtime.admin.response;
+
+import com.fasterxml.jackson.annotation.JsonCreator;
+import com.fasterxml.jackson.annotation.JsonProperty;
+
+
+public class GetMetricsResponse {
+    //HTTP Metrics
+    public float maxHTTPTPS;
+    public float avgHTTPTPS;
+    public long maxHTTPCost;
+    public float avgHTTPCost;
+    public float avgHTTPBodyDecodeCost;
+    public long httpDiscard;
+    public float maxBatchSendMsgTPS;
+    public float avgBatchSendMsgTPS;
+    public long sendBatchMsgNumSum;
+    public long sendBatchMsgFailNumSum;
+    public float sendBatchMsgFailRate;
+    public long sendBatchMsgDiscardNumSum;
+    public float maxSendMsgTPS;
+    public float avgSendMsgTPS;
+    public long sendMsgNumSum;
+    public long sendMsgFailNumSum;
+    public float sendMsgFailRate;
+    public long replyMsgNumSum;
+    public long replyMsgFailNumSum;
+    public float maxPushMsgTPS;
+    public float avgPushMsgTPS;
+    public long pushHTTPMsgNumSum;
+    public long pushHTTPMsgFailNumSum;
+    public float pushHTTPMsgFailRate;
+    public float maxHTTPPushLatency;
+    public float avgHTTPPushLatency;
+    public int batchMsgQueueSize;
+    public int sendMsgQueueSize;
+    public int pushMsgQueueSize;
+    public int retryHTTPQueueSize;
+    public float avgBatchSendMsgCost;
+    public float avgSendMsgCost;
+    public float avgReplyMsgCost;
+
+    //TCP Metrics
+    public int retryTCPQueueSize;
+    public int client2eventMeshTCPTPS;
+    public int eventMesh2mqTCPTPS;
+    public int mq2eventMeshTCPTPS;
+    public int eventMesh2clientTCPTPS;
+    public int allTCPTPS;
+    public int allTCPConnections;
+    public int subTopicTCPNum;
+
+
+    @JsonCreator
+    public GetMetricsResponse(
+            //HTTP Metrics
+            @JsonProperty(""maxHTTPTPS"") float maxHTTPTPS,
+            @JsonProperty(""avgHTTPTPS"") float avgHTTPTPS,
+            @JsonProperty(""maxHTTPCost"") long maxHTTPCost,
+            @JsonProperty(""avgHTTPCost"") float avgHTTPCost,
+            @JsonProperty(""avgHTTPBodyDecodeCost"") float avgHTTPBodyDecodeCost,
+            @JsonProperty(""httpDiscard"") long httpDiscard,
+            @JsonProperty(""maxBatchSendMsgTPS"") float maxBatchSendMsgTPS,
+            @JsonProperty(""avgBatchSendMsgTPS"") float avgBatchSendMsgTPS,
+            @JsonProperty(""sendBatchMsgNumSum"") long sendBatchMsgNumSum,
+            @JsonProperty(""sendBatchMsgFailNumSum"") long sendBatchMsgFailNumSum,
+            @JsonProperty(""sendBatchMsgFailRate"") float sendBatchMsgFailRate,
+            @JsonProperty(""sendBatchMsgDiscardNumSum"") long sendBatchMsgDiscardNumSum,
+            @JsonProperty(""maxSendMsgTPS"") float maxSendMsgTPS,
+            @JsonProperty(""avgSendMsgTPS"") float avgSendMsgTPS,
+            @JsonProperty(""sendMsgNumSum"") long sendMsgNumSum,
+            @JsonProperty(""sendMsgFailNumSum"") long sendMsgFailNumSum,
+            @JsonProperty(""sendMsgFailRate"") float sendMsgFailRate,
+            @JsonProperty(""replyMsgNumSum"") long replyMsgNumSum,
+            @JsonProperty(""replyMsgFailNumSum"") long replyMsgFailNumSum,
+            @JsonProperty(""maxPushMsgTPS"") float maxPushMsgTPS,
+            @JsonProperty(""avgPushMsgTPS"") float avgPushMsgTPS,
+            @JsonProperty(""pushHTTPMsgNumSum"") long pushHTTPMsgNumSum,
+            @JsonProperty(""pushHTTPMsgFailNumSum"") long pushHTTPMsgFailNumSum,
+            @JsonProperty(""pushHTTPMsgFailRate"") float pushHTTPMsgFailRate,
+            @JsonProperty(""maxHTTPPushLatency"") float maxHTTPPushLatency,
+            @JsonProperty(""avgHTTPPushLatency"") float avgHTTPPushLatency,
+            @JsonProperty(""batchMsgQueueSize"") int batchMsgQueueSize,
+            @JsonProperty(""sendMsgQueueSize"") int sendMsgQueueSize,
+            @JsonProperty(""pushMsgQueueSize"") int pushMsgQueueSize,
+            @JsonProperty(""retryHTTPQueueSize"") int retryHTTPQueueSize,
+            @JsonProperty(""avgBatchSendMsgCost"") float avgBatchSendMsgCost,
+            @JsonProperty(""avgSendMsgCost"") float avgSendMsgCost,
+            @JsonProperty(""avgReplyMsgCost"") float avgReplyMsgCost,
+            //TCP Metrics","[{'comment': '```suggestion\r\n            // TCP Metrics\r\n```', 'commenter': 'xiaoyang-sde'}]"
1135,eventmesh-dashboard/pages/index.tsx,"@@ -29,7 +30,8 @@ const Index: NextPage = () => (
     </Head>
     <Endpoint />
     <Configuration />
+    <Metrics />
   </>
 );
 
-export default Index;
+export default Index;","[{'comment': 'Please add a new line at the end of the file', 'commenter': 'xiaoyang-sde'}]"
1135,eventmesh-dashboard/components/index/Metrics.tsx,"@@ -0,0 +1,298 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+import {
+  Text,
+  Table,
+  TableContainer,
+  Tbody,
+  Th,
+  Thead,
+  Tr,
+  Td,
+  Box,
+} from '@chakra-ui/react';
+import axios from 'axios';
+import React, { useContext, useEffect, useState } from 'react';
+import { AppContext } from '../../context/context';
+
+interface EventMeshMetrics {
+    maxHTTPTPS: number,
+    avgHTTPTPS: number,
+    maxHTTPCost: number,
+    avgHTTPCost: number,
+    avgHTTPBodyDecodeCost: number,
+    httpDiscard: number,
+    maxBatchSendMsgTPS: number,
+    avgBatchSendMsgTPS: number,
+    sendBatchMsgNumSum: number,
+    sendBatchMsgFailNumSum: number,
+    sendBatchMsgFailRate: number,
+    sendBatchMsgDiscardNumSum: number,
+    maxSendMsgTPS: number,
+    avgSendMsgTPS: number,
+    sendMsgNumSum: number,
+    sendMsgFailNumSum: number,
+    sendMsgFailRate: number,
+    replyMsgNumSum: number,
+    replyMsgFailNumSum: number,
+    maxPushMsgTPS: number,
+    avgPushMsgTPS: number,
+    pushHTTPMsgNumSum: number,
+    pushHTTPMsgFailNumSum: number,
+    pushHTTPMsgFailRate: number,
+    maxHTTPPushLatency : number,
+    avgHTTPPushLatency : number,
+    batchMsgQueueSize : number,
+    sendMsgQueueSize  : number,
+    pushMsgQueueSize : number,
+    retryHTTPQueueSize : number,
+    avgBatchSendMsgCost : number,
+    avgSendMsgCost : number,
+    avgReplyMsgCost : number,
+
+  //TCP Metrics
+    retryTCPQueueSize: number,
+    client2eventMeshTCPTPS : number,
+    eventMesh2mqTCPTPS : number,
+    mq2eventMeshTCPTPS : number,
+    eventMesh2clientTCPTPS : number,
+    allTCPTPS : number,
+    allTCPConnections : number,
+    subTopicTCPNum : number
+}
+
+const Metrics = () => {
+  const { state } = useContext(AppContext);
+  const [configuration, setConfiguration] = useState<Partial<EventMeshMetrics>>({});
+
+  useEffect(() => {
+    const fetch = async () => {
+      try {
+        const { data } = await axios.get<EventMeshMetrics>(`${state.endpoint}/metrics`);
+        setConfiguration(data);
+      } catch (error) {
+        setConfiguration({});
+      }
+    };
+
+    fetch();
+  }, []);
+
+  type MetricRecord = Record<string, string | number | boolean | undefined>;","[{'comment': 'I think `string` and `boolean` are never used in this `Record` type?', 'commenter': 'xiaoyang-sde'}]"
1135,eventmesh-dashboard/components/index/Metrics.tsx,"@@ -0,0 +1,298 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+import {
+  Text,
+  Table,
+  TableContainer,
+  Tbody,
+  Th,
+  Thead,
+  Tr,
+  Td,
+  Box,
+} from '@chakra-ui/react';
+import axios from 'axios';
+import React, { useContext, useEffect, useState } from 'react';
+import { AppContext } from '../../context/context';
+
+interface EventMeshMetrics {
+    maxHTTPTPS: number,
+    avgHTTPTPS: number,
+    maxHTTPCost: number,
+    avgHTTPCost: number,
+    avgHTTPBodyDecodeCost: number,
+    httpDiscard: number,
+    maxBatchSendMsgTPS: number,
+    avgBatchSendMsgTPS: number,
+    sendBatchMsgNumSum: number,
+    sendBatchMsgFailNumSum: number,
+    sendBatchMsgFailRate: number,
+    sendBatchMsgDiscardNumSum: number,
+    maxSendMsgTPS: number,
+    avgSendMsgTPS: number,
+    sendMsgNumSum: number,
+    sendMsgFailNumSum: number,
+    sendMsgFailRate: number,
+    replyMsgNumSum: number,
+    replyMsgFailNumSum: number,
+    maxPushMsgTPS: number,
+    avgPushMsgTPS: number,
+    pushHTTPMsgNumSum: number,
+    pushHTTPMsgFailNumSum: number,
+    pushHTTPMsgFailRate: number,
+    maxHTTPPushLatency : number,
+    avgHTTPPushLatency : number,
+    batchMsgQueueSize : number,
+    sendMsgQueueSize  : number,
+    pushMsgQueueSize : number,
+    retryHTTPQueueSize : number,
+    avgBatchSendMsgCost : number,
+    avgSendMsgCost : number,
+    avgReplyMsgCost : number,
+
+  //TCP Metrics","[{'comment': '```suggestion\r\n   // TCP Metrics\r\n```', 'commenter': 'xiaoyang-sde'}]"
1135,eventmesh-dashboard/components/index/Metrics.tsx,"@@ -0,0 +1,298 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+import {
+  Text,
+  Table,
+  TableContainer,
+  Tbody,
+  Th,
+  Thead,
+  Tr,
+  Td,
+  Box,
+} from '@chakra-ui/react';
+import axios from 'axios';
+import React, { useContext, useEffect, useState } from 'react';
+import { AppContext } from '../../context/context';
+
+interface EventMeshMetrics {
+    maxHTTPTPS: number,
+    avgHTTPTPS: number,
+    maxHTTPCost: number,
+    avgHTTPCost: number,
+    avgHTTPBodyDecodeCost: number,
+    httpDiscard: number,
+    maxBatchSendMsgTPS: number,
+    avgBatchSendMsgTPS: number,
+    sendBatchMsgNumSum: number,
+    sendBatchMsgFailNumSum: number,
+    sendBatchMsgFailRate: number,
+    sendBatchMsgDiscardNumSum: number,
+    maxSendMsgTPS: number,
+    avgSendMsgTPS: number,
+    sendMsgNumSum: number,
+    sendMsgFailNumSum: number,
+    sendMsgFailRate: number,
+    replyMsgNumSum: number,
+    replyMsgFailNumSum: number,
+    maxPushMsgTPS: number,
+    avgPushMsgTPS: number,
+    pushHTTPMsgNumSum: number,
+    pushHTTPMsgFailNumSum: number,
+    pushHTTPMsgFailRate: number,
+    maxHTTPPushLatency : number,
+    avgHTTPPushLatency : number,
+    batchMsgQueueSize : number,
+    sendMsgQueueSize  : number,
+    pushMsgQueueSize : number,
+    retryHTTPQueueSize : number,
+    avgBatchSendMsgCost : number,
+    avgSendMsgCost : number,
+    avgReplyMsgCost : number,
+
+  //TCP Metrics
+    retryTCPQueueSize: number,
+    client2eventMeshTCPTPS : number,
+    eventMesh2mqTCPTPS : number,
+    mq2eventMeshTCPTPS : number,
+    eventMesh2clientTCPTPS : number,
+    allTCPTPS : number,
+    allTCPConnections : number,
+    subTopicTCPNum : number
+}
+
+const Metrics = () => {
+  const { state } = useContext(AppContext);
+  const [configuration, setConfiguration] = useState<Partial<EventMeshMetrics>>({});","[{'comment': 'I think `metrics` and `setMetrics` might be a better name?', 'commenter': 'xiaoyang-sde'}]"
1135,eventmesh-dashboard/components/index/Metrics.tsx,"@@ -0,0 +1,298 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * ""License""); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+import {
+  Text,
+  Table,
+  TableContainer,
+  Tbody,
+  Th,
+  Thead,
+  Tr,
+  Td,
+  Box,
+} from '@chakra-ui/react';
+import axios from 'axios';
+import React, { useContext, useEffect, useState } from 'react';
+import { AppContext } from '../../context/context';
+
+interface EventMeshMetrics {
+    maxHTTPTPS: number,
+    avgHTTPTPS: number,
+    maxHTTPCost: number,
+    avgHTTPCost: number,
+    avgHTTPBodyDecodeCost: number,
+    httpDiscard: number,
+    maxBatchSendMsgTPS: number,
+    avgBatchSendMsgTPS: number,
+    sendBatchMsgNumSum: number,
+    sendBatchMsgFailNumSum: number,
+    sendBatchMsgFailRate: number,
+    sendBatchMsgDiscardNumSum: number,
+    maxSendMsgTPS: number,
+    avgSendMsgTPS: number,
+    sendMsgNumSum: number,
+    sendMsgFailNumSum: number,
+    sendMsgFailRate: number,
+    replyMsgNumSum: number,
+    replyMsgFailNumSum: number,
+    maxPushMsgTPS: number,
+    avgPushMsgTPS: number,
+    pushHTTPMsgNumSum: number,
+    pushHTTPMsgFailNumSum: number,
+    pushHTTPMsgFailRate: number,
+    maxHTTPPushLatency : number,
+    avgHTTPPushLatency : number,
+    batchMsgQueueSize : number,
+    sendMsgQueueSize  : number,
+    pushMsgQueueSize : number,
+    retryHTTPQueueSize : number,
+    avgBatchSendMsgCost : number,
+    avgSendMsgCost : number,
+    avgReplyMsgCost : number,
+
+  //TCP Metrics
+    retryTCPQueueSize: number,
+    client2eventMeshTCPTPS : number,
+    eventMesh2mqTCPTPS : number,
+    mq2eventMeshTCPTPS : number,
+    eventMesh2clientTCPTPS : number,
+    allTCPTPS : number,
+    allTCPConnections : number,
+    subTopicTCPNum : number
+}
+
+const Metrics = () => {
+  const { state } = useContext(AppContext);
+  const [configuration, setConfiguration] = useState<Partial<EventMeshMetrics>>({});
+
+  useEffect(() => {
+    const fetch = async () => {
+      try {
+        const { data } = await axios.get<EventMeshMetrics>(`${state.endpoint}/metrics`);
+        setConfiguration(data);
+      } catch (error) {
+        setConfiguration({});
+      }
+    };
+
+    fetch();
+  }, []);
+
+  type MetricRecord = Record<string, string | number | boolean | undefined>;
+  const httpMetrics: MetricRecord = {
+    'Max HTTP TPS': configuration.maxHTTPTPS,
+    'Avg HTTP TPS': configuration.avgHTTPTPS,
+    'Max HTTP Cost': configuration.maxHTTPCost,
+    'Avg HTTP Cost': configuration.avgHTTPCost,
+    'Avg HTTP Body Decode Cost': configuration.avgHTTPBodyDecodeCost,
+    'HTTP Discard': configuration.httpDiscard,
+  };
+  const batchMetrics: MetricRecord = {
+    'Max Batch Send Msg TPS': configuration.maxBatchSendMsgTPS,
+    'Avg Batch Send Msg TPS': configuration.avgBatchSendMsgTPS,
+    'Send Batch Msg Num Sum': configuration.sendBatchMsgNumSum,
+    'Send Batch Msg Fail Num Sum': configuration.sendBatchMsgFailNumSum,
+    'Send Batch Msg Fail Rate': configuration.sendBatchMsgFailRate,
+    'Send Batch Msg Discard Num Sum': configuration.sendBatchMsgDiscardNumSum,
+  };
+  const sendMetrics: MetricRecord = {
+    'Max Send Msg TPS': configuration.maxSendMsgTPS,
+    'Avg Send Msg TPS': configuration.avgSendMsgTPS,
+    'Send Msg Num Sum': configuration.sendMsgNumSum,
+    'Send Msg Fail Num Sum': configuration.sendMsgFailNumSum,
+    'Send Msg Fail Rate': configuration.sendMsgFailRate,
+    'Reply Msg Num Sum': configuration.replyMsgNumSum,
+    'Reply Msg Fail Num Sum': configuration.replyMsgFailNumSum,
+  };
+  const pushMetrics: MetricRecord = {
+    'Max Push Msg TPS': configuration.maxPushMsgTPS,
+    'Avg Push Msg TPS': configuration.avgPushMsgTPS,
+    'Push HTTP Msg Num Sum': configuration.pushHTTPMsgNumSum,
+    'Push HTTP Msg Fail Num Sum': configuration.pushHTTPMsgFailNumSum,
+    'Push HTTP Msg Fail Rate': configuration.pushHTTPMsgFailRate,
+    'Max HTTP Push Latency': configuration.maxHTTPPushLatency,
+    'Avg HTTP Push Latency': configuration.avgHTTPPushLatency,
+  };
+  const tcpMetrics: MetricRecord = {
+    'Retry TCP Queue Size': configuration.retryTCPQueueSize,
+    'Client2eventMesh TCP TPS': configuration.client2eventMeshTCPTPS,
+    'EventMesh2mq TCP TPS': configuration.eventMesh2mqTCPTPS,
+    'MQ2eventMesh TCP TPS': configuration.mq2eventMeshTCPTPS,
+    'EventMesh2client TCP TPS': configuration.eventMesh2clientTCPTPS,
+    'All TCP TPS': configuration.allTCPTPS,
+    'All TCP Connections': configuration.allTCPConnections,
+    'Sub Topic TCP Num': configuration.subTopicTCPNum,
+  };
+
+  const convertConfigurationToTable = (
+    metricRecord: Record<string, string | number | boolean | undefined>,
+  ) => Object.entries(metricRecord).map(([key, value]) => {
+    if (value === undefined) {
+      return (
+        <Tr>
+          <Td>{key}</Td>
+          <Td>Undefined</Td>
+        </Tr>
+      );
+    }
+
+    return (
+      <Tr>
+        <Td>{key}</Td>
+        <Td>{value.toString()}</Td>
+      </Tr>
+    );
+  });
+
+  if (Object.keys(configuration).length === 0) {
+    return false;
+  }
+
+  return (
+    <>
+      <Box
+        maxW=""full""
+        bg=""white""
+        borderWidth=""1px""
+        borderRadius=""md""
+        overflow=""hidden""
+        p=""4""
+        mt=""4""
+      >
+        <Text
+          w=""full""
+        >
+          EventMesh HTTP Metrics
+        </Text>
+
+        <TableContainer mt=""4"">
+          <Table variant=""simple"">
+            <Thead>
+              <Tr>
+                <Th>Metric</Th>
+                <Th>Value</Th>
+              </Tr>
+            </Thead>
+            <Tbody>
+              {convertConfigurationToTable(httpMetrics)}
+            </Tbody>
+          </Table>
+        </TableContainer>
+
+        <Text
+          w=""full""
+          mt=""4""
+        >
+          HTTP Batch Metrics
+        </Text>
+
+        <TableContainer mt=""4"">
+          <Table variant=""simple"">
+            <Thead>
+              <Tr>
+                <Th>Metric</Th>
+                <Th>Value</Th>
+              </Tr>
+            </Thead>
+            <Tbody>
+              {convertConfigurationToTable(batchMetrics)}
+            </Tbody>
+          </Table>
+        </TableContainer>
+
+        <Text
+          w=""full""
+          mt=""4""
+        >
+          HTTP Send Metrics
+        </Text>
+
+        <TableContainer mt=""4"">
+          <Table variant=""simple"">
+            <Thead>
+              <Tr>
+                <Th>Configuration Field</Th>","[{'comment': 'Metric Field?', 'commenter': 'xiaoyang-sde'}]"
1882,eventmesh-connector-plugin/eventmesh-connector-kafka/src/main/java/org/apache/eventmesh/connector/kafka/config/ConfigurationWrapper.java,"@@ -34,10 +34,13 @@
 import lombok.experimental.UtilityClass;
 import lombok.extern.slf4j.Slf4j;
 
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
 @Slf4j
 @UtilityClass
 public class ConfigurationWrapper {
-
+    public Logger logger = LoggerFactory.getLogger(ConfigurationWrapper.class);","[{'comment': 'please add static final', 'commenter': 'xwm1992'}, {'comment': 'Have added the modifiers', 'commenter': 'krittysv'}]"
1883,eventmesh-connector-plugin/eventmesh-connector-kafka/src/main/java/org/apache/eventmesh/connector/kafka/consumer/ConsumerImpl.java,"@@ -38,7 +38,12 @@
 import io.cloudevents.CloudEvent;
 import io.cloudevents.kafka.CloudEventDeserializer;
 
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
 public class ConsumerImpl {
+    public Logger logger = LoggerFactory.getLogger(ConsumerImpl.class);","[{'comment': 'please add static final', 'commenter': 'xwm1992'}, {'comment': ' Have made the necessary changes.', 'commenter': 'rinuaby13'}]"
1918,eventmesh-protocol-plugin/eventmesh-protocol-http/src/main/java/org/apache/eventmesh/protocol/http/HttpProtocolAdaptor.java,"@@ -95,8 +95,11 @@ public ProtocolTransportObject fromCloudEvent(CloudEvent cloudEvent) throws Prot
         }
         httpEventWrapper.setSysHeaderMap(sysHeaderMap);
         // ce data
-        Map<String, Object> dataContentMap = JsonUtils.deserialize(new String(cloudEvent.getData().toBytes(), Constants.DEFAULT_CHARSET),
+        String jsonStr = new String(cloudEvent.getData().toBytes(), Constants.DEFAULT_CHARSET);","[{'comment': '`cloudEvent.getData()` may due NPE, please check this return value, note the `jsonStr`', 'commenter': 'xwm1992'}]"
1991,eventmesh-protocol-plugin/eventmesh-protocol-cloudevents/src/main/java/org/apache/eventmesh/protocol/cloudevents/resolver/http/SendMessageRequestProtocolResolver.java,"@@ -62,6 +62,10 @@ public static CloudEvent buildEvent(Header header, Body body) throws ProtocolHan
 
             CloudEvent event = null;
             if (StringUtils.equals(SpecVersion.V1.toString(), protocolVersion)) {
+                if(EventFormatProvider.getInstance() == null ||","[{'comment': 'please use `Object.requireNonNull` instead of return `null`', 'commenter': 'xwm1992'}, {'comment': 'ok.,done. please review again', 'commenter': 'skyXJJ'}]"
1991,eventmesh-protocol-plugin/eventmesh-protocol-cloudevents/src/main/java/org/apache/eventmesh/protocol/cloudevents/resolver/http/SendMessageRequestProtocolResolver.java,"@@ -81,6 +85,10 @@ public static CloudEvent buildEvent(Header header, Body body) throws ProtocolHan
                         .withExtension(SendMessageRequestBody.PRODUCERGROUP, producerGroup)
                         .build();
             } else if (StringUtils.equals(SpecVersion.V03.toString(), protocolVersion)) {
+                if(EventFormatProvider.getInstance() == null ||","[{'comment': 'same as above', 'commenter': 'xwm1992'}]"
2029,eventmesh-examples/src/main/java/org/apache/eventmesh/common/ExampleConstants.java,"@@ -51,4 +51,9 @@ public class ExampleConstants {
     public static final String EVENTMESH_SELECTOR_NACOS_ADDRESS = ""eventmesh.selector.nacos.address"";
 
     public static final String EVENTMESH_SELECTOR_TYPE = ""eventmesh.selector.type"";
+
+	public static final String env = ""P"";
+	public static final String idc = ""FT"";
+	public static final String subsys = ""1234"";
+	public static final String SERVER_PORT = ""server.port"";","[{'comment': 'please make sure that these variables are coded in a consistent style', 'commenter': 'xwm1992'}, {'comment': 'changes have been made, please review again', 'commenter': 'abinaya-u'}]"
2029,eventmesh-webhook/eventmesh-webhook-receive/src/main/java/org/apache/eventmesh/webhook/receive/protocol/GithubProtocol.java,"@@ -43,7 +43,7 @@ public class GithubProtocol implements ManufacturerProtocol {
 
     private static final String H_MAC_SHA = ""HmacSHA256"";
 
-    private static final char ZERO_CHAR = '0';
+    private static final Character ZERO_CHAR = '0';","[{'comment': 'why you change this to Character, can this code be compiled ?', 'commenter': 'xwm1992'}, {'comment': 'this change is not intentional, I reverted it back', 'commenter': 'abinaya-u'}]"
2063,eventmesh-connector-plugin/eventmesh-connector-standalone/src/main/java/org/apache/eventmesh/connector/standalone/broker/task/SubScribeTask.java,"@@ -57,8 +57,9 @@ public void run() {
                 if (offset == null) {
                     CloudEvent message = standaloneBroker.getMessage(topicName);
                     if (message != null) {
-                        if (message.getExtension(""offset"") != null) {
-                            offset = new AtomicInteger((int) message.getExtension(""offset""));
+                        Object tmpOffset = message.getExtension(""offset"");
+                        if (tmpOffset instanceof Integer) {
+                            offset = new AtomicInteger((Integer) tmpOffset);","[{'comment': 'Here please change to `new AtomicInteger(Integer.parseInt(tmpOffset.toString()))`', 'commenter': 'xwm1992'}]"
2064,eventmesh-runtime/src/main/java/org/apache/eventmesh/runtime/util/HttpResponseUtils.java,"@@ -29,37 +27,38 @@
 import io.netty.handler.codec.http.HttpResponse;
 import io.netty.handler.codec.http.HttpResponseStatus;
 import io.netty.handler.codec.http.HttpVersion;
+import org.apache.eventmesh.common.Constants;","[{'comment': ""please don't change this import order"", 'commenter': 'xwm1992'}, {'comment': 'I think it must optimize', 'commenter': 'moremind'}, {'comment': ""but this not followed our project checkstyle config, the ci check won't be succeeded."", 'commenter': 'xwm1992'}, {'comment': 'I think eventmesh need optimize or refactor some nonstandard code. ', 'commenter': 'moremind'}, {'comment': ""I'm not clearly get what you mean, why you change the package import order ?"", 'commenter': 'xwm1992'}]"
2150,eventmesh-catalog-go/internal/util/file_utils.go,"@@ -0,0 +1,27 @@
+// Licensed to the Apache Software Foundation (ASF) under one or more
+// contributor license agreements.  See the NOTICE file distributed with
+// this work for additional information regarding copyright ownership.
+// The ASF licenses this file to You under the Apache License, Version 2.0
+// (the ""License""); you may not use this file except in compliance with
+// the License.  You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an ""AS IS"" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package util
+
+import ""os""
+
+// Exists 判断所给路径文件是否存在","[{'comment': 'remove the Chinese comment please', 'commenter': 'xwm1992'}, {'comment': 'same as above', 'commenter': 'xwm1992'}]"
2168,eventmesh-connector-plugin/eventmesh-connector-redis/src/test/java/org/apache/eventmesh/connector/redis/consumer/RedisConsumerTest.java,"@@ -77,7 +77,7 @@ public void testSubscribe() throws Exception {
                 .withSubject(""topic"")
                 .withType(String.class.getCanonicalName())
                 .withDataContentType(""text/plain"")
-                .withData(""data"".getBytes())
+                .withData(""data"".getBytes(StandardCharsets.UTF_8))","[{'comment': 'You need import the package `java.nio.charset.StandardCharsets` above, under the line 24', 'commenter': 'xwm1992'}]"
2324,eventmesh-runtime/src/main/java/org/apache/eventmesh/runtime/boot/EventMeshGrpcServer.java,"@@ -262,7 +266,8 @@ private void initThreadPool() {
 
     private void initHttpClientPool() {
         httpClientPool = new LinkedList<>();
-        for (int i = 0; i < 8; i++) {
+        int clientPool = (int)(Math.random()*(MAX_LIMIT-MIN_LIMIT+1)+MIN_LIMIT);","[{'comment': 'please split the `*`, `-`, `+` with the white space', 'commenter': 'xwm1992'}, {'comment': 'updated', 'commenter': 'vinayakghatul'}]"
2324,eventmesh-runtime/src/main/java/org/apache/eventmesh/runtime/boot/EventMeshGrpcServer.java,"@@ -262,7 +266,8 @@ private void initThreadPool() {
 
     private void initHttpClientPool() {
         httpClientPool = new LinkedList<>();
-        for (int i = 0; i < 8; i++) {
+        int clientPool = (int)(Math.random() * (MAX_LIMIT - MIN_LIMIT + 1) + MIN_LIMIT);","[{'comment': '<img width=""1370"" alt=""image"" src=""https://user-images.githubusercontent.com/63457588/205059786-a0603863-b65d-4f8c-8526-5130d747ad97.png"">\r\n\r\nStill has checkStyle error in this line, maybe you can just use ```RandomUtils``` to get a random integer within that range.', 'commenter': 'horoc'}, {'comment': 'this checkSytle error for the typecast `(int)` ， need a whitespace after this', 'commenter': 'xwm1992'}]"
2324,eventmesh-runtime/src/main/java/org/apache/eventmesh/runtime/boot/EventMeshGrpcServer.java,"@@ -262,7 +266,8 @@ private void initThreadPool() {
 
     private void initHttpClientPool() {
         httpClientPool = new LinkedList<>();
-        for (int i = 0; i < 8; i++) {
+        int clientPool = (int) (RandomUtils.nextInt(MIN_LIMIT, MAX_LIMIT);","[{'comment': ""here miss the ')' at the end of the line"", 'commenter': 'xwm1992'}]"
2499,eventmesh-server-go/examples/webhook/main.go,"@@ -0,0 +1,79 @@
+// Copyright (C) @2021 Webank Group Holding Limited
+//
+// Licensed under the Apache License, Version 2.0 (the ""License""); you may not use this file except
+// in compliance with the License. You may obtain a copy of the License at
+//
+// 	http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software distributed under the License
+// is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+// or implied. See the License for the specific language governing permissions and limitations under
+// the License.
+// date: 2021/03/07 15:45
+// author: bruceliu@webank.com
+
+package main
+
+import (
+	""flag""
+	""fmt""
+	""github.com/gin-gonic/gin""
+	""io/ioutil""
+	""net/http""
+	""net/url""
+	""strings""
+)
+
+// Response indicate the http response
+type Response struct {
+	RetCode string `json:""retCode""`
+	ErrMsg  string `json:""errMsg""`
+}
+
+// OK return the success response
+func OK(data interface{}) *Response {
+	return &Response{
+		RetCode: ""0"",
+		ErrMsg:  ""OK"",
+	}
+}
+
+// Err return the error response
+func Err(err error, code string) *Response {
+	return &Response{
+		RetCode: code,
+		ErrMsg:  err.Error(),
+	}
+}
+
+// provide a webserver to handle the operator event callback
+func main() {
+	flag.Parse()
+	router := gin.Default()
+	printAndReply := func(c *gin.Context) {
+		buf, err := ioutil.ReadAll(c.Request.Body)
+		if err != nil {
+			c.JSON(http.StatusOK, Err(err, ""-1""))
+			return
+		}
+		content, err := url.QueryUnescape(string(buf))
+		if err != nil {
+			c.JSON(http.StatusOK, Err(err, ""-1""))
+			return
+		}
+		sps := strings.Split(content, ""&"")
+		for _, sp := range sps {
+			fmt.Println(sp)","[{'comment': '## Log entries created from user input\n\nThis log entry depends on a [user-provided value](1).\n\n[Show more details](https://github.com/apache/incubator-eventmesh/security/code-scanning/7)', 'commenter': 'github-advanced-security[bot]'}]"
2588,eventmesh-protocol-plugin/eventmesh-protocol-cloudevents/src/main/java/org/apache/eventmesh/protocol/cloudevents/resolver/grpc/GrpcMessageProtocolResolver.java,"@@ -155,37 +148,37 @@ public static List<CloudEvent> buildBatchEvents(BatchMessage batchMessage) {
 
             String contentType = item.getPropertiesOrDefault(ProtocolKey.CONTENT_TYPE, Constants.CONTENT_TYPE_CLOUDEVENTS_JSON);
             EventFormat eventFormat = EventFormatProvider.getInstance().resolveFormat(contentType);
-            CloudEvent event = eventFormat.deserialize(cloudEventJson.getBytes(StandardCharsets.UTF_8));
+            CloudEvent event = Objects.requireNonNull(eventFormat).deserialize(cloudEventJson.getBytes(StandardCharsets.UTF_8));
 
-            String env = StringUtils.isEmpty(header.getEnv()) ? event.getExtension(ProtocolKey.ENV).toString() : header.getEnv();
-            String idc = StringUtils.isEmpty(header.getIdc()) ? event.getExtension(ProtocolKey.IDC).toString() : header.getIdc();
-            String ip = StringUtils.isEmpty(header.getIp()) ? event.getExtension(ProtocolKey.IP).toString() : header.getIp();
-            String pid = StringUtils.isEmpty(header.getPid()) ? event.getExtension(ProtocolKey.PID).toString() : header.getPid();
-            String sys = StringUtils.isEmpty(header.getSys()) ? event.getExtension(ProtocolKey.SYS).toString() : header.getSys();
+            String env = StringUtils.isEmpty(header.getEnv()) ? getEventExtension(event, ProtocolKey.ENV) : header.getEnv();
+            String idc = StringUtils.isEmpty(header.getIdc()) ? getEventExtension(event, ProtocolKey.IDC) : header.getIdc();
+            String ip = StringUtils.isEmpty(header.getIp()) ? getEventExtension(event, ProtocolKey.IP): header.getIp();","[{'comment': 'here has a ci check error, need a white space after `(event, ProtocolKey.IP)`', 'commenter': 'xwm1992'}]"
2995,eventmesh-runtime/src/main/java/org/apache/eventmesh/runtime/core/protocol/tcp/client/group/ClientGroupWrapper.java,"@@ -486,6 +486,7 @@ public synchronized void initClientGroupPersistentConsumer() throws Exception {
                                 group, topic, bizSeqNo, sendBackTimes,
                                 sendBackFromEventMeshIp);
 
+                        sendBackTimes = Objects.requireNonNull(sendBackTimes);
                         if (sendBackTimes >= eventMeshTCPServer","[{'comment': 'you can add `Ojects.requireNoNull(sendBackTimes)` at line 490 --> `if(Ojects.requireNoNull(sendBackTimes) >= eventMeshTCPSever`', 'commenter': 'xwm1992'}]"
3046,eventmesh-runtime/src/main/java/org/apache/eventmesh/runtime/core/protocol/tcp/client/session/Session.java,"@@ -280,6 +280,16 @@ public boolean equals(Object o) {
         }
         return true;
     }
+    
+     @Override
+    public int hashCode()
+    {
+        int result = 17;   //primeNumber
+        result += 31*result + client!=null?Objects.hash(client);
+        result += 31*result + context!=null?Objects.hash(contetx);
+        result += 31*result + eventMeshTCPConfiguration!=null?Objects.hash(eventMeshTCPConfiguration);","[{'comment': ""@himansh295 These code can't be compiled please fix."", 'commenter': 'xwm1992'}]"
3046,eventmesh-runtime/src/main/java/org/apache/eventmesh/runtime/core/protocol/tcp/client/session/Session.java,"@@ -280,6 +280,16 @@ public boolean equals(Object o) {
         }
         return true;
     }
+    
+     @Override
+    public int hashCode()
+    {
+        int result = 17;                                 //primeNumber
+        result += 31*result + client!=null?Objects.hash(client) : 0;","[{'comment': 'result += 31 * result + client!=null?Objects.hash(client) : 0; -> result += 31 * result + (client!=null?Objects.hash(client) : 0);', 'commenter': 'xwm1992'}, {'comment': 'Sure @xwm1992 ', 'commenter': 'himansh295'}]"
3049,docs/zh/design-document/12-zipkin.md,"@@ -1,49 +1,27 @@
-# 通过 Zipkin 观察 Trace
-
-### 1、下载和运行Zipkin
-
-请参考https://zipkin.io/pages/quickstart.html
-
-
-
-### 2、运行eventmesh
-
-运行eventmesh-starter(参考[eventmesh-runtime-quickstart](eventmesh-runtime-quickstart.md))
-
-运行eventmesh-example(参考[eventmesh-sdk-java-quickstart](eventmesh-sdk-java-quickstart.md))
-
-
-
-### 3、相关的设置
-
-eventmesh-runtime/conf/eventmesh.properties中：
-
-默认的exporter是log，需要手动改成Zipkin
-
-```properties
-#trace exporter
-eventmesh.trace.exporter.type=Zipkin
-```
-下面是关于Zipkin的各种配置
-```properties
-#set the maximum batch size to use
-eventmesh.trace.exporter.max.export.size=512
-#set the queue size. This must be >= the export batch size
-eventmesh.trace.exporter.max.queue.size=2048
-#set the max amount of time an export can run before getting(TimeUnit=SECONDS)
-eventmesh.trace.exporter.export.timeout=30
-#set time between two different exports(TimeUnit=SECONDS)
-eventmesh.trace.exporter.export.interval=5
-
-#zipkin
-eventmesh.trace.export.zipkin.ip=localhost
-eventmesh.trace.export.zipkin.port=9411
-```
-
-以上都是相关的配置，如果你十分熟悉Zipkin的话可以自行修改。
-
-
-
-### 4、观察
-
-浏览器打开： **localhost:9411**
+使用 Zipkin 收集痕迹","[{'comment': 'please note the first level heading', 'commenter': 'xwm1992'}]"
3049,docs/zh/design-document/12-zipkin.md,"@@ -1,49 +1,27 @@
-# 通过 Zipkin 观察 Trace
-
-### 1、下载和运行Zipkin
-
-请参考https://zipkin.io/pages/quickstart.html
-
-
-
-### 2、运行eventmesh
-
-运行eventmesh-starter(参考[eventmesh-runtime-quickstart](eventmesh-runtime-quickstart.md))
-
-运行eventmesh-example(参考[eventmesh-sdk-java-quickstart](eventmesh-sdk-java-quickstart.md))
-
-
-
-### 3、相关的设置
-
-eventmesh-runtime/conf/eventmesh.properties中：
-
-默认的exporter是log，需要手动改成Zipkin
-
-```properties
-#trace exporter
-eventmesh.trace.exporter.type=Zipkin
-```
-下面是关于Zipkin的各种配置
-```properties
-#set the maximum batch size to use
-eventmesh.trace.exporter.max.export.size=512
-#set the queue size. This must be >= the export batch size
-eventmesh.trace.exporter.max.queue.size=2048
-#set the max amount of time an export can run before getting(TimeUnit=SECONDS)
-eventmesh.trace.exporter.export.timeout=30
-#set time between two different exports(TimeUnit=SECONDS)
-eventmesh.trace.exporter.export.interval=5
-
-#zipkin
-eventmesh.trace.export.zipkin.ip=localhost
-eventmesh.trace.export.zipkin.port=9411
-```
-
-以上都是相关的配置，如果你十分熟悉Zipkin的话可以自行修改。
-
-
-
-### 4、观察
-
-浏览器打开： **localhost:9411**
+使用 Zipkin 收集痕迹
+齐普金","[{'comment': 'here just use Zipkin, and second level heading', 'commenter': 'xwm1992'}]"
3049,docs/zh/design-document/12-zipkin.md,"@@ -1,49 +1,27 @@
-# 通过 Zipkin 观察 Trace
-
-### 1、下载和运行Zipkin
-
-请参考https://zipkin.io/pages/quickstart.html
-
-
-
-### 2、运行eventmesh
-
-运行eventmesh-starter(参考[eventmesh-runtime-quickstart](eventmesh-runtime-quickstart.md))
-
-运行eventmesh-example(参考[eventmesh-sdk-java-quickstart](eventmesh-sdk-java-quickstart.md))
-
-
-
-### 3、相关的设置
-
-eventmesh-runtime/conf/eventmesh.properties中：
-
-默认的exporter是log，需要手动改成Zipkin
-
-```properties
-#trace exporter
-eventmesh.trace.exporter.type=Zipkin
-```
-下面是关于Zipkin的各种配置
-```properties
-#set the maximum batch size to use
-eventmesh.trace.exporter.max.export.size=512
-#set the queue size. This must be >= the export batch size
-eventmesh.trace.exporter.max.queue.size=2048
-#set the max amount of time an export can run before getting(TimeUnit=SECONDS)
-eventmesh.trace.exporter.export.timeout=30
-#set time between two different exports(TimeUnit=SECONDS)
-eventmesh.trace.exporter.export.interval=5
-
-#zipkin
-eventmesh.trace.export.zipkin.ip=localhost
-eventmesh.trace.export.zipkin.port=9411
-```
-
-以上都是相关的配置，如果你十分熟悉Zipkin的话可以自行修改。
-
-
-
-### 4、观察
-
-浏览器打开： **localhost:9411**
+使用 Zipkin 收集痕迹
+齐普金
+分布式跟踪是一种用于分析和监控使用微服务架构构建的应用程序的方法。 分布式跟踪有助于查明发生故障的位置以及导致性能不佳的原因。
+
+Zipkin 是一种分布式跟踪系统，可帮助收集解决服务架构中的延迟问题所需的计时数据。 EventMesh 公开了可以由 Zipkin 收集和分析的跟踪数据集合。 请按照“Zipkin 快速入门”教程下载并安装最新版本的 Zipkin。
+
+配置
+要启用 EventMesh Runtime 的跟踪导出器，请将 conf/eventmesh.properties 文件中的 eventMesh.server.trace.enabled 字段设置为 true。
+
+# 跟踪插件
+eventMesh.server.trace.enabled=true
+eventMesh.trace.plugin=zipkin
+要自定义跟踪导出器的行为（例如超时或导出间隔），请编辑 exporter.properties 文件。
+
+# 设置要使用的最大批量大小
+eventmesh.trace.max.export.size=512
+# 设置队列大小。 这必须 >= 导出批量大小
+eventmesh.trace.max.queue.size=2048
+# 设置导出在获取之前可以运行的最长时间(TimeUnit=SECONDS)
+eventmesh.trace.export.timeout=30
+# 设置两次不同导出之间的时间 (TimeUnit=SECONDS)
+eventmesh.trace.export.interval=5
+要将导出的跟踪数据发送到 Zipkin，请编辑 conf/zipkin.properties 文件中的 eventmesh.trace.zipkin.ip 和 eventmesh.trace.zipkin.port 字段以匹配 Zipkin 服务器的配置。
+
+# Zipkin的IP和端口
+eventmesh.trace.zipkin.ip=localhost
+eventmesh.trace.zipkin.port=9411","[{'comment': 'these content please under the code format with markdown', 'commenter': 'xwm1992'}]"
3049,docs/zh/design-document/12-zipkin.md,"@@ -1,49 +1,27 @@
-# 通过 Zipkin 观察 Trace
-
-### 1、下载和运行Zipkin
-
-请参考https://zipkin.io/pages/quickstart.html
-
-
-
-### 2、运行eventmesh
-
-运行eventmesh-starter(参考[eventmesh-runtime-quickstart](eventmesh-runtime-quickstart.md))
-
-运行eventmesh-example(参考[eventmesh-sdk-java-quickstart](eventmesh-sdk-java-quickstart.md))
-
-
-
-### 3、相关的设置
-
-eventmesh-runtime/conf/eventmesh.properties中：
-
-默认的exporter是log，需要手动改成Zipkin
-
-```properties
-#trace exporter
-eventmesh.trace.exporter.type=Zipkin
-```
-下面是关于Zipkin的各种配置
-```properties
-#set the maximum batch size to use
-eventmesh.trace.exporter.max.export.size=512
-#set the queue size. This must be >= the export batch size
-eventmesh.trace.exporter.max.queue.size=2048
-#set the max amount of time an export can run before getting(TimeUnit=SECONDS)
-eventmesh.trace.exporter.export.timeout=30
-#set time between two different exports(TimeUnit=SECONDS)
-eventmesh.trace.exporter.export.interval=5
-
-#zipkin
-eventmesh.trace.export.zipkin.ip=localhost
-eventmesh.trace.export.zipkin.port=9411
-```
-
-以上都是相关的配置，如果你十分熟悉Zipkin的话可以自行修改。
-
-
-
-### 4、观察
-
-浏览器打开： **localhost:9411**
+使用 Zipkin 收集痕迹
+齐普金
+分布式跟踪是一种用于分析和监控使用微服务架构构建的应用程序的方法。 分布式跟踪有助于查明发生故障的位置以及导致性能不佳的原因。
+
+Zipkin 是一种分布式跟踪系统，可帮助收集解决服务架构中的延迟问题所需的计时数据。 EventMesh 公开了可以由 Zipkin 收集和分析的跟踪数据集合。 请按照“Zipkin 快速入门”教程下载并安装最新版本的 Zipkin。
+
+配置","[{'comment': 'change to second level heading', 'commenter': 'xwm1992'}]"
3228,eventmesh-runtime/src/main/java/org/apache/eventmesh/runtime/admin/handler/HTTPClientHandler.java,"@@ -175,13 +175,13 @@ void list(HttpExchange httpExchange) throws IOException {
 
     @Override
     public void handle(HttpExchange httpExchange) throws IOException {
-        if (httpExchange.getRequestMethod().equals(""OPTIONS"")) {
+        if (""OPTIONS"".equals(httpExchange.getRequestMethod())) {
             preflight(httpExchange);
         }
-        if (httpExchange.getRequestMethod().equals(""GET"")) {
+        if (.""GET""equals(httpExchange.getRequestMethod())) {","[{'comment': 'please fix this', 'commenter': 'xwm1992'}]"
3322,settings.gradle,"@@ -66,4 +66,9 @@ include 'eventmesh-trace-plugin:eventmesh-trace-jaeger'
 include 'eventmesh-webhook'
 include 'eventmesh-webhook:eventmesh-webhook-api'
 include 'eventmesh-webhook:eventmesh-webhook-admin'
-include 'eventmesh-webhook:eventmesh-webhook-receive'
\ No newline at end of file
+include 'eventmesh-webhook:eventmesh-webhook-receive'
+include 'eventmesh-security-auth-token'
+include 'eventmesh-security-plugin:eventmesh-security-auth-token'
+findProject(':eventmesh-security-plugin:eventmesh-security-auth-token')?.name = 'eventmesh-security-auth-token'
+include 'eventmesh-security-plugin:eventmesh-security-acl-token'
+findProject(':eventmesh-security-plugin:eventmesh-security-acl-token')?.name = 'eventmesh-security-acl-token'","[{'comment': ""these lines can changed to :\r\n```\r\ninclude 'eventmesh-security-plugin'\r\ninclude 'eventmesh-security-plugin:eventmesh-security-api'\r\ninclude 'eventmesh-security-plugin:eventmesh-security-auth-token'\r\n```"", 'commenter': 'xwm1992'}, {'comment': 'OK, I will fix it next time I submit', 'commenter': 'slowpao'}]"
3322,eventmesh-common/src/main/java/org/apache/eventmesh/common/config/CommonConfiguration.java,"@@ -72,6 +72,8 @@ public class CommonConfiguration {
     @ConfigFiled(field = ""connector.plugin.type"", notEmpty = true)
     private String eventMeshConnectorPluginType = ""rocketmq"";
 
+    @ConfigFiled(field = ""security.validation.type.token"", notEmpty = true)
+    private boolean eventMeshSecurityValidateTypeToken = false;","[{'comment': 'this configuration need add to the eventmesh.properties file, since it is marked with @ConfigFiled, you can refer to `eventMeshConnectorPluginType`', 'commenter': 'xwm1992'}, {'comment': 'OK, I will fix it next time I submit', 'commenter': 'slowpao'}]"
3322,eventmesh-common/src/main/java/org/apache/eventmesh/common/config/CommonConfiguration.java,"@@ -95,6 +97,8 @@ public class CommonConfiguration {
     @ConfigFiled(field = ""server.registry.enabled"")
     private boolean eventMeshServerRegistryEnable = false;
 
+    @ConfigFiled(field = ""security.publickey"")
+    private String eventMeshSecurityPublickey = """";","[{'comment': 'same as above', 'commenter': 'xwm1992'}, {'comment': 'OK, I will fix it next time I submit', 'commenter': 'slowpao'}]"
3322,eventmesh-connector-plugin/eventmesh-connector-pulsar/src/main/java/org/apache/eventmesh/connector/pulsar/config/ClientConfiguration.java,"@@ -25,7 +25,7 @@
 
 @Getter
 @Setter
-@Config(prefix = ""eventMesh.server.pulsar"", path = ""classPath://pulsar-client.properties"")
+@Config(prefix = ""eventMesh.server.pulsar"")","[{'comment': 'why you remove this config: path = ""classPath://pulsar-client.properties""', 'commenter': 'xwm1992'}, {'comment': 'OK, I will fix it next time I submit', 'commenter': 'slowpao'}]"
3322,eventmesh-registry-plugin/eventmesh-registry-etcd/src/main/java/org/apache/eventmesh/registry/etcd/service/EtcdRegistryService.java,"@@ -231,6 +232,11 @@ public boolean unRegister(EventMeshUnRegisterInfo eventMeshUnRegisterInfo) throw
         }
     }
 
+    @Override
+    public EventMeshAppSubTopicInfo findEventMeshAppSubTopicInfoByGroup(String group) throws RegistryException {
+        return null;","[{'comment': 'the return value here is null, will it be implemented in other pr', 'commenter': 'xwm1992'}, {'comment': 'It is implemented in the EtcdCustomService class', 'commenter': 'slowpao'}]"
3322,eventmesh-runtime/src/main/java/org/apache/eventmesh/runtime/acl/Acl.java,"@@ -92,6 +94,11 @@ public void doAclCheckInTcpConnect(String remoteAddr, UserAgent userAgent, int r
         aclService.doAclCheckInConnect(buildTcpAclProperties(remoteAddr, userAgent, null, requestCode));
     }
 
+    public void doAclCheckInTcpConnect(String remoteAddr, String token, String subsystem, String topic,
+        String requestURI, Object obj) throws AclException {
+        aclService.doAclCheckInReceive(buildHttpAclProperties(remoteAddr, token, subsystem, topic, requestURI, obj));","[{'comment': ""this method will be triggered in tcp mode, but your's method is `buildHttpAclProperties`, it's not a good place to put it here"", 'commenter': 'xwm1992'}]"
3322,eventmesh-runtime/src/main/java/org/apache/eventmesh/runtime/acl/Acl.java,"@@ -138,6 +141,15 @@ public void doAclCheckInHttpReceive(String remoteAddr, String user, String pass,
         aclService.doAclCheckInReceive(buildHttpAclProperties(remoteAddr, user, pass, subsystem, topic, requestURI));
     }
 
+    public void doAclCheckInTcpReceive(String remoteAddr, String token, String subsystem, String topic,
+        String requestURI, Object obj) throws AclException {
+        aclService.doAclCheckInReceive(buildHttpAclProperties(remoteAddr, token, subsystem, topic, requestURI, obj));","[{'comment': 'same as above', 'commenter': 'xwm1992'}]"
3322,eventmesh-runtime/src/main/java/org/apache/eventmesh/runtime/core/protocol/tcp/client/task/HelloTask.java,"@@ -65,10 +65,17 @@ public void run() {
         Session session = null;
         UserAgent user = (UserAgent) pkg.getBody();
         try {
+
             //do acl check in connect
+            String remoteAddr = RemotingHelper.parseChannelRemoteAddr(ctx.channel());
+            String group = user.getGroup();
+            String token = user.getToken();
+            String subsystem = user.getSubsystem();
+            String topic = ""ddd/dnamespace/dtopic"";","[{'comment': 'What is the topic here for？', 'commenter': 'xwm1992'}, {'comment': 'OK, I will fix it next time I submit', 'commenter': 'slowpao'}]"
3322,eventmesh-runtime/src/main/java/org/apache/eventmesh/runtime/core/protocol/tcp/client/task/SubscribeTask.java,"@@ -59,10 +61,19 @@ public void run() {
             final List<SubscriptionItem> subscriptionItems = new ArrayList<>();
             final boolean eventMeshServerSecurityEnable = eventMeshTCPServer.getEventMeshTCPConfiguration().isEventMeshServerSecurityEnable();
             final String remoteAddr = RemotingHelper.parseChannelRemoteAddr(ctx.channel());
+
+            String group = session.getClient().getGroup();
+            String token = session.getClient().getToken();
+            String subsystem = session.getClient().getSubsystem();
+
+            EventMeshAppSubTopicInfo eventMeshAppSubTopicInfo = eventMeshTCPServer.getRegistry().findEventMeshAppSubTopicInfo(group);
             subscriptionInfo.getTopicList().forEach(item -> {
-                //do acl check for receive msg
                 if (eventMeshServerSecurityEnable) {","[{'comment': '`findEventMeshAppSubTopicInfo` method move into `if(eventMeshServerSecurityEnable)` is more convenient.', 'commenter': 'xwm1992'}, {'comment': 'OK, I will fix it next time I submit', 'commenter': 'slowpao'}]"
3322,eventmesh-registry-plugin/eventmesh-registry-etcd/src/main/java/org/apache/eventmesh/registry/etcd/service/EtcdCustomService.java,"@@ -0,0 +1,74 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.eventmesh.registry.etcd.service;
+
+import org.apache.eventmesh.api.exception.RegistryException;
+import org.apache.eventmesh.api.registry.bo.EventMeshAppSubTopicInfo;
+import org.apache.eventmesh.common.Constants;
+import org.apache.eventmesh.common.utils.JsonUtils;
+import org.apache.eventmesh.registry.etcd.constant.EtcdConstant;
+
+import org.apache.commons.collections4.CollectionUtils;
+
+import java.util.List;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import io.etcd.jetcd.ByteSequence;
+import io.etcd.jetcd.Client;
+import io.etcd.jetcd.KeyValue;
+import io.etcd.jetcd.options.GetOption;
+
+public class EtcdCustomService extends EtcdRegistryService {
+
+    private static final String KEY_PREFIX = ""eventMesh"" + EtcdConstant.KEY_SEPARATOR;
+    private static final String KEY_APP = ""app"";
+    private static final String KEY_SERVICE = ""service"";
+    private static final Logger logger = LoggerFactory.getLogger(EtcdCustomService.class);
+
+
+    public EventMeshAppSubTopicInfo findEventMeshAppSubTopicInfoByGroup(String group) throws RegistryException {
+
+        Client client = getEtcdClient();
+        String keyPrefix = KEY_PREFIX + KEY_APP + EtcdConstant.KEY_SEPARATOR + group;
+        List<KeyValue> keyValues = null;
+        try {
+            ByteSequence keyByteSequence = ByteSequence.from(keyPrefix.getBytes(Constants.DEFAULT_CHARSET));
+
+            GetOption getOption = GetOption.newBuilder().withPrefix(keyByteSequence).build();
+
+            keyValues = client.getKVClient().get(keyByteSequence, getOption).get().getKvs();
+
+
+            if (CollectionUtils.isNotEmpty(keyValues)) {
+                for (KeyValue kv : keyValues) {
+                    EventMeshAppSubTopicInfo eventMeshAppSubTopicInfo =
+                        JsonUtils.parseObject(new String(kv.getValue().getBytes(), Constants.DEFAULT_CHARSET), EventMeshAppSubTopicInfo.class);
+                    return eventMeshAppSubTopicInfo;
+                }
+            }
+        } catch (Exception e) {
+            logger.error(""[EtcdRegistryService][findEventMeshAppSubTopicInfoByGroup] error, group: {}"", group, e);
+            throw new RegistryException(e.getMessage());
+        }
+
+        return null;","[{'comment': 'nit: When you have to return null or empty, maybe you can consider using `Optional` as a replacement or add a `@Nullable` annotation. ', 'commenter': 'Markliniubility'}, {'comment': 'OK, I will fix it next time I submit', 'commenter': 'slowpao'}]"
3344,eventmesh-common/src/main/java/org/apache/eventmesh/common/protocol/tcp/codec/Codec.java,"@@ -74,12 +74,20 @@ public void encode(ChannelHandlerContext ctx, Package pkg, ByteBuf out) throws E
             int headerLength = ArrayUtils.getLength(headerData);
             int bodyLength = ArrayUtils.getLength(bodyData);
 
-            int length = 4 + 4 + headerLength + bodyLength;
+            int length = headerLength + bodyLength;","[{'comment': 'this line need to change:\r\n`int length = CONSTANT_MAGIC_FLAG.length + VERSION.length + headerLength + bodyLength;`', 'commenter': 'xwm1992'}]"
3344,eventmesh-common/src/main/java/org/apache/eventmesh/common/protocol/tcp/codec/Codec.java,"@@ -108,14 +116,14 @@ public void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) thro
 
                 final int length = in.readInt();
                 final int headerLength = in.readInt();
-                final int bodyLength = length - 8 - headerLength;
+                final int bodyLength = length - headerLength;","[{'comment': 'this line need to change:\r\n`final int bodyLength = length - CONSTANT_MAGIC_FLAG.length - VERSION.length - headerLength;`', 'commenter': 'xwm1992'}]"
3499,eventmesh-webhook/eventmesh-webhook-api/src/main/java/org/apache/eventmesh/webhook/api/Manufacturer.java,"@@ -54,11 +54,7 @@ public void setManufacturerEventMap(Map<String, List<String>> manufacturerEventM
     }
 
     public List<String> getManufacturerEvents(String manufacturerName) {
-        if (!manufacturerEventMap.containsKey(manufacturerName)) {
-            List<String> m = new ArrayList<>();
-            manufacturerEventMap.put(manufacturerName, m);
-            return m;
-        }
+        manufacturerEventMap.computeIfAbsent(manufacturerName, key -> manufacturerEventMap.put(manufacturerName, new ArrayList<>()));","[{'comment': '1. It is recommended to use ConcurrentHashMap\r\n2. The logic can be further simplified\r\n', 'commenter': 'mytang0'}]"
3524,eventmesh-protocol-plugin/eventmesh-protocol-meshmessage/src/main/java/org/apache/eventmesh/protocol/meshmessage/resolver/tcp/TcpMessageProtocolResolver.java,"@@ -76,6 +76,7 @@ public static CloudEvent buildEvent(Header header, EventMeshMessage message) thr
             .withId(header.getSeq())
             .withSource(URI.create(""/""))
             .withType(""eventmeshmessage"")
+            .withDataContentType(""text/plain"")
             .withSubject(topic)
             .withData(content.getBytes(StandardCharsets.UTF_8));","[{'comment': 'How about replace StandardCharsets.UTF_8 with Constants.DEFAULT_CHARSET, Consistent code style.', 'commenter': 'mxsm'}, {'comment': 'will do. thanks for your advice.', 'commenter': 'hgaol'}, {'comment': 'updated.', 'commenter': 'hgaol'}]"
3524,eventmesh-common/src/main/java/org/apache/eventmesh/common/Constants.java,"@@ -28,6 +28,8 @@ public class Constants {
 
     public static final String DATE_FORMAT_DEFAULT = ""yyyy-MM-dd HH:mm:ss"";
 
+    public static final String DATA_CONTENT_TYPE = ""DataContentType"";","[{'comment': 'the DataContentType key in the CloudEvents protocol must be lowercase，please refer to https://github.com/cloudevents/spec/blob/v1.0.2/cloudevents/spec.md', 'commenter': 'xwm1992'}, {'comment': 'resolved.', 'commenter': 'hgaol'}]"
3524,eventmesh-protocol-plugin/eventmesh-protocol-meshmessage/src/main/java/org/apache/eventmesh/protocol/meshmessage/resolver/tcp/TcpMessageProtocolResolver.java,"@@ -77,7 +75,11 @@ public static CloudEvent buildEvent(Header header, EventMeshMessage message) thr
             .withSource(URI.create(""/""))
             .withType(""eventmeshmessage"")
             .withSubject(topic)
-            .withData(content.getBytes(StandardCharsets.UTF_8));
+            .withData(content.getBytes(Constants.DEFAULT_CHARSET));
+
+        if (message.getHeaders().containsKey(Constants.DATA_CONTENT_TYPE)) {
+            cloudEventBuilder.withDataContentType(message.getHeaders().get(Constants.DATA_CONTENT_TYPE));
+        }
 ","[{'comment': 'Since you implement by adding headers, you also need to set headers in TcpMessageProtocolResolver#buildEventMeshMessage.\r\n\r\n```\r\nif (cloudEvent.getDataContentType() != null) {\r\n           eventMeshMessage.getHeaders().put(Constants.DATA_CONTENT_TYPE, cloudEvent.getDataContentType());\r\n}\r\n```', 'commenter': 'mytang0'}, {'comment': 'resolved. thanks for notification!', 'commenter': 'hgaol'}]"
3551,eventmesh-registry-plugin/eventmesh-registry-etcd/src/main/java/org/apache/eventmesh/registry/etcd/service/EtcdCustomService.java,"@@ -77,31 +77,29 @@ public List<EventMeshServicePubTopicInfo> findEventMeshServicePubTopicInfos() th
 
     @Nullable
     public EventMeshAppSubTopicInfo findEventMeshAppSubTopicInfoByGroup(String group) throws RegistryException {
-
         Client client = getEtcdClient();
         String keyPrefix = KEY_PREFIX + KEY_APP + EtcdConstant.KEY_SEPARATOR + group;
         List<KeyValue> keyValues = null;
         try {
             ByteSequence keyByteSequence = ByteSequence.from(keyPrefix.getBytes(Constants.DEFAULT_CHARSET));
-
             GetOption getOption = GetOption.newBuilder().withPrefix(keyByteSequence).build();
-
             keyValues = client.getKVClient().get(keyByteSequence, getOption).get().getKvs();
-
-
             if (CollectionUtils.isNotEmpty(keyValues)) {
-                for (KeyValue kv : keyValues) {
-                    EventMeshAppSubTopicInfo eventMeshAppSubTopicInfo =
-                        JsonUtils.parseObject(new String(kv.getValue().getBytes(), Constants.DEFAULT_CHARSET), EventMeshAppSubTopicInfo.class);
+                EventMeshAppSubTopicInfo eventMeshAppSubTopicInfo =
+                    JsonUtils.parseObject(
+                        new String(keyValues.get(0).getValue().getBytes(), Constants.DEFAULT_CHARSET),
+                        EventMeshAppSubTopicInfo.class
+                    );
+                if (eventMeshAppSubTopicInfo != null) {
                     return eventMeshAppSubTopicInfo;
+                } else {
+                    throw new NullPointerException(""eventMeshAppSubTopicInfo is null!"");","[{'comment': 'Return directly, there is already a null check outside.', 'commenter': 'mytang0'}, {'comment': 'Done', 'commenter': 'PickBas'}]"
3557,eventmesh-runtime/src/main/java/org/apache/eventmesh/runtime/core/protocol/http/processor/SendAsyncEventProcessor.java,"@@ -212,7 +212,7 @@ public void handler(final HandlerService.HandlerSpecific handlerSpecific, final
             return;
         }
 
-        final String content = new String(event.getData().toBytes(), StandardCharsets.UTF_8);
+        final String content = new String(Objects.requireNonNull(event.getData().toBytes()), StandardCharsets.UTF_8);","[{'comment': 'modify like this: `final String content = new String(Objects.requireNonNull(event.getData()).toBytes(), StandardCharsets.UTF_8);\r\n`', 'commenter': 'mxsm'}, {'comment': 'Done', 'commenter': 'Orcohen33'}]"
3594,eventmesh-runtime/src/test/java/org/apache/eventmesh/runtime/boot/EventMeshServerTest.java,"@@ -60,56 +60,56 @@ private void testGetConfigWhenStartup(Boolean hasEnv) throws Exception {
     }
 
     private void assertTCPConfig(EventMeshTCPConfiguration config) {
-        Assert.assertEquals(config.getEventMeshTcpServerPort(), 816);
-        Assert.assertEquals(config.getEventMeshTcpIdleAllSeconds(), 1816);
-        Assert.assertEquals(config.getEventMeshTcpIdleWriteSeconds(), 2816);
-        Assert.assertEquals(config.getEventMeshTcpIdleReadSeconds(), 3816);
-        Assert.assertEquals(config.getEventMeshTcpMsgReqnumPerSecond(), Integer.valueOf(4816));
-        Assert.assertEquals(config.getEventMeshTcpClientMaxNum(), 5816);
-        Assert.assertEquals(config.getEventMeshTcpGlobalScheduler(), 6816);
-        Assert.assertEquals(config.getEventMeshTcpTaskHandleExecutorPoolSize(), 7816);
-        Assert.assertEquals(config.getEventMeshTcpMsgDownStreamExecutorPoolSize(), 8816);
-        Assert.assertEquals(config.getEventMeshTcpSessionExpiredInMills(), 1816);
-        Assert.assertEquals(config.getEventMeshTcpSessionUpstreamBufferSize(), 11816);
-        Assert.assertEquals(config.getEventMeshTcpMsgAsyncRetryTimes(), 12816);
-        Assert.assertEquals(config.getEventMeshTcpMsgSyncRetryTimes(), 13816);
-        Assert.assertEquals(config.getEventMeshTcpMsgRetrySyncDelayInMills(), 14816);
-        Assert.assertEquals(config.getEventMeshTcpMsgRetryAsyncDelayInMills(), 15816);
-        Assert.assertEquals(config.getEventMeshTcpMsgRetryQueueSize(), 16816);
-        Assert.assertEquals(config.getEventMeshTcpRebalanceIntervalInMills(), Integer.valueOf(17816));
-        Assert.assertEquals(config.getEventMeshServerAdminPort(), 18816);
-        Assert.assertEquals(config.isEventMeshTcpSendBackEnabled(), Boolean.TRUE);
-        Assert.assertEquals(config.getEventMeshTcpSendBackMaxTimes(), 3);
-        Assert.assertEquals(config.getEventMeshTcpPushFailIsolateTimeInMills(), 21816);
-        Assert.assertEquals(config.getGracefulShutdownSleepIntervalInMills(), 22816);
-        Assert.assertEquals(config.getSleepIntervalInRebalanceRedirectMills(), 23816);
-        Assert.assertEquals(config.getEventMeshEventSize(), 22816);
-        Assert.assertEquals(config.getEventMeshEventBatchSize(), 23816);
+        Assert.assertEquals(816,config.getEventMeshTcpServerPort());
+        Assert.assertEquals(1816,config.getEventMeshTcpIdleAllSeconds());
+        Assert.assertEquals(2816,config.getEventMeshTcpIdleWriteSeconds());
+        Assert.assertEquals(3816,config.getEventMeshTcpIdleReadSeconds());
+        Assert.assertEquals(Integer.valueOf(4816),config.getEventMeshTcpMsgReqnumPerSecond());
+        Assert.assertEquals(5816,config.getEventMeshTcpClientMaxNum());
+        Assert.assertEquals(6816,config.getEventMeshTcpGlobalScheduler());
+        Assert.assertEquals(7816,config.getEventMeshTcpTaskHandleExecutorPoolSize());
+        Assert.assertEquals(8816,config.getEventMeshTcpMsgDownStreamExecutorPoolSize());
+        Assert.assertEquals(1816,config.getEventMeshTcpSessionExpiredInMills());
+        Assert.assertEquals(11816,config.getEventMeshTcpSessionUpstreamBufferSize());
+        Assert.assertEquals(12816,config.getEventMeshTcpMsgAsyncRetryTimes());
+        Assert.assertEquals(13816,config.getEventMeshTcpMsgSyncRetryTimes());
+        Assert.assertEquals(14816,config.getEventMeshTcpMsgRetrySyncDelayInMills());
+        Assert.assertEquals(15816,config.getEventMeshTcpMsgRetryAsyncDelayInMills());
+        Assert.assertEquals(16816,config.getEventMeshTcpMsgRetryQueueSize());
+        Assert.assertEquals(Integer.valueOf(17816),config.getEventMeshTcpRebalanceIntervalInMills());
+        Assert.assertEquals(18816,config.getEventMeshServerAdminPort());
+        Assert.assertEquals(Boolean.TRUE,config.isEventMeshTcpSendBackEnabled());
+        Assert.assertEquals(3,config.getEventMeshTcpSendBackMaxTimes());
+        Assert.assertEquals(21816,config.getEventMeshTcpPushFailIsolateTimeInMills());
+        Assert.assertEquals(22816,config.getGracefulShutdownSleepIntervalInMills());
+        Assert.assertEquals(23816,config.getSleepIntervalInRebalanceRedirectMills());
+        Assert.assertEquals(22816,config.getEventMeshEventSize());
+        Assert.assertEquals(23816,config.getEventMeshEventBatchSize());
     }
 
     private void assertCommonConfig(CommonConfiguration config) {
-        Assert.assertEquals(""env-succeed!!!"", config.getEventMeshEnv());
-        Assert.assertEquals(""idc-succeed!!!"", config.getEventMeshIDC());
-        Assert.assertEquals(""cluster-succeed!!!"", config.getEventMeshCluster());
-        Assert.assertEquals(""name-succeed!!!"", config.getEventMeshName());
-        Assert.assertEquals(""816"", config.getSysID());
-        Assert.assertEquals(""connector-succeed!!!"", config.getEventMeshConnectorPluginType());
-        Assert.assertEquals(""storage-succeed!!!"", config.getEventMeshStoragePluginType());
-        Assert.assertEquals(""security-succeed!!!"", config.getEventMeshSecurityPluginType());
-        Assert.assertEquals(""registry-succeed!!!"", config.getEventMeshRegistryPluginType());
-        Assert.assertEquals(""trace-succeed!!!"", config.getEventMeshTracePluginType());
-        Assert.assertEquals(""hostIp-succeed!!!"", config.getEventMeshServerIp());
+        Assert.assertEquals(config.getEventMeshEnv(),""env-succeed!!!"");
+        Assert.assertEquals(config.getEventMeshIDC(),""idc-succeed!!!"");
+        Assert.assertEquals(config.getEventMeshCluster(),""cluster-succeed!!!"");
+        Assert.assertEquals(config.getEventMeshName(),""name-succeed!!!"");
+        Assert.assertEquals(config.getSysID(),""816"");
+        Assert.assertEquals(config.getEventMeshConnectorPluginType(),""connector-succeed!!!"");
+        Assert.assertEquals(config.getEventMeshStoragePluginType(),""storage-succeed!!!"");
+        Assert.assertEquals(config.getEventMeshSecurityPluginType(),""security-succeed!!!"");
+        Assert.assertEquals(config.getEventMeshRegistryPluginType(),""registry-succeed!!!"");
+        Assert.assertEquals(config.getEventMeshTracePluginType(),""trace-succeed!!!"");
+        Assert.assertEquals(config.getEventMeshServerIp(),""hostIp-succeed!!!"");
 
         List<String> list = new ArrayList<>();
         list.add(""metrics-succeed1!!!"");
         list.add(""metrics-succeed2!!!"");
         list.add(""metrics-succeed3!!!"");
-        Assert.assertEquals(list, config.getEventMeshMetricsPluginType());
+        Assert.assertEquals(config.getEventMeshMetricsPluginType(),list);
 
         Assert.assertTrue(config.isEventMeshServerSecurityEnable());
         Assert.assertTrue(config.isEventMeshServerRegistryEnable());
         Assert.assertTrue(config.isEventMeshServerTraceEnable());
 
-        Assert.assertEquals(""eventmesh.idc-succeed!!!"", config.getEventMeshWebhookOrigin());
+        Assert.assertEquals(config.getEventMeshWebhookOrigin(),""eventmesh.idc-succeed!!!"");","[{'comment': ""Please restore the changes in these lines, the original order of 'expect' and 'actual' is correct."", 'commenter': 'Pil0tXia'}]"
3666,eventmesh-runtime/src/main/java/org/apache/eventmesh/runtime/util/Utils.java,"@@ -98,9 +98,9 @@ public static void logFailedMessageFlow(ChannelFuture future, Package pkg, UserA
     private static void logFailedMessageFlow(Package pkg, UserAgent user, long startTime, long taskExecuteTime,
         Throwable e) {
         if (pkg.getBody() instanceof EventMeshMessage) {
+            final Sting mqMessage = EventMeshUtil.printMqMessage((EventMeshMessage) pkg.getBody());","[{'comment': '`Sting` is not correct, please change to `String`.', 'commenter': 'xwm1992'}]"
3666,eventmesh-runtime/src/main/java/org/apache/eventmesh/runtime/util/Utils.java,"@@ -118,8 +118,9 @@ private static void logFailedMessageFlow(Package pkg, UserAgent user, long start
      */
     public static void logSucceedMessageFlow(Package pkg, UserAgent user, long startTime, long taskExecuteTime) {
         if (pkg.getBody() instanceof EventMeshMessage) {
+            final Sting mqMessage = EventMeshUtil.printMqMessage((EventMeshMessage) pkg.getBody());","[{'comment': 'same as above.', 'commenter': 'xwm1992'}]"
3746,eventmesh-runtime/src/main/java/org/apache/eventmesh/runtime/boot/EventMeshGrpcServer.java,"@@ -126,6 +127,7 @@ public void init() throws Exception {
             .addService(new ProducerService(this, sendMsgExecutor))
             .addService(new ConsumerService(this, clientMgmtExecutor, replyMsgExecutor))
             .addService(new HeartbeatService(this, clientMgmtExecutor))
+            .addService(new PublisherService(this, clientMgmtExecutor))","[{'comment': 'why publisherService use the clientMgmtExecutor?', 'commenter': 'xwm1992'}]"
3746,eventmesh-runtime/src/main/java/org/apache/eventmesh/runtime/core/protocol/grpc/processor/AbstructPublishBatchCloudEventProcessor.java,"@@ -0,0 +1,105 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.eventmesh.runtime.core.protocol.grpc.processor;
+
+import org.apache.eventmesh.api.exception.AclException;
+import org.apache.eventmesh.common.protocol.grpc.cloudevents.CloudEvent;
+import org.apache.eventmesh.common.protocol.grpc.cloudevents.CloudEventBatch;
+import org.apache.eventmesh.common.protocol.grpc.common.EventMeshCloudEventUtils;
+import org.apache.eventmesh.common.protocol.grpc.common.StatusCode;
+import org.apache.eventmesh.common.protocol.http.common.RequestCode;
+import org.apache.eventmesh.runtime.acl.Acl;
+import org.apache.eventmesh.runtime.boot.EventMeshGrpcServer;
+import org.apache.eventmesh.runtime.constants.EventMeshConstants;
+import org.apache.eventmesh.runtime.core.protocol.grpc.service.EventEmitter;
+import org.apache.eventmesh.runtime.core.protocol.grpc.service.ServiceUtils;
+
+import java.util.concurrent.TimeUnit;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import lombok.extern.slf4j.Slf4j;
+
+@Slf4j
+public abstract class AbstructPublishBatchCloudEventProcessor implements PublishProcessor<CloudEventBatch, CloudEvent> {","[{'comment': 'Class Name Abstruct -> Abstract', 'commenter': 'xwm1992'}]"
3819,eventmesh-runtime/src/main/java/org/apache/eventmesh/runtime/core/protocol/http/producer/SendMessageContext.java,"@@ -123,13 +123,13 @@ public String toString() {
     }
 
     @Override
-    public boolean retry() throws Exception {
+    public void retry() throws Exception {
         if (eventMeshProducer == null) {
-            return false;
+            log.error(""Exception happends during retry. EventMeshProduceer is null."");","[{'comment': 'here need add return in if block', 'commenter': 'xwm1992'}, {'comment': 'I was merging 3 `RetryContext`s in module http, grpc and tcp to one.\r\n![1683322381305](https://user-images.githubusercontent.com/35672972/236572429-f594b8ca-bca3-4e35-9f1f-15af71a4a107.png)\r\n3 `RetryContext`s have almost same structure except a little difference. This `retry()` is that difference. It returns boolean in module http, grpc, and void in module tcp. Then I checked all calls of `retry()` that returns boolean. I found the return value of boolean has no practical use in all calls. So I chose to modify it to `void` to keep with `retry()` in module tcp.\r\n\r\nIf the return value of boolean type is indeed useful, may I modify the void to boolean in module tcp?', 'commenter': 'pandaapo'}, {'comment': 'What I mean is that in your modified logic, the return is missing in the if code block, and return boolean is not required.\r\nyou need add `return` after the `log.error()`.', 'commenter': 'xwm1992'}, {'comment': 'Oh! Yes. :joy:', 'commenter': 'pandaapo'}]"
3819,eventmesh-runtime/src/main/java/org/apache/eventmesh/runtime/core/protocol/http/producer/SendMessageContext.java,"@@ -123,13 +123,13 @@ public String toString() {
     }
 
     @Override
-    public boolean retry() throws Exception {
+    public void retry() throws Exception {
         if (eventMeshProducer == null) {
-            return false;
+            log.error(""Exception happends during retry. EventMeshProduceer is null."");
         }
 
         if (retryTimes > 0) { //retry once
-            return false;
+            log.error(""Exception happends during retry. The retryTimes > 0."");","[{'comment': 'same as above', 'commenter': 'xwm1992'}]"
3840,eventmesh-storage-plugin/eventmesh-storage-standalone/src/test/java/org/apache/eventmesh/storage/standalone/broker/MessageQueueTest.java,"@@ -103,12 +103,12 @@ public void testGetSize() {
     public void testGetTakeIndex() throws InterruptedException {
         MessageEntity takeIndexMessageEntity = messageQueue.take();
         Assert.assertNotNull(takeIndexMessageEntity);
-        Assert.assertTrue(messageQueue.getTakeIndex() == 1);
+        Assert.assertEquals(messageQueue.getTakeIndex() == 1);","[{'comment': 'Assert.assertEquals(1, messageQueue.getTakeIndex());', 'commenter': 'Alonexc'}]"
3841,eventmesh-common/src/main/java/org/apache/eventmesh/common/protocol/http/HttpCommand.java,"@@ -57,9 +57,27 @@ public class HttpCommand implements ProtocolTransportObject {
 
     public String httpVersion;
 
-    public Header header;
+    private transient Header header;
 
-    public Body body;
+    private transient Body body;
+    
+    // getter and setter for header
+    public Header getHeader() {
+        return header;
+    }
+
+    public void setHeader(Header header) {
+        this.header = header;
+    }
+
+    // getter and setter for body
+    public Body getBody() {
+        return body;
+    }
+
+    public void setBody(Body body) {
+        this.body = body;
+    }","[{'comment': 'This class has @Data annotation by lombok, do not need to add additional getter/setter @harshithasudhakar ', 'commenter': 'xwm1992'}]"
3841,eventmesh-common/src/main/java/org/apache/eventmesh/common/protocol/http/HttpCommand.java,"@@ -57,9 +60,9 @@ public class HttpCommand implements ProtocolTransportObject {
 
     public String httpVersion;
 
-    public Header header;
+    @Getter @Setter private transient Header header;","[{'comment': 'you do not need to add @Getter @Setter, because this class has the @Data annotation. @harshithasudhakar ', 'commenter': 'xwm1992'}]"
3841,eventmesh-common/src/main/java/org/apache/eventmesh/common/protocol/http/HttpCommand.java,"@@ -57,9 +60,9 @@ public class HttpCommand implements ProtocolTransportObject {
 
     public String httpVersion;
 
-    public Header header;
+    @Getter @Setter private transient Header header;
 
-    public Body body;
+    @Getter @Setter private transient Body body;","[{'comment': 'same as above', 'commenter': 'xwm1992'}]"
3953,eventmesh-runtime/src/main/java/org/apache/eventmesh/runtime/boot/EventMeshServer.java,"@@ -73,14 +73,16 @@ public EventMeshServer() {
 
         final List<String> provideServerProtocols = configuration.getEventMeshProvideServerProtocols();
         for (final String provideServerProtocol : provideServerProtocols) {
-            if (ConfigurationContextUtil.HTTP.equals(provideServerProtocol)) {
-                BOOTSTRAP_LIST.add(new EventMeshHttpBootstrap(this));
-            }
-            if (ConfigurationContextUtil.TCP.equals(provideServerProtocol)) {
-                BOOTSTRAP_LIST.add(new EventMeshTcpBootstrap(this));
-            }
-            if (ConfigurationContextUtil.GRPC.equals(provideServerProtocol)) {
-                BOOTSTRAP_LIST.add(new EventMeshGrpcBootstrap(this));
+            switch (provideServerProtocol) {","[{'comment': 'if you change to switch, you need add default case.', 'commenter': 'xwm1992'}, {'comment': '> if you change to switch, you need add default case.\r\n\r\nI hava fix it and resubmit again', 'commenter': 'mxsm'}, {'comment': 'you need add default in switch condition. I think you just need to add:\r\nswitch (condition) {\r\n case 1:\r\n case 2:\r\ndefault:\r\n    break;\r\n}', 'commenter': 'xwm1992'}]"
3986,eventmesh-connector-sdks/eventmesh-connector-sdk-java/src/main/java/org/apache/eventmesh/connector/api/config/PubSubConfig.java,"@@ -38,4 +38,6 @@ public class PubSubConfig {
 
     private String passWord;
 
+    private String subsystem;","[{'comment': ""here don't use the subsystem, use `appId` instead which is in `PubSubConfig` class"", 'commenter': 'xwm1992'}]"
3986,eventmesh-connector-sdks/eventmesh-connector-sdk-java/src/main/java/org/apache/eventmesh/connector/util/ConfigUtil.java,,"[{'comment': ""@tooo-bad It seems that you've added a git submodule. Please remove it."", 'commenter': 'Pil0tXia'}, {'comment': 'I have searched the config file for no information about submodules, and there is no .gitmodules file in the root directory.', 'commenter': 'tooo-bad'}]"
4139,eventmesh-admin/eventmesh-admin-rocketmq/src/test/java/org/apache/eventmesh/admin/rocketmq/util/UrlMappingPatternTest.java,"@@ -86,8 +88,21 @@ public void testGetParamNames() {
     }
 
     @Test
-    public void testCompile() {
-        //TODO : Fix me to test the method compile(). It is better using Mockito not PowerMockito.
+    public void testCompile() throws NoSuchFieldException, IllegalAccessException {
+        // Mock the compiledUrlMappingPattern field with reflection
+        Pattern mockedPattern = mock(Pattern.class);
+        Field compiledUrlMappingPatternField = urlMappingPattern.getClass().getDeclaredField(""compiledUrlMappingPattern"");
+        compiledUrlMappingPatternField.setAccessible(true);
+        compiledUrlMappingPatternField.set(urlMappingPattern, mockedPattern);","[{'comment': 'It seems unnecessary to `mock(Pattern.class)` for the field `compiledUrlMappingPattern` again. Because `compiledUrlMappingPattern` has already been mocked.\r\nYou can use reflection to obtain and directly use the `compiledUrlMappingPattern` field.', 'commenter': 'pandaapo'}, {'comment': 'Thank you! It is really a good idea. I have committed the changes, and please review it at your ease.', 'commenter': 'Pil0tXia'}]"
4212,eventmesh-sdks/eventmesh-sdk-java/src/main/java/org/apache/eventmesh/client/grpc/producer/EventMeshMessageProducer.java,"@@ -116,7 +116,6 @@ public EventMeshMessage requestReply(EventMeshMessage message, long timeout) {
             }
             return EventMeshCloudEventBuilder.buildMessageFromEventMeshCloudEvent(reply, PROTOCOL_TYPE);
         } catch (Exception e) {
-            e.printStackTrace();
             if (log.isErrorEnabled()) {
                 log.error(""Error in RequestReply message {}"", message, e);
             }","[{'comment': 'Consider removing the if statement.', 'commenter': 'mxsm'}]"
4229,eventmesh-runtime/src/main/java/org/apache/eventmesh/runtime/core/protocol/tcp/client/task/MessageTransferTask.java,"@@ -181,27 +181,23 @@ public void run() {
 
     private CloudEvent addTimestamp(CloudEvent event, Command cmd, long sendTime) {
         if (cmd == RESPONSE_TO_SERVER) {
-            event = CloudEventBuilder.from(event)
-                .withExtension(EventMeshConstants.RSP_C2EVENTMESH_TIMESTAMP,
-                    String.valueOf(startTime))
-                .withExtension(EventMeshConstants.RSP_EVENTMESH2MQ_TIMESTAMP,
-                    String.valueOf(sendTime))
-                .withExtension(EventMeshConstants.RSP_SEND_EVENTMESH_IP,
-                    eventMeshTCPServer.getEventMeshTCPConfiguration().getEventMeshServerIp())
-                .build();
+            event = getCloudEvent(event, sendTime, EventMeshConstants.RSP_C2EVENTMESH_TIMESTAMP, EventMeshConstants.RSP_EVENTMESH2MQ_TIMESTAMP,
+                EventMeshConstants.RSP_SEND_EVENTMESH_IP);","[{'comment': ""If a method's input parameters do not require any reassignment logic, it is not recommended to use them as left-hand values for reassignment. Typically, it is better to use a new variable as the return value, which will make the logic clearer. In this case, there is no necessity to define a new variable, so you can directly return the return value of the `getCloudEvent` method."", 'commenter': 'Pil0tXia'}, {'comment': ""It's updated now."", 'commenter': 'fabian4'}]"
4229,eventmesh-runtime/src/main/java/org/apache/eventmesh/runtime/core/protocol/tcp/client/task/MessageTransferTask.java,"@@ -181,25 +181,20 @@ public void run() {
 
     private CloudEvent addTimestamp(CloudEvent event, Command cmd, long sendTime) {
         if (cmd == RESPONSE_TO_SERVER) {
-            event = CloudEventBuilder.from(event)
-                .withExtension(EventMeshConstants.RSP_C2EVENTMESH_TIMESTAMP,
-                    String.valueOf(startTime))
-                .withExtension(EventMeshConstants.RSP_EVENTMESH2MQ_TIMESTAMP,
-                    String.valueOf(sendTime))
-                .withExtension(EventMeshConstants.RSP_SEND_EVENTMESH_IP,
-                    eventMeshTCPServer.getEventMeshTCPConfiguration().getEventMeshServerIp())
-                .build();
+            return getCloudEvent(event, sendTime, EventMeshConstants.RSP_C2EVENTMESH_TIMESTAMP, EventMeshConstants.RSP_EVENTMESH2MQ_TIMESTAMP,
+                EventMeshConstants.RSP_SEND_EVENTMESH_IP);
         } else {
-            event = CloudEventBuilder.from(event)
-                .withExtension(EventMeshConstants.REQ_C2EVENTMESH_TIMESTAMP,
-                    String.valueOf(startTime))
-                .withExtension(EventMeshConstants.REQ_EVENTMESH2MQ_TIMESTAMP,
-                    String.valueOf(sendTime))
-                .withExtension(EventMeshConstants.REQ_SEND_EVENTMESH_IP,
-                    eventMeshTCPServer.getEventMeshTCPConfiguration().getEventMeshServerIp())
-                .build();
+            return getCloudEvent(event, sendTime, EventMeshConstants.REQ_C2EVENTMESH_TIMESTAMP, EventMeshConstants.REQ_EVENTMESH2MQ_TIMESTAMP,
+                EventMeshConstants.REQ_SEND_EVENTMESH_IP);
         }
-        return event;
+    }
+
+    private CloudEvent getCloudEvent(CloudEvent event, long sendTime, String times, String mq, String ip) {","[{'comment': 'Compared to before, the readability of the parameter list is not good. ', 'commenter': 'lrhkobe'}]"
4229,eventmesh-runtime/src/main/java/org/apache/eventmesh/runtime/core/protocol/tcp/client/task/MessageTransferTask.java,"@@ -181,25 +181,20 @@ public void run() {
 
     private CloudEvent addTimestamp(CloudEvent event, Command cmd, long sendTime) {
         if (cmd == RESPONSE_TO_SERVER) {
-            event = CloudEventBuilder.from(event)
-                .withExtension(EventMeshConstants.RSP_C2EVENTMESH_TIMESTAMP,
-                    String.valueOf(startTime))
-                .withExtension(EventMeshConstants.RSP_EVENTMESH2MQ_TIMESTAMP,
-                    String.valueOf(sendTime))
-                .withExtension(EventMeshConstants.RSP_SEND_EVENTMESH_IP,
-                    eventMeshTCPServer.getEventMeshTCPConfiguration().getEventMeshServerIp())
-                .build();
+            return getCloudEvent(event, sendTime, EventMeshConstants.RSP_C2EVENTMESH_TIMESTAMP, EventMeshConstants.RSP_EVENTMESH2MQ_TIMESTAMP,
+                EventMeshConstants.RSP_SEND_EVENTMESH_IP);
         } else {
-            event = CloudEventBuilder.from(event)
-                .withExtension(EventMeshConstants.REQ_C2EVENTMESH_TIMESTAMP,
-                    String.valueOf(startTime))
-                .withExtension(EventMeshConstants.REQ_EVENTMESH2MQ_TIMESTAMP,
-                    String.valueOf(sendTime))
-                .withExtension(EventMeshConstants.REQ_SEND_EVENTMESH_IP,
-                    eventMeshTCPServer.getEventMeshTCPConfiguration().getEventMeshServerIp())
-                .build();
+            return getCloudEvent(event, sendTime, EventMeshConstants.REQ_C2EVENTMESH_TIMESTAMP, EventMeshConstants.REQ_EVENTMESH2MQ_TIMESTAMP,
+                EventMeshConstants.REQ_SEND_EVENTMESH_IP);","[{'comment': 'You may give these parameters newlines to improve readability, or create a new local variable to pass the parameter. I would suggest the former.', 'commenter': 'Pil0tXia'}, {'comment': 'Do you mean like this?\r\n\r\n```java\r\nprivate CloudEvent addTimestamp(CloudEvent event, Command cmd, long sendTime) {\r\n      if (cmd == RESPONSE_TO_SERVER) {\r\n          return getCloudEvent(event, sendTime,\r\n              EventMeshConstants.RSP_C2EVENTMESH_TIMESTAMP,\r\n              EventMeshConstants.RSP_EVENTMESH2MQ_TIMESTAMP,\r\n              EventMeshConstants.RSP_SEND_EVENTMESH_IP);\r\n      } else {\r\n          return getCloudEvent(event, sendTime,\r\n              EventMeshConstants.REQ_C2EVENTMESH_TIMESTAMP,\r\n              EventMeshConstants.REQ_EVENTMESH2MQ_TIMESTAMP,\r\n              EventMeshConstants.REQ_SEND_EVENTMESH_IP);\r\n      }\r\n  }\r\n```', 'commenter': 'fabian4'}, {'comment': ""It seems better. You might want to ask @lrhkobe's opinion."", 'commenter': 'Pil0tXia'}, {'comment': 'ping @lrhkobe ', 'commenter': 'fabian4'}, {'comment': 'I prefer to keep the previous way.\r\nBecause the readability of this method `private CloudEvent getCloudEvent(CloudEvent event, long sendTime, String times, String mq, String ip)`  is not good.\r\n\r\nSuch as:\r\n```\r\n CloudEventBuilder.from(event)\r\n            .withExtension(times, String.valueOf(startTime))\r\n            .withExtension(mq, String.valueOf(sendTime))\r\n```\r\nThe parameter ( `times` and `mq` ) and the value passed in  seems not match.', 'commenter': 'lrhkobe'}, {'comment': 'So. should I keep it the same as before? Since I just did it as the issue told.\r\n\r\n', 'commenter': 'fabian4'}]"
4229,eventmesh-runtime/src/main/java/org/apache/eventmesh/runtime/core/protocol/tcp/client/task/MessageTransferTask.java,"@@ -181,25 +181,20 @@ public void run() {
 
     private CloudEvent addTimestamp(CloudEvent event, Command cmd, long sendTime) {
         if (cmd == RESPONSE_TO_SERVER) {
-            event = CloudEventBuilder.from(event)
-                .withExtension(EventMeshConstants.RSP_C2EVENTMESH_TIMESTAMP,
-                    String.valueOf(startTime))
-                .withExtension(EventMeshConstants.RSP_EVENTMESH2MQ_TIMESTAMP,
-                    String.valueOf(sendTime))
-                .withExtension(EventMeshConstants.RSP_SEND_EVENTMESH_IP,
-                    eventMeshTCPServer.getEventMeshTCPConfiguration().getEventMeshServerIp())
-                .build();
+            return getCloudEvent(event, sendTime, EventMeshConstants.RSP_C2EVENTMESH_TIMESTAMP, EventMeshConstants.RSP_EVENTMESH2MQ_TIMESTAMP,
+                EventMeshConstants.RSP_SEND_EVENTMESH_IP);
         } else {
-            event = CloudEventBuilder.from(event)
-                .withExtension(EventMeshConstants.REQ_C2EVENTMESH_TIMESTAMP,
-                    String.valueOf(startTime))
-                .withExtension(EventMeshConstants.REQ_EVENTMESH2MQ_TIMESTAMP,
-                    String.valueOf(sendTime))
-                .withExtension(EventMeshConstants.REQ_SEND_EVENTMESH_IP,
-                    eventMeshTCPServer.getEventMeshTCPConfiguration().getEventMeshServerIp())
-                .build();
+            return getCloudEvent(event, sendTime, EventMeshConstants.REQ_C2EVENTMESH_TIMESTAMP, EventMeshConstants.REQ_EVENTMESH2MQ_TIMESTAMP,
+                EventMeshConstants.REQ_SEND_EVENTMESH_IP);
         }
-        return event;
+    }
+
+    private CloudEvent getCloudEvent(CloudEvent event, long sendTime, String times, String mq, String ip) {
+        return CloudEventBuilder.from(event)
+            .withExtension(times, String.valueOf(startTime))
+            .withExtension(mq, String.valueOf(sendTime))
+            .withExtension(ip, eventMeshTCPServer.getEventMeshTCPConfiguration().getEventMeshServerIp())
+            .build();
     }","[{'comment': '```suggestion\r\n    private CloudEvent buildCloudEventWithTimestamps(CloudEvent event, String client2EventMeshTime,\r\n        String eventMesh2MqTime, long sendTime, String eventMeshIP) {\r\n        return CloudEventBuilder.from(event)\r\n            .withExtension(client2EventMeshTime, String.valueOf(startTime))\r\n            .withExtension(eventMesh2MqTime, String.valueOf(sendTime))\r\n            .withExtension(eventMeshIP, eventMeshTCPServer.getEventMeshTCPConfiguration().getEventMeshServerIp())\r\n            .build();\r\n    }\r\n```\r\n\r\nThe constant `RSP_C2EVENTMESH_TIMESTAMP` represents the timestamp of the response from the client to EventMesh. \r\nThe constant `RSP_EVENTMESH2MQ_TIMESTAMP` represents the timestamp of the response from EventMesh to Message Queue. \r\nThe constant `RSP_SEND_EVENTMESH_IP` represents the IP address of the EventMesh that sends the response. \r\n\r\nSo in my suggestion, the parameter names will be more readable. \r\n\r\nFurthermore, the name `getCloudEvent` does not match the functionality of this method, as it actually adds some extension fields to the CloudEvent. Thus, I suggest changing it to `buildCloudEventWithTimestamps`.\r\n\r\nAt last, I have also adjusted the order of the arguments, placing `sendTime` after `eventMesh2MqTime`. This makes it more aligned with the order in which the parameters are filled in the method and thus, more readable. ', 'commenter': 'Pil0tXia'}]"
4229,eventmesh-runtime/src/main/java/org/apache/eventmesh/runtime/core/protocol/tcp/client/task/MessageTransferTask.java,"@@ -181,25 +181,20 @@ public void run() {
 
     private CloudEvent addTimestamp(CloudEvent event, Command cmd, long sendTime) {
         if (cmd == RESPONSE_TO_SERVER) {
-            event = CloudEventBuilder.from(event)
-                .withExtension(EventMeshConstants.RSP_C2EVENTMESH_TIMESTAMP,
-                    String.valueOf(startTime))
-                .withExtension(EventMeshConstants.RSP_EVENTMESH2MQ_TIMESTAMP,
-                    String.valueOf(sendTime))
-                .withExtension(EventMeshConstants.RSP_SEND_EVENTMESH_IP,
-                    eventMeshTCPServer.getEventMeshTCPConfiguration().getEventMeshServerIp())
-                .build();
+            return getCloudEvent(event, sendTime, EventMeshConstants.RSP_C2EVENTMESH_TIMESTAMP, EventMeshConstants.RSP_EVENTMESH2MQ_TIMESTAMP,
+                EventMeshConstants.RSP_SEND_EVENTMESH_IP);","[{'comment': ""To match the changes in the method signature, it would be better to write the return statement as follows, putting `sendTime` on the same line as `RSP_EVENTMESH2MQ_TIMESTAMP` to highlight the corresponding relationship between these two parameters:\r\n```suggestion\r\nreturn buildCloudEventWithTimestamps(event,\r\n            EventMeshConstants.RSP_C2EVENTMESH_TIMESTAMP,\r\n            EventMeshConstants.RSP_EVENTMESH2MQ_TIMESTAMP, sendTime,\r\n            EventMeshConstants.RSP_SEND_EVENTMESH_IP);\r\n```\r\n\r\nHowever, in this PR, although we've extracted similar code into a method, we haven't reduced the number of lines of code or enhanced its readability. Overall, the modifications in this PR are technically acceptable but not particularly necessary."", 'commenter': 'Pil0tXia'}]"
4253,eventmesh-common/src/main/java/org/apache/eventmesh/common/utils/AssertUtils.java,"@@ -27,35 +27,35 @@
 public final class AssertUtils {
 
     /**
-     * assert obj not null
+     * Assert actual is not null
      *
-     * @param obj     obj
+     * @param actual  Object to test
      * @param message error message
      */
-    public static void notNull(final Object obj, final String message) {
-        isTrue(Objects.nonNull(obj), message);
+    public static void notNull(final Object actual, final String message) {
+        isTrue(Objects.nonNull(actual), message);
     }
 
     /**
-     * assert test is true
+     * Assert actual is true
      *
-     * @param test    test
+     * @param actual  boolean to test
      * @param message error message
      */
-    public static void isTrue(final Boolean test, final String message) {
-        if (!Boolean.TRUE.equals(test)) {
+    public static void isTrue(final Boolean actual, final String message) {
+        if (!Boolean.TRUE.equals(actual)) {
             throw new IllegalArgumentException(message);","[{'comment': 'If there is no logic in the code that needs to compare the expected value to the actual value, and there is no expected value that needs to be compared, then there is no need to name a single parameter `actual`.\r\n\r\nBesides, ""actual"" is an adjective.\r\n\r\nThe same applies to the other two methods.', 'commenter': 'Pil0tXia'}, {'comment': '@Pil0tXia Thanks for your feedback. As the idea of the test is an assertion, naming the variable as `actual `is like naming it `current`. \r\nAnyway after doing some [research ](https://docs.oracle.com/middleware/11119/jdev/api-reference-esdk/oracle/ide/util/Assert.html#check_boolean_) I saw that for booleans, the variable is usually named `condition`. If this LGTY, I will rename the boolean variable as `condition `and rollback the remaining variables.', 'commenter': 'HattoriHenzo'}, {'comment': 'Yes, `condition` is better. Good idea.', 'commenter': 'Pil0tXia'}]"
4257,eventmesh-storage-plugin/eventmesh-storage-mongodb/src/main/java/org/apache/eventmesh/storage/mongodb/utils/MongodbCloudEventUtil.java,"@@ -29,10 +29,12 @@
 import io.cloudevents.SpecVersion;
 import io.cloudevents.core.builder.CloudEventBuilder;
 
+import static org.apache.eventmesh.storage.mongodb.constant.MongodbConstants.*;","[{'comment': ""checkstyle doesn't seem to support '. *' import."", 'commenter': 'Alonexc'}, {'comment': 'Thanks for the feedback, \r\n\r\nUpdated in my last commit.', 'commenter': 'Ruhshan'}]"
4257,eventmesh-storage-plugin/eventmesh-storage-mongodb/src/main/java/org/apache/eventmesh/storage/mongodb/constant/MongodbConstants.java,"@@ -24,5 +24,14 @@ public class MongodbConstants {
     public static final String SEQUENCE_COLLECTION_NAME = ""pub_sub_seq"";
     public static final String SEQUENCE_KEY_FN = ""topic"";
     public static final String SEQUENCE_VALUE_FN = ""value"";
+    public static final String DOC_KEY_VERSION = ""version"";
+    public static final String DOC_KEY_DATA = ""data"";
+    public static final String DOC_KEY_ID = ""id"";
+    public static final String DOC_KEY_SOURCE = ""source"";
+    public static final String DOC_KEY_TYPE = ""type"";
+    public static final String DOC_KEY_DATA_CONTENT_TYPE = ""datacontenttype"";
+    public static final String DOC_KEY_SUBJECT = ""subject"";","[{'comment': '```suggestion\r\n    public static final String CLOUD_EVENT_DOC_VERSION = ""version"";\r\n    public static final String CLOUD_EVENT_DOC_DATA = ""data"";\r\n    public static final String CLOUD_EVENT_DOC_ID = ""id"";\r\n    public static final String CLOUD_EVENT_DOC_SOURCE = ""source"";\r\n    public static final String CLOUD_EVENT_DOC_TYPE = ""type"";\r\n    public static final String CLOUD_EVENT_DOC_DATACONTENTTYPE = ""datacontenttype"";\r\n    public static final String CLOUD_EVENT_DOC_SUBJECT = ""subject"";\r\n```\r\nThere is no need to add `KEY_` in the middle of constants. Considering their usage in both `convertToCloudEvent` and `convertToDocument` methods, the suggested naming is more readable.', 'commenter': 'Pil0tXia'}, {'comment': 'Thanks for the feedback. Implement in latest commit. ', 'commenter': 'Ruhshan'}]"
4257,eventmesh-storage-plugin/eventmesh-storage-mongodb/src/main/java/org/apache/eventmesh/storage/mongodb/utils/MongodbCloudEventUtil.java,"@@ -29,10 +29,19 @@
 import io.cloudevents.SpecVersion;
 import io.cloudevents.core.builder.CloudEventBuilder;
 
+import static org.apache.eventmesh.storage.mongodb.constant.MongodbConstants.CLOUD_EVENT_DOC_DATA;
+import static org.apache.eventmesh.storage.mongodb.constant.MongodbConstants.CLOUD_EVENT_DOC_DATACONTENTTYPE;
+import static org.apache.eventmesh.storage.mongodb.constant.MongodbConstants.CLOUD_EVENT_DOC_ID;
+import static org.apache.eventmesh.storage.mongodb.constant.MongodbConstants.CLOUD_EVENT_DOC_SOURCE;
+import static org.apache.eventmesh.storage.mongodb.constant.MongodbConstants.CLOUD_EVENT_DOC_SUBJECT;
+import static org.apache.eventmesh.storage.mongodb.constant.MongodbConstants.CLOUD_EVENT_DOC_TYPE;
+import static org.apache.eventmesh.storage.mongodb.constant.MongodbConstants.CLOUD_EVENT_DOC_VERSION;","[{'comment': 'I suggest importing the `MongodbConstants` class only and using Constants.NAME to refer to the constant, which has the advantage of explicitness. Anyone reading the code can immediately understand that the constant NAME comes from the `MongodbConstants` class. This can reduce cognitive overhead and prevent confusion with constants of the same prefix in other classes.', 'commenter': 'Pil0tXia'}, {'comment': 'Thanks for clarifying again. Will definitely use this pattern in future for appropriate scenarios.\r\n\r\nAnd implemented your feedback in the last commit.', 'commenter': 'Ruhshan'}]"
4270,eventmesh-protocol-plugin/eventmesh-protocol-meshmessage/src/main/java/org/apache/eventmesh/protocol/meshmessage/MeshMessageProtocolAdaptor.java,"@@ -108,31 +108,32 @@ public List<CloudEvent> toBatchCloudEvent(ProtocolTransportObject protocol) thro
     public ProtocolTransportObject fromCloudEvent(CloudEvent cloudEvent) throws ProtocolHandleException {
         validateCloudEvent(cloudEvent);
         String protocolDesc =
-            cloudEvent.getExtension(Constants.PROTOCOL_DESC) == null ? null : cloudEvent.getExtension(Constants.PROTOCOL_DESC).toString();
-
-        if (StringUtils.equals(MeshMessageProtocolConstant.PROTOCOL_DESC_HTTP, protocolDesc)) {
-            HttpCommand httpCommand = new HttpCommand();
-            Body body = new Body() {
-                final Map<String, Object> map = new HashMap<>();
-
-                @Override
-                public Map<String, Object> toMap() {
-                    if (cloudEvent.getData() == null) {
+                cloudEvent.getExtension(Constants.PROTOCOL_DESC) == null ? null : cloudEvent.getExtension(Constants.PROTOCOL_DESC).toString();
+
+        switch (Objects.requireNonNull(protocolDesc)) {
+            case MeshMessageProtocolConstant.PROTOCOL_DESC_HTTP:
+                HttpCommand httpCommand = new HttpCommand();
+                Body body = new Body() {
+                    final Map<String, Object> map = new HashMap<>();
+
+                    @Override
+                    public Map<String, Object> toMap() {
+                        if (cloudEvent.getData() == null) {
+                            return map;
+                        }
+                        map.put(MeshMessageProtocolConstant.PROTOCOL_KEY_CONTENT, new String(cloudEvent.getData().toBytes(), StandardCharsets.UTF_8));","[{'comment': ' StandardCharsets.UTF_8 replace with  Constants.DEFAULT_CHARSET', 'commenter': 'mxsm'}]"
4270,eventmesh-protocol-plugin/eventmesh-protocol-meshmessage/src/main/java/org/apache/eventmesh/protocol/meshmessage/MeshMessageProtocolAdaptor.java,"@@ -77,19 +75,20 @@ private CloudEvent deserializeTcpProtocol(Header header, String bodyJson) throws
     }
 
     private CloudEvent deserializeHttpProtocol(String requestCode,
-        org.apache.eventmesh.common.protocol.http.header.Header header,
-        Body body) throws ProtocolHandleException {
-
-        if (String.valueOf(RequestCode.MSG_BATCH_SEND.getRequestCode()).equals(requestCode)) {
-            return SendMessageBatchProtocolResolver.buildEvent(header, body);
-        } else if (String.valueOf(RequestCode.MSG_BATCH_SEND_V2.getRequestCode()).equals(requestCode)) {
-            return SendMessageBatchV2ProtocolResolver.buildEvent(header, body);
-        } else if (String.valueOf(RequestCode.MSG_SEND_SYNC.getRequestCode()).equals(requestCode)) {
-            return SendMessageRequestProtocolResolver.buildEvent(header, body);
-        } else if (String.valueOf(RequestCode.MSG_SEND_ASYNC.getRequestCode()).equals(requestCode)) {
-            return SendMessageRequestProtocolResolver.buildEvent(header, body);
-        } else {
-            throw new ProtocolHandleException(String.format(""unsupported requestCode: %s"", requestCode));
+                                               org.apache.eventmesh.common.protocol.http.header.Header header,
+                                               Body body) throws ProtocolHandleException {
+
+        switch (RequestCode.valueOf(requestCode)) {
+            case MSG_BATCH_SEND:
+                return SendMessageBatchProtocolResolver.buildEvent(header, body);
+            case MSG_BATCH_SEND_V2:
+                return SendMessageBatchV2ProtocolResolver.buildEvent(header, body);
+            case MSG_SEND_SYNC:
+                return SendMessageRequestProtocolResolver.buildEvent(header, body);","[{'comment': 'Line 87 is redundant.', 'commenter': 'Pil0tXia'}, {'comment': 'Merged both the Cases.', 'commenter': 'devCod3r'}]"
4270,eventmesh-protocol-plugin/eventmesh-protocol-meshmessage/src/main/java/org/apache/eventmesh/protocol/meshmessage/MeshMessageProtocolAdaptor.java,"@@ -108,31 +107,33 @@ public List<CloudEvent> toBatchCloudEvent(ProtocolTransportObject protocol) thro
     public ProtocolTransportObject fromCloudEvent(CloudEvent cloudEvent) throws ProtocolHandleException {
         validateCloudEvent(cloudEvent);
         String protocolDesc =
-            cloudEvent.getExtension(Constants.PROTOCOL_DESC) == null ? null : cloudEvent.getExtension(Constants.PROTOCOL_DESC).toString();
-
-        if (StringUtils.equals(MeshMessageProtocolConstant.PROTOCOL_DESC_HTTP, protocolDesc)) {
-            HttpCommand httpCommand = new HttpCommand();
-            Body body = new Body() {
-                final Map<String, Object> map = new HashMap<>();
-
-                @Override
-                public Map<String, Object> toMap() {
-                    if (cloudEvent.getData() == null) {
+                cloudEvent.getExtension(Constants.PROTOCOL_DESC) == null ? null : cloudEvent.getExtension(Constants.PROTOCOL_DESC).toString();","[{'comment': 'No change needs to be made in this line.', 'commenter': 'Pil0tXia'}, {'comment': 'Reverted back the changes (Removed few white spaces).', 'commenter': 'devCod3r'}]"
4270,eventmesh-protocol-plugin/eventmesh-protocol-meshmessage/src/main/java/org/apache/eventmesh/protocol/meshmessage/MeshMessageProtocolAdaptor.java,"@@ -108,31 +107,33 @@ public List<CloudEvent> toBatchCloudEvent(ProtocolTransportObject protocol) thro
     public ProtocolTransportObject fromCloudEvent(CloudEvent cloudEvent) throws ProtocolHandleException {
         validateCloudEvent(cloudEvent);
         String protocolDesc =
-            cloudEvent.getExtension(Constants.PROTOCOL_DESC) == null ? null : cloudEvent.getExtension(Constants.PROTOCOL_DESC).toString();
-
-        if (StringUtils.equals(MeshMessageProtocolConstant.PROTOCOL_DESC_HTTP, protocolDesc)) {
-            HttpCommand httpCommand = new HttpCommand();
-            Body body = new Body() {
-                final Map<String, Object> map = new HashMap<>();
-
-                @Override
-                public Map<String, Object> toMap() {
-                    if (cloudEvent.getData() == null) {
+                cloudEvent.getExtension(Constants.PROTOCOL_DESC) == null ? null : cloudEvent.getExtension(Constants.PROTOCOL_DESC).toString();
+
+        switch (Objects.requireNonNull(protocolDesc)) {
+            case MeshMessageProtocolConstant.PROTOCOL_DESC_HTTP:
+                HttpCommand httpCommand = new HttpCommand();
+                Body body = new Body() {
+                    final Map<String, Object> map = new HashMap<>();
+
+                    @Override
+                    public Map<String, Object> toMap() {
+                        if (cloudEvent.getData() == null) {
+                            return map;
+                        }
+                        map.put(MeshMessageProtocolConstant.PROTOCOL_KEY_CONTENT, new String(cloudEvent.getData().toBytes(),
+                                Constants.DEFAULT_CHARSET));","[{'comment': 'Consider putting the second argument on the same line.', 'commenter': 'Pil0tXia'}, {'comment': 'The second argument is on the same line but when I tried to put all the 3 arguments in the same line, I got the warning as shown below:\r\n<img width=""320"" alt=""image"" src=""https://github.com/apache/eventmesh/assets/124816912/acd33f5d-66eb-4e58-ac9b-dbe86cfece39"">\r\n', 'commenter': 'devCod3r'}, {'comment': ""Like this:\r\n```java\r\nmap.put(MeshMessageProtocolConstant.PROTOCOL_KEY_CONTENT,\r\n        new String(cloudEvent.getData().toBytes(), Constants.DEFAULT_CHARSET));\r\n```\r\nBecause `new String(cloudEvent.getData().toBytes(), Constants.DEFAULT_CHARSET)` is the second argument of `map.put`.\r\n\r\n`Put` method doesn't have three arguments; it's the original line breaks that make it look like it has three arguments ."", 'commenter': 'Pil0tXia'}, {'comment': 'I have put the whole second argument in the next line as suggested, thank you for the info :)', 'commenter': 'devCod3r'}]"
4280,eventmesh-connectors/eventmesh-connector-redis/src/main/java/org/apache/eventmesh/connector/redis/server/RedisConnectServer.java,"@@ -0,0 +1,45 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.eventmesh.connector.redis.server;
+
+import org.apache.eventmesh.connector.redis.config.RedisServerConfig;
+import org.apache.eventmesh.connector.redis.sink.connector.RedisSinkConnector;
+import org.apache.eventmesh.connector.redis.source.connector.RedisSourceConnector;
+import org.apache.eventmesh.openconnect.Application;
+import org.apache.eventmesh.openconnect.util.ConfigUtil;
+
+import lombok.extern.slf4j.Slf4j;
+
+@Slf4j
+public class RedisConnectServer {
+
+    public static void main(String[] args) throws Exception {
+
+        RedisServerConfig serverConfig = ConfigUtil.parse(RedisServerConfig.class, ""server-config.yml"");
+
+        if (serverConfig.isSourceEnable()) {
+            Application kafkaSourceApp = new Application();
+            kafkaSourceApp.run(RedisSourceConnector.class);
+        }
+
+        if (serverConfig.isSinkEnable()) {
+            Application kafkaSinkApp = new Application();
+            kafkaSinkApp.run(RedisSinkConnector.class);","[{'comment': 'I suggest a naming change for `kafkaSourceApp` and `kafkaSinkApp`.', 'commenter': 'Pil0tXia'}]"
4280,eventmesh-connectors/eventmesh-connector-redis/src/main/resources/sink-config.yml,"@@ -0,0 +1,31 @@
+#
+# Licensed to the Apache Software Foundation (ASF) under one or more
+# contributor license agreements.  See the NOTICE file distributed with
+# this work for additional information regarding copyright ownership.
+# The ASF licenses this file to You under the Apache License, Version 2.0
+# (the ""License""); you may not use this file except in compliance with
+# the License.  You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an ""AS IS"" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+pubSubConfig:
+    meshAddress: 127.0.0.1:10000
+    subject: TopicTest
+    idc: FT
+    env: PRD
+    group: kafkaSink","[{'comment': 'and here.', 'commenter': 'Pil0tXia'}]"
4282,.github/workflows/build.yaml,"@@ -35,6 +35,8 @@ jobs:
         uses: docker/build-push-action@v3
         with:
           push: true
-          tags: eventmesh/eventmesh:latest
           file: ./docker/Dockerfile
           context: ./
+          tags: |
+            eventmesh/eventmesh:latest
+            apache/eventmesh:latest","[{'comment': ""I don't think adding `apache` to the script will help solve this issue. Actually this script never works correctly after commit https://github.com/apache/eventmesh/commit/2e6e6bfbdc3ee629eff93ef8804094c88f8bbc6b.\r\n\r\nMay you please make neccesary modifications and verify it works in your forked repo? Then we can set the DockerHub auth in repo ENVs."", 'commenter': 'Pil0tXia'}, {'comment': 'You want me to use my docker creds for my repo and than check if the image is pushed. Is my assumption correct?', 'commenter': 'kartiktayal'}, {'comment': 'Yes, in this way, we will be able to locate the reason of function failure.', 'commenter': 'Pil0tXia'}, {'comment': 'Made the changes to the workflow. The docker image is getting pushed now. Please let me know if we need to update the repos where the image is to be pushed.', 'commenter': 'kartiktayal'}]"
4285,eventmesh-sdks/eventmesh-sdk-java/src/main/java/org/apache/eventmesh/client/grpc/util/EventMeshCloudEventBuilder.java,"@@ -190,56 +187,25 @@ private static CloudEvent switchEventMeshMessage2EventMeshCloudEvent(EventMeshMe
 
     private static CloudEvent switchCloudEvent2EventMeshCloudEvent(io.cloudevents.CloudEvent message, EventMeshGrpcClientConfig clientConfig,
         EventMeshProtocolType protocolType) {
-        final io.cloudevents.CloudEvent cloudEvent = message;
-        CloudEventBuilder cloudEventBuilder = CloudEventBuilder.from(cloudEvent);
-        if (null == cloudEvent.getExtension(ProtocolKey.ENV)) {
-            cloudEventBuilder.withExtension(ProtocolKey.ENV, clientConfig.getEnv());
-        }
-        if (null == cloudEvent.getExtension(ProtocolKey.IDC)) {
-            cloudEventBuilder.withExtension(ProtocolKey.IDC, clientConfig.getEnv());
-        }
-        if (null == cloudEvent.getExtension(ProtocolKey.IP)) {
-            cloudEventBuilder.withExtension(ProtocolKey.IP, Objects.requireNonNull(IPUtils.getLocalAddress()));
-        }
-        if (null == cloudEvent.getExtension(ProtocolKey.PID)) {
-            cloudEventBuilder.withExtension(ProtocolKey.PID, Long.toString(ThreadUtils.getPID()));
-        }
-        if (null == cloudEvent.getExtension(ProtocolKey.SYS)) {
-            cloudEventBuilder.withExtension(ProtocolKey.SYS, clientConfig.getSys());
-        }
 
-        if (null == cloudEvent.getExtension(ProtocolKey.LANGUAGE)) {
-            cloudEventBuilder.withExtension(ProtocolKey.LANGUAGE, Constants.LANGUAGE_JAVA);
-        }
+        CloudEventBuilder cloudEventBuilder = CloudEventBuilder.from(message);
+
+        builderCloudEvent(message, cloudEventBuilder, ProtocolKey.ENV, clientConfig.getEnv());
+        builderCloudEvent(message, cloudEventBuilder, ProtocolKey.IDC, clientConfig.getIdc());
+        builderCloudEvent(message, cloudEventBuilder, ProtocolKey.IP, Objects.requireNonNull(IPUtils.getLocalAddress()));","[{'comment': 'How about changing the method name to `buildCloudEvent`?', 'commenter': 'Pil0tXia'}, {'comment': '> How about changing the method name to `buildCloudEvent`?\r\n\r\nYes, it does. `buildCloudEvent` seems to fit this behavior better.', 'commenter': 'hhuang1231'}]"
4285,eventmesh-sdks/eventmesh-sdk-java/src/main/java/org/apache/eventmesh/client/grpc/util/EventMeshCloudEventBuilder.java,"@@ -248,6 +214,12 @@ private static CloudEvent switchCloudEvent2EventMeshCloudEvent(io.cloudevents.Cl
         return null;
     }
 
+    private static void buildCloudEvent(io.cloudevents.CloudEvent message, CloudEventBuilder cloudEventBuilder, String protocolKey, String key) {","[{'comment': ""1. I think it may be better to change the method name to `computeCloudEventIfAbsent()` according to the logic. \r\n\r\n2. The last param is a value, not a key, so its name isn't appropriate. I think `computeCloudEventIfAbsent(io.cloudevents.CloudEvent message, CloudEventBuilder cloudEventBuilder, String key, String value)` may be better."", 'commenter': 'pandaapo'}, {'comment': 'Reasonable. \r\n(Though for the moment most similar treatments are not called this name)😂.', 'commenter': 'Pil0tXia'}, {'comment': ""1. Yes, it's easier to read with the suffix `IfAbsent` .\r\n2. But I think `build` might be more of a prefix fix than `compute`.After all, we use `CloudEventbuilder` to `Build` it.\r\n3. Maybe we could change `String protocolKey` to `String extension` and `String key` to `String value.`.\r\n\r\nFinally, if you have a better suggestion, I will be more than happy to see it."", 'commenter': 'hhuang1231'}]"
4316,.github/workflows/greetings.yml,"@@ -26,7 +26,7 @@ jobs:
     name: Greeting
     runs-on: ubuntu-latest
     steps:
-      - uses: actions/first-interaction@v1
+      - uses: actions/first-interaction@v1.1.1
         with:","[{'comment': ""This modification shouldn't be part of this PR. The good thing is that this update won't affect the current workflow configuration. Acceptable."", 'commenter': 'Pil0tXia'}]"
4336,eventmesh-runtime/src/main/java/org/apache/eventmesh/runtime/core/protocol/http/processor/HandlerService.java,"@@ -268,6 +284,11 @@ public void run() {
                 response = processorWrapper.httpProcessor.handler(request);
 
                 this.postHandler();
+                if (processorWrapper.httpProcessor instanceof ShortHttpProcessor) {
+                    sendShortResponse(ctx, this.request, this.response);
+                    return;
+                }
+                HandlerService.this.sendResponse(ctx, this.request, this.response);","[{'comment': 'here please do not refactor the postHandler method code, just move the method calling position is ok.', 'commenter': 'xwm1992'}, {'comment': 'done~', 'commenter': 'Pil0tXia'}]"
4337,eventmesh-common/src/main/java/org/apache/eventmesh/common/protocol/grpc/common/EventMeshCloudEventUtils.java,"@@ -47,8 +47,12 @@ public static String getEnv(CloudEvent cloudEvent) {
     }
 
     public static String getEnv(CloudEvent cloudEvent, String defaultValue) {
+        return getValue(cloudEvent, defaultValue, ProtocolKey.ENV);
+    }
+
+    private static String getValue(CloudEvent cloudEvent, String defaultValue, String protocolKey) {
         try {
-            return cloudEvent.getAttributesOrThrow(ProtocolKey.ENV).getCeString();
+            return cloudEvent.getAttributesOrThrow(protocolKey).getCeString();
         } catch (Exception e) {
             return defaultValue;
         }","[{'comment': 'Maybe it would be better to put the utility method at the top or bottom of the method calls.', 'commenter': 'Pil0tXia'}, {'comment': 'Moved on top.', 'commenter': 'maxim-zgardan'}]"
4337,eventmesh-common/src/main/java/org/apache/eventmesh/common/protocol/grpc/common/EventMeshCloudEventUtils.java,"@@ -363,15 +275,15 @@ public static String getDataContent(CloudEvent cloudEvent) {
     public static String getDataContent(final CloudEvent cloudEvent, String defaultValue) {
         String dataContentType = getDataContentType(cloudEvent);
         if (ProtoSupport.isTextContent(dataContentType)) {
-            return Optional.ofNullable(cloudEvent.getTextData()).orElse(defaultValue);
+            return Optional.of(cloudEvent.getTextData()).orElse(defaultValue);","[{'comment': 'After making this modification, does `orElse()`  become redundant?', 'commenter': 'pandaapo'}]"
4337,eventmesh-common/src/main/java/org/apache/eventmesh/common/protocol/grpc/common/EventMeshCloudEventUtils.java,"@@ -380,7 +292,7 @@ public static Map<String, String> getAttributes(final CloudEvent cloudEvent) {
         if (Objects.isNull(cloudEvent)) {
             return new HashMap<>(0);
         }
-        Map<String, CloudEventAttributeValue> attributesMap = Optional.ofNullable(cloudEvent.getAttributesMap()).orElse(new HashMap<>(0));
+        Map<String, CloudEventAttributeValue> attributesMap = Optional.of(cloudEvent.getAttributesMap()).orElse(new HashMap<>(0));","[{'comment': 'Same as the opinion above.', 'commenter': 'pandaapo'}]"
4340,eventmesh-common/src/test/java/org/apache/eventmesh/common/protocol/http/WebhookProtocolTransportObjectTest.java,"@@ -0,0 +1,63 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.eventmesh.common.protocol.http;
+
+import org.junit.Assert;
+import org.junit.Test;
+
+public class WebhookProtocolTransportObjectTest {
+
+    WebhookProtocolTransportObject webhookProtocolTransportObject = new WebhookProtocolTransportObject(""cloudEventId"", ""eventType"",
+        ""cloudEventName"", ""cloudEventSource"", ""dataContentType"", new byte[] {(byte) 0});
+
+    @Test
+    public void testSetCloudEventId() {
+        webhookProtocolTransportObject.setCloudEventId(""cloudEventId"");
+    }
+
+    @Test
+    public void testSetEventType() {
+        webhookProtocolTransportObject.setEventType(""eventType"");
+    }
+
+    @Test
+    public void testSetCloudEventName() {
+        webhookProtocolTransportObject.setCloudEventName(""cloudEventName"");
+    }
+
+    @Test
+    public void testSetCloudEventSource() {
+        webhookProtocolTransportObject.setCloudEventSource(""cloudEventSource"");
+    }
+
+    @Test
+    public void testSetDataContentType() {
+        webhookProtocolTransportObject.setDataContentType(""dataContentType"");","[{'comment': '`dataContentType` should be `application/json`. Other setters should also be modified to improve readability.', 'commenter': 'Pil0tXia'}, {'comment': 'Corrected.', 'commenter': '847850277'}]"
4340,eventmesh-common/src/test/java/org/apache/eventmesh/common/protocol/http/WebhookProtocolTransportObjectTest.java,"@@ -0,0 +1,63 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.eventmesh.common.protocol.http;
+
+import org.junit.Assert;
+import org.junit.Test;
+
+public class WebhookProtocolTransportObjectTest {
+
+    WebhookProtocolTransportObject webhookProtocolTransportObject = new WebhookProtocolTransportObject(""cloudEventId"", ""eventType"",
+        ""cloudEventName"", ""cloudEventSource"", ""dataContentType"", new byte[] {(byte) 0});
+
+    @Test
+    public void testSetCloudEventId() {
+        webhookProtocolTransportObject.setCloudEventId(""cloudEventId"");
+    }
+
+    @Test
+    public void testSetEventType() {
+        webhookProtocolTransportObject.setEventType(""eventType"");
+    }
+
+    @Test
+    public void testSetCloudEventName() {
+        webhookProtocolTransportObject.setCloudEventName(""cloudEventName"");
+    }
+
+    @Test
+    public void testSetCloudEventSource() {
+        webhookProtocolTransportObject.setCloudEventSource(""cloudEventSource"");
+    }
+
+    @Test
+    public void testSetDataContentType() {
+        webhookProtocolTransportObject.setDataContentType(""dataContentType"");
+    }
+
+    @Test
+    public void testSetBody() {
+        webhookProtocolTransportObject.setBody(new byte[]{(byte) 0});","[{'comment': 'Body bytes can be found in debug mode.', 'commenter': 'Pil0tXia'}, {'comment': 'Corrected.', 'commenter': '847850277'}, {'comment': ""Excuse me, I didn't see any change on `testSetBody`. The `cloudEventId` should be `d0b29520-2bba-11ee-877b-2b18ac132e64`, and cloudEventSource and more should also be modified. Maybe running debug mode once would be a good idea. 😊"", 'commenter': 'Pil0tXia'}, {'comment': 'Corrected.\r\nThank you for pointing out the mistake, I thought fixing this would be enough.\r\n```java\r\n@Before\r\npublic void setUp() {\r\n    webhookProtocolTransportObject = WebhookProtocolTransportObject.builder().build();\r\n}\r\n```\r\n\r\n', 'commenter': '847850277'}, {'comment': 'Not enough. The builder should be used like this. Otherwise, the test will fail.\r\n\r\n```\r\nWebhookProtocolTransportObject webhookProtocolTransportObject = WebhookProtocolTransportObject.builder()\r\n.cloudEventId(cloudEventId).eventType(eventType).cloudEventName(webHookConfig.getCloudEventName())\r\n.cloudEventSource(webHookConfig.getManufacturerDomain())\r\n.dataContentType(webHookConfig.getDataContentType()).body(body).build();\r\n```\r\n\r\nPleas substitute getters with expected value.\r\n\r\nMoreover, as is said above twice, I suggest give full bytes to `body` in `testSetBody`, instead of `0`, as is shown in the screenshot.\r\n\r\n![image](https://github.com/apache/eventmesh/assets/41445332/7203db8f-d9de-4fd2-80d2-6269d19c600a)\r\n\r\nYou may build a byte array with a test string. As is used in `WebHookController`:\r\n\r\n```\r\nByteBuf buf = ((FullHttpRequest) httpRequest).content();\r\nwebHookController.execute(httpRequest.uri(), header, ByteBufUtil.getBytes(buf));\r\n```', 'commenter': 'Pil0tXia'}, {'comment': '> Not enough. The builder should be used like this. Otherwise, the test will fail.\r\n> \r\n> ```\r\n> WebhookProtocolTransportObject webhookProtocolTransportObject = WebhookProtocolTransportObject.builder()\r\n> .cloudEventId(cloudEventId).eventType(eventType).cloudEventName(webHookConfig.getCloudEventName())\r\n> .cloudEventSource(webHookConfig.getManufacturerDomain())\r\n> .dataContentType(webHookConfig.getDataContentType()).body(body).build();\r\n> ```\r\n> \r\n> Pleas substitute getters with expected value.\r\n> \r\n> Moreover, as is said above twice, I suggest give full bytes to `body` in `testSetBody`, instead of `0`, as is shown in the screenshot.\r\n> \r\n> ![image](https://user-images.githubusercontent.com/41445332/258748769-7203db8f-d9de-4fd2-80d2-6269d19c600a.png)\r\n> \r\n> You may build a byte array with a test string. As is used in `WebHookController`:\r\n> \r\n> ```\r\n> ByteBuf buf = ((FullHttpRequest) httpRequest).content();\r\n> webHookController.execute(httpRequest.uri(), header, ByteBufUtil.getBytes(buf));\r\n> ```\r\n\r\nthis builder just create an instance of an empty attribute.\r\nand set body Corrected.\r\n\r\n\r\n```java\r\n@Before\r\npublic void setUp() {\r\n    webhookProtocolTransportObject = WebhookProtocolTransportObject.builder().build();\r\n}\r\n```\r\n\r\n', 'commenter': '847850277'}]"
4340,eventmesh-common/src/test/java/org/apache/eventmesh/common/protocol/http/WebhookProtocolTransportObjectTest.java,"@@ -0,0 +1,78 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.eventmesh.common.protocol.http;
+
+import org.apache.eventmesh.common.Constants;
+import org.apache.eventmesh.common.utils.JsonUtils;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Objects;
+
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.Test;
+
+public class WebhookProtocolTransportObjectTest {
+
+    private WebhookProtocolTransportObject webhookProtocolTransportObject;
+
+    @Before
+    public void setUp() {
+        webhookProtocolTransportObject = WebhookProtocolTransportObject.builder().build();
+    }
+
+    @Test
+    public void testSetCloudEventId() {
+        webhookProtocolTransportObject.setCloudEventId(""d0b29520-2bba-11ee-877b-2b18ac132e64"");
+    }
+","[{'comment': ""I got you. You would like to use setters to build a `WebhookProtocolTransportObject` and test it as a whole. It's OK.\r\n\r\nHowever, as marked above, this is not a Unit Test, because there is no assert judgement in it. The marked snippet is purely a setter, which is a pre-test construction and preparation and should be classified under the `@Before` annotation. \r\n\r\nEach unit test should have an assert judgement. You may read https://eventmesh.apache.org/zh/community/contribute/write-unit-test for more information."", 'commenter': 'Pil0tXia'}]"
4340,eventmesh-common/src/test/java/org/apache/eventmesh/common/protocol/http/WebhookProtocolTransportObjectTest.java,"@@ -0,0 +1,78 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.eventmesh.common.protocol.http;
+
+import org.apache.eventmesh.common.Constants;
+import org.apache.eventmesh.common.utils.JsonUtils;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Objects;
+
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.Test;
+
+public class WebhookProtocolTransportObjectTest {
+
+    private WebhookProtocolTransportObject webhookProtocolTransportObject;
+
+    @Before
+    public void setUp() {
+        webhookProtocolTransportObject = WebhookProtocolTransportObject.builder().build();
+    }
+
+    @Test
+    public void testSetCloudEventId() {
+        webhookProtocolTransportObject.setCloudEventId(""d0b29520-2bba-11ee-877b-2b18ac132e64"");
+    }
+
+    @Test
+    public void testSetEventType() {
+        webhookProtocolTransportObject.setEventType(""github.all"");
+    }
+
+    @Test
+    public void testSetCloudEventName() {
+        webhookProtocolTransportObject.setCloudEventName(""github-eventmesh"");
+    }
+
+    @Test
+    public void testSetCloudEventSource() {
+        webhookProtocolTransportObject.setCloudEventSource(""www.github.com"");
+    }
+
+    @Test
+    public void testSetDataContentType() {
+        webhookProtocolTransportObject.setDataContentType(""application/json"");
+    }
+
+    @Test
+    public void testSetBody() {
+        Map<String, Object> bodyMap = new HashMap<>();
+        bodyMap.put(""user"", ""tom"");
+        bodyMap.put(""password"", ""123456"");
+        webhookProtocolTransportObject.setBody(Objects.requireNonNull(JsonUtils.toJSONString(bodyMap)).getBytes(Constants.DEFAULT_CHARSET));
+    }
+
+    @Test
+    public void testBuilder() {
+        WebhookProtocolTransportObject.WebhookProtocolTransportObjectBuilder result = WebhookProtocolTransportObject.builder();
+        Assert.assertNotNull(result);","[{'comment': 'As the final judgement Object, `assertNotNull` is not recommended, how about `assertEqual`.', 'commenter': 'Pil0tXia'}, {'comment': 'It is recommended to use `assertEquals` here to determine whether the WebhookProtocolTransportObject has actually been constructed with the expected values.\r\n\r\nYou may use a builder to build another object and assert it with the one that you have set up in your own test class:\r\n\r\n```java\r\nWebhookProtocolTransportObject webhookProtocolTransportObject = WebhookProtocolTransportObject.builder()\r\n            .cloudEventId(cloudEventId).eventType(eventType).cloudEventName(webHookConfig.getCloudEventName())\r\n            .cloudEventSource(webHookConfig.getManufacturerDomain())\r\n            .dataContentType(webHookConfig.getDataContentType()).body(body).build();\r\n```', 'commenter': 'Pil0tXia'}]"
4340,eventmesh-common/src/test/java/org/apache/eventmesh/common/protocol/http/WebhookProtocolTransportObjectTest.java,"@@ -0,0 +1,78 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.eventmesh.common.protocol.http;
+
+import org.apache.eventmesh.common.Constants;
+import org.apache.eventmesh.common.utils.JsonUtils;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Objects;
+
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.Test;
+
+public class WebhookProtocolTransportObjectTest {
+
+    private WebhookProtocolTransportObject webhookProtocolTransportObject;
+
+    @Before
+    public void setUp() {
+        webhookProtocolTransportObject = WebhookProtocolTransportObject.builder().build();
+    }
+
+    @Test
+    public void testSetCloudEventId() {
+        webhookProtocolTransportObject.setCloudEventId(""d0b29520-2bba-11ee-877b-2b18ac132e64"");
+    }
+
+    @Test
+    public void testSetEventType() {
+        webhookProtocolTransportObject.setEventType(""github.all"");
+    }
+
+    @Test
+    public void testSetCloudEventName() {
+        webhookProtocolTransportObject.setCloudEventName(""github-eventmesh"");
+    }
+
+    @Test
+    public void testSetCloudEventSource() {
+        webhookProtocolTransportObject.setCloudEventSource(""www.github.com"");
+    }
+
+    @Test
+    public void testSetDataContentType() {
+        webhookProtocolTransportObject.setDataContentType(""application/json"");
+    }
+
+    @Test
+    public void testSetBody() {
+        Map<String, Object> bodyMap = new HashMap<>();
+        bodyMap.put(""user"", ""tom"");
+        bodyMap.put(""password"", ""123456"");","[{'comment': 'The web request body is usually a json string instead of a Map. For example:\r\n\r\n```json\r\n{\r\n  ""zen"": ""Design for failure."",\r\n  ""hook_id"": 425906842,\r\n  ""hook"": {\r\n    ""type"": ""Repository"",\r\n    ""name"": ""web"",\r\n    ""events"": [\r\n      ""*""\r\n    ],\r\n    ""config"": {\r\n      ""insecure_ssl"": ""0"",\r\n      ""url"": ""http://eventmesh.example.com:10106/webhook/github/eventmesh/all""\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nThis does not affect the validation of the method, but the sample in the test class is an important hint to give developers examples of the data format.', 'commenter': 'Pil0tXia'}, {'comment': 'fixed.', 'commenter': '847850277'}, {'comment': ""In fact, you should compare the byte array of the body, not two hashmaps. you just need to convert a piece of **STRING** (the received web request, the actual value) to a byte array, and then construct an expected value on your own, convert it to a byte array and compare it to the former. This is enough.\r\n\r\nFor example:\r\n\r\n```java\r\nString request = '...';\r\nbyte[] expectedBody = ...;\r\nAssert.assertEquals(expectedBody, actualBody);\r\n```"", 'commenter': 'Pil0tXia'}]"
4405,eventmesh-runtime/build.gradle,"@@ -38,6 +38,7 @@ dependencies {
     implementation project("":eventmesh-storage-plugin:eventmesh-storage-api"")
     implementation project("":eventmesh-storage-plugin:eventmesh-storage-standalone"")
     implementation project("":eventmesh-storage-plugin:eventmesh-storage-rocketmq"")
+    implementation project("":eventmesh-storage-plugin:eventmesh-storage-redis"")","[{'comment': 'Please revert config change.', 'commenter': 'Pil0tXia'}]"
4405,eventmesh-storage-plugin/eventmesh-storage-redis/src/main/java/org/apache/eventmesh/storage/redis/admin/RedisAdmin.java,"@@ -0,0 +1,68 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.eventmesh.storage.redis.admin;
+
+import org.apache.eventmesh.api.admin.AbstractAdmin;
+import org.apache.eventmesh.api.admin.TopicProperties;
+import org.apache.eventmesh.storage.redis.client.RedissonClient;
+
+import java.util.List;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.stream.Collectors;
+
+import org.redisson.Redisson;
+import org.redisson.api.RPatternTopic;
+import org.redisson.api.RTopic;
+
+import io.cloudevents.CloudEvent;
+
+public class RedisAdmin extends AbstractAdmin {
+
+    private final Redisson redisson;
+
+    public RedisAdmin() {
+        super(new AtomicBoolean(false));
+        redisson = RedissonClient.INSTANCE;
+    }
+
+    @Override
+    public List<TopicProperties> getTopic() throws Exception {
+        RPatternTopic patternTopic = redisson.getPatternTopic(""*"");
+        return patternTopic.getPatternNames()
+            .stream()
+            .map(s -> new TopicProperties(s, 0))
+            .collect(Collectors.toList());
+    }
+
+    @Override
+    public void createTopic(String topicName) throws Exception {
+        // Just subscribe it directly, no need to create it first.","[{'comment': 'In that case, can the subscription logic be written here?', 'commenter': 'pandaapo'}, {'comment': ""The subscription logic is in `RedisConsumer` and is called by Consumer API. I don't think it is needed here."", 'commenter': 'fabian4'}, {'comment': ""Through your reply, I found that our understanding of the admin function is different. The admin function boundary that I understand is a bit larger. Of course, I am not sure if the community has a clear definition of this aspect. So let's take a look at the community's response to this, and if there is no response, ignore this review.\r\n\r\n---\r\n\r\n通过你的回复我发现我们对于admin功能的理解不同。我所理解的admin功能边界更大一些。当然我也不清楚社区对这方面有没有明确界定。所以看社区对此的反应吧，如果没有反应就忽略这条review。"", 'commenter': 'pandaapo'}, {'comment': '@fabian4 `createTopic` is used to manually create a topic on eventmesh-dashboard, it has little to do with consumers. This method will eventually be called by the TopicHandler to provide an endpoint.', 'commenter': 'Pil0tXia'}, {'comment': 'So since Redis does not need to create it first, we can leave it this way. Am I right? @Pil0tXia ', 'commenter': 'fabian4'}, {'comment': ""@fabian4 The functionality of storing events and messages using the storage-plugin is managed by consumers and producers. The function of managing event storage topics is the responsibility of the admin.\r\n\r\nIt's ok to temporarily not implement this method, but that doesn't mean the method doesn't need to be implemented. Therefore, the comments here are misleading."", 'commenter': 'Pil0tXia'}, {'comment': '@fabian4 This comment is better substituted with a TODO.', 'commenter': 'Pil0tXia'}]"
4405,eventmesh-storage-plugin/eventmesh-storage-redis/src/main/java/org/apache/eventmesh/storage/redis/admin/RedisAdmin.java,"@@ -0,0 +1,68 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.eventmesh.storage.redis.admin;
+
+import org.apache.eventmesh.api.admin.AbstractAdmin;
+import org.apache.eventmesh.api.admin.TopicProperties;
+import org.apache.eventmesh.storage.redis.client.RedissonClient;
+
+import java.util.List;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.stream.Collectors;
+
+import org.redisson.Redisson;
+import org.redisson.api.RPatternTopic;
+import org.redisson.api.RTopic;
+
+import io.cloudevents.CloudEvent;
+
+public class RedisAdmin extends AbstractAdmin {
+
+    private final Redisson redisson;
+
+    public RedisAdmin() {
+        super(new AtomicBoolean(false));
+        redisson = RedissonClient.INSTANCE;
+    }
+
+    @Override
+    public List<TopicProperties> getTopic() throws Exception {
+        RPatternTopic patternTopic = redisson.getPatternTopic(""*"");","[{'comment': 'Will there be performance issues due to the wide range of ""*"" matches? If there is such a possibility, how about writing ""TODO"" to explain this situation?', 'commenter': 'pandaapo'}, {'comment': ""https://github.com/redisson/redisson/wiki/6.-distributed-objects#671-topic-pattern\r\n\r\nWe can only use pattern to get the topic since we don't know what's the topic exactlly. I haven't found a way to do this more efficiently."", 'commenter': 'fabian4'}, {'comment': '""TODO"", sometimes it\'s just to mark problems that cannot be solved at present. For example, a preliminary simple idea is to set a configuration parameter to limit the number of matches in order to prevent potential performance issues.\r\n\r\n---\r\n\r\n“TODO”嘛，有些时候不就是为了标记目前解决不了的问题嘛。比如一个粗糙且简单的思路：为了防止可能出现的性能问题，通过一个配置参数来限制匹配的数量。', 'commenter': 'pandaapo'}]"
4462,eventmesh-runtime/src/main/java/org/apache/eventmesh/runtime/core/protocol/grpc/consumer/consumergroup/StreamTopicConfig.java,"@@ -40,19 +40,23 @@ public class StreamTopicConfig extends ConsumerGroupTopicConfig {
     /**
      * Key: IDC Value: list of emitters with Client_IP:port
      */
-    private final transient Map<String, Map<String, EventEmitter<CloudEvent>>> idcEmitterMap = new ConcurrentHashMap<>();
+    private final Map<String, Map<String, EventEmitter<CloudEvent>>> idcEmitterMap = new ConcurrentHashMap<>();
 
     /**
      * Key: IDC Value: list of emitters
      */
-    private transient Map<String, List<EventEmitter<CloudEvent>>> idcEmitters = new ConcurrentHashMap<>();
+    private Map<String, List<EventEmitter<CloudEvent>>> idcEmitters = new ConcurrentHashMap<>();
 
-    private transient List<EventEmitter<CloudEvent>> totalEmitters = new ArrayList<>();
+    private List<EventEmitter<CloudEvent>> totalEmitters = new ArrayList<>();
 
     public StreamTopicConfig(final String consumerGroup, final String topic, final SubscriptionMode subscriptionMode) {
         super(consumerGroup, topic, subscriptionMode, GrpcType.STREAM);
     }
 
+    public String createKey(String ip, String pid) {
+        return ip + "":"" + pid;
+    }
+","[{'comment': '1. It will be better to mark this method with `private` modifier.\r\n2. `concat()` is better than `+` operator here. The concat() method is more strict in what it accepts and has a better performance.\r\n3. Maybe the `concatKey()` method name will be better, because the key has been provided instead of `Generated`.', 'commenter': 'Pil0tXia'}, {'comment': 'thanks!', 'commenter': 'pandalee99'}]"
4462,eventmesh-runtime/src/test/java/org/apache/eventmesh/runtime/demo/CClientDemo.java,"@@ -45,13 +42,10 @@ public static void main(String[] args) throws Exception {
         client.justSubscribe(ASYNC_TOPIC, SubscriptionMode.CLUSTERING, SubscriptionType.ASYNC);
         client.justSubscribe(BROADCAST_TOPIC, SubscriptionMode.BROADCASTING, SubscriptionType.ASYNC);
         client.listen();
-        client.registerSubBusiHandler(new ReceiveMsgHook() {
-            @Override
-            public void handle(Package msg, ChannelHandlerContext ctx) {
-                if (msg.getHeader().getCmd() == Command.ASYNC_MESSAGE_TO_CLIENT || msg.getHeader().getCmd() == Command.BROADCAST_MESSAGE_TO_CLIENT) {
-                    if (log.isInfoEnabled()) {
-                        log.info(""receive message: {}"", msg);
-                    }
+        client.registerSubBusiHandler((msg, ctx) -> {
+            if (msg.getHeader().getCmd() == Command.ASYNC_MESSAGE_TO_CLIENT || msg.getHeader().getCmd() == Command.BROADCAST_MESSAGE_TO_CLIENT) {
+                if (log.isInfoEnabled()) {
+                    log.info(""receive message: {}"", msg);","[{'comment': 'These modifications has been merged in your PR #4461.\r\nYou should create a new branch to do your work. Otherwise, the merged code will be resubmitted.', 'commenter': 'pandaapo'}, {'comment': 'Yes, a new branch is needed to resolve another issue.\r\n\r\n![image](https://github.com/apache/eventmesh/assets/41445332/657fa3d7-fd04-41f2-af3a-23c79722f97a)\r\n', 'commenter': 'Pil0tXia'}, {'comment': 'I see. Thanks for the guidance!', 'commenter': 'pandalee99'}]"
4465,eventmesh-runtime/src/main/java/org/apache/eventmesh/runtime/core/protocol/tcp/client/EventMeshTcp2Client.java,"@@ -54,13 +54,11 @@ public static InetSocketAddress serverGoodby2Client(TCPThreadPoolGroup tcpThread
             Package msg = new Package();
             msg.setHeader(new Header(SERVER_GOODBYE_REQUEST, OPStatus.SUCCESS.getCode(),
                 ""graceful normal quit from eventmesh"", null));
-
-            tcpThreadPoolGroup.getScheduler().submit(new Runnable() {
-                @Override
-                public void run() {
+              tcpThreadPoolGroup.getScheduler().submit(() -> {
+                  
                     long taskExecuteTime = System.currentTimeMillis();
                     Utils.writeAndFlush(msg, startTime, taskExecuteTime, session.getContext(), session);
-                }
+                  
             });","[{'comment': 'Please remove this blank line.', 'commenter': 'Pil0tXia'}]"
4468,eventmesh-connectors/eventmesh-connector-rocketmq/src/main/resources/source-config.yml,"@@ -26,7 +26,7 @@ pubSubConfig:
     passWord: rocketmqPassWord
 connectorConfig:
     connectorName: rocketmqSource
-    nameserver: 127.0.0.1:9877
+    nameserver: 192.168.123.50:9876","[{'comment': 'Using 127.0.0.1:9876 might be a better choice', 'commenter': 'mxsm'}, {'comment': 'Yes, the original port was mistaking.', 'commenter': 'Pil0tXia'}]"
4468,eventmesh-runtime/conf/eventmesh.properties,"@@ -72,7 +72,7 @@ eventMesh.server.blacklist.ipv4=0.0.0.0/8,127.0.0.0/8,169.254.0.0/16,255.255.255
 eventMesh.server.blacklist.ipv6=::/128,::1/128,ff00::/8
 
 #connector plugin
-eventMesh.connector.plugin.type=standalone
+eventMesh.connector.plugin.type=rocketmq","[{'comment': 'Use standalone', 'commenter': 'mxsm'}, {'comment': ""Thank you for reviewing! Yes, you may notice that these config changes come from these commits:\r\n\r\n![image](https://github.com/apache/eventmesh/assets/41445332/d1fbcc75-9902-477a-839b-22e00b1aad59)\r\n\r\nBecause this PR is still a draft and WIP before, so these commits haven't been reverted.\r\n\r\nDon't worry, I won't forget it. They are now reverted."", 'commenter': 'Pil0tXia'}]"
4468,eventmesh-admin-new/src/main/java/org/apache/eventmesh/adminnew/EventmeshAdminApplication.java,"@@ -0,0 +1,30 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.eventmesh.adminnew;
+
+import org.springframework.boot.SpringApplication;
+import org.springframework.boot.autoconfigure.SpringBootApplication;
+
+@SpringBootApplication
+public class EventmeshAdminApplication {","[{'comment': 'change to EventMeshAdminApplication', 'commenter': 'xwm1992'}, {'comment': 'Done~ The `eventmesh-admin-kotlin` module has the M capitalised, and the changes have not been synchronised in the `eventmesh-admin-new` module. This has now been fixed.', 'commenter': 'Pil0tXia'}]"
4468,eventmesh-admin-new/src/test/java/org/apache/eventmesh/adminnew/EventmeshAdminApplicationTests.java,"@@ -0,0 +1,30 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.eventmesh.adminnew;
+
+import org.junit.jupiter.api.Test;
+import org.springframework.boot.test.context.SpringBootTest;
+
+@SpringBootTest
+class EventmeshAdminApplicationTests {","[{'comment': 'change to EventMeshAdminApplicationTests', 'commenter': 'xwm1992'}, {'comment': 'Done~', 'commenter': 'Pil0tXia'}]"
4469,eventmesh-runtime/src/test/java/org/apache/eventmesh/runtime/demo/BroadCastSubClient.java,"@@ -31,28 +30,57 @@
 
 
 import lombok.extern.slf4j.Slf4j;
+public class ReplacedWithLambda implements SubClientImpl {
+
+    public ReplacedWithLambda() {
+        super(""localhost"", 10000, MessageUtils.generateSubServer());
+    }
+
+    @Override
+    public void handle(Package msg, ChannelHandlerContext ctx) {
+        if (msg.getHeader().getCommand() == Command.BROADCAST_MESSAGE_TO_CLIENT) {
+            if (msg.getBody() instanceof EventMeshMessage) {
+                String body = ((EventMeshMessage) msg.getBody()).getBody();
+                if (log.isInfoEnabled()) {
+                    log.info(""receive message -------------------------------"" + body);
+                }
+            }
+        }
+    }
+}
+
+
 
-@Slf4j
 public class BroadCastSubClient {
 
     public static void main(String[] args) throws Exception {
-        try (SubClientImpl client = new SubClientImpl(""localhost"", 10000, MessageUtils.generateSubServer())) {
+        try (ReplacedWithLambda client = new ReplacedWithLambda()) {
             client.init();
             client.heartbeat();
             client.justSubscribe(ClientConstants.BROADCAST_TOPIC, SubscriptionMode.BROADCASTING, SubscriptionType.ASYNC);
-            client.registerBusiHandler(new ReceiveMsgHook() {
-                @Override
-                public void handle(Package msg, ChannelHandlerContext ctx) {
-                    if (msg.getHeader().getCommand() == Command.BROADCAST_MESSAGE_TO_CLIENT) {
-                        if (msg.getBody() instanceof EventMeshMessage) {
-                            String body = ((EventMeshMessage) msg.getBody()).getBody();
-                            if (log.isInfoEnabled()) {
-                                log.info(""receive message -------------------------------"" + body);
-                            }
-                        }
-                    }
-                }
-            });
+
+            client.registerBusiHandler(new ReceiveMsgHook());
+            client.handle();
+
         }
     }
 }
+
+            //client.registerBusiHandler(new ReceiveMsgHook() {
+
+               // @Override
+//                public void handle(Package msg, ChannelHandlerContext ctx)-> {
+//                    if (msg.getHeader().getCommand() == Command.BROADCAST_MESSAGE_TO_CLIENT) {
+//                        if (msg.getBody() instanceof EventMeshMessage) {
+//                            String body = ((EventMeshMessage) msg.getBody()).getBody();
+//                            if (log.isInfoEnabled()) {
+//                                log.info(""receive message -------------------------------""+body);
+//                            }
+//                        }
+//                    }
+//                }
+          //  });
+//
+//        }
+//    }
+//}","[{'comment': 'Unused comments may be removed.', 'commenter': 'Pil0tXia'}]"
4477,eventmesh-connectors/eventmesh-connector-spring/src/main/java/org/apache/eventmesh/connector/spring/source/MessageSendingOperations.java,"@@ -0,0 +1,40 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.eventmesh.connector.spring.source;
+
+import org.apache.eventmesh.common.enums.ProtocolType;
+
+/**
+ * Operations for sending messages to a destination.
+ */
+public interface MessageSendingOperations {","[{'comment': ""Shouldn't these behaviors be behaviors of a Sink according to the design of eventmesh?"", 'commenter': 'pandaapo'}, {'comment': 'It has been completed in a new round of submissions.', 'commenter': 'yanrongzhen'}, {'comment': ""I am still confused about the Source you have implemented. You start the Source Connector Server by launching it through the Spring container, but after your Source is started, the `queue` of `SpringSourceConnector` is always empty, and I didn't see any behavior of obtaining data from a source in any form during the startup process.\r\nCould you explain it?\r\n\r\n---\r\n我对你实现的Source仍然有困惑。你通过Spring容器启动来启动Source Connector Server，但是你的Source启动完成后，`SpringSourceConnector`的`queue`一直是空的，在启动过程中我好像没看到从某个源以某种形式获取数据的行为。\r\n你能否解答一下？"", 'commenter': 'pandaapo'}, {'comment': 'Since the source side is the user system itself, the user needs to actively send the message to the queue by calling the send method of the `SpringSourceConnector`.', 'commenter': 'yanrongzhen'}, {'comment': ""Are you sure this is the design of the Source Connector in the community? This means that the continuous invocation of the poll method on the source after runtime startup will be limited by the user's call to `MessageSendingOperations#send()`.\r\n\r\n---\r\n你确定这是社区对于Source Connnector的设计吗？这样runtime启动以后对source的poll方法的不断调用要受限于用户对`MessageSendingOperations#send()`的手动调用。"", 'commenter': 'pandaapo'}, {'comment': ""> I am still confused about the Source you have implemented. You start the Source Connector Server by launching it through the Spring container, but after your Source is started, the `queue` of `SpringSourceConnector` is always empty, and I didn't see any behavior of obtaining data from a source in any form during the startup process. Could you explain it?\r\n> \r\n> ---\r\n> 我对你实现的Source仍然有困惑。你通过Spring容器启动来启动Source Connector Server，但是你的Source启动完成后，`SpringSourceConnector`的`queue`一直是空的，在启动过程中我好像没看到从某个源以某种形式获取数据的行为。 你能否解答一下？\r\n>\r\n>> Since the source side is the user system itself, the user needs to actively send the message to the queue by calling the send method of the `SpringSourceConnector`\r\n>>\r\n>>> Are you sure this is the design of the Source Connector in the community? This means that the continuous invocation of the poll method on the source after runtime startup will be limited by the user's call to `MessageSendingOperations#send()`.\r\n>>>\r\n>>> ---\r\n>>> 你确定这是社区对于Source Connnector的设计吗？这样runtime启动以后对source的poll方法的不断调用要受限于用户对`MessageSendingOperations#send()`的手动调用。\r\n\r\n@xwm1992 Can the Source Connector be designed like this now?"", 'commenter': 'pandaapo'}, {'comment': ""> > I am still confused about the Source you have implemented. You start the Source Connector Server by launching it through the Spring container, but after your Source is started, the `queue` of `SpringSourceConnector` is always empty, and I didn't see any behavior of obtaining data from a source in any form during the startup process. Could you explain it?\r\n> > \r\n> > 我对你实现的Source仍然有困惑。你通过Spring容器启动来启动Source Connector Server，但是你的Source启动完成后，`SpringSourceConnector`的`queue`一直是空的，在启动过程中我好像没看到从某个源以某种形式获取数据的行为。 你能否解答一下？\r\n> > > Since the source side is the user system itself, the user needs to actively send the message to the queue by calling the send method of the `SpringSourceConnector`\r\n> > > > Are you sure this is the design of the Source Connector in the community? This means that the continuous invocation of the poll method on the source after runtime startup will be limited by the user's call to `MessageSendingOperations#send()`.\r\n> > > > \r\n> > > > 你确定这是社区对于Source Connnector的设计吗？这样runtime启动以后对source的poll方法的不断调用要受限于用户对`MessageSendingOperations#send()`的手动调用。\r\n> \r\n> @xwm1992 Can the Source Connector be designed like this now?\r\n\r\nspring source connector poll message from the memory queue is ok, for spring application user need send the message to the local queue for source connector poll."", 'commenter': 'xwm1992'}]"
4477,eventmesh-common/src/main/java/org/apache/eventmesh/common/enums/EventMeshMessageProtocolType.java,"@@ -17,24 +17,24 @@
 
 package org.apache.eventmesh.common.enums;
 
-public enum EventMeshProtocolType {
+public enum EventMeshMessageProtocolType {
 
     CLOUD_EVENTS(""cloudevents""),
     EVENT_MESH_MESSAGE(""eventmeshmessage""),
     OPEN_MESSAGE(""openmessage"");
 ","[{'comment': '`EventMeshMessageProtocolType` class name is duplicate with its member `EVENT_MESH_MESSAGE(""eventmeshmessage"")`. It\'s better to rename to `MessageProtocolType` if no more conflicts.', 'commenter': 'Pil0tXia'}, {'comment': 'It has been rolled back and changed to the original name.', 'commenter': 'yanrongzhen'}]"
4477,eventmesh-sdks/eventmesh-sdk-java/src/main/java/org/apache/eventmesh/client/IProducer.java,"@@ -0,0 +1,55 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.eventmesh.client;
+
+import org.apache.eventmesh.client.http.producer.RRCallback;
+
+import java.util.List;
+
+import lombok.SneakyThrows;
+
+/**
+ * Producer interface.
+ */
+public interface IProducer {
+","[{'comment': 'The `C` naming style is not recommended. You may put this class in a package.', 'commenter': 'Pil0tXia'}, {'comment': 'done', 'commenter': 'yanrongzhen'}]"
4477,eventmesh-sdks/eventmesh-sdk-java/src/main/java/org/apache/eventmesh/client/grpc/consumer/EventMeshGrpcConsumer.java,"@@ -128,8 +129,9 @@ public void subscribe(final List<SubscriptionItem> subscriptionItems) {
 
         addSubscription(subscriptionItems, SDK_STREAM_URL);
 
-        CloudEvent subscription = EventMeshCloudEventBuilder.buildEventSubscription(clientConfig, EventMeshProtocolType.EVENT_MESH_MESSAGE, null,
-            subscriptionItems);
+        CloudEvent subscription =
+            EventMeshCloudEventBuilder.buildEventSubscription(clientConfig, EventMeshMessageProtocolType.EVENT_MESH_MESSAGE, null,
+                subscriptionItems);
         synchronized (this) {","[{'comment': '![image](https://github.com/apache/eventmesh/assets/41445332/712ff47d-bf9c-49aa-9c53-98a455965452)\r\n\r\n![image](https://github.com/apache/eventmesh/assets/41445332/496d6d0a-2f6e-431c-9ed4-bdaf4c2d64b7)\r\n\r\nThe former one seems confusing and the later one will be enough.', 'commenter': 'Pil0tXia'}, {'comment': ""It looks like due to spotless code formatting, I'll try to fix it in another issue later."", 'commenter': 'yanrongzhen'}]"
4477,eventmesh-connectors/eventmesh-connector-spring/src/main/java/org/apache/eventmesh/connector/spring/source/connector/SpringSourceConnector.java,"@@ -0,0 +1,115 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.eventmesh.connector.spring.source.connector;
+
+import org.apache.eventmesh.connector.spring.source.MessageSendingOperations;
+import org.apache.eventmesh.connector.spring.source.config.SpringSourceConfig;
+import org.apache.eventmesh.openconnect.api.config.Config;
+import org.apache.eventmesh.openconnect.api.connector.ConnectorContext;
+import org.apache.eventmesh.openconnect.api.connector.SourceConnectorContext;
+import org.apache.eventmesh.openconnect.api.source.Source;
+import org.apache.eventmesh.openconnect.offsetmgmt.api.data.ConnectRecord;
+import org.apache.eventmesh.openconnect.offsetmgmt.api.data.RecordOffset;
+import org.apache.eventmesh.openconnect.offsetmgmt.api.data.RecordPartition;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.concurrent.BlockingQueue;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.TimeUnit;
+
+import lombok.extern.slf4j.Slf4j;
+
+@Slf4j
+public class SpringSourceConnector implements Source, MessageSendingOperations {
+
+    private static final int DEFAULT_BATCH_SIZE = 10;
+
+    private SpringSourceConfig sourceConfig;
+
+    private BlockingQueue<ConnectRecord> queue;
+
+    @Override
+    public Class<? extends Config> configClass() {
+        return SpringSourceConfig.class;
+    }
+
+    @Override
+    public void init(Config config) throws Exception {
+        // init config for spring source connector
+        this.sourceConfig = (SpringSourceConfig) config;
+        this.queue = new LinkedBlockingQueue<>(1000);
+    }
+
+    @Override
+    public void init(ConnectorContext connectorContext) throws Exception {
+        SourceConnectorContext sourceConnectorContext = (SourceConnectorContext) connectorContext;
+        // init config for spring source connector
+        this.sourceConfig = (SpringSourceConfig) sourceConnectorContext.getSourceConfig();
+        this.queue = new LinkedBlockingQueue<>(1000);
+    }
+
+    @Override
+    public void start() throws Exception {
+
+    }
+
+    @Override
+    public void commit(ConnectRecord record) {
+
+    }
+
+    @Override
+    public String name() {
+        return this.sourceConfig.getSourceConnectorConfig().getConnectorName();
+    }
+
+    @Override
+    public void stop() throws Exception {
+
+    }
+
+    @Override
+    public List<ConnectRecord> poll() {
+        List<ConnectRecord> connectRecords = new ArrayList<>(DEFAULT_BATCH_SIZE);
+
+        for (int count = 0; count < DEFAULT_BATCH_SIZE; ++count) {
+            try {
+                ConnectRecord connectRecord = queue.poll(3, TimeUnit.SECONDS);
+                if (connectRecord == null) {
+                    break;
+                }
+                connectRecords.add(connectRecord);
+            } catch (InterruptedException e) {
+                Thread currentThread = Thread.currentThread();
+                log.warn(""[SpringSourceConnector] Interrupting thread {} due to exception {}"",
+                    currentThread.getName(), e.getMessage());
+                currentThread.interrupt();
+            }
+        }
+        return connectRecords;
+    }
+
+    @Override
+    public void send(Object message) {","[{'comment': 'When users want to call this method to send data to Source, how do users obtain this object?', 'commenter': 'pandaapo'}, {'comment': 'Get SpringSourceConnector from the spring container.', 'commenter': 'yanrongzhen'}]"
4477,eventmesh-openconnect/eventmesh-openconnect-java/src/main/java/org/apache/eventmesh/openconnect/Application.java,"@@ -35,11 +37,20 @@ public class Application {
 
     public static final Map<String, Connector> CONNECTOR_MAP = new HashMap<>();
 
+    private static final String SPRING = ""spring"";
+
     public void run(Class<? extends Connector> clazz) throws Exception {
 
-        Connector connector;
+        Connector connector = null;
         try {
-            connector = clazz.getDeclaredConstructor().newInstance();
+            SourceCreateService createService =
+                EventMeshExtensionFactory.getExtension(SourceCreateService.class, SPRING);
+            if (createService != null) {
+                connector = createService.create();
+            }
+            if (connector == null) {
+                connector = clazz.getDeclaredConstructor().newInstance();
+            }","[{'comment': 'In `Application`, in order to create a specific type of `Connector`, namely the Spring Source Connector, the logic of ""loading SPI with the specified name of Spring"" is added.\r\nIs there some limitation to `Application`? Because `Application` should be a class independent of specific connectors, it is hard to create other specific types of connectors after this modification (your SPI is also designed for other types of connectors).\r\n\r\n---\r\n在`Application`这个类中为了创建某一特定类型的`Connector`，即Spring Source Connector，加入“加载指定名称为Spring的SPI”的逻辑。\r\n是不是使这个类出现了某种限制？因为`Application`应该是独立于具体Connector之上的一个类，这样写了以后，若再出现其他特定类型的Connector需要创建就不好办了（你的SPI也是为了其他类型Connector所设计的）。', 'commenter': 'pandaapo'}]"
4493,eventmesh-connectors/eventmesh-connector-prometheus/src/main/java/org/apache/eventmesh/connector/prometheus/server/PrometheusConnectServer.java,"@@ -0,0 +1,39 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.eventmesh.connector.prometheus.server;
+
+import org.apache.eventmesh.connector.prometheus.config.PrometheusServerConfig;
+import org.apache.eventmesh.connector.prometheus.source.connector.PrometheusSourceConnector;
+import org.apache.eventmesh.openconnect.Application;
+import org.apache.eventmesh.openconnect.util.ConfigUtil;
+
+import lombok.extern.slf4j.Slf4j;
+
+@Slf4j
+public class PrometheusConnectServer {
+
+    public static void main(String[] args) throws Exception {
+
+        PrometheusServerConfig serverConfig = ConfigUtil.parse(PrometheusServerConfig.class, ""server-config.yml"");
+
+        if (serverConfig.isSourceEnable()) {
+            Application kafkaSourceApp = new Application();
+            kafkaSourceApp.run(PrometheusSourceConnector.class);","[{'comment': 'here still `kafkaSourceApp`', 'commenter': 'xwm1992'}, {'comment': ""ok I'll update"", 'commenter': 'willimpo'}]"
4493,eventmesh-connectors/eventmesh-connector-prometheus/src/main/java/org/apache/eventmesh/connector/prometheus/source/connector/PrometheusSourceConnector.java,"@@ -0,0 +1,189 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.eventmesh.connector.prometheus.source.connector;
+
+import com.alibaba.fastjson.JSON;
+import com.alibaba.fastjson.JSONObject;
+import java.nio.charset.StandardCharsets;
+import java.text.MessageFormat;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import lombok.extern.slf4j.Slf4j;
+import org.apache.eventmesh.connector.prometheus.model.QueryPrometheusReq;
+import org.apache.eventmesh.connector.prometheus.model.QueryPrometheusRsp;
+import org.apache.eventmesh.connector.prometheus.source.config.PrometheusSourceConfig;
+import org.apache.eventmesh.openconnect.api.config.Config;
+import org.apache.eventmesh.openconnect.api.connector.ConnectorContext;
+import org.apache.eventmesh.openconnect.api.connector.SourceConnectorContext;
+import org.apache.eventmesh.openconnect.api.source.Source;
+import org.apache.eventmesh.openconnect.offsetmgmt.api.data.ConnectRecord;
+import org.apache.eventmesh.openconnect.offsetmgmt.api.data.RecordOffset;
+import org.apache.eventmesh.openconnect.offsetmgmt.api.data.RecordPartition;
+import org.apache.eventmesh.openconnect.offsetmgmt.api.storage.OffsetStorageReader;
+import org.apache.http.HttpStatus;
+import org.apache.http.client.methods.CloseableHttpResponse;
+import org.apache.http.client.methods.HttpPost;
+import org.apache.http.entity.ContentType;
+import org.apache.http.entity.StringEntity;
+import org.apache.http.impl.client.CloseableHttpClient;
+import org.apache.http.impl.client.HttpClientBuilder;
+import org.apache.http.util.EntityUtils;
+
+@Slf4j
+public class PrometheusSourceConnector implements Source {
+
+    private static final String INSTANCE_ID = ""instanceId"";
+
+    private OffsetStorageReader offsetStorageReader;
+
+    private PrometheusSourceConfig sourceConfig;
+
+    private CloseableHttpClient httpClient;
+
+    private QueryPrometheusReq queryPrometheusReq;
+
+    private Long startTime;
+
+    private Long initTime;
+
+    private Integer interval;
+
+    private String url;
+
+    @Override
+    public Class<? extends Config> configClass() {
+        return PrometheusSourceConfig.class;
+    }
+
+    @Override
+    public void init(Config config) throws Exception {
+        this.sourceConfig = (PrometheusSourceConfig) config;
+        doInit();
+    }
+
+    @Override
+    public void init(ConnectorContext connectorContext) throws Exception {
+        SourceConnectorContext sourceConnectorContext = (SourceConnectorContext) connectorContext;
+        this.sourceConfig = (PrometheusSourceConfig) sourceConnectorContext.getSourceConfig();
+        this.offsetStorageReader = sourceConnectorContext.getOffsetStorageReader();
+
+        doInit();
+    }
+
+    private void doInit() {
+        queryPrometheusReq = new QueryPrometheusReq();
+        queryPrometheusReq.setQuery(sourceConfig.getConnectorConfig().getQuery());
+        queryPrometheusReq.setStep(sourceConfig.getConnectorConfig().getStep());
+
+        interval = sourceConfig.getConnectorConfig().getInterval();
+        initTime = sourceConfig.getConnectorConfig().getInitTime();
+
+        url = MessageFormat.format(""{0}/{1}"", sourceConfig.getConnectorConfig().getAddress(), sourceConfig.getConnectorConfig().getApi());
+
+        httpClient = HttpClientBuilder.create().build();
+    }
+
+    @Override
+    public void start() throws Exception {
+        log.info(""prometheus source connector start."");
+
+        Map<String, String> partitionMap = new HashMap<>();
+        partitionMap.put(INSTANCE_ID, sourceConfig.getConnectorConfig().getConnectorId());
+        RecordPartition recordPartition = new RecordPartition(partitionMap);
+        RecordOffset recordOffset = offsetStorageReader.readOffset(recordPartition);","[{'comment': 'why you use the recordOffset and offsetStorageReader for prometheus connector?', 'commenter': 'xwm1992'}, {'comment': 'In prometheus source connector ,I read data from prometheus server with time range, and use recordOffset to save completed timestamp for each query. Is that necessary?', 'commenter': 'willimpo'}, {'comment': 'offsetmgmt is optional and recommended.', 'commenter': 'Pil0tXia'}, {'comment': '> In prometheus source connector ,I read data from prometheus server with time range, and use recordOffset to save completed timestamp for each query. Is that necessary?\r\n\r\nThe purpose of reading and persisting offset is to ensure that message duplication is avoided after the source connector is restarted. Depending on how you use it here, it seems that it will cause ambiguity. I understand that promethues data synchronization should not require offset to avoid ambiguity.\r\n\r\n---\r\noffset 的读取与持久化是为了保证source connector重启后避免消息重复，看你这里用法感觉会造成歧义，我理解promethues的数据同步应该不需要offset，避免歧义', 'commenter': 'xwm1992'}, {'comment': 'OK let me check', 'commenter': 'willimpo'}]"
4493,eventmesh-connectors/eventmesh-connector-prometheus/src/main/java/org/apache/eventmesh/connector/prometheus/source/connector/PrometheusSourceConnector.java,"@@ -0,0 +1,189 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.eventmesh.connector.prometheus.source.connector;
+
+import com.alibaba.fastjson.JSON;
+import com.alibaba.fastjson.JSONObject;
+import java.nio.charset.StandardCharsets;
+import java.text.MessageFormat;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import lombok.extern.slf4j.Slf4j;
+import org.apache.eventmesh.connector.prometheus.model.QueryPrometheusReq;
+import org.apache.eventmesh.connector.prometheus.model.QueryPrometheusRsp;
+import org.apache.eventmesh.connector.prometheus.source.config.PrometheusSourceConfig;
+import org.apache.eventmesh.openconnect.api.config.Config;
+import org.apache.eventmesh.openconnect.api.connector.ConnectorContext;
+import org.apache.eventmesh.openconnect.api.connector.SourceConnectorContext;
+import org.apache.eventmesh.openconnect.api.source.Source;
+import org.apache.eventmesh.openconnect.offsetmgmt.api.data.ConnectRecord;
+import org.apache.eventmesh.openconnect.offsetmgmt.api.data.RecordOffset;
+import org.apache.eventmesh.openconnect.offsetmgmt.api.data.RecordPartition;
+import org.apache.eventmesh.openconnect.offsetmgmt.api.storage.OffsetStorageReader;
+import org.apache.http.HttpStatus;
+import org.apache.http.client.methods.CloseableHttpResponse;
+import org.apache.http.client.methods.HttpPost;
+import org.apache.http.entity.ContentType;
+import org.apache.http.entity.StringEntity;
+import org.apache.http.impl.client.CloseableHttpClient;
+import org.apache.http.impl.client.HttpClientBuilder;
+import org.apache.http.util.EntityUtils;
+
+@Slf4j
+public class PrometheusSourceConnector implements Source {
+
+    private static final String INSTANCE_ID = ""instanceId"";
+
+    private OffsetStorageReader offsetStorageReader;
+
+    private PrometheusSourceConfig sourceConfig;
+
+    private CloseableHttpClient httpClient;
+
+    private QueryPrometheusReq queryPrometheusReq;
+
+    private Long startTime;
+
+    private Long initTime;
+
+    private Integer interval;
+
+    private String url;
+
+    @Override
+    public Class<? extends Config> configClass() {
+        return PrometheusSourceConfig.class;
+    }
+
+    @Override
+    public void init(Config config) throws Exception {
+        this.sourceConfig = (PrometheusSourceConfig) config;
+        doInit();
+    }
+
+    @Override
+    public void init(ConnectorContext connectorContext) throws Exception {
+        SourceConnectorContext sourceConnectorContext = (SourceConnectorContext) connectorContext;
+        this.sourceConfig = (PrometheusSourceConfig) sourceConnectorContext.getSourceConfig();
+        this.offsetStorageReader = sourceConnectorContext.getOffsetStorageReader();
+
+        doInit();
+    }
+
+    private void doInit() {
+        queryPrometheusReq = new QueryPrometheusReq();
+        queryPrometheusReq.setQuery(sourceConfig.getConnectorConfig().getQuery());
+        queryPrometheusReq.setStep(sourceConfig.getConnectorConfig().getStep());
+
+        interval = sourceConfig.getConnectorConfig().getInterval();
+        initTime = sourceConfig.getConnectorConfig().getInitTime();
+
+        url = MessageFormat.format(""{0}/{1}"", sourceConfig.getConnectorConfig().getAddress(), sourceConfig.getConnectorConfig().getApi());
+
+        httpClient = HttpClientBuilder.create().build();
+    }
+
+    @Override
+    public void start() throws Exception {
+        log.info(""prometheus source connector start."");
+
+        Map<String, String> partitionMap = new HashMap<>();
+        partitionMap.put(INSTANCE_ID, sourceConfig.getConnectorConfig().getConnectorId());
+        RecordPartition recordPartition = new RecordPartition(partitionMap);
+        RecordOffset recordOffset = offsetStorageReader.readOffset(recordPartition);
+        if (recordOffset != null) {
+            Long pollOffset = (Long) recordOffset.getOffset().get(""queueOffset"");
+            if (pollOffset != null) {
+                // use offset
+                startTime = pollOffset;
+            } else if (initTime != null) {
+                // use preset time
+                startTime = initTime;
+            } else {
+                // use real time
+                startTime = System.currentTimeMillis() / 1000;
+            }
+        }
+    }
+
+    @Override
+    public void commit(ConnectRecord record) {
+        startTime += interval;
+    }
+
+    @Override
+    public String name() {
+        return this.sourceConfig.getConnectorConfig().getConnectorName();
+    }
+
+    @Override
+    public void stop() throws Exception {
+        log.info(""prometheus source connector stop."");
+    }
+
+    @Override
+    public List<ConnectRecord> poll() {
+        try {
+            queryPrometheusReq.setStart(startTime);
+            queryPrometheusReq.setEnd(startTime + interval);
+
+            HttpPost httpPost = new HttpPost(url);
+            httpPost.setEntity(new StringEntity(JSON.toJSONString(queryPrometheusReq), ContentType.APPLICATION_JSON));
+            CloseableHttpResponse response = httpClient.execute(httpPost);
+            if (response.getStatusLine().getStatusCode() != HttpStatus.SC_OK) {","[{'comment': 'Is it possible to use a keep-alive connection or reuse http connection here? For example, use a PoolingHttpClientConnectionManager.', 'commenter': 'Pil0tXia'}, {'comment': 'yes I agree with you. And I found a feature https://github.com/apache/eventmesh/issues/4481 is planned, so I think I can use directly when ready', 'commenter': 'willimpo'}]"
4493,eventmesh-connectors/eventmesh-connector-prometheus/src/main/java/org/apache/eventmesh/connector/prometheus/source/connector/PrometheusSourceConnector.java,"@@ -0,0 +1,154 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.eventmesh.connector.prometheus.source.connector;
+
+import org.apache.eventmesh.connector.prometheus.model.QueryPrometheusReq;
+import org.apache.eventmesh.connector.prometheus.model.QueryPrometheusRsp;
+import org.apache.eventmesh.connector.prometheus.source.config.PrometheusSourceConfig;
+import org.apache.eventmesh.openconnect.api.config.Config;
+import org.apache.eventmesh.openconnect.api.connector.ConnectorContext;
+import org.apache.eventmesh.openconnect.api.connector.SourceConnectorContext;
+import org.apache.eventmesh.openconnect.api.source.Source;
+import org.apache.eventmesh.openconnect.offsetmgmt.api.data.ConnectRecord;
+import org.apache.eventmesh.openconnect.offsetmgmt.api.data.RecordOffset;
+import org.apache.eventmesh.openconnect.offsetmgmt.api.data.RecordPartition;
+
+import org.apache.http.HttpStatus;
+import org.apache.http.client.methods.CloseableHttpResponse;
+import org.apache.http.client.methods.HttpPost;
+import org.apache.http.entity.ContentType;
+import org.apache.http.entity.StringEntity;
+import org.apache.http.impl.client.CloseableHttpClient;
+import org.apache.http.impl.client.HttpClientBuilder;
+import org.apache.http.util.EntityUtils;
+
+import java.nio.charset.StandardCharsets;
+import java.text.MessageFormat;
+import java.util.ArrayList;
+import java.util.List;
+
+import com.alibaba.fastjson.JSON;
+import com.alibaba.fastjson.JSONObject;
+
+import lombok.extern.slf4j.Slf4j;
+
+@Slf4j
+public class PrometheusSourceConnector implements Source {
+
+    private PrometheusSourceConfig sourceConfig;
+
+    private CloseableHttpClient httpClient;
+
+    private QueryPrometheusReq queryPrometheusReq;
+
+    private Long initTime;
+
+    private Long startTime;
+
+    private Integer interval;
+
+    private String url;
+
+    @Override
+    public Class<? extends Config> configClass() {
+        return PrometheusSourceConfig.class;
+    }
+
+    @Override
+    public void init(Config config) {
+        this.sourceConfig = (PrometheusSourceConfig) config;
+        doInit();
+    }
+
+    @Override
+    public void init(ConnectorContext connectorContext) {
+        SourceConnectorContext sourceConnectorContext = (SourceConnectorContext) connectorContext;
+        this.sourceConfig = (PrometheusSourceConfig) sourceConnectorContext.getSourceConfig();
+
+        doInit();
+    }
+
+    private void doInit() {
+        queryPrometheusReq = new QueryPrometheusReq();
+        queryPrometheusReq.setQuery(sourceConfig.getConnectorConfig().getQuery());
+        queryPrometheusReq.setStep(sourceConfig.getConnectorConfig().getStep());
+
+        interval = sourceConfig.getConnectorConfig().getInterval();
+        initTime = sourceConfig.getConnectorConfig().getInitTime();
+
+        url = MessageFormat.format(""{0}/{1}"", sourceConfig.getConnectorConfig().getAddress(), sourceConfig.getConnectorConfig().getApi());
+
+        httpClient = HttpClientBuilder.create().build();
+    }
+
+    @Override
+    public void start() {
+        log.info(""prometheus source connector start."");
+        startTime = initTime != null ? initTime : System.currentTimeMillis() / 1000;
+    }
+
+    @Override
+    public void commit(ConnectRecord record) {
+        startTime += interval;
+    }
+
+    @Override
+    public String name() {
+        return this.sourceConfig.getConnectorConfig().getConnectorName();
+    }
+
+    @Override
+    public void stop() {
+        log.info(""prometheus source connector stop."");
+    }
+
+    @Override
+    public List<ConnectRecord> poll() {
+        try {
+            queryPrometheusReq.setStart(startTime);
+            queryPrometheusReq.setEnd(startTime + interval);
+
+            HttpPost httpPost = new HttpPost(url);
+            httpPost.setEntity(new StringEntity(JSON.toJSONString(queryPrometheusReq), ContentType.APPLICATION_JSON));
+            CloseableHttpResponse response = httpClient.execute(httpPost);
+            if (response.getStatusLine().getStatusCode() != HttpStatus.SC_OK) {
+                log.error(""failed to poll message from prometheus,http code={}"", response.getStatusLine().getStatusCode());
+                return null;
+            }","[{'comment': 'The network connection is unreliable. So it may be better to add retry logic after the request fails.', 'commenter': 'pandaapo'}, {'comment': ""> The network connection is unreliable. So it may be better to add retry logic after the request fails.\r\n\r\nOK I'll update"", 'commenter': 'willimpo'}]"
4495,eventmesh-sdks/eventmesh-sdk-java/src/main/java/org/apache/eventmesh/client/tcp/common/MessageUtils.java,"@@ -82,7 +84,7 @@ public static Package buildPackage(Object message, Command command) {
         if (message instanceof CloudEvent) {
             final CloudEvent cloudEvent = (CloudEvent) message;
             Preconditions.checkNotNull(cloudEvent.getDataContentType(), ""DateContentType cannot be null"");
-            msg.getHeader().putProperty(Constants.PROTOCOL_TYPE, EventMeshCommon.CLOUD_EVENTS_PROTOCOL_NAME);
+            msg.getHeader().putProperty(Constants.PROTOCOL_TYPE, CLOUD_EVENTS_PROTOCOL_NAME);
             msg.getHeader().putProperty(Constants.PROTOCOL_VERSION, cloudEvent.getSpecVersion().toString());","[{'comment': 'Coding Style differs here. Please use static import only when this class uses single constant class.', 'commenter': 'Pil0tXia'}]"
4495,eventmesh-sdks/eventmesh-sdk-java/src/main/java/org/apache/eventmesh/client/tcp/common/EventMeshCommon.java,"@@ -39,8 +39,6 @@ public class EventMeshCommon {
      */
     public static final String USER_AGENT_PURPOSE_SUB = ""sub"";
 
-    // protocol type
-    public static final String CLOUD_EVENTS_PROTOCOL_NAME = ""cloudevents"";
     public static final String EM_MESSAGE_PROTOCOL_NAME = ""eventmeshmessage"";
     public static final String OPEN_MESSAGE_PROTOCOL_NAME = ""openmessage"";
 }","[{'comment': '`cloudevents` removed but `eventmeshmessage` and `openmessage` remaining here.', 'commenter': 'Pil0tXia'}]"
4495,eventmesh-sdks/eventmesh-sdk-java/src/main/java/org/apache/eventmesh/client/http/ProtocolConstant.java,"@@ -19,7 +19,6 @@
 
 public final class ProtocolConstant {
 
-    public static final String CE_PROTOCOL = ""cloudevents"";
     public static final String EM_MESSAGE_PROTOCOL = ""eventmeshmessage"";
     public static final String OP_MESSAGE_PROTOCOL = ""openmessage"";
     public static final String PROTOCOL_DESC = ""http"";","[{'comment': 'Another `cloudevents` removed but `eventmeshmessage` and `openmessage` remaining here. The protocols are torn apart and still duplicate.\r\n', 'commenter': 'Pil0tXia'}]"
4495,eventmesh-sdks/eventmesh-sdk-java/src/main/java/org/apache/eventmesh/client/tcp/common/MessageUtils.java,"@@ -17,6 +17,8 @@
 
 package org.apache.eventmesh.client.tcp.common;
 
+import static org.apache.eventmesh.common.Constants.CLOUD_EVENTS_PROTOCOL_NAME;
+
 import org.apache.eventmesh.common.Constants;
 import org.apache.eventmesh.common.protocol.SubscriptionItem;","[{'comment': 'Static imports should not be used here, because `Constants` class has already been imported.', 'commenter': 'Pil0tXia'}]"
4506,eventmesh-security-plugin/eventmesh-security-auth-token/src/main/java/org/apache/eventmesh/auth/token/impl/auth/AuthTokenUtils.java,"@@ -136,14 +137,15 @@ public static boolean authAccess(AclProperties aclProperties) {
 
         String topic = aclProperties.getTopic();
 
-        Set<String> groupTopics = (Set<String>) aclProperties.getExtendedField(""topics"");
+        Object topics = aclProperties.getExtendedField(""topics"");
 
-        if (groupTopics.contains(topic)) {
-            return true;
-        } else {
-            return false;
+        if (!(topics instanceof Set)) {
+            throw new RuntimeException(""abc"");","[{'comment': '""abc""?', 'commenter': 'pandaapo'}, {'comment': 'Oops, fixed.', 'commenter': 'yanrongzhen'}]"
4506,eventmesh-security-plugin/eventmesh-security-auth-token/src/main/java/org/apache/eventmesh/auth/token/impl/auth/AuthTokenUtils.java,"@@ -136,14 +137,15 @@ public static boolean authAccess(AclProperties aclProperties) {
 
         String topic = aclProperties.getTopic();
 
-        Set<String> groupTopics = (Set<String>) aclProperties.getExtendedField(""topics"");
+        Object topics = aclProperties.getExtendedField(""topics"");","[{'comment': 'This modification can have impacts on code readability and it is recommended to add some comments if there is no better solution.', 'commenter': 'Pil0tXia'}]"
4507,eventmesh-common/src/main/java/org/apache/eventmesh/common/file/WatchFileTask.java,"@@ -38,10 +40,8 @@ public class WatchFileTask extends Thread {
     private final transient WatchService watchService;
 
     private final transient List<FileChangeListener> fileChangeListeners = new ArrayList<>();
-
-    private transient volatile boolean watch = true;
-
     private final transient String directoryPath;
+    private transient volatile boolean watch = true;
 ","[{'comment': 'Is this modification necessary? The new lines was removed.', 'commenter': 'Pil0tXia'}]"
4507,eventmesh-common/src/main/java/org/apache/eventmesh/common/protocol/tcp/codec/Codec.java,"@@ -50,16 +51,81 @@ public class Codec {
     private static final byte[] CONSTANT_MAGIC_FLAG = serializeBytes(""EventMesh"");
     private static final byte[] VERSION = serializeBytes(""0000"");
 
+    private static Object deserializeBody(String bodyJsonString, Header header) throws JsonProcessingException {
+        Command command = header.getCmd();
+        switch (command) {
+            case HELLO_REQUEST:
+            case RECOMMEND_REQUEST:","[{'comment': 'Private methods should be located at the very bottom of a class.', 'commenter': 'Pil0tXia'}]"
4507,eventmesh-connectors/eventmesh-connector-jdbc/src/main/java/org/apache/eventmesh/connector/jdbc/connection/JdbcConnection.java,"@@ -76,6 +73,29 @@ public JdbcConnection(JdbcConfig jdbcConfig, InitialOperation initialOperation,
         }
     }
 
+    /**
+     * Creates a ConnectionFactory that uses a pattern-based URL with placeholder values.
+     *
+     * @param urlWithPlaceholder The URL pattern with placeholders.
+     * @param replaces           The replacement values for the placeholders.
+     * @return The ConnectionFactory instance.
+     */
+    @SuppressWarnings(""unchecked"")
+    public static ConnectionFactory createPatternConnectionFactory(String urlWithPlaceholder, String... replaces) {
+        return config -> {","[{'comment': ""This static method is called by another class, so you shouldn't move its position and it is recommended to leave it where it was at the bottom of this class.\r\n\r\nThere are other similar places, such as private enums in `MysqlCdcEngine` and those changes should be reverted."", 'commenter': 'Pil0tXia'}]"
4507,eventmesh-connectors/eventmesh-connector-jdbc/src/main/java/org/apache/eventmesh/connector/jdbc/connection/JdbcConnection.java,"@@ -46,13 +47,9 @@ public class JdbcConnection implements AutoCloseable {
     private static final String STATEMENT_DELIMITER = "";"";
 
     private final JdbcConfig jdbcConfig;
-
-    private volatile Connection connection;
-
     private final InitialOperation initialOperation;
-
     private final ConnectionFactory connectionFactory;
-
+    private volatile Connection connection;
     private JdbcDriverMetaData jdbcDriverMetaData;","[{'comment': 'There is no need to change field positions and blank lines are missing.\r\n\r\nAlso, the `@Slf4j` annotation on L37 of this class should be located below the javadoc.', 'commenter': 'Pil0tXia'}]"
4507,eventmesh-connectors/eventmesh-connector-jdbc/src/main/java/org/apache/eventmesh/connector/jdbc/connection/JdbcConnection.java,"@@ -432,13 +442,11 @@ public <T> T preparedQuery(String sql, ResultSetMapper<T> resultSetMapper, Prepa
      * @throws SQLException if a database access error occurs.
      */
     public <T> T preparedQuery(String sql, PreparedStatementFactory preparedStatementFactory, ResultSetMapper<T> resultSetMapper,
-        PreparedParameter... preparedParameters) throws SQLException {
+                               PreparedParameter... preparedParameters) throws SQLException {
 ","[{'comment': 'Redundant indention here. We rarely use this kind of line break. There are other similar places.', 'commenter': 'Pil0tXia'}]"
4507,eventmesh-connectors/eventmesh-connector-jdbc/src/main/java/org/apache/eventmesh/connector/jdbc/source/dialect/cdc/mysql/MysqlCdcEngine.java,"@@ -96,12 +96,9 @@
 @Slf4j
 public class MysqlCdcEngine extends AbstractCdcEngine<MysqlAntlr4DdlParser, MysqlJdbcContext, MysqlDatabaseDialect> {
 
+    private final EnumMap<EventType, Consumer<Event>> eventHandlers = new EnumMap<>(EventType.class);
     private BinaryLogClient client;
-
     private BlockingQueue<Event> eventQueue = new LinkedBlockingQueue<>(10000);
-
-    private final EnumMap<EventType, Consumer<Event>> eventHandlers = new EnumMap<>(EventType.class);
-
     private Map<Long/* table number */, TableId> tableIdMap = new HashMap<>(64);","[{'comment': 'Field sequence and formating problem. There are other similar places.', 'commenter': 'Pil0tXia'}]"
4507,eventmesh-runtime/src/main/java/org/apache/eventmesh/runtime/util/EventMeshUtil.java,"@@ -295,20 +288,20 @@ public static void printState(final ThreadPoolExecutor scheduledExecutorService)
     @SuppressWarnings(""unchecked"")
     public static <T> T cloneObject(final T object) throws IOException, ClassNotFoundException {
         try (ByteArrayOutputStream byOut = new ByteArrayOutputStream();
-            ObjectOutputStream outputStream = new ObjectOutputStream(byOut)) {
+             ObjectOutputStream outputStream = new ObjectOutputStream(byOut)) {
 
             outputStream.writeObject(object);
 
             try (ByteArrayInputStream byIn = new ByteArrayInputStream(byOut.toByteArray());
-                ObjectInputStream inputStream = new ObjectInputStream(byIn)) {
+                 ObjectInputStream inputStream = new ObjectInputStream(byIn)) {
                 return (T) inputStream.readObject();
             }
         }
 
     }
 
     public static Map<String, Object> getCloudEventExtensionMap(final String protocolVersion,
-        final CloudEvent cloudEvent) {
+                                                                final CloudEvent cloudEvent) {
         final EventMeshCloudEventWriter eventMeshCloudEventWriter = new EventMeshCloudEventWriter();","[{'comment': 'This method signature can be merged into one line.', 'commenter': 'Pil0tXia'}]"
4507,eventmesh-runtime/src/main/java/org/apache/eventmesh/runtime/util/EventMeshUtil.java,"@@ -295,20 +288,20 @@ public static void printState(final ThreadPoolExecutor scheduledExecutorService)
     @SuppressWarnings(""unchecked"")
     public static <T> T cloneObject(final T object) throws IOException, ClassNotFoundException {
         try (ByteArrayOutputStream byOut = new ByteArrayOutputStream();
-            ObjectOutputStream outputStream = new ObjectOutputStream(byOut)) {
+             ObjectOutputStream outputStream = new ObjectOutputStream(byOut)) {
 
             outputStream.writeObject(object);
 
             try (ByteArrayInputStream byIn = new ByteArrayInputStream(byOut.toByteArray());
-                ObjectInputStream inputStream = new ObjectInputStream(byIn)) {
+                 ObjectInputStream inputStream = new ObjectInputStream(byIn)) {
                 return (T) inputStream.readObject();","[{'comment': ""I'm afraid your CheckStyle plugin was misconfigured. Please have a check.\r\n\r\n@yanrongzhen Is it a side effect of Spotless plugin? This contributor once ran `checkStyleMain` gradle task."", 'commenter': 'Pil0tXia'}, {'comment': ""I think it's not a side effect of Spotless, I tried to perform `checkStyleMain`, but failed to reproduce."", 'commenter': 'yanrongzhen'}]"
4507,eventmesh-examples/src/main/java/org/apache/eventmesh/grpc/sub/app/service/SubService.java,"@@ -48,11 +49,15 @@
 @Component
 public class SubService implements InitializingBean {
 
+    private final SubscriptionItem subscriptionItem = new SubscriptionItem();
+    // CountDownLatch size is the same as messageSize in AsyncPublishInstance.java (Publisher)
+    private final CountDownLatch countDownLatch = new CountDownLatch(AsyncPublishInstance.MESSAGE_SIZE);
     private EventMeshGrpcConsumer eventMeshGrpcConsumer;
-
     private Properties properties;
-
-    private final SubscriptionItem subscriptionItem = new SubscriptionItem();
+    private final String localPort = properties.getProperty(SERVER_PORT);
+    private final String url = getURL(localPort, ""/sub/test"");
+    private final String eventMeshIp = properties.getProperty(ExampleConstants.EVENTMESH_IP);
+    private final String eventMeshGrpcPort = properties.getProperty(ExampleConstants.EVENTMESH_GRPC_PORT);
 ","[{'comment': 'Please note that there are many other similar changes that need to be reverted, including two types of problems, ""redundant indention"" and ""field/method sequence and formatting"", as mentioned in my last review.', 'commenter': 'Pil0tXia'}]"
4507,eventmesh-runtime/src/main/java/org/apache/eventmesh/runtime/core/protocol/http/processor/LocalUnSubscribeEventProcessor.java,"@@ -235,12 +229,12 @@ public void handler(final HandlerService.HandlerSpecific handlerSpecific, final
 
     @Override
     public String[] paths() {
-        return new String[]{RequestURI.UNSUBSCRIBE_LOCAL.getRequestURI()};
+        return new String[] {RequestURI.UNSUBSCRIBE_LOCAL.getRequestURI()};
     }
 
     private void registerClient(final HttpEventWrapper requestWrapper,
-        final String consumerGroup,
-        final List<String> topicList, final String url) {
+                                final String consumerGroup,
+                                final List<String> topicList, final String url) {
         Objects.requireNonNull(requestWrapper, ""requestWrapper can not be null"");","[{'comment': 'Redundant indention here. These params can be merged into one line.', 'commenter': 'Pil0tXia'}]"
4507,eventmesh-runtime/src/main/java/org/apache/eventmesh/runtime/core/protocol/http/processor/UnSubscribeProcessor.java,"@@ -226,7 +222,7 @@ public void processRequest(final ChannelHandlerContext ctx, final AsyncContext<H
                         UnSubscribeResponseBody.class);
                     final long endTime = System.currentTimeMillis();
                     log.error(""message|eventMesh2mq|REQ|ASYNC|send2MQCost={}ms""
-                        + ""|topic={}|url={}"", endTime - startTime,
+                            + ""|topic={}|url={}"", endTime - startTime,
                         JsonUtils.toJSONString(unSubscribeRequestBody.getTopics()),
                         unSubscribeRequestBody.getUrl(), e);","[{'comment': '```suggestion\r\nlog.error(""message|eventMesh2mq|REQ|ASYNC|send2MQCost={}ms|topic={}|url={}"", endTime - startTime,\r\n                        JsonUtils.toJSONString(unSubscribeRequestBody.getTopics()), unSubscribeRequestBody.getUrl(), e);\r\n```\r\n\r\nThe same as L201-L204 in this class.', 'commenter': 'Pil0tXia'}]"
4507,eventmesh-runtime/src/main/java/org/apache/eventmesh/runtime/core/protocol/http/push/AsyncHTTPPushRequest.java,"@@ -76,9 +77,8 @@ public class AsyncHTTPPushRequest extends AbstractHTTPPushRequest {
     public static final Logger CMD_LOGGER = LoggerFactory.getLogger(EventMeshConstants.CMD);
 
     public static final Logger LOGGER = LoggerFactory.getLogger(""AsyncHTTPPushRequest"");
-
-    public String currPushUrl;
     private final Map<String, Set<AbstractHTTPPushRequest>> waitingRequests;
+    public String currPushUrl;
 ","[{'comment': 'Field sequence problem here.', 'commenter': 'Pil0tXia'}]"
4507,eventmesh-runtime/src/main/java/org/apache/eventmesh/runtime/core/protocol/tcp/client/group/ClientGroupWrapper.java,"@@ -75,52 +76,33 @@
 public class ClientGroupWrapper {
 
     private final String sysId;
-
-    private String group;
-
-    private EventMeshTCPConfiguration eventMeshTCPConfiguration;
-
     private final EventMeshTCPServer eventMeshTCPServer;
-
-    private TcpRetryer tcpRetryer;
-
-    private EventMeshTcpMonitor eventMeshTcpMonitor;
-
-    private DownstreamDispatchStrategy downstreamDispatchStrategy;
-
     private final ReadWriteLock groupLock = new ReentrantReadWriteLock();","[{'comment': 'Field sequence problem here.', 'commenter': 'Pil0tXia'}]"
4507,eventmesh-runtime/src/main/java/org/apache/eventmesh/runtime/core/protocol/tcp/client/group/ClientGroupWrapper.java,"@@ -249,7 +227,7 @@ public boolean removeSubscription(SubscriptionItem subscriptionItem, Session ses
         String topic = subscriptionItem.getTopic();
         if (session == null
             || !StringUtils.equalsIgnoreCase(group,
-                EventMeshUtil.buildClientGroup(session.getClient().getGroup()))) {
+            EventMeshUtil.buildClientGroup(session.getClient().getGroup()))) {","[{'comment': '```suggestion\r\nif (session == null || !StringUtils.equalsIgnoreCase(group, EventMeshUtil.buildClientGroup(session.getClient().getGroup()))) {\r\n```\r\n\r\nThe same as L333-L335, L365-L367, L395-L397, L427-L429.', 'commenter': 'Pil0tXia'}]"
4507,eventmesh-sdks/eventmesh-sdk-java/src/main/java/org/apache/eventmesh/client/grpc/consumer/EventMeshGrpcConsumer.java,"@@ -64,14 +65,11 @@
 public class EventMeshGrpcConsumer implements AutoCloseable {
 
     private static final String SDK_STREAM_URL = ""grpc_stream"";
-    private ManagedChannel channel;
     private final EventMeshGrpcClientConfig clientConfig;
-
     private final Map<String, SubscriptionInfo> subscriptionMap = new ConcurrentHashMap<>();
-
     private final ScheduledThreadPoolExecutor scheduler = new ScheduledThreadPoolExecutor(Runtime.getRuntime().availableProcessors(),
         new EventMeshThreadFactory(""GRPCClientScheduler"", true));
-
+    private ManagedChannel channel;
     private ConsumerServiceBlockingStub consumerClient;","[{'comment': 'Field sequence problem here.', 'commenter': 'Pil0tXia'}]"
4507,eventmesh-sdks/eventmesh-sdk-java/src/main/java/org/apache/eventmesh/client/grpc/consumer/SubStreamHandler.java,"@@ -47,13 +48,11 @@ public class SubStreamHandler<T> extends Thread implements Serializable {
     private final transient ConsumerServiceStub consumerAsyncClient;
 
     private final transient EventMeshGrpcClientConfig clientConfig;
-
-    private transient StreamObserver<CloudEvent> sender;
-
     private final ReceiveMsgHook<T> listener;
+    private transient StreamObserver<CloudEvent> sender;
 
     public SubStreamHandler(final ConsumerServiceStub consumerAsyncClient, final EventMeshGrpcClientConfig clientConfig,
-        final ReceiveMsgHook<T> listener) {
+                            final ReceiveMsgHook<T> listener) {
         this.consumerAsyncClient = consumerAsyncClient;","[{'comment': 'Redundant indention and field sequence problem here. \r\n\r\n**I will refrain from further annotating similar questions below. You can independently review them on this page:**\r\n\r\n![image](https://github.com/apache/eventmesh/assets/41445332/0ad19437-0597-4923-adf4-d7c26d030ff7)\r\n', 'commenter': 'Pil0tXia'}]"
4507,eventmesh-webhook/eventmesh-webhook-admin/src/main/java/org/apache/eventmesh/webhook/admin/FileWebHookConfigOperation.java,"@@ -59,13 +60,27 @@ public FileWebHookConfigOperation(final Properties properties) throws FileNotFou
         this.webHookFilePath = webHookFilePath;
     }
 
+    public static boolean writeToFile(final File webhookConfigFile, final WebHookConfig webHookConfig) {
+        // Wait for the previous cacheInit to complete in case of concurrency
+        synchronized (SharedLatchHolder.lock) {
+            try (FileOutputStream fos = new FileOutputStream(webhookConfigFile);
+                BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(fos, StandardCharsets.UTF_8))) {
+                // Lock this file to prevent concurrent modification and it will be automatically unlocked when fos closes
+                fos.getChannel().lock();
+                bw.write(Objects.requireNonNull(JsonUtils.toJSONString(webHookConfig)));
+            } catch (IOException e) {
+                LogUtils.error(log, ""write webhookConfig {} to file error"", webHookConfig.getCallbackPath());
+                return false;
+            }
+            return true;
+        }
+    }
+
     @Override","[{'comment': 'Method sequence problem here.', 'commenter': 'Pil0tXia'}]"
4507,eventmesh-runtime/src/main/java/org/apache/eventmesh/runtime/admin/handler/RedirectClientBySubSystemHandler.java,"@@ -127,22 +125,18 @@ public void handle(final HttpExchange httpExchange) throws IOException {
                 }
             } catch (Exception e) {
                 log.error(""clientManage|redirectClientBySubSystem|fail|subSystem={}|destEventMeshIp""
-                    +
-                    ""={}|destEventMeshPort={},errMsg={}"", subSystem, destEventMeshIp, destEventMeshPort, e);
+                    + ""={}|destEventMeshPort={}"", subSystem, destEventMeshIp, destEventMeshPort, e);
 ","[{'comment': 'If you want to remove the last param of a logger, please unify the same logger in other endpoints such as `RedirectClientByPathHandler`.', 'commenter': 'Pil0tXia'}]"
4507,eventmesh-runtime/src/test/java/org/apache/eventmesh/runtime/client/common/RequestContext.java,"@@ -76,9 +77,7 @@ public void finish(Package msg) {
 
     public static RequestContext context(Object key, Package request, CountDownLatch latch) throws Exception {
         RequestContext c = new RequestContext(key, request, latch);
-        if (log.isInfoEnabled()) {
-            log.info(""_RequestContext|create|key="" + key);
-        }
+        LogUtils.info(log, ""_RequestContext|create|key="" + key);","[{'comment': 'How about replace with:\r\n```java\r\n LogUtils.info(log, ""_RequestContext|create|key={}"", key);\r\n```', 'commenter': 'mxsm'}]"
4507,eventmesh-runtime/src/test/java/org/apache/eventmesh/runtime/demo/SyncPubClient.java,"@@ -38,10 +39,8 @@ public static void main(String[] args) throws Exception {
                 Package rr = pubClient.rr(MessageUtils.rrMesssage(""TEST-TOPIC-TCP-SYNC"", i), 3000);
                 if (rr.getBody() instanceof EventMeshMessage) {
                     String body = ((EventMeshMessage) rr.getBody()).getBody();
-                    if (log.isInfoEnabled()) {
-                        log.info(""rrMessage: "" + body + ""             ""
-                            + ""rr-reply-------------------------------------------------"" + rr);
-                    }
+                    LogUtils.info(log, ""rrMessage: "" + body + ""             ""
+                        + ""rr-reply-------------------------------------------------"" + rr);","[{'comment': 'Same as above', 'commenter': 'mxsm'}]"
4507,eventmesh-runtime/src/test/java/org/apache/eventmesh/runtime/demo/BroadCastSubClient.java,"@@ -46,9 +47,7 @@ public void handle(Package msg, ChannelHandlerContext ctx) {
                     if (msg.getHeader().getCommand() == Command.BROADCAST_MESSAGE_TO_CLIENT) {
                         if (msg.getBody() instanceof EventMeshMessage) {
                             String body = ((EventMeshMessage) msg.getBody()).getBody();
-                            if (log.isInfoEnabled()) {
-                                log.info(""receive message -------------------------------"" + body);
-                            }
+                            LogUtils.info(log, ""receive message -------------------------------"" + body);","[{'comment': 'Same as above', 'commenter': 'mxsm'}]"
4507,eventmesh-sdks/eventmesh-sdk-java/src/main/java/org/apache/eventmesh/client/grpc/producer/EventMeshGrpcProducer.java,"@@ -60,9 +61,7 @@ public EventMeshGrpcProducer(EventMeshGrpcClientConfig clientConfig) {
     }
 
     public <T> Response publish(T message) {
-        if (log.isInfoEnabled()) {
-            log.info(""Publish message "" + message.toString());
-        }
+        LogUtils.info(log, ""Publish message "" + message.toString());","[{'comment': 'Same as above', 'commenter': 'mxsm'}]"
4507,eventmesh-runtime/src/test/java/org/apache/eventmesh/runtime/demo/BroadCastSubClient.java,"@@ -46,9 +47,7 @@ public void handle(Package msg, ChannelHandlerContext ctx) {
                     if (msg.getHeader().getCommand() == Command.BROADCAST_MESSAGE_TO_CLIENT) {
                         if (msg.getBody() instanceof EventMeshMessage) {
                             String body = ((EventMeshMessage) msg.getBody()).getBody();
-                            if (log.isInfoEnabled()) {
-                                log.info(""receive message -------------------------------"" + body);
-                            }
+                            LogUtils.info(log, ""receive message -------------------------------"", body);","[{'comment': '``` \r\nLogUtils.info(log, ""receive message -------------------------------{}"", body);\r\n```', 'commenter': 'mxsm'}]"
4507,eventmesh-runtime/src/test/java/org/apache/eventmesh/runtime/demo/SyncPubClient.java,"@@ -38,10 +39,8 @@ public static void main(String[] args) throws Exception {
                 Package rr = pubClient.rr(MessageUtils.rrMesssage(""TEST-TOPIC-TCP-SYNC"", i), 3000);
                 if (rr.getBody() instanceof EventMeshMessage) {
                     String body = ((EventMeshMessage) rr.getBody()).getBody();
-                    if (log.isInfoEnabled()) {
-                        log.info(""rrMessage: "" + body + ""             ""
-                            + ""rr-reply-------------------------------------------------"" + rr);
-                    }
+                    LogUtils.info(log, ""rrMessage: "", body, ""             ""
+                        , ""rr-reply-------------------------------------------------"", rr);","[{'comment': 'Same as above', 'commenter': 'mxsm'}]"
4514,eventmesh-common/build.gradle,"@@ -25,8 +25,8 @@ dependencies {
     api ""org.apache.commons:commons-text""
     api ""org.apache.commons:commons-lang3""
 
-    implementation group: 'com.jayway.jsonpath', name: 'json-path', version: '2.7.0'
-    implementation 'commons-net:commons-net:3.9.0'
+    api ""com.jayway.jsonpath:json-path""
+//    implementation 'commons-net:commons-net:3.9.0'
     api ""io.cloudevents:cloudevents-core""","[{'comment': 'Is the comment here still useful?', 'commenter': 'Pil0tXia'}, {'comment': 'fixed', 'commenter': 'xwm1992'}]"
4514,eventmesh-filter/src/main/java/org/apache/eventmesh/filter/exception/JsonException.java,"@@ -0,0 +1,34 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the ""License""); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.eventmesh.filter.exception;
+
+/**
+ * Json format exception
+ */
+public class JsonException extends RuntimeException {
+","[{'comment': 'We already has a same class at `org.apache.eventmesh.common.exception.JsonException`.', 'commenter': 'Pil0tXia'}, {'comment': 'fixed', 'commenter': 'xwm1992'}]"
4514,settings.gradle,"@@ -23,6 +23,8 @@ include 'eventmesh-common'
 include 'eventmesh-starter'
 include 'eventmesh-examples'
 include 'eventmesh-spi'
+include 'eventmesh-filter'
+include 'eventmesh-transform'","[{'comment': '`filter` is a noun however `transform` is a verb. How about `eventmesh-transformer`?', 'commenter': 'Pil0tXia'}, {'comment': 'fixed', 'commenter': 'xwm1992'}]"
4525,eventmesh-storage-plugin/eventmesh-storage-standalone/src/main/java/org/apache/eventmesh/storage/standalone/broker/model/TopicMetadata.java,"@@ -25,7 +25,8 @@
  */
 public class TopicMetadata implements Serializable {
 
-    private String topicName;
+    private static final long serialVersionUID = -9011507202771676415L;
+    private final String topicName;
 ","[{'comment': 'Better have a newline between these two members to match eventmesh codestyle.', 'commenter': 'Pil0tXia'}]"
4561,eventmesh-connectors/eventmesh-connector-openfunction/src/test/java/org/apache/eventmesh/connector/openfunction/source/connector/OpenFunctionSourceConnectorTest.java,"@@ -0,0 +1,51 @@
+package org.apache.eventmesh.connector.openfunction.source.connector;
+
+import org.apache.eventmesh.connector.openfunction.source.config.OpenFunctionSourceConfig;
+import org.apache.eventmesh.openconnect.offsetmgmt.api.data.ConnectRecord;
+import org.apache.eventmesh.openconnect.offsetmgmt.api.data.RecordOffset;
+import org.apache.eventmesh.openconnect.offsetmgmt.api.data.RecordPartition;
+
+import java.util.List;
+import java.util.concurrent.BlockingQueue;
+
+import org.junit.jupiter.api.Assertions;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.extension.ExtendWith;
+import org.mockito.Spy;
+import org.mockito.junit.jupiter.MockitoExtension;
+
+@ExtendWith(MockitoExtension.class)
+public class OpenFunctionSourceConnectorTest {
+
+    @Spy
+    private OpenFunctionSourceConnector connector;","[{'comment': 'This `@Spy` annotation is redundant, because you completely manually constructed `connector` without simulating it. Because `@Spy` is redundant, `@ExtendWith(MockitoExtension.class)` also becomes redundant.', 'commenter': 'pandaapo'}, {'comment': '@pandaapo I have made the changes as per your previous comment. The only difference is not that with @Spy annotation I didn\'t need to use ""new"" Operator and also removed the dependencies from the build.gradle file', 'commenter': 'VishalMCF'}]"
4561,eventmesh-connectors/eventmesh-connector-openfunction/src/test/java/org/apache/eventmesh/connector/openfunction/source/connector/OpenFunctionSourceConnectorTest.java,"@@ -0,0 +1,45 @@
+package org.apache.eventmesh.connector.openfunction.source.connector;
+
+import org.apache.eventmesh.connector.openfunction.source.config.OpenFunctionSourceConfig;
+import org.apache.eventmesh.openconnect.offsetmgmt.api.data.ConnectRecord;
+import org.apache.eventmesh.openconnect.offsetmgmt.api.data.RecordOffset;
+import org.apache.eventmesh.openconnect.offsetmgmt.api.data.RecordPartition;
+
+import java.util.List;
+import java.util.concurrent.BlockingQueue;
+
+import org.junit.jupiter.api.Assertions;
+import org.junit.jupiter.api.Test;
+
+public class OpenFunctionSourceConnectorTest {
+
+    private final OpenFunctionSourceConnector connector = new OpenFunctionSourceConnector();
+
+    @Test
+    public void testSpringSourceConnector() throws Exception {
+        OpenFunctionSourceConfig sourceConfig = new OpenFunctionSourceConfig();
+        connector.init(sourceConfig);
+        connector.start();
+        final int count = 5;
+        final String message = ""testMessage"";
+        writeMockedRecords(count, message);
+        List<ConnectRecord> connectRecords = connector.poll();
+        Assertions.assertEquals(count, connectRecords.size());
+        for (int i = 0; i < connectRecords.size(); i++) {
+            Object actualMessage = String.valueOf(connectRecords.get(i).getData());
+            String expectedMessage = ""testMessage"" + i;
+            Assertions.assertEquals(expectedMessage, actualMessage);
+        }","[{'comment': 'It is better to call `stop ()` at the last, although it is currently an empty method. Additionally, please fix the checkstyle error prompted by CI.', 'commenter': 'pandaapo'}]"
